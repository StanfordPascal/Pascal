//PASCALNL JOB (PASCAL),'PASCAL LOAD2',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1),
//             USER=PASCALN,PASSWORD=PAS
//*
//********************************************************************
//*
//* LOAD Pascal System from large flat files
//* Part 2 - Sample programs and jobs
//*
//********************************************************************
//*
//LOAD2    EXEC PGM=SPLITMVS
//STEPLIB  DD  DISP=SHR,DSN=PASCALN.TESTPGM.LOAD
//SYSPRINT DD  SYSOUT=A
//OUTPUT   DD  SYSOUT=A,DCB=(RECFM=VB,LRECL=133)
//PASTRACE DD  SYSOUT=A
//********************************************************************
//* assign output files here, choose high level qualifier as you like
//********************************************************************
//OUTF006  DD  DISP=SHR,DSN=PASCALN.TESTPGM.ASM
//OUTF007  DD  DISP=SHR,DSN=PASCALN.TESTPGM.PAS
//OUTF008  DD  DISP=SHR,DSN=PASCALN.TESTPGM.CNTL
//OUTF00B  DD  DISP=SHR,DSN=PASCALN.RUNTIME.MATHTEXT
//SYSUDUMP DD  SYSOUT=A
//QRD      DD  DISP=SHR,DSN=PASCALN.DBGINFO
//********************************************************************
//* instream input file - the complete rest of the job
//* delimiter $* never occurs
//********************************************************************
//INPUT    DD  DATA,DLM='$*'
++FILE PASCALN.TESTPGM.ASM                          MEMB PAS2AF   EXT ASS HEX -
PAS2AF   TITLE 'ASSEMBLER FUNCTION CALLABLE FROM PASCAL'
*
**************************************************************
*        Pascal prototype =
*
*        function PAS_TO_ASM_FUNC ( X1 : INTEGER ;
*                                   X2 : INTEGER ) : INTEGER ;
*
*           EXTERNAL ASSEMBLER 'PAS2AF' ;
**************************************************************
*
PAS2AF   CSECT
         STM   R14,R12,12(R13)
         LR    R11,R15             LOAD BASE REGISTER
         USING PAS2AF,R11
         LA    R15,SAVEAREA
         ST    R15,8(R13)
         ST    R13,4(R15)
         LR    R13,R15
*
**************************************************************
*        fetch parameters
**************************************************************
*
         L     R2,0(R1)            = X1 (by value)
         L     R3,4(R1)            = X2 (by value)
*
**************************************************************
*        work on parameters
**************************************************************
*
         AR    R2,R3
         SRA   R2,1
         LR    R0,R2               function result in R0
*
**************************************************************
*        exit (return to caller)
**************************************************************
*
EXIT     DS    0H
         L     R13,4(R13)
         LM    R14,R15,12(R13)     restore regs
         LM    R1,R12,24(R13)      but omit R0 (function result)
         XR    R15,R15
         BR    R14
         EJECT
*
**************************************************************
*        definitions
**************************************************************
*
         DS    0D
SAVEAREA DS    18F
*
**************************************************************
*        REGISTER ASSIGNMENTS
**************************************************************
*
         REGEQU
*
         END
++FILE PASCALN.TESTPGM.ASM                          MEMB PAS2ASM  EXT ASS HEX -
PAS2ASM  TITLE 'ASSEMBLER SUBROUTINE CALLABLE FROM PASCAL'
*
**************************************************************
*        Pascal prototype =
*
*        procedure PAS2ASM ( X1 : INTEGER ;
*                            var X2 : INTEGER ;
*                            T1 : CHAR20 ;
*                            var T2 : CHAR20 ) ;
*
*           EXTERNAL ASSEMBLER 'PAS2FTN' ;
**************************************************************
*
PAS2ASM  CSECT
         STM   R14,R12,12(R13)
         LR    R11,R15             LOAD BASE REGISTER
         USING PAS2ASM,R11
         LA    R15,SAVEAREA
         ST    R15,8(R13)
         ST    R13,4(R15)
         LR    R13,R15
*
**************************************************************
*        fetch parameters
**************************************************************
*
         L     R2,0(R1)            = X1 (by value)
         L     R3,4(R1)            = ADDR of X2 (by addr)
         LA    R4,8(R1)            = ADDR of T1 (by value)
         L     R5,28(R1)           = ADDR of T2 (by addr)
*
**************************************************************
*        work on parameters
**************************************************************
*
         LA    R6,7
         ST    R6,0(R3)            set X2 to 7
*
         MVC   0(20,R5),=CL20'String from PAS2ASM'   set T2
*
**************************************************************
*        exit (return to caller)
**************************************************************
*
EXIT     DS    0H
         L     R13,4(R13)
         LM    R14,R12,12(R13)
         XR    R15,R15
         BR    R14
         EJECT
*
**************************************************************
*        definitions
**************************************************************
*
         DS    0D
SAVEAREA DS    18F
*
**************************************************************
*        REGISTER ASSIGNMENTS
**************************************************************
*
         REGEQU
*
         END
++FILE PASCALN.TESTPGM.ASM                          MEMB PAS2FF   EXT ASS HEX -
PAS2FF   TITLE 'ASSEMBLER FUNCTION CALLABLE FROM PASCAL'
*
**************************************************************
*        Pascal prototype =
*
*        function PAS_TO_FTN_FUNC ( X1 : INTEGER ;
*                                   X2 : INTEGER ) : INTEGER ;
*
*           EXTERNAL FORTRAN 'PAS2FF' ;
*
*        With FORTRAN, all parameters are passed by reference
*        the compiler generates dummy arguments for every
*        Pascal by-value parameter and passes the addresses
*        of these dummy arguments. The original variables or
*        constants (or results of expressions) will not be
*        touched by the subroutine.
**************************************************************
*
PAS2FF   CSECT
         STM   R14,R12,12(R13)
         LR    R11,R15             LOAD BASE REGISTER
         USING PAS2FF,R11
         LA    R15,SAVEAREA
         ST    R15,8(R13)
         ST    R13,4(R15)
         LR    R13,R15
*
**************************************************************
*        fetch parameters
**************************************************************
*
         L     R2,0(R1)            = X1 (by addr)
         L     R2,0(R2)            = X1 (value)
         L     R3,4(R1)            = X2 (by addr)
         L     R3,0(R3)            = X2 (value)
*
**************************************************************
*        work on parameters
**************************************************************
*
         AR    R2,R3
         SRA   R2,1
         LR    R0,R2               function result in R0
*
**************************************************************
*        exit (return to caller)
**************************************************************
*
EXIT     DS    0H
         L     R13,4(R13)
         LM    R14,R15,12(R13)     restore regs
         LM    R1,R12,24(R13)      but omit R0 (function result)
         XR    R15,R15
         BR    R14
         EJECT
*
**************************************************************
*        definitions
**************************************************************
*
         DS    0D
SAVEAREA DS    18F
*
**************************************************************
*        REGISTER ASSIGNMENTS
**************************************************************
*
         REGEQU
*
         END
++FILE PASCALN.TESTPGM.ASM                          MEMB PAS2FTN  EXT ASS HEX -
PAS2FTN  TITLE 'ASSEMBLER SUBROUTINE CALLABLE FROM PASCAL'
*
**************************************************************
*        Pascal prototype =
*
*        procedure PASCAL_TO_FORTRAN ( X1 : INTEGER ;
*                                      var X2 : INTEGER ;
*                                      T1 : CHAR20 ;
*                                      var T2 : CHAR20 ) ;
*
*           EXTERNAL FORTRAN 'PAS2FTN' ;
*
*        because the subroutine is specified as
*        EXTERNAL FORTRAN, all parameters are passed
*        by reference, and the leftmost bit is set
*        on the last parameter address
**************************************************************
*
PAS2FTN  CSECT
         STM   R14,R12,12(R13)
         LR    R11,R15             LOAD BASE REGISTER
         USING PAS2FTN,R11
         LA    R15,SAVEAREA
         ST    R15,8(R13)
         ST    R13,4(R15)
         LR    R13,R15
*
**************************************************************
*        fetch parameter addresses
**************************************************************
*
         LM    R2,R5,0(R1)
*
**************************************************************
*        work on parameters
**************************************************************
*
         LA    R6,8
         ST    R6,0(R2)            will change dummy arg only
         LA    R6,8
         ST    R6,0(R3)            set X2 to 7
*
         LTR   R5,R5
         BP    R5POS
         MVC   0(20,R5),=CL20'Last Addr. negative'
         B     OK
R5POS    DS    0H
         MVC   0(20,R5),=CL20'Last Addr. positive'
OK       DS    0H
*
**************************************************************
*        exit (return to caller)
**************************************************************
*
EXIT     DS    0H
         L     R13,4(R13)
         LM    R14,R12,12(R13)
         XR    R15,R15
         BR    R14
         EJECT
*
**************************************************************
*        definitions
**************************************************************
*
         DS    0D
SAVEAREA DS    18F
*
**************************************************************
*        REGISTER ASSIGNMENTS
**************************************************************
*
         REGEQU
*
         END
++FILE PASCALN.TESTPGM.PAS                          MEMB AUFBADR  EXT PAS HEX -
program AUFBADR ( EING , AUSG ) ;

(********)
(*$A+   *)
(********)



type CHAR5 = array [ 1 .. 5 ] of CHAR ;
     CHAR30 = array [ 1 .. 30 ] of CHAR ;


var EING : TEXT ;
    AUSG : TEXT ;
    NAME : CHAR30 ;
    STRASSE : CHAR30 ;
    LANDKZ : CHAR ;
    PLZ : CHAR5 ;
    ORT : CHAR30 ;
    NAME2 : CHAR30 ;
    STRASSE2 : CHAR30 ;
    LANDKZ2 : CHAR ;
    PLZ2 : CHAR5 ;
    ORT2 : CHAR30 ;
    SPACE : INTEGER ;


begin (* HAUPTPROGRAMM *)
  RESET ( EING ) ;
  while not EOF ( EING ) do
    begin
      READ ( EING , NAME ) ;
      READ ( EING , STRASSE ) ;
      READ ( EING , LANDKZ ) ;
      READ ( EING , PLZ ) ;
      READ ( EING , ORT ) ;
      READLN ( EING ) ;
      if not EOF ( EING ) then
        begin
          READ ( EING , NAME2 ) ;
          READ ( EING , STRASSE2 ) ;
          READ ( EING , LANDKZ2 ) ;
          READ ( EING , PLZ2 ) ;
          READ ( EING , ORT2 ) ;
          READLN ( EING ) ;
        end (* then *)
      else
        begin
          NAME2 := ' ' ;
          STRASSE2 := ' ' ;
          LANDKZ2 := ' ' ;
          PLZ2 := ' ' ;
          ORT2 := ' ' ;
        end (* else *) ;
      WRITELN ( AUSG , NAME , ' ' : 10 , NAME2 ) ;
      WRITELN ( AUSG , STRASSE , ' ' : 10 , STRASSE2 ) ;
      SPACE := 4 ;
      if LANDKZ <> ' ' then
        begin
          WRITE ( AUSG , LANDKZ , '-' ) ;
          SPACE := SPACE - 2 ;
        end (* then *) ;
      WRITE ( AUSG , PLZ ) ;
      WRITE ( AUSG , ' ' ) ;
      WRITE ( AUSG , ORT ) ;
      WRITE ( AUSG , ' ' : SPACE ) ;
      if LANDKZ2 <> ' ' then
        begin
          WRITE ( AUSG , LANDKZ2 , '-' ) ;
        end (* then *) ;
      WRITE ( AUSG , PLZ2 ) ;
      WRITE ( AUSG , ' ' ) ;
      WRITE ( AUSG , ORT2 ) ;
      WRITELN ( AUSG ) ;
      WRITELN ( AUSG ) ;
      WRITELN ( AUSG ) ;
      WRITELN ( AUSG ) ;
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB AVLTREE  EXT PAS HEX -
module AVLTREE ;

(**************************************************************)
(*                                                            *)
(*   Portierung des AVLTREE Moduls nach Pascal                *)
(*   Soll funktionieren fuer beliebige AVL-Baeume             *)
(*   Key- und Datendefinition kommt "von aussen"              *)
(*                                                            *)
(*   Bernd Oppolzer - 07.2018                                 *)
(*                                                            *)
(**************************************************************)
(*$A+                                                         *)
(**************************************************************)



type PTR_AVLNODE = -> AVLNODE ;
     AVLNODE = record
                 MAGIC : CHAR ( 8 ) ;      // always 'AVLNODEX'
                 PVORG : PTR_AVLNODE ;     // Vorgaenger
                 PLN : PTR_AVLNODE ;       // linker Nachfolger
                 PRN : PTR_AVLNODE ;       // rechter Nachfolger
                 BALANCE : INTEGER ;       // balance lt. Wirth
                 KEY : VOIDPTR ;           // Schluessel
                 KEYLEN : INTEGER ;        // Keylen if deep copy
                 OBJ : VOIDPTR ;           // eigentliche Info
                 OBJLEN : INTEGER ;        // Objlen if deep copy
               end ;
     PTR_AVLLINK = -> AVLLINK ;
     AVLLINK = record                      // only used for avlprint
                 ZEICHNEN : CHAR ;         // storage for character
                 NEXT : PTR_AVLLINK ;      // to print the tree
                 PREV : PTR_AVLLINK ;      // linkage lines
               end ;
     PTR_AVLC = -> AVLC_ENTRY ;
     AVLC_ENTRY = record
                    MAGIC : CHAR ( 8 ) ;   // always 'AVLCACHE'
                    CNAME : CHAR ( 8 ) ;   // Name of Cache
                    COUNT : INTEGER ;      // Nbr of entries
                    PTREE : PTR_AVLNODE ;  // ptr to tree
                  end ;



local function AVLSRCH_INTERN ( SKEY : VOIDPTR ;         // look
                              SKEYLEN : INTEGER ;        // for
                              var POBJ : VOIDPTR ;       // comments
                              var POBJLEN : VOIDPTR ;    // at
                              var GEFUNDEN : BOOLEAN ;   // function
                              var PP : PTR_AVLNODE ;     // AVLSRCH
                              var HCHANGED : BOOLEAN ;   // below
                              EINFUEGEN : BOOLEAN ;      //
                              function AVLCOMP           // look
                              ( X1 : VOIDPTR ;           // for
                              L1 : INTEGER ;             // comments
                              X2 : VOIDPTR ;             // at
                              L2 : INTEGER )             // function
                              : INTEGER )                // AVLSRCH
                              : PTR_AVLNODE ;            // below

(********************************************************************)
(*                                                                  *)
(*   Suchfunktion im AVL-Baum (fuegt auch ein, falls noetig)        *)
(*                                                                  *)
(*   SKEY = Zeiger auf Suchargument fuer Suche und ggf. Einfg.      *)
(*   SKEYLEN = deep copy, wenn skeylen > 0 - dann wird der Key      *)
(*             beim Einfuegen in den AVL-Baum kopiert (ALLOC)       *)
(*             ansonsten wird nur der Pointer gespeichert           *)
(*   POBJ = pointer to OBJ is returned from tree node               *)
(*   POBJLEN = pointer to OBJLEN field is returned from tree node   *)
(*   GEFUNDEN = if true then found, otherwise inserted or NIL ret.  *)
(*   PP = actual AVL-tree, may be changed on return                 *)
(*   HCHANGED = init with false, may change during recursion        *)
(*   EINFUEGEN = set to true, if insert on not found condition      *)
(*   AVLCOMP = Vergleichsfunktion fuer Suchargumente, muss          *)
(*             Werte zurueckgeben wie memcmp (1, -1, 0)             *)
(*                                                                  *)
(*   The AVL tree may be used to record pointers only; in this      *)
(*   case KEYLEN and OBJLEN are zero. Or it may be use to record    *)
(*   the contents as well. In this case, SKEYLEN should be          *)
(*   specified as a positive value. On insert, the key value        *)
(*   is copied into the AVL tree (using ALLOC and MEMCPY),          *)
(*   and on free, the storage is freed.                             *)
(*                                                                  *)
(*   Same goes for POBJ and POBJLEN, but AVLSRCH does not do        *)
(*   anything to the OBJ fields; it simply returns their            *)
(*   addresses and leaves it up to the caller to enter              *)
(*   the values and the length there. When freeing the tree,        *)
(*   the obj values are freed by AVLFREE, if objlen                 *)
(*   contains a nonzero value.                                      *)
(*                                                                  *)
(*   The AVLCOMP function gets the lengths of the two operands      *)
(*   as parameters, but with a pointer-only AVL tree, the           *)
(*   length parameters will be zero, and the AVLCOMP is             *)
(*   supposed to know the length in this case, anyway, and          *)
(*   to do the comparison correctly (maybe constant length).        *)
(*                                                                  *)
(********************************************************************)


   var P1 : PTR_AVLNODE ;
       P2 : PTR_AVLNODE ;
       P : PTR_AVLNODE ;
       PX : PTR_AVLNODE ;
       PRES : PTR_AVLNODE ;
       PVORG_SAVE : PTR_AVLNODE ;

   begin (* AVLSRCH_INTERN *)
     P := PP ;
     if P = NIL then
       begin
         GEFUNDEN := FALSE ;

     /************************************************************/
     /* Der Knoten existiert noch nicht, der gesuchte Schluessel */
     /* wurde also nicht gefunden.                               */
     /************************************************************/

         if EINFUEGEN then
           begin

     /************************************************************/
     /* Es wird ein neuer Knoten mit diesem Schluessel angelegt  */
     /* und in den Baum eingefuegt.                              */
     /************************************************************/

             P := ALLOC ( SIZEOF ( AVLNODE ) ) ;
             with P -> do
               begin
                 MAGIC := 'AVLNODEX' ;
                 PVORG := NIL ;
                 PLN := NIL ;
                 PRN := NIL ;
                 BALANCE := 0 ;
                 KEY := NIL ;
                 KEYLEN := 0 ;
                 OBJ := NIL ;
                 OBJLEN := 0 ;
               end (* with *) ;
             if SKEYLEN > 0 then
               begin

     /************************************************************/
     /* deep copy                                                */
     /************************************************************/

                 P -> . KEY := ALLOC ( SKEYLEN ) ;
                 MEMCPY ( P -> . KEY , SKEY , SKEYLEN ) ;
                 P -> . KEYLEN := SKEYLEN ;
               end (* then *)
             else
               P -> . KEY := SKEY ;
             HCHANGED := TRUE ;
             PRES := P ;
             POBJ := ADDR ( PRES -> . OBJ ) ;
             POBJLEN := ADDR ( PRES -> . OBJLEN ) ;
           end (* then *)
         else
           begin
             PRES := NIL ;
             POBJ := NIL ;
             POBJLEN := NIL ;
           end (* else *) ;
         PP := P ;
         AVLSRCH_INTERN := PRES ;
         return ;
       end (* then *) ;
     if AVLCOMP ( SKEY , SKEYLEN , P -> . KEY , P -> . KEYLEN ) < 0
     then
       begin

     /************************************************************/
     /* Der gesuchte Schluessel ist kleiner als der Schluessel   */
     /* des aktuellen Knotens. Es wird also im linken Teilbaum   */
     /* weitergesucht (rekursiver Aufruf). Nachdem das passiert  */
     /* ist, wird geprueft, ob sich der linke Teilbaum durch ein */
     /* eventuelles Einfuegen verlaengert hat.                   */
     /************************************************************/

         PRES := AVLSRCH_INTERN ( SKEY , SKEYLEN , POBJ , POBJLEN ,
                 GEFUNDEN , P -> . PLN , HCHANGED , EINFUEGEN , AVLCOMP
                 ) ;
         if EINFUEGEN and HCHANGED then
           begin
             PVORG_SAVE := P -> . PVORG ;

     /**************************************************/
     /* Falls der linke Teilbaum laenger geworden ist: */
     /**************************************************/

             case P -> . BALANCE of
               1 : begin

     /********************************************/
     /* bisher war der rechte Teilbaum laenger   */
     /********************************************/

                     P -> . BALANCE := 0 ;
                     HCHANGED := FALSE ;
                   end (* tag/ca *) ;
               0 : begin

     /*********************************************/
     /* bisher waren beide Teilbaeume gleich lang */
     /*********************************************/

                     P -> . BALANCE := - 1 ;
                   end (* tag/ca *) ;
               otherwise
                 begin

     /***************************************************/
     /* Der linke Teilbaum war ohnehin schon laenger.   */
     /* Jetzt muss der Baum umorganisiert werden!       */
     /* Zunaechst wird geprueft, ob beim linken Nach-   */
     /* folger der linke Teilbaum laenger ist (Fall A)  */
     /* oder der rechte (Fall B). Danach werden die     */
     /* Verbindungszeiger neu gesetzt.                  */
     /***************************************************/

                   P1 := P -> . PLN ;
                   if P1 -> . BALANCE = - 1 then
                     begin

     /************************************/
     /* Fall A                           */
     /************************************/

                       PX := P1 -> . PRN ;
                       P -> . PLN := PX ;
                       if PX <> NIL then
                         PX -> . PVORG := P ;
                       P1 -> . PRN := P ;
                       P -> . PVORG := P1 ;
                       P -> . BALANCE := 0 ;
                       P := P1 ;
                     end (* then *)
                   else
                     begin

     /************************************/
     /* Fall B                           */
     /************************************/

                       P2 := P1 -> . PRN ;
                       PX := P2 -> . PLN ;
                       P1 -> . PRN := PX ;
                       if PX <> NIL then
                         PX -> . PVORG := P1 ;
                       P2 -> . PLN := P1 ;
                       P1 -> . PVORG := P2 ;
                       PX := P2 -> . PRN ;
                       P -> . PLN := PX ;
                       if PX <> NIL then
                         PX -> . PVORG := P ;
                       P2 -> . PRN := P ;
                       P -> . PVORG := P2 ;
                       if P2 -> . BALANCE = - 1 then
                         P -> . BALANCE := 1
                       else
                         P -> . BALANCE := 0 ;
                       if P2 -> . BALANCE = 1 then
                         P1 -> . BALANCE := - 1
                       else
                         P1 -> . BALANCE := 0 ;
                       P := P2 ;
                     end (* else *) ;
                   P -> . BALANCE := 0 ;
                   HCHANGED := FALSE ;
                 end (* otherw *)
             end (* case *) ;
             if P -> . PLN <> NIL then
               P -> . PLN -> . PVORG := P ;
             P -> . PVORG := PVORG_SAVE ;
           end (* then *)
       end (* then *)
     else
       if AVLCOMP ( SKEY , SKEYLEN , P -> . KEY , P -> . KEYLEN ) > 0
       then
         begin

     /************************************************************/
     /* Der gesuchte Schluessel ist groesser als der Schluessel  */
     /* des aktuellen Knotens. Es wird also im rechten Teilbaum  */
     /* weitergesucht (rekursiver Aufruf). Nachdem das passiert  */
     /* ist, wird geprueft ob sich der rechte Teilbaum durch ein */
     /* eventuelles Einfuegen verlaengert hat.                   */
     /************************************************************/

           PRES := AVLSRCH_INTERN ( SKEY , SKEYLEN , POBJ , POBJLEN ,
                   GEFUNDEN , P -> . PRN , HCHANGED , EINFUEGEN ,
                   AVLCOMP ) ;
           if EINFUEGEN and HCHANGED then
             begin
               PVORG_SAVE := P -> . PVORG ;

     /***************************************************/
     /* Falls der rechte Teilbaum laenger geworden ist: */
     /***************************************************/

               case P -> . BALANCE of
                 - 1 : begin

     /********************************************/
     /* bisher war der linke Teilbaum laenger    */
     /********************************************/

                         P -> . BALANCE := 0 ;
                         HCHANGED := FALSE ;
                       end (* tag/ca *) ;
                 0 : begin

     /*********************************************/
     /* bisher waren beide Teilbaeume gleich lang */
     /*********************************************/

                       P -> . BALANCE := 1 ;
                     end (* tag/ca *) ;
                 otherwise
                   begin

     /***************************************************/
     /* Der rechte Teilbaum war ohnehin schon laenger.  */
     /* Jetzt muss der Baum umorganisiert werden!       */
     /* Zunaechst wird geprueft, ob beim rechten Nach-  */
     /* folger der rechte Teilbaum laenger ist (Fall A) */
     /* oder der linke (Fall B). Danach werden die      */
     /* Verbindungszeiger neu gesetzt.                  */
     /***************************************************/

                     P1 := P -> . PRN ;
                     if P1 -> . BALANCE = 1 then
                       begin

     /************************************/
     /* Fall A                           */
     /************************************/

                         PX := P1 -> . PLN ;
                         P -> . PRN := PX ;
                         if PX <> NIL then
                           PX -> . PVORG := P ;
                         P1 -> . PLN := P ;
                         P -> . PVORG := P1 ;
                         P -> . BALANCE := 0 ;
                         P := P1 ;
                       end (* then *)
                     else
                       begin

     /************************************/
     /* Fall B                           */
     /************************************/

                         P2 := P1 -> . PLN ;
                         PX := P2 -> . PRN ;
                         P1 -> . PLN := PX ;
                         if PX <> NIL then
                           PX -> . PVORG := P1 ;
                         P2 -> . PRN := P1 ;
                         P1 -> . PVORG := P2 ;
                         PX := P2 -> . PLN ;
                         P -> . PRN := PX ;
                         if PX <> NIL then
                           PX -> . PVORG := P ;
                         P2 -> . PLN := P ;
                         P -> . PVORG := P2 ;
                         if P2 -> . BALANCE = 1 then
                           P -> . BALANCE := - 1
                         else
                           P -> . BALANCE := 0 ;
                         if P2 -> . BALANCE = - 1 then
                           P1 -> . BALANCE := 1
                         else
                           P1 -> . BALANCE := 0 ;
                         P := P2 ;
                       end (* else *) ;
                     P -> . BALANCE := 0 ;
                     HCHANGED := FALSE ;
                   end (* otherw *)
               end (* case *) ;
               if P -> . PRN <> NIL then
                 P -> . PRN -> . PVORG := P ;
               P -> . PVORG := PVORG_SAVE ;
             end (* then *)
         end (* then *)
       else
         begin
           GEFUNDEN := TRUE ;

     /***********************************************************/
     /* Schluessel gefunden, diesen Knoten zurueckgeben         */
     /***********************************************************/

           PRES := P ;
           POBJ := ADDR ( PRES -> . OBJ ) ;
           POBJLEN := ADDR ( PRES -> . OBJLEN ) ;
           if EINFUEGEN then
             HCHANGED := FALSE ;
         end (* else *) ;
     PP := P ;
     AVLSRCH_INTERN := PRES ;
   end (* AVLSRCH_INTERN *) ;



function AVLSRCH ( SKEY : VOIDPTR ;        // ptr to key
                 SKEYLEN : INTEGER ;       // keylen (if deep copy)
                 var POBJ : VOIDPTR ;      // ptr to obj ptr
                 var POBJLEN : VOIDPTR ;   // ptr to objlen field
                 var GEFUNDEN : BOOLEAN ;  // true if found
                 var PP : PTR_AVLNODE ;    // tree pointer
                 var HCHANGED : BOOLEAN ;  // height changed
                 EINFUEGEN : BOOLEAN ;     // if insert then true
                 function AVLCOMP          // passed as parameter:
                 ( X1 : VOIDPTR ;          // compare func for
                 L1 : INTEGER ;            // nodes in avl tree
                 X2 : VOIDPTR ;            // integer return values
                 L2 : INTEGER )            // like memcmp
                 : INTEGER ) : PTR_AVLNODE ;

   begin (* AVLSRCH *)
     if PP <> NIL then
       if PP -> . MAGIC <> 'AVLNODEX' then
         begin
           WRITELN (
              '+++ AVLSRCH: parameter PP invalid (MAGIC field not ok)'
                     ) ;
           EXIT ( 2001 ) ;
         end (* then *) ;
     AVLSRCH := AVLSRCH_INTERN ( SKEY , SKEYLEN , POBJ , POBJLEN ,
                GEFUNDEN , PP , HCHANGED , EINFUEGEN , AVLCOMP ) ;
   end (* AVLSRCH *) ;



function AVLGET ( MODUS : CHAR ;           // mode = F(irst), N(ext)
                START : PTR_AVLNODE ;      // starting position
                var RESULT : PTR_AVLNODE ; // new position
                var PKEY : VOIDPTR ;       // pointer to key
                var KEYLEN : INTEGER ;     // keylen
                var POBJ : VOIDPTR ;       // pointer to obj
                var OBJLEN : INTEGER )     // objlen
                : INTEGER ;                // zero, if OK

(********************************************************************)
(*                                                                  *)
(*   suche nachfolger im baum:                                      *)
(*                                                                  *)
(*   vorwaerts:                                                     *)
(*                                                                  *)
(*   wenn rechter nachfolger da,                                    *)
(*      gehe dorthin, und                                           *)
(*      dann immer linker nachfolger, bis keiner mehr da ist.       *)
(*      fertig                                                      *)
(*                                                                  *)
(*   wenn kein rechter nachfolger da:                               *)
(*      wenn kein vorgaenger da: ende der iteration                 *)
(*      wenn vorgaenger da:                                         *)
(*         ist aktueller knoten linker nachfolger des vorgaengers?  *)
(*         ja: vorgaenger nehmen und fertig.                        *)
(*         nein: weiter mit vorgaenger                              *)
(*                                                                  *)
(*   rueckwaerts:                                                   *)
(*                                                                  *)
(*   wenn linker nachfolger da,                                     *)
(*      gehe dorthin, und                                           *)
(*      dann immer rechter nachfolger, bis keiner mehr da ist.      *)
(*      fertig                                                      *)
(*                                                                  *)
(*   wenn kein linker nachfolger da:                                *)
(*      wenn kein vorgaenger da: ende der iteration                 *)
(*      wenn vorgaenger da:                                         *)
(*         ist aktueller knoten rechter nachfolger des vorgaengers? *)
(*         ja: vorgaenger nehmen und fertig.                        *)
(*         nein: weiter mit vorgaenger                              *)
(*                                                                  *)
(*   erster und letzter ist einfach:                                *)
(*                                                                  *)
(*   nach oben und dann ganz links oder ganz rechts runter          *)
(*                                                                  *)
(*------------------------------------------------------------------*)
(*                                                                  *)
(*   Die folgende Funktion navigiert auf dem Baum;                  *)
(*   dabei kann wie ueblich first, last, next, previous             *)
(*   mitgegeben werden (F,L,N,P).                                   *)
(*                                                                  *)
(*   Fuer start muss irgendein Knoten des Baums mitgegeben          *)
(*   werden (bei F und L geht es am schnellsten mit dem             *)
(*   root-Knoten, aber alle anderen gehen auch). Bei N und P        *)
(*   wird der jeweils naechste bzw. vorhergehende zurueck-          *)
(*   gegeben, ansonsten der erste bzw. letzte ueberhaupt.           *)
(*                                                                  *)
(*------------------------------------------------------------------*)
(*                                                                  *)
(*   erstellt 12.2009 - OPP                                         *)
(*                                                                  *)
(********************************************************************)


   var RES : PTR_AVLNODE ;
       P : PTR_AVLNODE ;
       RC : INTEGER ;
       RESCHECK : PTR_AVLNODE ;
       CHECK_RESULT : BOOLEAN ;

   begin (* AVLGET *)
     RES := NIL ;
     PKEY := NIL ;
     POBJ := NIL ;
     KEYLEN := - 1 ;
     OBJLEN := - 1 ;
     CHECK_RESULT := FALSE ;
     RC := 0 ;
     if START = NIL then
       RC := 2
     else
       if START -> . MAGIC <> 'AVLNODEX' then
         begin
           WRITELN (
            '+++ AVLGET: parameter START invalid (MAGIC field not ok)'
                     ) ;
           EXIT ( 2001 ) ;
         end (* then *) ;
     if RC = 0 then
       begin
         while START -> . PVORG <> NIL do
           START := START -> . PVORG ;
         if MODUS = 'N' then
           begin
             if RESULT = NIL then
               MODUS := 'F'
             else
               CHECK_RESULT := TRUE
           end (* then *) ;
         if MODUS = 'P' then
           begin
             if RESULT = NIL then
               MODUS := 'L'
             else
               CHECK_RESULT := TRUE
           end (* then *)
       end (* then *) ;
     if CHECK_RESULT then
       begin
         if RESULT -> . MAGIC <> 'AVLNODEX' then
           begin
             WRITELN (
           '+++ AVLGET: parameter RESULT invalid (MAGIC field not ok)'
                       ) ;
             EXIT ( 2001 ) ;
           end (* then *) ;
         RESCHECK := RESULT ;
         while RESCHECK -> . PVORG <> NIL do
           RESCHECK := RESCHECK -> . PVORG ;
         if RESCHECK <> START then
           RC := 3
       end (* then *) ;
     case MODUS of
       'F' : if RC = 0 then
               begin
                 while START -> . PLN <> NIL do
                   START := START -> . PLN ;
                 RES := START ;
               end (* then *) ;
       'L' : if RC = 0 then
               begin
                 while START -> . PRN <> NIL do
                   START := START -> . PRN ;
                 RES := START ;
               end (* then *) ;
       'N' : if RC = 0 then
               begin
                 P := RESULT -> . PRN ;
                 if P <> NIL then
                   begin
                     while P -> . PLN <> NIL do
                       P := P -> . PLN ;
                     RES := P ;
                   end (* then *)
                 else
                   begin
                     P := RESULT ;
                     while TRUE do
                       begin
                         if P -> . PVORG = NIL then
                           begin
                             RC := 1 ;
                             break ;
                           end (* then *) ;
                         if P = P -> . PVORG -> . PLN then
                           begin
                             RES := P -> . PVORG ;
                             break ;
                           end (* then *) ;
                         P := P -> . PVORG ;
                       end (* while *)
                   end (* else *)
               end (* then *) ;
       'P' : if RC = 0 then
               begin
                 P := RESULT -> . PLN ;
                 if P <> NIL then
                   begin
                     while P -> . PRN <> NIL do
                       P := P -> . PRN ;
                     RES := P ;
                   end (* then *)
                 else
                   begin
                     P := RESULT ;
                     while TRUE do
                       begin
                         if P -> . PVORG = NIL then
                           begin
                             RC := 1 ;
                             break ;
                           end (* then *) ;
                         if P = P -> . PVORG -> . PRN then
                           begin
                             RES := P -> . PVORG ;
                             break ;
                           end (* then *) ;
                         P := P -> . PVORG ;
                       end (* while *)
                   end (* else *)
               end (* then *) ;
       otherwise
         begin
           RC := - 1 ;
         end (* otherw *)
     end (* case *) ;
     RESULT := RES ;
     if RES <> NIL then
       begin
         PKEY := RES -> . KEY ;
         KEYLEN := RES -> . KEYLEN ;
         POBJ := RES -> . OBJ ;
         OBJLEN := RES -> . OBJLEN ;
       end (* then *) ;
     AVLGET := RC ;
   end (* AVLGET *) ;



procedure AVLPRINT ( P : PTR_AVLNODE ;     // tree to print
                   var AUSGFILE : TEXT ;   // output file
                   EINRUECK : INTEGER ;    // indentation count
                   PV : PTR_AVLLINK ;      // nil on top level call
                   RICHTUNG : CHAR ;       // blank on top level call
                   procedure AVLPKEY       // passed as parameter:
                   ( var F : TEXT ;        // procedure to print
                   P : VOIDPTR ) ) ;       // one key value

(********************************************************************)
(*                                                                  *)
(*   Drucken AVL-Baum                                               *)
(*                                                                  *)
(*   P = Zeiger auf AVL-Baum                                        *)
(*   AUSGFILE = Textfile, auf den gedruckt werden soll              *)
(*   EINRUECK = Anzahl Einrueckzeichen pro Ebene                    *)
(*   AVLPKEY = Prozedur zum Drucken eines Knotens                   *)
(*   PV = Verbindungsinformation, bei Top Level NIL mitgeben        *)
(*   RICHTUNG = Teilbauminfo, bei Top Level Blank mitgeben          *)
(*                                                                  *)
(********************************************************************)


   const SW = '-' ;
         SS = '|' ;

   var I : INTEGER ;
       VN : AVLLINK ;
       PVL : PTR_AVLLINK ;

   static PVFIRST : PTR_AVLLINK ;

   begin (* AVLPRINT *)
     if P <> NIL then
       begin

     /*********************************************/
     /*   Rechten Teilbaum ausgeben. Dazu         */
     /*   Verbindungsstruktur an die              */
     /*   verkettete Liste dranhaengen            */
     /*********************************************/

         if PV <> NIL then
           PV -> . NEXT := ADDR ( VN )
         else
           PVFIRST := ADDR ( VN ) ;
         VN . PREV := PV ;
         VN . ZEICHNEN := 'N' ;
         VN . NEXT := NIL ;
         AVLPRINT ( P -> . PRN , AUSGFILE , EINRUECK , ADDR ( VN ) ,
                    'R' , AVLPKEY ) ;

     /*********************************************************/
     /*   Schreiben der Key-Information und evtl. not-        */
     /*   wendiger Verbindungszeichen                         */
     /*********************************************************/

         if PV <> NIL then
           begin
             WRITE ( AUSGFILE , ' ' : EINRUECK ) ;
             PVL := PVFIRST ;
             while PVL <> PV do
               begin
                 if PVL -> . ZEICHNEN = 'J' then
                   WRITE ( AUSGFILE , SS : EINRUECK )
                 else
                   WRITE ( AUSGFILE , ' ' : EINRUECK ) ;
                 PVL := PVL -> . NEXT
               end (* while *)
           end (* then *) ;

     //************************************************************
     //  if (p -> pvorg <> NIL)
     //     printf ("%05d/", p -> pvorg -> key);
     //  else
     //     printf (" NIL/");
     //************************************************************

         AVLPKEY ( AUSGFILE , P -> . KEY ) ;
         if PV <> NIL then
           if RICHTUNG = 'R' then
             PV -> . ZEICHNEN := 'J'
           else
             PV -> . ZEICHNEN := 'N' ;
         if P -> . PLN <> NIL then
           VN . ZEICHNEN := 'J'
         else
           VN . ZEICHNEN := 'N' ;
         if ( P -> . PRN <> NIL ) or ( P -> . PLN <> NIL ) then
           begin

     /********************************************************/
     /*   Falls es Nachfolge-Knoten gibt, horizontale        */
     /*   Verbindungszeichen ausgeben                        */
     /********************************************************/

             WRITE ( AUSGFILE , ' ' ) ;
             for I := 1 to EINRUECK - 2 do
               WRITE ( AUSGFILE , SW ) ;
             WRITE ( AUSGFILE , SS ) ;
           end (* then *) ;
         WRITELN ( AUSGFILE ) ;

     /*******************************************************/
     /*   Verbindungszeichen ausgeben                       */
     /*******************************************************/

         if FALSE then
           begin
             VN . NEXT := NIL ;
             WRITE ( AUSGFILE , ' ' : EINRUECK ) ;
             PVL := PVFIRST ;
             while PVL <> PV do
               begin
                 if PVL -> . ZEICHNEN = 'J' then
                   WRITE ( AUSGFILE , SS : EINRUECK )
                 else
                   WRITE ( AUSGFILE , ' ' : EINRUECK ) ;
                 PVL := PVL -> . NEXT
               end (* while *) ;
             WRITELN ( AUSGFILE ) ;
           end (* then *) ;

     /*********************************/
     /*   Linken Teilbaum ausgeben    */
     /*********************************/

         AVLPRINT ( P -> . PLN , AUSGFILE , EINRUECK , ADDR ( VN ) ,
                    'L' , AVLPKEY )
       end (* then *)
   end (* AVLPRINT *) ;



procedure AVLFREE ( P : PTR_AVLNODE ) ;

   begin (* AVLFREE *)
     if P <> NIL then
       begin
         AVLFREE ( P -> . PLN ) ;
         AVLFREE ( P -> . PRN ) ;
         if P -> . KEYLEN > 0 then
           if P -> . KEY <> NIL then
             FREE ( P -> . KEY ) ;
         if P -> . OBJLEN > 0 then
           if P -> . OBJ <> NIL then
             FREE ( P -> . OBJ ) ;
         FREE ( P ) ;
       end (* then *)
   end (* AVLFREE *) ;



function AVLCACHE ( FUNKCODE : CHAR ( 8 ) ;   // Funktionscode
                  PHANDLE : VOIDPTR ;         // Cachehandle
                  var SEQKEY : VOIDPTR ;      // seq. Keyposition,
                  var PKEY : VOIDPTR ;        // Zeiger auf Key
                  var LKEY : INTEGER ;        // Laenge Key
                  var PDAT : VOIDPTR ;        // Zeiger auf Daten
                  var LDAT : INTEGER )        // Laenge Daten
                  : INTEGER ;

(********************************************************************)
(*                                                                  *)
(*   Create and manage Cache Areas using AVL-Trees                  *)
(*                                                                  *)
(*   FUNKCODE = function code, see below                            *)
(*   PHANDLE = Cache Handle (once the cache has been created)       *)
(*   SEQKEY = used when processing a cache sequentially             *)
(*   PKEY = pointer to cache key                                    *)
(*   LKEY = length of cache key                                     *)
(*   PDAT = pointer to cache data                                   *)
(*   LDAT = length of cache data                                    *)
(*                                                                  *)
(*   Function CREATE (also used to locate existing cache):          *)
(*                                                                  *)
(*   PKEY points to 8 byte cache name                               *)
(*   LKEY is not used                                               *)
(*                                                                  *)
(*   if successful, PDAT returns cache handle                       *)
(*   LDAT returns 20 (= current sizeof cache handle)                *)
(*   function result is zero, when (empty) cache is created         *)
(*   4, when existing cache has been located,                       *)
(*   other return codes are errors                                  *)
(*                                                                  *)
(*   Function GET:                                                  *)
(*                                                                  *)
(*   PHANDLE: handle for cache (returned by CREATE)                 *)
(*   PKEY / LKEY: identifies key                                    *)
(*   PDAT / LDAT: to return the data, if key found                  *)
(*                                                                  *)
(*   function result is zero, when data is found                    *)
(*   and 8, if data is not found;                                   *)
(*   20, if phandle is NIL or invalid                               *)
(*                                                                  *)
(*   Function PUT:                                                  *)
(*                                                                  *)
(*   PHANDLE: handle for cache (returned by CREATE)                 *)
(*   PKEY / LKEY: identifies key                                    *)
(*   PDAT / LDAT: identifies data                                   *)
(*                                                                  *)
(*   function result is zero, when data is inserted into            *)
(*   cache, and 4, when data is replaced (freed and inserted);      *)
(*   20, if phandle is NIL or invalid                               *)
(*                                                                  *)
(*   Function GFIRST:                                               *)
(*                                                                  *)
(*   PHANDLE: handle for cache (returned by CREATE)                 *)
(*   SEQKEY: stores the cache reading position between calls        *)
(*   PKEY / LKEY: to return the key, if entry found                 *)
(*   PDAT / LDAT: to return the data, if entry found                *)
(*                                                                  *)
(*   function result is zero, when data is found                    *)
(*   and 8, if data is not found (empty cache)                      *)
(*   20, if phandle is NIL or invalid                               *)
(*                                                                  *)
(*   Function GNEXT:                                                *)
(*                                                                  *)
(*   PHANDLE: handle for cache (returned by CREATE)                 *)
(*   SEQKEY: stores the cache reading position between calls        *)
(*   PKEY / LKEY: to return the key, if entry found                 *)
(*   PDAT / LDAT: to return the data, if entry found                *)
(*                                                                  *)
(*   function result is zero, when data is found                    *)
(*   and 8, if data is not found (no next cache entry)              *)
(*   20, if phandle is NIL or invalid                               *)
(*                                                                  *)
(*   note: calling GNEXT with a SEQKEY of NIL is the same           *)
(*   as calling GFIRST                                              *)
(*                                                                  *)
(*   Function TRACE:                                                *)
(*                                                                  *)
(*   PHANDLE: handle for cache (returned by CREATE)                 *)
(*   PKEY: should be NIL or point to an 8 byte cache name           *)
(*   all other parameters have no meaning                           *)
(*                                                                  *)
(*   the cache is printed; the key and data is treated              *)
(*   as characters strings of the stored length                     *)
(*                                                                  *)
(*   function result is zero, when data is found                    *)
(*   and 8, if data is not found (empty cache)                      *)
(*   20, if phandle is NIL or invalid                               *)
(*                                                                  *)
(********************************************************************)


   type PVOIDPTR = -> VOIDPTR ;

   var CMDX : INTEGER ;
       RC : INTEGER ;
       I : INTEGER ;
       PCACHENAME : -> CHAR ( 8 ) ;
       PPAVLC : -> PTR_AVLC ;
       PAVLC : PTR_AVLC ;
       POBJ : PVOIDPTR ;
       POBJLEN : -> INTEGER ;
       PLEN : -> INTEGER ;
       PRES : VOIDPTR ;
       GEFUNDEN : BOOLEAN ;
       HCHANGED : BOOLEAN ;
       PBAUMX : VOIDPTR ;
       RCFOUND : INTEGER ;
       PKEY_LOCAL : VOIDPTR ;
       LKEY_LOCAL : INTEGER ;
       PDAT_LOCAL : VOIDPTR ;
       LDAT_LOCAL : INTEGER ;
       SEQKEY_LOCAL : VOIDPTR ;
       PC254 : -> CHAR ( 254 ) ;

   static PCACHEDIR : VOIDPTR ;

   const COMMAND_COUNT = 8 ;
         COMMANDS : array [ 1 .. COMMAND_COUNT ] of CHAR ( 8 ) =
         ( 'CREATE' , 'GET' , 'PUT' , 'GFIRST' , 'GNEXT' , 'TRACE' ,
           'DELETE' , 'SHOWALL' ) ;


   function DIRCOMP ( X1 : VOIDPTR ; L1 : INTEGER ; X2 : VOIDPTR ; L2 :
                    INTEGER ) : INTEGER ;

   //****************************************************************
   // compare function for AVL tree key values (here: char (8) keys)
   // this function is passed as a parameter to avlsrch
   //****************************************************************


      var S1 : CHAR ( 8 ) ;
          SP1 : -> CHAR ( 8 ) ;
          S2 : CHAR ( 8 ) ;
          SP2 : -> CHAR ( 8 ) ;

      begin (* DIRCOMP *)

        //**********************************************
        // this coding simply to avoid warning message
        // about parameters not used :-)
        //**********************************************

        if FALSE then
          if L1 <> L2 then
            begin
              L1 := 8 ;
              L2 := 8
            end (* then *) ;
        SP1 := X1 ;
        SP2 := X2 ;
        S1 := SP1 -> ;
        S2 := SP2 -> ;
        if S1 > S2 then
          DIRCOMP := 1
        else
          if S1 < S2 then
            DIRCOMP := - 1
          else
            DIRCOMP := 0 ;
      end (* DIRCOMP *) ;


   function CACHECOMP ( X1 : VOIDPTR ; L1 : INTEGER ; X2 : VOIDPTR ; L2
                      : INTEGER ) : INTEGER ;

   //****************************************************************
   // compare function for AVL tree key values
   // here: arbitrary structures of varying length
   // this function is passed as a parameter to avlsrch
   //****************************************************************


      begin (* CACHECOMP *)
        if L1 > L2 then
          CACHECOMP := 1
        else
          if L1 < L2 then
            CACHECOMP := - 1
          else
            CACHECOMP := MEMCMP ( X1 , X2 , L1 ) ;
      end (* CACHECOMP *) ;


   begin (* AVLCACHE *)
     CMDX := 0 ;
     for I := 1 to COMMAND_COUNT do
       if FUNKCODE = COMMANDS [ I ] then
         begin
           CMDX := I ;
           break
         end (* then *) ;
     case CMDX of
       1 : begin  // CREATE (or LOCATE)
             PDAT := NIL ;
             LDAT := 0 ;
             PCACHENAME := PKEY ;
             HCHANGED := FALSE ;
             PRES := AVLSRCH ( PCACHENAME , 8 , PPAVLC , PLEN ,
                     GEFUNDEN , PCACHEDIR , HCHANGED , TRUE , DIRCOMP )
                     ;
             if PRES = NIL then
               RC := 12
             else
               begin
                 if GEFUNDEN then
                   begin
                     PAVLC := PPAVLC -> ;
                     RC := 4
                   end (* then *)
                 else
                   begin
                     RC := 0 ;
                     PPAVLC -> := ALLOC ( SIZEOF ( AVLC_ENTRY ) ) ;
                     PAVLC := PPAVLC -> ;
                     with PAVLC -> do
                       begin
                         MAGIC := 'AVLCACHE' ;
                         CNAME := PCACHENAME -> ;
                         COUNT := 0 ;
                         PTREE := NIL ;
                       end (* with *) ;
                     PLEN -> := SIZEOF ( AVLC_ENTRY ) ;
                   end (* else *) ;
                 PDAT := PAVLC ;
                 LDAT := PLEN -> ;
               end (* else *)
           end (* tag/ca *) ;
       2 : begin
             repeat  // GET - one time loop
               PAVLC := PHANDLE ;

     //************************************************************
     // check handle and return if handle nok
     //************************************************************

               if PAVLC = NIL then
                 begin
                   RC := 20 ;
                   break
                 end (* then *) ;
               if PAVLC -> . MAGIC <> 'AVLCACHE' then
                 begin
                   RC := 20 ;
                   break
                 end (* then *) ;

     //************************************************************
     // search for key and return data if found
     //************************************************************

               PBAUMX := PAVLC -> . PTREE ;
               HCHANGED := FALSE ;
               PRES := AVLSRCH ( PKEY , LKEY , POBJ , POBJLEN ,
                       GEFUNDEN , PBAUMX , HCHANGED , FALSE , CACHECOMP
                       ) ;
               if not GEFUNDEN then
                 begin
                   PDAT := NIL ;
                   LDAT := 0 ;
                   RC := 8 ;
                 end (* then *)
               else
                 begin
                   PDAT := POBJ -> ;
                   LDAT := POBJLEN -> ;
                   RC := 0 ;
                 end (* else *)
             until TRUE
           end (* tag/ca *) ;
       3 : begin
             repeat  // PUT - one time loop
               PAVLC := PHANDLE ;

     //************************************************************
     // check handle and return if handle nok
     //************************************************************

               if PAVLC = NIL then
                 begin
                   RC := 20 ;
                   break
                 end (* then *) ;
               if PAVLC -> . MAGIC <> 'AVLCACHE' then
                 begin
                   RC := 20 ;
                   break
                 end (* then *) ;

     //************************************************************
     // search for key and insert if notfound
     //************************************************************

               PBAUMX := PAVLC -> . PTREE ;
               HCHANGED := FALSE ;
               PRES := AVLSRCH ( PKEY , LKEY , POBJ , POBJLEN ,
                       GEFUNDEN , PBAUMX , HCHANGED , TRUE , CACHECOMP
                       ) ;
               if not GEFUNDEN then
                 begin

     //************************************************************
     // insert data if notfound
     //************************************************************

                   PAVLC -> . COUNT := PAVLC -> . COUNT + 1 ;
                   POBJ -> := ALLOC ( LDAT ) ;
                   POBJLEN -> := LDAT ;
                   MEMCPY ( POBJ -> , PDAT , LDAT ) ;
                   PAVLC -> . PTREE := PBAUMX ;
                   RC := 0 ;
                 end (* then *)
               else
                 begin

     //************************************************************
     // replace data if notfound
     //************************************************************

                   FREE ( POBJ -> ) ;
                   POBJ -> := ALLOC ( LDAT ) ;
                   POBJLEN -> := LDAT ;
                   MEMCPY ( POBJ -> , PDAT , LDAT ) ;
                   RC := 4 ;
                 end (* else *)
             until TRUE
           end (* tag/ca *) ;
       4 : begin
             repeat  // GFIRST - one time loop
               PAVLC := PHANDLE ;

     //************************************************************
     // check handle and return if handle nok
     //************************************************************

               if PAVLC = NIL then
                 begin
                   RC := 20 ;
                   break
                 end (* then *) ;
               if PAVLC -> . MAGIC <> 'AVLCACHE' then
                 begin
                   RC := 20 ;
                   break
                 end (* then *) ;

     //************************************************************
     // search for first key using AVLGET / F
     //************************************************************

               PBAUMX := PAVLC -> . PTREE ;
               RCFOUND := AVLGET ( 'F' , PBAUMX , SEQKEY , PKEY , LKEY
                          , PDAT , LDAT ) ;
               if RCFOUND <> 0 then
                 begin
                   PKEY := NIL ;
                   LKEY := 0 ;
                   PDAT := NIL ;
                   LDAT := 0 ;
                   RC := 8 ;
                 end (* then *)
               else
                 begin
                   RC := 0 ;
                 end (* else *)
             until TRUE
           end (* tag/ca *) ;
       5 : begin
             repeat  // GNEXT - one time loop
               PAVLC := PHANDLE ;

     //************************************************************
     // check handle and return if handle nok
     //************************************************************

               if PAVLC = NIL then
                 begin
                   RC := 20 ;
                   break
                 end (* then *) ;
               if PAVLC -> . MAGIC <> 'AVLCACHE' then
                 begin
                   RC := 20 ;
                   break
                 end (* then *) ;

     //************************************************************
     // search for next key using AVLGET / N
     //************************************************************

               PBAUMX := PAVLC -> . PTREE ;
               RCFOUND := AVLGET ( 'N' , PBAUMX , SEQKEY , PKEY , LKEY
                          , PDAT , LDAT ) ;
               if RCFOUND <> 0 then
                 begin
                   PKEY := NIL ;
                   LKEY := 0 ;
                   PDAT := NIL ;
                   LDAT := 0 ;
                   RC := 8 ;
                 end (* then *)
               else
                 begin
                   RC := 0 ;
                 end (* else *)
             until TRUE
           end (* tag/ca *) ;
       6 : begin
             repeat  // TRACE - one time loop
               PAVLC := PHANDLE ;

     //************************************************************
     // check handle and return if handle nok
     //************************************************************

               if PAVLC = NIL then
                 begin
                   RC := 20 ;
                   break
                 end (* then *) ;
               if PAVLC -> . MAGIC <> 'AVLCACHE' then
                 begin
                   RC := 20 ;
                   break
                 end (* then *) ;

     //************************************************************
     // output the whole cache using AVLGET
     //************************************************************

               WRITELN ;
               PC254 := PKEY ;
               if PC254 <> NIL then
                 WRITELN ( 'Print CACHE - Cachename = ' , SUBSTR (
                           PC254 -> , 1 , 8 ) )
               else
                 WRITELN ( 'Print CACHE - Cachename = *unknown*' ) ;
               WRITELN ( 'Number of entries = ' , PAVLC -> . COUNT : 1
                         ) ;
               WRITELN ( '----------------------------------------' ) ;
               RC := 8 ;
               SEQKEY_LOCAL := NIL ;
               PBAUMX := PAVLC -> . PTREE ;
               while TRUE do
                 begin
                   RCFOUND := AVLGET ( 'N' , PBAUMX , SEQKEY_LOCAL ,
                              PKEY_LOCAL , LKEY_LOCAL , PDAT_LOCAL ,
                              LDAT_LOCAL ) ;
                   if RCFOUND <> 0 then
                     break ;
                   WRITELN ;
                   PC254 := PKEY_LOCAL ;
                   WRITELN ( 'key: ' , SUBSTR ( PC254 -> , 1 ,
                             LKEY_LOCAL ) ) ;
                   PC254 := PDAT_LOCAL ;
                   WRITELN ( 'dat: ' , SUBSTR ( PC254 -> , 1 ,
                             LDAT_LOCAL ) ) ;
                   RC := 0 ;
                 end (* while *) ;
               WRITELN ;
             until TRUE
           end (* tag/ca *) ;
       7 : begin

           end (* tag/ca *) ;
       8 : begin

           end (* tag/ca *) ;
       otherwise
         begin

         end (* otherw *)
     end (* case *) ;
     AVLCACHE := RC ;
   end (* AVLCACHE *) ;



begin (* HAUPTPROGRAMM *)

end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB COPYREAL EXT PAS HEX -
program COPYREAL ( F , G ) ;


var F , G : FILE of REAL ;
    X : REAL ;


begin (* HAUPTPROGRAMM *)
  REWRITE ( F ) ;
  X := 1.0 ;
  while X <= 10.0 do
    begin

  /*********************/
  /* WRITE ( F , X ) ; */
  /*********************/

      PUT ( F ) ;
      F -> := X ;
      X := X + 0.5 ;
    end (* while *) ;
  RESET ( F ) ;
  REWRITE ( G ) ;
  while not EOF ( F ) do
    begin
      G -> := F -> ;
      GET ( F ) ;
      PUT ( G )
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB COPYTEIL EXT PAS HEX -
program COPYTEIL ( INPFILE , OUTFILE ) ;

//************************************************
// Programm kopiert Binaerdateien
// verwendet CSP RDD
//************************************************
// war in PCINT noch nicht implementiert (11.2019)
// CSP RDD verwendet fread, fuellt allerdings
// am Ende zu kurzen Buffer mit Hex Nullen auf
// dadurch wird Zieldatei immer auf 1024 ohne
// Rest teilbare Laenge verlaengert
//************************************************
// eof erst, wenn fread Ergebnis 0 bringt.
//************************************************
// Abhilfe: spaeter Funktion schreiben, die
// tatsaechliche gelesene Laenge der Lesefunktion
// abfragbar macht (Ergebnis von fread).
// Das kann im letzten fread weniger als die
// angeforderte Satzlaenge sein.
//************************************************



const BUFSIZE = 1024 ;


type BUFFER = CHAR ( BUFSIZE ) ;


var INPFILE : FILE of BUFFER ;
    OUTFILE : FILE of BUFFER ;
    X : BUFFER ;
    SATZZAHL : INTEGER ;


begin (* HAUPTPROGRAMM *)
  RESET ( INPFILE ) ;
  REWRITE ( OUTFILE ) ;
  SATZZAHL := 0 ;
  while not EOF ( INPFILE ) do
    begin
      READ ( INPFILE , X ) ;
      WRITE ( OUTFILE , X ) ;
      SATZZAHL := SATZZAHL + 1 ;
      if SATZZAHL MOD 100000 = 0 then
        WRITELN ( SATZZAHL , ' Buffer ausgegeben' ) ;
    end (* while *) ;
  WRITELN ( SATZZAHL , ' Buffer ausgegeben' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB COPYTEXT EXT PAS HEX -
program COPYTEXT ( INPUT , OUTPUT ) ;

(**********************************************)
(*   This program copies the characters       *)
(*   and line structure of the textfile       *)
(*   input to the textfile output.            *)
(**********************************************)



var CH : CHAR ;


begin (* HAUPTPROGRAMM *)
  RESET ( INPUT ) ;
  REWRITE ( OUTPUT ) ;
  while not EOF do
    begin
      while not EOLN do
        begin
          READ ( CH ) ;
          WRITE ( CH )
        end (* while *) ;
      READLN ;
      WRITELN
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB DECOD    EXT PAS HEX -
program DECOD ( INPUT , OUTPUT ) ;


var I : INTEGER ;
    C1 : CHAR ;
    C2 : CHAR ;
    CH : CHAR ;
    HEX : packed array [ 0 .. 15 ] of CHAR ;


begin (* HAUPTPROGRAMM *)
  RESET ( INPUT ) ;
  HEX := '0123456789ABCDEF' ;
  I := 0 ;
  while not ( EOF ( INPUT ) ) do
    begin
      READ ( INPUT , CH ) ;
      C1 := HEX [ ORD ( CH ) DIV 16 ] ;
      C2 := HEX [ ORD ( CH ) MOD 16 ] ;
      WRITE ( OUTPUT , C1 , C2 ) ;
      I := I + 2 ;
      if ( EOLN ( INPUT ) ) then
        begin
          WRITELN ( OUTPUT , '#' ) ;
          I := 0 ;
          READ ( INPUT , CH ) ;

  (******************************)
  (* BLANK NACH EOLN UEBERLESEN *)
  (******************************)

        end (* then *) ;
      if I >= 60 then
        begin
          WRITELN ( OUTPUT ) ;
          I := 0 ;
        end (* then *) ;
    end (* while *) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB DOWNLOAD EXT PAS HEX -
program DOWNLOAD ( CONTROL , OUTPUT , PDS001 , PDS002 , PDS003 , PDS004
                   , PDS005 , PDS006 , PDS007 , PDS008 , PDS009 ,
                   PDS00A , PDS00B , PDS00C , PDS00D , PDS00E , PDS00F
                   ) ;

(***********************************************************)
(*                                                         *)
(*   This program copies many pds members into one         *)
(*   large file, which is the base of the distribution     *)
(*   of the Stanford Pascal compiler - MVS edition         *)
(*                                                         *)
(*   Most files are text files, but some are binary;       *)
(*   the binary files are hex encoded, so that this        *)
(*   transfer file is a pure text file.                    *)
(*                                                         *)
(*   It contains all the needed meta information, so       *)
(*   that on Windows etc. the files can be extracted       *)
(*   and distributed to certain directories. On the        *)
(*   target mainframes, the original members can be        *)
(*   restored                                              *)
(*                                                         *)
(***********************************************************)
(*                                                         *)
(*   Author: Bernd Oppolzer - May 2017                     *)
(*                                                         *)
(***********************************************************)
(*                                                         *)
(*   The input file CONTROL tells the member names         *)
(*   of the input files                                    *)
(*                                                         *)
(*   Syntax example:                                       *)
(*                                                         *)
(*   8 PASCALN.COMPILER.TEXT        PASCAL1    OBJ    H    *)
(*                                                         *)
(*   8 - number of input file (PDS008 in this case)        *)
(*   2nd parm - DSNAME, which is written to the transfer   *)
(*              file; take care, that this name matches    *)
(*              the allocation of the file number !!       *)
(*   3rd parm - member name, which is read from the        *)
(*              input file (PDS008 in this case)           *)
(*   4th parm - file type for target system (e.g. Win)     *)
(*   5th parm - H if hex encoding needed, otherwise        *)
(*              omit this parameter                        *)
(*                                                         *)
(*   further example:                                      *)
(*                                                         *)
(*   7 PASCALN.TESTPGM.CNTL         TESTSCAL   JOB         *)
(*   7 PASCALN.TESTPGM.CNTL         TESTSTAT   JOB         *)
(*   7 PASCALN.TESTPGM.CNTL         XCOMP      JOB         *)
(*   **************************************************    *)
(*   8 PASCALN.COMPILER.TEXT        PASCAL1    OBJ    H    *)
(*   8 PASCALN.COMPILER.TEXT        PASCAL2    OBJ    H    *)
(*                                                         *)
(***********************************************************)



const SIZEDSN = 44 ;
      SIZEMEM = 8 ;
      SIZEEXT = 3 ;
      MAXLINEOFFS = 72 ;
      MAXOUT = 100 ;


type CHARPTR = -> CHAR ;


var CONTROL : TEXT ;
    PDS001 : TEXT ;
    PDS002 : TEXT ;
    PDS003 : TEXT ;
    PDS004 : TEXT ;
    PDS005 : TEXT ;
    PDS006 : TEXT ;
    PDS007 : TEXT ;
    PDS008 : TEXT ;
    PDS009 : TEXT ;
    PDS00A : TEXT ;
    PDS00B : TEXT ;
    PDS00C : TEXT ;
    PDS00D : TEXT ;
    PDS00E : TEXT ;
    PDS00F : TEXT ;
    LINEBUF : array [ 1 .. 80 ] of CHAR ;
    X : INTEGER ;
    XFOUND : INTEGER ;
    FILENO : CHAR ;
    PDSN : CHARPTR ;
    PMEM : CHARPTR ;
    PEXT : CHARPTR ;
    PEND : CHARPTR ;
    LEN : INTEGER ;
    DSN : array [ 1 .. SIZEDSN ] of CHAR ;
    MEM : array [ 1 .. SIZEMEM ] of CHAR ;
    EXT : array [ 1 .. SIZEEXT ] of CHAR ;
    HEXFLAG : CHAR ;



procedure WRITEHEX ( C : CHAR ) ;

   var C1 : CHAR ;
       C2 : CHAR ;

   const HEX : array [ 0 .. 15 ] of CHAR = '0123456789ABCDEF' ;

   begin (* WRITEHEX *)
     C1 := HEX [ ORD ( C ) DIV 16 ] ;
     C2 := HEX [ ORD ( C ) MOD 16 ] ;
     WRITE ( C1 , C2 ) ;
   end (* WRITEHEX *) ;



procedure COPYLINE ( var F : TEXT ; HEXFLAG : CHAR ) ;

(*********************************************)
(*   read line into large buffer             *)
(*   store length and line info              *)
(*   into transfer file                      *)
(*   convert to hex if required              *)
(*********************************************)


   var LINEBUF : array [ 1 .. 1000 ] of CHAR ;
       I : INTEGER ;
       CNT : INTEGER ;
       CH : CHAR ;
       START : INTEGER ;
       TAG : CHAR ;
       CNTOUT : INTEGER ;

   begin (* COPYLINE *)
     I := 0 ;

     /*********************************************/
     /*   read line and remember char cnt         */
     /*********************************************/

     while TRUE do
       begin
         READ ( F , CH ) ;
         I := I + 1 ;
         LINEBUF [ I ] := CH ;
         if EOLN ( F ) then
           break ;
       end (* while *) ;
     READLN ( F ) ;
     CNT := I ;

     /*********************************************/
     /*   write line, max 100 chars (maxout)      */
     /*   per output line                         */
     /*   format:                                 */
     /*   - DATAx (x = seqno of line part)        */
     /*   - complete line length                  */
     /*   - offset of line part                   */
     /*   - line part content (char or hex)       */
     /*********************************************/

     if HEXFLAG = 'H' then
       begin
         CNTOUT := 30 ;
         START := 1 ;
         TAG := '1' ;
         while TRUE do
           begin
             WRITE ( '++DATA' , TAG , CNT : 5 , START - 1 : 5 , ' ' ) ;
             for I := START to START + CNTOUT - 1 do
               if I <= CNT then
                 WRITEHEX ( LINEBUF [ I ] )
               else
                 break ;
             WRITELN ;
             START := START + CNTOUT ;
             if START > CNT then
               break ;
             TAG := CHR ( ORD ( TAG ) + 1 ) ;
           end (* while *) ;
       end (* then *)
     else
       begin
         for I := 1 to CNT do
           WRITE ( LINEBUF [ I ] ) ;
         WRITELN
       end (* else *)
   end (* COPYLINE *) ;



procedure WRITE_FILE ( var F : TEXT ; PDSN : CHARPTR ; PMEMB : CHARPTR
                     ; PEXT : CHARPTR ; HEXFLAG : CHAR ) ;

   var P : VOIDPTR ;
       CP : -> CHAR ;
       DSNAME : array [ 1 .. SIZEDSN ] of CHAR ;
       MEMBNAME : array [ 1 .. SIZEMEM ] of CHAR ;
       EXT : array [ 1 .. SIZEEXT ] of CHAR ;

   begin (* WRITE_FILE *)
     MEMCPY ( ADDR ( DSNAME ) , PDSN , SIZEDSN ) ;
     MEMCPY ( ADDR ( MEMBNAME ) , PMEMB , SIZEMEM ) ;
     MEMCPY ( ADDR ( EXT ) , PEXT , SIZEEXT ) ;

     /*********************************************/
     /*   assign member name to input file        */
     /*********************************************/

     ASSIGNMEM ( F , ADDR ( MEMBNAME ) , SIZEMEM ) ;

     /*********************************************/
     /*   try reset and check success             */
     /*********************************************/

     RESET ( F ) ;
     P := FILEFCB ( F ) ;
     CP := PTRADD ( P , 32 ) ;
     if CP -> = '0' then
       return ;

     /*********************************************/
     /*   write header info into transfer file    */
     /*********************************************/

     WRITELN ( '++FILE ' , DSNAME , ' MEMB ' , MEMBNAME , ' EXT ' , EXT
               , ' HEX ' , HEXFLAG ) ;

     /*********************************************/
     /*   copy lines until eof of input member    */
     /*********************************************/

     while not EOF ( F ) do
       begin
         COPYLINE ( F , HEXFLAG ) ;
       end (* while *) ;

     /*********************************************/
     /*   close input file (must be closed        */
     /*   before new assignmem)                   */
     /*********************************************/

     CLOSE ( F ) ;
   end (* WRITE_FILE *) ;



begin (* HAUPTPROGRAMM *)
  RESET ( CONTROL ) ;
  while not EOF ( CONTROL ) do
    begin

  /*********************************************/
  /*   read line from control file             */
  /*********************************************/

      READLN ( CONTROL , LINEBUF ) ;
      if LINEBUF [ 1 ] = '*' then
        continue ;

  /*********************************************/
  /*   no comment line, look for file no       */
  /*********************************************/

      XFOUND := 0 ;
      for X := 1 to 80 do
        if LINEBUF [ X ] <> ' ' then
          begin
            XFOUND := X ;
            break
          end (* then *) ;
      if XFOUND = 0 then
        continue ;
      FILENO := LINEBUF [ XFOUND ] ;

  /*********************************************/
  /*   extract ds name from linebuf            */
  /*********************************************/

      X := XFOUND + 1 ;
      while ( X < MAXLINEOFFS ) and ( LINEBUF [ X ] = ' ' ) do
        X := X + 1 ;
      PDSN := ADDR ( LINEBUF [ X ] ) ;
      while ( X < MAXLINEOFFS ) and ( LINEBUF [ X ] <> ' ' ) do
        X := X + 1 ;
      PEND := ADDR ( LINEBUF [ X ] ) ;
      LEN := PTRDIFF ( PEND , PDSN ) ;
      if LEN > SIZEDSN then
        LEN := SIZEDSN ;
      DSN := ' ' ;
      MEMCPY ( ADDR ( DSN ) , PDSN , LEN ) ;

  /*********************************************/
  /*   extract member name from linebuf        */
  /*********************************************/

      while ( X < MAXLINEOFFS ) and ( LINEBUF [ X ] = ' ' ) do
        X := X + 1 ;
      PMEM := ADDR ( LINEBUF [ X ] ) ;
      while ( X < MAXLINEOFFS ) and ( LINEBUF [ X ] <> ' ' ) do
        X := X + 1 ;
      PEND := ADDR ( LINEBUF [ X ] ) ;
      LEN := PTRDIFF ( PEND , PMEM ) ;
      if LEN > SIZEMEM then
        LEN := SIZEMEM ;
      MEM := ' ' ;
      MEMCPY ( ADDR ( MEM ) , PMEM , LEN ) ;

  /*********************************************/
  /*   extract extension name from linebuf     */
  /*********************************************/

      while ( X < MAXLINEOFFS ) and ( LINEBUF [ X ] = ' ' ) do
        X := X + 1 ;
      PEXT := ADDR ( LINEBUF [ X ] ) ;
      while ( X < MAXLINEOFFS ) and ( LINEBUF [ X ] <> ' ' ) do
        X := X + 1 ;
      PEND := ADDR ( LINEBUF [ X ] ) ;
      LEN := PTRDIFF ( PEND , PEXT ) ;
      if LEN > SIZEEXT then
        LEN := SIZEEXT ;
      EXT := ' ' ;
      MEMCPY ( ADDR ( EXT ) , PEXT , LEN ) ;

  /*********************************************/
  /*   look for hex flag                       */
  /*********************************************/

      while ( X < MAXLINEOFFS ) and ( LINEBUF [ X ] = ' ' ) do
        X := X + 1 ;
      HEXFLAG := LINEBUF [ X ] ;
      if HEXFLAG <> 'H' then
        HEXFLAG := '-' ;

  /**************************************************/
  /*   call write function depending on fileno      */
  /**************************************************/

      case FILENO of
        '1' : WRITE_FILE ( PDS001 , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        '2' : WRITE_FILE ( PDS002 , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        '3' : WRITE_FILE ( PDS003 , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        '4' : WRITE_FILE ( PDS004 , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        '5' : WRITE_FILE ( PDS005 , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        '6' : WRITE_FILE ( PDS006 , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        '7' : WRITE_FILE ( PDS007 , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        '8' : WRITE_FILE ( PDS008 , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        '9' : WRITE_FILE ( PDS009 , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        'A' : WRITE_FILE ( PDS00A , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        'B' : WRITE_FILE ( PDS00B , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        'C' : WRITE_FILE ( PDS00C , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        'D' : WRITE_FILE ( PDS00D , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        'E' : WRITE_FILE ( PDS00E , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
        'F' : WRITE_FILE ( PDS00F , ADDR ( DSN ) , ADDR ( MEM ) , ADDR
                           ( EXT ) , HEXFLAG ) ;
      end (* case *) ;
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB ENCOD    EXT PAS HEX -
program ENCOD ( INPUT , OUTPUT ) ;


var I : INTEGER ;
    CH : CHAR ;
    I2 : INTEGER ;
    NL : BOOLEAN ;


begin (* HAUPTPROGRAMM *)
  NL := FALSE ;
  while not ( EOF ( INPUT ) ) do
    begin
      READ ( INPUT , CH ) ;
      if ( CH >= '0' ) and ( CH <= '9' ) then
        I := ORD ( CH ) - ORD ( '0' )
      else
        if ( CH >= 'A' ) and ( CH <= 'F' ) then
          I := ORD ( CH ) - ORD ( 'A' ) + 10
        else
          if CH = '#' then
            begin
              I := - 1 ;
              NL := TRUE
            end (* then *)
          else
            I := - 1 ;
      if I >= 0 then
        begin
          READ ( INPUT , CH ) ;
          if ( CH >= '0' ) and ( CH <= '9' ) then
            I2 := ORD ( CH ) - ORD ( '0' )
          else
            if ( CH >= 'A' ) and ( CH <= 'F' ) then
              I2 := ORD ( CH ) - ORD ( 'A' ) + 10 ;
          if NL then
            begin
              WRITELN ( OUTPUT ) ;
              NL := FALSE
            end (* then *) ;
          WRITE ( OUTPUT , CHR ( I * 16 + I2 ) ) ;
        end (* then *)
    end (* while *) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB FIB1982  EXT PAS HEX -
program FIBOK ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



type POS_INT = 0 .. 30 ;


var I : POS_INT ;
    TIME : INTEGER ;



function FIBONACCI ( J : POS_INT ) : INTEGER ;

(******************************)
(* to evaluate fibonacci # j, *)
(* for j >= 0                 *)
(* subject to int overflow    *)
(******************************)


   begin (* FIBONACCI *)
     if J = 0 then
       FIBONACCI := 0
     else
       if J = 1 then
         FIBONACCI := 1
       else
         FIBONACCI := FIBONACCI ( J - 1 ) + FIBONACCI ( J - 2 ) ;
   end (* FIBONACCI *) ;



begin (* HAUPTPROGRAMM *)
  for I := 10 to 30 do
    begin
      TIME := CLOCK ( 0 ) ;
      WRITELN ( ' fibonacci # ' , I : 3 , ' is ' , FIBONACCI ( I ) : 8
                , ' (Comp.time = ' , CLOCK ( 0 ) - TIME : 5 ,
                ' Milli Sec.)' ) ;
    end (* for *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB FIBDEMO  EXT PAS HEX -
program FIB_DEMO ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



type POS_INT = 0 .. 30 ;


var I : POS_INT ;
    TIME : INTEGER ;


static TESTDUMP : INTEGER ;
       TESTCHAR : array [ 1 .. 10 ] of CHAR ;



function FIBONACCI ( J : POS_INT ) : INTEGER ;

(******************************)
(* to evaluate fibonacci # j, *)
(* for j >= 0                 *)
(* subject to int overflow    *)
(******************************)


   static ANZCALL : INTEGER ;

   begin (* FIBONACCI *)
     ANZCALL := ANZCALL + 1 ;
     if J = 0 then
       FIBONACCI := 0
     else
       if J = 1 then
         FIBONACCI := 1
       else
         FIBONACCI := FIBONACCI ( J - 1 ) + FIBONACCI ( J - 3 ) ;
   end (* FIBONACCI *) ;



begin (* HAUPTPROGRAMM *)
  TESTDUMP := 42 ;
  TESTCHAR := 'Oppolzer' ;
  for I := 10 to 25 do
    begin
      TIME := CLOCK ( 0 ) ;
      WRITELN ( ' fibonacci # ' , I : 3 , ' is ' , FIBONACCI ( I ) : 8
                , ' (Comp.time = ' , CLOCK ( 0 ) - TIME : 5 ,
                ' Milli Sec.)' ) ;
    end (* for *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB FIBOK    EXT PAS HEX -
program FIBOK ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



type POS_INT = 0 .. 30 ;


var I : POS_INT ;
    TIME : INTEGER ;


static TESTDUMP : INTEGER ;
       TESTCHAR : array [ 1 .. 10 ] of CHAR ;



function FIBONACCI ( J : POS_INT ) : INTEGER ;

(******************************)
(* to evaluate fibonacci # j, *)
(* for j >= 0                 *)
(* subject to int overflow    *)
(******************************)


   static ANZCALL : INTEGER ;

   begin (* FIBONACCI *)
     ANZCALL := ANZCALL + 1 ;
     if J = 0 then
       FIBONACCI := 0
     else
       if J = 1 then
         FIBONACCI := 1
       else
         FIBONACCI := FIBONACCI ( J - 1 ) + FIBONACCI ( J - 2 ) ;
   end (* FIBONACCI *) ;



begin (* HAUPTPROGRAMM *)
  TESTDUMP := 42 ;
  TESTCHAR := 'Oppolzer' ;
  for I := 10 to 30 do
    begin
      TIME := CLOCK ( 0 ) ;
      WRITELN ( ' fibonacci # ' , I : 3 , ' is ' , FIBONACCI ( I ) : 8
                , ' (Comp.time = ' , CLOCK ( 0 ) - TIME : 5 ,
                ' Milli Sec.)' ) ;
    end (* for *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB KALENDER EXT PAS HEX -
program KALENDER ( INPUT , OUTPUT , DRUCKER ) ;


type MONATE = ( JAN , FEB , MAR , APR , MAI , JUN , JUL , AUG , SEP ,
              OKT , NOV , DEZ ) ;
     JAHR = array [ MONATE ] of INTEGER ;
     TSTRING = packed array [ 1 .. 24 ] of CHAR ;
     WOCHE = array [ 1 .. 7 ] of record
                                   TAG : INTEGER ;
                                   MONAT : INTEGER ;
                                   FEIERTAG : BOOLEAN
                                 end ;
     KALFELD = array [ 1 .. 70 ] of WOCHE ;
     WOFELD = array [ 1 .. 70 ] of INTEGER ;


var DRUCKER : TEXT ;
    BEZUGSJAHR , OSTERTAG : INTEGER ;
    SCHALTTAG : INTEGER ;
    MONATSLAENGE : JAHR ;
    MONATSWERT : MONATE ;
    SONNTAG : INTEGER ;
    KAL : KALFELD ;
    WO : WOFELD ;
    LAUFTAG : INTEGER ;
    NRWOCHE : INTEGER ;



procedure VORBESETZEN ;

   var W , T : INTEGER ;

   begin (* VORBESETZEN *)
     BEZUGSJAHR := 0 ;
     for W := 1 to 70 do
       for T := 1 to 7 do
         begin
           KAL [ W ] [ T ] . TAG := 0 ;
           KAL [ W ] [ T ] . MONAT := 0 ;
           KAL [ W ] [ T ] . FEIERTAG := FALSE
         end (* for *) ;
     for W := 1 to 70 do
       WO [ W ] := 0 ;
     MONATSLAENGE [ JAN ] := 31 ;
     MONATSLAENGE [ FEB ] := 28 ;
     MONATSLAENGE [ MAR ] := 31 ;
     MONATSLAENGE [ APR ] := 30 ;
     MONATSLAENGE [ MAI ] := 31 ;
     MONATSLAENGE [ JUN ] := 30 ;
     MONATSLAENGE [ JUL ] := 31 ;
     MONATSLAENGE [ AUG ] := 31 ;
     MONATSLAENGE [ SEP ] := 30 ;
     MONATSLAENGE [ OKT ] := 31 ;
     MONATSLAENGE [ NOV ] := 30 ;
     MONATSLAENGE [ DEZ ] := 31 ;
   end (* VORBESETZEN *) ;



procedure MONATSNAME ( M : MONATE ) ;

   begin (* MONATSNAME *)
     case M of
       JAN : WRITELN ( ' JANUAR' ) ;
       FEB : WRITELN ( ' FEBRUAR' ) ;
       MAR : WRITELN ( ' MAERZ' ) ;
       APR : WRITELN ( ' APRIL' ) ;
       MAI : WRITELN ( ' MAI' ) ;
       JUN : WRITELN ( ' JUNI' ) ;
       JUL : WRITELN ( ' JULI' ) ;
       AUG : WRITELN ( ' AUGUST' ) ;
       SEP : WRITELN ( ' SEPTEMBER' ) ;
       OKT : WRITELN ( ' OKTOBER' ) ;
       NOV : WRITELN ( ' NOVEMBER' ) ;
       DEZ : WRITELN ( ' DEZEMBER' ) ;
     end (* case *) ;
   end (* MONATSNAME *) ;



procedure MONATSNAMEDRU ( M : INTEGER ) ;

   begin (* MONATSNAMEDRU *)
     case M of
       1 : WRITE ( DRUCKER , ' Jan   ' ) ;
       2 : WRITE ( DRUCKER , ' Feb   ' ) ;
       3 : WRITE ( DRUCKER , ' Mr   ' ) ;
       4 : WRITE ( DRUCKER , ' Apr   ' ) ;
       5 : WRITE ( DRUCKER , ' Mai   ' ) ;
       6 : WRITE ( DRUCKER , ' Jun   ' ) ;
       7 : WRITE ( DRUCKER , ' Jul   ' ) ;
       8 : WRITE ( DRUCKER , ' Aug   ' ) ;
       9 : WRITE ( DRUCKER , ' Sep   ' ) ;
       10 : WRITE ( DRUCKER , ' Okt   ' ) ;
       11 : WRITE ( DRUCKER , ' Nov   ' ) ;
       12 : WRITE ( DRUCKER , ' Dez   ' ) ;
     end (* case *) ;
   end (* MONATSNAMEDRU *) ;



procedure WOCHENTAG ( T : INTEGER ) ;

   begin (* WOCHENTAG *)
     case T of
       0 : WRITE ( '   SONNTAG,' ) ;
       1 : WRITE ( '    MONTAG,' ) ;
       2 : WRITE ( '  DIENSTAG,' ) ;
       3 : WRITE ( '  MITTWOCH,' ) ;
       4 : WRITE ( 'DONNERSTAG,' ) ;
       5 : WRITE ( '   FREITAG,' ) ;
       6 : WRITE ( '   SAMSTAG,' ) ;
     end (* case *) ;
   end (* WOCHENTAG *) ;



procedure OSTERN ;

   var A , B , C , D , E : INTEGER ;
       DH , EH : INTEGER ;

   begin (* OSTERN *)
     if ( BEZUGSJAHR >= 1583 ) and ( BEZUGSJAHR <= 1699 ) then
       DH := 22 ;
     if ( BEZUGSJAHR >= 1700 ) and ( BEZUGSJAHR <= 1899 ) then
       DH := 23 ;
     if ( BEZUGSJAHR >= 1900 ) and ( BEZUGSJAHR <= 2199 ) then
       DH := 24 ;
     if ( BEZUGSJAHR >= 2200 ) and ( BEZUGSJAHR <= 2299 ) then
       DH := 25 ;
     if ( BEZUGSJAHR >= 1583 ) and ( BEZUGSJAHR <= 1699 ) then
       EH := 2 ;
     if ( BEZUGSJAHR >= 1700 ) and ( BEZUGSJAHR <= 1799 ) then
       EH := 3 ;
     if ( BEZUGSJAHR >= 1800 ) and ( BEZUGSJAHR <= 1899 ) then
       EH := 4 ;
     if ( BEZUGSJAHR >= 1900 ) and ( BEZUGSJAHR <= 2099 ) then
       EH := 5 ;
     if ( BEZUGSJAHR >= 2100 ) and ( BEZUGSJAHR <= 2199 ) then
       EH := 6 ;
     if ( BEZUGSJAHR >= 2200 ) and ( BEZUGSJAHR <= 2299 ) then
       EH := 0 ;
     A := BEZUGSJAHR MOD 19 ;
     B := BEZUGSJAHR MOD 4 ;
     C := BEZUGSJAHR MOD 7 ;
     D := ( 19 * A + DH ) MOD 30 ;
     E := ( 2 * B + 4 * C + 6 * D + EH ) MOD 7 ;
     OSTERTAG := D + E ;
     if OSTERTAG = 35 then
       OSTERTAG := 28 ;
     if ( ( D = 28 ) and ( E = 6 ) and ( A > 10 ) ) then
       OSTERTAG := 27 ;
     if ( ( B = 0 ) and ( ( BEZUGSJAHR MOD 100 <> 0 ) or ( BEZUGSJAHR
     MOD 400 = 0 ) ) ) then
       SCHALTTAG := 1
     else
       SCHALTTAG := 0 ;
     OSTERTAG := OSTERTAG + SCHALTTAG + 81 ;
   end (* OSTERN *) ;



procedure UMRECHNUNG ( TAG : INTEGER ; NAME : TSTRING ) ;

   var WERKTAG : INTEGER ;
       T : INTEGER ;

   begin (* UMRECHNUNG *)
     WERKTAG := TAG ;
     MONATSWERT := JAN ;
     while TAG > MONATSLAENGE [ MONATSWERT ] do
       begin
         TAG := TAG - MONATSLAENGE [ MONATSWERT ] ;
         MONATSWERT := SUCC ( MONATSWERT ) ;
       end (* while *) ;
     T := ( WERKTAG + 7 - SONNTAG ) MOD 7 ;
     if T = 0 then
       T := 7 ;
     if TAG = 1 then
       NRWOCHE := NRWOCHE + 1
     else
       if T = 1 then
         NRWOCHE := NRWOCHE + 1 ;
     KAL [ NRWOCHE ] [ T ] . TAG := TAG ;
     KAL [ NRWOCHE ] [ T ] . MONAT := ORD ( MONATSWERT ) + 1 ;
     if T in [ 6 , 7 ] then
       KAL [ NRWOCHE ] [ T ] . FEIERTAG := TRUE
   end (* UMRECHNUNG *) ;



procedure MARKFEIERTAG ( TAG : INTEGER ; NAME : TSTRING ) ;

   var WERKTAG : INTEGER ;
       W , T : INTEGER ;

   begin (* MARKFEIERTAG *)
     WERKTAG := TAG ;
     MONATSWERT := JAN ;
     while TAG > MONATSLAENGE [ MONATSWERT ] do
       begin
         TAG := TAG - MONATSLAENGE [ MONATSWERT ] ;
         MONATSWERT := SUCC ( MONATSWERT ) ;
       end (* while *) ;
     WRITE ( ' ' , NAME ) ;
     WOCHENTAG ( ( WERKTAG + 7 - SONNTAG ) MOD 7 ) ;
     WRITE ( ' ' , TAG : 2 , '.' ) ;
     MONATSNAME ( MONATSWERT ) ;
     for W := 1 to 70 do
       for T := 1 to 7 do
         begin
           if ( KAL [ W ] [ T ] . TAG = TAG ) and ( KAL [ W ] [ T ] .
           MONAT = ORD ( MONATSWERT ) + 1 ) then
             KAL [ W ] [ T ] . FEIERTAG := TRUE
         end (* for *) ;
   end (* MARKFEIERTAG *) ;



procedure WOFUELL ;

   var W : INTEGER ;

   begin (* WOFUELL *)
     if KAL [ 1 ] [ 5 ] . TAG > 1 then
       WO [ 1 ] := 1
     else
       WO [ 1 ] := 0 ;
     for W := 2 to 70 do
       begin
         if KAL [ W ] [ 1 ] . TAG <> 0 then
           WO [ W ] := WO [ W - 1 ] + 1
         else
           WO [ W ] := WO [ W - 1 ]
       end (* for *)
   end (* WOFUELL *) ;



procedure DUMPKAL ;

   var W , T : INTEGER ;

   begin (* DUMPKAL *)
     for W := 1 to 70 do
       begin
         for T := 1 to 7 do
           begin
             WRITE ( KAL [ W ] [ T ] . TAG : 2 ) ;
             WRITE ( '.' ) ;
             WRITE ( KAL [ W ] [ T ] . MONAT : 2 ) ;
             if KAL [ W ] [ T ] . FEIERTAG then
               WRITE ( '*  ' )
             else
               WRITE ( '   ' ) ;
           end (* for *) ;
         WRITELN
       end (* for *)
   end (* DUMPKAL *) ;



procedure DRUCKKAL ;

   var W , T : INTEGER ;
       MONATALT : INTEGER ;

   begin (* DRUCKKAL *)
     MONATALT := 99 ;
     REWRITE ( DRUCKER ) ;
     WRITELN ( DRUCKER , '.S 0' ) ;
     WRITELN ( DRUCKER , '.Z 0' ) ;
     WRITELN ( DRUCKER , '.E 4' ) ;
     WRITELN ( DRUCKER , '.L 2' ) ;
     WRITELN ( DRUCKER , '.P' ) ;
     WRITE ( DRUCKER , BEZUGSJAHR : 5 ) ;
     WRITELN ( DRUCKER , ' ' : 12 , 'Mo  Di  Mi  Do  Fr  Sa  So' ) ;
     WRITELN ( DRUCKER ) ;
     for W := 1 to 70 do
       begin
         if KAL [ W ] [ 1 ] . MONAT <> MONATALT then
           begin
             WRITELN ( DRUCKER , '.L 2' ) ;
             MONATALT := KAL [ W + 1 ] [ 1 ] . MONAT ;
             MONATSNAMEDRU ( MONATALT )
           end (* then *)
         else
           begin
             if W < 70 then
               if KAL [ W + 1 ] [ 1 ] . MONAT <> MONATALT then
                 WRITELN ( DRUCKER , '.L 3' ) ;
             WRITE ( DRUCKER , ' ' : 7 ) ;
           end (* else *) ;
         WRITE ( DRUCKER , ' Wo' , WO [ W ] : 3 , ' ' : 4 ) ;
         for T := 1 to 7 do
           begin
             if KAL [ W ] [ T ] . TAG <> 0 then
               WRITE ( DRUCKER , KAL [ W ] [ T ] . TAG : 2 )
             else
               WRITE ( DRUCKER , ' ' : 2 ) ;
             if KAL [ W ] [ T ] . FEIERTAG then
               WRITE ( DRUCKER , '* ' )
             else
               WRITE ( DRUCKER , '  ' ) ;
           end (* for *) ;
         WRITELN ( DRUCKER )
       end (* for *)
   end (* DRUCKKAL *) ;



begin (* HAUPTPROGRAMM *)
  VORBESETZEN ;
  while ( BEZUGSJAHR < 1584 ) or ( BEZUGSJAHR > 2299 ) do
    begin
      if ( BEZUGSJAHR > 0 ) then
        WRITE ( ' UNGUELTIGES BEZUGSJAHR ' , BEZUGSJAHR : 1 , '.' ) ;
      WRITELN ( ' GIB DAS BEZUGSJAHR AN ' ) ;
      READ ( BEZUGSJAHR ) ;
      BEZUGSJAHR := ABS ( BEZUGSJAHR ) ;
    end (* while *) ;
  WRITELN ( ' DIE BERECHNUNG FUER DAS BEZUGSJAHR ' , BEZUGSJAHR : 4 ,
            ' LAUTET' ) ;
  OSTERN ;
  if SCHALTTAG = 1 then
    MONATSLAENGE [ FEB ] := 29 ;
  SONNTAG := OSTERTAG MOD 7 ;
  NRWOCHE := 0 ;
  for LAUFTAG := 1 to 365 + SCHALTTAG do
    UMRECHNUNG ( LAUFTAG , '                        ' ) ;
  MARKFEIERTAG ( 1 , 'NEUJAHR                 ' ) ;
  MARKFEIERTAG ( 6 , 'HL. DREI KOENIGE        ' ) ;
  MARKFEIERTAG ( OSTERTAG - 48 , 'ROSENMONTAG             ' ) ;
  MARKFEIERTAG ( OSTERTAG - 2 , 'KARFREITAG              ' ) ;
  MARKFEIERTAG ( OSTERTAG , 'OSTERSONNTAG            ' ) ;
  MARKFEIERTAG ( OSTERTAG + 1 , 'OSTERMONTAG             ' ) ;
  MARKFEIERTAG ( 121 + SCHALTTAG , '1. MAI                  ' ) ;
  MARKFEIERTAG ( OSTERTAG + 39 , 'CHRISTI HIMMELFAHRT     ' ) ;
  MARKFEIERTAG ( OSTERTAG + 49 , 'PFINGSTSONNTAG          ' ) ;
  MARKFEIERTAG ( OSTERTAG + 50 , 'PFINGSTMONTAG           ' ) ;
  MARKFEIERTAG ( OSTERTAG + 60 , 'FRONLEICHNAM            ' ) ;
  MARKFEIERTAG ( 276 + SCHALTTAG , '3. OKTOBER              ' ) ;
  MARKFEIERTAG ( 305 + SCHALTTAG , 'ALLERHEILIGEN           ' ) ;
  MARKFEIERTAG ( 359 + SCHALTTAG , '1. WEIHNACHTSFEIERTAG   ' ) ;
  MARKFEIERTAG ( 360 + SCHALTTAG , '2. WEIHNACHTSFEIERTAG   ' ) ;
  WOFUELL ;
  DRUCKKAL
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB LISTGENC EXT PAS HEX -
program LISTGENC ( OUTPUT , MUSTER , PROGRAMM , PROTOKOL ) ;


const LINESIZE = 180 ;
      MAXLEER = 10 ;


type ZEILTYP = packed array [ 1 .. LINESIZE ] of CHAR ;


var MUSTER : TEXT ;
    PROGRAMM : TEXT ;
    PROTOKOL : TEXT ;
    ZEILE : ZEILTYP ;
    CHARANZ : INTEGER ;



function ISTELLEN ( I : INTEGER ) : INTEGER ;

   begin (* ISTELLEN *)
     if I <= 9 then
       ISTELLEN := 1
     else
       if I <= 99 then
         ISTELLEN := 2
       else
         if I <= 999 then
           ISTELLEN := 3
         else
           if I <= 9999 then
             ISTELLEN := 4
           else
             ISTELLEN := 5
   end (* ISTELLEN *) ;



procedure ZEILREIN ;

   var CH : CHAR ;
       FERTIG : BOOLEAN ;
       DUMMY : CHAR ;

   begin (* ZEILREIN *)
     CHARANZ := 0 ;
     while not EOLN ( MUSTER ) do
       begin
         READ ( MUSTER , CH ) ;
         CHARANZ := CHARANZ + 1 ;
         if CHARANZ <= LINESIZE then
           ZEILE [ CHARANZ ] := CH
       end (* while *) ;
     READLN ( MUSTER ) ;
     if CHARANZ > LINESIZE then
       CHARANZ := LINESIZE ;
     FERTIG := CHARANZ < 1 ;
     while not FERTIG do
       begin
         FERTIG := ZEILE [ CHARANZ ] <> ' ' ;
         if not FERTIG then
           begin
             CHARANZ := CHARANZ - 1 ;
             FERTIG := CHARANZ < 1
           end (* then *)
       end (* while *)
   end (* ZEILREIN *) ;



procedure INFORAUS ( X , Y : INTEGER ) ;

   var I : INTEGER ;
       LASTBLANK : INTEGER ;
       HILF : INTEGER ;
       HILF2 : INTEGER ;


   function PLATZ ( X , Y : INTEGER ) : INTEGER ;

      var HILF : INTEGER ;
          I : INTEGER ;

      begin (* PLATZ *)
        HILF := 0 ;
        for I := X to Y do
          if not ( ZEILE [ I ] in [ '''' , '"' , '\' ] ) then
            HILF := HILF + 1
          else
            HILF := HILF + 2 ;
        PLATZ := HILF
      end (* PLATZ *) ;


   begin (* INFORAUS *)
     repeat
       HILF := PLATZ ( X , Y ) ;
       HILF2 := Y - X + 1 ;
       if HILF <= 40 then
         begin
           WRITE ( PROGRAMM , '   fprintf (fp, "%-' , HILF2 : ISTELLEN
                   ( HILF2 ) , 's", "' ) ;
           for I := X to Y do
             if not ( ZEILE [ I ] in [ '''' , '"' , '\' ] ) then
               WRITE ( PROGRAMM , ZEILE [ I ] )
             else
               WRITE ( PROGRAMM , '\' , ZEILE [ I ] ) ;
           WRITELN ( PROGRAMM , '"); ' ) ;
           X := Y + 1
         end (* then *)
       else
         begin
           LASTBLANK := 0 ;
           I := X ;
           HILF := 0 ;
           repeat
             if not ( ZEILE [ I ] in [ '''' , '"' , '\' ] ) then
               HILF := HILF + 1
             else
               HILF := HILF + 2 ;
             if ZEILE [ I ] = ' ' then
               LASTBLANK := I ;
             I := I + 1
           until HILF > 35 ;
           if LASTBLANK = 0 then
             LASTBLANK := I - 1 ;
           HILF := PLATZ ( X , LASTBLANK ) ;
           HILF2 := LASTBLANK - X + 1 ;
           WRITE ( PROGRAMM , '   fprintf (fp, "%-' , HILF2 : ISTELLEN
                   ( HILF2 ) , 's", "' ) ;
           for I := X to LASTBLANK do
             if not ( ZEILE [ I ] in [ '''' , '"' , '\' ] ) then
               WRITE ( PROGRAMM , ZEILE [ I ] )
             else
               WRITE ( PROGRAMM , '\' , ZEILE [ I ] ) ;
           WRITELN ( PROGRAMM , '"); ' ) ;
           X := LASTBLANK + 1 ;
         end (* else *)
     until X > Y
   end (* INFORAUS *) ;



procedure BEFEHLERAUS ;

   var NONBLANK : INTEGER ;
       START : INTEGER ;
       FERTIG : BOOLEAN ;
       ANZBLANK : INTEGER ;
       LAUF : INTEGER ;
       I : INTEGER ;

   begin (* BEFEHLERAUS *)
     if CHARANZ > 0 then
       begin
         NONBLANK := 1 ;
         while ZEILE [ NONBLANK ] = ' ' do
           NONBLANK := NONBLANK + 1 ;
         if NONBLANK > 1 then
           if NONBLANK = 2 then
             WRITELN ( PROGRAMM , '   fprintf (fp, " ");' )
           else
             WRITELN ( PROGRAMM , '   fprintf (fp, "%' , ( NONBLANK - 1
                       ) : ISTELLEN ( NONBLANK - 1 ) , 's", "");' ) ;
         START := NONBLANK ;
         repeat
           FERTIG := FALSE ;
           LAUF := START ;
           ANZBLANK := 0 ;
           while not FERTIG do
             begin
               if LAUF > CHARANZ then
                 FERTIG := TRUE
               else
                 begin
                   if ZEILE [ LAUF ] = ' ' then
                     ANZBLANK := ANZBLANK + 1
                   else
                     ANZBLANK := 0 ;
                   FERTIG := ANZBLANK >= MAXLEER ;
                   if not FERTIG then
                     LAUF := LAUF + 1
                 end (* else *)
             end (* while *) ;
           if LAUF > CHARANZ then
             begin
               INFORAUS ( START , CHARANZ ) ;
               WRITELN ( PROGRAMM , '   fprintf (fp, "\n");' ) ;
               START := LAUF ;
             end (* then *)
           else
             INFORAUS ( START , LAUF - ANZBLANK ) ;
           if LAUF <= CHARANZ then
             begin
               LAUF := LAUF - ANZBLANK + 1 ;
               START := LAUF ;
               repeat
                 LAUF := LAUF + 1
               until ZEILE [ LAUF ] <> ' ' ;
               WRITELN ( PROGRAMM , '   fprintf (fp, "%' , ( LAUF -
                         START ) : ISTELLEN ( LAUF - START ) ,
                         's", "");' ) ;
               START := LAUF ;
             end (* then *) ;
         until START > CHARANZ
       end (* then *)
     else
       WRITELN ( PROGRAMM , '   fprintf (fp, "\n");' ) ;
     WRITELN ( PROGRAMM ) ;
   end (* BEFEHLERAUS *) ;



procedure TESTDUMP ;

   var I : INTEGER ;

   begin (* TESTDUMP *)
     WRITELN ( PROTOKOL , 'Neue Zeile - Char-Anzahl = ' , CHARANZ : 3 )
               ;
     for I := 1 to CHARANZ do
       WRITELN ( PROTOKOL , I : 3 , '-' , ZEILE [ I ] , '-' ) ;
   end (* TESTDUMP *) ;



begin (* HAUPTPROGRAMM *)
  RESET ( MUSTER ) ;
  REWRITE ( PROGRAMM ) ;
  REWRITE ( PROTOKOL ) ;
  WRITELN ( PROGRAMM , 'void print (FILE *fp)' ) ;
  WRITELN ( PROGRAMM ) ;
  WRITELN ( PROGRAMM , '{' ) ;
  repeat
    ZEILREIN ;
    BEFEHLERAUS
  until EOF ( MUSTER ) ;
  WRITELN ( PROGRAMM , '}' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB MANORBOY EXT PAS HEX -
program MANORBOY ( OUTPUT ) ;

(*************************************************************)
(* program to do knuth's man or boy test                     *)
(* from https://rosettacode.org/wiki/Man_or_boy_test#Pascal  *)
(*************************************************************)
(* option to enable assembler listing:                       *)
(*$A+                                                        *)
(*************************************************************)




function ZERO : INTEGER ;

   begin (* ZERO *)
     ZERO := 0
   end (* ZERO *) ;



function ONE : INTEGER ;

   begin (* ONE *)
     ONE := 1
   end (* ONE *) ;



function NEGONE : INTEGER ;

   begin (* NEGONE *)
     NEGONE := - 1
   end (* NEGONE *) ;



function A ( K : INTEGER ; function X1 : INTEGER ; function X2 :
           INTEGER ; function X3 : INTEGER ; function X4 : INTEGER ;
           function X5 : INTEGER ) : INTEGER ;


   function B : INTEGER ;

      begin (* B *)
        K := K - 1 ;
        B := A ( K , B , X1 , X2 , X3 , X4 )
      end (* B *) ;


   begin (* A *)
     if K <= 0 then
       A := X4 + X5
     else
       A := B
   end (* A *) ;



begin (* HAUPTPROGRAMM *)
  WRITELN ( A ( 10 , ONE , NEGONE , NEGONE , ONE , ZERO ) )
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB MODRAND  EXT PAS HEX -
module MODRAND ;



function RANDOM ( X : INTEGER ) : INTEGER ;

   begin (* RANDOM *)
     WRITELN ( 'random: ' , X ) ;
     RANDOM := X ;
   end (* RANDOM *) ;



begin (* HAUPTPROGRAMM *)

end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB PAS2PAS  EXT PAS HEX -
module $PAS2PAS ;

//**********************************************************************
//$A+
//**********************************************************************



type CHAR20 = array [ 1 .. 20 ] of CHAR ;



procedure PAS2PAS ( X1 : INTEGER ; var X2 : INTEGER ; T1 : CHAR20 ; var
                  T2 : CHAR20 ) ;

   begin (* PAS2PAS *)
     WRITELN ( 'pas2pas: x1 = ' , X1 ) ;
     WRITELN ( 'pas2pas: x2 = ' , X2 ) ;
     WRITELN ( 'pas2pas: t1 = <' , T1 , '>' ) ;
     WRITELN ( 'pas2pas: t2 = <' , T2 , '>' ) ;
     X2 := 5 ;
     T2 := 'string from pas2pas' ;
   end (* PAS2PAS *) ;



function PAS2Pf ( X1 : INTEGER ; x2 : INTEGER ) : integer ;

   begin (* PAS2pf *)
     pas2pf := ( x1 + x2 ) div 2 ;
   end (* PAS2PAS *) ;



begin (* HAUPTPROGRAMM *)

end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB PASFORM  EXT PAS HEX -
program PASFORM ( OUTPUT , EINGABE , AUSGABE , TRACE ) ;

(********************************************************************)
(*                                                                  *)
(*   PASCAL-FORMATIERER                                             *)
(*                                                                  *)
(*   STAND: JULI 1990                                               *)
(*   AUTOR: BERND OPPOLZER                                          *)
(*                                                                  *)
(*   UNTERSCHIEDE PASCAL/VS ZU TURBO/3:                             *)
(*                                                                  *)
(*   INSYMBOL MUSS AUSSER BLANKS BEI TURBO/3                        *)
(*   AUCH CHR(10) UND CHR(13) UEBERLESEN.                           *)
(*   TERMIN/TERMOUT BEI PASCAL/VS.                                  *)
(*   ASSIGN/CLOSE BEI TURBO/3.                                      *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*   ANPASSUNGEN FUER FPC AM 05.10.2013:                            *)
(*                                                                  *)
(*   ARRAY-KLAMMERN IMMER ALS [ ] AUSGEBEN                          *)
(*                                                                  *)
(*   POINTER-SYMBOLE IMMER ALS ^                                    *)
(*                                                                  *)
(*   CHARACTER-RANGE MIT RUECKSICHT AUF EBCDIC ...                  *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*   -- NEUE VERSION VON INSYMBOL, DIE AN STANFORD PASCAL           *)
(*      ANGEPASST IST                                               *)
(*                                                                  *)
(*   -- KOMMENTARE BESSER ABHANDELN WIE FOLGT:                      *)
(*                                                                  *)
(*   A) ZUNAECHST GIBT ES VIER SORTEN - ODER FUENF:                 *)
(*      1) # SIND ZU UEBERLESEN                                     *)
(*      2) SOLCHE MIT "..."                                         *)
(*      3) DANN DIE DREI UEBLICHEN                                  *)
(*                                                                  *)
(*   B) KOMMENTARE INNERHALB VON STATEMENTS BEHALTEN WIR BEI        *)
(*                                                                  *)
(*   C) KOMMENTARE AUSSERHALB KASTELN WIR EIN                       *)
(*                                                                  *)
(*   D) WICHTIG: AUCH SOLCHE, DIE UEBER MEHRERE ZEILEN GEHEN        *)
(*                                                                  *)
(*   E) REKURSIVE KOMMENTARE MUESSEN MOEGLICH SEIN                  *)
(*                                                                  *)
(*   F) ANDERE LOGIK BEI CASE                                       *)
(*                                                                  *)
(*   G) HINTER ZEILE 50 NICHT WEITER EINRUECKEN !!                  *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*   OFFEN:                                                         *)
(*                                                                  *)
(*   * WO BLEIBEN DIE LEERZEILEN HINTER DEN KOMMENTARKAESTEN        *)
(*                                                                  *)
(*   * ANDERS EINRUECKEN BEI VARIANTEN RECORDS                      *)
(*                                                                  *)
(*   * NICHT ALLE KOMMENTARE UEBERLESEN HINTER BEGIN/END USW.       *)
(*                                                                  *)
(*   * HINTER ZEILE 50 NICHT WEITER EINRUECKEN !!!                  *)
(*                                                                  *)
(*   * FEHLER BEI PASCAL2, WAS IST DA LOS ??                        *)
(*     KOMMENTAR NACH BEGIN WIRD UEBERLESEN, ABER DA WIRD           *)
(*     NUR DER ERSTE TEIL EINGELESEN; DER REST WIRD DANN            *)
(*     ALS NORMALES STATEMENT INTERPRETIERT ...                     *)
(*     KOMMC.UEBERLESEN USW. BESSER MACHEN ...                      *)
(*   * BEI KURZEN KOMMENTAREN STIMMEN DIE KAESTCHEN NICHT           *)
(*                                                                  *)
(*   * KLEINBUCHSTABEN AUCH KLEIN LASSEN                            *)
(*                                                                  *)
(*   * EINLESEN LAENGERE RECORDS, MINDESTENS 80, VERMUTLICH 120     *)
(*                                                                  *)
(*   * REKURSIVE KOMMENTARE, KOMMENTARKAESTEN UEBERHAUPT            *)
(*                                                                  *)
(*   * CONST FUER STRUKTUREN NACH VAR WIRD NICHT AKZEPTIERT         *)
(*                                                                  *)
(*   * KOMMENTARE VOLLSTAENDIG AUSGEBEN UND AUFTEILEN               *)
(*                                                                  *)
(*   * " KOMMENTARE MIT LAENGE KLEINER VIER KOMPLETT IGNORIEREN     *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*   ANPASSUNGEN am 31.08.2016                                      *)
(*                                                                  *)
(*   Kommentare anders eingerueckt                                  *)
(*   Neuzeile bei komplexen consts (Stanford-Erweiterung)           *)
(*                                                                  *)
(********************************************************************)



const VERKETT2 = '' ;
      MAXLOUTPUT = 72 ;
      MAXLINPUT = 160 ;
      MAXEINR = 51 ;
      MAXIDSIZE = 20 ;


type WORT = array [ 1 .. 100 ] of CHAR ;
     SWORT = packed array [ 1 .. 10 ] of CHAR ;
     FELD6 = packed array [ 1 .. 6 ] of CHAR ;
     PWORT = record
               NAME : packed array [ 1 .. MAXIDSIZE ] of CHAR ;
               LAENGE : INTEGER
             end ;
     SYMBOL = ( EOFSY , IDENTIFIER , ZAHL , STRIPU , ZKETTE , SONDER ,
              POINTERSY , ECKKLAMMAUF , ECKKLAMMZU , GLEICH , ZUWEISUNG
              , KLAMMAUF , DOPU , KLAMMZU , ANDSY , ARRAYSY , BEGINSY ,
              BREAKSY , CASESY , CONSTSY , CONTINUESY , DOSY , ELSESY ,
              ENDSY , FORSY , FUNCTIONSY , GOTOSY , IFSY , INSY ,
              LABELSY , LOCALSY , MODULESY , NOTSY , OFSY , ORSY ,
              OTHERWISESY , OVERLAYSY , PACKEDSY , PROCEDURESY ,
              PROGRAMSY , RECORDSY , REPEATSY , RETURNSY , SETSY ,
              SQLBEGINSY , SQLENDSY , SQLVARSY , STATICSY , THENSY ,
              TOSY , TYPESY , UNTILSY , VARSY , WHILESY , WITHSY ,
              XORSY ) ;
     KOMMCTL = record
                 KOMMP : WORT ;
                 KOMML : INTEGER ;
                 ENDOFKOMM : BOOLEAN ;
                 ANZKOMM : INTEGER ;
                 ZUSTAND : INTEGER ;
                 KOMMTYPE : CHAR ;
                 NURSTERNE : BOOLEAN ;
                 KOMMSTATUS : INTEGER ;
                 UEBERLESEN : INTEGER ;
                 KOMM_VOR_PROC : BOOLEAN ;
               end ;


var EINGABE , AUSGABE : TEXT ;
    ZZAUS : INTEGER ;
    BLANKSYMBOLE : set of SYMBOL ;
    STERMSYMBOLE : set of SYMBOL ;
    TTERMSYMBOLE : set of SYMBOL ;
    WORTSYMBOLE : set of SYMBOL ;
    EXPRSYMBOLE : set of SYMBOL ;
    W1 : WORT ;
    INC : INTEGER ;
    DICHT : BOOLEAN ;
    COMPOUNDNZ : BOOLEAN ;
    BLANKSVORHANDEN : BOOLEAN ;
    NOMAJOR : BOOLEAN ;
    EINR : INTEGER ;
    EINRKOMM : INTEGER ;
    MODUS : INTEGER ;
    WTAB : array [ ANDSY .. XORSY ] of SWORT ;
    WTABSQL : array [ 1 .. 30 ] of SWORT ;
    ANZSQLWORTE : INTEGER ;
    W1ENDE , W1INDEX : INTEGER ;
    EOFILE : BOOLEAN ;
    SONDERZEICHEN , ISTARTSET , IWEITERSET , HEXZIFFERN , ZIFFERN : set
                                                   of CHAR ;
    S : SYMBOL ;
    OUTPOINTER : INTEGER ;
    INPOINTER : INTEGER ;
    NICHTLESEN : INTEGER ;
    CH1 , CH2 : CHAR ;
    ZIFFERNGELESEN : BOOLEAN ;
    NULLSTATE : BOOLEAN ;
    KOMMLAENGE : INTEGER ;
    ENDEKASTEN : CHAR ;
    ENDEKOMMEIN : INTEGER ;
    ZZAUSVOR : INTEGER ;
    INSQLSTATE : BOOLEAN ;
    SQLHOSTV : BOOLEAN ;
    TRACE : TEXT ;

    (*******************************************************)
    (*  KOMMC: AUFZEICHNEN DES LAUFENDEN KOMMENTAR-STATUS  *)
    (*******************************************************)

    KOMMC : KOMMCTL ;



procedure HALTX ;

   begin (* HALTX *)
     EXIT ( 8 )
   end (* HALTX *) ;



function MAJOR ( CH : CHAR ) : CHAR ;

   begin (* MAJOR *)
     if CH in [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' ] then
       MAJOR := CHR ( ORD ( CH ) - ORD ( 'a' ) + ORD ( 'A' ) )
     else
       MAJOR := CH
   end (* MAJOR *) ;



function MINOR ( CH : CHAR ) : CHAR ;

   begin (* MINOR *)
     if CH in [ 'A' .. 'I' , 'J' .. 'R' , 'S' .. 'Z' ] then
       MINOR := CHR ( ORD ( CH ) - ORD ( 'A' ) + ORD ( 'a' ) )
     else
       MINOR := CH
   end (* MINOR *) ;



procedure RESWRD ( var SYERG : SYMBOL ) ;

   var TESTWORT : SWORT ;
       I : INTEGER ;
       SY : SYMBOL ;
       WORTENDE : INTEGER ;

   begin (* RESWRD *)
     SYERG := IDENTIFIER ;
     TESTWORT := '' ;
     if W1ENDE <= 10 then
       WORTENDE := W1ENDE
     else
       WORTENDE := 10 ;
     for I := 1 to WORTENDE do
       TESTWORT [ I ] := W1 [ I ] ;
     for SY := ANDSY to XORSY do
       begin
         if TESTWORT = WTAB [ SY ] then
           SYERG := SY
       end (* for *)
   end (* RESWRD *) ;



function RESWRDSQL : BOOLEAN ;

   var TESTWORT : SWORT ;
       I : INTEGER ;
       RW : BOOLEAN ;
       WORTENDE : INTEGER ;

   begin (* RESWRDSQL *)
     RW := FALSE ;
     TESTWORT := '' ;
     if W1ENDE <= 10 then
       WORTENDE := W1ENDE
     else
       WORTENDE := 10 ;
     for I := 1 to WORTENDE do
       TESTWORT [ I ] := W1 [ I ] ;
     for I := 1 to ANZSQLWORTE do
       if TESTWORT = WTABSQL [ I ] then
         RW := TRUE ;
     RESWRDSQL := RW
   end (* RESWRDSQL *) ;



procedure READCH ( var CH : CHAR ) ;

   begin (* READCH *)
     EOFILE := FALSE ;
     if EOF ( EINGABE ) then
       begin
         EOFILE := TRUE ;
         CH := ' '
       end (* then *)
     else
       begin
         if EOLN ( EINGABE ) then
           INPOINTER := 0 ;
         if INPOINTER > MAXLINPUT then
           begin
             READLN ( EINGABE ) ;
             INPOINTER := 0 ;
             CH := ' '
           end (* then *)
         else
           begin
             if EOF ( EINGABE ) then
               begin
                 EOFILE := TRUE ;
                 CH := ' '
               end (* then *)
             else
               begin
                 INPOINTER := INPOINTER + 1 ;
                 READ ( EINGABE , CH )
               end (* else *)
           end (* else *)
       end (* else *) ;
     if not NOMAJOR then
       CH := MAJOR ( CH )
   end (* READCH *) ;



procedure LIES ( var CH : CHAR ) ;

   begin (* LIES *)
     if NICHTLESEN = 2 then
       begin
         CH := CH1 ;
         CH1 := CH2 ;
         NICHTLESEN := 1
       end (* then *)
     else
       if NICHTLESEN = 1 then
         begin
           CH := CH1 ;
           NICHTLESEN := 0
         end (* then *)
       else
         begin
           READCH ( CH ) ;
           if ZIFFERNGELESEN and ( CH = '.' ) then
             begin
               READCH ( CH2 ) ;
               if not ( CH2 in ZIFFERN ) then
                 begin
                   CH1 := CH ;
                   CH := ' ' ;
                   NICHTLESEN := 2
                 end (* then *)
               else
                 begin
                   CH1 := CH2 ;
                   NICHTLESEN := 1
                 end (* else *)
             end (* then *)
         end (* else *) ;
     W1INDEX := W1INDEX + 1 ;
     W1 [ W1INDEX ] := CH ;
     ZIFFERNGELESEN := ( CH in ZIFFERN ) ;
   end (* LIES *) ;



procedure LIESKOMM ( var CH : CHAR ) ;

   begin (* LIESKOMM *)
     READCH ( CH ) ;
     W1INDEX := W1INDEX + 1 ;
     W1 [ W1INDEX ] := CH ;
     ZIFFERNGELESEN := ( CH in ZIFFERN ) ;
   end (* LIESKOMM *) ;



procedure NEUZEILEKOMM ( BLANKS : BOOLEAN ) ;

   var EIN : INTEGER ;

   begin (* NEUZEILEKOMM *)
     EIN := EINRKOMM ;
     if EIN > MAXEINR then
       EIN := MAXEINR ;
     WRITELN ( AUSGABE ) ;
     ZZAUS := ZZAUS + 1 ;
     if BLANKS then
       begin
         if EIN > 0 then
           WRITE ( AUSGABE , ' ' : EIN ) ;
         OUTPOINTER := EIN
       end (* then *)
     else
       OUTPOINTER := 0 ;
     BLANKSVORHANDEN := FALSE ;
   end (* NEUZEILEKOMM *) ;



procedure KOMMENDEKASTEN ;

   var I : INTEGER ;
       KOMMTYPE : CHAR ;

   begin (* KOMMENDEKASTEN *)
     if ENDEKASTEN <> ' ' then
       begin
         KOMMTYPE := ENDEKASTEN ;
         if ENDEKOMMEIN <> 0 then
           WRITE ( AUSGABE , ' ' : ENDEKOMMEIN ) ;
         case KOMMTYPE of
           ')' : WRITE ( AUSGABE , '(*' ) ;
           '/' : WRITE ( AUSGABE , '/*' ) ;
           '}' : WRITE ( AUSGABE , '(*' ) ;
           '"' : WRITE ( AUSGABE , '"' ) ;
         end (* case *) ;
         for I := 1 to KOMMLAENGE - 4 do
           WRITE ( AUSGABE , '*' ) ;
         if KOMMTYPE = '"' then
           WRITE ( AUSGABE , '**' ) ;
         case KOMMTYPE of
           ')' : WRITE ( AUSGABE , '*)' ) ;
           '/' : WRITE ( AUSGABE , '*/' ) ;
           '}' : WRITE ( AUSGABE , '*)' ) ;
           '"' : WRITE ( AUSGABE , '"' ) ;
         end (* case *) ;
         WRITELN ( AUSGABE ) ;
         ZZAUS := ZZAUS + 1 ;
         ENDEKASTEN := ' '
       end (* then *) ;
   end (* KOMMENDEKASTEN *) ;



procedure READKOMM ( var KOMMC : KOMMCTL ) ;

   var CH : CHAR ;
       I : INTEGER ;

   begin (* READKOMM *)
     KOMMC . KOMML := 0 ;
     case KOMMC . KOMMTYPE of
       ')' : begin
               KOMMC . KOMMP [ 1 ] := '(' ;
               KOMMC . KOMMP [ 2 ] := '*' ;
               KOMMC . KOMML := 2 ;
             end (* tag/ca *) ;
       '/' : begin
               KOMMC . KOMMP [ 1 ] := '/' ;
               KOMMC . KOMMP [ 2 ] := '*' ;
               KOMMC . KOMML := 2 ;
             end (* tag/ca *) ;
       '}' : begin
               KOMMC . KOMMP [ 1 ] := '(' ;
               KOMMC . KOMMP [ 2 ] := '*' ;
               KOMMC . KOMML := 2 ;
             end (* tag/ca *) ;
       '"' : begin
               KOMMC . KOMMP [ 1 ] := '"' ;
               KOMMC . KOMML := 1 ;
             end (* tag/ca *) ;
     end (* case *) ;

     (************************************************)
     (*   HIER WERDEN DIE ERSTEN 100 ZEICHEN         *)
     (*   IN DEN KOMMPUFFER EINGETRAGEN              *)
     (************************************************)

     KOMMC . ENDOFKOMM := FALSE ;
     case KOMMC . KOMMTYPE of
       ')' : begin
               repeat
                 READCH ( CH ) ;
                 KOMMC . KOMML := KOMMC . KOMML + 1 ;
                 KOMMC . KOMMP [ KOMMC . KOMML ] := CH ;
                 case KOMMC . ZUSTAND of
                   1 : begin
                         if CH = '*' then
                           KOMMC . ZUSTAND := 2
                         else
                           if CH = '(' then
                             KOMMC . ZUSTAND := 3
                       end (* tag/ca *) ;
                   2 : begin
                         if CH = '*' then
                           KOMMC . ZUSTAND := 2
                         else
                           if CH = ')' then
                             begin
                               KOMMC . ANZKOMM := KOMMC . ANZKOMM - 1 ;
                               if KOMMC . ANZKOMM <= 0 then
                                 KOMMC . ENDOFKOMM := TRUE
                               else
                                 KOMMC . ZUSTAND := 1
                             end (* then *)
                           else
                             KOMMC . ZUSTAND := 1
                       end (* tag/ca *) ;
                   3 : begin
                         if CH = '*' then
                           begin
                             KOMMC . ZUSTAND := 1 ;
                             KOMMC . ANZKOMM := KOMMC . ANZKOMM + 1
                           end (* then *)
                         else
                           KOMMC . ZUSTAND := 1
                       end (* tag/ca *) ;
                 end (* case *)
               until ( KOMMC . KOMML >= 98 ) or KOMMC . ENDOFKOMM or
               EOLN ( EINGABE ) ;
             end (* tag/ca *) ;
       '/' : begin
               repeat
                 READCH ( CH ) ;
                 KOMMC . KOMML := KOMMC . KOMML + 1 ;
                 KOMMC . KOMMP [ KOMMC . KOMML ] := CH ;
                 case KOMMC . ZUSTAND of
                   1 : begin
                         if CH = '*' then
                           KOMMC . ZUSTAND := 2
                         else
                           if CH = '/' then
                             KOMMC . ZUSTAND := 3
                       end (* tag/ca *) ;
                   2 : begin
                         if CH = '*' then
                           KOMMC . ZUSTAND := 2
                         else
                           if CH = '/' then
                             begin
                               KOMMC . ANZKOMM := KOMMC . ANZKOMM - 1 ;
                               if KOMMC . ANZKOMM <= 0 then
                                 KOMMC . ENDOFKOMM := TRUE
                               else
                                 KOMMC . ZUSTAND := 1
                             end (* then *)
                           else
                             KOMMC . ZUSTAND := 1
                       end (* tag/ca *) ;
                   3 : begin
                         if CH = '*' then
                           begin
                             KOMMC . ZUSTAND := 1 ;
                             KOMMC . ANZKOMM := KOMMC . ANZKOMM + 1
                           end (* then *)
                         else
                           KOMMC . ZUSTAND := 1
                       end (* tag/ca *) ;
                 end (* case *)
               until ( KOMMC . KOMML >= 98 ) or KOMMC . ENDOFKOMM or
               EOLN ( EINGABE ) ;
             end (* tag/ca *) ;
       '}' : begin
               repeat
                 READCH ( CH ) ;
                 KOMMC . KOMML := KOMMC . KOMML + 1 ;
                 KOMMC . KOMMP [ KOMMC . KOMML ] := CH ;
                 if CH = '}' then
                   begin
                     KOMMC . ANZKOMM := KOMMC . ANZKOMM - 1 ;
                     if KOMMC . ANZKOMM <= 0 then
                       KOMMC . ENDOFKOMM := TRUE ;
                     KOMMC . KOMMP [ KOMMC . KOMML ] := '*' ;
                     KOMMC . KOMML := KOMMC . KOMML + 1 ;
                     KOMMC . KOMMP [ KOMMC . KOMML ] := ')' ;
                   end (* then *)
                 else
                   if CH = '{' then
                     KOMMC . ANZKOMM := KOMMC . ANZKOMM + 1
               until ( KOMMC . KOMML >= 98 ) or KOMMC . ENDOFKOMM or
               EOLN ( EINGABE ) ;
             end (* tag/ca *) ;
       '"' : begin
               repeat
                 READCH ( CH ) ;
                 KOMMC . KOMML := KOMMC . KOMML + 1 ;
                 KOMMC . KOMMP [ KOMMC . KOMML ] := CH ;
                 KOMMC . ENDOFKOMM := ( CH = '"' ) ;
               until ( KOMMC . KOMML >= 98 ) or KOMMC . ENDOFKOMM or
               EOLN ( EINGABE ) ;
             end (* tag/ca *) ;
     end (* case *) ;
     if KOMMC . ENDOFKOMM then
       begin
         KOMMC . NURSTERNE := TRUE ;
         for I := 2 to KOMMC . KOMML - 1 do
           if KOMMC . KOMMP [ I ] <> '*' then
             begin
               KOMMC . NURSTERNE := FALSE ;
               break
             end (* then *)
       end (* then *) ;

     (************************************************)
     (*   TRACEAUSGABE                               *)
     (************************************************)
     (*                                              *)
     (*      WRITELN ( TRACE , KOMMC . KOMML : 4 ,   *)
     (*                KOMMC . ENDOFKOMM ,           *)
     (*                KOMMC . ANZKOMM : 4 ,         *)
     (*                KOMMC . ZUSTAND : 4 , ' ' ,   *)
     (*                KOMMC . KOMMTYPE , ' ' ,      *)
     (*                KOMMC . KOMMP ) ;             *)
     (*      WRITELN ( TRACE ,                       *)
     (*                'KOMMSTATUS NACH READKOMM = ' *)
     (*                , KOMMC . KOMMSTATUS ) ;      *)
     (*                                              *)
     (************************************************)
     (*   W1INDEX AUF NULL, WEIL NICHTS RELEVANTES   *)
     (*   GELESEN WURDE                              *)
     (************************************************)

     W1INDEX := 0 ;

     (************************************************)
     (*   MUSS MAN MACHEN, WEIL READCH VERWENDET     *)
     (*   WIRD                                       *)
     (************************************************)

   end (* READKOMM *) ;



procedure WRITEKOMM ( var KOMMC : KOMMCTL ; KOMMLAENGE : INTEGER ) ;

   var I : INTEGER ;
       X : INTEGER ;
       Y : INTEGER ;
       CH1 : CHAR ;
       CH2 : CHAR ;
       CH3 : CHAR ;
       FILLCH : CHAR ;

   begin (* WRITEKOMM *)
     while TRUE do
       begin
         if KOMMC . KOMML < KOMMLAENGE then
           begin
             if KOMMC . NURSTERNE then
               FILLCH := '*'
             else
               FILLCH := ' ' ;
             for I := KOMMC . KOMML + 1 to KOMMLAENGE do
               KOMMC . KOMMP [ I ] := FILLCH ;
             X := KOMMLAENGE ;
             case KOMMC . KOMMTYPE of
               ')' : begin
                       if KOMMC . ENDOFKOMM then
                         begin
                           KOMMC . KOMMP [ KOMMC . KOMML ] := FILLCH ;
                           KOMMC . KOMMP [ KOMMC . KOMML - 1 ] :=
                                                   FILLCH
                         end (* then *) ;
                       KOMMC . KOMMP [ X ] := ')' ;
                       KOMMC . KOMMP [ X - 1 ] := '*' ;
                     end (* tag/ca *) ;
               '/' : begin
                       if KOMMC . ENDOFKOMM then
                         begin
                           KOMMC . KOMMP [ KOMMC . KOMML ] := FILLCH ;
                           KOMMC . KOMMP [ KOMMC . KOMML - 1 ] :=
                                                   FILLCH
                         end (* then *) ;
                       KOMMC . KOMMP [ X ] := '/' ;
                       KOMMC . KOMMP [ X - 1 ] := '*' ;
                     end (* tag/ca *) ;
               '}' : begin
                       if KOMMC . ENDOFKOMM then
                         begin
                           KOMMC . KOMMP [ KOMMC . KOMML ] := FILLCH ;
                           KOMMC . KOMMP [ KOMMC . KOMML - 1 ] :=
                                                   FILLCH
                         end (* then *) ;
                       KOMMC . KOMMP [ X ] := ')' ;
                       KOMMC . KOMMP [ X - 1 ] := '*' ;
                     end (* tag/ca *) ;
               '"' : begin
                       if KOMMC . ENDOFKOMM then
                         begin
                           KOMMC . KOMMP [ KOMMC . KOMML ] := FILLCH
                         end (* then *) ;
                       KOMMC . KOMMP [ X ] := '"' ;
                     end (* tag/ca *) ;
             end (* case *) ;
           end (* then *) ;
         if KOMMC . KOMML > KOMMLAENGE then
           begin
             case KOMMC . KOMMTYPE of
               ')' : begin
                       X := KOMMLAENGE - 2 ;
                       CH1 := KOMMC . KOMMP [ X ] ;
                       CH2 := KOMMC . KOMMP [ X + 1 ] ;
                       CH3 := KOMMC . KOMMP [ X + 2 ] ;
                       KOMMC . KOMMP [ X ] := ' ' ;
                       KOMMC . KOMMP [ X + 1 ] := '*' ;
                       KOMMC . KOMMP [ X + 2 ] := ')' ;
                     end (* tag/ca *) ;
               '/' : begin
                       X := KOMMLAENGE - 2 ;
                       CH1 := KOMMC . KOMMP [ X ] ;
                       CH2 := KOMMC . KOMMP [ X + 1 ] ;
                       CH3 := KOMMC . KOMMP [ X + 2 ] ;
                       KOMMC . KOMMP [ X ] := ' ' ;
                       KOMMC . KOMMP [ X + 1 ] := '*' ;
                       KOMMC . KOMMP [ X + 2 ] := '/' ;
                     end (* tag/ca *) ;
               '}' : begin
                       X := KOMMLAENGE - 2 ;
                       CH1 := KOMMC . KOMMP [ X ] ;
                       CH2 := KOMMC . KOMMP [ X + 1 ] ;
                       CH3 := KOMMC . KOMMP [ X + 2 ] ;
                       KOMMC . KOMMP [ X ] := ' ' ;
                       KOMMC . KOMMP [ X + 1 ] := '*' ;
                       KOMMC . KOMMP [ X + 2 ] := ')' ;
                     end (* tag/ca *) ;
               '"' : begin
                       X := KOMMLAENGE ;
                       CH1 := KOMMC . KOMMP [ X ] ;
                       KOMMC . KOMMP [ X ] := '"' ;
                     end (* tag/ca *) ;
             end (* case *) ;
           end (* then *) ;
         for I := 1 to KOMMLAENGE do
           WRITE ( AUSGABE , KOMMC . KOMMP [ I ] ) ;
         if KOMMC . KOMML > KOMMLAENGE then
           begin
             NEUZEILEKOMM ( TRUE ) ;
             case KOMMC . KOMMTYPE of
               ')' : begin
                       KOMMC . KOMMP [ 1 ] := '(' ;
                       KOMMC . KOMMP [ 2 ] := '*' ;
                       KOMMC . KOMMP [ 3 ] := CH1 ;
                       KOMMC . KOMMP [ 4 ] := CH2 ;
                       KOMMC . KOMMP [ 5 ] := CH3 ;
                       X := 5 ;
                     end (* tag/ca *) ;
               '/' : begin
                       KOMMC . KOMMP [ 1 ] := '/' ;
                       KOMMC . KOMMP [ 2 ] := '*' ;
                       KOMMC . KOMMP [ 3 ] := CH1 ;
                       KOMMC . KOMMP [ 4 ] := CH2 ;
                       KOMMC . KOMMP [ 5 ] := CH3 ;
                       X := 5 ;
                     end (* tag/ca *) ;
               '}' : begin
                       KOMMC . KOMMP [ 1 ] := '(' ;
                       KOMMC . KOMMP [ 2 ] := '*' ;
                       KOMMC . KOMMP [ 3 ] := CH1 ;
                       KOMMC . KOMMP [ 4 ] := CH2 ;
                       KOMMC . KOMMP [ 5 ] := CH3 ;
                       X := 5 ;
                     end (* tag/ca *) ;
               '"' : begin
                       KOMMC . KOMMP [ 1 ] := '"' ;
                       KOMMC . KOMMP [ 2 ] := CH1 ;
                       X := 2 ;
                     end (* tag/ca *) ;
             end (* case *) ;
             Y := KOMMLAENGE + 1 ;
             for Y := KOMMLAENGE + 1 to KOMMC . KOMML do
               begin
                 X := X + 1 ;
                 KOMMC . KOMMP [ X ] := KOMMC . KOMMP [ Y ] ;
               end (* for *) ;
             KOMMC . KOMML := X ;
             continue ;
           end (* then *) ;
         if KOMMC . ENDOFKOMM then
           break ;
         NEUZEILEKOMM ( TRUE ) ;
         READKOMM ( KOMMC ) ;
       end (* while *)
   end (* WRITEKOMM *) ;



procedure KOMMENTAR ( var KOMMC : KOMMCTL ) ;

(********************************************************************)
(*                                                                  *)
(*   OKTOBER 2011: KOMMENTARLOGIK NEU - ZUSTANDSGETRIEBEN           *)
(*                                                                  *)
(*   KOMMKASTEN: BOOLEAN - LEGT FEST, OB WIR AKTUELL KASTEN         *)
(*   WOLLEN ODER NICHT                                              *)
(*                                                                  *)
(*   KOMMZUSTAND: ZUSTAND DER KOMMENTARBEARBEITUNG                  *)
(*                                                                  *)
(*   0 = AUSSERHALB VON KOMMENTAREN                                 *)
(*   1 = INNERHALB KOMMENTARKASTEN-BEARBEITUNG                      *)
(*   2 = NOCH UNKLAR                                                *)
(*                                                                  *)
(*   EINRKOMM: POSITION, AB DER KOMMENTAR BEGINNT                   *)
(*                                                                  *)
(*   ZUNAECHST EINLESEN DES KOMMENTARS ODER DER ERSTEN              *)
(*   100 ZEICHEN IN DEN BUFFER KOMMC.KOMMP                          *)
(*   WENN SICH DANN HERAUSSTELLT, DASS ES BEREITS EIN               *)
(*   KOMMENTARKASTEN-ANFANG IST, DESSEN LAENGE FESTHALTEN           *)
(*   UND DEN ZUSTAND BEIBEHALTEN                                    *)
(*                                                                  *)
(*   WENN NICHT: KOMMENTAR ENTSPRECHEND STUECKELN;                  *)
(*   MAXIMALE LAENGE ERGIBT SICH AUS EINRKOMM                       *)
(*                                                                  *)
(********************************************************************)


   var I : INTEGER ;
       DICHTSAVE : BOOLEAN ;
       KASTENEINFUEGEN : BOOLEAN ;

   begin (* KOMMENTAR *)
     KASTENEINFUEGEN := FALSE ;
     KOMMC . ENDOFKOMM := FALSE ;
     KOMMC . ANZKOMM := 1 ;
     KOMMC . ZUSTAND := 1 ;
     KOMMC . NURSTERNE := FALSE ;
     READKOMM ( KOMMC ) ;

     (************************************************)
     (*   ABKLAEREN, OB KOMMENTAR UEBERLESEN WERDEN  *)
     (*   MUSS                                       *)
     (************************************************)

     DICHTSAVE := DICHT ;
     if KOMMC . UEBERLESEN <> 0 then
       DICHT := TRUE ;
     if KOMMC . KOMMTYPE = '"' then
       if KOMMC . KOMML <= 4 then
         DICHT := TRUE ;

     (************************************************)
     (*   DICHT = KOMMENTAR UEBERLESEN               *)
     (************************************************)

     if DICHT then
       begin
         while not KOMMC . ENDOFKOMM do
           READKOMM ( KOMMC )
       end (* then *)
     else
       begin
         if KOMMC . KOMM_VOR_PROC then
           begin
             NEUZEILEKOMM ( FALSE ) ;
             NEUZEILEKOMM ( FALSE ) ;
             NEUZEILEKOMM ( FALSE ) ;
             NEUZEILEKOMM ( FALSE ) ;
             KOMMC . KOMM_VOR_PROC := FALSE ;
           end (* then *) ;
         case KOMMC . KOMMSTATUS of
           0 : begin
                 if MODUS > 2 then
                   begin
                     NEUZEILEKOMM ( FALSE ) ;
                     NEUZEILEKOMM ( TRUE ) ;
                   end (* then *) ;
                 if MODUS = 2 then
                   NEUZEILEKOMM ( TRUE ) ;

     (************************************************)
     (*   SCHAUEN, OB KASTEN EINGEFUEGT WERDEN MUSS  *)
     (************************************************)

                 KASTENEINFUEGEN := not KOMMC . NURSTERNE ;

     (************************************************)
     (*   WENN KOMMENTAR NICHT PASST, WIRD AUF       *)
     (*   JEDEN FALL EIN KASTEN EINGEFUEGT           *)
     (************************************************)

                 if KOMMC . KOMML > 72 - EINRKOMM then
                   KASTENEINFUEGEN := TRUE ;

     (************************************************)
     (*   NEUER KOMMC.KOMMSTATUS ABH. VOM KASTEN     *)
     (************************************************)

                 if KASTENEINFUEGEN then
                   KOMMC . KOMMSTATUS := 1
                 else
                   KOMMC . KOMMSTATUS := 2 ;

     (************************************************)
     (*   KOMMLAENGE FESTLEGEN                       *)
     (************************************************)

                 KOMMLAENGE := KOMMC . KOMML ;
                 if not KOMMC . ENDOFKOMM then
                   KOMMLAENGE := KOMMLAENGE + 3 ;
                 if KOMMLAENGE < 10 then
                   KOMMLAENGE := 10 ;
                 if KOMMC . KOMML > 72 - EINRKOMM then
                   KOMMLAENGE := 72 - EINRKOMM ;
               end (* tag/ca *) ;
           1 : begin
                 if MODUS >= 2 then
                   NEUZEILEKOMM ( TRUE ) ;
               end (* tag/ca *) ;
           2 : begin
                 if MODUS >= 2 then
                   NEUZEILEKOMM ( TRUE ) ;
               end (* tag/ca *) ;
         end (* case *) ;

     (************************************************)
     (*   AUSGEBEN DES KOMMENTARS                    *)
     (************************************************)

         if KASTENEINFUEGEN then
           begin
             ENDEKASTEN := KOMMC . KOMMTYPE ;
             ENDEKOMMEIN := EINRKOMM ;
             case KOMMC . KOMMTYPE of
               ')' : WRITE ( AUSGABE , '(*' ) ;
               '/' : WRITE ( AUSGABE , '/*' ) ;
               '}' : WRITE ( AUSGABE , '(*' ) ;
               '"' : WRITE ( AUSGABE , '"' ) ;
             end (* case *) ;
             for I := 1 to KOMMLAENGE - 4 do
               WRITE ( AUSGABE , '*' ) ;
             if KOMMC . KOMMTYPE = '"' then
               WRITE ( AUSGABE , '**' ) ;
             case KOMMC . KOMMTYPE of
               ')' : WRITE ( AUSGABE , '*)' ) ;
               '/' : WRITE ( AUSGABE , '*/' ) ;
               '}' : WRITE ( AUSGABE , '*)' ) ;
               '"' : WRITE ( AUSGABE , '"' ) ;
             end (* case *) ;
             NEUZEILEKOMM ( TRUE ) ;
           end (* then *) ;
         WRITEKOMM ( KOMMC , KOMMLAENGE ) ;
       end (* else *) ;
     DICHT := DICHTSAVE ;
   end (* KOMMENTAR *) ;



procedure INSYMBOL ( var S : SYMBOL ) ;

   var CH : CHAR ;
       KOMMENTFOUND : BOOLEAN ;
       ZIFFERNLESEN : BOOLEAN ;

   begin (* INSYMBOL *)
     NULLSTATE := FALSE ;
     repeat
       KOMMENTFOUND := FALSE ;
       if W1INDEX = 0 then
         LIES ( CH )
       else
         begin
           W1INDEX := W1ENDE + 1 ;
           W1 [ 1 ] := W1 [ W1INDEX ] ;
           CH := W1 [ W1INDEX ] ;
           W1INDEX := 1
         end (* else *) ;

     (************************************************)
     (*   BLANKS USW. UEBERLESEN                     *)
     (************************************************)

       while ( ( CH = ' ' ) or ( CH = CHR ( 10 ) ) or ( CH = CHR ( 13 )
       ) or ( CH = '#' ) ) and not EOFILE do
         begin

     (************************************************)
     (*   NACH EINER LEERZEILE KOMMENTARE            *)
     (*   NICHT MEHR UEBERLESEN                      *)
     (************************************************)

           if KOMMC . UEBERLESEN = 2 then
             if INPOINTER = 1 then
               KOMMC . UEBERLESEN := 0 ;
           W1INDEX := 0 ;
           LIES ( CH )
         end (* while *) ;
       if CH = ' ' then
         S := EOFSY
       else
         if CH in ISTARTSET then
           begin
             repeat
               LIES ( CH ) ;
             until not ( CH in IWEITERSET ) ;
             W1ENDE := W1INDEX - 1 ;
             RESWRD ( S )
           end (* then *)
         else
           if CH in ( ZIFFERN + [ '#' ] ) then
             begin

     (************************************************)
     (*   auch 0x... hex darstellung zulassen        *)
     (*   Exponent E gross oder klein schreiben      *)
     (************************************************)

               repeat
                 ZIFFERNLESEN := TRUE ;
                 if CH = '0' then
                   begin
                     LIES ( CH ) ;
                     if not ( CH in ( ZIFFERN + [ 'e' , 'E' , '.' , 'X'
                     , 'x' ] ) ) then
                       break ;
                     if CH in [ 'X' , 'x' ] then
                       begin
                         repeat
                           LIES ( CH )
                         until not ( CH in ( ZIFFERN + [ 'A' .. 'F' ,
                         'a' .. 'f' ] ) ) ;
                         break ;
                       end (* then *) ;
                     if CH in [ 'e' , 'E' , '.' ] then
                       ZIFFERNLESEN := FALSE ;
                   end (* then *) ;
                 if ZIFFERNLESEN then
                   repeat
                     LIES ( CH )
                   until not ( CH in ZIFFERN ) ;
                 if CH = '.' then
                   repeat
                     LIES ( CH )
                   until not ( CH in ZIFFERN ) ;
                 if ( CH = 'E' ) or ( CH = 'e' ) then
                   begin
                     LIES ( CH ) ;
                     if ( CH = '+' ) or ( CH = '-' ) then
                       LIES ( CH ) ;
                     repeat
                       LIES ( CH )
                     until not ( CH in ZIFFERN )
                   end (* then *)
               until TRUE ;
               S := ZAHL
             end (* then *)
           else
             if CH = '$' then
               begin
                 repeat
                   LIES ( CH )
                 until not ( CH in HEXZIFFERN ) ;
                 S := ZAHL
               end (* then *)
             else
               if CH = '''' then
                 begin
                   repeat
                     NOMAJOR := TRUE ;
                     repeat
                       LIESKOMM ( CH )
                     until CH = '''' ;
                     NOMAJOR := FALSE ;
                     LIES ( CH )
                   until CH <> '''' ;
                   S := ZKETTE
                 end (* then *)
               else
                 begin
                   if CH = '{' then
                     begin
                       NOMAJOR := TRUE ;
                       KOMMC . KOMMTYPE := '}' ;
                       KOMMENTAR ( KOMMC ) ;
                       NOMAJOR := FALSE ;
                       KOMMENTFOUND := TRUE
                     end (* then *)
                   else
                     if CH = '"' then
                       begin
                         NOMAJOR := TRUE ;
                         KOMMC . KOMMTYPE := '"' ;
                         KOMMENTAR ( KOMMC ) ;
                         NOMAJOR := FALSE ;
                         KOMMENTFOUND := TRUE
                       end (* then *)
                     else
                       if CH = '(' then
                         begin
                           LIES ( CH ) ;
                           if CH = '*' then
                             begin
                               NOMAJOR := TRUE ;
                               KOMMC . KOMMTYPE := ')' ;
                               KOMMENTAR ( KOMMC ) ;
                               NOMAJOR := FALSE ;
                               KOMMENTFOUND := TRUE
                             end (* then *)
                           else
                             begin
                               S := KLAMMAUF ;
                               if ( CH = '.' ) or ( CH = '/' ) then
                                 begin
                                   S := ECKKLAMMAUF ;
                                   LIES ( CH ) ;
                                 end (* then *)
                             end (* else *)
                         end (* then *)
                       else
                         if CH = '/' then
                           begin
                             LIES ( CH ) ;
                             if CH = '*' then
                               begin
                                 NOMAJOR := TRUE ;
                                 KOMMC . KOMMTYPE := '/' ;
                                 KOMMENTAR ( KOMMC ) ;
                                 NOMAJOR := FALSE ;
                                 KOMMENTFOUND := TRUE
                               end (* then *)
                             else
                               begin
                                 S := SONDER ;
                                 if CH = ')' then
                                   begin
                                     S := ECKKLAMMZU ;
                                     LIES ( CH ) ;
                                   end (* then *)
                               end (* else *)
                           end (* then *)
                         else
                           begin
                             S := SONDER ;
                             if ( CH in SONDERZEICHEN ) then
                               case CH of
                                 '@' : begin
                                         S := POINTERSY ;
                                         LIES ( CH )
                                       end (* tag/ca *) ;
                                 '[' : begin
                                         S := ECKKLAMMAUF ;
                                         LIES ( CH )
                                       end (* tag/ca *) ;
                                 ']' : begin
                                         S := ECKKLAMMZU ;
                                         LIES ( CH )
                                       end (* tag/ca *) ;
                                 '^' : begin
                                         S := POINTERSY ;
                                         LIES ( CH )
                                       end (* tag/ca *) ;
                                 '*' : begin
                                         LIES ( CH )
                                       end (* tag/ca *) ;
                                 ')' : begin
                                         LIES ( CH ) ;
                                         S := KLAMMZU
                                       end (* tag/ca *) ;
                                 '-' : begin
                                         LIES ( CH ) ;
                                         if CH = '>' then
                                           begin
                                             S := POINTERSY ;
                                             LIES ( CH )
                                           end (* then *)
                                       end (* tag/ca *) ;
                                 '+' : begin
                                         LIES ( CH )
                                       end (* tag/ca *) ;
                                 '=' : begin
                                         LIES ( CH ) ;
                                         S := GLEICH
                                       end (* tag/ca *) ;
                                 ':' : begin
                                         LIES ( CH ) ;
                                         S := DOPU ;
                                         if CH = '=' then
                                           begin
                                             S := ZUWEISUNG ;
                                             LIES ( CH )
                                           end (* then *)
                                       end (* tag/ca *) ;
                                 ';' : begin
                                         LIES ( CH ) ;
                                         S := STRIPU
                                       end (* tag/ca *) ;
                                 ',' : begin
                                         LIES ( CH )
                                       end (* tag/ca *) ;
                                 '.' : begin
                                         LIES ( CH ) ;
                                         if CH = '.' then
                                           LIES ( CH )
                                         else
                                           if CH = ')' then
                                             begin
                                               S := ECKKLAMMZU ;
                                               LIES ( CH )
                                             end (* then *)
                                       end (* tag/ca *) ;
                                 '>' : begin
                                         LIES ( CH ) ;
                                         if CH = '=' then
                                           LIES ( CH )
                                       end (* tag/ca *) ;
                                 '<' : begin
                                         LIES ( CH ) ;
                                         if CH = '=' then
                                           LIES ( CH )
                                         else
                                           if CH = '>' then
                                             LIES ( CH )
                                       end (* tag/ca *) ;
                                 '!' : begin
                                         LIES ( CH ) ;
                                         if CH = '!' then
                                           LIES ( CH )
                                       end (* tag/ca *) ;
                                 VERKETT2 :
                                   begin
                                     LIES ( CH ) ;
                                     if CH = VERKETT2 then
                                       LIES ( CH )
                                   end (* tag/ca *) ;
                                 '%' : begin
                                         if not DICHT then
                                           if KOMMC . KOMMSTATUS = 1
                                           then
                                             begin
                                               NEUZEILEKOMM ( FALSE ) ;
                                               KOMMENDEKASTEN ;
                                               KOMMC . KOMMSTATUS := 0
                                                   ;
                                               if MODUS > 2 then
                                                 NEUZEILEKOMM ( FALSE )
                                                   ;
                                             end (* then *)
                                           else
                                             begin
                                               NEUZEILEKOMM ( FALSE ) ;
                                               if MODUS > 2 then
                                                 NEUZEILEKOMM ( FALSE )
                                                   ;
                                             end (* else *)
                                         else
                                           NEUZEILEKOMM ( FALSE ) ;
                                         WRITE ( AUSGABE , CH ) ;
                                         NOMAJOR := TRUE ;
                                         repeat
                                           READCH ( CH ) ;
                                           WRITE ( AUSGABE , CH ) ;
                                         until EOLN ( EINGABE ) or (
                                         INPOINTER = 0 ) ;
                                         NOMAJOR := FALSE ;
                                         OUTPOINTER := MAXLOUTPUT + 1 ;
                                         KOMMENTFOUND := TRUE ;
                                         W1INDEX := 0
                                       end (* tag/ca *)
                               end (* case *)
                             else
                               LIES ( CH )
                           end (* else *)
                 end (* else *)
     until not KOMMENTFOUND ;
     KOMMC . UEBERLESEN := 0 ;
     W1ENDE := W1INDEX - 1 ;
   end (* INSYMBOL *) ;



procedure NEUZEILE ( BLANKS : BOOLEAN ) ;

   var EIN : INTEGER ;

   begin (* NEUZEILE *)
     EIN := EINR ;
     if EIN > MAXEINR then
       EIN := MAXEINR ;
     if not DICHT then
       begin
         if KOMMC . KOMMSTATUS = 1 then
           begin
             NEUZEILEKOMM ( FALSE ) ;
             KOMMENDEKASTEN ;
           end (* then *)
         else
           if KOMMC . KOMMSTATUS = 2 then
             begin
               WRITELN ( AUSGABE ) ;
               ZZAUS := ZZAUS + 1 ;
             end (* then *) ;
       end (* then *) ;
     KOMMC . KOMMSTATUS := 0 ;
     WRITELN ( AUSGABE ) ;
     ZZAUS := ZZAUS + 1 ;
     if BLANKS then
       begin
         if EIN > 0 then
           WRITE ( AUSGABE , ' ' : EIN ) ;
         OUTPOINTER := EIN
       end (* then *)
     else
       OUTPOINTER := 0 ;
     BLANKSVORHANDEN := FALSE ;
   end (* NEUZEILE *) ;



procedure PLATZZEILE ( PLATZBEDARF : INTEGER ) ;

   var EIN : INTEGER ;

   begin (* PLATZZEILE *)
     EIN := EINR ;
     if EIN > MAXEINR then
       EIN := MAXEINR ;
     if PLATZBEDARF > MAXLOUTPUT then
       begin
         WRITELN ( '+++ Zkette passt nicht in Zeile' ) ;
         HALTX
       end (* then *)
     else
       if EIN + PLATZBEDARF < MAXLOUTPUT then
         NEUZEILE ( TRUE )
       else
         begin
           WRITELN ( AUSGABE ) ;
           ZZAUS := ZZAUS + 1 ;
           if MAXLOUTPUT - PLATZBEDARF - 1 > 0 then
             WRITE ( AUSGABE , ' ' : MAXLOUTPUT - PLATZBEDARF - 1 ) ;
           OUTPOINTER := MAXLOUTPUT - PLATZBEDARF - 1 ;
           BLANKSVORHANDEN := FALSE ;
         end (* else *)
   end (* PLATZZEILE *) ;



procedure OUTSYMBOL ( S : SYMBOL ) ;

   var I : INTEGER ;
       PLATZBEDARF : INTEGER ;
       CH : CHAR ;

   begin (* OUTSYMBOL *)
     if not DICHT then
       if KOMMC . KOMMSTATUS > 0 then
         begin
           if KOMMC . KOMMSTATUS = 1 then
             begin
               NEUZEILEKOMM ( FALSE ) ;
               KOMMENDEKASTEN ;
             end (* then *)
           else
             if KOMMC . KOMMSTATUS = 2 then
               begin
                 WRITELN ( AUSGABE ) ;
                 ZZAUS := ZZAUS + 1 ;
               end (* then *) ;
           if MODUS > 2 then
             NEUZEILE ( TRUE )
           else
             if not DICHT then
               WRITE ( AUSGABE , ' ' )
         end (* then *) ;
     KOMMC . KOMMSTATUS := 0 ;

     (*****************************)
     (* SYMBOLE GGF. MODIFIZIEREN *)
     (*****************************)

     if S in [ POINTERSY , ECKKLAMMAUF , ECKKLAMMZU ] then
       begin
         case S of
           POINTERSY :
             begin
               W1 [ 3 ] := W1 [ W1INDEX ] ;
               W1 [ 1 ] := '-' ;
               W1 [ 2 ] := '>' ;
               W1ENDE := 2 ;
             end (* tag/ca *) ;
           ECKKLAMMAUF :
             begin
               W1 [ 2 ] := W1 [ W1INDEX ] ;
               W1 [ 1 ] := '[' ;
               W1ENDE := 1 ;
             end (* tag/ca *) ;
           ECKKLAMMZU :
             begin
               W1 [ 2 ] := W1 [ W1INDEX ] ;
               W1 [ 1 ] := ']' ;
               W1ENDE := 1 ;
             end (* tag/ca *)
         end (* case *)
       end (* then *) ;
     if not DICHT then
       begin
         PLATZBEDARF := OUTPOINTER + W1ENDE + 1 ;
         if ( S = DOPU ) and INSQLSTATE then
           PLATZBEDARF := PLATZBEDARF + 8 ;
         if PLATZBEDARF > MAXLOUTPUT then
           PLATZZEILE ( PLATZBEDARF - OUTPOINTER ) ;
         if not INSQLSTATE then
           if S in WORTSYMBOLE then
             for I := 1 to W1ENDE do
               begin
                 CH := W1 [ I ] ;
                 CH := MINOR ( CH ) ;
                 W1 [ I ] := CH ;
               end (* for *) ;
         if ZZAUSVOR = ZZAUS then
           if not SQLHOSTV then
             WRITE ( AUSGABE , ' ' )
           else
             OUTPOINTER := OUTPOINTER - 1 ;
         ZZAUSVOR := ZZAUS ;
         for I := 1 to W1ENDE do
           WRITE ( AUSGABE , W1 [ I ] ) ;
         SQLHOSTV := ( S = DOPU ) and INSQLSTATE ;
         OUTPOINTER := OUTPOINTER + W1ENDE + 1
       end (* then *)
     else
       begin
         PLATZBEDARF := OUTPOINTER + W1ENDE ;
         if ( BLANKSVORHANDEN and ( S in BLANKSYMBOLE ) ) then
           PLATZBEDARF := PLATZBEDARF + 1 ;
         if PLATZBEDARF > MAXLOUTPUT then
           PLATZZEILE ( PLATZBEDARF - OUTPOINTER ) ;
         if ( BLANKSVORHANDEN and ( S in BLANKSYMBOLE ) ) then
           begin
             WRITE ( AUSGABE , ' ' ) ;
             OUTPOINTER := OUTPOINTER + 1
           end (* then *) ;
         if not INSQLSTATE then
           if S in WORTSYMBOLE then
             for I := 1 to W1ENDE do
               begin
                 CH := W1 [ I ] ;
                 CH := MINOR ( CH ) ;
                 W1 [ I ] := CH ;
               end (* for *) ;
         for I := 1 to W1ENDE do
           WRITE ( AUSGABE , W1 [ I ] ) ;
         OUTPOINTER := OUTPOINTER + W1ENDE ;
         BLANKSVORHANDEN := ( S in BLANKSYMBOLE )
       end (* else *)
   end (* OUTSYMBOL *) ;



procedure STRIPUTEST ;

   begin (* STRIPUTEST *)
     if S = STRIPU then
       begin
         OUTSYMBOL ( S ) ;
         repeat
           INSYMBOL ( S )
         until S <> STRIPU
       end (* then *)
   end (* STRIPUTEST *) ;



procedure KOMM_ZWISCHEN_PROCS ( BLOCKLEVEL : INTEGER ) ;

   var EINRKOMMSAVE : INTEGER ;

   begin (* KOMM_ZWISCHEN_PROCS *)
     EINRKOMMSAVE := EINRKOMM ;
     if BLOCKLEVEL <= 2 then
       begin
         KOMMC . KOMM_VOR_PROC := TRUE ;
         EINRKOMM := 0 ;
       end (* then *) ;
     if S = STRIPU then
       begin
         OUTSYMBOL ( S ) ;
         repeat
           INSYMBOL ( S ) ;
         until S <> STRIPU
       end (* then *) ;
     KOMMC . KOMM_VOR_PROC := FALSE ;
     EINRKOMM := EINRKOMMSAVE ;
   end (* KOMM_ZWISCHEN_PROCS *) ;



procedure SQLSTATE ;

   var EINRSAVE : INTEGER ;
       EINRZWEI : INTEGER ;

   begin (* SQLSTATE *)
     KOMMC . UEBERLESEN := 1 ;
     EINRSAVE := EINR ;
     EINR := EINR + 9 ;
     EINRZWEI := EINR ;
     OUTSYMBOL ( S ) ;
     INSQLSTATE := TRUE ;
     INSYMBOL ( S ) ;
     EINR := EINR + W1ENDE + 1 ;
     OUTSYMBOL ( S ) ;
     INSYMBOL ( S ) ;
     repeat
       if RESWRDSQL then
         begin

     (************************************************)
     (*   W1ENDE ENTHAELT DIE ANZAHL DER ZEICHEN     *)
     (*   DES ZULETZT GELESENEN WORTES.              *)
     (************************************************)

           EINR := EINRZWEI ;
           NEUZEILE ( TRUE ) ;
           EINR := EINR + W1ENDE + 1
         end (* then *) ;
       OUTSYMBOL ( S ) ;
       INSYMBOL ( S ) ;
       if S = EOFSY then
         begin
           WRITELN ( '+++ Warnung: Dateiende innerhalb SQL-Einschub.' )
                     ;
           HALTX
         end (* then *) ;
       if S = STRIPU then
         WRITELN ( '+++ Warnung: Strichpunkt in SQL-Einschub.' ) ;
     until ( S = SQLENDSY ) or ( S = STRIPU ) ;
     EINR := EINRZWEI ;
     EINR := EINR - 9 ;
     INSQLSTATE := FALSE ;
     if S <> STRIPU then
       begin
         NEUZEILE ( TRUE ) ;
         OUTSYMBOL ( S ) ;
         INSYMBOL ( S ) ;
       end (* then *) ;
     STRIPUTEST ;
     EINR := EINRSAVE ;
     KOMMC . UEBERLESEN := 0 ;
   end (* SQLSTATE *) ;



procedure CSIMPSTATE ;

   var EINRSAVE : INTEGER ;


   procedure CSFEHLERTEST ;

      begin (* CSFEHLERTEST *)
        if S in WORTSYMBOLE - EXPRSYMBOLE - STERMSYMBOLE then
          begin
            OUTSYMBOL ( S ) ;
            WRITELN ( '+++ Syntaxfehler festgestellt.' ) ;
            HALTX
          end (* then *)
      end (* CSFEHLERTEST *) ;


   begin (* CSIMPSTATE *)
     EINRSAVE := EINR ;
     repeat
       OUTSYMBOL ( S ) ;
       INSYMBOL ( S ) ;
       CSFEHLERTEST
     until ( S = ZUWEISUNG ) or ( S = KLAMMAUF ) or ( S in STERMSYMBOLE
     ) ;
     if not ( S in STERMSYMBOLE ) then
       begin
         OUTSYMBOL ( S ) ;
         EINR := OUTPOINTER ;
         INSYMBOL ( S ) ;
         while not ( S in STERMSYMBOLE ) do
           begin
             CSFEHLERTEST ;
             OUTSYMBOL ( S ) ;
             INSYMBOL ( S )
           end (* while *)
       end (* then *) ;
     STRIPUTEST ;
     EINR := EINRSAVE
   end (* CSIMPSTATE *) ;



procedure CTYPE ;

   var EINRSAVE : INTEGER ;
       ANZKLAMAUF : INTEGER ;


   procedure FIELDLIST ( VORSCHUB : BOOLEAN ) ;

      var EINRS2 : INTEGER ;
          VS : BOOLEAN ;

      begin (* FIELDLIST *)
        VS := VORSCHUB ;
        while ( S <> ENDSY ) and ( S <> KLAMMZU ) do
          begin
            if VS then
              NEUZEILE ( TRUE ) ;
            VS := TRUE ;
            if S = CASESY then
              begin
                repeat
                  OUTSYMBOL ( S ) ;
                  INSYMBOL ( S )
                until S = OFSY ;
                OUTSYMBOL ( S ) ;
                EINR := EINR + INC ;
                INSYMBOL ( S ) ;
                repeat
                  if ( S <> ENDSY ) and ( S <> KLAMMZU ) then
                    begin
                      if S = STRIPU then
                        begin
                          NEUZEILE ( TRUE ) ;
                          OUTSYMBOL ( S ) ;
                          INSYMBOL ( S )
                        end (* then *)
                      else
                        begin
                          NEUZEILE ( TRUE ) ;
                          repeat
                            OUTSYMBOL ( S ) ;
                            INSYMBOL ( S ) ;
                          until S = KLAMMAUF ;
                          EINRS2 := EINR ;
                          EINR := EINR + INC ;
                          NEUZEILE ( TRUE ) ;
                          OUTSYMBOL ( S ) ;
                          EINR := EINR + INC ;
                          INSYMBOL ( S ) ;
                          repeat
                            if S <> KLAMMZU then
                              FIELDLIST ( FALSE ) ;
                            if S <> KLAMMZU then
                              NEUZEILE ( TRUE )
                          until S = KLAMMZU ;
                          OUTSYMBOL ( S ) ;
                          INSYMBOL ( S ) ;
                          STRIPUTEST ;
                          EINR := EINRS2
                        end (* else *)
                    end (* then *)
                until ( S = ENDSY ) or ( S = KLAMMZU ) ;
                EINR := EINR - INC
              end (* then *)
            else
              begin
                repeat
                  OUTSYMBOL ( S ) ;
                  INSYMBOL ( S )
                until S = DOPU ;
                OUTSYMBOL ( S ) ;
                INSYMBOL ( S ) ;
                CTYPE ;
                STRIPUTEST
              end (* else *)
          end (* while *)
      end (* FIELDLIST *) ;


   begin (* CTYPE *)
     if S <> ENDSY then
       begin
         EINRSAVE := EINR ;
         EINR := OUTPOINTER ;
         ANZKLAMAUF := 0 ;
         if S = KLAMMAUF then
           begin
             TTERMSYMBOLE := TTERMSYMBOLE - [ KLAMMZU ] ;
             ANZKLAMAUF := ANZKLAMAUF + 1 ;
           end (* then *) ;
         while not ( S in TTERMSYMBOLE ) do
           begin
             OUTSYMBOL ( S ) ;
             INSYMBOL ( S ) ;
             if S = KLAMMAUF then
               begin
                 TTERMSYMBOLE := TTERMSYMBOLE - [ KLAMMZU ] ;
                 ANZKLAMAUF := ANZKLAMAUF + 1 ;
               end (* then *) ;
             if S = KLAMMZU then
               begin
                 ANZKLAMAUF := ANZKLAMAUF - 1 ;
                 if ANZKLAMAUF < 0 then
                   TTERMSYMBOLE := TTERMSYMBOLE + [ KLAMMZU ] ;
               end (* then *) ;
           end (* while *) ;
         TTERMSYMBOLE := TTERMSYMBOLE + [ KLAMMZU ] ;
         if S = STRIPU then
           begin
             OUTSYMBOL ( S ) ;
             INSYMBOL ( S ) ;
             EINR := EINRSAVE ;
           end (* then *)
         else
           if S = RECORDSY then
             begin
               EINR := EINRSAVE ;
               EINRSAVE := EINR ;
               EINR := OUTPOINTER ;
               OUTSYMBOL ( S ) ;
               EINR := EINR + INC ;
               INSYMBOL ( S ) ;
               FIELDLIST ( TRUE ) ;
               EINR := EINR - INC ;
               NEUZEILE ( TRUE ) ;
               OUTSYMBOL ( S ) ;
               INSYMBOL ( S ) ;
               STRIPUTEST ;
               EINR := EINRSAVE ;
             end (* then *)
           else
             EINR := EINRSAVE
       end (* then *)
   end (* CTYPE *) ;



procedure CSTATE ( AUFNEUEZEILE : BOOLEAN ; KENNUNG : FELD6 ) ;

   var EINRSAVE : INTEGER ;
       LAUFX : INTEGER ;

   begin (* CSTATE *)
     if ( S = BEGINSY ) and not COMPOUNDNZ then
       AUFNEUEZEILE := FALSE ;
     if AUFNEUEZEILE then
       NEUZEILE ( TRUE ) ;

     (*********************************)
     (* leeres statement              *)
     (*********************************)

     if S = STRIPU then
       begin
         OUTSYMBOL ( S ) ;
         INSYMBOL ( S ) ;
         return
       end (* then *) ;

     (*********************************)
     (* prozeduraufruf                *)
     (*********************************)

     if S = IDENTIFIER then
       begin
         CSIMPSTATE ;
         return
       end (* then *) ;

     (*********************************)
     (* break (neu)                   *)
     (*********************************)

     if S = BREAKSY then
       begin
         CSIMPSTATE ;
         return
       end (* then *) ;

     (*********************************)
     (* continue (neu)                *)
     (*********************************)

     if S = CONTINUESY then
       begin
         CSIMPSTATE ;
         return
       end (* then *) ;

     (*********************************)
     (* return (neu)                  *)
     (*********************************)

     if S = RETURNSY then
       begin
         CSIMPSTATE ;
         return
       end (* then *) ;

     (*********************************)
     (* sql-Einschub                  *)
     (*********************************)

     if S = SQLBEGINSY then
       begin
         SQLSTATE ;
         return
       end (* then *) ;

     (*********************************)
     (* Statement mit label           *)
     (*********************************)

     if S = ZAHL then
       begin
         repeat
           OUTSYMBOL ( S ) ;
           INSYMBOL ( S )
         until S = DOPU ;
         OUTSYMBOL ( S ) ;
         INSYMBOL ( S ) ;
         CSTATE ( TRUE , '      ' ) ;
         return
       end (* then *) ;

     (*********************************)
     (* andere, je nach typ           *)
     (*********************************)

     if S = BEGINSY then
       begin
         OUTSYMBOL ( S ) ;
         if COMPOUNDNZ then
           EINR := EINR + INC ;
         INSYMBOL ( S ) ;
         repeat
           CSTATE ( TRUE , '      ' )
         until ( S in STERMSYMBOLE ) ;
         if COMPOUNDNZ then
           begin
             EINR := EINR - INC ;
             NEUZEILE ( TRUE ) ;
           end (* then *) ;
         OUTSYMBOL ( S ) ;
         if KENNUNG <> '      ' then
           begin
             if OUTPOINTER + 13 < MAXLOUTPUT then
               begin
                 WRITE ( AUSGABE , ' (* ' ) ;
                 for LAUFX := 1 to 6 do
                   if KENNUNG [ LAUFX ] <> ' ' then
                     WRITE ( AUSGABE , KENNUNG [ LAUFX ] ) ;
                 WRITE ( AUSGABE , ' *)' ) ;
                 OUTPOINTER := OUTPOINTER + 13
               end (* then *) ;
             KOMMC . UEBERLESEN := 2
           end (* then *) ;
         INSYMBOL ( S ) ;
         STRIPUTEST
       end (* then *)
     else
       if S = CASESY then
         begin
           repeat
             OUTSYMBOL ( S ) ;
             INSYMBOL ( S )
           until S = OFSY ;
           OUTSYMBOL ( S ) ;
           EINR := EINR + INC ;
           INSYMBOL ( S ) ;
           while not ( S in ( STERMSYMBOLE - [ ELSESY , OTHERWISESY ] )
           ) do
             begin
               NEUZEILE ( TRUE ) ;
               if S = ELSESY then
                 begin
                   OUTSYMBOL ( S ) ;
                   INSYMBOL ( S ) ;
                   EINR := EINR + INC ;
                   NEUZEILE ( TRUE ) ;
                   CSTATE ( FALSE , 'else/c' ) ;
                   EINR := EINR - INC ;
                 end (* then *)
               else
                 if S = OTHERWISESY then
                   begin
                     OUTSYMBOL ( S ) ;
                     INSYMBOL ( S ) ;
                     EINR := EINR + INC ;
                     NEUZEILE ( TRUE ) ;
                     CSTATE ( FALSE , 'otherw' ) ;
                     EINR := EINR - INC ;
                   end (* then *)
                 else
                   begin
                     while S <> DOPU do
                       begin
                         OUTSYMBOL ( S ) ;
                         INSYMBOL ( S )
                       end (* while *) ;
                     OUTSYMBOL ( S ) ;
                     if OUTPOINTER - EINR <= 8 then
                       begin
                         EINRSAVE := EINR ;
                         EINR := OUTPOINTER ;
                       end (* then *)
                     else
                       begin
                         EINRSAVE := EINR ;
                         EINR := EINR + INC ;
                         NEUZEILE ( TRUE ) ;
                       end (* else *) ;
                     INSYMBOL ( S ) ;
                     CSTATE ( FALSE , 'tag/ca' ) ;
                     EINR := EINRSAVE ;
                   end (* else *)
             end (* while *) ;
           EINR := EINR - INC ;
           NEUZEILE ( TRUE ) ;
           OUTSYMBOL ( S ) ;
           if OUTPOINTER + 11 < MAXLOUTPUT then
             begin
               WRITE ( AUSGABE , ' (* case *)' ) ;
               OUTPOINTER := OUTPOINTER + 11
             end (* then *) ;
           KOMMC . UEBERLESEN := 2 ;
           INSYMBOL ( S ) ;
           STRIPUTEST
         end (* then *)
       else
         if ( S = FORSY ) or ( S = WHILESY ) or ( S = WITHSY ) then
           begin
             if S = FORSY then
               KENNUNG := 'for   ' ;
             if S = WHILESY then
               KENNUNG := 'while ' ;
             if S = WITHSY then
               KENNUNG := 'with  ' ;
             repeat
               OUTSYMBOL ( S ) ;
               INSYMBOL ( S )
             until S = DOSY ;
             OUTSYMBOL ( S ) ;
             EINR := EINR + INC ;
             INSYMBOL ( S ) ;
             CSTATE ( TRUE , KENNUNG ) ;
             STRIPUTEST ;
             EINR := EINR - INC ;
           end (* then *)
         else
           if S = GOTOSY then
             CSIMPSTATE
           else
             if S = IFSY then
               begin
                 repeat
                   OUTSYMBOL ( S ) ;
                   INSYMBOL ( S )
                 until S = THENSY ;
                 OUTSYMBOL ( S ) ;
                 EINR := EINR + INC ;
                 INSYMBOL ( S ) ;
                 CSTATE ( TRUE , 'then  ' ) ;
                 EINR := EINR - INC ;
                 if S = ELSESY then
                   begin
                     NEUZEILE ( TRUE ) ;
                     OUTSYMBOL ( S ) ;
                     EINR := EINR + INC ;
                     INSYMBOL ( S ) ;
                     CSTATE ( TRUE , 'else  ' ) ;
                     STRIPUTEST ;
                     EINR := EINR - INC ;
                   end (* then *)
                 else
                   STRIPUTEST
               end (* then *)
             else
               if S = REPEATSY then
                 begin
                   OUTSYMBOL ( S ) ;
                   EINR := EINR + INC ;
                   INSYMBOL ( S ) ;
                   repeat
                     CSTATE ( TRUE , '      ' )
                   until ( S in STERMSYMBOLE ) ;
                   EINR := EINR - INC ;
                   NEUZEILE ( TRUE ) ;
                   repeat
                     OUTSYMBOL ( S ) ;
                     INSYMBOL ( S )
                   until ( S in STERMSYMBOLE ) ;
                   STRIPUTEST
                 end (* then *)
               else
                 begin
                   if NULLSTATE then
                     begin
                       WRITELN ( '+++ Syntaxfehler festgestellt.' ) ;
                       HALTX
                     end (* then *)
                   else
                     NULLSTATE := TRUE
                 end (* else *)
   end (* CSTATE *) ;



procedure CBODY ( FUELLWORT : PWORT ; BLOCKLEVEL : INTEGER ) ;

   var I : INTEGER ;
       EINRKOMMSAVE : INTEGER ;

   begin (* CBODY *)
     if S = BEGINSY then
       begin
         EINRKOMMSAVE := EINRKOMM ;
         NEUZEILE ( TRUE ) ;
         OUTSYMBOL ( S ) ;
         WRITE ( AUSGABE , ' (* ' ) ;
         for I := 1 to FUELLWORT . LAENGE do
           WRITE ( AUSGABE , FUELLWORT . NAME [ I ] ) ;
         WRITE ( AUSGABE , ' *)' ) ;
         EINR := EINR + INC ;
         EINRKOMM := EINR ;
         KOMMC . UEBERLESEN := 2 ;
         INSYMBOL ( S ) ;
         repeat
           CSTATE ( TRUE , '      ' )
         until ( S in STERMSYMBOLE ) ;
         EINR := EINR - INC ;
         NEUZEILE ( TRUE ) ;
         OUTSYMBOL ( S ) ;
         WRITE ( AUSGABE , ' (* ' ) ;
         for I := 1 to FUELLWORT . LAENGE do
           WRITE ( AUSGABE , FUELLWORT . NAME [ I ] ) ;
         WRITE ( AUSGABE , ' *)' ) ;
         KOMMC . UEBERLESEN := 2 ;
         INSYMBOL ( S ) ;
         KOMM_ZWISCHEN_PROCS ( BLOCKLEVEL ) ;
         EINRKOMM := EINRKOMMSAVE ;
       end (* then *)
     else
       begin
         EINRKOMMSAVE := EINRKOMM ;
         EINRKOMM := EINR ;
         CSTATE ( TRUE , '      ' ) ;
         EINRKOMM := EINRKOMMSAVE ;
       end (* else *)
   end (* CBODY *) ;



procedure CBLOCK ( FUELLWORT : PWORT ; BLOCKLEVEL : INTEGER ) ;

   var EINRSAVE : INTEGER ;
       EINRKOMMSAVE : INTEGER ;
       KLAMMZ : INTEGER ;
       I : INTEGER ;
       PROCWORT : PWORT ;
       SALT : SYMBOL ;
       INCR : INTEGER ;
       PROC_VORH : BOOLEAN ;

   begin (* CBLOCK *)
     EINRKOMMSAVE := EINRKOMM ;
     EINRKOMM := EINR ;
     while TRUE do
       begin
         if S = LABELSY then
           begin
             NEUZEILE ( FALSE ) ;
             if BLOCKLEVEL = 1 then
               NEUZEILE ( FALSE ) ;
             NEUZEILE ( TRUE ) ;
             OUTSYMBOL ( S ) ;
             EINRSAVE := EINR ;
             EINR := OUTPOINTER ;
             EINRKOMMSAVE := EINRKOMM ;
             EINRKOMM := OUTPOINTER ;
             INSYMBOL ( S ) ;
             while S <> STRIPU do
               begin
                 OUTSYMBOL ( S ) ;
                 INSYMBOL ( S )
               end (* while *) ;
             OUTSYMBOL ( S ) ;
             INSYMBOL ( S ) ;
             EINR := EINRSAVE ;
             continue ;
           end (* then *) ;
         if S = CONSTSY then
           begin
             NEUZEILE ( FALSE ) ;
             if BLOCKLEVEL = 1 then
               NEUZEILE ( FALSE ) ;
             NEUZEILE ( TRUE ) ;
             OUTSYMBOL ( S ) ;
             EINRKOMM := OUTPOINTER ;
             INSYMBOL ( S ) ;
             EINR := EINR + 6 ;
             while S = IDENTIFIER do
               begin
                 INCR := 0 ;
                 repeat
                   OUTSYMBOL ( S ) ;

     (************************************************)
     (* wenn nach gleichheitszeichen eine runde oder *)
     (* eckige klammer folgt, dann neuzeile          *)
     (************************************************)

                   SALT := S ;
                   INSYMBOL ( S ) ;
                   if ( SALT = GLEICH ) and ( ( S = KLAMMAUF ) or ( S =
                   ECKKLAMMAUF ) ) then
                     begin
                       NEUZEILE ( TRUE ) ;
                       INCR := INCR + 2 ;
                       EINR := EINR + 2 ;
                     end (* then *) ;
                 until S = STRIPU ;
                 OUTSYMBOL ( S ) ;
                 EINR := EINR - INCR ;
                 INSYMBOL ( S ) ;
                 if S = IDENTIFIER then
                   NEUZEILE ( TRUE )
               end (* while *) ;
             EINR := EINR - 6 ;
             continue ;
           end (* then *) ;
         if S = TYPESY then
           begin
             NEUZEILE ( FALSE ) ;
             if BLOCKLEVEL = 1 then
               NEUZEILE ( FALSE ) ;
             NEUZEILE ( TRUE ) ;
             OUTSYMBOL ( S ) ;
             EINRKOMM := OUTPOINTER ;
             INSYMBOL ( S ) ;
             EINR := EINR + 5 ;
             while S = IDENTIFIER do
               begin
                 repeat
                   OUTSYMBOL ( S ) ;
                   INSYMBOL ( S )
                 until S = GLEICH ;
                 OUTSYMBOL ( S ) ;
                 INSYMBOL ( S ) ;
                 CTYPE ;
                 if S = IDENTIFIER then
                   NEUZEILE ( TRUE )
               end (* while *) ;
             EINR := EINR - 5 ;
             continue ;
           end (* then *) ;
         if S = SQLVARSY then
           begin
             NEUZEILE ( FALSE ) ;
             if BLOCKLEVEL = 1 then
               NEUZEILE ( FALSE ) ;
             NEUZEILE ( TRUE ) ;
             OUTSYMBOL ( S ) ;
             EINRKOMM := OUTPOINTER ;
             INSYMBOL ( S ) ;
             EINR := EINR + 7 ;
             while S = IDENTIFIER do
               begin
                 repeat
                   OUTSYMBOL ( S ) ;
                   INSYMBOL ( S )
                 until S = DOPU ;
                 OUTSYMBOL ( S ) ;
                 INSYMBOL ( S ) ;
                 CTYPE ;
                 if S = IDENTIFIER then
                   NEUZEILE ( TRUE )
               end (* while *) ;
             EINR := EINR - 7 ;
             continue ;
           end (* then *) ;
         if S = VARSY then
           begin
             NEUZEILE ( FALSE ) ;
             if BLOCKLEVEL = 1 then
               NEUZEILE ( FALSE ) ;
             NEUZEILE ( TRUE ) ;
             OUTSYMBOL ( S ) ;
             EINRKOMM := OUTPOINTER ;
             INSYMBOL ( S ) ;
             EINR := EINR + 4 ;
             while S = IDENTIFIER do
               begin
                 repeat
                   OUTSYMBOL ( S ) ;
                   INSYMBOL ( S )
                 until S = DOPU ;
                 OUTSYMBOL ( S ) ;
                 INSYMBOL ( S ) ;
                 CTYPE ;
                 if S = IDENTIFIER then
                   NEUZEILE ( TRUE )
               end (* while *) ;
             EINR := EINR - 4 ;
             continue ;
           end (* then *) ;
         if S = STATICSY then
           begin
             NEUZEILE ( FALSE ) ;
             if BLOCKLEVEL = 1 then
               NEUZEILE ( FALSE ) ;
             NEUZEILE ( TRUE ) ;
             OUTSYMBOL ( S ) ;
             EINRKOMM := OUTPOINTER ;
             INSYMBOL ( S ) ;
             EINR := EINR + 7 ;
             while S = IDENTIFIER do
               begin
                 repeat
                   OUTSYMBOL ( S ) ;
                   INSYMBOL ( S )
                 until S = DOPU ;
                 OUTSYMBOL ( S ) ;
                 INSYMBOL ( S ) ;
                 CTYPE ;
                 if S = IDENTIFIER then
                   NEUZEILE ( TRUE )
               end (* while *) ;
             EINR := EINR - 7 ;
             continue ;
           end (* then *) ;
         break ;
       end (* while *) ;
     PROC_VORH := FALSE ;
     while ( S = PROCEDURESY ) or ( S = FUNCTIONSY ) or ( S = OVERLAYSY
     ) or ( S = LOCALSY ) do
       begin
         if not PROC_VORH then
           if BLOCKLEVEL = 1 then
             NEUZEILE ( FALSE ) ;
         PROC_VORH := TRUE ;
         NEUZEILE ( FALSE ) ;
         NEUZEILE ( FALSE ) ;
         NEUZEILE ( TRUE ) ;
         KLAMMZ := 0 ;
         EINRSAVE := EINR ;
         EINRKOMM := EINR ;
         while ( S = OVERLAYSY ) or ( S = LOCALSY ) do
           begin
             OUTSYMBOL ( S ) ;
             INSYMBOL ( S ) ;
           end (* while *) ;
         OUTSYMBOL ( S ) ;
         INSYMBOL ( S ) ;
         PROCWORT . NAME := '' ;
         for I := 1 to W1ENDE do
           if I <= MAXIDSIZE then
             PROCWORT . NAME [ I ] := W1 [ I ] ;
         if W1ENDE > MAXIDSIZE then
           PROCWORT . LAENGE := MAXIDSIZE
         else
           PROCWORT . LAENGE := W1ENDE ;
         repeat
           OUTSYMBOL ( S ) ;
           INSYMBOL ( S ) ;
           if S = KLAMMAUF then
             begin
               KLAMMZ := KLAMMZ + 1 ;
               if KLAMMZ = 1 then
                 begin
                   EINR := OUTPOINTER
                 end (* then *)
             end (* then *) ;
           if S = KLAMMZU then
             KLAMMZ := KLAMMZ - 1
         until ( S = STRIPU ) and ( KLAMMZ = 0 ) ;
         OUTSYMBOL ( S ) ;
         INSYMBOL ( S ) ;
         EINR := EINRSAVE ;
         EINR := EINR + 3 ;
         CBLOCK ( PROCWORT , BLOCKLEVEL + 1 ) ;
         EINR := EINR - 3 ;
         if BLOCKLEVEL = 1 then
           NEUZEILE ( FALSE ) ;
       end (* while *) ;
     NEUZEILE ( FALSE ) ;
     if ( BLOCKLEVEL = 1 ) or PROC_VORH then
       NEUZEILE ( FALSE ) ;
     CBODY ( FUELLWORT , BLOCKLEVEL ) ;
     EINRKOMM := EINRKOMMSAVE
   end (* CBLOCK *) ;



procedure PROG ;

   var S : SYMBOL ;

   begin (* PROG *)
     repeat
       INSYMBOL ( S ) ;
       OUTSYMBOL ( S ) ;
       if S = ENDSY then
         KOMMC . UEBERLESEN := 2
     until EOFILE
   end (* PROG *) ;



procedure CHANGE ;

   var EINRSAVE : INTEGER ;
       I : INTEGER ;
       MAINWORT : PWORT ;

   begin (* CHANGE *)
     MAINWORT . NAME := 'HAUPTPROGRAMM  ' ;
     MAINWORT . LAENGE := 13 ;
     EINRSAVE := EINR ;
     INSYMBOL ( S ) ;
     OUTSYMBOL ( S ) ;
     if ( S = PROGRAMSY ) or ( S = MODULESY ) then
       begin
         MAINWORT . NAME := 'HAUPTPROGRAMM  ' ;
         MAINWORT . LAENGE := 13
       end (* then *)
     else
       begin
         INSYMBOL ( S ) ;
         MAINWORT . NAME := '' ;
         for I := 1 to W1ENDE do
           if I <= MAXIDSIZE then
             MAINWORT . NAME [ I ] := W1 [ I ] ;
         if W1ENDE > MAXIDSIZE then
           MAINWORT . LAENGE := MAXIDSIZE
         else
           MAINWORT . LAENGE := W1ENDE ;
         OUTSYMBOL ( S )
       end (* else *) ;
     INSYMBOL ( S ) ;
     repeat
       OUTSYMBOL ( S ) ;
       if S = KLAMMAUF then
         begin
           EINR := OUTPOINTER ;
           repeat
             INSYMBOL ( S ) ;
             OUTSYMBOL ( S )
           until S = KLAMMZU ;
         end (* then *) ;
       INSYMBOL ( S )
     until S = STRIPU ;
     OUTSYMBOL ( S ) ;
     INSYMBOL ( S ) ;
     EINR := EINRSAVE ;
     CBLOCK ( MAINWORT , 1 ) ;
     OUTSYMBOL ( S ) ;
     INSYMBOL ( S ) ;
     if S <> EOFSY then
       WRITELN ( '+++ Warnung: Es wurde nicht die' ,
                 ' ganze Datei verarbeitet.' )
   end (* CHANGE *) ;



procedure VORBESETZEN ;

   begin (* VORBESETZEN *)
     WTAB [ ANDSY ] := 'AND       ' ;
     WTAB [ ARRAYSY ] := 'ARRAY     ' ;
     WTAB [ BEGINSY ] := 'BEGIN     ' ;
     WTAB [ BREAKSY ] := 'BREAK     ' ;
     WTAB [ CASESY ] := 'CASE      ' ;
     WTAB [ CONSTSY ] := 'CONST     ' ;
     WTAB [ CONTINUESY ] := 'CONTINUE  ' ;
     WTAB [ DOSY ] := 'DO        ' ;
     WTAB [ ELSESY ] := 'ELSE      ' ;
     WTAB [ ENDSY ] := 'END       ' ;
     WTAB [ FORSY ] := 'FOR       ' ;
     WTAB [ FUNCTIONSY ] := 'FUNCTION  ' ;
     WTAB [ GOTOSY ] := 'GOTO      ' ;
     WTAB [ IFSY ] := 'IF        ' ;
     WTAB [ INSY ] := 'IN        ' ;
     WTAB [ LABELSY ] := 'LABEL     ' ;
     WTAB [ LOCALSY ] := 'LOCAL     ' ;
     WTAB [ MODULESY ] := 'MODULE    ' ;
     WTAB [ NOTSY ] := 'NOT       ' ;
     WTAB [ OFSY ] := 'OF        ' ;
     WTAB [ ORSY ] := 'OR        ' ;
     WTAB [ OTHERWISESY ] := 'OTHERWISE ' ;
     WTAB [ OVERLAYSY ] := 'OVERLAY   ' ;
     WTAB [ PACKEDSY ] := 'PACKED    ' ;
     WTAB [ PROCEDURESY ] := 'PROCEDURE ' ;
     WTAB [ PROGRAMSY ] := 'PROGRAM   ' ;
     WTAB [ RECORDSY ] := 'RECORD    ' ;
     WTAB [ REPEATSY ] := 'REPEAT    ' ;
     WTAB [ RETURNSY ] := 'RETURN    ' ;
     WTAB [ SETSY ] := 'SET       ' ;
     WTAB [ SQLBEGINSY ] := 'SQLBEGIN  ' ;
     WTAB [ SQLENDSY ] := 'SQLEND    ' ;
     WTAB [ SQLVARSY ] := 'SQLVAR    ' ;
     WTAB [ STATICSY ] := 'STATIC    ' ;
     WTAB [ THENSY ] := 'THEN      ' ;
     WTAB [ TOSY ] := 'TO        ' ;
     WTAB [ TYPESY ] := 'TYPE      ' ;
     WTAB [ UNTILSY ] := 'UNTIL     ' ;
     WTAB [ VARSY ] := 'VAR       ' ;
     WTAB [ WHILESY ] := 'WHILE     ' ;
     WTAB [ WITHSY ] := 'WITH      ' ;
     WTAB [ XORSY ] := 'XOR       ' ;
     WTABSQL [ 1 ] := 'CONNECT   ' ;
     WTABSQL [ 2 ] := 'DECLARE   ' ;
     WTABSQL [ 3 ] := 'DELETE    ' ;
     WTABSQL [ 4 ] := 'FROM      ' ;
     WTABSQL [ 5 ] := 'GROUP     ' ;
     WTABSQL [ 6 ] := 'HAVING    ' ;
     WTABSQL [ 7 ] := 'INSERT    ' ;
     WTABSQL [ 8 ] := 'INTO      ' ;
     WTABSQL [ 9 ] := 'ORDER     ' ;
     WTABSQL [ 10 ] := 'SELECT    ' ;
     WTABSQL [ 11 ] := 'SET       ' ;
     WTABSQL [ 12 ] := 'UNION     ' ;
     WTABSQL [ 13 ] := 'UPDATE    ' ;
     WTABSQL [ 14 ] := 'VALUES    ' ;
     WTABSQL [ 15 ] := 'WHERE     ' ;
     ANZSQLWORTE := 15 ;
   end (* VORBESETZEN *) ;



begin (* HAUPTPROGRAMM *)
  REWRITE ( TRACE ) ;
  MODUS := 4 ;
  KOMMC . KOMML := 0 ;
  KOMMC . ENDOFKOMM := FALSE ;
  KOMMC . ANZKOMM := 0 ;
  KOMMC . ZUSTAND := 0 ;
  KOMMC . KOMMTYPE := ' ' ;
  KOMMC . NURSTERNE := FALSE ;
  KOMMC . KOMMSTATUS := 0 ;
  KOMMC . KOMM_VOR_PROC := FALSE ;

  (***********************************************)
  (*   HIER UNTERSCHIED PASCAL/VS ZU TURBO/3     *)
  (*   TERMIN (INPUT) ; TERMOUT (OUTPUT) ;       *)
  (*   WIRD BENOETIGT BEI PASCAL/VS              *)
  (***********************************************)

  COMPOUNDNZ := TRUE ;
  if MODUS > 4 then
    begin
      COMPOUNDNZ := FALSE ;
      MODUS := MODUS - 2
    end (* then *) ;
  DICHT := ( MODUS = 1 ) or ( MODUS = 3 ) ;
  VORBESETZEN ;
  STERMSYMBOLE := [ EOFSY , STRIPU , ELSESY , ENDSY , OTHERWISESY ,
                  UNTILSY ] ;
  TTERMSYMBOLE := [ EOFSY , STRIPU , ENDSY , RECORDSY , KLAMMZU ] ;
  BLANKSYMBOLE := [ IDENTIFIER , ZAHL , ANDSY , ARRAYSY , BEGINSY ,
                  BREAKSY , CASESY , CONSTSY , CONTINUESY , DOSY ,
                  ELSESY , ENDSY , FORSY , FUNCTIONSY , GOTOSY , IFSY ,
                  INSY , LABELSY , LOCALSY , MODULESY , NOTSY , OFSY ,
                  ORSY , OTHERWISESY , OVERLAYSY , PACKEDSY ,
                  PROCEDURESY , PROGRAMSY , RECORDSY , REPEATSY ,
                  RETURNSY , SETSY , SQLBEGINSY , SQLENDSY , SQLVARSY ,
                  STATICSY , THENSY , TOSY , TYPESY , UNTILSY , VARSY ,
                  WHILESY , WITHSY , XORSY ] ;
  WORTSYMBOLE := [ ANDSY , ARRAYSY , BEGINSY , BREAKSY , CASESY ,
                 CONSTSY , CONTINUESY , DOSY , ELSESY , ENDSY , FORSY ,
                 FUNCTIONSY , GOTOSY , IFSY , INSY , LABELSY , LOCALSY
                 , MODULESY , NOTSY , OFSY , ORSY , OTHERWISESY ,
                 OVERLAYSY , PACKEDSY , PROCEDURESY , PROGRAMSY ,
                 RECORDSY , REPEATSY , RETURNSY , SETSY , SQLBEGINSY ,
                 SQLENDSY , SQLVARSY , STATICSY , THENSY , TOSY ,
                 TYPESY , UNTILSY , VARSY , WHILESY , WITHSY , XORSY ]
                 ;
  EXPRSYMBOLE := [ ANDSY , INSY , NOTSY , ORSY , XORSY ] ;
  SONDERZEICHEN := [ '@' , '^' , '*' , ')' , '-' , '+' , '=' , ':' ,
                   ';' , ',' , '.' , '/' , '>' , '<' , '!' , '%' , '['
                   , ']' , VERKETT2 ] ;
  ISTARTSET := [ 'A' .. 'I' , 'J' .. 'R' , 'S' .. 'Z' , '$' ] ;
  IWEITERSET := [ 'A' .. 'I' , 'J' .. 'R' , 'S' .. 'Z' , '0' .. '9' ,
                '_' ] ;
  ZIFFERN := [ '0' .. '9' ] ;
  HEXZIFFERN := [ '0' .. '9' , 'A' .. 'F' ] ;
  NICHTLESEN := 0 ;
  EINR := 0 ;
  EINRKOMM := 0 ;
  INC := 2 ;
  NOMAJOR := FALSE ;
  BLANKSVORHANDEN := FALSE ;
  KOMMC . UEBERLESEN := 0 ;
  ENDEKASTEN := ' ' ;
  ENDEKOMMEIN := 0 ;
  KOMMLAENGE := 0 ;
  INSQLSTATE := FALSE ;
  SQLHOSTV := FALSE ;
  ZZAUS := 0 ;
  ZZAUSVOR := - 1 ;
  RESET ( EINGABE ) ;
  REWRITE ( AUSGABE ) ;
  W1INDEX := 0 ;
  INPOINTER := 0 ;
  if EINR <> 0 then
    WRITE ( AUSGABE , ' ' : EINR ) ;
  OUTPOINTER := EINR ;
  if MODUS < 3 then
    PROG
  else
    CHANGE ;
  WRITELN ( AUSGABE ) ;

  (***********************************************)
  (*   HIER UNTERSCHIED PASCAL/VS ZU TURBO/3     *)
  (*   CLOSE (EINGABE) ; CLOSE (AUSGABE) ;       *)
  (*   WIRD BENOETIGT BEI TURBO/3                *)
  (***********************************************)

  WRITELN ( ZZAUS + 1 : 6 , ' Zeilen ausgegeben.' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB PRIMZERL EXT PAS HEX -
program PRIMZERL ( INPUT , OUTPUT ) ;


const TABSIZE = 100000 ;
      PRIMWIDTH = 8 ;
      PRIM_PER_LINE = 8 ;
      SHOW_TABLE_OF_PRIMES = FALSE ;


var PTAB : array [ 1 .. TABSIZE ] of INTEGER ;
    PLAUF : INTEGER ;
    PINDEX : INTEGER ;
    ZAHL , ZAHL1 , ZAHL2 : INTEGER ;
    PRIM_FOUND : BOOLEAN ;



function TESTPRIM ( TESTZAHL : INTEGER ; var IX : INTEGER ) : BOOLEAN ;

   var I : INTEGER ;
       REST : INTEGER ;

   begin (* TESTPRIM *)
     I := 2 ;
     TESTPRIM := FALSE ;
     while TRUE do
       begin
         if PTAB [ I ] * PTAB [ I ] > TESTZAHL then
           begin
             PTAB [ IX ] := TESTZAHL ;
             IX := IX + 1 ;
             TESTPRIM := TRUE ;
             break ;
           end (* then *) ;
         REST := TESTZAHL MOD PTAB [ I ] ;
         if REST = 0 then
           break ;
         I := I + 1 ;
       end (* while *)
   end (* TESTPRIM *) ;



procedure PRIMFAKTOR_ZERLEGUNG ( TESTZAHL : INTEGER ) ;

   var I : INTEGER ;
       REST : INTEGER ;
       ERSTE : BOOLEAN ;
       X : INTEGER ;

   begin (* PRIMFAKTOR_ZERLEGUNG *)
     ERSTE := TRUE ;
     I := 1 ;
     X := TESTZAHL ;
     while TRUE do
       begin
         if PTAB [ I ] * PTAB [ I ] > TESTZAHL then
           begin
             if ERSTE then
               WRITE ( TESTZAHL , ' ist Primzahl' )
             else
               WRITE ( X : 1 ) ;
             break ;
           end (* then *) ;
         REST := X MOD PTAB [ I ] ;
         if REST <> 0 then
           I := I + 1
         else
           begin
             if ERSTE then
               begin
                 WRITE ( TESTZAHL , ' = ' ) ;
                 ERSTE := FALSE
               end (* then *) ;
             X := X DIV PTAB [ I ] ;
             WRITE ( PTAB [ I ] : 1 ) ;
             if X = 1 then
               break ;
             WRITE ( ' * ' )
           end (* else *) ;
       end (* while *) ;
     WRITELN ;
   end (* PRIMFAKTOR_ZERLEGUNG *) ;



begin (* HAUPTPROGRAMM *)
  PTAB [ 1 ] := 2 ;
  PTAB [ 2 ] := 3 ;
  PTAB [ 3 ] := 5 ;
  PTAB [ 4 ] := 7 ;
  PTAB [ 5 ] := 11 ;
  PLAUF := 11 ;
  PINDEX := 6 ;
  if SHOW_TABLE_OF_PRIMES then
    WRITELN ( 'Tabelle der ersten ' , TABSIZE : 1 , ' Primzahlen' ) ;
  while PINDEX <= TABSIZE do
    begin
      PLAUF := PLAUF + 2 ;
      PRIM_FOUND := TESTPRIM ( PLAUF , PINDEX ) ;
      if PRIM_FOUND then
        if SHOW_TABLE_OF_PRIMES then
          begin
            if PINDEX MOD PRIM_PER_LINE = 1 then
              WRITELN ;
            WRITE ( PTAB [ PINDEX - 1 ] : PRIMWIDTH ) ;
          end (* then *)
        else
          if PINDEX MOD 5000 = 0 then
            WRITELN ( PINDEX , ' Primzahlen bereits gefunden' ) ;
    end (* while *) ;
  if SHOW_TABLE_OF_PRIMES then
    WRITELN ;
  while TRUE do
    begin
      WRITELN ;
      WRITELN ( 'Bitte Testzahlen von ... bis eingeben:' ) ;
      READLN ( ZAHL1 , ZAHL2 ) ;
      if ( ZAHL1 = 0 ) & ( ZAHL2 = 0 ) then
        break ;
      for ZAHL := ZAHL1 to ZAHL2 do
        begin
          PRIMFAKTOR_ZERLEGUNG ( ZAHL ) ;
        end (* for *) ;
      if EOF ( INPUT ) then
        break ;
    end (* while *) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB SHOWHEX  EXT PAS HEX -
program SHOWHEX ( INPUT , INPTEXT , INPBIN , OUTPUT ) ;


const BUFLEN = 32 ;


type BYTE = record
              CONT : CHAR ;
            end ;
     FILEMODE = ( MODE_TEXT , MODE_BINARY ) ;


var I : INTEGER ;
    CH : CHAR ;
    BUFFER : array [ 1 .. BUFLEN ] of CHAR ;
    LINE : INTEGER ;
    POS : INTEGER ;
    INPTEXT : TEXT ;
    INPBIN : FILE of BYTE ;
    X : INTEGER ;
    PARM_MODE : FILEMODE ;
    PARM_FILENAME : array [ 1 .. 250 ] of CHAR ;
    PARM_LF : INTEGER ;



procedure CHKPARMS ;

/***********************************/
/* check run time parms via osparm */
/* option -b or -t (bin or text)   */
/* and filename                    */
/***********************************/


   var SX : INTEGER ;
       STATUS : INTEGER ;

   begin (* CHKPARMS *)
     if OSPARM = NIL then
       begin
         PARM_MODE := MODE_TEXT ;
         PARM_FILENAME := ' ' ;
         PARM_LF := 0 ;
       end (* then *)
     else
       begin
         with OSPARM -> do
           begin
             STATUS := 1 ;
             for SX := 1 to PLENGTH do
               begin
                 case STATUS of
                   1 : if PSTRING [ SX ] = ' ' then
                         STATUS := 1
                       else
                         if PSTRING [ SX ] = '-' then
                           STATUS := 2
                         else
                           begin
                             STATUS := 3 ;
                             PARM_FILENAME := ' ' ;
                             PARM_FILENAME [ 1 ] := PSTRING [ SX ] ;
                             PARM_LF := 1 ;
                           end (* else *) ;
                   2 : if PSTRING [ SX ] = ' ' then
                         STATUS := 99
                       else
                         if PSTRING [ SX ] = '-' then
                           STATUS := 99
                         else
                           begin
                             STATUS := 4 ;
                             if PSTRING [ SX ] = 'b' then
                               PARM_MODE := MODE_BINARY
                             else
                               if PSTRING [ SX ] = 't' then
                                 PARM_MODE := MODE_TEXT
                               else
                                 STATUS := 99 ;
                           end (* else *) ;
                   3 : if PSTRING [ SX ] = ' ' then
                         STATUS := 1
                       else
                         begin
                           PARM_LF := PARM_LF + 1 ;
                           PARM_FILENAME [ PARM_LF ] := PSTRING [ SX ]
                                                   ;
                           STATUS := 3 ;
                         end (* else *) ;
                   4 : if PSTRING [ SX ] = ' ' then
                         STATUS := 1
                       else
                         STATUS := 99 ;
                 end (* case *)
               end (* for *) ;
           end (* with *) ;
       end (* else *) ;
   end (* CHKPARMS *) ;



procedure DUMPCHAR ( CH : CHAR ) ;

   begin (* DUMPCHAR *)
     if CH in [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' , 'A' .. 'I' , 'J'
     .. 'R' , 'S' .. 'Z' , '0' .. '9' , ' ' , ',' , '.' , '-' , ';' ,
     ':' , '_' , '!' , '"' , '>' , '<' , '$' , '%' , '&' , '/' , '(' ,
     ')' , '=' , '?' , '+' , '*' , '#' , '*' ] then
       WRITE ( CH )
     else
       WRITE ( '.' )
   end (* DUMPCHAR *) ;



function ISTELLEN ( I : INTEGER ) : INTEGER ;

   var IMAX : INTEGER ;
       IST : INTEGER ;

   begin (* ISTELLEN *)
     I := ABS ( I ) ;
     IMAX := 1000000000 ;
     IST := 10 ;
     while ( I < IMAX ) and ( IMAX > 1 ) do
       begin
         IMAX := IMAX DIV 10 ;
         IST := IST - 1
       end (* while *) ;
     ISTELLEN := IST
   end (* ISTELLEN *) ;



function ENDOFFILE : BOOLEAN ;

   begin (* ENDOFFILE *)
     if PARM_MODE = MODE_TEXT then
       ENDOFFILE := EOF ( INPTEXT )
     else
       ENDOFFILE := EOF ( INPBIN )
   end (* ENDOFFILE *) ;



function ENDOFLINE : BOOLEAN ;

   begin (* ENDOFLINE *)
     if PARM_MODE = MODE_TEXT then
       ENDOFLINE := EOLN ( INPTEXT )
     else
       ENDOFLINE := FALSE
   end (* ENDOFLINE *) ;



function GETFILE : CHAR ;

   begin (* GETFILE *)
     if PARM_MODE = MODE_TEXT then
       begin
         GETFILE := INPTEXT -> ;
         GET ( INPTEXT ) ;
       end (* then *)
     else
       begin
         GETFILE := INPBIN -> . CONT ;
         GET ( INPBIN ) ;
       end (* else *)
   end (* GETFILE *) ;



procedure BUFFER_AUSG ;

   var C1 : CHAR ;
       C2 : CHAR ;
       START , ENDE : INTEGER ;

   const HEX : packed array [ 0 .. 15 ] of CHAR = '0123456789abcdef' ;

   begin (* BUFFER_AUSG *)
     START := 1 ;
     ENDE := I ;
     if POS = 1 then
       WRITELN ( 'Line ' , LINE : 1 ) ;
     X := ISTELLEN ( POS + ENDE - 1 ) ;
     if X < 3 then
       X := 3 ;
     WRITE ( 'Pos ' , POS : X , ': ' ) ;
     for I := START to ENDE do
       begin
         CH := BUFFER [ I ] ;
         C1 := HEX [ ORD ( CH ) DIV 16 ] ;
         C2 := HEX [ ORD ( CH ) MOD 16 ] ;
         WRITE ( C1 , C2 ) ;
         if I MOD 4 = 0 then
           WRITE ( ' ' ) ;
       end (* for *) ;
     WRITELN ;
     WRITE ( ' to ' , POS + ENDE - 1 : X , ': ' ) ;
     for I := START to ENDE do
       begin
         DUMPCHAR ( BUFFER [ I ] ) ;
         WRITE ( ' ' ) ;
         if I MOD 4 = 0 then
           WRITE ( ' ' ) ;
       end (* for *) ;
     WRITELN ;
   end (* BUFFER_AUSG *) ;



begin (* HAUPTPROGRAMM *)
  CHKPARMS ;
  LINE := 1 ;
  POS := 1 ;
  I := 0 ;
  MEMSET ( ADDR ( BUFFER ) , ' ' , BUFLEN ) ;
  if PARM_MODE = MODE_TEXT then
    RESET ( INPTEXT )
  else
    RESET ( INPBIN ) ;
  while not ENDOFFILE do
    begin
      if not ENDOFLINE then
        begin
          CH := GETFILE ;
          I := I + 1 ;
          BUFFER [ I ] := CH ;
        end (* then *) ;
      if ENDOFLINE or ( I >= BUFLEN ) then
        begin
          BUFFER_AUSG ;

  (******************************)
  (* BLANK NACH EOLN UEBERLESEN *)
  (******************************)

          if ENDOFLINE then
            begin
              if not ENDOFFILE then
                begin
                  CH := GETFILE ;
                end (* then *) ;
              LINE := LINE + 1 ;
              POS := 1 ;
            end (* then *)
          else
            begin
              POS := POS + BUFLEN ;
            end (* else *) ;
          MEMSET ( ADDR ( BUFFER ) , ' ' , BUFLEN ) ;
          I := 0 ;
        end (* then *) ;
    end (* while *) ;
  if I > 0 then
    BUFFER_AUSG ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB SPLITMVS EXT PAS HEX -
program SPLITMVS ( INPUT , OUTPUT , OUTF001 , OUTF002 , OUTF003 ,
                   OUTF004 , OUTF005 , OUTF006 , OUTF007 , OUTF008 ,
                   OUTF009 , OUTF00A , OUTF00B , OUTF00C , OUTF00D ,
                   OUTF00E , OUTF00F ) ;

(***********************************************************)
(*                                                         *)
(*   This program creates on MVS all the files             *)
(*   of the Pascal system from the large download file     *)
(*   named PASCALN.TXT.                                    *)
(*                                                         *)
(*   It is similar to SPLITPAS.PAS, which creates          *)
(*   directories on Windows from the same file.            *)
(*                                                         *)
(***********************************************************)
(*                                                         *)
(*   Author: Bernd Oppolzer - December 2017                *)
(*                                                         *)
(***********************************************************)



const SIZEDSN = 44 ;
      SIZEMEM = 8 ;
      SIZEEXT = 3 ;
      MAXLINEOFFS = 72 ;
      MAXOUT = 100 ;


type CHARPTR = -> CHAR ;
     ZEILE = array [ 1 .. 128 ] of CHAR ;
     DSNAME = array [ 1 .. 44 ] of CHAR ;
     CHAR6 = array [ 1 .. 6 ] of CHAR ;
     CHAR8 = array [ 1 .. 8 ] of CHAR ;
     CHAR3 = array [ 1 .. 3 ] of CHAR ;
     CHAR80 = array [ 1 .. 80 ] of CHAR ;
     CHAR100 = array [ 1 .. 100 ] of CHAR ;


var OUTF001 : TEXT ;
    OUTF002 : TEXT ;
    OUTF003 : TEXT ;
    OUTF004 : TEXT ;
    OUTF005 : TEXT ;
    OUTF006 : TEXT ;
    OUTF007 : TEXT ;
    OUTF008 : TEXT ;
    OUTF009 : TEXT ;
    OUTF00A : TEXT ;
    OUTF00B : TEXT ;
    OUTF00C : TEXT ;
    OUTF00D : TEXT ;
    OUTF00E : TEXT ;
    OUTF00F : TEXT ;
    FN : CHAR ;
    ZINP : ZEILE ;
    ZOUT : array [ 1 .. 1000 ] of CHAR ;
    LOUT : INTEGER ;
    OUTPOS : INTEGER ;
    CPIN : CHARPTR ;
    CPOUT : CHARPTR ;
    TAG : CHAR6 ;
    DSN : DSNAME ;
    MEM : CHAR8 ;
    EXT : CHAR3 ;
    HEXFLAG : CHAR ;



procedure ASSIGN_FILE ( PDSN : CHARPTR ; PMEM : CHARPTR ; PEXT :
                      CHARPTR ; HEXFLAG : CHAR ) ;

(***********************************************************)
(*                                                         *)
(*   this procedure assigns a file name and path           *)
(*   to the pascal file OUTBIN or OUTF001                  *)
(*   (depending on the HEXFLAG). The directory is          *)
(*   built from the DSN, the file name is built from       *)
(*   the member name and the extension                     *)
(*                                                         *)
(***********************************************************)


   var DSN : DSNAME ;
       MEM : CHAR8 ;
       EXT : CHAR3 ;
       PFADNAME : DSNAME ;
       PFADLEN : INTEGER ;
       FILENAME : CHAR100 ;
       FILELEN : INTEGER ;
       I : INTEGER ;
       MD_CMD : CHAR100 ;
       RC : INTEGER ;
       CMDPART : CHAR80 ;

   const DSN_TAB : array [ 1 .. 15 ] of DSNAME =
         ( 'PASCALN.COMPILER.PAS                    ' ,
           'PASCALN.COMPILER.CNTL                   ' ,
           'PASCALN.COMPILER.MESSAGES               ' ,
           'PASCALN.COMPILER.PROCLIB                ' ,
           'PASCALN.RUNTIME.ASM                     ' ,
           'PASCALN.TESTPGM.ASM                     ' ,
           'PASCALN.TESTPGM.PAS                     ' ,
           'PASCALN.TESTPGM.CNTL                    ' ,
           'PASCALN.COMPILER.TEXT                   ' ,
           'PASCALN.RUNTIME.TEXT                    ' ,
           'PASCALN.RUNTIME.MATHTEXT                ' ,
           'PASCALN.OLDCOMP.CNTL                    ' ,
           'PASCALN.OLDCOMP.SAMPLE                  ' ,
           'PASCALN.OLDCOMP.SOURCE                  ' ,
           '                                        ' ) ;
         FN_TAB : array [ 1 .. 15 ] of CHAR = '123456789ABCDEF' ;

   begin (* ASSIGN_FILE *)
     MEMCPY ( ADDR ( DSN ) , PDSN , SIZEDSN ) ;
     MEMCPY ( ADDR ( MEM ) , PMEM , SIZEMEM ) ;
     MEMCPY ( ADDR ( EXT ) , PEXT , SIZEEXT ) ;
     WRITELN ( '-----------------------------' ) ;
     WRITELN ( 'dsn = ' , DSN ) ;
     WRITELN ( 'mem = ' , MEM ) ;
     WRITELN ( 'ext = ' , EXT ) ;
     WRITELN ( 'hex = ' , HEXFLAG ) ;
     WRITELN ( '-----------------------------' ) ;

     /********************************************************/
     /*  set fn (global char) depeding on filename           */
     /*  read from input file pascaln.txt                    */
     /********************************************************/

     FN := ' ' ;
     for I := 1 to 15 do
       if DSN = DSN_TAB [ I ] then
         begin
           FN := FN_TAB [ I ] ;
           break
         end (* then *) ;

     /********************************************************/
     /*  ASSign member and open file for writing             */
     /********************************************************/

     case FN of
       '1' : begin
               ASSIGNMEM ( OUTF001 , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF001 ) ;
             end (* tag/ca *) ;
       '2' : begin
               ASSIGNMEM ( OUTF002 , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF002 ) ;
             end (* tag/ca *) ;
       '3' : begin
               ASSIGNMEM ( OUTF003 , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF003 ) ;
             end (* tag/ca *) ;
       '4' : begin
               ASSIGNMEM ( OUTF004 , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF004 ) ;
             end (* tag/ca *) ;
       '5' : begin
               ASSIGNMEM ( OUTF005 , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF005 ) ;
             end (* tag/ca *) ;
       '6' : begin
               ASSIGNMEM ( OUTF006 , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF006 ) ;
             end (* tag/ca *) ;
       '7' : begin
               ASSIGNMEM ( OUTF007 , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF007 ) ;
             end (* tag/ca *) ;
       '8' : begin
               ASSIGNMEM ( OUTF008 , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF008 ) ;
             end (* tag/ca *) ;
       '9' : begin
               ASSIGNMEM ( OUTF009 , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF009 ) ;
             end (* tag/ca *) ;
       'A' : begin
               ASSIGNMEM ( OUTF00A , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF00A ) ;
             end (* tag/ca *) ;
       'B' : begin
               ASSIGNMEM ( OUTF00B , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF00B ) ;
             end (* tag/ca *) ;
       'C' : begin
               ASSIGNMEM ( OUTF00C , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF00C ) ;
             end (* tag/ca *) ;
       'D' : begin
               ASSIGNMEM ( OUTF00D , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF00D ) ;
             end (* tag/ca *) ;
       'E' : begin
               ASSIGNMEM ( OUTF00E , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF00E ) ;
             end (* tag/ca *) ;
       'F' : begin
               ASSIGNMEM ( OUTF00F , ADDR ( MEM ) , 8 ) ;
               REWRITE ( OUTF00F ) ;
             end (* tag/ca *) ;
     end (* case *) ;
   end (* ASSIGN_FILE *) ;



procedure CLOSE_FILE ;

   begin (* CLOSE_FILE *)
     case FN of
       '1' : CLOSE ( OUTF001 ) ;
       '2' : CLOSE ( OUTF002 ) ;
       '3' : CLOSE ( OUTF003 ) ;
       '4' : CLOSE ( OUTF004 ) ;
       '5' : CLOSE ( OUTF005 ) ;
       '6' : CLOSE ( OUTF006 ) ;
       '7' : CLOSE ( OUTF007 ) ;
       '8' : CLOSE ( OUTF008 ) ;
       '9' : CLOSE ( OUTF009 ) ;
       'A' : CLOSE ( OUTF00A ) ;
       'B' : CLOSE ( OUTF00B ) ;
       'C' : CLOSE ( OUTF00C ) ;
       'D' : CLOSE ( OUTF00D ) ;
       'E' : CLOSE ( OUTF00E ) ;
       'F' : CLOSE ( OUTF00F ) ;
     end (* case *) ;
   end (* CLOSE_FILE *) ;



procedure WRITEBUF ( var OUTF : TEXT ; HEXFLAG : CHAR ; CPOUT : CHARPTR
                   ; LOUT : INTEGER ) ;

   var I : INTEGER ;
       H : INTEGER ;
       HEX : INTEGER ;
       CH : CHAR ;
       CPLAST : CHARPTR ;
       OUTREC : CHAR80 ;

       (***********************************************************)
       (*                                                         *)
       (*   the buffer (addressed by cpout, length in lout)       *)
       (*   is written to the output file.                        *)
       (*                                                         *)
       (*   if hex, the decoding is done.                         *)
       (*                                                         *)
       (*   if not hex, trailing blanks are eliminated.           *)
       (*                                                         *)
       (***********************************************************)


   begin (* WRITEBUF *)
     if HEXFLAG = 'H' then
       begin
         OUTREC := '' ;
         for I := 1 to 80 do
           begin
             CH := CPOUT -> ;
             if ( CH >= '0' ) and ( CH <= '9' ) then
               H := ORD ( CH ) - ORD ( '0' )
             else
               if ( CH >= 'A' ) and ( CH <= 'F' ) then
                 H := ORD ( CH ) - ORD ( 'A' ) + 10 ;
             HEX := H * 16 ;
             CPOUT := PTRADD ( CPOUT , 1 ) ;
             CH := CPOUT -> ;
             if ( CH >= '0' ) and ( CH <= '9' ) then
               H := ORD ( CH ) - ORD ( '0' )
             else
               if ( CH >= 'A' ) and ( CH <= 'F' ) then
                 H := ORD ( CH ) - ORD ( 'A' ) + 10 ;
             HEX := HEX + H ;
             CPOUT := PTRADD ( CPOUT , 1 ) ;
             OUTREC [ I ] := CHR ( HEX ) ;
           end (* for *) ;
         WRITELN ( OUTF , OUTREC ) ;
       end (* then *)
     else
       begin
         CPLAST := PTRADD ( CPOUT , LOUT - 1 ) ;
         while ( LOUT > 0 ) and ( CPLAST -> = ' ' ) do
           begin
             LOUT := LOUT - 1 ;
             CPLAST := PTRADD ( CPLAST , - 1 ) ;
           end (* while *) ;
         for I := 1 to LOUT do
           begin
             WRITE ( OUTF , CPOUT -> ) ;
             CPOUT := PTRADD ( CPOUT , 1 ) ;
           end (* for *) ;
         WRITELN ( OUTF ) ;
       end (* else *)
   end (* WRITEBUF *) ;



procedure WRITE_FILE ( HEXFLAG : CHAR ; CPOUT : CHARPTR ; LOUT :
                     INTEGER ) ;

   begin (* WRITE_FILE *)
     case FN of
       '1' : WRITEBUF ( OUTF001 , HEXFLAG , CPOUT , LOUT ) ;
       '2' : WRITEBUF ( OUTF002 , HEXFLAG , CPOUT , LOUT ) ;
       '3' : WRITEBUF ( OUTF003 , HEXFLAG , CPOUT , LOUT ) ;
       '4' : WRITEBUF ( OUTF004 , HEXFLAG , CPOUT , LOUT ) ;
       '5' : WRITEBUF ( OUTF005 , HEXFLAG , CPOUT , LOUT ) ;
       '6' : WRITEBUF ( OUTF006 , HEXFLAG , CPOUT , LOUT ) ;
       '7' : WRITEBUF ( OUTF007 , HEXFLAG , CPOUT , LOUT ) ;
       '8' : WRITEBUF ( OUTF008 , HEXFLAG , CPOUT , LOUT ) ;
       '9' : WRITEBUF ( OUTF009 , HEXFLAG , CPOUT , LOUT ) ;
       'A' : WRITEBUF ( OUTF00A , HEXFLAG , CPOUT , LOUT ) ;
       'B' : WRITEBUF ( OUTF00B , HEXFLAG , CPOUT , LOUT ) ;
       'C' : WRITEBUF ( OUTF00C , HEXFLAG , CPOUT , LOUT ) ;
       'D' : WRITEBUF ( OUTF00D , HEXFLAG , CPOUT , LOUT ) ;
       'E' : WRITEBUF ( OUTF00E , HEXFLAG , CPOUT , LOUT ) ;
       'F' : WRITEBUF ( OUTF00F , HEXFLAG , CPOUT , LOUT ) ;
     end (* case *) ;
   end (* WRITE_FILE *) ;



begin (* HAUPTPROGRAMM *)
  READLN ( ZINP ) ;
  while not EOF ( INPUT ) do
    begin
      MEMCPY ( ADDR ( TAG ) , ADDR ( ZINP ) , 6 ) ;

  (***********************************************************)
  (*   the record tagged with FILE contains the              *)
  (*   meta information (DSN, MEM, EXT, Hex Flag)            *)
  (***********************************************************)

      if TAG = '++FILE' then
        begin
          MEMCPY ( ADDR ( DSN ) , ADDR ( ZINP [ 8 ] ) , SIZEDSN ) ;
          MEMCPY ( ADDR ( MEM ) , ADDR ( ZINP [ 58 ] ) , SIZEMEM ) ;
          MEMCPY ( ADDR ( EXT ) , ADDR ( ZINP [ 71 ] ) , SIZEEXT ) ;
          HEXFLAG := ZINP [ 79 ] ;
          ASSIGN_FILE ( ADDR ( DSN ) , ADDR ( MEM ) , ADDR ( EXT ) ,
                        HEXFLAG ) ;
          LOUT := - 1 ;
          repeat
            if EOF ( INPUT ) then
              break ;
            READLN ( ZINP ) ;
            MEMCPY ( ADDR ( TAG ) , ADDR ( ZINP ) , 6 ) ;

  (***********************************************************)
  (*   the other records (DATA) are collected into           *)
  (*   the large buffer ZOUT. When the buffer is complete,   *)
  (*   WRITEBUF is called to flush the buffer.               *)
  (***********************************************************)

            if HEXFLAG = 'H' then
              begin
                if TAG = '++DATA' then
                  begin
                    if ZINP [ 7 ] = '1' then
                      begin
                        if LOUT > 0 then
                          WRITE_FILE ( HEXFLAG , ADDR ( ZOUT ) , LOUT )
                                       ;
                        LOUT := IVALSTR ( ADDR ( ZINP [ 8 ] ) , 5 ) ;
                        OUTPOS := IVALSTR ( ADDR ( ZINP [ 13 ] ) , 5 )
                                  ;
                        OUTPOS := OUTPOS * 2 ;
                        CPOUT := ADDR ( ZOUT ) ;
                        CPOUT := PTRADD ( CPOUT , OUTPOS ) ;
                        CPIN := ADDR ( ZINP [ 19 ] ) ;
                        MEMCPY ( CPOUT , CPIN , 60 ) ;
                      end (* then *)
                    else
                      begin
                        OUTPOS := IVALSTR ( ADDR ( ZINP [ 13 ] ) , 5 )
                                  ;
                        OUTPOS := OUTPOS * 2 ;
                        CPOUT := ADDR ( ZOUT ) ;
                        CPOUT := PTRADD ( CPOUT , OUTPOS ) ;
                        CPIN := ADDR ( ZINP [ 19 ] ) ;
                        MEMCPY ( CPOUT , CPIN , 60 ) ;
                      end (* else *)
                  end (* then *)
              end (* then *)
            else
              if TAG <> '++FILE' then
                WRITE_FILE ( HEXFLAG , ADDR ( ZINP ) , 80 ) ;
          until TAG = '++FILE' ;
          if LOUT > 0 then
            WRITE_FILE ( HEXFLAG , ADDR ( ZOUT ) , LOUT ) ;
          CLOSE_FILE ;
        end (* then *)
      else
        begin
          WRITELN ( '+++ falsche Satzart: ' , TAG ) ;
          break ;
        end (* else *)
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB SPLITPAS EXT PAS HEX -
program SPLITPAS ( INPUT , OUTPUT , OUTTEXT , OUTBIN ) ;

(***********************************************************)
(*                                                         *)
(*   This program splits the large download file           *)
(*   - see download.pas - into the original seperate       *)
(*   files and writes them (on Windows etc.) into          *)
(*   directories; the names of the directories are         *)
(*   built from the names of the original MVS datasets.    *)
(*                                                         *)
(*   The hex flags are recognized; the hex encoded         *)
(*   files are written in the original binary              *)
(*   representation, so that they could be transferred     *)
(*   to a target mainframe using binary FTP or             *)
(*   equivalent transfer protocols.                        *)
(*                                                         *)
(***********************************************************)
(*                                                         *)
(*   Author: Bernd Oppolzer - May 2017                     *)
(*                                                         *)
(***********************************************************)
(*                                                         *)
(*   outtext = output file for text                        *)
(*   outbin  = output file for binary (recfm f lrecl 80)   *)
(*                                                         *)
(*   the program uses the new anyfile type;                *)
(*   this was needed to make assign on binary files        *)
(*   possible                                              *)
(*                                                         *)
(*   assign assigns Windows file names (and paths)         *)
(*   to Pascal files (before rewrite in this case)         *)
(*                                                         *)
(***********************************************************)



const SIZEDSN = 44 ;
      SIZEMEM = 8 ;
      SIZEEXT = 3 ;
      MAXLINEOFFS = 72 ;
      MAXOUT = 100 ;


type CHARPTR = -> CHAR ;
     CHAR6 = array [ 1 .. 6 ] of CHAR ;
     CHAR80 = array [ 1 .. 80 ] of CHAR ;
     ZEILE = array [ 1 .. 128 ] of CHAR ;
     RECBIN = record
                Z : CHAR80 ;
              end ;


var OUTTEXT : TEXT ;
    OUTBIN : FILE of RECBIN ;
    OUTREC : RECBIN ;
    ZINP : ZEILE ;
    ZOUT : array [ 1 .. 1000 ] of CHAR ;
    LOUT : INTEGER ;
    OUTPOS : INTEGER ;
    CPOUT : CHARPTR ;
    TAG : CHAR6 ;
    DSN : array [ 1 .. SIZEDSN ] of CHAR ;
    MEM : array [ 1 .. SIZEMEM ] of CHAR ;
    EXT : array [ 1 .. SIZEEXT ] of CHAR ;
    HEXFLAG : CHAR ;



procedure ASSIGN ( var X : ANYFILE ; FNAME : CHARPTR ; LEN : INTEGER )
                 ;

   EXTERNAL ;



procedure ASSIGN_FILE ( PDSN : CHARPTR ; PMEM : CHARPTR ; PEXT :
                      CHARPTR ; HEXFLAG : CHAR ) ;

(***********************************************************)
(*                                                         *)
(*   this procedure assigns a file name and path           *)
(*   to the pascal file OUTBIN or OUTTEXT                  *)
(*   (depending on the HEXFLAG). The directory is          *)
(*   built from the DSN, the file name is built from       *)
(*   the member name and the extension                     *)
(*                                                         *)
(***********************************************************)


   var DSN : array [ 1 .. SIZEDSN ] of CHAR ;
       MEM : array [ 1 .. SIZEMEM ] of CHAR ;
       EXT : array [ 1 .. SIZEEXT ] of CHAR ;
       PFADNAME : array [ 1 .. SIZEDSN ] of CHAR ;
       PFADLEN : INTEGER ;
       FILENAME : array [ 1 .. 100 ] of CHAR ;
       FILELEN : INTEGER ;
       I : INTEGER ;
       MD_CMD : array [ 1 .. 100 ] of CHAR ;
       RC : INTEGER ;
       CMDPART : CHAR80 ;

   begin (* ASSIGN_FILE *)
     MEMCPY ( ADDR ( DSN ) , PDSN , SIZEDSN ) ;
     MEMCPY ( ADDR ( MEM ) , PMEM , SIZEMEM ) ;
     MEMCPY ( ADDR ( EXT ) , PEXT , SIZEEXT ) ;
     WRITELN ( '-----------------------------' ) ;
     WRITELN ( 'dsn = ' , DSN ) ;
     WRITELN ( 'mem = ' , MEM ) ;
     WRITELN ( 'ext = ' , EXT ) ;
     WRITELN ( 'hex = ' , HEXFLAG ) ;
     WRITELN ( '-----------------------------' ) ;
     PFADLEN := 0 ;
     PFADNAME := DSN ;
     for I := 1 to SIZEDSN do
       if PFADNAME [ I ] <> ' ' then
         begin
           PFADLEN := I ;
           if PFADNAME [ I ] = '.' then
             PFADNAME [ I ] := '_'
         end (* then *) ;
     WRITELN ( 'pfadname = ' , PFADNAME ) ;
     WRITELN ( 'pfadlen = ' , PFADLEN ) ;

     /********************************************************/
     /*  create directory                                    */
     /********************************************************/

     MD_CMD := 'mkdir ' ;
     MEMCPY ( ADDR ( MD_CMD [ 7 ] ) , ADDR ( PFADNAME ) , SIZEDSN ) ;
     CMDPART := '2>NUL #' ;
     MEMCPY ( ADDR ( MD_CMD [ 53 ] ) , ADDR ( CMDPART ) , 8 ) ;
     WINX ( ADDR ( MD_CMD ) , RC ) ;

     /********************************************************/
     /*  ASSign file                                         */
     /********************************************************/

     FILENAME := ' ' ;
     MEMCPY ( ADDR ( FILENAME ) , ADDR ( PFADNAME ) , SIZEDSN ) ;
     FILENAME [ PFADLEN + 1 ] := '/' ;
     MEMCPY ( ADDR ( FILENAME [ PFADLEN + 2 ] ) , ADDR ( MEM ) ,
              SIZEMEM ) ;
     for I := PFADLEN + 2 to PFADLEN + 10 do
       if FILENAME [ I ] = ' ' then
         begin
           FILELEN := I - 1 ;
           break
         end (* then *) ;
     FILENAME [ FILELEN + 1 ] := '.' ;
     MEMCPY ( ADDR ( FILENAME [ FILELEN + 2 ] ) , ADDR ( EXT ) ,
              SIZEEXT ) ;
     FILELEN := FILELEN + 1 + SIZEEXT ;
     WRITELN ( 'filename = ' , FILENAME ) ;
     WRITELN ( 'filelen = ' , FILELEN ) ;
     WRITELN ( '-----------------------------' ) ;
     if HEXFLAG = 'H' then
       ASSIGN ( OUTBIN , ADDR ( FILENAME ) , FILELEN )
     else
       ASSIGN ( OUTTEXT , ADDR ( FILENAME ) , FILELEN ) ;
   end (* ASSIGN_FILE *) ;



procedure WRITEBUF ( HEXFLAG : CHAR ; CPOUT : CHARPTR ; LOUT : INTEGER
                   ) ;

   var I : INTEGER ;
       H : INTEGER ;
       HEX : INTEGER ;
       CH : CHAR ;
       CPLAST : CHARPTR ;

       (***********************************************************)
       (*                                                         *)
       (*   the buffer (addressed by cpout, length in lout)       *)
       (*   is written to the output file.                        *)
       (*                                                         *)
       (*   if hex, the decoding is done.                         *)
       (*                                                         *)
       (*   if not hex, trailing blanks are eliminated.           *)
       (*                                                         *)
       (***********************************************************)


   begin (* WRITEBUF *)
     if HEXFLAG = 'H' then
       begin
         OUTREC . Z := '' ;
         for I := 1 to 80 do
           begin
             CH := CPOUT -> ;
             if ( CH >= '0' ) and ( CH <= '9' ) then
               H := ORD ( CH ) - ORD ( '0' )
             else
               if ( CH >= 'A' ) and ( CH <= 'F' ) then
                 H := ORD ( CH ) - ORD ( 'A' ) + 10 ;
             HEX := H * 16 ;
             CPOUT := PTRADD ( CPOUT , 1 ) ;
             CH := CPOUT -> ;
             if ( CH >= '0' ) and ( CH <= '9' ) then
               H := ORD ( CH ) - ORD ( '0' )
             else
               if ( CH >= 'A' ) and ( CH <= 'F' ) then
                 H := ORD ( CH ) - ORD ( 'A' ) + 10 ;
             HEX := HEX + H ;
             CPOUT := PTRADD ( CPOUT , 1 ) ;
             OUTREC . Z [ I ] := CHR ( HEX ) ;
           end (* for *) ;

     /***************************************/
     /* PUT ( OUTBIN ) ;                    */
     /* OUTBIN -> := OUTREC ;               */
     /***************************************/

         WRITE ( OUTBIN , OUTREC ) ;
       end (* then *)
     else
       begin
         CPLAST := PTRADD ( CPOUT , LOUT - 1 ) ;
         while ( LOUT > 0 ) and ( CPLAST -> = ' ' ) do
           begin
             LOUT := LOUT - 1 ;
             CPLAST := PTRADD ( CPLAST , - 1 ) ;
           end (* while *) ;
         for I := 1 to LOUT do
           begin
             WRITE ( OUTTEXT , CPOUT -> ) ;
             CPOUT := PTRADD ( CPOUT , 1 ) ;
           end (* for *) ;
         WRITELN ( OUTTEXT ) ;
       end (* else *)
   end (* WRITEBUF *) ;



begin (* HAUPTPROGRAMM *)
  READLN ( ZINP ) ;
  while not EOF ( INPUT ) do
    begin
      MEMCPY ( ADDR ( TAG ) , ADDR ( ZINP ) , 6 ) ;

  (***********************************************************)
  (*   the record tagged with FILE contains the              *)
  (*   meta information (DSN, MEM, EXT, Hex Flag)            *)
  (***********************************************************)

      if TAG = '++FILE' then
        begin
          MEMCPY ( ADDR ( DSN ) , ADDR ( ZINP [ 8 ] ) , SIZEDSN ) ;
          MEMCPY ( ADDR ( MEM ) , ADDR ( ZINP [ 58 ] ) , SIZEMEM ) ;
          MEMCPY ( ADDR ( EXT ) , ADDR ( ZINP [ 71 ] ) , SIZEEXT ) ;
          HEXFLAG := ZINP [ 79 ] ;
          ASSIGN_FILE ( ADDR ( DSN ) , ADDR ( MEM ) , ADDR ( EXT ) ,
                        HEXFLAG ) ;
          if HEXFLAG = 'H' then
            REWRITE ( OUTBIN )
          else
            REWRITE ( OUTTEXT ) ;
          LOUT := - 1 ;
          repeat
            if EOF ( INPUT ) then
              break ;
            READLN ( ZINP ) ;
            MEMCPY ( ADDR ( TAG ) , ADDR ( ZINP ) , 6 ) ;

  (***********************************************************)
  (*   the other records (DATA) are collected into           *)
  (*   the large buffer ZOUT. When the buffer is complete,   *)
  (*   WRITEBUF is called to flush the buffer.               *)
  (***********************************************************)

            if HEXFLAG = 'H' then
              begin
                if TAG = '++DATA' then
                  begin
                    if ZINP [ 7 ] = '1' then
                      begin
                        if LOUT > 0 then
                          WRITEBUF ( HEXFLAG , ADDR ( ZOUT ) , LOUT ) ;
                        LOUT := IVALSTR ( ADDR ( ZINP [ 8 ] ) , 5 ) ;
                        OUTPOS := IVALSTR ( ADDR ( ZINP [ 13 ] ) , 5 )
                                  ;
                        OUTPOS := OUTPOS * 2 ;
                        CPOUT := PTRADD ( ADDR ( ZOUT ) , OUTPOS ) ;
                        MEMCPY ( CPOUT , ADDR ( ZINP [ 19 ] ) , 100 ) ;
                      end (* then *)
                    else
                      begin
                        OUTPOS := IVALSTR ( ADDR ( ZINP [ 13 ] ) , 5 )
                                  ;
                        OUTPOS := OUTPOS * 2 ;
                        CPOUT := PTRADD ( ADDR ( ZOUT ) , OUTPOS ) ;
                        MEMCPY ( CPOUT , ADDR ( ZINP [ 19 ] ) , 100 ) ;
                      end (* else *)
                  end (* then *)
              end (* then *)
            else
              if TAG <> '++FILE' then
                WRITEBUF ( HEXFLAG , ADDR ( ZINP ) , 80 ) ;
          until TAG = '++FILE' ;
          if LOUT > 0 then
            WRITEBUF ( HEXFLAG , ADDR ( ZOUT ) , LOUT ) ;
          if HEXFLAG = 'H' then
            CLOSE ( OUTBIN )
          else
            CLOSE ( OUTTEXT ) ;
        end (* then *)
      else
        begin
          WRITELN ( '+++ falsche Satzart: ' , TAG ) ;
          break ;
        end (* else *)
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TEST1    EXT PAS HEX -
program TEST1 ( OUTPUT ) ;

(********)
(*$N+,A+*)
(********)



type CHARSET = packed array [ CHAR ] of CHAR ;
     MNEM_TABLE = array [ 0 .. 255 ] of array [ 1 .. 4 ] of CHAR ;
     INTPTR = -> INTEGER ;

     (*****************************************************************)
     (*************************************************************** *)
     (*****************************************************************)
     (*************************************************************** *)
     (*****************************************************************)
     (*                                                               *)
     (*                                                               *)
     (*    WIR TESTEN HIER MAL EINEN GROESSEREN KOMMENTAR             *)
     (*                                                               *)
     (*                                                               *)
     (*                                                               *)
     (*    DER UEBER MEHRERE ZEILEN GEHT ..................           *)
     (*                                                               *)
     (*                                                               *)
     (*                                                               *)
     (*  ************************************************************ *)
     (*******                                                         *)
     (****                                                            *)
     (*                                                               *)
     (*************************************************************** *)
     (*****************************************************************)
     (*****************************************************************)



var CH : CHAR ;
    X : CHARSET ;
    F : packed array [ 1 .. 6 ] of CHAR ;
    I : INTEGER ;
    SUMTEST : INTEGER ;


const Y : array [ 1 .. 5 ] of INTEGER =
      ( 4 , 5 , 7 , 9 , 12 ) ;
      XTBLN : MNEM_TABLE =
      ( '(00)' , '(01)' , '(02)' , '(03)' , 'SPM ' , 'BALR' , 'BCTR' ,
        'BCR ' , 'SSK ' , 'ISK ' , 'SVC ' , '(0B)' , '(0C)' , '(0D)' ,
        'MVCL' , 'CLCL' , 'LPR ' , 'LNR ' , 'LTR ' , 'LCR ' , 'NR  ' ,
        'CLR ' , 'OR  ' , 'XR  ' , 'LR  ' , 'CR  ' , 'AR  ' , 'SR  ' ,
        'MR  ' , 'DR  ' , 'ALR ' , 'SLR ' , 'LPDR' , 'LNDR' , 'LTDR' ,
        'LCDR' , 'HDR ' , 'LRDR' , 'MXR ' , 'MXDR' , 'LDR ' , 'CDR ' ,
        'ADR ' , 'SDR ' , 'MDR ' , 'DDR ' , 'AWR ' , 'SWR ' , 'LPER' ,
        'LNER' , 'LTER' , 'LCER' , 'HER ' , 'LRER' , 'AXR ' , 'SXR ' ,
        'LER ' , 'CER ' , 'AER ' , 'SER ' , 'MER ' , 'DER ' , 'AUR ' ,
        'SUR ' , 'STH ' , 'LA  ' , 'STC ' , 'IC  ' , 'EX  ' , 'BAL ' ,
        'BCT ' , 'BC  ' , 'LH  ' , 'CH  ' , 'AH  ' , 'SH  ' , 'MH  ' ,
        '(4D)' , 'CVD ' , 'CVB ' , 'ST  ' , '(51)' , '(52)' , '(53)' ,
        'N   ' , 'CL  ' , 'O   ' , 'X   ' , 'L   ' , 'C   ' , 'A   ' ,
        'S   ' , 'M   ' , 'D   ' , 'AL  ' , 'SL  ' , 'STD ' , '(61)' ,
        '(62)' , '(63)' , '(64)' , '(65)' , '(66)' , 'MXD ' , 'LD  ' ,
        'CD  ' , 'AD  ' , 'SD  ' , 'MD  ' , 'DD  ' , 'AW  ' , 'SW  ' ,
        'STE ' , '(71)' , '(72)' , '(73)' , '(74)' , '(75)' , '(76)' ,
        '(77)' , 'LE  ' , 'CE  ' , 'AE  ' , 'SE  ' , 'ME  ' , 'DE  ' ,
        'AU  ' , 'SU  ' , 'SSM ' , '(81)' , 'LPSW' , 'DIAG' , 'WRD ' ,
        'RDD ' , 'BXH ' , 'BXLE' , 'SRL ' , 'SLL ' , 'SRA ' , 'SLA ' ,
        'SRDL' , 'SLDL' , 'SRDA' , 'SLDA' , 'STM ' , 'TM  ' , 'MVI ' ,
        'TS  ' , 'NI  ' , 'CLI ' , 'OI  ' , 'XI  ' , 'LM  ' , '(99)' ,
        '(9A)' , '(9B)' , 'SIO ' , 'TIO ' , 'HIO ' , 'TCH ' , '(A0)' ,
        '(A1)' , '(A2)' , '(A3)' , '(A4)' , '(A5)' , '(A6)' , '(A7)' ,
        '(A8)' , '(A9)' , '(AA)' , '(AB)' , '(AC)' , '(AD)' , '(AE)' ,
        '(AF)' , '(B0)' , 'LRA ' , 'STCK' , '(B3)' , '(B4)' , '(B5)' ,
        'STCT' , 'LCTL' , '(B8)' , '(B9)' , '(BA)' , '(BB)' , '(BC)' ,
        'CLM ' , 'STCM' , 'ICM ' , '(C0)' , '(C1)' , '(C2)' , '(C3)' ,
        '(C4)' , '(C5)' , '(C6)' , '(C7)' , '(C8)' , '(C9)' , '(CA)' ,
        '(CB)' , '(CC)' , '(CD)' , '(CE)' , '(CF)' , '(D0)' , 'MVN ' ,
        'MVC ' , 'MVZ ' , 'NC  ' , 'CLC ' , 'OC  ' , 'XC  ' , '(D8)' ,
        '(D9)' , '(DA)' , '(DB)' , 'TR  ' , 'TRT ' , 'ED  ' , 'EDMK' ,
        '(E0)' , '(E1)' , '(E2)' , '(E3)' , '(E4)' , '(E5)' , '(E6)' ,
        '(E7)' , '(E8)' , '(E9)' , '(EA)' , '(EB)' , '(EC)' , '(ED)' ,
        '(EE)' , '(EF)' , 'SRP ' , 'MVO ' , 'PACK' , 'UNPK' , '(F4)' ,
        '(F5)' , '(F6)' , '(F7)' , 'ZAP ' , 'CP  ' , 'AP  ' , 'SP  ' ,
        'MP  ' , 'DP  ' , '(FE)' , '(FF)' ) ;



procedure CHARSET_INI ( var X : CHARSET ) ;

   var CH : CHAR ;

   begin (* CHARSET_INI *)

     (********************************************)
     (* HIER SIND NEUERDINGS KOMMENTARE MOEGLICH *)
     (********************************************)

     for CH := CHR ( 0 ) to CHR ( 255 ) do
       X [ CH ] := ' '
   end (* CHARSET_INI *) ;



procedure CHARSET_ADD ( var X : CHARSET ; VON : CHAR ; BIS : CHAR ) ;

   var CH : CHAR ;

   begin (* CHARSET_ADD *)
     for CH := VON to BIS do
       begin
         if CH = 'F' then
           return ;
         X [ CH ] := 'J'
       end (* for *)
   end (* CHARSET_ADD *) ;



function IN_CHARSET ( var X : CHARSET ; SUCH : CHAR ) : BOOLEAN ;

   begin (* IN_CHARSET *)
     IN_CHARSET := ( X [ SUCH ] <> ' ' ) ;
   end (* IN_CHARSET *) ;



function IN_CHARSET1 ( var X : CHARSET ; SUCH : CHAR ; ZUSATZ : CHAR )
                     : BOOLEAN ;

   begin (* IN_CHARSET1 *)
     IN_CHARSET1 := ( X [ SUCH ] <> ' ' ) or ( SUCH = ZUSATZ ) ;
   end (* IN_CHARSET1 *) ;



begin (* HAUPTPROGRAMM *)

  (***********************************)
  (* DIESER KOMM SOLL STEHEN BLEIBEN *)
  (***********************************)

  WRITELN ( 'DATE=' , DATE ) ;

  /*****************************************/
  /* CONTINUE; /* -- YIELDS ERROR E71 -- */*/
  /*****************************************/

  F := 'BERND ' ;
  for I := 1 to 6 do
    begin
      if F [ I ] = 'D' then
        break ;
      if F [ I ] = 'E' then
        continue ;
      WRITELN ( 'FOR-SCHLEIFE: I = ' , I : 3 , ' F(I) = ' , F [ I ] ) ;
    end (* for *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  while F [ I ] <> ' ' do
    begin
      if F [ I ] = 'D' then
        break ;
      if F [ I ] = 'R' then
        begin
          I := I + 1 ;
          continue
        end (* then *) ;
      WRITELN ( 'WHILE-SCHLEIFE: I = ' , I : 3 ) ;
      I := I + 1 ;
    end (* while *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  repeat
    if F [ I ] = 'D' then
      break ;
    if F [ I ] = 'R' then
      begin
        I := I + 1 ;
        continue
      end (* then *) ;
    WRITELN ( 'REPEAT-SCHLEIFE: I = ' , I : 3 ) ;
    I := I + 1 ;
  until F [ I ] = ' ' ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  F := 'BERND ' ;
  for I := 1 to 6 do
    begin
      WRITELN ( 'FOR-SCHLEIFE: I = ' , I : 3 , ' F(I) = ' , F [ I ] ) ;
      break ;

  (*****************************)
  (* DIESER KOMM BLEIBT STEHEN *)
  (*****************************)

    end (* for *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  while F [ I ] <> ' ' do
    begin
      WRITELN ( 'WHILE-SCHLEIFE: I = ' , I : 3 ) ;
      I := I + 1 ;
      break ;
    end (* while *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  repeat
    WRITELN ( 'REPEAT-SCHLEIFE: I = ' , I : 3 ) ;
    I := I + 1 ;
    break ;
  until F [ I ] = ' ' ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  F := 'BERND ' ;
  for I := 1 to 6 do
    begin
      WRITELN ( 'FOR-SCHLEIFE: I = ' , I : 3 , ' F(I) = ' , F [ I ] ) ;
      continue ;
    end (* for *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  while F [ I ] <> ' ' do
    begin
      WRITELN ( 'WHILE-SCHLEIFE: I = ' , I : 3 ) ;
      I := I + 1 ;
      continue ;
    end (* while *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  repeat
    WRITELN ( 'REPEAT-SCHLEIFE: I = ' , I : 3 ) ;
    I := I + 1 ;
    continue ;
  until F [ I ] = ' ' ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  CHARSET_INI ( X ) ;
  CHARSET_ADD ( X , 'A' , 'Z' ) ;
  CH := 'A' ;
  WRITELN ( 'ORD VON A = ' , ORD ( CH ) ) ;
  WRITELN ( 'AUSGABE VON X:' ) ;
  WRITELN ( X ) ;
  WRITELN ( 'ENDE AUSGABE VON X' ) ;
  WRITELN ( F ) ;

  /*********/
  /*RETURN;*/
  /*********/

  WRITELN ( 'BUCHSTABE A IN X: ' , IN_CHARSET ( X , 'A' ) ) ;
  WRITELN ( 'ZIFFER 5 IN X: ' , IN_CHARSET ( X , '5' ) ) ;

  (*************************)
  (* KOMMENTAR ZUM SCHLUSS *)
  (*************************)

  for I := 0 to 255 do
    WRITELN ( I , ' = ' , XTBLN ( I ) ) ;
  I := 3 ;
  SUMTEST := Y [ I ] + Y [ I + 2 ] ;
  WRITELN ( 'sumtest = ' , SUMTEST ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TEST2    EXT PAS HEX -
program test2(input, output);

var
    a: integer;

begin
    a := 3;
   writeln(a)
end.
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTAND  EXT PAS HEX -
program TESTAND ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



var X , Y : INTEGER ;
    A , B : BOOLEAN ;


begin (* HAUPTPROGRAMM *)
  X := 0X0E ;
  Y := 0X1D ;
  A := FALSE ;
  B := TRUE ;
  WRITELN ( 'x        ' , X ) ;
  WRITELN ( 'y        ' , Y ) ;
  WRITELN ( 'x and y  ' , X and Y ) ;
  WRITELN ( 'x and y  ' , X & Y ) ;
  WRITELN ( 'x or y   ' , X or Y ) ;
  WRITELN ( 'x or y   ' , X  Y ) ;
  WRITELN ( 'x xor y  ' , X xor Y ) ;
  WRITELN ( 'not x    ' , not X ) ;
  WRITELN ( 'not y    ' , not Y ) ;
  WRITELN ( 'a        ' , A ) ;
  WRITELN ( 'b        ' , B ) ;
  WRITELN ( 'a and b  ' , A and B ) ;
  WRITELN ( 'a and b  ' , A & B ) ;
  WRITELN ( 'a or b   ' , A or B ) ;
  WRITELN ( 'a or b   ' , A  B ) ;
  WRITELN ( 'a xor b  ' , A xor B ) ;
  WRITELN ( 'not a    ' , not A ) ;
  WRITELN ( 'not b    ' , not B ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTASM  EXT PAS HEX -
program TESTASM ( OUTPUT ) ;

//**********************************************************************
//
// test program to test calls of external subroutines
// from Stanford Pascal
// written in ASSEMBLER and FORTRAN (and Pascal)
//
// Bernd Oppolzer - 12.2017
//
//$A+
//**********************************************************************



type CHAR20 = array [ 1 .. 20 ] of CHAR ;


var I : INTEGER ;
    N : INTEGER ;
    C1 : CHAR20 ;
    C2 : CHAR20 ;
    XRES : INTEGER ;
    WINDOWS : BOOLEAN ;



procedure PASCAL_TO_PASCAL ( X1 : INTEGER ; var X2 : INTEGER ; T1 :
                           CHAR20 ; var T2 : CHAR20 ) ;

   EXTERNAL 'PAS2PAS' ;



procedure PASCAL_TO_ASSEMBLER ( X1 : INTEGER ; var X2 : INTEGER ; T1 :
                              CHAR20 ; var T2 : CHAR20 ) ;

   EXTERNAL ASSEMBLER 'PAS2ASM' ;



procedure PASCAL_TO_FORTRAN ( X1 : INTEGER ; var X2 : INTEGER ; T1 :
                            CHAR20 ; var T2 : CHAR20 ) ;

   EXTERNAL FORTRAN 'PAS2FTN' ;



function PAS_TO_PAS_FUNC ( X1 : INTEGER ; X2 : INTEGER ) : INTEGER ;

   EXTERNAL 'PAS2PF' ;



function PAS_TO_ASM_FUNC ( X1 : INTEGER ; X2 : INTEGER ) : INTEGER ;

   EXTERNAL ASSEMBLER 'PAS2AF' ;



function PAS_TO_FTN_FUNC ( X1 : INTEGER ; X2 : INTEGER ) : INTEGER ;

   EXTERNAL FORTRAN 'PAS2FF' ;



begin (* HAUPTPROGRAMM *)
  WINDOWS := FALSE ;
  if ORD ( '0' ) <> 0xf0 then
    WINDOWS := TRUE ;
  WRITELN ( 'Test external calls from Pascal' ) ;

  //******************************************************************
  // set variables and test call of PASCAL proc
  //******************************************************************

  I := 42 ;
  N := 42 ;
  C1 := 'Test string 1' ;
  C2 := 'Test string 2' ;
  WRITELN ( 'Values before PAS2PAS call:' ) ;
  WRITELN ( 'i   = ' , I ) ;
  WRITELN ( 'n   = ' , N ) ;
  WRITELN ( 'c1  = <' , C1 , '>' ) ;
  WRITELN ( 'c2  = <' , C2 , '>' ) ;
  PASCAL_TO_PASCAL ( I , N , C1 , C2 ) ;
  WRITELN ( 'Values after PAS2PAS call:' ) ;
  WRITELN ( 'i   = ' , I ) ;
  WRITELN ( 'n   = ' , N ) ;
  WRITELN ( 'c1  = <' , C1 , '>' ) ;
  WRITELN ( 'c2  = <' , C2 , '>' ) ;

  //******************************************************************
  // set variables and test call of ASSEMBLER proc
  //******************************************************************

  if TRUE then
    begin
      I := 42 ;
      N := 42 ;
      C1 := 'Test string 1' ;
      C2 := 'Test string 2' ;
      WRITELN ( 'Values before PAS2ASM call:' ) ;
      WRITELN ( 'i   = ' , I ) ;
      WRITELN ( 'n   = ' , N ) ;
      WRITELN ( 'c1  = <' , C1 , '>' ) ;
      WRITELN ( 'c2  = <' , C2 , '>' ) ;
      PASCAL_TO_ASSEMBLER ( I , N , C1 , C2 ) ;
      WRITELN ( 'Values after PAS2ASM call:' ) ;
      WRITELN ( 'i   = ' , I ) ;
      WRITELN ( 'n   = ' , N ) ;
      WRITELN ( 'c1  = <' , C1 , '>' ) ;
      WRITELN ( 'c2  = <' , C2 , '>' ) ;
    end (* then *) ;

  //******************************************************************
  // set variables and test call of FORTRAN subroutine
  //******************************************************************

  if not WINDOWS then
    begin
      I := 42 ;
      N := 42 ;
      C1 := 'Test string 1' ;
      C2 := 'Test string 2' ;
      WRITELN ( 'Values before PAS2FTN call:' ) ;
      WRITELN ( 'i   = ' , I ) ;
      WRITELN ( 'n   = ' , N ) ;
      WRITELN ( 'c1  = <' , C1 , '>' ) ;
      WRITELN ( 'c2  = <' , C2 , '>' ) ;
      PASCAL_TO_FORTRAN ( I , N , C1 , C2 ) ;
      WRITELN ( 'Values after PAS2FTN call:' ) ;
      WRITELN ( 'i   = ' , I ) ;
      WRITELN ( 'n   = ' , N ) ;
      WRITELN ( 'c1  = <' , C1 , '>' ) ;
      WRITELN ( 'c2  = <' , C2 , '>' ) ;
    end (* then *) ;

  //******************************************************************
  // test call of external functions
  //******************************************************************

  XRES := PAS_TO_PAS_FUNC ( 20 , 30 ) ;
  WRITELN ( 'PAS_TO_PAS_FUNC (20, 30) RETURNS ' , XRES ) ;
  if WINDOWS then
    return ;
  XRES := PAS_TO_ASM_FUNC ( 20 , 30 ) ;
  WRITELN ( 'PAS_TO_ASM_FUNC (20, 30) RETURNS ' , XRES ) ;
  XRES := PAS_TO_FTN_FUNC ( 20 , 30 ) ;
  WRITELN ( 'PAS_TO_FTN_FUNC (20, 30) RETURNS ' , XRES ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTAVL  EXT PAS HEX -
program TESTAVL ( OUTPUT ) ;

//***************************************************************
// test program to test avltree library module
//***************************************************************
//$X+
//***************************************************************



type CACHEPTR = -> CACHEREC ;
     CACHEREC = record
                  MAGIC : CHAR ( 8 ) ;     // always 'AVLCACHE'
                  CNAME : CHAR ( 8 ) ;     // Name of Cache
                  COUNT : INTEGER ;        // Nbr of entries
                  PTREE : VOIDPTR ;        // ptr to tree
                end ;


var I : INTEGER ;
    RC : INTEGER ;
    PBAUM : VOIDPTR ;
    PELEMENT : VOIDPTR ;
    PLAUF : VOIDPTR ;
    HCHANGED : BOOLEAN ;
    GEFUNDEN : BOOLEAN ;
    VVEKTOR : array [ 1 .. 20 ] of INTEGER ;
    KEYLEN : INTEGER ;
    POBJ : VOIDPTR ;
    OBJLEN : INTEGER ;
    POBJLEN : -> INTEGER ;
    PINT : -> INTEGER ;
    S9 : STRING ( 9 ) ;
    PS9 : -> STRING ( 9 ) ;
    SEQKEY : VOIDPTR ;
    PKEY : VOIDPTR ;
    LKEY : INTEGER ;
    PDAT : VOIDPTR ;
    LDAT : INTEGER ;
    CACHENAME : CHAR ( 8 ) ;
    KEY : CHAR ( 8 ) ;
    DAT : CHAR ( 12 ) ;
    PCACHE : CACHEPTR ;
    PC12 : -> CHAR ( 12 ) ;
    DUMMYP : VOIDPTR ;
    DUMMYI : INTEGER ;



function AVLSRCH ( SKEY : VOIDPTR ;         // ptr to key
                 SKEYLEN : INTEGER ;        // keylen (if deep copy)
                 var POBJ : VOIDPTR ;       // ptr to obj ptr
                 var POBJLEN : VOIDPTR ;    // ptr to objlen field
                 var GEFUNDEN : BOOLEAN ;   // true if found
                 var PP : VOIDPTR ;         // tree pointer
                 var HCHANGED : BOOLEAN ;   // height changed
                 EINFUEGEN : BOOLEAN ;      // if insert then true
                 function AVLCOMP ( X1 : VOIDPTR ; L1 : INTEGER ; X2 :
                 VOIDPTR ; L2 : INTEGER ) : INTEGER ) : VOIDPTR ;

   EXTERNAL ;



function AVLSRCHX ( SKEY : VOIDPTR ;        // ptr to key
                  SKEYLEN : INTEGER ;       // keylen (if deep copy)
                  var POBJ : VOIDPTR ;      // ptr to obj ptr
                  var POBJLEN : VOIDPTR ;   // ptr to objlen field
                  var GEFUNDEN : BOOLEAN ;  // true if found
                  var PP : VOIDPTR ;        // tree pointer
                  var HCHANGED : BOOLEAN ;  // height changed
                  EINFUEGEN : BOOLEAN ;     // if insert then true
                  MODUS : CHAR ;            // = or > (type of search)
                  function AVLCOMP ( X1 : VOIDPTR ; L1 : INTEGER ; X2 :
                  VOIDPTR ; L2 : INTEGER ) : INTEGER ) : VOIDPTR ;

   EXTERNAL ;



function AVLGET ( MODUS : CHAR ;            // mode = F(irst), N(ext)
                START : VOIDPTR ;           // starting position
                var RESULT : VOIDPTR ;      // new position
                var PKEY : VOIDPTR ;        // pointer to key
                var KEYLEN : INTEGER ;      // keylen
                var POBJ : VOIDPTR ;        // pointer to obj
                var OBJLEN : INTEGER )      // objlen
                : INTEGER ;                 // zero, if OK

   EXTERNAL ;



procedure AVLPRINT ( P : VOIDPTR ;            // tree to print
                   var AUSGFILE : TEXT ;      // output file
                   EINRUECK : INTEGER ;       // indentation count
                   PV : VOIDPTR ;             // nil on top level call
                   RICHTUNG : CHAR ;          // blank on top level call
                   procedure AVLPKEY ( var F : TEXT ; P : VOIDPTR ) ) ;

   EXTERNAL ;



procedure AVLFREE ( P : VOIDPTR ) ;

   EXTERNAL ;



function AVLCACHE ( FUNKCODE : CHAR ( 8 ) ;   // Funktionscode
                  PHANDLE : VOIDPTR ;         // Cachehandle
                  var SEQKEY : VOIDPTR ;      // seq. Keyposition,
                  var PKEY : VOIDPTR ;        // Zeiger auf Key
                  var LKEY : INTEGER ;        // Laenge Key
                  var PDAT : VOIDPTR ;        // Zeiger auf Daten
                  var LDAT : INTEGER )        // Laenge Daten
                  : INTEGER ;

   EXTERNAL ;



function COMPARE ( X1 : VOIDPTR ; L1 : INTEGER ; X2 : VOIDPTR ; L2 :
                 INTEGER ) : INTEGER ;

//***************************************************************
// compare function for AVL tree key values (here: integer keys)
// this function is passed as a parameter to avlsrch
//***************************************************************


   var I1 : INTEGER ;
       IP1 : -> INTEGER ;
       I2 : INTEGER ;
       IP2 : -> INTEGER ;

   begin (* COMPARE *)
     IP1 := X1 ;
     IP2 := X2 ;
     I1 := IP1 -> ;
     I2 := IP2 -> ;
     if I1 > I2 then
       COMPARE := 1
     else
       if I1 < I2 then
         COMPARE := - 1
       else
         COMPARE := 0 ;
   end (* COMPARE *) ;



procedure PRINTELEM ( var F : TEXT ; X : VOIDPTR ) ;

//***************************************************************
// print key value
// this function is passed as a parameter to avlprint
//***************************************************************


   var I1 : INTEGER ;
       IP1 : -> INTEGER ;

   begin (* PRINTELEM *)
     IP1 := X ;
     I1 := IP1 -> ;
     WRITE ( F , I1 : 8 ) ;
   end (* PRINTELEM *) ;



function COMPARE_S9 ( X1 : VOIDPTR ; L1 : INTEGER ; X2 : VOIDPTR ; L2 :
                    INTEGER ) : INTEGER ;

//******************************************************************
// compare function for AVL tree key values (here: string(9) keys)
// this function is passed as a parameter to avlsrch
//******************************************************************


   var S1 : STRING ( 9 ) ;
       SP1 : -> STRING ( 9 ) ;
       S2 : STRING ( 9 ) ;
       SP2 : -> STRING ( 9 ) ;

   begin (* COMPARE_S9 *)
     SP1 := X1 ;
     SP2 := X2 ;
     S1 := SP1 -> ;
     S2 := SP2 -> ;
     if S1 > S2 then
       COMPARE_S9 := 1
     else
       if S1 < S2 then
         COMPARE_S9 := - 1
       else
         COMPARE_S9 := 0 ;
   end (* COMPARE_S9 *) ;



procedure PRINT_S9 ( var F : TEXT ; X : VOIDPTR ) ;

//**********************************************************
// print key value
// this function is passed as a parameter to avlprint
//**********************************************************


   var S1 : STRING ( 9 ) ;
       SP1 : -> STRING ( 9 ) ;

   begin (* PRINT_S9 *)
     SP1 := X ;
     S1 := SP1 -> ;
     WRITE ( F , S1 : 10 ) ;
   end (* PRINT_S9 *) ;



procedure INSERT_WORD ;

   type TPINT = -> INTEGER ;
        TPPINT = -> TPINT ;

   var PPINT : TPPINT ;
       PINT : TPINT ;

   begin (* INSERT_WORD *)
     HCHANGED := FALSE ;
     PELEMENT := AVLSRCH ( ADDR ( S9 ) , SIZEOF ( S9 ) , POBJ , POBJLEN
                 , GEFUNDEN , PBAUM , HCHANGED , TRUE , COMPARE_S9 ) ;
     if GEFUNDEN then
       begin
         PPINT := POBJ ;
         PINT := PPINT -> ;
         PINT -> := PINT -> + 1 ;
       end (* then *)
     else
       begin
         PINT := ALLOC ( SIZEOF ( INTEGER ) ) ;
         PINT -> := 1 ;
         PPINT := POBJ ;
         PPINT -> := PINT ;
         PINT := POBJLEN ;
         PINT -> := SIZEOF ( INTEGER ) ;
       end (* else *)
   end (* INSERT_WORD *) ;



procedure TEST1 ;

   begin (* TEST1 *)
     VVEKTOR [ 1 ] := 3 ;
     VVEKTOR [ 2 ] := 5 ;
     VVEKTOR [ 3 ] := 7 ;
     VVEKTOR [ 4 ] := 12 ;
     VVEKTOR [ 5 ] := 34 ;
     VVEKTOR [ 6 ] := 1 ;
     VVEKTOR [ 7 ] := 6 ;
     VVEKTOR [ 8 ] := 23 ;
     VVEKTOR [ 9 ] := 78 ;
     VVEKTOR [ 10 ] := 45 ;
     VVEKTOR [ 11 ] := 32 ;
     VVEKTOR [ 12 ] := 89 ;
     VVEKTOR [ 13 ] := 11 ;
     VVEKTOR [ 14 ] := 102 ;
     VVEKTOR [ 15 ] := 2 ;
     VVEKTOR [ 16 ] := 77 ;
     VVEKTOR [ 17 ] := 4 ;
     VVEKTOR [ 18 ] := 66 ;
     VVEKTOR [ 19 ] := 44 ;
     VVEKTOR [ 20 ] := 99 ;

     //**********************************************************
     // insert values into AVL tree
     // only pointers are recorded in AVL tree, no deep copy
     //**********************************************************

     WRITELN ;
     WRITELN ( 'values are inserted into AVL tree' ) ;
     WRITELN ( 'using general procedure AVLSRCH' ) ;
     WRITELN ( '===================================================' )
               ;
     PBAUM := NIL ;
     for I := 1 to 20 do
       begin
         HCHANGED := FALSE ;
         PELEMENT := AVLSRCH ( ADDR ( VVEKTOR [ I ] ) , 0 , POBJ ,
                     POBJLEN , GEFUNDEN , PBAUM , HCHANGED , TRUE ,
                     COMPARE ) ;
       end (* for *) ;

     //*******************************************
     // print AVL tree using AVLPRINT
     //*******************************************

     WRITELN ;
     WRITELN ( 'print AVL tree using general procedure AVLPRINT' ) ;
     WRITELN ( '===================================================' )
               ;
     AVLPRINT ( PBAUM , OUTPUT , 8 , NIL , ' ' , PRINTELEM ) ;

     //*******************************************
     // walk thru AVL tree and print values
     //*******************************************

     WRITELN ;
     WRITELN ( 'walk thru AVL tree using general procedure AVLGET' ) ;
     WRITELN ( '===================================================' )
               ;
     RC := AVLGET ( 'F' , PBAUM , PLAUF , PINT , KEYLEN , POBJ , OBJLEN
           ) ;
     while RC = 0 do
       begin
         WRITELN ( 'aus AVL-Baum: ' , PINT -> , '   Keylen: ' , KEYLEN
                   ) ;
         RC := AVLGET ( 'N' , PBAUM , PLAUF , PINT , KEYLEN , POBJ ,
               OBJLEN ) ;
       end (* while *) ;
     AVLFREE ( PBAUM ) ;

     //*******************************************
     // insert values into AVL tree
     // now with deep copy
     //*******************************************

     WRITELN ;
     WRITELN ( 'values are inserted into AVL tree' ) ;
     WRITELN ( 'using general procedure AVLSRCH' ) ;
     WRITELN ( '===================================================' )
               ;
     PBAUM := NIL ;
     for I := 1 to 20 do
       begin
         HCHANGED := FALSE ;
         PELEMENT := AVLSRCH ( ADDR ( VVEKTOR [ I ] ) , SIZEOF (
                     INTEGER ) , POBJ , POBJLEN , GEFUNDEN , PBAUM ,
                     HCHANGED , TRUE , COMPARE ) ;
       end (* for *) ;

     //*******************************************
     // print AVL tree using AVLPRINT
     //*******************************************

     WRITELN ;
     WRITELN ( 'print AVL tree using general procedure AVLPRINT' ) ;
     WRITELN ( '===================================================' )
               ;
     AVLPRINT ( PBAUM , OUTPUT , 8 , NIL , ' ' , PRINTELEM ) ;

     //*******************************************
     // walk thru AVL tree and print values
     //*******************************************

     WRITELN ;
     WRITELN ( 'walk thru AVL tree using general procedure AVLGET' ) ;
     WRITELN ( '===================================================' )
               ;
     RC := AVLGET ( 'F' , PBAUM , PLAUF , PINT , KEYLEN , POBJ , OBJLEN
           ) ;
     while RC = 0 do
       begin
         WRITELN ( 'aus AVL-Baum: ' , PINT -> , '   Keylen: ' , KEYLEN
                   ) ;
         RC := AVLGET ( 'N' , PBAUM , PLAUF , PINT , KEYLEN , POBJ ,
               OBJLEN ) ;
       end (* while *) ;
     AVLFREE ( PBAUM ) ;
   end (* TEST1 *) ;



procedure TEST2 ;

   type TP = -> STRING ( 9 ) ;
        TPI = -> INTEGER ;

   var S9A : STRING ( 9 ) ;
       PP : -> TP ;
       P : TP ;
       PPI : -> TPI ;
       PI : TPI ;
       PKEY_NEU : VOIDPTR ;
       PKEYLEN_NEU : -> INTEGER ;

   begin (* TEST2 *)

     //************************************************************
     // insert values into AVL tree
     // string (9) variables instead of integers
     //************************************************************
     // the same variable is used again and again to insert values
     // into the AVL tree; this is only valid if deep copy is speci
     //fied
     // (the second parameter of AVLSRCH needs to be equal to the
     // key size in this case)
     //************************************************************
     // most interesting: the AVL functions work for different
     // key types; the compare functions passed as parameter handle
     // the differences
     //************************************************************

     WRITELN ;
     WRITELN ( 'values are inserted into AVL tree' ) ;
     WRITELN ( 'using general procedure AVLSRCH' ) ;
     WRITELN ( '===================================================' )
               ;
     PBAUM := NIL ;
     S9 := 'wovon' ;
     INSERT_WORD ;
     S9 := 'man' ;
     INSERT_WORD ;
     S9 := 'nicht' ;
     INSERT_WORD ;
     S9 := 'reden' ;
     INSERT_WORD ;
     S9 := 'kann' ;
     INSERT_WORD ;
     S9 := 'davon' ;
     INSERT_WORD ;
     S9 := 'muss' ;
     INSERT_WORD ;
     S9 := 'man' ;
     INSERT_WORD ;
     S9 := 'schweigen' ;
     INSERT_WORD ;

     //*******************************************
     // print AVL tree using AVLPRINT
     //*******************************************

     WRITELN ;
     WRITELN ( 'print AVL tree using general procedure AVLPRINT' ) ;
     WRITELN ( '===================================================' )
               ;
     AVLPRINT ( PBAUM , OUTPUT , 10 , NIL , ' ' , PRINT_S9 ) ;

     //*******************************************
     // walk thru AVL tree and print values
     //*******************************************

     WRITELN ;
     WRITELN ( 'walk thru AVL tree using general procedure AVLGET' ) ;
     WRITELN ( '===================================================' )
               ;
     PLAUF := NIL ;
     RC := AVLGET ( 'N' , PBAUM , PLAUF , PS9 , KEYLEN , POBJ , OBJLEN
           ) ;
     while RC = 0 do
       begin
         PINT := POBJ ;
         WRITELN ( 'aus AVL-Baum: ' , PS9 -> : 9 , '   Keylen: ' ,
                   KEYLEN , '   Obj: ' , PINT -> ) ;
         RC := AVLGET ( 'N' , PBAUM , PLAUF , PS9 , KEYLEN , POBJ ,
               OBJLEN ) ;
       end (* while *) ;

     //*******************************************
     // test AVLSRCHX using > search
     //*******************************************

     WRITELN ;
     WRITELN ( 'test AVLSRCHX (success)' ) ;
     WRITELN ( '===================================================' )
               ;
     HCHANGED := FALSE ;
     S9A := 'bernd' ;
     PELEMENT := AVLSRCHX ( ADDR ( S9A ) , SIZEOF ( S9A ) , PKEY_NEU ,
                 PKEYLEN_NEU , GEFUNDEN , PBAUM , HCHANGED , FALSE ,
                 '>' , COMPARE_S9 ) ;
     WRITELN ( 'gefunden    = ' , GEFUNDEN ) ;
     WRITELN ( 'pkey neu    = ' , PKEY_NEU ) ;
     WRITELN ( 'pkeylen neu = ' , PKEYLEN_NEU ) ;
     PP := PKEY_NEU ;
     if PP <> NIL then
       begin
         P := PP -> ;
         WRITELN ( 'key         = ' , P -> ) ;
       end (* then *) ;
     if PKEYLEN_NEU <> NIL then
       WRITELN ( 'keylen      = ' , PKEYLEN_NEU -> ) ;
     if GEFUNDEN then
       begin
         PELEMENT := AVLSRCHX ( P , PKEYLEN_NEU -> , POBJ , POBJLEN ,
                     GEFUNDEN , PBAUM , HCHANGED , FALSE , '=' ,
                     COMPARE_S9 ) ;
         WRITELN ( 'gefunden    = ' , GEFUNDEN ) ;
         WRITELN ( 'pobj        = ' , POBJ ) ;
         WRITELN ( 'pobjlen     = ' , POBJLEN ) ;
         PPI := POBJ ;
         if PPI <> NIL then
           begin
             PI := PPI -> ;
             WRITELN ( 'obj         = ' , PI -> ) ;
           end (* then *) ;
         if POBJLEN <> NIL then
           WRITELN ( 'objlen      = ' , POBJLEN -> ) ;
       end (* then *) ;
     WRITELN ;
     WRITELN ( 'test AVLSRCHX (success)' ) ;
     WRITELN ( '===================================================' )
               ;
     HCHANGED := FALSE ;
     S9A := 'mond' ;
     PELEMENT := AVLSRCHX ( ADDR ( S9A ) , SIZEOF ( S9A ) , PKEY_NEU ,
                 PKEYLEN_NEU , GEFUNDEN , PBAUM , HCHANGED , FALSE ,
                 '>' , COMPARE_S9 ) ;
     WRITELN ( 'gefunden    = ' , GEFUNDEN ) ;
     WRITELN ( 'pkey neu    = ' , PKEY_NEU ) ;
     WRITELN ( 'pkeylen neu = ' , PKEYLEN_NEU ) ;
     PP := PKEY_NEU ;
     if PP <> NIL then
       begin
         P := PP -> ;
         WRITELN ( 'key         = ' , P -> ) ;
       end (* then *) ;
     if PKEYLEN_NEU <> NIL then
       WRITELN ( 'keylen      = ' , PKEYLEN_NEU -> ) ;
     if GEFUNDEN then
       begin
         PELEMENT := AVLSRCHX ( P , PKEYLEN_NEU -> , POBJ , POBJLEN ,
                     GEFUNDEN , PBAUM , HCHANGED , FALSE , '=' ,
                     COMPARE_S9 ) ;
         WRITELN ( 'gefunden    = ' , GEFUNDEN ) ;
         WRITELN ( 'pobj        = ' , POBJ ) ;
         WRITELN ( 'pobjlen     = ' , POBJLEN ) ;
         PPI := POBJ ;
         if PPI <> NIL then
           begin
             PI := PPI -> ;
             WRITELN ( 'obj         = ' , PI -> ) ;
           end (* then *) ;
         if POBJLEN <> NIL then
           WRITELN ( 'objlen      = ' , POBJLEN -> ) ;
       end (* then *) ;
     WRITELN ;
     WRITELN ( 'test AVLSRCHX (no success - key too high)' ) ;
     WRITELN ( '===================================================' )
               ;
     HCHANGED := FALSE ;
     S9A := 'zzzz' ;
     PELEMENT := AVLSRCHX ( ADDR ( S9A ) , SIZEOF ( S9A ) , PKEY_NEU ,
                 PKEYLEN_NEU , GEFUNDEN , PBAUM , HCHANGED , FALSE ,
                 '>' , COMPARE_S9 ) ;
     WRITELN ( 'gefunden    = ' , GEFUNDEN ) ;
     WRITELN ( 'pkey neu    = ' , PKEY_NEU ) ;
     WRITELN ( 'pkeylen neu = ' , PKEYLEN_NEU ) ;
     PP := PKEY_NEU ;
     if PP <> NIL then
       begin
         P := PP -> ;
         WRITELN ( 'key         = ' , P -> ) ;
       end (* then *) ;
     if PKEYLEN_NEU <> NIL then
       WRITELN ( 'keylen      = ' , PKEYLEN_NEU -> ) ;
     if GEFUNDEN then
       begin
         PELEMENT := AVLSRCHX ( P , PKEYLEN_NEU -> , POBJ , POBJLEN ,
                     GEFUNDEN , PBAUM , HCHANGED , FALSE , '=' ,
                     COMPARE_S9 ) ;
         WRITELN ( 'gefunden    = ' , GEFUNDEN ) ;
         WRITELN ( 'pobj        = ' , POBJ ) ;
         WRITELN ( 'pobjlen     = ' , POBJLEN ) ;
         PPI := POBJ ;
         if PPI <> NIL then
           begin
             PI := PPI -> ;
             WRITELN ( 'obj         = ' , PI -> ) ;
           end (* then *) ;
         if POBJLEN <> NIL then
           WRITELN ( 'objlen      = ' , POBJLEN -> ) ;
       end (* then *) ;

     //*******************************************
     // free AVL tree
     //*******************************************

     AVLFREE ( PBAUM ) ;
   end (* TEST2 *) ;



procedure TEST3 ;

   begin (* TEST3 *)

     //************************************************
     // test cache create calls
     //************************************************

     WRITELN ;
     WRITELN ( 'Test AVLCACHE CREATE' ) ;
     WRITELN ( '===================================================' )
               ;
     PKEY := ADDR ( CACHENAME ) ;
     CACHENAME := 'CACHE1' ;
     RC := AVLCACHE ( 'CREATE' , NIL , SEQKEY , PKEY , LKEY , PDAT ,
           LDAT ) ;
     WRITELN ( 'RC          = ' , RC ) ;
     WRITELN ( 'PDAT        = ' , PDAT ) ;
     WRITELN ( 'LDAT        = ' , LDAT ) ;
     PCACHE := PDAT ;
     WRITELN ( 'CACHE.MAGIC = ' , PCACHE -> . MAGIC ) ;
     WRITELN ( 'CACHE.CNAME = ' , PCACHE -> . CNAME ) ;
     WRITELN ( 'CACHE.COUNT = ' , PCACHE -> . COUNT ) ;
     WRITELN ( 'CACHE.PTREE = ' , PCACHE -> . PTREE ) ;
     WRITELN ;
     WRITELN ( 'Test AVLCACHE CREATE' ) ;
     WRITELN ( '===================================================' )
               ;
     PKEY := ADDR ( CACHENAME ) ;
     CACHENAME := 'CACHE2' ;
     RC := AVLCACHE ( 'CREATE' , NIL , SEQKEY , PKEY , LKEY , PDAT ,
           LDAT ) ;
     WRITELN ( 'RC          = ' , RC ) ;
     WRITELN ( 'PDAT        = ' , PDAT ) ;
     WRITELN ( 'LDAT        = ' , LDAT ) ;
     PCACHE := PDAT ;
     WRITELN ( 'CACHE.MAGIC = ' , PCACHE -> . MAGIC ) ;
     WRITELN ( 'CACHE.CNAME = ' , PCACHE -> . CNAME ) ;
     WRITELN ( 'CACHE.COUNT = ' , PCACHE -> . COUNT ) ;
     WRITELN ( 'CACHE.PTREE = ' , PCACHE -> . PTREE ) ;
     WRITELN ;
     WRITELN ( 'Test AVLCACHE CREATE' ) ;
     WRITELN ( '===================================================' )
               ;
     PKEY := ADDR ( CACHENAME ) ;
     CACHENAME := 'CACHE1' ;
     RC := AVLCACHE ( 'CREATE' , NIL , SEQKEY , PKEY , LKEY , PDAT ,
           LDAT ) ;
     WRITELN ( 'RC          = ' , RC ) ;
     WRITELN ( 'PDAT        = ' , PDAT ) ;
     WRITELN ( 'LDAT        = ' , LDAT ) ;
     PCACHE := PDAT ;
     WRITELN ( 'CACHE.MAGIC = ' , PCACHE -> . MAGIC ) ;
     WRITELN ( 'CACHE.CNAME = ' , PCACHE -> . CNAME ) ;
     WRITELN ( 'CACHE.COUNT = ' , PCACHE -> . COUNT ) ;
     WRITELN ( 'CACHE.PTREE = ' , PCACHE -> . PTREE ) ;

     //************************************************
     // test put calls
     //************************************************

     WRITELN ;
     WRITELN ( 'Test AVLCACHE PUT' ) ;
     WRITELN ( '===================================================' )
               ;
     KEY := 'BERND' ;
     DAT := 'OPPOLZER' ;
     PKEY := ADDR ( KEY ) ;
     LKEY := 5 ;
     PDAT := ADDR ( DAT ) ;
     LDAT := 12 ;
     RC := AVLCACHE ( 'PUT' , PCACHE , SEQKEY , PKEY , LKEY , PDAT ,
           LDAT ) ;
     WRITELN ( 'RC          = ' , RC ) ;
     WRITELN ;
     WRITELN ( 'Test AVLCACHE PUT' ) ;
     WRITELN ( '===================================================' )
               ;
     KEY := 'BERND' ;
     DAT := 'OPPOLZER' ;
     PKEY := ADDR ( KEY ) ;
     LKEY := 5 ;
     PDAT := ADDR ( DAT ) ;
     LDAT := 12 ;
     RC := AVLCACHE ( 'PUT' , PCACHE , SEQKEY , PKEY , LKEY , PDAT ,
           LDAT ) ;
     WRITELN ( 'RC          = ' , RC ) ;
     WRITELN ;
     WRITELN ( 'Test AVLCACHE PUT' ) ;
     WRITELN ( '===================================================' )
               ;
     KEY := 'BERND2' ;
     DAT := 'OPPOLZER' ;
     PKEY := ADDR ( KEY ) ;
     LKEY := 6 ;
     PDAT := ADDR ( DAT ) ;
     LDAT := 12 ;
     RC := AVLCACHE ( 'PUT' , PCACHE , SEQKEY , PKEY , LKEY , PDAT ,
           LDAT ) ;
     WRITELN ( 'RC          = ' , RC ) ;
     WRITELN ;
     WRITELN ( 'Test AVLCACHE PUT' ) ;
     WRITELN ( '===================================================' )
               ;
     KEY := 'BERND1' ;
     DAT := 'Oppolzer' ;
     PKEY := ADDR ( KEY ) ;
     LKEY := 6 ;
     PDAT := ADDR ( DAT ) ;
     LDAT := 12 ;
     RC := AVLCACHE ( 'PUT' , PCACHE , SEQKEY , PKEY , LKEY , PDAT ,
           LDAT ) ;
     WRITELN ( 'RC          = ' , RC ) ;

     //************************************************
     // nochmal test create
     //************************************************

     WRITELN ;
     WRITELN ( 'Test AVLCACHE CREATE' ) ;
     WRITELN ( '===================================================' )
               ;
     PKEY := ADDR ( CACHENAME ) ;
     CACHENAME := 'CACHE1' ;
     RC := AVLCACHE ( 'CREATE' , NIL , SEQKEY , PKEY , LKEY , PDAT ,
           LDAT ) ;
     WRITELN ( 'RC          = ' , RC ) ;
     WRITELN ( 'PDAT        = ' , PDAT ) ;
     WRITELN ( 'LDAT        = ' , LDAT ) ;
     PCACHE := PDAT ;
     WRITELN ( 'CACHE.MAGIC = ' , PCACHE -> . MAGIC ) ;
     WRITELN ( 'CACHE.CNAME = ' , PCACHE -> . CNAME ) ;
     WRITELN ( 'CACHE.COUNT = ' , PCACHE -> . COUNT ) ;
     WRITELN ( 'CACHE.PTREE = ' , PCACHE -> . PTREE ) ;

     //************************************************
     // test get
     //************************************************

     WRITELN ;
     WRITELN ( 'Test AVLCACHE GET' ) ;
     WRITELN ( '===================================================' )
               ;
     KEY := 'BERND2' ;
     PKEY := ADDR ( KEY ) ;
     LKEY := 6 ;
     PDAT := NIL ;
     LDAT := 0 ;
     RC := AVLCACHE ( 'GET' , PCACHE , SEQKEY , PKEY , LKEY , PDAT ,
           LDAT ) ;
     WRITELN ( 'RC          = ' , RC ) ;
     WRITELN ( 'PDAT        = ' , PDAT ) ;
     WRITELN ( 'LDAT        = ' , LDAT ) ;
     if RC = 0 then
       begin
         PC12 := PDAT ;
         WRITELN ( 'PC12        = ' , PC12 ) ;
         WRITELN ( 'PC12 ->     = ' , PC12 -> ) ;
       end (* then *) ;

     //************************************************
     // test gfirst
     //************************************************

     WRITELN ;
     WRITELN ( 'Test AVLCACHE GFIRST und GNEXT' ) ;
     WRITELN ( '===================================================' )
               ;
     PKEY := NIL ;
     LKEY := 0 ;
     PDAT := NIL ;
     LDAT := 0 ;
     SEQKEY := NIL ;
     RC := AVLCACHE ( 'GFIRST' , PCACHE , SEQKEY , PKEY , LKEY , PDAT ,
           LDAT ) ;
     WRITELN ( 'RC          = ' , RC ) ;
     WRITELN ( 'PKEY        = ' , PKEY ) ;
     WRITELN ( 'LKEY        = ' , LKEY ) ;
     WRITELN ( 'PDAT        = ' , PDAT ) ;
     WRITELN ( 'LDAT        = ' , LDAT ) ;
     WRITELN ( 'SEQKEY      = ' , SEQKEY ) ;
     if RC = 0 then
       begin
         PC12 := PKEY ;
         WRITELN ( 'PKEY ->     = ' , SUBSTR ( PC12 -> , 1 , LKEY ) ) ;
         PC12 := PDAT ;
         WRITELN ( 'PDAT ->     = ' , SUBSTR ( PC12 -> , 1 , LDAT ) ) ;
       end (* then *) ;
     while TRUE do
       begin
         PKEY := NIL ;
         LKEY := 0 ;
         PDAT := NIL ;
         LDAT := 0 ;
         RC := AVLCACHE ( 'GNEXT' , PCACHE , SEQKEY , PKEY , LKEY ,
               PDAT , LDAT ) ;
         WRITELN ( 'RC          = ' , RC ) ;
         WRITELN ( 'PKEY        = ' , PKEY ) ;
         WRITELN ( 'LKEY        = ' , LKEY ) ;
         WRITELN ( 'PDAT        = ' , PDAT ) ;
         WRITELN ( 'LDAT        = ' , LDAT ) ;
         WRITELN ( 'SEQKEY      = ' , SEQKEY ) ;
         if RC = 0 then
           begin
             PC12 := PKEY ;
             WRITELN ( 'PKEY ->     = ' , SUBSTR ( PC12 -> , 1 , LKEY )
                       ) ;
             PC12 := PDAT ;
             WRITELN ( 'PDAT ->     = ' , SUBSTR ( PC12 -> , 1 , LDAT )
                       ) ;
           end (* then *)
         else
           break
       end (* while *) ;
     WRITELN ;
     WRITELN ( 'Test AVLCACHE GNEXT only' ) ;
     WRITELN ( '===================================================' )
               ;
     SEQKEY := NIL ;
     while TRUE do
       begin
         PKEY := NIL ;
         LKEY := 0 ;
         PDAT := NIL ;
         LDAT := 0 ;
         RC := AVLCACHE ( 'GNEXT' , PCACHE , SEQKEY , PKEY , LKEY ,
               PDAT , LDAT ) ;
         WRITELN ( 'RC          = ' , RC ) ;
         WRITELN ( 'PKEY        = ' , PKEY ) ;
         WRITELN ( 'LKEY        = ' , LKEY ) ;
         WRITELN ( 'PDAT        = ' , PDAT ) ;
         WRITELN ( 'LDAT        = ' , LDAT ) ;
         WRITELN ( 'SEQKEY      = ' , SEQKEY ) ;
         if RC = 0 then
           begin
             PC12 := PKEY ;
             WRITELN ( 'PKEY ->     = ' , SUBSTR ( PC12 -> , 1 , LKEY )
                       ) ;
             PC12 := PDAT ;
             WRITELN ( 'PDAT ->     = ' , SUBSTR ( PC12 -> , 1 , LDAT )
                       ) ;
           end (* then *)
         else
           break
       end (* while *) ;
     WRITELN ;
     WRITELN ( 'Test AVLCACHE TRACE' ) ;
     WRITELN ( '===================================================' )
               ;
     PKEY := ADDR ( CACHENAME ) ;
     RC := AVLCACHE ( 'TRACE' , PCACHE , DUMMYP , PKEY , DUMMYI ,
           DUMMYP , DUMMYI ) ;

     //************************************************
     // nochmal test create
     //************************************************

     WRITELN ;
     WRITELN ( 'Test AVLCACHE CREATE' ) ;
     WRITELN ( '===================================================' )
               ;
     PKEY := ADDR ( CACHENAME ) ;
     CACHENAME := 'CACHE2' ;
     RC := AVLCACHE ( 'CREATE' , NIL , SEQKEY , PKEY , LKEY , PDAT ,
           LDAT ) ;
     WRITELN ( 'RC          = ' , RC ) ;
     WRITELN ( 'PDAT        = ' , PDAT ) ;
     WRITELN ( 'LDAT        = ' , LDAT ) ;
     PCACHE := PDAT ;
     WRITELN ( 'CACHE.MAGIC = ' , PCACHE -> . MAGIC ) ;
     WRITELN ( 'CACHE.CNAME = ' , PCACHE -> . CNAME ) ;
     WRITELN ( 'CACHE.COUNT = ' , PCACHE -> . COUNT ) ;
     WRITELN ( 'CACHE.PTREE = ' , PCACHE -> . PTREE ) ;

     //************************************************
     // test gnext
     //************************************************

     WRITELN ;
     WRITELN ( 'Test AVLCACHE GNEXT on empty cache' ) ;
     WRITELN ( '===================================================' )
               ;
     SEQKEY := NIL ;
     while TRUE do
       begin
         PKEY := NIL ;
         LKEY := 0 ;
         PDAT := NIL ;
         LDAT := 0 ;
         RC := AVLCACHE ( 'GNEXT' , PCACHE , SEQKEY , PKEY , LKEY ,
               PDAT , LDAT ) ;
         WRITELN ( 'RC          = ' , RC ) ;
         WRITELN ( 'PKEY        = ' , PKEY ) ;
         WRITELN ( 'LKEY        = ' , LKEY ) ;
         WRITELN ( 'PDAT        = ' , PDAT ) ;
         WRITELN ( 'LDAT        = ' , LDAT ) ;
         WRITELN ( 'SEQKEY      = ' , SEQKEY ) ;
         if RC = 0 then
           begin
             PC12 := PKEY ;
             WRITELN ( 'PKEY ->     = ' , SUBSTR ( PC12 -> , 1 , LKEY )
                       ) ;
             PC12 := PDAT ;
             WRITELN ( 'PDAT ->     = ' , SUBSTR ( PC12 -> , 1 , LDAT )
                       ) ;
           end (* then *)
         else
           break
       end (* while *) ;
   end (* TEST3 *) ;



begin (* HAUPTPROGRAMM *)
  TEST1 ;
  TEST2 ;
  if FALSE then
    TEST3
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTCA2  EXT PAS HEX -
program TESTCA2 ( OUTPUT ) ;


type CHAR8 = packed array [ 1 .. 8 ] of CHAR ;


var WORT : CHAR8 ;


begin (* HAUPTPROGRAMM *)
  WORT := 'BERND' ;
  for I := 1 to 8 do
    begin
      case WORT [ I ] of
        'A' .. 'C' :
          WRITELN ( 'ABC' ) ;
        'D' .. 'F' :
          WRITELN ( 'DEF' ) ;
        'G' .. 'Z' :
          WRITELN ( 'other letter' ) ;
        ' ' : WRITELN ( 'blank' ) ;
        otherwise
          WRITELN ( 'other char' )
      end (* case *)
    end (* for *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTCA3  EXT PAS HEX -
program TESTCA2 ( OUTPUT ) ;


type CHAR8 = packed array [ 1 .. 8 ] of CHAR ;


var WORT : CHAR8 ;
    I : INTEGER ;


begin (* HAUPTPROGRAMM *)
  WORT := 'BERND' ;
  for I := 1 to 8 do
    begin
      case WORT [ I ] of
        'A' .. 'C' :
          WRITELN ( 'ABC' ) ;
        'D' .. 'F' :
          WRITELN ( 'DEF' ) ;
        'G' .. 'Z' :
          WRITELN ( 'other letter' ) ;
        ' ' : WRITELN ( 'blank' ) ;
        otherwise
          WRITELN ( 'other char' )
      end (* case *)
    end (* for *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTCASE EXT PAS HEX -
program TESTCASE ( OUTPUT ) ;


var X : INTEGER ;


begin (* HAUPTPROGRAMM *)
  for X := - 5 to 5 do
    case X of
      - 5 : WRITELN ( 'minus 5' ) ;
      - 4 : WRITELN ( 'minus 4' ) ;
      - 3 : WRITELN ( 'minus 3' ) ;
      - 2 : WRITELN ( 'minus 2' ) ;
      - 1 : WRITELN ( 'minus 1' ) ;
      0 : WRITELN ( 'null' ) ;
      1 : WRITELN ( 'plus 1' ) ;
      2 : WRITELN ( 'plus 2' ) ;
      3 : WRITELN ( 'plus 3' ) ;
      4 : WRITELN ( 'plus 4' ) ;
      5 : WRITELN ( 'plus 5' ) ;
      otherwise
        WRITELN ( '???' )
    end (* case *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTCEIN EXT PAS HEX -
program TESTCEIN ( OUTPUT ) ;


var C : CHAR ;



procedure WAIT ;

(**********************************)
(*   WARTET DARAUF, DASS EINE     *)
(*   EINGABE ERFOLGT.             *)
(**********************************)


   var I : INTEGER ;
       C : CHAR ;

   begin (* WAIT *)
     WRITELN ( 'Start Funktion Wait' ) ;
     READLN ;
     WRITELN ( 'Ende Funktion Wait' ) ;
   end (* WAIT *) ;



procedure READY ;

(************************************)
(*   READY-MELDUNG, DIE QUITTIERT   *)
(*   WERDEN MUSS.                   *)
(************************************)


   begin (* READY *)
     WRITELN ;
     WRITELN ( 'FUNKTION AUSGEFUEHRT (ENTER DRUECKEN)' ) ;
     WAIT
   end (* READY *) ;



begin (* HAUPTPROGRAMM *)
  if TRUE then
    begin
      TERMIN ( INPUT ) ;
      TERMOUT ( OUTPUT )
    end (* then *) ;
  CLRSCRN ;
  WRITELN ( 'lesen bis zum dollarzeichen ...' ) ;
  WRITELN ( 'erst mal initialisierung ...' ) ;
  WRITELN ( 'start einleseschleife ...' ) ;
  RESET ( INPUT ) ;
  repeat
    READ ( C ) ;
    WRITELN ( 'gelesen: <' , C , '> ord = ' , ORD ( C ) : 3 ) ;
    if EOLN then
      begin
        WRITELN ( '*eoln*' ) ;
        READLN ;
        WRITELN ( 'readln ausgefuehrt' ) ;
        if EOF then
          WRITELN ( '*eof*' ) ;
      end (* then *)
  until ( C = '$' ) or EOF ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTCOLL EXT PAS HEX -
program TESTCOLL ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



type POS_INT = 0 .. 30 ;


var I : POS_INT ;
    TIME : INTEGER ;


static TESTDUMP : INTEGER ;
       TESTCHAR : array [ 1 .. 10 ] of CHAR ;



function FIBONACCI ( J : POS_INT ) : INTEGER ;

(******************************)
(* to evaluate fibonacci # j, *)
(* for j >= 0                 *)
(* subject to int overflow    *)
(******************************)


   type BUFFER = array [ 1 .. 40000 ] of INTEGER ;
        PBUFFER = -> BUFFER ;

   static ANZCALL : INTEGER ;

   var CP : -> CHAR ;
       C : CHAR ;
       P : PBUFFER ;
       x1 : buffer;
       x2 : buffer;

   begin (* FIBONACCI *)
     NEW ( P ) ;
     ANZCALL := ANZCALL + 1 ;
     if J = 5 then
       begin
         CP := ADDR ( C ) ;
         CP := PTRADD ( CP , 8000000 ) ;
         CP -> := 'A' ;
       end (* then *) ;
     if J = 0 then
       FIBONACCI := 0
     else
       if J = 1 then
         FIBONACCI := 1
       else
         FIBONACCI := FIBONACCI ( J - 1 ) + FIBONACCI ( J - 3 ) ;
   end (* FIBONACCI *) ;



begin (* HAUPTPROGRAMM *)
  TESTDUMP := 42 ;
  TESTCHAR := 'Oppolzer' ;
  for I := 10 to 25 do
    begin
      TIME := CLOCK ( 0 ) ;
      WRITELN ( ' fibonacci # ' , I : 3 , ' is ' , FIBONACCI ( I ) : 8
                , ' (Comp.time = ' , CLOCK ( 0 ) - TIME : 5 ,
                ' Milli Sec.)' ) ;
    end (* for *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTCOPY EXT PAS HEX -
program TESTCOPY ( OUTPUT , INP1 , OUT1 , OUT2 ) ;

//*****
//$A+
//*****



var INP1 : TEXT ;
    OUT1 : TEXT ;
    OUT2 : TEXT ;
    CF : CHAR ( 80 ) ;
    CV : STRING ( 80 ) ;
    ZEILNR : INTEGER ;
    LAENGE : INTEGER ;
    LMAX : INTEGER ;
    COUT : STRING ( 80 ) ;


begin (* HAUPTPROGRAMM *)
  RESET ( INP1 ) ;
  REWRITE ( OUT1 ) ;
  ZEILNR := 0 ;
  while not EOF ( INP1 ) do
    begin
      READLN ( INP1 , CF ) ;
      ZEILNR := ZEILNR + 1 ;
      LMAX := MAXLENGTH ( CF ) ;
      LAENGE := LENGTH ( CF ) ;
      WRITELN ( 'Zeile ' , ZEILNR , ' MaxL ' , LMAX , ' Laenge ' ,
                LAENGE ) ;
      WRITELN ( OUT1 , CF )
    end (* while *) ;
  CLOSE ( OUT1 ) ;
  RESET ( INP1 ) ;
  REWRITE ( OUT2 ) ;
  ZEILNR := 0 ;
  while not EOF ( INP1 ) do
    begin
      READLN ( INP1 , CV ) ;
      ZEILNR := ZEILNR + 1 ;
      LMAX := MAXLENGTH ( CV ) ;
      LAENGE := LENGTH ( CV ) ;
      WRITELN ( 'Zeile ' , ZEILNR , ' MaxL ' , LMAX , ' Laenge ' ,
                LAENGE ) ;
      COUT := RTRIM ( CV ) ;
      WRITELN ( 'Laenge der Ausgabezeile = ' , LENGTH ( COUT ) ) ;
      WRITELN ( OUT2 , COUT )
    end (* while *) ;
  CLOSE ( OUT2 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTCPY2 EXT PAS HEX -
program TESTCPY2 ( OUTPUT , INP1 , OUT2 ) ;


var INP1 : TEXT ;
    OUT2 : TEXT ;
    CV : STRING ( 80 ) ;
    ZEILNR : INTEGER ;
    LAENGE : INTEGER ;
    LMAX : INTEGER ;
    COUT : STRING ( 80 ) ;


begin (* HAUPTPROGRAMM *)
  RESET ( INP1 ) ;
  REWRITE ( OUT2 ) ;
  ZEILNR := 0 ;
  while not EOF ( INP1 ) do
    begin
      READLN ( INP1 , CV ) ;
      ZEILNR := ZEILNR + 1 ;
      LMAX := MAXLENGTH ( CV ) ;
      LAENGE := LENGTH ( CV ) ;
      WRITELN ( 'Zeile ' , ZEILNR , ' MaxL ' , LMAX , ' Laenge ' ,
                LAENGE ) ;
      COUT := RTRIM ( CV ) ;
      WRITELN ( 'Laenge der Ausgabezeile = ' , LENGTH ( COUT ) ) ;
      WRITELN ( OUT2 , COUT )
    end (* while *) ;
  CLOSE ( OUT2 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTCPY3 EXT PAS HEX -
program TESTCPY3 ( OUTPUT , INP1 , OUT1 ) ;


var INP1 : TEXT ;
    OUT1 : TEXT ;
    CF : CHAR ( 80 ) ;
    ZEILNR : INTEGER ;
    LAENGE : INTEGER ;
    LMAX : INTEGER ;


begin (* HAUPTPROGRAMM *)
  RESET ( INP1 ) ;
  REWRITE ( OUT1 ) ;
  ZEILNR := 0 ;
  while not EOF ( INP1 ) do
    begin
      READLN ( INP1 , CF ) ;
      ZEILNR := ZEILNR + 1 ;
      LMAX := MAXLENGTH ( CF ) ;
      LAENGE := LENGTH ( CF ) ;
      WRITELN ( 'Zeile ' , ZEILNR , ' MaxL ' , LMAX , ' Laenge ' ,
                LAENGE ) ;
      WRITELN ( OUT1 , CF )
    end (* while *) ;
  CLOSE ( OUT1 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTDUPL EXT PAS HEX -
program TESTDUPL ( INPUT , OUTPUT ) ;
(*$A+*)

type SUBR = 0 .. 30 ;


var VARIABLE_H_LANGER_NAME : INTEGER ;
    VARIABLE_H_LANGER_ANDERER_NAME : INTEGER ;



procedure PROC_LANGER_NAME_2 ;

   var VARIABLE_2_LANGER_NAME : INTEGER ;
       VARIABLE_2_LANGER_ANDERER_NAME : INTEGER ;
       X : SUBR ;

   begin (* PROC_LANGER_NAME_2 *)
     VARIABLE_2_LANGER_NAME := 7 ;
     VARIABLE_2_LANGER_ANDERER_NAME := 23 ;
     X := 27 ;
     X := X + 5 ;
   end (* PROC_LANGER_NAME_2 *) ;



procedure PROC_LANGER_NAME_1 ;

   var VARIABLE_1_LANGER_NAME : INTEGER ;
       VARIABLE_1_LANGER_ANDERER_NAME : INTEGER ;

   begin (* PROC_LANGER_NAME_1 *)
     VARIABLE_1_LANGER_NAME := 11 ;
     VARIABLE_1_LANGER_ANDERER_NAME := 27 ;
     PROC_LANGER_NAME_2 ;
   end (* PROC_LANGER_NAME_1 *) ;



begin (* HAUPTPROGRAMM *)
  VARIABLE_H_LANGER_NAME := 5 ;
  VARIABLE_H_LANGER_ANDERER_NAME := 12 ;
  WRITELN ( VARIABLE_H_LANGER_NAME ) ;
  WRITELN ( VARIABLE_H_LANGER_ANDERER_NAME ) ;
  PROC_LANGER_NAME_1 ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTERR  EXT PAS HEX -
program TESTERR ( OUTPUT ) ;

//*****
//$A+
//*****



var IFILE : TEXT ;
    I : INTEGER ;
    R : REAL ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( 'testen real einlesen' ) ;
  READLN ( R ) ;
  WRITELN ( 'gelesen: ' , R : 1 : 9 ) ;
  I := 12340 ;
  WRITELN ( I * 0.001 : 7 : 2 ) ;
  if FALSE then
    begin
      REWRITE ( IFILE ) ;
      WRITELN ( IFILE , 'A' ) ;
      RESET ( IFILE ) ;
      READ ( IFILE , I ) ;
      $ERROR ( 999 ) ;
    end (* then *) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTERR1 EXT PAS HEX -
program TESTERR1 ( OUTPUT ) ;

//**********************************************************************
//$A+
//**********************************************************************



var FTEXT : array [ 1 .. 120 ] of CHAR ;
    CP1 , CP2 , CP3 : -> CHAR ;
    INFOPOS , L : INTEGER ;


begin (* HAUPTPROGRAMM *)
  INFOPOS := 25 ;
  L := 28 ;
  CP1 := ADDR ( FTEXT ) ;
  CP2 := PTRADD ( ADDR ( FTEXT ) , 32 ) ;

  //******************************************************************
  // das folgende Statement erzeugt P-CODE ADA,
  // dieser wird durch Pascal2 falsch bersetzt (AH ...)
  //******************************************************************

  CP3 := PTRADD ( ADDR ( FTEXT ) , L - INFOPOS ) ;
  WRITELN ( 'cp1, cp2, cp3 = ' , CP1 : 10 , CP2 : 10 , CP3 : 10 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTERR2 EXT PAS HEX -
program TESTERR2 ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



var I : INTEGER ;
    CH : CHAR ;


type ALFA = array [ 1 .. 40 ] of CHAR ;


static ABC : ALFA ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( 'abc = ' , ABC ) ;
  I := 40 ;
  CH := '/' ;
  MEMSET ( ADDR ( ABC ) , CH , I ) ;
  WRITELN ( 'abc = ' , ABC ) ;
  MEMSET ( ADDR ( ABC ) , '*' , I ) ;
  WRITELN ( 'abc = ' , ABC ) ;
  MEMSET ( ADDR ( ABC ) , '*' , 40 ) ;
  WRITELN ( 'abc = ' , ABC ) ;
  MEMSET ( ADDR ( ABC ) , '*' , SIZEOF ( ABC ) ) ;
  WRITELN ( 'abc = ' , ABC ) ;
  MEMSET ( ADDR ( ABC ) , '*' , SIZEOF ( ALFA ) ) ;
  WRITELN ( 'abc = ' , ABC ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTERR3 EXT PAS HEX -
program TESTERR3 ( OUTPUT ) ;


var S : CHAR ( 80 ) ;
    S2 : CHAR ( 10 ) ;



procedure WRITE_VORSCHRIFT ( var F : TEXT ; VORSCHRIFT : CHAR ( 10 ) )
                           ;

   begin (* WRITE_VORSCHRIFT *)
     WRITELN ( F , VORSCHRIFT ) ;
   end (* WRITE_VORSCHRIFT *) ;



function CHARFUNC : STRING ;

   begin (* CHARFUNC *)
     CHARFUNC := 'constant' ;
   end (* CHARFUNC *) ;



procedure FEHLER_ZUWEISUNG ;

   begin (* FEHLER_ZUWEISUNG *)
     S := 'langer string mit vielen zeichen' ;
     S2 := SUBSTR ( S , 8 , 8 ) ;

     //****************************************
     // runtime error stringsize is diagnosed
     // which is correct
     // but wrong error line
     // error line refers to line in $PASSTR1
     // should refer to loc here !
     //****************************************

     if FALSE then
       S2 := 'zu langer ' || 'String' ;
     if FALSE then
       S2 := SUBSTR ( S , 8 , 20 ) ;
   end (* FEHLER_ZUWEISUNG *) ;



begin (* HAUPTPROGRAMM *)
  FEHLER_ZUWEISUNG ;

  //*********************************************
  // compiler refuses to compile procedure call
  // where function result of string type
  // is passed by value to fixed char argument
  // but should work
  //*********************************************

  if TRUE then
    begin
      WRITE_VORSCHRIFT ( OUTPUT , S2 ) ;
      WRITE_VORSCHRIFT ( OUTPUT , CHARFUNC ) ;
      WRITE_VORSCHRIFT ( OUTPUT , SUBSTR ( S , 8 , 7 ) ) ;
    end (* then *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTERR4 EXT PAS HEX -
program TESTERR4 ( OUTPUT ) ;



function F1 : INTEGER ;

   begin (* F1 *)
     F1 := 5 ;
   end (* F1 *) ;



function F2 : INTEGER ;

   begin (* F2 *)
     F1 := 12 ;
   end (* F2 *) ;



begin (* HAUPTPROGRAMM *)
  WRITELN ( F1 ) ;
  WRITELN ( F2 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTFIL1 EXT PAS HEX -
program TESTFIL1 ( INPUT , OUTPUT ) ;


var CH : CHAR ;


begin (* HAUPTPROGRAMM *)
  RESET ( INPUT ) ;
  while not EOF do
    begin
      CH := INPUT -> ;
      WRITE ( OUTPUT , CH ) ;
      if not EOLN then
        begin
          GET ( INPUT ) ;
          continue ;
        end (* then *) ;
      repeat
        WRITELN ;
        GET ( INPUT ) ;
      until EOF or not EOLN ;
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTFILE EXT PAS HEX -
program TESTFILE ( INPUT ) ;

(********)
(*$A+   *)
(********)



const UMGEBUNG = 'WIN' ;


type VEKTOR = array [ 1 .. 10 ] of INTEGER ;
     TREC = record
              KEY : INTEGER ;
              FELD : VEKTOR ;
            end ;


var I : INTEGER ;
    ANZ : INTEGER ;
    F : VEKTOR ;
    FANZ : INTEGER ;
    OUTFILE_INTERN : FILE of TREC ;
    TXTFILE_INTERN : TEXT ;
    X : VOIDPTR ;
    RBUF : TREC ;
    P : VOIDPTR ;
    PP : -> VOIDPTR ;
    AP : ANYPTR ;
    IP : -> INTEGER ;
    AF : ANYFILE ;
    R : REAL ;
    C : array [ 1 .. 4 ] of CHAR ;



procedure DUMP ( PVON : VOIDPTR ; PBIS : VOIDPTR ) ;

(*********************************************************)
(*  Speicherbereich von PVON bis PBIS hexadezimal        *)
(*  ausgeben                                             *)
(*********************************************************)


   var P1 : VOIDPTR ;
       P2 : VOIDPTR ;
       MOD1 : INTEGER ;
       MOD2 : INTEGER ;


   procedure DUMPCHAR ( CH : CHAR ) ;

      begin (* DUMPCHAR *)
        if CH in [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' , 'A' .. 'I' ,
        'J' .. 'R' , 'S' .. 'Z' , '0' .. '9' , ' ' , ',' , '.' , '-' ,
        ';' , ':' , '_' , '!' , '"' , '' , '$' , '%' , '&' , '/' , '('
        , ')' , '=' , '?' , '+' , '*' , '#' , '*' ] then
          WRITE ( CH )
        else
          WRITE ( '.' )
      end (* DUMPCHAR *) ;


   procedure DUMPZEILE ( ADR : VOIDPTR ; P1 : VOIDPTR ; P2 : VOIDPTR )
                       ;

      var CH : -> CHAR ;
          I : INTEGER ;

      const HEXTAB : array [ 0 .. 15 ] of CHAR = '0123456789abcdef' ;

      begin (* DUMPZEILE *)
        WRITE ( ADR , ': ' ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , 4 ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , 4 ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , 4 ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , - 12 ) ;
        CH := ADR ;
        WRITE ( ' *' ) ;
        for I := 1 to 16 do
          begin
            DUMPCHAR ( CH -> ) ;
            CH := PTRADD ( CH , 1 )
          end (* for *) ;
        WRITELN ( '*' ) ;
      end (* DUMPZEILE *) ;


   begin (* DUMP *)
     WRITELN ( 'Dump Speicherbereich von ' , PVON , ' bis ' , PBIS ) ;
     P1 := PTRADD ( PVON , - 16 ) ;
     MOD1 := PTR2INT ( P1 ) MOD 16 ;
     P1 := PTRADD ( P1 , 16 - MOD1 ) ;
     P2 := PTRADD ( PBIS , 15 ) ;
     MOD2 := PTR2INT ( P2 ) MOD 16 ;
     P2 := PTRADD ( P2 , - MOD2 ) ;
     while PTRDIFF ( P1 , P2 ) < 0 do
       begin
         DUMPZEILE ( P1 , PVON , PBIS ) ;
         P1 := PTRADD ( P1 , 16 ) ;
       end (* while *) ;
   end (* DUMP *) ;



procedure COMPUTE ( X : INTEGER ) ;

   begin (* COMPUTE *)
     if X = 1 then
       F [ 1 ] := 1
     else
       if X = 2 then
         F [ 2 ] := 1
       else
         F [ X ] := F [ X - 1 ] + F [ X - 2 ]
   end (* COMPUTE *) ;



procedure SHIFT ;

   var I : INTEGER ;

   begin (* SHIFT *)
     for I := 1 to 9 do
       F [ I ] := F [ I + 1 ] ;
   end (* SHIFT *) ;



procedure WRITE_VEKTOR ;

   var X : TREC ;
       I : INTEGER ;

   begin (* WRITE_VEKTOR *)
     ANZ := ANZ + 1 ;
     X . KEY := ANZ ;
     X . FELD := F ;
     WRITE ( OUTFILE_INTERN , X ) ;
     WRITELN ( OUTPUT , 'Testausgabe WRITE_VEKTOR, Key = ' , ANZ ) ;
     for I := 1 to 5 do
       WRITE ( OUTPUT , F [ I ] ) ;
     WRITELN ;
     for I := 6 to 10 do
       WRITE ( OUTPUT , F [ I ] ) ;
     WRITELN ;
     WRITELN ( '----------------------------------' ,
               '----------------------------------' ) ;
   end (* WRITE_VEKTOR *) ;



procedure TESTCLOSE ( var I : INTEGER ; var X : ANYFILE ) ;

   begin (* TESTCLOSE *)

     /******************************************************/
     /*   if FALSE then                                    */
     /*     WRITELN ( 'file component: ' , X -> ) ;        */
     /******************************************************/

     CLOSE ( X ) ;
   end (* TESTCLOSE *) ;



begin (* HAUPTPROGRAMM *)
  REWRITE ( TXTFILE_INTERN ) ;
  WRITELN ( TXTFILE_INTERN , 'TEST TEST ' ) ;
  X := ADDR ( TXTFILE_INTERN ) ;
  WRITELN ( 'pasfcb txtfile = ' , X ) ;
  DUMP ( PTRCAST ( X ) , PTRADD ( X , 12 ) ) ;
  WRITELN ( 'dump pasfcb fertig' ) ;
  if UMGEBUNG = 'WIN' then
    begin
      PP := PTRCAST ( X ) ;
      P := PP -> ;
      DUMP ( P , PTRADD ( P , 300 ) ) ;
    end (* then *)
  else
    begin
      X := FILEFCB ( TXTFILE_INTERN ) ;
      WRITELN ( 'filefcb txtfile = ' , X ) ;
      DUMP ( PTRCAST ( X ) , PTRADD ( X , 120 ) ) ;
      WRITELN ( 'dump filefcb fertig' ) ;
    end (* else *) ;
  REWRITE ( OUTFILE_INTERN ) ;
  X := ADDR ( OUTFILE_INTERN ) ;
  WRITELN ( 'pasfcb outfile = ' , X ) ;
  DUMP ( PTRCAST ( X ) , PTRADD ( X , 54 ) ) ;
  WRITELN ( 'dump pasfcb fertig' ) ;
  if UMGEBUNG = 'WIN' then
    begin
      PP := PTRCAST ( X ) ;
      P := PP -> ;
      DUMP ( P , PTRADD ( P , 300 ) ) ;
    end (* then *)
  else
    begin
      X := FILEFCB ( OUTFILE_INTERN ) ;
      WRITELN ( 'filefcb outfile = ' , X ) ;
      DUMP ( PTRCAST ( X ) , PTRADD ( X , 120 ) ) ;
      WRITELN ( 'dump filefcb fertig' ) ;
    end (* else *) ;
  for I := 1 to 10 do
    F [ I ] := 0 ;
  ANZ := 0 ;
  FANZ := 0 ;
  while ANZ < 100 do
    begin
      if FANZ < 10 then
        begin
          FANZ := FANZ + 1 ;
          COMPUTE ( FANZ ) ;
          WRITE_VEKTOR ;
        end (* then *)
      else
        begin
          SHIFT ;
          COMPUTE ( FANZ ) ;
          WRITE_VEKTOR ;
        end (* else *)
    end (* while *) ;
  RESET ( OUTFILE_INTERN ) ;
  X := ADDR ( OUTFILE_INTERN ) ;
  WRITELN ( 'pasfcb outfile = ' , X ) ;
  DUMP ( PTRCAST ( X ) , PTRADD ( X , 54 ) ) ;
  WRITELN ( 'dump pasfcb fertig' ) ;
  if UMGEBUNG = 'WIN' then
    begin
      PP := PTRCAST ( X ) ;
      P := PP -> ;
      DUMP ( P , PTRADD ( P , 300 ) ) ;
    end (* then *)
  else
    begin
      X := FILEFCB ( OUTFILE_INTERN ) ;
      WRITELN ( 'filefcb outfile = ' , X ) ;
      DUMP ( PTRCAST ( X ) , PTRADD ( X , 120 ) ) ;
      WRITELN ( 'dump filefcb fertig' ) ;
    end (* else *) ;
  while not EOF ( OUTFILE_INTERN ) do
    begin
      WRITELN ( 'key = ' , OUTFILE_INTERN -> . KEY ) ;
      for I := 1 to 5 do
        WRITE ( OUTPUT , OUTFILE_INTERN -> . FELD [ I ] ) ;
      WRITELN ;
      for I := 6 to 10 do
        WRITE ( OUTPUT , OUTFILE_INTERN -> . FELD [ I ] ) ;
      WRITELN ;
      WRITELN ( '----------------------------------' ,
                '----------------------------------' ) ;
      GET ( OUTFILE_INTERN ) ;
    end (* while *) ;
  WRITELN ( 'neue Tests Anyptr usw.' ) ;
  WRITELN ( '----------------------' ) ;
  P := ADDR ( ANZ ) ;
  WRITELN ( 'p  = ' , P ) ;
  AP := P ;
  IP := P ;
  WRITELN ( 'ap = ' , AP ) ;
  WRITELN ( 'ip = ' , IP ) ;
  WRITELN ( 'ip -> = ' , IP -> ) ;

  /************************************/
  /* WRITELN ( 'ap -> = ' , AP -> ) ; */
  /************************************/

  TESTCLOSE ( I , TXTFILE_INTERN ) ;
  TESTCLOSE ( I , OUTFILE_INTERN ) ;
  TESTCLOSE ( I , OUTFILE_INTERN ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTFILP EXT PAS HEX -
program TESTFILP ( OUTPUT ) ;


var FILEP : -> TEXT ;



procedure OUTTEST ( var FP : TEXT ) ;

   begin (* OUTTEST *)
     WRITELN ( FP , 'outtest: works' ) ;
   end (* OUTTEST *) ;



begin (* HAUPTPROGRAMM *)
  FILEP := ADDR ( OUTPUT ) ;
  OUTTEST ( FILEP -> ) ;
  WRITELN ( 'eof = ' , EOF ( OUTPUT ) ) ;
  WRITELN ( 'eof = ' , EOF ( FILEP -> ) ) ;
  WRITELN ( OUTPUT , 'writeln: works' ) ;
  WRITELN ( FILEP -> , 'writeln: works' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTFP2  EXT PAS HEX -
program TESTFP2 ( OUTPUT ) ;

(**********************************************************************)
(*                                                                    *)
(*   Testprogram fuer die Uebergabe von Funktionsparametern           *)
(*                                                                    *)
(*   Opp - 2018.02                                                    *)
(*                                                                    *)
(**********************************************************************)
(* Assembler-Output:                                                  *)
(*$A+                                                                 *)
(**********************************************************************)




function F1 ( X : REAL ) : REAL ;

   begin (* F1 *)
     F1 := X * X
   end (* F1 *) ;



function F2 ( X : REAL ) : REAL ;

   begin (* F2 *)
     F2 := SIN ( X )
   end (* F2 *) ;



procedure F3 ( X1 : REAL ; X2 : REAL ; function F ( X : REAL ) : REAL )
             ;

   var X : REAL ;

   begin (* F3 *)
     X := X1 ;
     while X <= X2 do
       begin
         WRITELN ( 'funktion f: ' , X : 10 : 2 , F ( X ) : 15 : 7 ) ;
         X := ROUNDX ( X + 0.1 , - 1 ) ;
       end (* while *)
   end (* F3 *) ;



begin (* HAUPTPROGRAMM *)
  WRITELN ( 'calling F3 with F1 = square x' ) ;
  F3 ( 1.0 , 3.0 , F1 ) ;
  WRITELN ( 'calling F3 with F2 = sin x' ) ;
  F3 ( 1.0 , 3.0 , F2 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTFPAR EXT PAS HEX -
program TESTFPAR ( OUTPUT ) ;

(**********************************************************************)
(*                                                                    *)
(*   Testprogram fuer die Uebergabe von Funktionsparametern           *)
(*                                                                    *)
(*   Opp - 2018.02                                                    *)
(*                                                                    *)
(**********************************************************************)
(* Assembler-Output:                                                  *)
(*$A+                                                                 *)
(**********************************************************************)




function F1 ( X : REAL ) : REAL ;

   begin (* F1 *)
     F1 := X * X
   end (* F1 *) ;



function F2 ( X : REAL ) : REAL ;

   begin (* F2 *)
     F2 := SIN ( X )
   end (* F2 *) ;



function F2FALSCH ( X : REAL ) : INTEGER ;

(*************************************************)
(* kann nicht uebergeben werden                  *)
(* da falscher ergebnis-typ                      *)
(* wurde vom compiler anfangs noch toleriert     *)
(*************************************************)


   begin (* F2FALSCH *)
     F2FALSCH := 0 ;
   end (* F2FALSCH *) ;



procedure F3 ( X1 : REAL ; X2 : REAL ; function F ( X : REAL ) : REAL )
             ;

   var X : REAL ;

   begin (* F3 *)
     X := X1 ;
     while X <= X2 do
       begin
         WRITELN ( 'funktion f: ' , X : 10 : 2 , F ( X ) : 15 : 7 ) ;
         X := ROUNDX ( X + 0.1 , - 1 ) ;
       end (* while *)
   end (* F3 *) ;



begin (* HAUPTPROGRAMM *)
  WRITELN ( 'calling F3 with F1 = square x' ) ;
  F3 ( 1.0 , 3.0 , F1 ) ;
  WRITELN ( 'calling F3 with F2 = sin x' ) ;
  F3 ( 1.0 , 3.0 , F2 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTFUNC EXT PAS HEX -
program TESTFUNC ( OUTPUT ) ;


var X : INTEGER ;


begin (* HAUPTPROGRAMM *)
  X := RANDOM ( 25 ) ;
  X := RANDOM ( X ) ;
  X := RANDOM ( X + 5 ) ;
  WRITELN ( X ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTGET  EXT PAS HEX -
program TESTGET ( INPUT , OUTPUT ) ;


var CH : CHAR ;



procedure TERMIN ( var X : TEXT ) ;

   EXTERNAL ;



procedure TERMOUT ( var X : TEXT ) ;

   EXTERNAL ;



begin (* HAUPTPROGRAMM *)
  TERMIN ( INPUT ) ;

  //****************************************************************
  // termin does not do an implicit reset, only sets terminal flag
  // input -> stays undefined (x'81') before the first get call
  //****************************************************************
  // after that, get should return first char entered
  //****************************************************************
  // the first get, in other words, does the same as
  // an implicit reset (not really advancing to the second byte
  // of the file)
  //****************************************************************

  GET ;
  while not EOF ( INPUT ) do
    begin
      CH := INPUT -> ;
      WRITELN ( 'x. zeichen = <' , CH , '>' , ORD ( CH ) ) ;
      GET ;
    end (* while *) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTHEL  EXT PAS HEX -
program TESTHEL ( OUTPUT ) ;


var X : INTEGER ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( 'hello from Pascal/S' ) ;
  WRITELN ( 'input integer' ) ;
  READLN ( X ) ;
  WRITELN ( 'integer' , X , ' has been read' ) ;
  WRITELN ( 'x + 1 = ' , X + 1 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTIEIN EXT PAS HEX -
program TESTIEIN ( OUTPUT ) ;


var X : INTEGER ;



procedure WAIT ;

(**********************************)
(*   WARTET DARAUF, DASS EINE     *)
(*   EINGABE ERFOLGT.             *)
(**********************************)


   var I : INTEGER ;
       C : CHAR ;

   begin (* WAIT *)
     WRITELN ( 'Start Funktion Wait' ) ;
     READLN ;
     WRITELN ( 'Ende Funktion Wait' ) ;
   end (* WAIT *) ;



procedure READY ;

(************************************)
(*   READY-MELDUNG, DIE QUITTIERT   *)
(*   WERDEN MUSS.                   *)
(************************************)


   begin (* READY *)
     WRITELN ;
     WRITELN ( 'FUNKTION AUSGEFUEHRT (ENTER DRUECKEN)' ) ;
     WAIT
   end (* READY *) ;



procedure IEIN ( var X : INTEGER ) ;

(***************************************)
(*   NICHTNEGATIVEN INTEGER EINLESEN   *)
(***************************************)


   var COUNT , CV : INTEGER ;
       C : CHAR ;

   begin (* IEIN *)
     WRITELN ( 'Start Funktion IEIN' ) ;
     COUNT := 0 ;
     X := 0 ;
     repeat
       READ ( C ) ;
       if FALSE then
         WRITELN ( 'gelesen: ' , ORD ( C ) , ' eoln = ' , EOLN ) ;
     until ( C <> ' ' ) or EOLN ;
     while ( C in [ '0' .. '9' ] ) do
       begin
         case C of
           '0' : CV := 0 ;
           '1' : CV := 1 ;
           '2' : CV := 2 ;
           '3' : CV := 3 ;
           '4' : CV := 4 ;
           '5' : CV := 5 ;
           '6' : CV := 6 ;
           '7' : CV := 7 ;
           '8' : CV := 8 ;
           '9' : CV := 9
         end (* case *) ;
         X := ( X * 10 ) + CV ;
         COUNT := COUNT + 1 ;
         if not EOLN then
           READ ( C )
         else
           C := ' ' ;
         if FALSE then
           WRITELN ( 'gelesen: ' , ORD ( C ) , ' eoln = ' , EOLN ) ;
       end (* while *) ;
     READLN ;
     WRITELN ( 'Ende Funktion IEIN' ) ;
   end (* IEIN *) ;



begin (* HAUPTPROGRAMM *)
  TERMIN ( INPUT ) ;
  TERMOUT ( OUTPUT ) ;
  WRITELN ( 'erst mal initialisierung' ) ;
  READY ;
  CLRSCRN ;
  repeat
    WRITELN ( 'eingabe von ints, bis eingabe = 33 ' ) ;
    IEIN ( X ) ;
    WRITELN ( 'gelesen: ' , X ) ;
    READY ;
    CLRSCRN ;
  until X = 33 ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTINN  EXT PAS HEX -
program TESTINN ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



var CH : CHAR ;
    X : INTEGER ;
    W : INTEGER ;
    C : array [ 10 .. 20 ] of INTEGER ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( 'index?' ) ;
  READ ( X ) ;
  WRITELN ( 'wert?' ) ;
  READ ( W ) ;
  C [ X ] := W ;
  repeat
    READ ( CH ) ;
    if CH in [ '*' , 'C' , 'D' , 'F' , 'H' , 'K' , 'M' , 'P' , 'S' ]
    then
      WRITELN ( CH , ': char ok' )
    else
      WRITELN ( CH , ': char nok' )
  until CH = ' ' ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTINP  EXT PAS HEX -
program TESTINP ( INPUT , OUTPUT , EINGABE ) ;

(********)
(*$K-,A+*)
(********)



var ZAHL1 : INTEGER ;
    ZAHL2 : INTEGER ;
    ZAHL3 : INTEGER ;
    CH : CHAR ;
    EINGABE : TEXT ;
    I : INTEGER ;


begin (* HAUPTPROGRAMM *)
  // TERMIN ( INPUT ) ;
  // TERMOUT ( OUTPUT ) ;
  WRITELN ( 'eof/input = ' , EOF ( INPUT ) ) ;
  WRITELN ( 'eof/output = ' , EOF ( OUTPUT ) ) ;
  CH := INPUT -> ;
  WRITELN ( 'ORD (INPUT ->) = ' , ORD ( CH ) ) ;
  CH := EINGABE -> ;
  WRITELN ( 'ORD (EINGABE ->) = ' , ORD ( CH ) ) ;
  WRITELN ( 'bitte zahl1 eingeben' ) ;
  READ ( ZAHL1 ) ;
  WRITELN ( 'bitte zahl2 eingeben' ) ;
  READ ( ZAHL2 ) ;
  WRITELN ( 'bitte zahl3 eingeben' ) ;
  READ ( ZAHL3 ) ;
  WRITELN ( 'zahl1 = ' , ZAHL1 ) ;
  WRITELN ( 'zahl2 = ' , ZAHL2 ) ;
  WRITELN ( 'zahl3 = ' , ZAHL3 ) ;
  READ ( EINGABE , ZAHL1 ) ;
  WRITELN ( 'EINGABE:ZAHL1 = ' , ZAHL1 ) ;
  WRITE ( 'PROGRAMMENDE (OHNE WRITELN)' ) ;
  WRITELN ;
  WRITELN ( 'UND NOCH NE ZEILE MIT WRITELN DAHINTER' ) ;
  if FALSE then
    begin
      for I := 1 to 20 do
        WRITELN ( 'es klappt, i = ' , I : 4 ) ;
      for CH := 'A' to 'Z' do
        WRITELN ( 'ch = ' , CH , ' ord = ' , ORD ( CH ) ) ;
    end (* then *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTINTS EXT PAS HEX -
program TESTINTS ( OUTPUT ) ;


var X : CHAR ( 8 ) ;
    I : INTEGER ;



procedure INTTOSTR ( CP : VOIDPTR ; LEN : INTEGER ; VAL : INTEGER ;
                   ZEROES : BOOLEAN ) ;

   var BUFFER : array [ 1 .. 20 ] of CHAR ;
       MINUS : BOOLEAN ;
       LETZT : INTEGER ;
       I : INTEGER ;
       LIMIT : INTEGER ;
       LENX : INTEGER ;
       POSX : INTEGER ;

   begin (* INTTOSTR *)
     if VAL < 0 then
       begin
         VAL := - VAL ;
         MINUS := TRUE
       end (* then *)
     else
       MINUS := FALSE ;
     I := 20 ;
     BUFFER := ' ' ;
     while VAL > 0 do
       begin
         LETZT := VAL MOD 10 ;
         BUFFER [ I ] := CHR ( ORD ( '0' ) + LETZT ) ;
         I := I - 1 ;
         VAL := VAL DIV 10 ;
       end (* while *) ;
     LIMIT := 20 - LEN ;
     if ZEROES then
       while I > LIMIT do
         begin
           BUFFER [ I ] := '0' ;
           I := I - 1 ;
         end (* while *) ;
     if MINUS then
       begin
         if ZEROES then
           I := I + 1 ;
         BUFFER [ I ] := '-' ;
         I := I - 1 ;
       end (* then *) ;
     LENX := 20 - I ;
     POSX := LEN - LENX ;
     MEMSET ( CP , ' ' , LEN ) ;
     MEMCPY ( PTRADD ( CP , POSX ) , ADDR ( BUFFER [ I + 1 ] ) , LENX )
              ;
   end (* INTTOSTR *) ;



begin (* HAUPTPROGRAMM *)
  I := 25 ;
  INTTOSTR ( ADDR ( X ) , 8 , I , TRUE ) ;
  WRITELN ( 'result inttostr = ' , X , ' expected: 00000025' ) ;
  I := - 25 ;
  INTTOSTR ( ADDR ( X ) , 8 , I , TRUE ) ;
  WRITELN ( 'result inttostr = ' , X , ' expected: -0000025' ) ;
  I := 25 ;
  INTTOSTR ( ADDR ( X ) , 8 , I , FALSE ) ;
  WRITELN ( 'result inttostr = ' , X , ' expected:       25' ) ;
  I := - 25 ;
  INTTOSTR ( ADDR ( X ) , 8 , I , FALSE ) ;
  WRITELN ( 'result inttostr = ' , X , ' expected:      -25' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTLAB  EXT PAS HEX -
program TESTINP ( INPUT , OUTPUT , EINGABE ) ;

(********)
(*$K-,A+*)
(********)



label 10 , 20 ;


type PTRX = -> X ;
     PTRF = -> FELD ;


var ZAHL1 : INTEGER ;
    ZAHL2 : INTEGER ;
    ZAHL3 : INTEGER ;
    CH : CHAR ;
    Cp2 : -> unknown ;
    EINGABE : TEXT ;
    I : INTEGER ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( 'eof/input = ' , EOF ( INPUT ) ) ;
  WRITELN ( 'eof/output = ' , EOF ( OUTPUT ) ) ;
  CH := INPUT -> ;
  WRITELN ( 'ORD (INPUT ->) = ' , ORD ( CH ) ) ;
  CH := EINGABE -> ;
  WRITELN ( 'ORD (EINGABE ->) = ' , ORD ( CH ) ) ;
  WRITELN ( 'bitte zahl1 eingeben' ) ;
  READ ( ZAHL1 ) ;
  WRITELN ( 'bitte zahl2 eingeben' ) ;
  READ ( ZAHL2 ) ;
  WRITELN ( 'bitte zahl3 eingeben' ) ;
  READ ( ZAHL3 ) ;
  WRITELN ( 'zahl1 = ' , ZAHL1 ) ;
  WRITELN ( 'zahl2 = ' , ZAHL2 ) ;
  WRITELN ( 'zahl3 = ' , ZAHL3 ) ;
  READ ( EINGABE , ZAHL1 ) ;
  WRITELN ( 'EINGABE:ZAHL1 = ' , ZAHL1 ) ;
  WRITE ( 'PROGRAMMENDE (OHNE WRITELN)' ) ;
  WRITELN ;
  WRITELN ( 'UND NOCH NE ZEILE MIT WRITELN DAHINTER' ) ;
  if FALSE then
    begin
      for I := 1 to 20 do
        WRITELN ( 'es klappt, i = ' , I : 4 ) ;
      for CH := 'A' to 'Z' do
        WRITELN ( 'ch = ' , CH , ' ord = ' , ORD ( CH ) ) ;
    end (* then *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTLAB2 EXT PAS HEX -
program TESTLAB2 ( INPUT , OUTPUT , EINGABE ) ;

(********)
(*$K-,A+*)
(********)



label 10 , 20 ;


var ZAHL1 : INTEGER ;
    ZAHL2 : INTEGER ;
    ZAHL3 : INTEGER ;
    CH : CHAR ;
    EINGABE : TEXT ;
    I : INTEGER ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( 'eof/input = ' , EOF ( INPUT ) ) ;
  WRITELN ( 'eof/output = ' , EOF ( OUTPUT ) ) ;
  CH := INPUT -> ;
  WRITELN ( 'ORD (INPUT ->) = ' , ORD ( CH ) ) ;
  CH := EINGABE -> ;
  WRITELN ( 'ORD (EINGABE ->) = ' , ORD ( CH ) ) ;
  WRITELN ( 'bitte zahl1 eingeben' ) ;
  READ ( ZAHL1 ) ;
  WRITELN ( 'bitte zahl2 eingeben' ) ;
  READ ( ZAHL2 ) ;
  WRITELN ( 'bitte zahl3 eingeben' ) ;
  READ ( ZAHL3 ) ;
  WRITELN ( 'zahl1 = ' , ZAHL1 ) ;
  WRITELN ( 'zahl2 = ' , ZAHL2 ) ;
  WRITELN ( 'zahl3 = ' , ZAHL3 ) ;
  READ ( EINGABE , ZAHL1 ) ;
  WRITELN ( 'EINGABE:ZAHL1 = ' , ZAHL1 ) ;
  20 :
  WRITE ( 'PROGRAMMENDE (OHNE WRITELN)' ) ;
  WRITELN ;
  WRITELN ( 'UND NOCH NE ZEILE MIT WRITELN DAHINTER' ) ;
  if FALSE then
    begin
      for I := 1 to 20 do
        WRITELN ( 'es klappt, i = ' , I : 4 ) ;
      for CH := 'A' to 'Z' do
        WRITELN ( 'ch = ' , CH , ' ord = ' , ORD ( CH ) ) ;
    end (* then *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTLSTR EXT PAS HEX -
program TESTLSTR ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



var ZEILE : array [ 1 .. 200 ] of CHAR ;
    I : INTEGER ;


begin (* HAUPTPROGRAMM *)
  ZEILE := 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'
           'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb'
           'cccccccccccccccccccccccccccccccccccc'
           'dddddddddddddddddddddddddddddddddddd'
           'eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee' ;
  WRITELN ( ZEILE ) ;
  MEMSET ( ADDR ( ZEILE ) , 'b' , 200 ) ;
  WRITELN ( ZEILE ) ;
  for I := 1 to 200 do
    ZEILE [ I ] := '=' ;
  WRITELN ( ZEILE ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTM1   EXT PAS HEX -
module TESTM1 ;



procedure PROC1 ;

   var A1 : INTEGER ;


   procedure PROC3 ;

      FORWARD ;


   procedure PROC2 ;

      var A2 : INTEGER ;

      begin (* PROC2 *)
        PROC3 ;
      end (* PROC2 *) ;


   procedure PROC3 ;

      var A3 : INTEGER ;

      begin (* PROC3 *)
        PROC2 ;
      end (* PROC3 *) ;


   begin (* PROC1 *)
     PROC2 ;
     PROC3 ;
   end (* PROC1 *) ;



begin (* HAUPTPROGRAMM *)

end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTMAJ  EXT PAS HEX -
program TESTMAJ ( OUTPUT ) ;


var KLEINBUCHST : set of CHAR ;
    WORT : array [ 1 .. 10 ] of CHAR ;
    I : INTEGER ;



function MAJOR ( CH : CHAR ) : CHAR ;

(******************************************)
(*   SETZT KLEINBUCHSTABEN IN GROSSE UM   *)
(******************************************)


   begin (* MAJOR *)
     if CH in KLEINBUCHST then
       MAJOR := CHR ( ORD ( CH ) - ORD ( 'a' ) + ORD ( 'A' ) )
     else
       MAJOR := CH
   end (* MAJOR *) ;



begin (* HAUPTPROGRAMM *)
  KLEINBUCHST := [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' ] ;
  repeat
    WRITELN ( 'bitte wort eingeben:' ) ;
    READLN ( WORT ) ;
    for I := 1 to 10 do
      WORT [ I ] := MAJOR ( WORT [ I ] ) ;
    WRITELN ( 'wort neu = ' , WORT ) ;
  until WORT = 'ENDE' ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTMOD  EXT PAS HEX -
module TESTMOD ( QRD , OUTPUT ) ;

(********************************************************************)
(*$D-                                                               *)
(********************************************************************)
(*                                                                  *)
(*             SNAPSHOT AND POST MORTEM DUMP UTILITY                *)
(*                                                                  *)
(*  THIS PROGRAM PRINTS OUT THE CURRENT STACK ENVIRONMENT FOR A     *)
(*  PASCAL PROGRAM RUNNING ON THE S.L.A.C. TRIPLEX SYSTEM (IBM 370) *)
(*  SNAPSHOT TRACES BACK THROUGH THE STACK FRAMES OF THE PROGRAM    *)
(*  AND FOR EACH STACK FRAME PRINTS 1) THE NAME OF THE PROCEDURE    *)
(*  WHICH 'OWNS' THAT FRAME, 2) THE NAME OF THE PROCEDURE WHICH     *)
(*  CALLED THE OWNING PROCEDURE AND THE SOURCE LINE NUMBER FROM     *)
(*  WHICH THE CALL WAS MADE, 3) THE VALUES OF THE PROCEDURE'S       *)
(*  PARAMETERS AND LOCAL VARIABLES.                                 *)
(*                                                                  *)
(*  THIS PROGRAM IS CLOSELY AWARE OF THE RUN-TIME ENVIRONMENT OF    *)
(*  'PASCAL' PROGRAMS AND USES 'CASE VARIANT' RECORDS TO INTERPRET  *)
(*  THE CONTENTS OF MEMORY LOCATIONS DIFFERENTLY AS NEEDED. FOR     *)
(*  THIS REASON, IT SHOULD NOT BE COMPILED WITH THE 'D+' OPTION.    *)
(*                                                                  *)
(*  AUTHOR:  EARL WALDIN                                            *)
(*                                                                  *)
(*           COMPUTATION RESEARCH GROUP                             *)
(*           STANFORD LINEAR ACCELERATOR CENTER                     *)
(*           STANFORD, CA. 94305                                    *)
(*                                                                  *)
(*                                                                  *)
(*                                         UPDATED: 12-05-78  (SZH) *)
(*                                         UPDATED: 08-09-79  (SZH) *)
(*                                         UPDATED: 07-26-80  (RNH) *)
(*                                         UPDATED: 04-11-82  (RNH) *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  09.2016 - bernd.oppolzer@yahoo.com                              *)
(*                                                                  *)
(*  tested with the new Stanford compiler version on VM Rel. 6      *)
(*  SNAPSHOT is linked from PASMONN using WXTRN                     *)
(*  no problem so far                                               *)
(*  the file QRD is written from the compiler as file QRR           *)
(*  (symbol table for variables and procedures)                     *)
(*  The identifiers now can have up to 20 chars in length.          *)
(*                                                                  *)
(*  PNAMLN changed to 20 to show longer variable and procedure      *)
(*  names correctly                                                 *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  10.2016 - bernd.oppolzer@yahoo.com                              *)
(*                                                                  *)
(*  The SNAPSHOT routine (now called PASSNAP) has been              *)
(*  enhanced to be able to show static variables, too.              *)
(*  To support this, the address of the STATIC CSECT is             *)
(*  stored at a certain place in the function prolog, which         *)
(*  can easily be found at run time (displacement of the            *)
(*  branch instruction at the EPA minus 4). If the address          *)
(*  at this place is zero, there are no static variables.           *)
(*                                                                  *)
(*  PASSNAP was further enhanced to show the EP addresses           *)
(*  of every function, the call offset at every call level          *)
(*  and the storage class, offset and address of every              *)
(*  variable (in addition to the variable name and the              *)
(*  value at the time of error or SNAPSHOT - in Pascal              *)
(*  notation).                                                      *)
(*                                                                  *)
(*  Other changes:                                                  *)
(*                                                                  *)
(*  - removed $ from internal proc names                            *)
(*                                                                  *)
(*  - to get access to the debug information which is at the        *)
(*    end of the Code CSECT, the length of the code is needed.      *)
(*    This was stored at EPA + 10 and overwrote part of the         *)
(*    CSECT info. I moved it behind the CSECT info, at the          *)
(*    position 2 bytes before the STATIC CSECT pointer, that        *)
(*    is: displacement of the initial branch instruction            *)
(*    minus 6. PASSNAP was changed at several places according      *)
(*    to this logic (see PTRADD-calls).                             *)
(*                                                                  *)
(*  - the calls to TRACER will work no more, because TRACER         *)
(*    still expects the code size at the old place (see             *)
(*    some places in PASMONN.ASS). This will be reworked later.     *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Dec 2016 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  The generation of the STATIC and CODE CSECTs was changed.       *)
(*                                                                  *)
(*  The STATIC CSECT contains its own size at offset 8;             *)
(*  the real data starts at offset 16 (10 to 15 are free).          *)
(*                                                                  *)
(*  The CODE CSECT contains the Pascal procedure name also          *)
(*  in the NODEBUG case in the CSECT identifier, and the            *)
(*  stacksize at a certain position (see GEN_CSECT and              *)
(*  INIT_CSECT for details).                                        *)
(*                                                                  *)
(*  This way it is possible for PASSNAP to show the areas           *)
(*  in their correct length also in the NODEBUG case in             *)
(*  hex dump format; and with the real Pascal proc names            *)
(*  (but no Pascal variable names; to do this, the DEBUG            *)
(*  switch and a DBGINFO file is needed).                           *)
(*                                                                  *)
(*  see procedure PRINT_VARIABLE and the calls of the               *)
(*  DUMP procedure in the NODEBUG case ...                          *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Apr 2017 - MVS Edition of PASSNAP - by Bernd Oppolzer           *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  To open the DBGINFO members with names known at runtime,        *)
(*  a new function ASSIGNMEM was created - and several              *)
(*  extensions have been made to the Pascal runtime PASMONN         *)
(*                                                                  *)
(*  After ASSIGNMEM and RESET, the File Status (offset 32           *)
(*  of the Pascal FCB) may be tested, and if it is '0',             *)
(*  the RESET was not successful, probably because the member       *)
(*  with the given name does not exist                              *)
(*                                                                  *)
(*  -------------------------------------------------------------   *)
(*                                                                  *)
(*  PASSNAP Edition for MVS = PASSNAP (easier for Linkage Editor)   *)
(*  PASSNAP Edition for CMS = PASSNAPC                              *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  May 2017 - Extensions to the Runtime by Bernd Oppolzer          *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  The error handling in the RUNTIME has been corrected and        *)
(*  improved for the case when PASSNAP is NOT used; this            *)
(*  introduced some changes in the common interface.                *)
(*                                                                  *)
(*  Now in case of an error a common error structure is built       *)
(*  and used by PASMONN and PASSNAP; see DUMPPARM below.            *)
(*                                                                  *)
(*  It contains the PSW, the registers, informations for            *)
(*  certain non-system runtime error like SUBRANGE and              *)
(*  some interesting addresses from the Pascal runtime              *)
(*  (heap pointers etc.).                                           *)
(*                                                                  *)
(*  See the procedure PRINT_SYSD, which prints these infos.         *)
(*                                                                  *)
(********************************************************************)



type CHARPTR = -> CHAR ;



procedure CMSX ( CMD : CHARPTR ; var RETCODE : INTEGER ) ;

   EXTERNAL ;



function $PASLIB ( FUNCCODE : INTEGER ; X : CHARPTR ) : CHARPTR ;

   EXTERNAL ;



procedure $PASSNAP ( LEVEL : INTEGER ; DUMPPTR : VOIDPTR ) ;

(****************************************************************)
(*  VALUES FOR DMPKIND WHEN CALLED BY A USER PROCEDURE ARE:     *)
(*                                                              *)
(*  0 - FULL LISTING EXCEPT THAT FOR ARRAYS, ONLY THE FIRST     *)
(*       AND LAST FEW  ENTRIES ARE PRINTED. (DEFAULT ON ABEND)  *)
(*                                                              *)
(*  1 - TRACE OF PROCEDURE CALLS ONLY (NO VARIABLES).           *)
(*                                                              *)
(* 10 - FULL LISTING INCLUDING ALL ENTRIES IN ARRAYS.           *)
(****************************************************************)


   const HALFW = 65536 ;

         (********)
         (*2EXP16*)
         (********)

         SL24 = 16777216 ;

         (********)
         (*2EXP24*)
         (********)

         ADDRC = SL24 ;
         PROCSIZE = 8192 ;
         FILHDRSIZE = 8 ;

         (*********************)
         (*SIZE OF FILE HEADER*)
         (*********************)

         VARLN = 8 ;
         PNAMLN = 20 ;
         BYL_INT = 4 ;
         MAL_INT = 4 ;
         BYL_HINT = 2 ;
         BYL_PTR = 4 ;
         MAL_PTR = 4 ;
         BYL_REAL = 8 ;
         MAL_REAL = 8 ;
         BYL_BOOL = 1 ;
         MAL_BOOL = 1 ;
         BYL_CHAR = 1 ;
         MAL_CHAR = 1 ;
         BYL_SET = 4 ;
         MAL_SET = 4 ;
         MAXELEM = 255 ;

         (*********************************)
         (*LARGEST IMPLEMENTED SET ELEMENT*)
         (*********************************)

         ELSPW = 32 ;

         (*********************************)
         (*NO. OF SET ELEMENTS PER WORD   *)
         (*********************************)

         MXINX = 8 ;

         (*********************************)
         (* = (MAXELEM+1) DIV ELSPW       *)
         (*********************************)

         IBFLN = 256 ;
         MIDCOL = 45 ;

         (************************************)
         (* APPROX. MIDDLE COLUMN ON LISTING *)
         (************************************)

         DEFLEV = 20 ;

         (***************************************)
         (* DEFAULT MAX LEVEL OF STACK TO TRACE *)
         (***************************************)

         ARRLMT = 4 ;

         (***************************************)
         (* DEFAULT # OF ARRAY ELEMENTS PRINTED *)
         (***************************************)

         STRLMT = 140 ;

         (****************************************)
         (* LIMIT ON STRING (ARRAY OF CHAR) SIZE *)
         (****************************************)

         UNDFINT = - 2122219135 ;

         (******************)
         (* HEX '81818181' *)
         (******************)

         UNDFHINT = - 32383 ;

         (******************)
         (* HEX '8181'     *)
         (******************)

         UNDFBYTE = 129 ;

         (******************)
         (* HEX '81'       *)
         (******************)

         MAXPTRS = 500 ;

         (*********************************)
         (* NO. OF ITEMS ON HEAP TO PRINT *)
         (*********************************)

         FULL = 0 ;
         STKTRACE = 1 ;

   type CHAR8 = array [ 1 .. 8 ] of CHAR ;
        CHAR80 = array [ 1 .. 80 ] of CHAR ;
        INT2PTR = record
                    case INTEGER of
                      0 :
                        ( P : CHARPTR ) ;
                      1 :
                        ( I : INTEGER ) ;
                  end ;
        ABNDP = -> DUMPPARM ;
        DUMPPARM = record
                     CHKERRC : INTEGER ;
                     CHKPSW1 : VOIDPTR ;
                     CHKPSW2 : VOIDPTR ;
                     CHKREGS : array [ 0 .. 15 ] of VOIDPTR ;
                     CHKINTRP : VOIDPTR ;
                     CHKITYPE : CHAR ;
                     CHKRANGE : CHAR ;
                     CHKFILE : CHAR ;
                     CHKDUMMY : CHAR ;
                     CHKLOWR : INTEGER ;
                     CHKUPPR : INTEGER ;
                     CHKCVAL : INTEGER ;
                     CHKMSGL : INTEGER ;
                     CHKMSG : -> MSGTYPE ;
                     CHKPASE : VOIDPTR ;
                     CHKHEAPP : VOIDPTR ;
                     CHKHEAPT : VOIDPTR ;
                   end ;
        MSGTYPE = array [ 1 .. 100 ] of CHAR ;
        HINTEGER = - 32768 .. 32767 ;
        DUMMYRNG = 0 .. 10000 ;
        PROCNAME = array [ 1 .. PNAMLN ] of CHAR ;
        PTR_TAG = record
                    case INTEGER of
                      1 :
                        ( I : INTEGER ) ;
                      2 :
                        ( C : CHAR ;

        (***********************)
        (* HOLDS TYPE CODE TAG *)
        (***********************)

                          P : array [ 1 .. 3 ] of CHAR )
                  end ;
        PROC_PTR = -> PROC_HEAD ;
        PROCTPTR = -> PROC_TAIL ;
        FRM_PTR = -> STK_FRM ;
        STK_FRM = record
                    case INTEGER of

        (*************************)
        (* STACK FRAME MARK AREA *)
        (*************************)

                      1 :
                        ( SPC1 : INTEGER ;
                          BAK_LNK : FRM_PTR ;
                          FOR_LNK : FRM_PTR ;
                          RET : INTEGER ;
                          EPA : PROC_PTR ;
                          GPR0_12 : array [ 0 .. 12 ] of INTEGER ;
                          SPC2 , SPC3 : INTEGER ;
                          FPRS : array [ 1 .. 4 ] of REAL ) ;

        (*********************************)
        (* STACK FRAME VARIABLE OVERLAYS *)
        (*********************************)

                      2 :
                        ( case INTEGER of
                            1 :
                              ( INT_VA : array [ DUMMYRNG ] of INTEGER
                                ) ;
                            2 :
                              ( BOOL_VA : array [ DUMMYRNG ] of BOOLEAN
                                ) ;
                            3 :
                              ( CHR_VA : array [ DUMMYRNG ] of CHAR ) ;
                            4 :
                              ( REAL_VA : array [ DUMMYRNG ] of REAL )
                                ;
                            5 :
                              ( HINT_VA : array [ DUMMYRNG ] of
                                          HINTEGER ) ) ;

        (*********************)
        (* GLOBAL STACK AREA *)
        (*********************)

                      3 :
                        ( SPCB : array [ 1 .. 18 ] of INTEGER ;
                          CURNTNP : INTEGER ;
                          ENDNP0 : INTEGER )
                  end ;
        PROC_HEAD = record
                      SPC1 : INTEGER ;
                      SPNAME : array [ 0 .. 5 ] of CHAR ;
                    end ;
        PROC_TAIL = record
                      PROCID : HINTEGER ;
                      SLINNO : HINTEGER ;
                      SOURCENAME : CHAR8 ;
                      LINARY : array [ 1 .. 100000 ] of CHAR ;
                    end ;
        VARTYPE = ( INT , SCL , RL , BOL , CHA , PTR , PSET , REC , ARY
                  , FIL , PAD , UNK ) ;

   var DMARRAY : array [ 0 .. 1 ] of FRM_PTR ;

       (******************************************)
       (* caution ... tricky; the stack frame    *)
       (* pointers are fetched by array access   *)
       (* using certain negative indexes;        *)
       (* works only, because dmarray is the     *)
       (* very first variable (offset zero)      *)
       (******************************************)
       (* NIH - Bernd Oppolzer - 2017            *)
       (******************************************)

       DMPKIND : INTEGER ;
       VARTARY : packed array [ 'A' .. 'Z' ] of VARTYPE ;
       DEPTH , MAXDEPTH , I , J , UID , PLEN : INTEGER ;
       CH : CHAR ;
       DONE : BOOLEAN ;
       TOPSTK , BOTSTK , TMPSTK , STATICP : FRM_PTR ;
       CPROCN : PROCNAME ;
       IBF : array [ 1 .. IBFLN ] of CHAR ;
       PAR2 : INTEGER ;
       ARRYLSTF : BOOLEAN ;
       NUMPTRS , LASTPTR : 0 .. MAXPTRS ;
       PROCSTOCOME : set of 0 .. 255 ;
       HEXCHARS : array [ 0 .. 15 ] of CHAR ;
       PTRS : array [ 1 .. MAXPTRS ] of PTR_TAG ;
       ISDEBUG : BOOLEAN ;
       SOURCENAME : CHAR8 ;
       QRD_IS_OPEN : BOOLEAN ;
       DP : -> DUMPPARM ;
       X : INTEGER ;
       ERRMS : MSGTYPE ;


   procedure DUMPSTOR ( PVON : VOIDPTR ; PBIS : VOIDPTR ) ;

   (*********************************************************)
   (*  Speicherbereich von PVON bis PBIS hexadezimal        *)
   (*  ausgeben                                             *)
   (*********************************************************)


      var P1 : VOIDPTR ;
          P2 : VOIDPTR ;
          MOD1 : INTEGER ;
          MOD2 : INTEGER ;

      const DUMPSHOWCHARS : set of CHAR =
            [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' , 'A' .. 'I' , 'J'
              .. 'R' , 'S' .. 'Z' , '0' .. '9' , ' ' , ',' , '.' , '-'
              , ';' , ':' , '_' , '!' , '"' , '' , '$' , '%' , '&' ,
              '/' , '(' , ')' , '=' , '?' , '+' , '*' , '#' , '*' ] ;


      procedure DUMPCHAR ( CH : CHAR ) ;

         begin (* DUMPCHAR *)
           if CH in DUMPSHOWCHARS then
             WRITE ( CH )
           else
             WRITE ( '.' )
         end (* DUMPCHAR *) ;


      procedure DUMPZEILE ( ADR : VOIDPTR ; P1 : VOIDPTR ; P2 : VOIDPTR
                          ) ;

         var CH : -> CHAR ;
             I : INTEGER ;
             J : INTEGER ;

         const HEXTAB : array [ 0 .. 15 ] of CHAR = '0123456789abcdef'
               ;

         begin (* DUMPZEILE *)
           WRITE ( ADR , ': ' ) ;
           CH := ADR ;
           for J := 1 to 4 do
             begin
               for I := 1 to 4 do
                 begin
                   if ( PTRDIFF ( CH , P1 ) < 0 ) or ( PTRDIFF ( CH ,
                   P2 ) > 0 ) then
                     WRITE ( '..' )
                   else
                     WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [
                             ORD ( CH -> ) MOD 16 ] ) ;
                   CH := PTRADD ( CH , 1 ) ;
                 end (* for *) ;
               WRITE ( ' ' ) ;
             end (* for *) ;
           CH := ADR ;
           WRITE ( ' *' ) ;
           for I := 1 to 16 do
             begin
               if ( PTRDIFF ( CH , P1 ) < 0 ) or ( PTRDIFF ( CH , P2 )
               > 0 ) then
                 WRITE ( ' ' )
               else
                 DUMPCHAR ( CH -> ) ;
               CH := PTRADD ( CH , 1 )
             end (* for *) ;
           WRITELN ( '*' ) ;
         end (* DUMPZEILE *) ;


      begin (* DUMPSTOR *)
        P1 := PTRADD ( PVON , - 16 ) ;
        MOD1 := PTR2INT ( P1 ) MOD 16 ;
        P1 := PTRADD ( P1 , 16 - MOD1 ) ;
        P2 := PTRADD ( PBIS , 16 ) ;
        MOD2 := PTR2INT ( P2 ) MOD 16 ;
        P2 := PTRADD ( P2 , - MOD2 ) ;
        while PTRDIFF ( P1 , P2 ) < 0 do
          begin
            DUMPZEILE ( P1 , PVON , PBIS ) ;
            P1 := PTRADD ( P1 , 16 ) ;
          end (* while *) ;
      end (* DUMPSTOR *) ;


   function IDLENGTH ( NAME : PROCNAME ) : INTEGER ;

      var I : INTEGER ;

      begin (* IDLENGTH *)
        I := PNAMLN ;
        while NAME [ I ] = ' ' do
          I := I - 1 ;
        IDLENGTH := I ;
      end (* IDLENGTH *) ;


   procedure PRINTHEX ( X : INTEGER ; L : INTEGER ) ;

      var IP : INT2PTR ;

      begin (* PRINTHEX *)
        IP . I := X ;
        WRITE ( IP . P : L ) ;
      end (* PRINTHEX *) ;


   procedure GET_PROCNAME ( P : PROC_PTR ; var PID , LEN : INTEGER ;
                          var NAME : PROCNAME ; var STATICP : FRM_PTR ;
                          var ISDEBUG : BOOLEAN ; var SOURCENAME :
                          CHAR8 ) ;

      type INTPTR = -> INTEGER ;

      var TP : record
                 case INTEGER of
                   1 :
                     ( I : INTEGER ) ;
                   2 :
                     ( P : PROCTPTR )
               end ;
          I : INTEGER ;
          OFFS : INTEGER ;
          PLEN : -> HINTEGER ;
          PSTATIC : -> FRM_PTR ;
          PDEBUG : -> HINTEGER ;
          LEN_NAME : INTEGER ;
          CP : -> CHAR ;
          COMP_SIG : array [ 1 .. 6 ] of CHAR ;
          LEN_KENNUNG : INTEGER ;

      begin (* GET_PROCNAME *)
        OFFS := P -> . SPC1 MOD 256 ;
        CP := PTRADD ( P , 4 ) ;
        LEN_KENNUNG := ORD ( CP -> ) ;
        repeat
          LEN_KENNUNG := LEN_KENNUNG + 1
        until LEN_KENNUNG MOD 4 = 2 ;
        CP := PTRADD ( CP , LEN_KENNUNG ) ;
        MEMCPY ( ADDR ( COMP_SIG ) , CP , 6 ) ;
        if COMP_SIG = 'STPASC' then
          begin
            PLEN := PTRADD ( P , OFFS ) ;
            PLEN := PTRADD ( PLEN , - 6 ) ;
            PSTATIC := PTRADD ( PLEN , 2 ) ;
            STATICP := PSTATIC -> ;
            PDEBUG := PTRADD ( PLEN , - 2 ) ;
            ISDEBUG := ( PDEBUG -> <> 0 ) ;
            LEN := PLEN -> ;
            PID := 0 ;
            NAME := ' ' ;
            SOURCENAME := ' ' ;
            LEN_NAME := ORD ( P -> . SPNAME [ 0 ] ) ;
            if LEN_NAME >= 29 then
              for I := 1 to PNAMLN do
                NAME [ I ] := P -> . SPNAME [ I + 9 ]
            else
              for I := 1 to 8 do
                NAME [ I ] := P -> . SPNAME [ I ] ;
            if ISDEBUG then
              begin
                TP . I := ORD ( P ) + LEN ;
                PID := TP . P -> . PROCID ;
                SOURCENAME := TP . P -> . SOURCENAME ;
              end (* then *) ;
          end (* then *)
        else
          begin
            NAME := '*UNKNOWN' ;
            STATICP := PTRADD ( NIL , 1 ) ;
            LEN := 0 ;
            PID := 0 ;
            ISDEBUG := FALSE ;
            SOURCENAME := ' '
          end (* else *)
      end (* GET_PROCNAME *) ;


   procedure PRINT_VARIABLE ( STKP : FRM_PTR ; STATICP : FRM_PTR ;
                            PNAME : PROCNAME ; PID : INTEGER ; ISDEBUG
                            : BOOLEAN ; SOURCENAME : CHAR8 ) ;

      label 999 ;

      type CMPCODE = ( PROCESS , SUCC , TYPERR , IDERR , SYNERR ,
                     NUMERR , EOFERR , BUFERR , ADDERR ) ;
           CNTRL = ( NAMED , UNNAMED , INDEXNAME , HEAPNAME ) ;

      var MAXI , I , VADDR , ALNFCT : INTEGER ;
          TPROCN : PROCNAME ;
          ERR : CMPCODE ;
          TN , NXT , NUM , J , LINELEN : INTEGER ;
          INDRCT : BOOLEAN ;
          SPKLASSE : CHAR ;
          H : array [ 1 .. 6 ] of CHAR ;
          SB : record
                 case INTEGER of
                   1 :
                     ( I : INTEGER ) ;
                   2 :
                     ( P : FRM_PTR )
               end ;
          CMSCMD : CHAR80 ;
          RC : INTEGER ;
          STATERC : INTEGER ;
          PSTATNAME : -> CHAR8 ;
          PSTATLEN : -> HINTEGER ;
          SSIZE : -> HINTEGER ;
          OFFS : HINTEGER ;
          AKT_PROC : PROC_PTR ;
          FCB : VOIDPTR ;
          CPT : CHARPTR ;


      procedure INS_SOURCENAME ( var CMD : CHAR80 ; SOURCENAME : CHAR8
                               ; STARTPOS : INTEGER ) ;

         begin (* INS_SOURCENAME *)
           for I := 1 to 8 do
             begin
               CMD [ STARTPOS ] := SOURCENAME [ I ] ;
               STARTPOS := STARTPOS + 1 ;
             end (* for *)
         end (* INS_SOURCENAME *) ;


      procedure ALIGN ( var OFFSET : INTEGER ; ALN : INTEGER ) ;

      (*******************************************************)
      (* ALIGNS POSITIVE 'OFFSET' ON AN 'ALN' BYTE BOUNDARY  *)
      (*******************************************************)


         begin (* ALIGN *)
           OFFSET := ( ( OFFSET + ALN - 1 ) DIV ALN ) * ALN ;
         end (* ALIGN *) ;


      procedure ERRMSG ( ECODE : CMPCODE ; INDX : INTEGER ) ;

         var J , K : INTEGER ;

         begin (* ERRMSG *)
           WRITELN ;
           WRITE ( '**** ERROR IN SYMBOL TABLE:    ' ) ;
           case ECODE of
             TYPERR :
               WRITELN ( 'ILLEGAL TYPE.' ) ;
             IDERR : WRITELN ( 'ILLEGAL IDENTIFIER.' ) ;
             SYNERR :
               WRITELN ( 'SYNTAX ERROR.' ) ;
             NUMERR :
               WRITELN ( 'IMPROPER NUMBER.' ) ;
             EOFERR :
               WRITELN ( 'PREMATURE END OF FILE.' ) ;
             BUFERR :
               WRITELN ( 'INTERNAL BUFFER EXCEEDED.' ) ;
             ADDERR :
               WRITELN ( 'ADDRESS EXPECTED.' ) ;
           end (* case *) ;
           J := 1 ;
           while J <= INDX do
             begin
               WRITELN ;
               WRITE ( ' ' ) ;
               if ( INDX - J + 1 ) < 80 then
                 K := INDX - J + 1
               else
                 K := 80 ;
               while K > 0 do
                 begin
                   WRITE ( IBF [ J ] ) ;
                   J := J + 1 ;
                   K := K - 1 ;
                 end (* while *) ;
             end (* while *) ;
           WRITELN ;
         end (* ERRMSG *) ;


      procedure PRINT ( INDNT : INTEGER ; var INDX : INTEGER ; SPKLASSE
                      : CHAR ; var OFFSET : INTEGER ; BASE : FRM_PTR ;
                      ARRINX : INTEGER ; IDCNTRL : CNTRL ) ;

         const DASHES = '    --------------------' ;

         var M , L , K , J , I , SAVALN : INTEGER ;
             UBND , LMT , LMT2 , LMT3 , LMT4 : INTEGER ;
             I_R_S : record
                       case INTEGER of
                         1 :
                           ( R : REAL ) ;
                         2 :
                           ( I1 : INTEGER ;
                             I2 : INTEGER ) ;
                     end ;
             TBOL : BOOLEAN ;
             TCH : CHAR ;
             H : array [ 1 .. 6 ] of CHAR ;
             IDNAME : array [ 1 .. PNAMLN ] of CHAR ;
             VTY : VARTYPE ;
             S_I : record
                     case INTEGER of
                       1 :
                         ( S : set of 0 .. MAXELEM ) ;
                       2 :
                         ( I : array [ 1 .. MXINX ] of INTEGER ) ;
                   end ;
             UNDF : BOOLEAN ;
             IP : INT2PTR ;


         procedure PRINT_UDEF ;

            const TN : array [ INT .. PSET ] of record L : 1 .. 8 ;
                  N : array [ 1 .. 8 ] of CHAR end =
                  ( ( 7 , 'INTEGER ' ) , ( 6 , 'SCALAR  ' ) , ( 4 ,
                    'REAL    ' ) , ( 7 , 'BOOLEAN ' ) , ( 4 ,
                    'CHAR    ' ) , ( 7 , 'POINTER ' ) , ( 3 ,
                    'SET     ' ) ) ;

            var LEN : 1 .. 8 ;

            begin (* PRINT_UDEF *)
              LEN := TN [ VTY ] . L ;
              WRITE ( ' = UNDEF. ' , TN [ VTY ] . N : LEN , ' ' ) ;
              LINELEN := LINELEN + LEN + 11 ;
            end (* PRINT_UDEF *) ;


         function CONVERT_NUM ( var IX : INTEGER ) : INTEGER ;

            var NUM , J : INTEGER ;
                SIGN : BOOLEAN ;

            begin (* CONVERT_NUM *)
              J := IX ;
              NUM := 0 ;
              SIGN := TRUE ;
              while IBF [ J ] = ' ' do
                J := J + 1 ;
              if IBF [ J ] = '-' then
                begin
                  SIGN := FALSE ;
                  J := J + 1 ;
                end (* then *) ;
              while IBF [ J ] in [ '0' .. '9' ] do
                begin
                  NUM := 10 * NUM + ORD ( IBF [ J ] ) - ORD ( '0' ) ;
                  J := J + 1 ;
                end (* while *) ;
              IX := J ;
              if SIGN then
                CONVERT_NUM := NUM
              else
                CONVERT_NUM := - NUM ;
            end (* CONVERT_NUM *) ;


         begin (* PRINT *)
           if IDCNTRL = NAMED then
             begin
               I := 0 ;
               IDNAME := '            ' ;
               while IBF [ INDX ] <> '=' do
                 begin
                   I := I + 1 ;
                   IDNAME [ I ] := IBF [ INDX ] ;
                   INDX := INDX + 1
                 end (* while *) ;
               INDX := INDX + 1 ;
             end (* then *) ;
           VTY := VARTARY [ IBF [ INDX ] ] ;
           if VTY in [ ARY , REC , PSET ] then
             if IDCNTRL <> HEAPNAME then
               LINELEN := MIDCOL ;

           (*******************************************************)
           (*    versuchsweise jede Zeile writeln ...             *)
           (*                                                     *)
           (*       if LINELEN >= MIDCOL then                     *)
           (*         begin                                       *)
           (*           WRITELN ;                                 *)
           (*           LINELEN := INDNT * 2 + 4 ;                *)
           (*           WRITE ( DASHES : LINELEN ) ;              *)
           (*         end                                         *)
           (*       else                                          *)
           (*         begin                                       *)
           (*           WRITE ( ' ' : MIDCOL + 4                  *)
           (*                   - LINELEN + INDNT * 2 ) ;         *)
           (*           LINELEN := MIDCOL + 2                     *)
           (*         end                                         *)
           (*******************************************************)

           WRITELN ;
           LINELEN := INDNT * 2 + 3 ;
           WRITE ( DASHES : LINELEN ) ;

           (*******************************************************)
           (*    Ende Versuch                                     *)
           (*-----------------------------------------------------*)
           (*    hier: Speicherklasse hinzugefuegt                *)
           (*******************************************************)

           LINELEN := LINELEN + PNAMLN + 19 ;
           case IDCNTRL of
             NAMED : begin
                       WRITE ( IDNAME : PNAMLN + 2 ) ;
                       WRITE ( '(' , SPKLASSE , '/' ) ;
                       PRINTHEX ( OFFSET , 4 ) ;
                       WRITE ( '/' , PTRADD ( BASE , OFFSET ) , ')' ) ;
                     end (* tag/ca *) ;
             UNNAMED :
               WRITE ( ' ' : PNAMLN + 19 ) ;
             INDEXNAME :
               WRITE ( ARRINX : PNAMLN + 18 , ':' ) ;
           end (* case *) ;

           (*******************************************************)
           (*    ausserdem adresse und offset                     *)
           (*******************************************************)

           INDX := INDX + 1 ;
           case VTY of
             INT , SCL :
               begin
                 J := ORD ( IBF [ INDX ] ) - ORD ( '0' ) ;
                 INDX := INDX + 1 ;
                 ALIGN ( OFFSET , J ) ;
                 ALIGN ( ALNFCT , J ) ;
                 if J = BYL_INT then
                   begin
                     I := BASE -> . INT_VA [ OFFSET DIV BYL_INT ] ;
                     UNDF := I = UNDFINT ;
                   end (* then *)
                 else
                   if J = BYL_HINT then
                     begin
                       I := BASE -> . HINT_VA [ OFFSET DIV BYL_HINT ] ;
                       UNDF := I = UNDFHINT ;
                     end (* then *)
                   else

           (****************)
           (* J = BYL_CHAR *)
           (****************)

                     begin
                       I := ORD ( BASE -> . CHR_VA [ OFFSET ] ) ;
                       UNDF := FALSE ;
                     end (* else *) ;
                 if UNDF then
                   PRINT_UDEF
                 else
                   if ( - 999999 <= I ) and ( I <= 9999999 ) then
                     begin
                       WRITE ( ' =' , I : 8 ) ;
                       LINELEN := LINELEN + 10
                     end (* then *)
                   else
                     begin
                       WRITE ( ' =' , I : 14 ) ;
                       LINELEN := LINELEN + 14 ;
                     end (* else *) ;
                 OFFSET := OFFSET + J ;
               end (* tag/ca *) ;
             RL : begin
                    ALIGN ( OFFSET , BYL_REAL ) ;
                    ALIGN ( ALNFCT , BYL_REAL ) ;
                    I_R_S . R := BASE -> . REAL_VA [ OFFSET DIV
                                 BYL_REAL ] ;
                    if ( I_R_S . I1 = UNDFINT ) and ( I_R_S . I2 =
                    UNDFINT ) then
                      PRINT_UDEF
                    else
                      begin
                        WRITE ( ' =' , I_R_S . R : 14 ) ;
                        LINELEN := LINELEN + 16
                      end (* else *) ;
                    OFFSET := OFFSET + BYL_REAL ;
                  end (* tag/ca *) ;
             CHA : begin
                     WRITE ( ' =     ''' ) ;

           (**********************************)
           (* LENGTH=1 --> NO ALIGNMENT HERE *)
           (**********************************)

                     TCH := BASE -> . CHR_VA [ OFFSET ] ;
                     if ( 64 <= ORD ( TCH ) ) and ( ORD ( TCH ) <= 250
                     ) then
                       WRITE ( TCH , '''' )
                     else
                       WRITE ( '#''' ) ;
                     LINELEN := LINELEN + 10 ;
                     OFFSET := OFFSET + BYL_CHAR ;
                   end (* tag/ca *) ;
             BOL : begin

           (**********************************)
           (* LENGTH=1 --> NO ALIGNMENT HERE *)
           (**********************************)

                     TBOL := BASE -> . BOOL_VA [ OFFSET ] ;
                     if ORD ( TBOL ) = UNDFBYTE then
                       PRINT_UDEF
                     else
                       begin
                         LINELEN := LINELEN + 10 ;
                         if TBOL then
                           WRITE ( ' =   TRUE ' )
                         else
                           WRITE ( ' =   FALSE' ) ;
                       end (* else *) ;
                     OFFSET := OFFSET + BYL_BOOL ;
                   end (* tag/ca *) ;
             PTR : begin
                     ALIGN ( OFFSET , BYL_PTR ) ;
                     ALIGN ( ALNFCT , BYL_PTR ) ;
                     I := CONVERT_NUM ( INDX ) ;

           (***************)
           (*TYPE CODE NO.*)
           (***************)

                     J := BASE -> . INT_VA [ OFFSET DIV BYL_INT ] ;
                     IP . I := J ;
                     repeat
                       if J = - 1 then
                         begin
                           WRITE ( ' =     NIL' ) ;
                           LINELEN := LINELEN + 10 ;
                           break ;
                         end (* then *) ;
                       if J = UNDFINT then
                         begin
                           PRINT_UDEF ;
                           break ;
                         end (* then *) ;
                       if ( BOTSTK -> . CURNTNP <= J ) and ( J <=
                       BOTSTK -> . ENDNP0 ) then
                         begin
                           WRITE ( ' = ' , IP . P ) ;
                           WRITE ( ' (HEAP/NEW)' ) ;
                           LINELEN := LINELEN + 22 ;
                           if NUMPTRS < MAXPTRS then
                             if I in [ 0 .. 255 ] then
                               begin
                                 PTRS [ NUMPTRS + 1 ] . I := J ;
                                 K := 1 ;
                                 while PTRS [ K ] . P <> PTRS [ NUMPTRS
                                 + 1 ] . P do
                                   K := K + 1 ;
                                 if K > NUMPTRS then
                                   NUMPTRS := K ;
                                 PTRS [ K ] . C := CHR ( I ) ;
                               end (* then *) ;
                           break ;
                         end (* then *) ;
                       if $PASLIB ( 6 , IP . P ) <> NIL then
                         begin
                           WRITE ( ' = ' , IP . P ) ;
                           WRITE ( ' (HEAP/ALLOC)' ) ;
                           LINELEN := LINELEN + 24 ;
                           if NUMPTRS < MAXPTRS then
                             if I in [ 0 .. 255 ] then
                               begin
                                 PTRS [ NUMPTRS + 1 ] . I := J ;
                                 K := 1 ;
                                 while PTRS [ K ] . P <> PTRS [ NUMPTRS
                                 + 1 ] . P do
                                   K := K + 1 ;
                                 if K > NUMPTRS then
                                   NUMPTRS := K ;
                                 PTRS [ K ] . C := CHR ( I ) ;
                               end (* then *) ;
                           break ;
                         end (* then *) ;

           (*******************)
           (* BAD/OLD POINTER *)
           (*******************)

                       WRITE ( ' = ' , IP . P , ' (INVALID POINTER)' )
                               ;
                       LINELEN := LINELEN + 29
                     until TRUE ;
                     OFFSET := OFFSET + BYL_INT ;
                   end (* tag/ca *) ;
             PSET : begin
                      ALIGN ( OFFSET , MAL_SET ) ;
                      ALIGN ( ALNFCT , MAL_SET ) ;
                      I := OFFSET DIV BYL_SET ;
                      M := CONVERT_NUM ( INDX ) ;
                      L := CONVERT_NUM ( INDX ) ;
                      L := ( L + ELSPW - 1 ) DIV ELSPW ;
                      S_I . S := [ ] ;
                      UNDF := TRUE ;
                      for J := 1 to L do
                        begin
                          S_I . I [ J ] := BASE -> . INT_VA [ I + J - 1
                                           ] ;
                          if S_I . I [ J ] <> UNDFINT then
                            UNDF := FALSE ;
                        end (* for *) ;
                      if UNDF then
                        PRINT_UDEF
                      else
                        begin
                          K := 0 ;
                          TCH := '(' ;
                          WRITE ( ' = ' ) ;
                          repeat
                            if K in S_I . S then
                              begin
                                WRITE ( TCH , K : 1 ) ;
                                J := K ;
                                while ( J < MAXELEM ) and ( ( J + 1 )
                                in S_I . S ) do
                                  J := J + 1 ;
                                if J > K then
                                  if J > ( K + 1 ) then
                                    WRITE ( '..' , J : 1 )
                                  else
                                    WRITE ( ',' , J : 1 ) ;
                                TCH := ',' ;
                                K := J + 2 ;
                              end (* then *)
                            else
                              K := K + 1 ;
                          until K > MAXELEM ;
                          if TCH = '(' then
                            begin
                              WRITE ( 'EMPTY' ) ;
                              LINELEN := LINELEN + 8
                            end (* then *)
                          else
                            begin
                              WRITE ( ')' ) ;
                              LINELEN := MIDCOL
                            end (* else *) ;
                        end (* else *) ;
                      OFFSET := OFFSET + L * BYL_SET ;
                    end (* tag/ca *) ;
             REC : begin
                     WRITE ( ' = RECORD' ) ;
                     J := ORD ( IBF [ INDX ] ) - ORD ( '0' ) ;
                     INDX := INDX + 2 ;
                     ALIGN ( OFFSET , J ) ;
                     ALIGN ( ALNFCT , J ) ;
                     INDNT := INDNT + 1 ;
                     LINELEN := MIDCOL ;
                     if IBF [ INDX - 1 ] = '(' then
                       while IBF [ INDX ] <> ')' do
                         begin
                           PRINT ( INDNT , INDX , 'R' , OFFSET , BASE ,
                                   0 , NAMED ) ;
                         end (* while *) ;
                     INDX := INDX + 1 ;
                     LINELEN := MIDCOL ;
                   end (* tag/ca *) ;
             ARY : begin
                     K := CONVERT_NUM ( INDX ) ;
                     M := CONVERT_NUM ( INDX ) ;
                     INDX := INDX + 1 ;
                     UBND := M - K ;
                     if ( VARTARY [ IBF [ INDX ] ] = CHA ) and ( UBND
                     <= STRLMT ) then
                       begin
                         WRITE ( ' = ''' ) ;
                         for I := 0 to UBND do
                           begin
                             TCH := BASE -> . CHR_VA [ OFFSET ] ;
                             OFFSET := OFFSET + 1 ;
                             if ( 64 <= ORD ( TCH ) ) and ( ORD ( TCH )
                             <= 250 ) then
                               WRITE ( TCH )
                             else
                               WRITE ( '#' ) ;
                           end (* for *) ;
                         WRITE ( '''' ) ;
                         LINELEN := LINELEN + UBND + 6 ;
                         INDX := INDX + 1 ;
                       end (* then *)
                     else
                       begin

           (*******************************************)
           (* FIND THE RANGE OF INDICES TO BE PRINTED *)
           (*******************************************)

                         LMT := ARRLMT ;
                         if UBND <= 3 * ARRLMT then
                           LMT := ARRLMT * 2 ;

           (*****************************************)
           (* SHORT ARRAYS, PRINT THE WHOLE THING,  *)
           (* VERY LONG ARRAYS, PRINT MORE ELEMENTS *)
           (*****************************************)

                         LMT4 := UBND - LMT ;
                         LMT2 := LMT4 DIV 2 ;
                         LMT3 := LMT2 + LMT + 1 ;
                         SAVALN := ALNFCT ;
                         ALNFCT := BYL_CHAR ;

           (********)
           (*=1    *)
           (********)

                         LINELEN := MIDCOL ;
                         for I := 0 to UBND do
                           if ( I < LMT ) or ( ( LMT2 < I ) and ( I <
                           LMT3 ) ) or ( I > LMT4 ) or ARRYLSTF then
                             begin
                               J := INDX ;
                               L := OFFSET ;
                               PRINT ( INDNT + 1 , J , 'X' , OFFSET ,
                                       BASE , K + I , INDEXNAME ) ;
                               ALIGN ( OFFSET , ALNFCT ) ;
                               L := OFFSET - L ;

           (***************************)
           (* LENGTH OF ARRAY ELEMENT *)
           (***************************)

                             end (* then *)
                           else
                             begin
                               if ( I = LMT ) or ( I = LMT3 ) then
                                 WRITELN ;
                               J := INDX ;
                               LINELEN := MIDCOL ;
                               OFFSET := OFFSET + L ;

           (****************************)
           (* SKIP OVER OTHER ELEMENTS *)
           (****************************)

                             end (* else *) ;
                         INDX := J - 1 ;
                         ALIGN ( ALNFCT , SAVALN ) ;

           (***************************)
           (* UPDATE ALIGNMENT FACTOR *)
           (***************************)

                         LINELEN := MIDCOL ;
                       end (* else *) ;
                   end (* tag/ca *) ;
             FIL : begin
                     INDX := INDX + 1 ;
                     WRITE ( ': FILE COMPONENT' ) ;
                     ALIGN ( OFFSET , BYL_INT ) ;
                     ALIGN ( ALNFCT , BYL_INT ) ;
                     OFFSET := OFFSET + FILHDRSIZE ;
                     LINELEN := LINELEN + 16 ;
                     PRINT ( INDNT + 1 , INDX , 'F' , OFFSET , BASE , 0
                             , UNNAMED ) ;
                   end (* tag/ca *) ;
             PAD : begin

           (**********************)
           (* SKIP PADDING BYTES *)
           (**********************)

                     K := CONVERT_NUM ( INDX ) ;
                     OFFSET := OFFSET + K ;
                   end (* tag/ca *) ;
           end (* case *) ;
           INDX := INDX + 1 ;
         end (* PRINT *) ;


      function IVSCAN ( var IX : INTEGER ; IDREQ : BOOLEAN ) : CMPCODE
                      ;

      /***************************************************/
      /* implemented using gotos                         */
      /* rework, if spare time                           */
      /***************************************************/


         label 10 , 20 , 30 , 40 ;

         var NEST : 0 .. 20 ;
             INDX : INTEGER ;
             NUMOK : BOOLEAN ;
             VTYPE : VARTYPE ;


         procedure SCAN_INTEGER ;

            begin (* SCAN_INTEGER *)
              INDX := INDX + 1 ;
              IBF [ INDX ] := ' ' ;
              if EOT ( QRD ) then
                begin
                  NUMOK := FALSE ;
                  return ;
                end (* then *) ;
              if QRD -> in [ '0' .. '9' ] then
                repeat
                  INDX := INDX + 1 ;
                  if INDX > IBFLN - 4 then
                    begin
                      NUMOK := FALSE ;
                      return ;
                    end (* then *) ;
                  IBF [ INDX ] := QRD -> ;
                  GET ( QRD ) ;
                until not ( QRD -> in [ '0' .. '9' ] )
              else
                NUMOK := FALSE ;
            end (* SCAN_INTEGER *) ;


         begin (* IVSCAN *)
           IVSCAN := EOFERR ;
           NEST := 0 ;
           NUMOK := TRUE ;
           INDX := IX ;
           if IDREQ then
             begin
               30 :
               if EOT ( QRD ) then
                 goto 10 ;
               if QRD -> in [ 'A' .. 'Z' , '$' , '_' ] then
                 repeat
                   INDX := INDX + 1 ;
                   if INDX > IBFLN - 4 then
                     begin
                       IVSCAN := BUFERR ;
                       goto 10
                     end (* then *) ;
                   IBF [ INDX ] := QRD -> ;
                   GET ( QRD ) ;
                   if EOF ( QRD ) then
                     goto 10 ;
                 until not ( QRD -> in [ 'A' .. 'Z' , '$' , '_' , '0'
                 .. '9' ] )
               else
                 if ( NEST > 0 ) and ( QRD -> = ')' ) then
                   begin
                     NEST := NEST - 1 ;
                     GET ( QRD ) ;
                     INDX := INDX + 1 ;
                     IBF [ INDX ] := ')' ;
                     goto 40 ;
                   end (* then *)
                 else
                   begin
                     IVSCAN := IDERR ;
                     goto 10
                   end (* else *) ;
               if EOT ( QRD ) then
                 goto 10 ;
               if QRD -> <> '=' then
                 begin
                   IVSCAN := SYNERR ;
                   goto 10
                 end (* then *) ;
               INDX := INDX + 1 ;
               IBF [ INDX ] := '=' ;
               GET ( QRD ) ;
             end (* then *) ;
           20 :
           if EOT ( QRD ) then
             goto 10 ;
           if QRD -> in [ 'A' .. 'Z' ] then
             VTYPE := VARTARY [ QRD -> ]
           else
             VTYPE := UNK ;
           INDX := INDX + 1 ;
           if INDX > IBFLN - 4 then
             begin
               IVSCAN := BUFERR ;
               goto 10
             end (* then *) ;
           IBF [ INDX ] := QRD -> ;
           GET ( QRD ) ;
           case VTYPE of
             UNK : begin
                     IVSCAN := TYPERR ;
                     goto 10
                   end (* tag/ca *) ;
             INT , SCL :
               if QRD -> in [ '1' , '2' , '4' ] then
                 begin
                   INDX := INDX + 1 ;
                   IBF [ INDX ] := QRD -> ;
                   GET ( QRD )
                 end (* then *)
               else
                 begin
                   INDX := INDX + 1 ;
                   IBF [ INDX ] := '4'
                 end (* else *) ;
             CHA , BOL :
               ;

           (**********************)
           (* NO ACTION REQUIRED *)
           (**********************)

             FIL : begin
                     INDX := INDX + 1 ;
                     IBF [ INDX ] := ' ' ;
                     goto 20
                   end (* tag/ca *) ;
             PSET : begin
                      SCAN_INTEGER ;
                      SCAN_INTEGER ;
                      if not NUMOK then
                        goto 10
                    end (* tag/ca *) ;
             ARY : begin
                     SCAN_INTEGER ;
                     SCAN_INTEGER ;
                     if not NUMOK then
                       goto 10 ;
                     INDX := INDX + 1 ;
                     IBF [ INDX ] := ' ' ;
                     goto 20
                   end (* tag/ca *) ;
             PTR , PAD :
               begin
                 SCAN_INTEGER ;
                 if not NUMOK then
                   goto 10
               end (* tag/ca *) ;
             REC : begin
                     INDX := INDX + 1 ;
                     if QRD -> in [ '1' , '2' , '4' , '8' ] then
                       begin
                         IBF [ INDX ] := QRD -> ;
                         GET ( QRD )
                       end (* then *)
                     else
                       IBF [ INDX ] := '1' ;
                     if EOT ( QRD ) then
                       goto 10 ;
                     if QRD -> = '(' then
                       begin
                         GET ( QRD ) ;
                         NEST := NEST + 1 ;
                         INDX := INDX + 1 ;
                         IBF [ INDX ] := '(' ;
                         IDREQ := TRUE ;
                         goto 30
                       end (* then *)
                     else
                       begin
                         IVSCAN := SYNERR ;
                         goto 10
                       end (* else *) ;
                   end (* tag/ca *) ;
           end (* case *) ;
           if EOT ( QRD ) then
             goto 10 ;
           40 :
           if QRD -> <> ';' then
             begin
               IVSCAN := SYNERR ;
               goto 10
             end (* then *) ;
           INDX := INDX + 1 ;
           IBF [ INDX ] := ';' ;
           GET ( QRD ) ;
           if NEST > 0 then
             goto 30 ;
           IVSCAN := SUCC ;
           10 :
           if not NUMOK then
             IVSCAN := NUMERR ;
           IX := INDX ;
         end (* IVSCAN *) ;


      begin (* PRINT_VARIABLE *)
        AKT_PROC := STKP -> . EPA ;
        OFFS := AKT_PROC -> . SPC1 MOD 256 ;
        SSIZE := PTRADD ( AKT_PROC , OFFS ) ;
        SSIZE := PTRADD ( SSIZE , - 10 ) ;
        WRITELN ;
        WRITELN ( '**** VARIABLES FOR ' , PNAME : IDLENGTH ( PNAME ) ,
                  ' ****' ) ;
        WRITELN ( '     Stack at address ' , STKP ) ;
        if PTR2INT ( STATICP ) = 0 then
          WRITELN ( '     No static variables' )
        else
          WRITELN ( '     Static variables at address ' , STATICP ) ;
        if not ISDEBUG then
          begin
            WRITELN ( '     Procedure ' , PNAME : IDLENGTH ( PNAME ) ,
                      ' compiled without DEBUG option' ) ;
            WRITELN ( '     Areas can only be dumped ' 'in hex ' ) ;
            WRITELN ;
            WRITELN ( '**** Stack Area' , ' (Length = ' , SSIZE -> : 1
                      , ') ****' ) ;
            WRITELN ;
            DUMPSTOR ( PTRCAST ( STKP ) , PTRADD ( STKP , SSIZE -> - 1
                       ) ) ;
            if PTR2INT ( STATICP ) <> 0 then
              begin
                PSTATNAME := PTRCAST ( STATICP ) ;
                PSTATLEN := PTRADD ( STATICP , 8 ) ;
                WRITELN ;
                WRITELN ( '**** Static Area ' , PSTATNAME -> : 8 ,
                          ' (Length = ' , PSTATLEN -> : 1 , ') ****' )
                          ;
                WRITELN ;
                DUMPSTOR ( PTRCAST ( STATICP ) , PTRADD ( STATICP ,
                           PSTATLEN -> - 1 ) ) ;
              end (* then *) ;
            return
          end (* then *) ;

        (*******************************************)
        (* the following part is different between *)
        (* the mvs and cms versions ... opening    *)
        (* the dbginfo files depending on the      *)
        (* procedure name ...                      *)
        (*******************************************)

        if not ( PID in PROCSTOCOME ) then
          begin
            if QRD_IS_OPEN then
              CLOSE ( QRD ) ;
            QRD_IS_OPEN := FALSE ;
            if FALSE then
              WRITELN ( 'print_variable: try reset(qrd), sourcename = '
                        , SOURCENAME ) ;
            CMSCMD := 'STATE XXXXXXXX DBGINFO * #' ;
            INS_SOURCENAME ( CMSCMD , SOURCENAME , 7 ) ;
            CMSX ( ADDR ( CMSCMD ) , RC ) ;
            if FALSE then
              begin
                WRITELN ( 'CMSX: ' , CMSCMD ) ;
                WRITELN ( 'print_variable: state command returns rc = '
                          , RC ) ;
              end (* then *) ;
            STATERC := RC ;
            CMSCMD := 'FILEDEF QRD CLEAR #' ;
            CMSX ( ADDR ( CMSCMD ) , RC ) ;
            if STATERC = 0 then
              begin
                CMSCMD := 'FILEDEF QRD DISK XXXXXXXX DBGINFO * '
                          '(RECFM F LRECL 80#' ;
                INS_SOURCENAME ( CMSCMD , SOURCENAME , 18 ) ;
                CMSX ( ADDR ( CMSCMD ) , RC ) ;
                if FALSE then
                  WRITELN ( 'print_variable: filedef returns rc = ' ,
                            RC ) ;
                RESET ( QRD ) ;
                PROCSTOCOME := [ 0 .. 255 ] ;
                QRD_IS_OPEN := TRUE ;
              end (* then *)
            else
              begin
                WRITELN ( '     Debug information file for '
                          'program/module ' , SOURCENAME , ' not found'
                          ) ;
                WRITELN ;
                return ;
              end (* else *) ;
          end (* then *) ;

        (*******************************************)
        (* end of opsys dependency                 *)
        (*******************************************)

        TPROCN := '            ' ;
        VADDR := - 1 ;
        while ( ( PNAME <> TPROCN ) or ( PID <> VADDR ) ) and ( not EOF
        ( QRD ) ) do
          begin
            while ( QRD -> <> '%' ) and ( not EOF ( QRD ) ) do
              READLN ( QRD ) ;
            GET ( QRD ) ;

        (*****************)
        (* SKIP OVER "%" *)
        (*****************)

            if not EOT ( QRD ) then
              begin
                I := 1 ;
                TPROCN := '            ' ;
                while ( QRD -> <> ' ' ) do
                  if I <= PNAMLN then
                    begin
                      READ ( QRD , TPROCN [ I ] ) ;
                      I := I + 1
                    end (* then *)
                  else
                    GET ( QRD ) ;
                READLN ( QRD , VADDR ) ;
                if VADDR in [ 0 .. 255 ] then
                  PROCSTOCOME := PROCSTOCOME - [ VADDR ] ;
              end (* then *) ;
          end (* while *) ;
        if ( PNAME = TPROCN ) and ( PID = VADDR ) then
          begin
            ERR := SUCC ;
            if EOT ( QRD ) then
              goto 999 ;
            LINELEN := MIDCOL ;
            while QRD -> in [ '@' , '0' .. '9' ] do
              begin
                if QRD -> = '@' then
                  begin
                    INDRCT := TRUE ;
                    GET ( QRD ) ;
                    if EOT ( QRD ) then
                      begin
                        ERR := EOFERR ;
                        goto 999
                      end (* then *) ;
                    if not ( QRD -> in [ '0' .. '9' ] ) then
                      begin
                        ERR := ADDERR ;
                        goto 999
                      end (* then *) ;
                  end (* then *)
                else
                  INDRCT := FALSE ;
                MAXI := 0 ;
                READ ( QRD , VADDR ) ;
                while QRD -> = ' ' do
                  GET ( QRD ) ;
                SPKLASSE := QRD -> ;
                GET ( QRD ) ;
                ERR := IVSCAN ( MAXI , TRUE ) ;
                if ERR <> SUCC then
                  goto 999 ;
                I := 1 ;
                ALNFCT := MAL_CHAR ;

        (*******************************)
        (* INITIALIZE ALIGNMENT FACTOR *)
        (*******************************)

                if INDRCT then
                  begin
                    SB . I := STKP -> . INT_VA [ VADDR DIV BYL_INT ] ;
                    VADDR := 0 ;
                    if ( ORD ( BOTSTK ) <= SB . I ) and ( SB . I <=
                    BOTSTK -> . ENDNP0 ) then
                      PRINT ( 0 , I , 'A' , VADDR , SB . P , 0 , NAMED
                              ) ;
                  end (* then *)
                else
                  if SPKLASSE = 'A' then
                    begin
                      SB . P := STKP ;
                      PRINT ( 0 , I , 'A' , VADDR , SB . P , 0 , NAMED
                              )
                    end (* then *)
                  else
                    if SPKLASSE = 'S' then
                      if PTR2INT ( STATICP ) > 0 then
                        begin
                          SB . P := STATICP ;
                          PRINT ( 0 , I , 'S' , VADDR , SB . P , 0 ,
                                  NAMED )
                        end (* then *) ;
                if EOT ( QRD ) then
                  goto 999 ;
              end (* while *) ;
            if ( QRD -> = '>' ) and ( NUMPTRS > 0 ) then
              begin

        (****************************)
        (* PRINT HEAP STORAGE ITEMS *)
        (****************************)

                NXT := BOTSTK -> . CURNTNP ;
                TN := 0 ;
                while QRD -> = '>' do

        (***********************************)
        (* FIRST READ THE HEAP TYPE DEFN.S *)
        (***********************************)

                  begin
                    NUM := 0 ;
                    GET ( QRD ) ;
                    TN := TN + 1 ;
                    if QRD -> in [ '0' .. '9' ] then
                      READ ( QRD , NUM ) ;
                    if TN = NUM then
                      begin
                        MAXI := 0 ;
                        ERR := IVSCAN ( MAXI , FALSE ) ;
                        if ERR <> SUCC then
                          goto 999 ;
                        if ODD ( MAXI ) then
                          MAXI := MAXI + 1 ;
                        NXT := NXT - MAXI - 2 ;
                        SB . I := NXT ;
                        for I := 1 to MAXI do
                          SB . P -> . CHR_VA [ I - 1 ] := IBF [ I ] ;
                        SB . P -> . HINT_VA [ MAXI DIV 2 ] := MAXI + 2
                                                   ;
                      end (* then *)
                    else
                      begin
                        ERR := NUMERR ;
                        goto 999
                      end (* else *) ;
                    if EOT ( QRD ) then

        (************)
        (*DO NOTHING*)
        (************)

                      ;
                  end (* while *) ;
                I := LASTPTR ;
                while I < NUMPTRS do

        (****************************)
        (* NOW PRINT EACH HEAP ITEM *)
        (****************************)

                  begin
                    I := I + 1 ;
                    NUM := ORD ( PTRS [ I ] . C ) ;
                    PTRS [ I ] . C := CHR ( 0 ) ;
                    J := PTRS [ I ] . I ;
                    if NUM <= TN then
                      begin
                        SB . I := BOTSTK -> . CURNTNP ;

        /**********************/
        /* was repeat --- ??? */
        /**********************/

                        while NUM > 0 do
                          begin
                            MAXI := SB . P -> . HINT_VA [ - 1 ] ;
                            SB . I := SB . I - MAXI ;
                            NUM := NUM - 1 ;
                          end (* while *) ;
                        PACK ( SB . P -> . CHR_VA , 0 , IBF ) ;

        (***********************************)
        (* ONLY "MAXI" CHARS NEED BE MOVED *)
        (***********************************)

                        SB . I := J ;
                        ALNFCT := BYL_INT ;
                        NUM := 1 ;
                        J := 0 ;
                        WRITELN ;
                        WRITELN ;
                        WRITE ( ' HEAP STORAGE AT ' : 22 , SB . P ) ;
                        LINELEN := 30 ;
                        PRINT ( 1 , NUM , 'H' , J , SB . P , 0 ,
                                HEAPNAME ) ;
                      end (* then *)
                    else
                      begin
                        ERR := NUMERR ;
                        MAXI := 0 ;
                        goto 999
                      end (* else *) ;
                  end (* while *) ;
                LASTPTR := I ;
              end (* then *) ;
            999 :
            if ERR <> SUCC then
              ERRMSG ( ERR , MAXI ) ;
          end (* then *)
        else
          WRITELN ( '     Procedure ' , PNAME , ' (ID:' , PID : 4 ,
                    ') not found in symbol table' ) ;
        WRITELN ;
      end (* PRINT_VARIABLE *) ;


   function GET_FROMLINE ( P : PROC_PTR ; RTNADD : INTEGER ) : INTEGER
                         ;

      const ESCAPE = 254 ;

            (************)
            (* HEX 'FE' *)
            (************)

            ESEND = 255 ;

            (************)
            (* HEX 'FF' *)
            (************)


      var NADDR , LIN , I , INDX : INTEGER ;
          TL : record
                 case INTEGER of
                   1 :
                     ( I : INTEGER ) ;
                   2 :
                     ( P : PROCTPTR )
               end ;
          OFFS : INTEGER ;
          PLEN : -> HINTEGER ;

      begin (* GET_FROMLINE *)
        OFFS := P -> . SPC1 MOD 4096 ;
        PLEN := PTRADD ( P , OFFS ) ;
        PLEN := PTRADD ( PLEN , - 6 ) ;
        I := PLEN -> ;
        if ( I <= 0 ) or ( I > PROCSIZE ) then
          GET_FROMLINE := 0
        else
          begin
            NADDR := ORD ( P ) ;
            TL . I := ORD ( P ) + I ;
            LIN := TL . P -> . SLINNO ;
            if ( RTNADD < NADDR ) or ( RTNADD >= TL . I ) then
              begin
                NADDR := 0 ;
                LIN := 0
              end (* then *) ;
            INDX := 1 ;
            with TL . P -> do
              while ( RTNADD > NADDR ) and ( ORD ( LINARY [ INDX ] ) <>
              ESEND ) do
                begin
                  I := ORD ( LINARY [ INDX ] ) ;
                  INDX := INDX + 1 ;
                  LIN := LIN + 1 ;
                  if I <> ESCAPE then
                    NADDR := NADDR + 2 * I
                  else
                    begin
                      NADDR := NADDR + ORD ( LINARY [ INDX ] ) * 512 +
                               ORD ( LINARY [ INDX + 1 ] ) * 2 ;
                      INDX := INDX + 2 ;
                    end (* else *) ;
                end (* while *) ;
            GET_FROMLINE := LIN ;
          end (* else *) ;
      end (* GET_FROMLINE *) ;


   procedure PRINT_LNK ( CURSTK , PRESTK : FRM_PTR ; var PNAME :
                       PROCNAME ; var PID , LNGTH : INTEGER ) ;

      var TPROCN : PROCNAME ;
          I , J : INTEGER ;
          DUMMYST : FRM_PTR ;
          RET24 : INTEGER ;
          EPA24 : INTEGER ;
          CALL_OFFS : INTEGER ;
          ISDEBUGP : BOOLEAN ;
          ISDEBUGC : BOOLEAN ;
          SOURCENAMEP : CHAR8 ;
          SOURCENAMEC : CHAR8 ;

      begin (* PRINT_LNK *)
        GET_PROCNAME ( CURSTK -> . EPA , PID , LNGTH , PNAME , DUMMYST
                       , ISDEBUGC , SOURCENAMEC ) ;
        GET_PROCNAME ( PRESTK -> . EPA , J , I , TPROCN , DUMMYST ,
                       ISDEBUGP , SOURCENAMEP ) ;
        WRITELN ;
        WRITELN ( '**** PROCEDURE ' , PNAME : IDLENGTH ( PNAME ) ,
                  ' WAS CALLED BY --> ' , TPROCN : IDLENGTH ( TPROCN )
                  ) ;
        if ISDEBUGC and ISDEBUGP then
          WRITELN ( '     FROM LINE: ' , GET_FROMLINE ( PRESTK -> . EPA
                    , ( CURSTK -> . RET MOD ADDRC ) ) : 1 ) ;
        WRITELN ( '     EPA address of ' , PNAME : IDLENGTH ( PNAME ) ,
                  ' is ' , CURSTK -> . EPA ) ;
        if PRESTK -> . EPA <> CURSTK -> . EPA then
          WRITELN ( '     EPA address of ' , TPROCN : IDLENGTH ( TPROCN
                    ) , ' is ' , PRESTK -> . EPA ) ;
        RET24 := CURSTK -> . RET MOD SL24 ;
        EPA24 := PTR2INT ( PRESTK -> . EPA ) MOD SL24 ;
        CALL_OFFS := RET24 - EPA24 ;
        WRITE ( '     Call offset is ' ) ;
        PRINTHEX ( CALL_OFFS , 4 ) ;
        WRITELN ;
      end (* PRINT_LNK *) ;


   procedure PRINT_SYSD ( P : ABNDP ; S : PROC_PTR ) ;

      type CODE_AT_PSW = array [ 1 .. 3 ] of VOIDPTR ;

      var I , J , K : INTEGER ;
          TPROCN : PROCNAME ;
          CODE : 0 .. 23 ;
          DUMMYST : FRM_PTR ;
          CALL_OFFS : INTEGER ;
          ISDEBUG : BOOLEAN ;
          SOURCENAME : CHAR8 ;
          ABADDR : INTEGER ;
          ABREG10 : INTEGER ;
          CP : -> CODE_AT_PSW ;

      begin (* PRINT_SYSD *)
        WRITELN ;
        WRITELN ( '**************************************************'
                  ) ;
        WRITELN ( '***   Machine and system related part          ***'
                  ) ;
        WRITELN ( '**************************************************'
                  ) ;
        WRITELN ;
        WRITELN ( '**** Interrupt PSW = ' , P -> . CHKPSW1 , ' ' , P ->
                  . CHKPSW2 ) ;
        WRITELN ( '**** Regs  0 ..  3 = ' , P -> . CHKREGS [ 0 ] , ' '
                  , P -> . CHKREGS [ 1 ] , ' ' , P -> . CHKREGS [ 2 ] ,
                  ' ' , P -> . CHKREGS [ 3 ] ) ;
        WRITELN ( '**** Regs  4 ..  7 = ' , P -> . CHKREGS [ 4 ] , ' '
                  , P -> . CHKREGS [ 5 ] , ' ' , P -> . CHKREGS [ 6 ] ,
                  ' ' , P -> . CHKREGS [ 7 ] ) ;
        WRITELN ( '**** Regs  8 .. 11 = ' , P -> . CHKREGS [ 8 ] , ' '
                  , P -> . CHKREGS [ 9 ] , ' ' , P -> . CHKREGS [ 10 ]
                  , ' ' , P -> . CHKREGS [ 11 ] ) ;
        WRITELN ( '**** Regs 12 .. 15 = ' , P -> . CHKREGS [ 12 ] , ' '
                  , P -> . CHKREGS [ 13 ] , ' ' , P -> . CHKREGS [ 14 ]
                  , ' ' , P -> . CHKREGS [ 15 ] ) ;
        CP := PTRADD ( P -> . CHKINTRP , - 6 ) ;
        WRITELN ( '**** Code at PSW   = ' , CP -> [ 1 ] , ' ' , CP -> [
                  2 ] , ' ' , CP -> [ 3 ] ) ;
        WRITELN ;
        WRITELN ( '**** ENTRY POINT $PASENT AT  : ' , P -> . CHKPASE )
                  ;
        WRITELN ( '**** BOTTOM OF RUNTIME STACK : ' , P -> . CHKREGS [
                  12 ] ) ;
        WRITELN ( '**** CURRENT STACK FRAME     : ' , P -> . CHKREGS [
                  13 ] ) ;
        WRITELN ( '**** CURRENT HEAP POINTER    : ' , P -> . CHKHEAPP )
                  ;
        WRITELN ( '**** POINTER TO TOP OF HEAP  : ' , P -> . CHKHEAPT )
                  ;
        WRITELN ;
        WRITELN ( '**************************************************'
                  ) ;
        WRITELN ( '***   Pascal specific part                     ***'
                  ) ;
        WRITELN ( '**************************************************'
                  ) ;
        WRITELN ;
        ABADDR := PTR2INT ( P -> . CHKINTRP ) ;
        ABREG10 := PTR2INT ( P -> . CHKREGS [ 10 ] ) ;
        with P -> do
          begin
            WRITE ( '**** RUN ERROR: ' , CHKERRC : 4 ) ;
            GET_PROCNAME ( S , I , J , TPROCN , DUMMYST , ISDEBUG ,
                           SOURCENAME ) ;
            CALL_OFFS := ( ABADDR MOD ADDRC ) - ( ABREG10 MOD ADDRC ) ;
            if ISDEBUG then
              WRITE ( '  FROM LINE: ' , GET_FROMLINE ( S , ABADDR MOD
                      ADDRC ) : 1 )
            else
              WRITE ( ' AT LOCATION ' , CALL_OFFS : 1 ) ;
            WRITELN ( '  OF PROCEDURE ' , TPROCN : IDLENGTH ( TPROCN )
                      ) ;
            WRITELN ( '     EPA address of ' , TPROCN : IDLENGTH (
                      TPROCN ) , ' is ' , S ) ;
            WRITE ( '     Error offset is ' ) ;
            PRINTHEX ( CALL_OFFS , 4 ) ;
            WRITELN ;
            WRITELN ;
            WRITE ( '**** ' ) ;
            if CHKERRC < 2000 then
              begin
                CODE := CHKERRC - 1000 ;
                case CODE of
                  1 : WRITE ( 'INDEX VALUE ' ) ;
                  2 : WRITE ( 'SUBRANGE VALUE ' ) ;
                  3 : WRITE ( 'ACTUAL PARAMETER ' ) ;
                  4 : WRITE ( 'SET ELEMENT(S) OUT OF RANGE ' ) ;
                  5 : WRITE ( 'POINTER VALUE ' ) ;
                  6 : WRITELN ( 'STACK/HEAP COLLISION.' ) ;
                  11 : WRITELN ( 'FILE DEFINITION ERROR.' ) ;
                  12 : WRITELN ( 'PROGRAM OUT OF STACK SPACE.' ) ;
                  13 : WRITELN ( 'CALL TO UNDEFINED STANDARD PROC.' ) ;
                  otherwise
                    WRITELN ( CHKMSG -> : CHKMSGL ) ;
                end (* case *) ;
                if ( CODE <= 3 ) or ( CODE = 5 ) then
                  begin
                    if ( CHKCVAL = UNDFINT ) or ( CHKCVAL = UNDFHINT )
                    then
                      WRITELN ( 'IS UNDEFINED.' )
                    else
                      if ( CODE = 5 ) and ( CHKCVAL = - 1 ) then
                        WRITELN ( 'IS NIL.' )
                      else
                        begin
                          WRITELN ( ' IS OUT OF RANGE.' ) ;
                          WRITELN ;
                          WRITELN ( '**** THE OFFENDING VALUE: ' ,
                                    CHKCVAL : 1 ,
                                    ' IS NOT IN THE RANGE: ' , CHKLOWR
                                    : 1 , '..' , CHKUPPR : 1 ) ;
                        end (* else *)
                  end (* then *) ;
              end (* then *)
            else
              if ( CHKERRC < 3000 ) and ( CHKERRC >= 2000 ) then
                begin
                  CODE := CHKERRC - 2000 ;
                  case CODE of
                    1 : WRITE ( 'OPERATION' ) ;
                    2 : WRITE ( 'PRIVILEGED OPERATION' ) ;
                    3 : WRITE ( 'EXECUTE' ) ;
                    4 : WRITE ( 'PROTECTION' ) ;
                    5 : WRITE ( 'ADDRESSING' ) ;
                    6 : WRITE ( 'SPECIFICATION' ) ;
                    7 : WRITE ( 'DATA' ) ;
                    8 : WRITE ( 'FIXED-POINT OVERFLOW' ) ;
                    9 : WRITE ( 'FIXED-POINT DIVIDE' ) ;
                    10 : WRITE ( 'DECIMAL OVERFLOW' ) ;
                    11 : WRITE ( 'DECIMAL DIVIDE' ) ;
                    12 : WRITE ( 'EXPONENT OVERFLOW' ) ;
                    13 : WRITE ( 'EXPONENT UNDERFLOW' ) ;
                    14 : WRITE ( 'SIGNIFICANCE' ) ;
                    15 : WRITE ( 'FLOATING-POINT DIVIDE' ) ;
                  end (* case *) ;
                  WRITELN ( ' EXCEPTION.' ) ;
                end (* then *)
              else
                if CHKERRC = 3001 then
                  WRITELN ( 'EXTERNAL ERROR: ' , CHKMSG -> : CHKMSGL )
                            ;
          end (* with *) ;
      end (* PRINT_SYSD *) ;


   begin (* $PASSNAP *)
     QRD_IS_OPEN := FALSE ;
     for CH := 'A' to 'Z' do
       VARTARY [ CH ] := UNK ;
     VARTARY [ 'A' ] := ARY ;
     VARTARY [ 'B' ] := BOL ;
     VARTARY [ 'C' ] := CHA ;
     VARTARY [ 'D' ] := REC ;
     VARTARY [ 'I' ] := INT ;
     VARTARY [ 'R' ] := RL ;
     VARTARY [ 'P' ] := PTR ;
     VARTARY [ 'S' ] := PSET ;
     VARTARY [ 'L' ] := SCL ;
     VARTARY [ 'F' ] := FIL ;
     VARTARY [ 'X' ] := PAD ;
     HEXCHARS := '0123456789ABCDEF' ;
     PROCSTOCOME := [ ] ;
     NUMPTRS := 0 ;
     LASTPTR := 0 ;
     WRITELN ;
     WRITELN ;
     WRITELN ;
     WRITELN ( '**************************************************' ) ;
     WRITELN ( '***   S N A P S H O T   D U M P                ***' ) ;
     WRITELN ( '**************************************************' ) ;
     WRITELN ;
     WRITE ( '**** SNAPSHOT WAS CALLED BY --> ' ) ;
     if LEVEL < 0 then
       begin
         WRITELN ( 'PASCAL_MONITOR' ) ;
         DMPKIND := 10 ;
         DP := DUMPPTR ;
         WRITELN ;
         WRITELN ( '**** DumpArea provided by PASCAL_MONITOR:' ) ;
         DUMPSTOR ( DUMPPTR , PTRADD ( DUMPPTR , SIZEOF ( DUMPPARM ) -
                    1 ) ) ;

     (*****************************)
     (* SAVED R1 IN RUNTIME STACK *)
     (*****************************)

         TOPSTK := DP -> . CHKREGS [ 1 ] ;

     (******************************)
     (* SAVED R12 IN RUNTIME STACK *)
     (******************************)

         BOTSTK := DP -> . CHKREGS [ 12 ] ;

     (******************************)
     (* SAVED R13 IN RUNTIME STACK *)
     (******************************)

         TMPSTK := DP -> . CHKREGS [ 13 ] ;

     (****************************)
     (* print error information  *)
     (****************************)

         ARRYLSTF := FALSE ;
         PRINT_SYSD ( DP , TMPSTK -> . EPA ) ;
         LEVEL := - 1 ;
         PAR2 := FULL ;
       end (* then *)
     else
       begin

     (******************************************)
     (* $passnap called via snapshot call from *)
     (* normal pascal procedure; 2nd parameter *)
     (* is integer and is casted here from     *)
     (* pointer parameter                      *)
     (******************************************)

         DMPKIND := PTR2INT ( DUMPPTR ) ;

     (******************************************)
     (* this is very tricky; the stack frame   *)
     (* pointers are fetched by array access   *)
     (* using certain negative indexes;        *)
     (* works only, because dmarray is the     *)
     (* very first variable (offset zero)      *)
     (******************************************)

         TOPSTK := DMARRAY [ - 24 ] ;

     (*****************************)
     (* SAVED R1 IN RUNTIME STACK *)
     (*****************************)

         BOTSTK := DMARRAY [ - 13 ] ;

     (******************************)
     (* SAVED R12 IN RUNTIME STACK *)
     (******************************)

         TMPSTK := TOPSTK -> . BAK_LNK ;
         PAR2 := DMPKIND MOD 10 ;
         ARRYLSTF := ( ( DMPKIND DIV 10 ) MOD 10 ) = 1 ;
         GET_PROCNAME ( TMPSTK -> . EPA , UID , PLEN , CPROCN , STATICP
                        , ISDEBUG , SOURCENAME ) ;
         WRITE ( CPROCN : IDLENGTH ( CPROCN ) ) ;
         if ISDEBUG then
           WRITELN ( '  FROM LINE: ' , GET_FROMLINE ( TMPSTK -> . EPA ,
                     TOPSTK -> . RET MOD ADDRC ) : 1 )
         else
           WRITELN ;
       end (* else *) ;
     DEPTH := 1 ;
     if LEVEL = - 1 then
       MAXDEPTH := DEFLEV
     else
       if LEVEL = 0 then
         MAXDEPTH := ADDRC
       else
         MAXDEPTH := LEVEL ;
     if ( PAR2 = FULL ) or ( PAR2 = STKTRACE ) then
       repeat
         DONE := ( TMPSTK = BOTSTK ) or ( DEPTH > MAXDEPTH ) ;
         if PAR2 = FULL then

     (****************************************)
     (* DUMP VARIABLES AS WELL AS CALL TRACE *)
     (****************************************)

           begin
             GET_PROCNAME ( TMPSTK -> . EPA , UID , PLEN , CPROCN ,
                            STATICP , ISDEBUG , SOURCENAME ) ;
             PRINT_VARIABLE ( TMPSTK , STATICP , CPROCN , UID , ISDEBUG
                              , SOURCENAME ) ;
           end (* then *) ;

     (*************)
     (* FULL DUMP *)
     (*************)

         if TMPSTK <> BOTSTK then
           PRINT_LNK ( TMPSTK , TMPSTK -> . BAK_LNK , CPROCN , UID ,
                       PLEN ) ;
         TMPSTK := TMPSTK -> . BAK_LNK ;
         DEPTH := DEPTH + 1 ;
       until DONE ;
     if NUMPTRS = MAXPTRS then
       WRITELN ( '**** NOTE: NOT ALL HEAP STORAGE ITEMS WERE PRINTED.'
                 ) ;
     WRITELN ;
     WRITELN ( '**** END OF SNAPSHOT DUMP ****' ) ;
     WRITELN ;
   end (* $PASSNAP *) ;



begin (* HAUPTPROGRAMM *)

end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTNF   EXT PAS HEX -
program TESTNF ( OUTPUT ) ;


var S1 , S2 , S3 : STRING ( 100 ) ;


begin (* HAUPTPROGRAMM *)
  S1 := 'Bernd Oppolzer' ;
  S2 := LEFT ( S1 , 5 ) ;
  S3 := RIGHT ( S1 , 8 ) ;
  WRITELN ( '<' , S1 , '>' ) ;
  WRITELN ( '<' , S2 , '>' ) ;
  WRITELN ( '<' , S3 , '>' ) ;
  S1 := RIGHT ( S1 , 50 ) ;
  S2 := LEFT ( S2 , 20 ) ;
  S3 := LEFT ( S3 , 4 ) ;
  WRITELN ( '<' , S1 , '>' ) ;
  WRITELN ( '<' , S2 , '>' ) ;
  WRITELN ( '<' , S3 , '>' ) ;
  WRITELN ( 'index     = ' , INDEX ( S1 , 'e' ) ) ;
  WRITELN ( 'lastindex = ' , LASTINDEX ( S1 , 'e' ) ) ;
  WRITELN ( 'index     = ' , INDEX ( S1 , 'er' ) ) ;
  WRITELN ( 'lastindex = ' , LASTINDEX ( S1 , 'er' ) ) ;
  WRITELN ( 'index     = ' , INDEX ( S1 , 'Oppo' ) ) ;
  WRITELN ( 'lastindex = ' , LASTINDEX ( S1 , 'Oppo' ) ) ;
  WRITELN ( 'index     = ' , INDEX ( S1 , '     Bernd' ) ) ;
  WRITELN ( 'lastindex = ' , LASTINDEX ( S1 , '     Bernd' ) ) ;
  WRITELN ( 'index     = ' , INDEX ( S2 , 'Bernd' ) ) ;
  WRITELN ( 'lastindex = ' , LASTINDEX ( S2 , 'Bernd' ) ) ;
  WRITELN ( 'index     = ' , INDEX ( S1 , '          ' ) ) ;
  WRITELN ( 'lastindex = ' , LASTINDEX ( S1 , '          ' ) ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTP3   EXT PAS HEX -
PROGRAM PASC_P3;

//$A+

         VAR N, I1, I2 : INTEGER;
         VAR S1,EOF    : STRING(25);
         DESCRIPTION   : ARRAY[1..25] OF STRING(25);

        BEGIN

         WRITELN (' ');
         WRITELN ('STEP-0 POPULATE ARRAY');
         WRITELN ('STEP-0 POPULATE ARRAY');

         DESCRIPTION[01] := 'WIDGET-BLUE              ';
         DESCRIPTION[02] := 'WIDGET-YELLOW            ';
         DESCRIPTION[03] := 'WIDGET-GREEN             ';
         DESCRIPTION[04] := 'WIDGET-PURPLE-N-GOLD     ';
         DESCRIPTION[05] := 'WIDGET-BLUE              ';
         DESCRIPTION[06] := 'WIDGET-ORANGE            ';
         DESCRIPTION[07] := 'WIDGET-FANCY-RED         ';
         DESCRIPTION[08] := 'WIDGET-FANCY-GREEN       ';
         DESCRIPTION[09] := 'WIDGET-FANCY-YELLOW      ';
         DESCRIPTION[10] := 'WIDGET-FANCY-ORANGE      ';
         DESCRIPTION[11] := 'WIDGET-BLUE-WITH-SPARKLES';
         DESCRIPTION[12] := 'WIDGET-RED-WITH-SPARKLES ';
         DESCRIPTION[13] := 'WIDGET-BLACK-CHERRY      ';
         DESCRIPTION[14] := 'WIDGET-RED-N-GREEN       ';
         DESCRIPTION[15] := 'WIDGET-LIGHTED-CLEAR     ';
         DESCRIPTION[16] := 'ENDOFFILE                ';
         DESCRIPTION[17] := 'RECORD 17                ';
         DESCRIPTION[18] := 'RECORD 18                ';
         DESCRIPTION[19] := 'RECORD 19                ';

         WRITELN (' ');
         WRITELN('STEP-1 STRING TESTS');
         WRITELN('STEP-1 STRING TESTS');

 {01}    WRITELN (' ');
         I1      := LENGTH(DESCRIPTION[16]);
         WRITELN('STEP-1-01 LENGTH(DESCRIPTION[16])==>',I1);

 {02}    N  := 16;
         I1      := LENGTH(DESCRIPTION[N]);
         WRITELN('STEP-1-02 LENGTH(DESCRIPTION[N]) ==>',I1);

 {03}    WRITELN (' ');
         S1 := SUBSTR(DESCRIPTION[16],1,9);
         WRITELN('STEP-1-03 SUBSTR(DESCRIPTION[16],1,9) ==>',
                            S1,'<==');

 {04}    WRITELN (' ');
         N  := 16;
         S1 := SUBSTR(DESCRIPTION[N],1,9);
         WRITELN('STEP-1-04 SUBSTR(DESCRIPTION[N],1,9) ==>',
                            S1,'<==');

 {05}    WRITELN (' ');
         S1 := DESCRIPTION[16];
         WRITELN('STEP-1-05 DESCRIPTION[16]) ==>', S1,'<==');

 {06}    WRITELN (' ');
         N  := 16;
         S1 := DESCRIPTION[N];
         WRITELN('STEP-1-06 DESCRIPTION[N])  ==>', S1,'<==');

         END.
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTP4   EXT PAS HEX -
program PASC_P4 ;

//**********************************************************************
//$A+
//**********************************************************************



var N , I1 , I2 : INTEGER ;


var S1 , EOF : STRING ( 25 ) ;
    DESCRIPTION : array [ 1 .. 25 ] of CHAR ( 25 ) ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( ' ' ) ;
  WRITELN ( 'STEP-0 POPULATE ARRAY' ) ;
  WRITELN ( 'STEP-0 POPULATE ARRAY' ) ;
  DESCRIPTION [ 01 ] := 'WIDGET-BLUE              ' ;
  DESCRIPTION [ 02 ] := 'WIDGET-YELLOW            ' ;
  DESCRIPTION [ 03 ] := 'WIDGET-GREEN             ' ;
  DESCRIPTION [ 04 ] := 'WIDGET-PURPLE-N-GOLD     ' ;
  DESCRIPTION [ 05 ] := 'WIDGET-BLUE              ' ;
  DESCRIPTION [ 06 ] := 'WIDGET-ORANGE            ' ;
  DESCRIPTION [ 07 ] := 'WIDGET-FANCY-RED         ' ;
  DESCRIPTION [ 08 ] := 'WIDGET-FANCY-GREEN       ' ;
  DESCRIPTION [ 09 ] := 'WIDGET-FANCY-YELLOW      ' ;
  DESCRIPTION [ 10 ] := 'WIDGET-FANCY-ORANGE      ' ;
  DESCRIPTION [ 11 ] := 'WIDGET-BLUE-WITH-SPARKLES' ;
  DESCRIPTION [ 12 ] := 'WIDGET-RED-WITH-SPARKLES ' ;
  DESCRIPTION [ 13 ] := 'WIDGET-BLACK-CHERRY      ' ;
  DESCRIPTION [ 14 ] := 'WIDGET-RED-N-GREEN       ' ;
  DESCRIPTION [ 15 ] := 'WIDGET-LIGHTED-CLEAR     ' ;
  DESCRIPTION [ 16 ] := 'ENDOFFILE                ' ;
  DESCRIPTION [ 17 ] := 'RECORD 17                ' ;
  DESCRIPTION [ 18 ] := 'RECORD 18                ' ;
  DESCRIPTION [ 19 ] := 'RECORD 19                ' ;
  WRITELN ( ' ' ) ;
  WRITELN ( 'STEP-1 STRING TESTS' ) ;
  WRITELN ( 'STEP-1 STRING TESTS' ) ;

  (******************************************************************)
  (* testcase 01                                                    *)
  (******************************************************************)

  WRITELN ( ' ' ) ;
  I1 := LENGTH ( DESCRIPTION [ 16 ] ) ;
  WRITELN ( 'STEP-1-01 LENGTH(DESCRIPTION[16])==>' , I1 ) ;

  (******************************************************************)
  (* testcase 02                                                    *)
  (******************************************************************)

  N := 16 ;
  I1 := LENGTH ( DESCRIPTION [ N ] ) ;
  WRITELN ( 'STEP-1-02 LENGTH(DESCRIPTION[N]) ==>' , I1 ) ;

  (******************************************************************)
  (* testcase 03                                                    *)
  (******************************************************************)

  WRITELN ( ' ' ) ;
  S1 := SUBSTR ( DESCRIPTION [ 16 ] , 1 , 9 ) ;
  WRITELN ( 'STEP-1-03 SUBSTR(DESCRIPTION[16],1,9) ==>' , S1 , '<==' )
            ;

  (******************************************************************)
  (* testcase 04                                                    *)
  (******************************************************************)

  WRITELN ( ' ' ) ;
  N := 16 ;
  S1 := SUBSTR ( DESCRIPTION [ N ] , 1 , 9 ) ;
  WRITELN ( 'STEP-1-04 SUBSTR(DESCRIPTION[N],1,9) ==>' , S1 , '<==' ) ;

  (******************************************************************)
  (* testcase 05                                                    *)
  (******************************************************************)

  WRITELN ( ' ' ) ;
  S1 := STR ( DESCRIPTION [ 16 ] ) ;
  WRITELN ( 'STEP-1-05 DESCRIPTION[16]) ==>' , S1 , '<==' ) ;

  (******************************************************************)
  (* testcase 06                                                    *)
  (******************************************************************)

  WRITELN ( ' ' ) ;
  N := 16 ;
  S1 := STR ( DESCRIPTION [ N ] ) ;
  WRITELN ( 'STEP-1-06 DESCRIPTION[N])  ==>' , S1 , '<==' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTP5   EXT PAS HEX -
program TESTP5 ( OUTPUT ) ;

//**********************************************************************
//$A+
//**********************************************************************



var N : INTEGER ;
    X : STRING ( 25 ) ;


const DESC_CONST : array [ 1 .. 25 ] of STRING ( 25 ) =
      ( 'WIDGET-BLUE' , 'WIDGET-YELLOW' , 'WIDGET-GREEN' ,
        'WIDGET-PURPLE-N-GOLD' , 'WIDGET-BLUE' , 'WIDGET-ORANGE' ,
        'WIDGET-FANCY-RED' , 'WIDGET-FANCY-GREEN' ,
        'WIDGET-FANCY-YELLOW' , 'WIDGET-FANCY-ORANGE' ,
        'WIDGET-BLUE-WITH-SPARKLES' , 'WIDGET-RED-WITH-SPARKLES' ,
        'WIDGET-BLACK-CHERRY' , 'WIDGET-RED-N-GREEN' ,
        'WIDGET-LIGHTED-CLEAR' , 'ENDOFFILE' , 'RECORD 17' ,
        'RECORD 18' , 'RECORD 19' , 'RECORD 20' , 'RECORD 21' ,
        'RECORD 22' , 'RECORD 23' , 'RECORD 24' , 'RECORD 25' ) ;
      XCONST : STRING ( 25 ) = 'CONST1' ;
      ACONST : array [ 1 .. 2 ] of STRING ( 25 ) =
      ( 'C1' , 'C2' ) ;


begin (* HAUPTPROGRAMM *)
  X := 'Oppolzer' ;
  WRITELN ( X ) ;
  WRITELN ( XCONST ) ;
  WRITELN ( ACONST [ 1 ] ) ;
  if XCONST = 'ENDOF' then
    WRITELN ( 'XCONST = ''ENDOFFILE''' ) ;
  if ACONST [ 1 ] = 'ENDOFFILE' then
    WRITELN ( 'ACONST / 1 = ''ENDOFFILE''' ) ;
  WRITELN ( 'where is the string ''ENDOFFILE''?' ) ;
  for N := 1 to 25 do
    begin
      WRITELN ( N , ': ' , DESC_CONST [ N ] ) ;
      if DESC_CONST [ N ] = 'ENDOFFILE' then
        WRITELN ( 'string ''ENDOFFILE'' found at position ' , N ) ;
    end (* for *) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTP6   EXT PAS HEX -
program PASC_P4 ;


var N : INTEGER ;


begin (* HAUPTPROGRAMM *)
  TERMIN ( INPUT ) ;
  WRITELN ( ' ' ) ;
  WRITELN ( 'ENTER AN INTEGER' ) ;
  READLN ( N ) ;
  WRITELN ( 'YOU ENTERED ' , N ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTP7   EXT PAS HEX -
PROGRAM PASC_P30;
         {$A+ }
         VAR C1 : CHAR(25);
         VAR C2 : CHAR(44);
         VAR N  : INTEGER;
         VAR I1 : INTEGER;
         VAR I2 : INTEGER;
         VAR R1 : REAL;
         VAR S1 : STRING(09);
         VAR S2 : STRING(25);
         VAR EOF : STRING(09);
         VAR DESCRIPTION : ARRAY[1..25] OF STRING(25);
         VAR WIDGETI : TEXT;
         VAR BUFFER  : CHAR(80);

        BEGIN
         { }
         WRITELN (' ');
         WRITELN ('STEP-1 POPULATE ARRAY');
         WRITELN ('STEP-1 POPULATE ARRAY');
         { }
         DESCRIPTION[01] := 'WIDGET-BLUE';
         DESCRIPTION[02] := 'WIDGET-YELLOW';
         DESCRIPTION[03] := 'WIDGET-GREEN';
         DESCRIPTION[04] := 'WIDGET-PURPLE-N-GOLD';
         DESCRIPTION[05] := 'WIDGET-BLUE';
         DESCRIPTION[06] := 'WIDGET-ORANGE';
         DESCRIPTION[07] := 'WIDGET-FANCY-RED';
         DESCRIPTION[08] := 'WIDGET-FANCY-GREEN';
         DESCRIPTION[09] := 'WIDGET-FANCY-YELLOW';
         DESCRIPTION[10] := 'WIDGET-FANCY-ORANGE';
         DESCRIPTION[11] := 'WIDGET-BLUE-WITH-SPARKLES';
         DESCRIPTION[12] := 'WIDGET-RED-WITH-SPARKLES';
         DESCRIPTION[13] := 'WIDGET-BLACK-CHERRY';
         DESCRIPTION[14] := 'WIDGET-RED-N-GREEN';
         DESCRIPTION[15] := 'WIDGET-LIGHTED-CLEAR';
         DESCRIPTION[16] := 'ENDOFFILE';
         { }
         WRITELN(' ');
         WRITELN ('STEP-2 TEST STRINGS');
         WRITELN ('STEP-2 TEST STRINGS');
         WRITELN(' ');
         { }
         EOF     := 'ENDOFFILE';
         S1      := 'ENDOFFILE';
         I1      := LENGTH(EOF);
         I2      := LENGTH(S1);
         WRITELN ('STEP 2 -- EOF  ==>',EOF , '<==');
         WRITELN ('STEP 2 -- S1   ==>',S1  , '<==');
         WRITELN ('STEP 2 -- THE LENGTH OF EOF  IS ', I1);
         WRITELN ('STEP 2 -- THE LENGTH OF S1   IS ', I2);
         { }
         WRITELN(' ');
         IF   EOF  = S1 THEN WRITELN ('STEP2 -- EOF  IS EQUAL TO S1');
         { }
         WRITELN(' ');
         WRITELN ('STEP-3 TEST ARRAY');
         WRITELN ('STEP-3 TEST ARRAY');
         WRITELN(' ');
         FOR I1 := 1 TO 16 DO
             BEGIN
             R1 := I1;
             S2 := DESCRIPTION[I1];
             S1 := SUBSTR(S2,1,9);
             WRITELN ('STEP-3-01 DESCRIPTION[',R1:2:0,'] ==>',
                       DESCRIPTION[I1],'<==');
             WRITELN ('STEP-3-02 SUBSTRING       ==>',
                       S1,'<==');
             IF S1  = EOF THEN
                WRITELN ('STEP-3-03 S1 IS EQUAL TO EOF');
             END;

         WRITELN (' ');
         WRITELN ('STEP-4 READLN TEST');
         WRITELN ('STEP-4 READLN TEST');
         WRITELN (' ');
         RESET (WIDGETI);
         READLN (WIDGETI,BUFFER);
         S1  :=  SUBSTR(BUFFER,13,9);
         WRITELN ('STEP-4-01 COLS   ==>0000000001111111111222222<==');
         WRITELN ('STEP-4-01 COLS   ==>1234567890123456789012345<==');
         WRITELN ('STEP-4-01 BUFFER ==>', BUFFER,'<==');
         WRITELN ('STEP-4-02 SUBSTR(BUFFER,13,9)==>', S1,'<==');
         CLOSE (WIDGETI);

         WRITELN (' ');
         WRITELN ('STEP-5 READ   TEST');
         WRITELN ('STEP-5 READ   TEST');
         WRITELN (' ');
         RESET (WIDGETI);
         READ  (WIDGETI,I1,R1,C1,C2);
         WRITELN ('STEP-5-01  I1    ==>', I1,'<==');
         WRITELN ('STEP-5-02  R1    ==>', R1,'<==');
         WRITELN ('STEP-5-03  C1    ==>', C1,'<==');
         WRITELN ('STEP-5-04  C2    ==>', C2,'<==');
         WRITELN (' ');
         S1   := SUBSTR(C1,1,9);
         WRITELN ('STEP-5-05  COLS          ==>000000000111111<==');
         WRITELN ('STEP-5-05  COLS          ==>123456789012345<==');
         WRITELN ('STEP-5-05  CI            ==>', C1,'<==');
         WRITELN ('STEP-5-06 SUBSTR(C1,1,9) ==>', S1,'<==');

         CLOSE (WIDGETI);

         WRITELN (' ');
         WRITELN (' ');
         WRITELN ('EOJ');
         { }
         END.


++FILE PASCALN.TESTPGM.PAS                          MEMB TESTPDS  EXT PAS HEX -
program TESTPDS ( INPUT , OUTPUT , PDS , PDSOUT ) ;


type CHAR8 = array [ 1 .. 8 ] of CHAR ;
     CHAR80 = array [ 1 .. 80 ] of CHAR ;


var PDS : TEXT ;
    PDSOUT : TEXT ;
    MEMBERNAME : CHAR8 ;
    ZEILE : CHAR80 ;



procedure TESTREAD ;

   begin (* TESTREAD *)
     RESET ( PDS ) ;
     WRITELN ( ' ' , 'nach reset' ) ;
     WRITELN ( ' ' , 'nach reset' ) ;
     WRITELN ( ' ' , 'nach reset' ) ;
     repeat
       WRITELN ( ' ' , 'vor readln' ) ;
       READLN ( PDS , ZEILE ) ;
       WRITELN ( ' ' , 'nach readln' ) ;
       WRITELN ( ' ' , ZEILE )
     until EOF ( PDS ) ;
   end (* TESTREAD *) ;



procedure TESTWRITE ;

   begin (* TESTWRITE *)
     RESET ( PDS ) ;
     REWRITE ( PDSOUT ) ;
     repeat
       READLN ( PDS , ZEILE ) ;
       WRITELN ( PDSOUT , ZEILE ) ;
     until EOF ( PDS ) ;
   end (* TESTWRITE *) ;



begin (* HAUPTPROGRAMM *)
  MEMBERNAME := 'KALENDER' ;
  WRITELN ( ' ' , 'vor assignmem' ) ;
  ASSIGNMEM ( PDS , ADDR ( MEMBERNAME ) , 8 ) ;
  WRITELN ( ' ' , 'nach assignmem' ) ;
  TESTREAD ;
  WRITELN ( ' ' , 'vor assignmem' ) ;
  ASSIGNMEM ( PDS , ADDR ( MEMBERNAME ) , 8 ) ;
  ASSIGNMEM ( PDSOUT , ADDR ( MEMBERNAME ) , 8 ) ;
  WRITELN ( ' ' , 'nach assignmem' ) ;
  TESTWRITE ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTPP   EXT PAS HEX -
program TESTREAD ( INPUTFILE , OUTPUT ) ;

//*******************************************
// korrekt nach Modifikation RDS und RDV
// EOLN wird korrekt signalisiert
// kein READLN nach EOLN noetig
// Ergebnis von READ (RDS und RDV)
// nach EOF nicht mehr verwenden
//*******************************************



var INPUTFILE : TEXT ;
    CH10 : CHAR ( 10 ) ;
    S10 : STRING ( 10 ) ;


begin (* HAUPTPROGRAMM *)
  WRITELN ;
  WRITELN ( 'lesen string (10)' ) ;
  WRITELN ;
  RESET ( INPUTFILE ) ;
  READ ( INPUTFILE , S10 ) ;
  while not EOF ( INPUTFILE ) do
    begin
      WRITELN ( 'gelesen: <' , S10 , '> eoln = ' , EOLN ( INPUTFILE ) )
                ;
      READ ( INPUTFILE , S10 ) ;
    end (* while *) ;
  WRITELN ;
  WRITELN ( 'lesen char (10)' ) ;
  WRITELN ;
  RESET ( INPUTFILE ) ;
  READ ( INPUTFILE , CH10 ) ;
  while not EOF ( INPUTFILE ) do
    begin
      WRITELN ( 'gelesen: <' , CH10 , '> eoln = ' , EOLN ( INPUTFILE )
                ) ;
      READ ( INPUTFILE , CH10 ) ;
    end (* while *) ;
  WRITELN ;
  WRITELN ( 'lesen char (10)' ) ;
  WRITELN ;
  RESET ( INPUTFILE ) ;
  READ ( INPUTFILE , CH10 ) ;
  while not EOF ( INPUTFILE ) do
    begin
      WRITELN ( 'gelesen: <' , CH10 , '> eoln = ' , EOLN ( INPUTFILE )
                ) ;
      READ ( INPUTFILE , CH10 ) ;
    end (* while *) ;
  WRITELN ;
  WRITELN ( 'lesen string (10)' ) ;
  WRITELN ;
  RESET ( INPUTFILE ) ;
  READ ( INPUTFILE , S10 ) ;
  while not EOF ( INPUTFILE ) do
    begin
      WRITELN ( 'gelesen: <' , S10 , '> eoln = ' , EOLN ( INPUTFILE ) )
                ;
      READ ( INPUTFILE , S10 ) ;
    end (* while *) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTPTR  EXT PAS HEX -
program TESTPTR ( OUTPUT ) ;

//**********************************************************************
//$A+
//**********************************************************************



type CHAINPTR = -> CHAIN ;
     CHAIN = record
               N : INTEGER ;
               NEXT : CHAINPTR ;
             end ;


var K : CHAINPTR ;
    KSTART : CHAINPTR ;



procedure PRINT ( X : CHAINPTR ) ;

   begin (* PRINT *)
     while X <> NIL do
       begin
         WRITELN ( X -> . N ) ;
         X := X -> . NEXT
       end (* while *)
   end (* PRINT *) ;



begin (* HAUPTPROGRAMM *)
  NEW ( K ) ;
  KSTART := K ;
  K -> . N := 1 ;
  NEW ( K -> . NEXT ) ;
  K := K -> . NEXT ;
  K -> . N := 2 ;
  NEW ( K -> . NEXT ) ;
  K := K -> . NEXT ;
  K -> . N := 3 ;
  K -> . NEXT := NIL ;
  PRINT ( KSTART ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTPTR2 EXT PAS HEX -
program TESTPTR ( OUTPUT ) ;

//**********************************************************************
//$A+
//**********************************************************************



type CFORW = record
               SOMEV : INTEGER ;
               C : -> CHAIN ;
             end ;
     CHAIN = record
               N : INTEGER ;
               NEXT : -> CHAIN ;
             end ;


var K : -> CHAIN ;
    X : CFORW ;



procedure PRINT ( X : -> CHAIN ) ;

   begin (* PRINT *)
     while X <> NIL do
       begin
         WRITELN ( X -> . N ) ;
         X := X -> . NEXT
       end (* while *)
   end (* PRINT *) ;



begin (* HAUPTPROGRAMM *)
  NEW ( K ) ;
  X . C := K ;
  K -> . N := 1 ;
  NEW ( K -> . NEXT ) ;
  K := K -> . NEXT ;
  K -> . N := 2 ;
  NEW ( K -> . NEXT ) ;
  K := K -> . NEXT ;
  K -> . N := 3 ;
  K -> . NEXT := NIL ;
  PRINT ( X . C ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRDB  EXT PAS HEX -
program TESTRDB ( INPUT , OUTPUT ) ;


type WIDTH = 0 .. 9 ;


var B : BOOLEAN ;
    B1 : BOOLEAN ;
    B2 : BOOLEAN ;
    W : WIDTH ;
    S : STRING ( 200 ) ;



procedure TERMIN ( var X : TEXT ) ;

   EXTERNAL ;



begin (* HAUPTPROGRAMM *)
  TERMIN ( INPUT ) ;
  B := TRUE ;
  WRITELN ( '-' , B : 10 , '-' , not B : 10 , '-' ) ;
  WRITELN ( '-' , B , '-' , not B , '-' ) ;
  WRITELN ( '-' , B : 3 , '-' , not B : 3 , '-' ) ;
  WRITELN ( '-' , B : 1 , '-' , not B : 1 , '-' ) ;
  repeat
    WRITELN ( 'bitte zweimal Boolean eingeben: ' ) ;
    READLN ( B1 , B2 ) ;
    WRITELN ( '-' , B1 : 1 , '-' , B2 : 1 , '-' ) ;
    WRITELN ( 'bitte zweimal Boolean in Laenge 6 eingeben: ' ) ;
    READLN ( B1 : 6 , B2 : 6 ) ;
    WRITELN ( '-' , B1 : 1 , '-' , B2 : 1 , '-' ) ;
    WRITELN ( 'bitte String eingeben fuer READSTR Boolean Laenge 6' ) ;
    READLN ( S ) ;
    READSTR ( S , B : 6 ) ;
    WRITELN ( '-' , B : 1 , '-' ) ;
    WRITELN ( 'bitte Eingabelaenge eingeben (0..9) ... Ende mit 0:' ) ;
    READLN ( W ) ;
    WRITELN ( 'bitte Boolean in Laenge ' , W : 1 , ' eingeben:' ) ;
    READLN ( B : W ) ;
    WRITELN ( '-' , B : 1 , '-' ) ;
    if W <> 0 then
      WRITELN ( 'nochmal von vorne' ) ;
  until W = 0
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRDC  EXT PAS HEX -
program TESTRDC ( INPFILE , OUTPUT ) ;

//*******************************************
// Testen RDC
//$A+
//*******************************************



var INPFILE : TEXT ;
    CH : CHAR ;
    COLS : INTEGER ;


begin (* HAUPTPROGRAMM *)
  WRITELN ;
  WRITELN ( 'lesen mit dauernd read' ) ;
  WRITELN ;
  RESET ( INPFILE ) ;
  READ ( INPFILE , CH ) ;
  while not EOF ( INPFILE ) do
    begin
      WRITELN ( 'gelesen: ' , CH , ORD ( CH ) : 4 , ' file char: ' ,
                INPFILE -> , ORD ( INPFILE -> ) : 4 , ' eof = ' , EOF (
                INPFILE ) , ' eoln = ' , EOLN ( INPFILE ) ) ;
      READ ( INPFILE , CH ) ;
    end (* while *) ;
  WRITELN ;
  WRITELN ( 'lesen mit read und readln' ) ;
  WRITELN ;
  RESET ( INPFILE ) ;
  while TRUE do
    begin
      if EOF ( INPFILE ) then
        break ;
      if EOLN ( INPFILE ) then
        begin
          READLN ( INPFILE ) ;
          WRITELN ( '--------------------------------------------' ) ;
          continue ;
        end (* then *) ;
      READ ( INPFILE , CH ) ;
      WRITELN ( 'gelesen: ' , CH , ORD ( CH ) : 4 , ' eof = ' , EOF (
                INPFILE ) , ' eoln = ' , EOLN ( INPFILE ) ) ;
    end (* while *) ;
  WRITELN ;
  WRITELN ( 'lesen mit read und readln - max 10 cols' ) ;
  WRITELN ;
  RESET ( INPFILE ) ;
  COLS := 0 ;
  while TRUE do
    begin
      if EOF ( INPFILE ) then
        break ;
      if EOLN ( INPFILE ) or ( COLS >= 10 ) then
        begin
          READLN ( INPFILE ) ;
          WRITELN ( '--------------------------------------------' ) ;
          COLS := 0 ;
          continue
        end (* then *) ;
      READ ( INPFILE , CH ) ;
      WRITELN ( 'gelesen: ' , CH , ORD ( CH ) : 4 , ' eof = ' , EOF (
                INPFILE ) , ' eoln = ' , EOLN ( INPFILE ) ) ;
      COLS := COLS + 1 ;
    end (* while *) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRDC2 EXT PAS HEX -
program TESTRDC2 ( INPFILE , OUTPUT ) ;

//*******************************************
// Testen RDC
//$A+
//*******************************************



var INPFILE : TEXT ;
    CH : CHAR ;
    COLS : INTEGER ;
    DONE : BOOLEAN ;
    C10 : CHAR ( 10 ) ;
    S10 : STRING ( 10 ) ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( 'input lines until line contains $' ) ;
  TERMIN ( INPFILE ) ;
  DONE := FALSE ;
  repeat
    for COLS := 1 to 10 do
      begin
        READ ( INPFILE , CH ) ;
        WRITELN ( 'found: ' , CH , ORD ( CH ) : 4 , ' eof = ' , EOF (
                  INPFILE ) , ' eoln = ' , EOLN ( INPFILE ) ) ;
        if CH = '$' then
          DONE := TRUE
      end (* for *) ;
    READLN ( INPFILE ) ;
  until DONE ;
  WRITELN ( 'input fixed char strings until line contains $' ) ;
  DONE := FALSE ;
  repeat
    READLN ( INPFILE , C10 ) ;
    WRITELN ( 'found: ' , LENGTH ( C10 ) : 4 , ' <' , C10 , '>' ) ;
    DONE := INDEX ( C10 , '$' ) <> 0 ;
  until DONE ;
  WRITELN ( 'input strings until line contains $' ) ;
  DONE := FALSE ;
  repeat
    READLN ( INPFILE , S10 ) ;
    WRITELN ( 'found: ' , LENGTH ( S10 ) : 4 , ' <' , S10 , '>' ) ;
    DONE := INDEX ( S10 , '$' ) <> 0 ;
  until DONE ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRDC3 EXT PAS HEX -
program TESTRDC3 ( SRCFIL , OUTPUT ) ;


label 99 ;


var SRCFIL : TEXT ;
    LINE : array [ 1 .. 250 ] of CHAR ;
    CC , LL : INTEGER ;
    CH : CHAR ;
    LC : INTEGER ;



procedure NEXTCH2 ;

(*****************************************)
(* read next character; process line end *)
(*****************************************)


   begin (* NEXTCH2 *)
     READ ( SRCFIL , CH ) ;
     WRITELN ( 'char = ' , CH , ' eoln = ' , EOLN ( SRCFIL ) ) ;
   end (* NEXTCH2 *) ;



procedure NEXTCH ;

(*****************************************)
(* read next character; process line end *)
(*****************************************)


   begin (* NEXTCH *)
     WRITELN ( 'at the beginning cc and ll: ' , CC , LL ) ;
     if CC = LL then
       begin
         if EOF ( SRCFIL )  (*[sam]*) then
           begin
             WRITELN ;
             WRITELN ( ' program incomplete' ) ;
             goto 99
           end (* then *) ;
         LC := LC + 1 ;
         WRITE ( LC : 5 , '  ' ) ;
         LL := 0 ;
         CC := 0 ;
         while not EOLN ( SRCFIL )  (*[sam]*) do
           begin
             LL := LL + 1 ;
             READ ( SRCFIL  (*[sam]*) , CH ) ;
             WRITE ( CH ) ;
             LINE [ LL ] := CH
           end (* while *) ;
         WRITELN ;
         LL := LL + 1 ;
         READ ( SRCFIL  (*[sam]*) , LINE [ LL ] ) ;
         WRITELN ( 'test line: <' , SUBSTR ( LINE , 1 , LL ) , '>' ) ;
       end (* then *) ;
     CC := CC + 1 ;
     CH := LINE [ CC ] ;
     WRITELN ( 'test char returned: <' , CH , '>' ) ;
   end (* NEXTCH *) ;



begin (* HAUPTPROGRAMM *)
  RESET ( SRCFIL ) ;
  CC := 0 ;
  LL := 0 ;
  LC := 0 ;
  repeat
    NEXTCH2
  until EOF ( SRCFIL ) ;
  99 :

end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRDD  EXT PAS HEX -
program TESTRDD ( INPFILE , OUTPUT ) ;


type BYTE = record
              CONT : CHAR
            end ;


var INPFILE : FILE of BYTE ;
    B : BYTE ;
    CH : CHAR ;


begin (* HAUPTPROGRAMM *)
  RESET ( INPFILE ) ;
  while not EOF ( INPFILE ) do
    begin
      READ ( INPFILE , B ) ;
      CH := B . CONT ;
      WRITE ( 'gelesen: ' ) ;
      if ORD ( CH ) > ORD ( ' ' ) then
        WRITE ( CH )
      else
        WRITE ( ' ' ) ;
      WRITE ( ORD ( CH ) : 4 ) ;
      CH := INPFILE -> . CONT ;
      WRITELN ( ORD ( CH ) : 4 ) ;
    end (* while *) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRDI  EXT PAS HEX -
program TESTRDI ( INPUT , OUTPUT ) ;

//**********************************************************
// Offene Punkte:
// * wieso falsche Anzahl Parms bei Aufruf $PASRDI ?
// * Testen lt. Beispielen aus Pascal/VS Handbuch
// * erweitern Pascal-Loesung auf FKT. RDH und RDY
// * CHK Anweisungen reinkompilieren nach RDH und RDY
// * Uebertragen nach CMS
// * evtl. Problem mit GET (muss RLN ausloesen)
// * anstelle von EXIT-Funktion Run-Time-Error (CHK?)
// * Run-Time-Error auf Mainframe anders aufbereiten
// * PASSNAP an PASSNAPC angleichen
// * auch Aufbereitung aendern, wenn SNAP ausgeschaltet ist
// * weiter: andere READ-Funktionen
// - Read BOOLEAN
// - Read SKALAR
//**********************************************************
//$X+
//**********************************************************



type BYTE = packed record
                     CONT : 0 .. 100 ;
                   end ;


var I : INTEGER ;
    X : INTEGER ;
    ENDE : BOOLEAN ;
    IFILE : TEXT ;
    J : INTEGER ;
    S : STRING ( 100 ) ;
    CC : CHAR ( 10 ) ;
    Y : BYTE ;
    CH : CHAR ;
    H : 0 .. 20000 ;



function $PASRDI ( var F : TEXT ; WIDTH : INTEGER ) : INTEGER ;

   EXTERNAL ;



begin (* HAUPTPROGRAMM *)
  REWRITE ( IFILE ) ;
  for I := 1 to 100 do
    begin
      WRITE ( IFILE , I * I * I : 8 ) ;
      if I MOD 5 = 0 then
        WRITELN ( IFILE )
    end (* for *) ;
  WRITELN ( 'reading from ifile using read' ) ;
  RESET ( IFILE ) ;
  for X := 1 to 100 do
    begin
      READ ( IFILE , I ) ;
      WRITE ( I : 8 ) ;
      if X MOD 10 = 0 then
        WRITELN ;
    end (* for *) ;
  WRITELN ( 'reading from ifile using new read function' ) ;
  RESET ( IFILE ) ;
  for X := 1 to 100 do
    begin
      I := $PASRDI ( IFILE , - 1 ) ;
      WRITE ( I : 8 ) ;
      if X MOD 10 = 0 then
        WRITELN ;
    end (* for *) ;
  WRITELN ( 'reading from ifile using width = 4' ) ;
  RESET ( IFILE ) ;
  for X := 1 to 200 do
    begin
      I := $PASRDI ( IFILE , 4 ) ;
      WRITE ( I : 8 ) ;
      if X MOD 10 = 0 then
        WRITELN ;
    end (* for *) ;
  WRITELN ( 'reading from ifile using width = 3' ) ;
  RESET ( IFILE ) ;
  for X := 1 to 200 do
    begin
      I := $PASRDI ( IFILE , 3 ) ;
      WRITE ( I : 8 ) ;
      if X MOD 10 = 0 then
        WRITELN ;
    end (* for *) ;

  //**************************************
  // Tests read example
  // from Pascal VS manual
  //**************************************

  WRITELN ( 'tests read example from Pascal/VS manual' ) ;
  REWRITE ( IFILE ) ;
  WRITELN ( IFILE , '36 24 ABCDEFGHIJKLMNOPQRSTUVWXYZ' ) ;
  RESET ( IFILE ) ;
  READLN ( IFILE , I , J , CH , CC , S ) ;
  WRITELN ( 'i          = ' , I ) ;
  WRITELN ( 'j          = ' , J ) ;
  WRITELN ( 'ch         = ' , CH ) ;
  WRITELN ( 'cc         = ' , CC ) ;
  WRITELN ( 's          = ' , S ) ;
  WRITELN ( 'length (s) = ' , LENGTH ( S ) ) ;

  //**************************************
  // Tests formatted read example
  // from Pascal VS manual
  //**************************************

  WRITELN ( 'tests formatted read example from Pascal/VS manual' ) ;
  REWRITE ( IFILE ) ;
  WRITELN ( IFILE , '36 24 ABCDEFGHIJKLMNOPQRSTUVWXYZ' ) ;
  RESET ( IFILE ) ;
  READLN ( IFILE , I : 4 , J : 10 , CH : J , CC , S ) ;
  WRITELN ( 'i          = ' , I ) ;
  WRITELN ( 'j          = ' , J ) ;
  WRITELN ( 'ch         = ' , CH ) ;
  WRITELN ( 'cc         = ' , CC ) ;
  WRITELN ( 's          = ' , S ) ;
  WRITELN ( 'length (s) = ' , LENGTH ( S ) ) ;

  //**************************************
  // Tests formatted read example
  // from Pascal VS manual
  //**************************************

  WRITELN ( 'tests integer reads with subranges (shorter length)' ) ;
  REWRITE ( IFILE ) ;
  WRITELN ( IFILE , '47110971234' ) ;
  RESET ( IFILE ) ;
  READLN ( IFILE , H : 4 , Y . CONT : 3 ) ;
  WRITELN ( 'h          = ' , H ) ;
  WRITELN ( 'y          = ' , Y . CONT ) ;

  //**************************************
  // only to test what the compiler does
  //**************************************

  if FALSE then
    READ ( IFILE , I , CH , I , CH , I ) ;

  //*******************************
  // test input from console file
  //*******************************

  ENDE := FALSE ;
  repeat
    WRITELN ( 'zum testen ints einlesen bis eoln' ) ;
    WRITELN ( 'ende durch eingabe von 4711' ) ;
    repeat
      READ ( I ) ;
      WRITELN ( 'gelesen: ' , I ) ;
      if I = 4711 then
        ENDE := TRUE ;
    until EOLN ;
    WRITELN ( 'eoln gefunden' ) ;
  until ENDE ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRDI2 EXT PAS HEX -
program TESTRDI2 ( INPUT , OUTPUT ) ;

//**********************************************************
//$X+,A+
//**********************************************************



var I : INTEGER ;
    ENDE : BOOLEAN ;



procedure TERMIN ( var X : TEXT ) ;

   EXTERNAL ;



procedure TERMOUT ( var X : TEXT ) ;

   EXTERNAL ;



begin (* HAUPTPROGRAMM *)
  TERMIN ( INPUT ) ;
  TERMOUT ( OUTPUT ) ;

  //*******************************
  // test input from console file
  //*******************************

  ENDE := FALSE ;
  repeat
    WRITELN ( 'zum testen ints einlesen bis eoln' ) ;
    ENDE := false ;
    WRITELN ( 'ende durch eingabe von 4711' ) ;
    repeat
      READ ( I ) ;
      WRITELN ( 'gelesen: ' , I ) ;
      if I = 4711 then
        ENDE := TRUE ;
    until EOLN ;
    WRITELN ( 'eoln gefunden' ) ;
  until ENDE ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRDR  EXT PAS HEX -
program TESTRDR ( INPUT , OUTPUT ) ;

//**********************************************************
//$X+,A+
//**********************************************************



var R : REAL ;
    ENDE : BOOLEAN ;



procedure TERMIN ( var X : TEXT ) ;

   EXTERNAL ;



procedure TERMOUT ( var X : TEXT ) ;

   EXTERNAL ;



begin (* HAUPTPROGRAMM *)
  TERMIN ( INPUT ) ;
  TERMOUT ( OUTPUT ) ;

  //*******************************
  // test input from console file
  //*******************************

  ENDE := FALSE ;
  repeat
    WRITELN ( 'zum testen reals einlesen bis eoln' ) ;
    ENDE := FALSE ;
    WRITELN ( 'ende durch eingabe von 4711' ) ;
    repeat
      READ ( R ) ;
      WRITELN ( 'gelesen: ' , R : 20 : 7 ) ;
      if R = 4711 then
        ENDE := TRUE ;
    until EOLN ;
    WRITELN ( 'eoln gefunden' ) ;
  until ENDE ;
  ENDE := FALSE ;
  repeat
    WRITELN ( 'zum testen reals einlesen bis eoln' ) ;
    WRITELN ( 'feste laenge 5' ) ;
    ENDE := FALSE ;
    WRITELN ( 'ende durch eingabe von 4711' ) ;
    repeat
      READ ( R : 5 ) ;
      WRITELN ( 'gelesen: ' , R : 20 : 7 ) ;
      if R = 4711 then
        ENDE := TRUE ;
    until EOLN ;
    WRITELN ( 'eoln gefunden' ) ;
  until ENDE ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRDS  EXT PAS HEX -
program TESTRDS ( INPFILE , OUTPUT ) ;


var INPFILE : TEXT ;
    C20 : CHAR ( 20 ) ;


begin (* HAUPTPROGRAMM *)
  RESET ( INPFILE ) ;
  READ ( INPFILE , C20 ) ;
  while not EOF ( INPFILE ) do
    begin
      WRITELN ( 'gelesen: <' , C20 , '> eoln = ' , EOLN ( INPFILE ) ) ;
      READ ( INPFILE , C20 ) ;
      WRITELN ( 'eof = ' , EOF ( INPFILE ) ) ;
    end (* while *) ;
  WRITELN ( 'Dateiende festgestellt' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRDV  EXT PAS HEX -
program TESTRDV ( INPFILE , OUTPUT ) ;


var INPFILE : TEXT ;
    S10 : STRING ( 10 ) ;


begin (* HAUPTPROGRAMM *)
  RESET ( INPFILE ) ;
  READ ( INPFILE , S10 ) ;
  while not EOF ( INPFILE ) do
    begin
      WRITELN ( 'gelesen: <' , S10 , '> eoln = ' , EOLN ( INPFILE ) ) ;
      READ ( INPFILE , S10 ) ;
      WRITELN ( 'eof = ' , EOF ( INPFILE ) ) ;
    end (* while *) ;
  WRITELN ( 'Dateiende festgestellt' ) ;
  CLOSE ( INPFILE ) ;
  RESET ( INPFILE ) ;
  READ ( INPFILE , S10 ) ;
  while not EOF ( INPFILE ) do
    begin
      WRITELN ( 'gelesen: <' , S10 , '> eoln = ' , EOLN ( INPFILE ) ) ;
      READ ( INPFILE , S10 ) ;
      WRITELN ( 'eof = ' , EOF ( INPFILE ) ) ;
    end (* while *) ;
  WRITELN ( 'Dateiende festgestellt' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTREA2 EXT PAS HEX -
program TESTREA2 ( INPUT , OUTPUT ) ;


var E1 : CHAR ( 10 ) ;
    V1 : STRING ( 10 ) ;


begin (* HAUPTPROGRAMM *)
  TERMIN ( INPUT ) ;
  WRITELN ( 'Test Eingabe feste CHARs (bis ENDE)' ) ;
  repeat
    READ ( E1 ) ;
    WRITELN ( 'Eingabe = <' , E1 , '> eoln = ' , EOLN ) ;
    if EOLN then
      READLN
  until E1 = 'ENDE' ;
  WRITELN ( 'Test Eingabe var. CHARs (bis ENDE)' ) ;
  repeat
    READ ( V1 ) ;
    WRITELN ( 'Eingabe = <' , V1 , '> eoln = ' , EOLN ) ;
    if EOLN then
      READLN
  until V1 = 'ENDE' ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTREA3 EXT PAS HEX -
program TESTREA3 ( INPUT , OUTPUT ) ;

//*****
//$A+
//*****



var ISTR : CHAR ( 10 ) ;
    I : INTEGER ;
    R : REAL ;
    CH : CHAR ;



procedure TERMIN ( var X : TEXT ) ;

   EXTERNAL ;



procedure TERMOUT ( var X : TEXT ) ;

   EXTERNAL ;



function IVALSTR ( CP : -> CHAR ; LEN : INTEGER ) : INTEGER ;

   EXTERNAL ;



begin (* HAUPTPROGRAMM *)
  TERMIN ( INPUT ) ;
  TERMOUT ( OUTPUT ) ;
  WRITELN ;
  WRITELN ( 'testen read real mit laenge' ) ;
  WRITELN ;
  repeat
    if TRUE then
      begin
        WRITELN ( 'bitte einen Buchstaben eingeben:' ) ;
        READLN ( CH ) ;
        WRITE ( 'ch = ' , CH : 1 ) ;
        WRITELN ;
        WRITELN ( 'bitte noch einen Buchstaben eingeben:' ) ;
        READLN ( CH ) ;
        WRITE ( 'ch = ' , CH : 1 ) ;
        WRITELN ;
      end (* then *) ;
    WRITELN ( 'bitte eine Zahl eingeben:' ) ;
    READLN ( R ) ;
    WRITE ( 'R = ' , R : 15 : 7 ) ;
    WRITELN ;
    WRITELN ( 'bitte noch eine Zahl eingeben:' ) ;
    READLN ( R ) ;
    WRITE ( 'R = ' , R : 15 : 7 ) ;
    WRITELN ;
    WRITELN ( 'bitte eine Zahl eingeben als Laenge fuer READ:' ) ;
    READLN ( ISTR ) ;
    I := IVALSTR ( ADDR ( ISTR ) , 10 ) ;
    WRITELN ( 'ende mit 0' ) ;
    WRITELN ( 'bitte Zahl eingeben, gelesen wird in Laenge ' , I : 1 )
              ;
    READ ( R : I ) ;
    READLN ;
    WRITE ( 'R = ' , R : 15 : 7 ) ;
    WRITELN ;
  until R = 0.0
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTREA6 EXT PAS HEX -
program TESTREAD ( INPUT , OUTPUT ) ;

//*****
//$A+
//*****



var CH : CHAR ;
    ISTR : CHAR ( 10 ) ;
    I : INTEGER ;
    C10 : CHAR ( 10 ) ;
    S10 : STRING ( 10 ) ;



procedure TERMIN ( var X : TEXT ) ;

   EXTERNAL ;



procedure TERMOUT ( var X : TEXT ) ;

   EXTERNAL ;



function IVALSTR ( CP : -> CHAR ; LEN : INTEGER ) : INTEGER ;

   EXTERNAL ;



begin (* HAUPTPROGRAMM *)
  TERMIN ( INPUT ) ;
  TERMOUT ( OUTPUT ) ;
  WRITELN ;
  WRITELN ( 'testen read mit laenge' ) ;
  WRITELN ;
  s10 := ' ' ;
  repeat
    WRITELN ( 'bitte eine zahl eingeben als laenge fuer read:' ) ;
    READLN ( ISTR ) ;
    I := IVALSTR ( ADDR ( ISTR ) , 10 ) ;
    WRITELN ( 'bitte text eingeben (ende mit $):' ) ;
    READLN ( CH : I , C10 : I , S10 : I ) ;
    WRITE ( 'i = ' , I : 1 , ' ' ) ;
    WRITE ( 'ch = ' , CH , ' ' ) ;
    WRITE ( 'c10 = <' , C10 , '> ' ) ;
    WRITE ( 's10 = <' , S10 , '> ' ) ;
    WRITELN ;
  until INDEX ( S10 , '$' ) <> 0
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTREA7 EXT PAS HEX -
program TESTREA7 ( INPUT , OUTPUT ) ;

//*****
//$A+
//*****



type SHORT = - 1000 .. 1000 ;


var ISTR : CHAR ( 10 ) ;
    I : INTEGER ;
    I2 : INTEGER ;
    CH : CHAR ;
    ISHORT : SHORT ;



procedure TERMIN ( var X : TEXT ) ;

   EXTERNAL ;



procedure TERMOUT ( var X : TEXT ) ;

   EXTERNAL ;



function IVALSTR ( CP : -> CHAR ; LEN : INTEGER ) : INTEGER ;

   EXTERNAL ;



begin (* HAUPTPROGRAMM *)
  TERMIN ( INPUT ) ;
  TERMOUT ( OUTPUT ) ;
  WRITELN ;
  WRITELN ( 'testen read mit laenge' ) ;
  WRITELN ;
  repeat
    if FALSE then
      begin
        WRITELN ( 'bitte einen Buchstaben eingeben:' ) ;
        READLN ( CH ) ;
        WRITE ( 'ch = ' , CH : 1 ) ;
        WRITELN ;
        WRITELN ( 'bitte noch einen Buchstaben eingeben:' ) ;
        READLN ( CH ) ;
        WRITE ( 'ch = ' , CH : 1 ) ;
        WRITELN ;
      end (* then *) ;
    WRITELN ( 'bitte eine Zahl eingeben:' ) ;
    READLN ( I ) ;
    WRITE ( 'i = ' , I : 1 ) ;
    WRITELN ;
    WRITELN ( 'bitte noch eine Zahl eingeben:' ) ;
    READLN ( I ) ;
    WRITE ( 'i = ' , I : 1 ) ;
    WRITELN ;
    WRITELN ( 'bitte ishort eingeben:' ) ;
    READLN ( ISHORT ) ;
    WRITE ( 'ishort = ' , ISHORT : 1 ) ;
    WRITELN ;
    WRITELN ( 'bitte eine Zahl eingeben als Laenge fuer READ:' ) ;
    READLN ( ISTR ) ;
    I := IVALSTR ( ADDR ( ISTR ) , 10 ) ;
    WRITELN ( 'ende mit 0' ) ;
    WRITELN ( 'bitte zweimal Zahl eingeben, gelesen wird in Laenge ' ,
              I : 1 ) ;
    READ ( I2 : I ) ;
    WRITELN ( 'read mit Laenge erfolgreich, vor readln' ) ;
    READLN ;
    WRITE ( 'i2 = ' , I2 : 1 ) ;
    WRITELN ;
    READ ( I2 : I ) ;
    READLN ;
    WRITE ( 'i2 = ' , I2 : 1 ) ;
    WRITELN ;
  until I2 = 0
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTREA8 EXT PAS HEX -
program TESTREA8 ( INPUT , OUTPUT ) ;


var I : INTEGER ;
    ANZ : INTEGER ;


begin (* HAUPTPROGRAMM *)
  ANZ := 0 ;
  READ ( I ) ;
  while not EOF ( INPUT ) do
    begin
      WRITE ( ' ' , I : 8 ) ;
      ANZ := ANZ + 1 ;
      if ANZ MOD 8 = 0 then
        WRITELN ;
      READ ( I ) ;
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTREAD EXT PAS HEX -
program TESTREAD ( INPFILE , OUTPUT ) ;


var INPFILE : TEXT ;
    CH : CHAR ;
    CH10 : CHAR ( 10 ) ;
    S10 : STRING ( 10 ) ;


begin (* HAUPTPROGRAMM *)
  WRITELN ;
  WRITELN ( 'lesen einzelne char' ) ;
  WRITELN ;
  RESET ( INPFILE ) ;
  while not EOF ( INPFILE ) do
    begin
      READ ( INPFILE , CH ) ;
      WRITELN ( 'gelesen: ' , CH , ORD ( CH ) : 4 , ' eof = ' , EOF (
                INPFILE ) , ' eoln = ' , EOLN ( INPFILE ) ) ;
    end (* while *) ;
  WRITELN ;
  WRITELN ( 'lesen char (10)' ) ;
  WRITELN ;
  RESET ( INPFILE ) ;
  while not EOF ( INPFILE ) do
    begin
      READ ( INPFILE , CH10 ) ;
      WRITELN ( 'gelesen: <' , CH10 , '> eoln = ' , EOLN ( INPFILE ) )
                ;
      if EOLN ( INPFILE ) then
        READLN ( INPFILE ) ;
    end (* while *) ;
  WRITELN ;
  WRITELN ( 'lesen string (10)' ) ;
  WRITELN ;
  RESET ( INPFILE ) ;
  while not EOF ( INPFILE ) do
    begin
      READ ( INPFILE , S10 ) ;
      WRITELN ( 'gelesen: <' , S10 , '> eoln = ' , EOLN ( INPFILE ) ) ;
      if EOLN ( INPFILE ) then
        READLN ( INPFILE ) ;
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTREAL EXT PAS HEX -
program TESTREAL ( OUTPUT ) ;

(********)
(*$a+   *)
(********)



var X : REAL ;
    Y : REAL ;
    M : INTEGER ;


begin (* HAUPTPROGRAMM *)
  X := 1.5 ;
  Y := SIN ( X ) ;
  WRITELN ( 'SIN (1.5) = ' , Y : 17 : 12 ) ;
  WRITELN ( 'SIN (1.0) = ' , SIN ( 1.0 ) : 17 : 12 ) ;
  Y := X + Y ;
  WRITELN ( 'y at stage 1 = ' , Y : 17 : 12 ) ;
  Y := Y * X ;
  WRITELN ( 'y at stage 2 = ' , Y : 17 : 12 ) ;
  Y := Y - X ;
  WRITELN ( 'y at stage 3 = ' , Y : 17 : 12 ) ;
  M := 12 ;
  Y := Y + M ;
  WRITELN ( 'y at stage 4 = ' , Y : 17 : 12 ) ;
  Y := Y / X ;
  WRITELN ( 'y at stage 5 = ' , Y : 17 : 12 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRL   EXT PAS HEX -
program TESTRL ( INPUT , OUTPUT , SCANINP ) ;

(********************************************)
(*$A+                                       *)
(********************************************)
(*  scan_code fuer ebcdic geeignet machen   *)
(*  zeilenposition usw. mitfuehren          *)
(*  listing mit syntaxfehlern usw.          *)
(*  scangenc entsprechend anpassen          *)
(********************************************)



const MAXLSIZE = 120 ;


type SOURCELINE = array [ 1 .. MAXLSIZE ] of CHAR ;
     SYMB = ( SYMB_EOF , SYMB_UNKNOWN , SEPARATOR , COMMENT , STRING ,
            IDENT , SYALL , SYOR , SYIGNORE , SYUPPER , SYKEY ,
            SYASSIGN , SYKOMMA , SYKLAMMAUF , SYKLAMMZU , SYSLASH ,
            SYRANGE , SYPLUS , SYMINUS , SYMULT , SYSTRIPU , SYEQUAL )
            ;
     SCAN_BLOCK = record
                    MODUS : INTEGER ;
                    DATEIENDE : INTEGER ;
                    ENDOFLINE : BOOLEAN ;
                    SLINE : SOURCELINE ;
                    LINENR : INTEGER ;
                    LINEPOS : INTEGER ;
                    LINELEN : INTEGER ;
                    LOOKAHEAD : CHAR ;
                    SYMBOLNR : SYMB ;
                    SYMBOL : SOURCELINE ;
                    LSYMBOL : INTEGER ;
                    MAXLSYMBOL : INTEGER ;
                  end ;


var SCB : SCAN_BLOCK ;
    SCANINP : TEXT ;
    CH : CHAR ;



procedure SCAN_READC ( var SCB : SCAN_BLOCK ; var CH : CHAR ) ;

   begin (* SCAN_READC *)
     while TRUE do
       begin
         if SCB . LINEPOS < SCB . LINELEN then
           begin
             SCB . LINEPOS := SCB . LINEPOS + 1 ;
             CH := SCB . SLINE [ SCB . LINEPOS ] ;
             SCB . ENDOFLINE := FALSE ;
             return ;
           end (* then *) ;
         if SCB . LINEPOS = SCB . LINELEN then
           begin
             SCB . LINEPOS := SCB . LINEPOS + 1 ;
             CH := ' ' ;
             SCB . ENDOFLINE := TRUE ;
             return ;
           end (* then *) ;
         if EOF ( SCANINP ) then
           begin
             SCB . DATEIENDE := 1 ;
             SCB . SLINE := ' ' ;
             SCB . LINENR := SCB . LINENR + 1 ;
             SCB . LINEPOS := 1 ;
             SCB . LINELEN := 0 ;
             return ;
           end (* then *) ;
         READLN ( SCANINP , SCB . SLINE ) ;
         SCB . LINENR := SCB . LINENR + 1 ;
         SCB . LINEPOS := 0 ;
         SCB . LINELEN := MAXLSIZE ;
         while TRUE do
           begin
             if SCB . LINELEN = 0 then
               break ;
             if SCB . SLINE [ SCB . LINELEN ] <> ' ' then
               break ;
             SCB . LINELEN := SCB . LINELEN - 1 ;
           end (* while *)
       end (* while *)
   end (* SCAN_READC *) ;



begin (* HAUPTPROGRAMM *)
  MEMSET ( ADDR ( SCB ) , CHR ( 0 ) , SIZEOF ( SCB ) ) ;
  SCB . MAXLSYMBOL := MAXLSIZE ;
  SCB . MODUS := 1 ;
  SCB . SYMBOLNR := SYMB_UNKNOWN ;
  SCB . SLINE := ' ' ;
  SCB . LINENR := 0 ;
  SCB . LINEPOS := 1 ;
  SCB . LINELEN := 0 ;
  while SCB . DATEIENDE = 0 do
    begin
      SCAN_READC ( SCB , CH ) ;
      WRITE ( CH ) ;
      if SCB . ENDOFLINE then
        WRITELN
    end (* while *) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRND  EXT PAS HEX -
program TESTRND ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



var R : REAL ;
    I : INTEGER ;



local procedure DUMP ( PVON : VOIDPTR ; PBIS : VOIDPTR ) ;

(*********************************************************)
(*  Speicherbereich von PVON bis PBIS hexadezimal        *)
(*  ausgeben                                             *)
(*********************************************************)


   var P1 : VOIDPTR ;
       P2 : VOIDPTR ;
       MOD1 : INTEGER ;
       MOD2 : INTEGER ;


   procedure DUMPCHAR ( CH : CHAR ) ;

      begin (* DUMPCHAR *)
        if CH in [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' , 'A' .. 'I' ,
        'J' .. 'R' , 'S' .. 'Z' , '0' .. '9' , ' ' , ',' , '.' , '-' ,
        ';' , ':' , '_' , '!' , '"' , '' , '$' , '%' , '&' , '/' , '('
        , ')' , '=' , '?' , '+' , '*' , '#' , '*' ] then
          WRITE ( CH )
        else
          WRITE ( '.' )
      end (* DUMPCHAR *) ;


   procedure DUMPZEILE ( ADR : VOIDPTR ; P1 : VOIDPTR ; P2 : VOIDPTR )
                       ;

      var CH : -> CHAR ;
          I : INTEGER ;

      const HEXTAB : array [ 0 .. 15 ] of CHAR = '0123456789abcdef' ;

      begin (* DUMPZEILE *)
        WRITE ( ADR , ': ' ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , 4 ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , 4 ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , 4 ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , - 12 ) ;
        CH := ADR ;
        WRITE ( ' *' ) ;
        for I := 1 to 16 do
          begin
            DUMPCHAR ( CH -> ) ;
            CH := PTRADD ( CH , 1 )
          end (* for *) ;
        WRITELN ( '*' ) ;
      end (* DUMPZEILE *) ;


   begin (* DUMP *)
     WRITELN ( 'Dump Speicherbereich von ' , PVON , ' bis ' , PBIS ) ;
     P1 := PTRADD ( PVON , - 16 ) ;
     MOD1 := PTR2INT ( P1 ) MOD 16 ;
     P1 := PTRADD ( P1 , 16 - MOD1 ) ;
     P2 := PTRADD ( PBIS , 15 ) ;
     MOD2 := PTR2INT ( P2 ) MOD 16 ;
     P2 := PTRADD ( P2 , - MOD2 ) ;
     while PTRDIFF ( P1 , P2 ) < 0 do
       begin
         DUMPZEILE ( P1 , PVON , PBIS ) ;
         P1 := PTRADD ( P1 , 16 ) ;
       end (* while *) ;
   end (* DUMP *) ;



begin (* HAUPTPROGRAMM *)

  /******************/
  /* positiver wert */
  /******************/

  R := 12.5 ;
  DUMP ( ADDR ( R ) , PTRADD ( ADDR ( R ) , 7 ) ) ;
  R := R * 4724731.123456 ;
  R := R / 4724731.123456 ;
  DUMP ( ADDR ( R ) , PTRADD ( ADDR ( R ) , 7 ) ) ;
  WRITELN ( 'r vor round   = ' , R : 15 : 7 ) ;
  I := ROUND ( R ) ;
  WRITELN ( 'i nach round  = ' , I : 13 ) ;
  I := TRUNC ( R ) ;
  WRITELN ( 'i nach trunc  = ' , I : 13 ) ;
  R := FLOOR ( R ) ;
  WRITELN ( 'r nach floor  = ' , R : 15 : 7 ) ;
  R := 12.357 ;
  WRITELN ( 'r vor roundx  = ' , R : 15 : 7 ) ;
  R := ROUNDX ( R , - 2 ) ;
  WRITELN ( 'r nach roundx = ' , R : 15 : 7 ) ;

  /******************/
  /* negativer wert */
  /******************/

  R := - 12.5 ;
  DUMP ( ADDR ( R ) , PTRADD ( ADDR ( R ) , 7 ) ) ;
  R := R * 4724731.123456 ;
  R := R / 4724731.123456 ;
  DUMP ( ADDR ( R ) , PTRADD ( ADDR ( R ) , 7 ) ) ;
  WRITELN ( 'r vor round   = ' , R : 15 : 7 ) ;
  I := ROUND ( R ) ;
  WRITELN ( 'i nach round  = ' , I : 13 ) ;
  I := TRUNC ( R ) ;
  WRITELN ( 'i nach trunc  = ' , I : 13 ) ;
  R := FLOOR ( R ) ;
  WRITELN ( 'r nach floor  = ' , R : 15 : 7 ) ;
  R := - 12.357 ;
  WRITELN ( 'r vor roundx  = ' , R : 15 : 7 ) ;
  R := ROUNDX ( R , - 2 ) ;
  WRITELN ( 'r nach roundx = ' , R : 15 : 7 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRS1  EXT PAS HEX -
program TESTRS1 ( INPUT , OUTPUT ) ;

//**********************************************************
//$X+
//**********************************************************



var S : STRING ( 200 ) ;
    CH : CHAR ;
    I : INTEGER ;
    F : CHAR ( 5 ) ;
    V : STRING ( 10 ) ;
    RPOS : INTEGER ;
    R : REAL ;



function $PASRSC ( const S : STRING ;         // source string
                 var RPOS : INTEGER ;         // reading position
                 WIDTH : INTEGER ) : CHAR ;   // optional width

   EXTERNAL ;



function $PASRSI ( const S : STRING ;         // source string
                 var RPOS : INTEGER ;         // reading position
                 WIDTH : INTEGER )            // optional width
                 : INTEGER ;

   EXTERNAL ;



function $PASRSR ( const S : STRING ;         // source string
                 var RPOS : INTEGER ;         // reading position
                 WIDTH : INTEGER )            // optional width
                 : REAL ;

   EXTERNAL ;



procedure $PASRSS ( const S : STRING ;     // source string
                  var RPOS : INTEGER ;     // reading position
                  WIDTH : INTEGER ;        // optional width
                  RES : VOIDPTR ;          // pointer to target
                  LEN : INTEGER ) ;        // len of target

   EXTERNAL ;



procedure $PASRSV ( const S : STRING ;     // source string
                  var RPOS : INTEGER ;     // reading position
                  WIDTH : INTEGER ;        // optional width
                  var RES : STRING ) ;     // target string

   EXTERNAL ;



begin (* HAUPTPROGRAMM *)
  S := '36 24  123.45678ABCDEFGHIJKLMNOPQRSTUVWXYZ' ;
  WRITELN ( 'source   s  = ' , S ) ;
  RPOS := 0 ;
  CH := $PASRSC ( S , RPOS , 2 ) ;
  I := $PASRSI ( S , RPOS , 4 ) ;
  R := $PASRSR ( S , RPOS , 8 ) ;
  $PASRSS ( S , RPOS , - 1 , ADDR ( F ) , 5 ) ;
  $PASRSV ( S , RPOS , 7 , V ) ;
  WRITELN ( 'ergebnis ch = ' , CH ) ;
  WRITELN ( 'ergebnis i  = ' , I : 1 ) ;
  WRITELN ( 'ergebnis r  = ' , R : 1 : 7 ) ;
  WRITELN ( 'ergebnis f  = ' , F ) ;
  WRITELN ( 'ergebnis v  = ' , V ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTRS2  EXT PAS HEX -
program TESTRS2 ( INPUT , OUTPUT ) ;

//**********************************************************
//$X+
//**********************************************************



var S : STRING ( 100 ) ;
    CH : CHAR ;
    I , J : INTEGER ;
    S1 : STRING ( 100 ) ;
    CC : CHAR ( 10 ) ;
    H : 0 .. 2000 ;
    F : CHAR ( 10 ) ;
    V : STRING ( 100 ) ;
    R : REAL ;
    B1 : BOOLEAN ;
    B2 : BOOLEAN ;


begin (* HAUPTPROGRAMM *)

  //**************
  // first tests
  //**************

  WRITELN ( 'first tests' ) ;
  S := '36 24  123.45678ABCDEFGHIJKLMNOPQRSTUVWXYZ' ;
  WRITELN ( 'source   s  = ' , S ) ;
  READSTR ( S , CH : 2 , H : 4 , R : 8 , F : 6 , V ) ;
  WRITELN ( 'ch          = ' , CH ) ;
  WRITELN ( 'h           = ' , H : 1 ) ;
  WRITELN ( 'r           = ' , R : 1 : 7 ) ;
  WRITELN ( 'f           = ' , F ) ;
  WRITELN ( 'v           = ' , V ) ;

  //********************************
  // tests from pascal/vs brochure
  //********************************

  WRITELN ( 'test pascal/vs example' ) ;
  S := '36 245ABCDEFGHIJK' ;
  READSTR ( S , I , J : 3 , CH , CC : 5 , S1 ) ;
  WRITELN ( 'source   s  = ' , S ) ;
  WRITELN ( 'i           = ' , I : 1 ) ;
  WRITELN ( 'j           = ' , J : 1 ) ;
  WRITELN ( 'ch          = ' , CH ) ;
  WRITELN ( 'cc          = ' , CC ) ;
  WRITELN ( 's1          = ' , S1 ) ;
  WRITELN ( 'length(s1)  = ' , LENGTH ( S1 ) : 1 ) ;

  //********************************
  // tests with boolean
  //********************************

  WRITELN ( 'test with boolean' ) ;
  S := '36 245FALABCDETFGHIJK' ;
  READSTR ( S , I , J : 3 , CH , B2 : 3 , CC : 5 , B1 , S1 ) ;
  WRITELN ( 'source   s  = ' , S ) ;
  WRITELN ( 'i           = ' , I : 1 ) ;
  WRITELN ( 'j           = ' , J : 1 ) ;
  WRITELN ( 'ch          = ' , CH ) ;
  WRITELN ( 'cc          = ' , CC ) ;
  WRITELN ( 's1          = ' , S1 ) ;
  WRITELN ( 'length(s1)  = ' , LENGTH ( S1 ) : 1 ) ;
  WRITELN ( 'b1          = ' , B1 ) ;
  WRITELN ( 'b2          = ' , B2 ) ;

  //*************
  // more tests
  //*************

  WRITELN ( 'more tests' ) ;
  S := '  1024   27' ;
  READSTR ( S , I , H ) ;
  WRITELN ( 'source   s  = ' , S ) ;
  WRITELN ( 'i           = ' , I ) ;
  WRITELN ( 'h           = ' , H ) ;
  READSTR ( S , I : 5 , H : 5 ) ;
  WRITELN ( 'source   s  = ' , S ) ;
  WRITELN ( 'i           = ' , I ) ;
  WRITELN ( 'h           = ' , H ) ;
  READSTR ( S , I : 4 , H : 4 ) ;
  WRITELN ( 'source   s  = ' , S ) ;
  WRITELN ( 'i           = ' , I ) ;
  WRITELN ( 'h           = ' , H ) ;
  READSTR ( S , I : 3 , H : 3 ) ;
  WRITELN ( 'source   s  = ' , S ) ;
  WRITELN ( 'i           = ' , I ) ;
  WRITELN ( 'h           = ' , H ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSCAL EXT PAS HEX -
program TESTSCAL ( INPUT , OUTPUT ) ;

(********)
(*$A+   *)
(********)



type FARBE = ( GELB , ROT , GRUEN , BLAU ) ;
     OPTYPE = ( PCTS , PCTI , PLOD , PSTR , PLDA , PLOC , PSTO , PLDC ,
              PLAB , PIND , PINC , PPOP , PCUP , PENT , PRET , PCSP ,
              PIXA , PEQU , PNEQ , PGEQ , PGRT , PLEQ , PLES , PUJP ,
              PFJP , PXJP , PCHK , PNEW , PADI , PADR , PSBI , PSBR ,
              PSCL , PFLT , PFLO , PTRC , PNGI , PNGR , PSQI , PSQR ,
              PABI , PABR , PNOT , PAND , PIOR , PDIF , PINT , PUNI ,
              PINN , PMOD , PODD , PMPI , PMPR , PDVI , PDVR , PMOV ,
              PLCA , PDEC , PSTP , PSAV , PRST , PCHR , PORD , PDEF ,
              PRND , PCRD , PXPO , PBGN , PEND , PASE , PSLD , PSMV ,
              PMST , PUXJ , PXLB , PCST , PDFC , PPAK , PADA , PSBA ,
              UNDEF_OP ) ;


var X : FARBE ;
    OPC : OPTYPE ;


begin (* HAUPTPROGRAMM *)
  for X := ROT to GRUEN do
    begin
      WRITELN ( 'Farbe: ' , ORD ( X ) , ' ' , '<' , PRED ( X ) : 10 ,
                '#' , X : 10 , '#' , SUCC ( X ) : 10 , '>' ) ;
    end (* for *) ;
  WRITELN ( 'liste aller opcodes' ) ;
  for OPC := PCTS to UNDEF_OP do
    begin
      WRITE ( OPC : 4 , ' ' ) ;
      if ORD ( OPC ) MOD 10 = 9 then
        WRITELN
    end (* for *) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSCAN EXT PAS HEX -
program TESTSCAN ( INPUT , OUTPUT , SCANINP ) ;

(********************************************)
(*$A+                                       *)
(********************************************)
(* * zeilenposition usw. mitfuehren         *)
(* * scan_code fuer ebcdic geeignet machen  *)
(* - listing mit syntaxfehlern usw.         *)
(* - scangenc entsprechend anpassen         *)
(********************************************)



const MAXLSIZE = 120 ;


type SOURCELINE = array [ 1 .. MAXLSIZE ] of CHAR ;
     CHAR32 = array [ 1 .. 32 ] of CHAR ;
     CHARPTR = -> CHAR ;
     SYMB = ( SYMB_EOF , SYMB_UNKNOWN , SEPARATOR , COMMENT , STRING ,
            IDENT , SYALL , SYOR , SYIGNORE , SYUPPER , SYKEY ,
            SYASSIGN , SYKOMMA , SYKLAMMAUF , SYKLAMMZU , SYSLASH ,
            SYRANGE , SYPLUS , SYMINUS , SYMULT , SYSTRIPU , SYEQUAL )
            ;
     SCANFT_PTR = -> SCAN_FTEXT ;
     SCAN_FTEXT = record
                    ERRCLASS : CHAR ;
                    NUMMER : INTEGER ;
                    FTEXT : CHARPTR ;
                    FTEXT_LEN : INTEGER
                  end ;
     SCANF_PTR = -> SCAN_FEHLER ;
     SCAN_FEHLER = record
                     ERRLEVEL : CHAR ;
                     ERRCLASS : CHAR ;
                     NUMMER : INTEGER ;
                     INFO : CHAR32 ;
                     ZEILNR : INTEGER ;
                     POSITION : INTEGER ;
                     NAECHST : SCANF_PTR ;
                   end ;
     SCAN_BLOCK = record
                    MODUS : INTEGER ;
                    DATEIENDE : INTEGER ;
                    ENDOFLINE : BOOLEAN ;
                    SLINE : SOURCELINE ;
                    LINENR : INTEGER ;
                    LINEPOS : INTEGER ;
                    LINELEN : INTEGER ;
                    LOOKAHEAD : CHAR ;
                    SYMBOLNR : SYMB ;
                    SYMBOL : SOURCELINE ;
                    LSYMBOL : INTEGER ;
                    MAXLSYMBOL : INTEGER ;
                    UFZAHL : INTEGER ;
                    SFZAHL : INTEGER ;
                    FEZAHL : INTEGER ;
                    WAZAHL : INTEGER ;
                    INZAHL : INTEGER ;
                    FEANFANG : SCANF_PTR ;
                    FEAKT : SCANF_PTR ;
                    FTTAB : SCANFT_PTR ;
                    FTTAB_SIZE : INTEGER ;
                    FTTABA : SCANFT_PTR ;
                    FTTABA_SIZE : INTEGER ;
                  end ;


var SCB : SCAN_BLOCK ;
    SCANINP : TEXT ;
    INFO : CHAR32 ;
    I : INTEGER ;



function TOUPPER ( C : CHAR ) : CHAR ;

   begin (* TOUPPER *)
     if C in [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' ] then
       C := CHR ( ORD ( C ) - ORD ( 'a' ) + ORD ( 'A' ) ) ;
     TOUPPER := C ;
   end (* TOUPPER *) ;



procedure SCAN_TOUPPER ( var SCB : SCAN_BLOCK ) ;

   var I : INTEGER ;

   begin (* SCAN_TOUPPER *)
     for I := 1 to SCB . LSYMBOL do
       SCB . SYMBOL [ I ] := TOUPPER ( SCB . SYMBOL [ I ] ) ;
   end (* SCAN_TOUPPER *) ;



function SCAN_CODE ( C : CHAR ) : INTEGER ;

   type TRANSLATE_TAB = array [ CHAR ] of INTEGER ;

   const EBCDIC_TO_ASCII : TRANSLATE_TAB =
         ( 0X00 , 0X01 , 0X02 , 0X03 , 0XEC , 0X09 , 0XCA , 0X7F , 0XE2
           , 0XD2 , 0XD3 , 0X0B , 0X0C , 0X0D , 0X0E , 0XA9 ,

         /******************************************************/
         /*   Beim Host: \n = 0x15 => 0x0a                     */
         /******************************************************/
         /*   0x10, 0x11, 0x12, 0x13, 0xef, 0xc5, 0x08, 0xcb,  */
         /******************************************************/


           0X10 , 0X11 , 0X12 , 0X13 , 0XEF , 0X0A , 0X08 , 0XCB , 0X18
           , 0X19 , 0XDC , 0XD8 , 0X1C , 0X1D , 0X1E , 0X1F ,

         /******************************************************/
         /*   0xb7, 0xb8, 0xb9, 0xbb, 0xc4, 0x0a, 0x17, 0x1b,  */
         /******************************************************/


           0XB7 , 0XB8 , 0XB9 , 0XBB , 0XC4 , 0XC5 , 0X17 , 0X1B , 0XCC
           , 0XCD , 0XCF , 0XD0 , 0XD1 , 0X05 , 0X06 , 0X07 , 0XD9 ,
           0XDA , 0X16 , 0XDD , 0XDE , 0XDF , 0XE0 , 0X04 , 0XE3 , 0XE5
           , 0XE9 , 0XEB , 0XB0 , 0XB1 , 0X9E , 0X1A , 0X20 , 0XC9 ,
           0X83 , 0X7B , 0X85 , 0XA0 , 0XF2 , 0X86 , 0X87 , 0XA4 , 0X8E
           , 0X2E , 0X3C , 0X28 , 0X2B , 0X21 , 0X26 , 0X82 , 0X88 ,
           0X89 , 0X8A , 0XA1 , 0X8C , 0X8B , 0X8D , 0X7E , 0X9A , 0X24
           , 0X2A , 0X29 , 0X3B , 0X5E , 0X2D , 0X2F , 0XB2 , 0X5B ,
           0XB4 , 0XB5 , 0XB6 , 0X8F , 0X80 , 0XA5 , 0X94 , 0X2C , 0X25
           , 0X5F , 0X3E , 0X3F , 0XBA , 0X90 , 0XBC , 0XBD , 0XBE ,
           0XF3 , 0XC0 , 0XC1 , 0XC2 , 0X60 , 0X3A , 0X23 , 0X15 , 0X27
           , 0X3D , 0X22 , 0XC3 , 0X61 , 0X62 , 0X63 , 0X64 , 0X65 ,
           0X66 , 0X67 , 0X68 , 0X69 , 0XAE , 0XAF , 0XC6 , 0XC7 , 0XC8
           , 0XF1 , 0XF8 , 0X6A , 0X6B , 0X6C , 0X6D , 0X6E , 0X6F ,
           0X70 , 0X71 , 0X72 , 0XA6 , 0XA7 , 0X91 , 0XCE , 0X92 , 0X0F
           , 0XE6 , 0XE1 , 0X73 , 0X74 , 0X75 , 0X76 , 0X77 , 0X78 ,
           0X79 , 0X7A , 0XAD , 0XA8 , 0XD4 , 0XD5 , 0XD6 , 0XD7 , 0X9B
           , 0X9C , 0X9D , 0XFA , 0X9F , 0X40 , 0X14 , 0XAC , 0XAB ,
           0XFC , 0XAA , 0XB3 , 0XE4 , 0XFE , 0XBF , 0XE7 , 0X84 , 0X41
           , 0X42 , 0X43 , 0X44 , 0X45 , 0X46 , 0X47 , 0X48 , 0X49 ,
           0XE8 , 0X93 , 0X7C , 0X95 , 0XA2 , 0XED , 0X81 , 0X4A , 0X4B
           , 0X4C , 0X4D , 0X4E , 0X4F , 0X50 , 0X51 , 0X52 , 0XEE ,
           0X96 , 0X7D , 0X97 , 0XA3 , 0X98 , 0X99 , 0XF0 , 0X53 , 0X54
           , 0X55 , 0X56 , 0X57 , 0X58 , 0X59 , 0X5A , 0XFD , 0XF5 ,
           0X5C , 0XF7 , 0XF6 , 0XF9 , 0X30 , 0X31 , 0X32 , 0X33 , 0X34
           , 0X35 , 0X36 , 0X37 , 0X38 , 0X39 , 0XDB , 0XFB , 0X5D ,
           0XF4 , 0XEA , 0XFF ) ;

   begin (* SCAN_CODE *)
     if ORD ( '0' ) = 0X30 then

     /*************************************************/
     /* that means: charset of target machine = ascii */
     /*************************************************/

       SCAN_CODE := ORD ( C )
     else
       SCAN_CODE := EBCDIC_TO_ASCII [ C ] ;
   end (* SCAN_CODE *) ;



procedure SCAN_FEHLER_AUSGEBEN ( var OUTF : TEXT ; var SCB : SCAN_BLOCK
                               ) ;

   var ERRCLASS : CHAR ;
       NUMMER : INTEGER ;
       PFTEXT : SCANFT_PTR ;

   begin (* SCAN_FEHLER_AUSGEBEN *)
     ERRCLASS := SCB . FEAKT -> . ERRCLASS ;
     NUMMER := SCB . FEAKT -> . NUMMER ;
     if SCB . FTTAB <> NIL then
       begin
         PFTEXT := SCB . FTTAB ;
         while PFTEXT -> . FTEXT <> NIL do
           begin
             if ( PFTEXT -> . ERRCLASS = ERRCLASS ) and ( PFTEXT -> .
             NUMMER = NUMMER ) then
               break ;
             PFTEXT := PTRADD ( PFTEXT , SIZEOF ( SCAN_FEHLER ) ) ;
           end (* while *) ;
         if PFTEXT -> . FTEXT <> NIL then
           begin

     /**********************************/
     /* hier fehlt noch Platzhalter %s */
     /**********************************/

             WRITELN ( OUTF , PFTEXT -> . FTEXT ) ;
             return ;
           end (* then *) ;
       end (* then *) ;
     if SCB . FTTABA <> NIL then
       begin
         PFTEXT := SCB . FTTABA ;
         while PFTEXT -> . FTEXT <> NIL do
           begin
             if ( PFTEXT -> . ERRCLASS = ERRCLASS ) and ( PFTEXT -> .
             NUMMER = NUMMER ) then
               break ;
             PFTEXT := PTRADD ( PFTEXT , SIZEOF ( SCAN_FEHLER ) ) ;
           end (* while *) ;
         if PFTEXT -> . FTEXT <> NIL then
           begin

     /**********************************/
     /* hier fehlt noch Platzhalter %s */
     /**********************************/

             WRITELN ( OUTF , PFTEXT -> . FTEXT ) ;
             return ;
           end (* then *) ;
       end (* then *) ;
     WRITELN ( OUTF , 'Unbekannter Fehler' ) ;
     return ;
   end (* SCAN_FEHLER_AUSGEBEN *) ;



procedure SOURCE_LISTING ( var OUTF : TEXT ; var SCB : SCAN_BLOCK ;
                         ALLES : BOOLEAN ) ;

(************************************************)
(*                                              *)
(*   source_listing beruht auf der alten        *)
(*   Funktion fehlerausgabe.                    *)
(*                                              *)
(*   Die Eingabedatei wird nochmal gelesen      *)
(*   und ausgegeben; die Fehler werden          *)
(*   ueber den ganzen Compile-Lauf hinweg       *)
(*   in der Fehlerliste gesammelt und hier      *)
(*   in den Source-Text eingestreut.            *)
(*                                              *)
(*   Schalter alles gibt an, ob auch Zeilen     *)
(*   ohne Fehler ausgegeben werden sollen       *)
(*                                              *)
(************************************************)


   var ZEILENNR : INTEGER ;
       PL : INTEGER ;
       FESAVE : SCANF_PTR ;
       ERSTAUSG : BOOLEAN ;
       ZEILE_ENTH_FEHLER : BOOLEAN ;

   begin (* SOURCE_LISTING *)
     RESET ( SCANINP ) ;
     REWRITE ( OUTF ) ;
     WRITELN ( OUTF ) ;
     WRITELN ( OUTF , 'S O U R C E   L I S T I N G' ) ;
     WRITELN ( OUTF ) ;
     WRITELN ( OUTF , '       ....5...10....5...20....5...30....5...40'
               '....5...50....5...60....5...70..' ) ;
     ZEILENNR := 0 ;
     SCB . FEAKT := SCB . FEANFANG ;
     while TRUE do
       begin
         if EOF ( SCANINP ) then
           break ;
         READLN ( SCANINP , SCB . SLINE ) ;
         ZEILENNR := ZEILENNR + 1 ;
         ZEILE_ENTH_FEHLER := SCB . FEAKT <> NIL ;
         if ZEILE_ENTH_FEHLER then
           ZEILE_ENTH_FEHLER := ( SCB . FEAKT -> . ZEILNR = ZEILENNR )
                                ;
         if ALLES or ZEILE_ENTH_FEHLER then
           begin
             WRITELN ( OUTF , ZEILENNR : 5 , '  ' , SCB . SLINE ) ;
           end (* then *) ;
         if ZEILE_ENTH_FEHLER then
           begin
             PL := 0 ;
             WRITE ( OUTF , ' ' : 7 ) ;
             FESAVE := SCB . FEAKT ;
             while TRUE do
               begin
                 if SCB . FEAKT = NIL then
                   break ;
                 if SCB . FEAKT -> . ZEILNR <> ZEILENNR then
                   break ;
                 if PL < SCB . FEAKT -> . POSITION then
                   begin
                     WRITE ( OUTF , ' ' : SCB . FEAKT -> . POSITION -
                             PL ) ;
                     PL := SCB . FEAKT -> . POSITION ;
                   end (* then *) ;
                 WRITE ( OUTF , '!' ) ;
                 PL := PL + 1 ;
                 SCB . FEAKT := SCB . FEAKT -> . NAECHST ;
               end (* while *) ;
             WRITELN ( OUTF ) ;
             SCB . FEAKT := FESAVE ;
             while TRUE do
               begin
                 if SCB . FEAKT = NIL then
                   break ;
                 if SCB . FEAKT -> . ZEILNR <> ZEILENNR then
                   break ;
                 case SCB . FEAKT -> . ERRLEVEL of
                   'S' : WRITELN ( OUTF , '+++ Schwerer Fehler ' , SCB
                                   . FEAKT -> . ERRCLASS , SCB . FEAKT
                                   -> . NUMMER : 3 , ': ' ) ;
                   'F' : WRITELN ( OUTF , '+++ Fehler ' , SCB . FEAKT
                                   -> . ERRCLASS , SCB . FEAKT -> .
                                   NUMMER : 3 , ': ' ) ;
                   'W' : WRITELN ( OUTF , '** Warnung ' , SCB . FEAKT
                                   -> . ERRCLASS , SCB . FEAKT -> .
                                   NUMMER : 3 , ': ' ) ;
                   'I' : WRITELN ( OUTF , '** Inform. ' , SCB . FEAKT
                                   -> . ERRCLASS , SCB . FEAKT -> .
                                   NUMMER : 3 , ': ' ) ;
                   otherwise
                     WRITELN ( OUTF , '** Level-' , SCB . FEAKT -> .
                               ERRLEVEL , ' ' , SCB . FEAKT -> .
                               ERRCLASS , SCB . FEAKT -> . NUMMER : 3 ,
                               ': ' ) ;
                 end (* case *) ;
                 SCAN_FEHLER_AUSGEBEN ( OUTF , SCB ) ;
                 SCB . FEAKT := SCB . FEAKT -> . NAECHST ;
               end (* while *) ;
             WRITELN ( OUTF ) ;
           end (* then *) ;
       end (* while *) ;
     WRITELN ( OUTF , '       ....5...10....5...20....5...30....5...40'
               '....5...50....5...60....5...70..' ) ;
     WRITELN ( OUTF ) ;
     if SCB . UFZAHL + SCB . SFZAHL + SCB . FEZAHL + SCB . WAZAHL = 0
     then
       begin
         WRITELN ( OUTF , 'Keine Fehler, keine Warnungen.' ) ;
       end (* then *)
     else
       begin
         ERSTAUSG := TRUE ;
         if SCB . UFZAHL <> 0 then
           begin
             WRITE ( OUTF , SCB . UFZAHL : 1 ) ;
             WRITE ( OUTF , ' unbekannte' ) ;
             if SCB . UFZAHL = 1 then
               WRITE ( OUTF , 'r' ) ;
             WRITELN ( OUTF , ' Fehler' ) ;
             ERSTAUSG := FALSE ;
           end (* then *) ;
         if SCB . SFZAHL <> 0 then
           begin
             if not ERSTAUSG then
               WRITE ( OUTF , ', ' ) ;
             WRITE ( OUTF , SCB . SFZAHL : 1 ) ;
             WRITE ( OUTF , ' schwere' ) ;
             if SCB . SFZAHL = 1 then
               WRITE ( OUTF , 'r' ) ;
             WRITELN ( OUTF , ' Fehler' ) ;
             ERSTAUSG := FALSE ;
           end (* then *) ;
         if SCB . FEZAHL <> 0 then
           begin
             if not ERSTAUSG then
               WRITE ( OUTF , ', ' ) ;
             WRITE ( OUTF , SCB . FEZAHL : 1 ) ;
             WRITELN ( OUTF , ' Fehler' ) ;
             ERSTAUSG := FALSE ;
           end (* then *) ;
         if SCB . WAZAHL <> 0 then
           begin
             if not ERSTAUSG then
               WRITE ( OUTF , ', ' ) ;
             WRITE ( OUTF , SCB . WAZAHL : 1 ) ;
             WRITELN ( OUTF , ' Warnung' ) ;
             if SCB . WAZAHL <> 1 then
               WRITE ( OUTF , 'en' ) ;
             ERSTAUSG := FALSE ;
           end (* then *) ;
         WRITELN ( OUTF , '.' ) ;
       end (* else *) ;
   end (* SOURCE_LISTING *) ;



procedure SCAN_READC ( var SCB : SCAN_BLOCK ; var CH : CHAR ) ;

   begin (* SCAN_READC *)
     while TRUE do
       begin
         if SCB . LINEPOS < SCB . LINELEN then
           begin
             SCB . LINEPOS := SCB . LINEPOS + 1 ;
             CH := SCB . SLINE [ SCB . LINEPOS ] ;
             SCB . ENDOFLINE := FALSE ;
             return ;
           end (* then *) ;
         if SCB . LINEPOS = SCB . LINELEN then
           begin
             SCB . LINEPOS := SCB . LINEPOS + 1 ;
             CH := ' ' ;
             SCB . ENDOFLINE := TRUE ;
             return ;
           end (* then *) ;
         if EOF ( SCANINP ) then
           begin
             SCB . DATEIENDE := 1 ;
             SCB . SLINE := ' ' ;
             SCB . LINENR := SCB . LINENR + 1 ;
             SCB . LINEPOS := 1 ;
             SCB . LINELEN := 0 ;
             return ;
           end (* then *) ;
         READLN ( SCANINP , SCB . SLINE ) ;
         SCB . LINENR := SCB . LINENR + 1 ;
         SCB . LINEPOS := 0 ;
         SCB . LINELEN := MAXLSIZE ;
         while TRUE do
           begin
             if SCB . LINELEN = 0 then
               break ;
             if SCB . SLINE [ SCB . LINELEN ] <> ' ' then
               break ;
             SCB . LINELEN := SCB . LINELEN - 1 ;
           end (* while *)
       end (* while *)
   end (* SCAN_READC *) ;



procedure SCAN_ERROR ( var SCB : SCAN_BLOCK ; ERRLEVEL : CHAR ;
                     ERRCLASS : CHAR ; I : INTEGER ; INFO : CHAR32 ;
                     ZEILNR : INTEGER ; PLATZ : INTEGER ) ;

   var PWORK : SCANF_PTR ;
       PSAVE : SCANF_PTR ;

   begin (* SCAN_ERROR *)

     /*****************************************************/
     /*   Fehlerelement in die Fehlerkette einfuegen      */
     /*****************************************************/

     case ERRLEVEL of
       'S' : SCB . SFZAHL := SCB . SFZAHL + 1 ;
       'W' : SCB . WAZAHL := SCB . WAZAHL + 1 ;
       'I' : SCB . INZAHL := SCB . INZAHL + 1 ;
       'O' : ;
       otherwise
         SCB . UFZAHL := SCB . UFZAHL + 1 ;
     end (* case *) ;
     if SCB . FEANFANG = NIL then
       begin
         SCB . FEANFANG := ALLOC ( SIZEOF ( SCAN_FEHLER ) ) ;
         SCB . FEAKT := SCB . FEANFANG ;
         SCB . FEAKT -> . ERRLEVEL := ERRLEVEL ;
         SCB . FEAKT -> . ERRCLASS := ERRCLASS ;
         SCB . FEAKT -> . NUMMER := I ;
         SCB . FEAKT -> . INFO := INFO ;
         SCB . FEAKT -> . ZEILNR := ZEILNR ;
         SCB . FEAKT -> . POSITION := PLATZ ;
         SCB . FEAKT -> . NAECHST := NIL ;
       end (* then *)
     else
       begin
         if ( SCB . FEAKT -> . ZEILNR < ZEILNR ) or ( ( SCB . FEAKT ->
         . ZEILNR = ZEILNR ) and ( SCB . FEAKT -> . POSITION <= PLATZ )
         ) then
           begin
             SCB . FEAKT -> . NAECHST := ALLOC ( SIZEOF ( SCAN_FEHLER )
                                         ) ;
             SCB . FEAKT := SCB . FEAKT -> . NAECHST ;
             SCB . FEAKT -> . ERRLEVEL := ERRLEVEL ;
             SCB . FEAKT -> . ERRCLASS := ERRCLASS ;
             SCB . FEAKT -> . NUMMER := I ;
             SCB . FEAKT -> . INFO := INFO ;
             SCB . FEAKT -> . ZEILNR := ZEILNR ;
             SCB . FEAKT -> . POSITION := PLATZ ;
             SCB . FEAKT -> . NAECHST := NIL ;
           end (* then *)
         else
           begin
             PWORK := SCB . FEANFANG ;
             if ( PWORK -> . ZEILNR < ZEILNR ) or ( ( PWORK -> . ZEILNR
             = ZEILNR ) and ( PWORK -> . POSITION <= PLATZ ) ) then
               begin
                 PWORK := SCB . FEANFANG ;
                 while ( PWORK -> . NAECHST -> . ZEILNR < ZEILNR ) or (
                 ( PWORK -> . NAECHST -> . ZEILNR = ZEILNR ) and (
                 PWORK -> . NAECHST -> . POSITION <= PLATZ ) ) do
                   PWORK := PWORK -> . NAECHST ;
                 PSAVE := PWORK -> . NAECHST ;
                 PWORK -> . NAECHST := ALLOC ( SIZEOF ( SCAN_FEHLER ) )
                                       ;
                 PWORK := PWORK -> . NAECHST ;
                 PWORK -> . ERRLEVEL := ERRLEVEL ;
                 PWORK -> . ERRCLASS := ERRCLASS ;
                 PWORK -> . NUMMER := I ;
                 PWORK -> . INFO := INFO ;
                 PWORK -> . ZEILNR := ZEILNR ;
                 PWORK -> . POSITION := PLATZ ;
                 PWORK -> . NAECHST := PSAVE ;
               end (* then *)
             else
               begin
                 PSAVE := SCB . FEANFANG ;
                 PWORK := ALLOC ( SIZEOF ( SCAN_FEHLER ) ) ;
                 PWORK -> . ERRLEVEL := ERRLEVEL ;
                 PWORK -> . ERRCLASS := ERRCLASS ;
                 PWORK -> . NUMMER := I ;
                 PWORK -> . INFO := INFO ;
                 PWORK -> . ZEILNR := ZEILNR ;
                 PWORK -> . POSITION := PLATZ ;
                 PWORK -> . NAECHST := PSAVE ;
                 SCB . FEANFANG := PWORK ;
               end (* else *)
           end (* else *)
       end (* else *)
   end (* SCAN_ERROR *) ;



procedure SCANNER ( var SCB : SCAN_BLOCK ) ;

   var ALTZUST : INTEGER ;
       ZUST : INTEGER ;
       CH : CHAR ;


   procedure SCANNER2 ( ALTZUST : INTEGER ; var SCB : SCAN_BLOCK ) ;

      begin (* SCANNER2 *)

        /***************************************************/
        /*   Symbol setzen abh. vom Endzustand             */
        /***************************************************/

        if SCB . DATEIENDE <> 0 then
          SCB . SYMBOLNR := SYMB_EOF
        else
          case ALTZUST of
            2 : SCB . SYMBOLNR := SEPARATOR ;
            10 : SCB . SYMBOLNR := COMMENT ;
            15 : SCB . SYMBOLNR := IDENT ;
            16 : SCB . SYMBOLNR := IDENT ;
            18 : SCB . SYMBOLNR := SYASSIGN ;
            19 : SCB . SYMBOLNR := SYKOMMA ;
            20 : SCB . SYMBOLNR := SYKLAMMAUF ;
            21 : SCB . SYMBOLNR := SYKLAMMZU ;
            24 : SCB . SYMBOLNR := SYRANGE ;
            25 : SCB . SYMBOLNR := SYPLUS ;
            26 : SCB . SYMBOLNR := SYMINUS ;
            27 : SCB . SYMBOLNR := SYMULT ;
            28 : SCB . SYMBOLNR := SYSTRIPU ;
            29 : SCB . SYMBOLNR := SYEQUAL ;
            30 : SCB . SYMBOLNR := SYSLASH ;
            32 : SCB . SYMBOLNR := STRING ;
          end (* case *) ;
        if FALSE then
          WRITELN ( 'zust = ' , ALTZUST , ' symb = ' , SCB . SYMBOLNR :
                    20 , ' ' , SCB . SYMBOL : SCB . LSYMBOL ) ;

        /***************************************************/
        /*   Umsetzen in Grossbuchstaben, wo gefordert     */
        /***************************************************/

        case SCB . SYMBOLNR of
          IDENT : SCAN_TOUPPER ( SCB ) ;
        end (* case *) ;

        /***************************************************/
        /*   Uebersetzen Keywords                          */
        /***************************************************/

        case SCB . SYMBOLNR of
          IDENT : begin
                    if SCB . SYMBOL = 'ALL' then
                      SCB . SYMBOLNR := SYALL
                    else
                      if SCB . SYMBOL = 'OR' then
                        SCB . SYMBOLNR := SYOR
                      else
                        if SCB . SYMBOL = 'IGNORE' then
                          SCB . SYMBOLNR := SYIGNORE
                        else
                          if SCB . SYMBOL = 'UPPER' then
                            SCB . SYMBOLNR := SYUPPER
                          else
                            if SCB . SYMBOL = 'KEY' then
                              SCB . SYMBOLNR := SYKEY
                  end (* tag/ca *) ;
        end (* case *) ;

        /*****************************************/
        /* ausgabe fuer -G- zunaechst ausgesetzt */
        /*****************************************/

      end (* SCANNER2 *) ;


   begin (* SCANNER *)
     SCB . SYMBOL := '' ;
     if SCB . MODUS > 0 then
       begin
         SCAN_READC ( SCB , CH ) ;
         SCB . LOOKAHEAD := CH ;
         SCB . MODUS := 0
       end (* then *)
     else
       CH := SCB . LOOKAHEAD ;
     if SCB . DATEIENDE <> 0 then
       begin
         SCB . DATEIENDE := SCB . DATEIENDE + 1 ;
         if SCB . DATEIENDE > 5 then
           SCAN_ERROR ( SCB , 'S' , 'S' , 1 , ' ' , SCB . LINENR , SCB
                        . LINEPOS ) ;
         SCB . SYMBOLNR := SYMB_EOF ;
         SCB . LSYMBOL := 1 ;
         SCB . SYMBOL [ 1 ] := CH ;
         return ;
       end (* then *) ;
     SCB . SYMBOLNR := SYMB_UNKNOWN ;
     SCB . LSYMBOL := 1 ;
     SCB . SYMBOL [ 1 ] := CH ;
     ZUST := 1 ;
     while ZUST > 0 do
       begin
         ALTZUST := ZUST ;
         case ZUST of
           10 : ZUST := - 1 ;
           18 : ZUST := - 1 ;
           19 : ZUST := - 1 ;
           20 : ZUST := - 1 ;
           21 : ZUST := - 1 ;
           24 : ZUST := - 1 ;
           25 : ZUST := - 1 ;
           26 : ZUST := - 1 ;
           27 : ZUST := - 1 ;
           28 : ZUST := - 1 ;
           29 : ZUST := - 1 ;
           1 : begin
                 if ( SCAN_CODE ( CH ) >= SCAN_CODE ( 'A' ) ) and (
                 SCAN_CODE ( CH ) <= SCAN_CODE ( 'Z' ) ) then
                   ZUST := 15
                 else
                   if ( SCAN_CODE ( CH ) >= SCAN_CODE ( 'a' ) ) and (
                   SCAN_CODE ( CH ) <= SCAN_CODE ( 'z' ) ) then
                     ZUST := 15
                   else
                     case CH of
                       ' ' : ZUST := 2 ;
                       '''' : ZUST := 11 ;
                       '(' : ZUST := 20 ;
                       ')' : ZUST := 21 ;
                       '*' : ZUST := 27 ;
                       '+' : ZUST := 25 ;
                       ',' : ZUST := 19 ;
                       '-' : ZUST := 26 ;
                       '.' : ZUST := 23 ;
                       '/' : ZUST := 30 ;
                       ':' : ZUST := 17 ;
                       ';' : ZUST := 28 ;
                       '=' : ZUST := 29 ;
                       otherwise
                         ZUST := - 1 ;
                     end (* case *) ;
               end (* tag/ca *) ;
           2 : begin
                 case CH of
                   ' ' : ZUST := 2 ;
                   otherwise
                     ZUST := - 1 ;
                 end (* case *) ;
               end (* tag/ca *) ;
           4 : begin
                 if ( SCAN_CODE ( CH ) >= 1 ) and ( SCAN_CODE ( CH ) <=
                 SCAN_CODE ( ')' ) ) then
                   ZUST := 5
                 else
                   if ( SCAN_CODE ( CH ) >= SCAN_CODE ( '+' ) ) and (
                   SCAN_CODE ( CH ) <= 255 ) then
                     ZUST := 5
                   else
                     case CH of
                       '*' : ZUST := 31 ;
                       otherwise
                         ZUST := - 1 ;
                     end (* case *) ;
               end (* tag/ca *) ;
           5 : begin
                 if ( SCAN_CODE ( CH ) >= 1 ) and ( SCAN_CODE ( CH ) <=
                 SCAN_CODE ( ')' ) ) then
                   ZUST := 5
                 else
                   if ( SCAN_CODE ( CH ) >= SCAN_CODE ( '+' ) ) and (
                   SCAN_CODE ( CH ) <= 255 ) then
                     ZUST := 5
                   else
                     case CH of
                       '*' : ZUST := 31 ;
                       otherwise
                         ZUST := - 1 ;
                     end (* case *) ;
               end (* tag/ca *) ;
           7 : begin
                 if ( SCAN_CODE ( CH ) >= 1 ) and ( SCAN_CODE ( CH ) <=
                 SCAN_CODE ( ')' ) ) then
                   ZUST := 8
                 else
                   if ( SCAN_CODE ( CH ) >= SCAN_CODE ( '+' ) ) and (
                   SCAN_CODE ( CH ) <= 255 ) then
                     ZUST := 8
                   else
                     case CH of
                       '*' : ZUST := 31 ;
                       otherwise
                         ZUST := - 1 ;
                     end (* case *) ;
               end (* tag/ca *) ;
           8 : begin
                 if ( SCAN_CODE ( CH ) >= 1 ) and ( SCAN_CODE ( CH ) <=
                 SCAN_CODE ( ')' ) ) then
                   ZUST := 8
                 else
                   if ( SCAN_CODE ( CH ) >= SCAN_CODE ( '+' ) ) and (
                   SCAN_CODE ( CH ) <= 255 ) then
                     ZUST := 8
                   else
                     case CH of
                       '*' : ZUST := 31 ;
                       otherwise
                         ZUST := - 1 ;
                     end (* case *) ;
               end (* tag/ca *) ;
           9 : begin
                 case CH of
                   '*' : ZUST := 9 ;
                   '/' : ZUST := 10 ;
                   otherwise
                     ZUST := - 1 ;
                 end (* case *) ;
               end (* tag/ca *) ;
           11 : begin
                  if ( SCAN_CODE ( CH ) >= 1 ) and ( SCAN_CODE ( CH )
                  <= 9 ) then
                    ZUST := 12
                  else
                    if ( SCAN_CODE ( CH ) >= 11 ) and ( SCAN_CODE ( CH
                    ) <= SCAN_CODE ( '&' ) ) then
                      ZUST := 12
                    else
                      if ( SCAN_CODE ( CH ) >= SCAN_CODE ( '(' ) ) and
                      ( SCAN_CODE ( CH ) <= 255 ) then
                        ZUST := 12
                      else
                        case CH of
                          '''' : ZUST := 32 ;
                          otherwise
                            ZUST := - 1 ;
                        end (* case *) ;
                end (* tag/ca *) ;
           12 : begin
                  if ( SCAN_CODE ( CH ) >= 1 ) and ( SCAN_CODE ( CH )
                  <= 9 ) then
                    ZUST := 12
                  else
                    if ( SCAN_CODE ( CH ) >= 11 ) and ( SCAN_CODE ( CH
                    ) <= SCAN_CODE ( '&' ) ) then
                      ZUST := 12
                    else
                      if ( SCAN_CODE ( CH ) >= SCAN_CODE ( '(' ) ) and
                      ( SCAN_CODE ( CH ) <= 255 ) then
                        ZUST := 12
                      else
                        case CH of
                          '''' : ZUST := 32 ;
                          otherwise
                            ZUST := - 1 ;
                        end (* case *) ;
                end (* tag/ca *) ;
           15 : begin
                  if ( SCAN_CODE ( CH ) >= SCAN_CODE ( '0' ) ) and (
                  SCAN_CODE ( CH ) <= SCAN_CODE ( '9' ) ) then
                    ZUST := 16
                  else
                    if ( SCAN_CODE ( CH ) >= SCAN_CODE ( 'A' ) ) and (
                    SCAN_CODE ( CH ) <= SCAN_CODE ( 'Z' ) ) then
                      ZUST := 16
                    else
                      if ( SCAN_CODE ( CH ) >= SCAN_CODE ( 'a' ) ) and
                      ( SCAN_CODE ( CH ) <= SCAN_CODE ( 'z' ) ) then
                        ZUST := 16
                      else
                        case CH of
                          '_' : ZUST := 16 ;
                          otherwise
                            ZUST := - 1 ;
                        end (* case *) ;
                end (* tag/ca *) ;
           16 : begin
                  if ( SCAN_CODE ( CH ) >= SCAN_CODE ( '0' ) ) and (
                  SCAN_CODE ( CH ) <= SCAN_CODE ( '9' ) ) then
                    ZUST := 16
                  else
                    if ( SCAN_CODE ( CH ) >= SCAN_CODE ( 'A' ) ) and (
                    SCAN_CODE ( CH ) <= SCAN_CODE ( 'Z' ) ) then
                      ZUST := 16
                    else
                      if ( SCAN_CODE ( CH ) >= SCAN_CODE ( 'a' ) ) and
                      ( SCAN_CODE ( CH ) <= SCAN_CODE ( 'z' ) ) then
                        ZUST := 16
                      else
                        case CH of
                          '_' : ZUST := 16 ;
                          otherwise
                            ZUST := - 1 ;
                        end (* case *) ;
                end (* tag/ca *) ;
           17 : begin
                  case CH of
                    '=' : ZUST := 18 ;
                    otherwise
                      ZUST := - 1 ;
                  end (* case *) ;
                end (* tag/ca *) ;
           23 : begin
                  case CH of
                    '.' : ZUST := 24 ;
                    otherwise
                      ZUST := - 1 ;
                  end (* case *) ;
                end (* tag/ca *) ;
           30 : begin
                  case CH of
                    '*' : ZUST := 4 ;
                    otherwise
                      ZUST := - 1 ;
                  end (* case *) ;
                end (* tag/ca *) ;
           31 : begin
                  if ( SCAN_CODE ( CH ) >= 1 ) and ( SCAN_CODE ( CH )
                  <= SCAN_CODE ( ')' ) ) then
                    ZUST := 7
                  else
                    if ( SCAN_CODE ( CH ) >= SCAN_CODE ( '0' ) ) and (
                    SCAN_CODE ( CH ) <= 255 ) then
                      ZUST := 7
                    else
                      case CH of
                        '*' : ZUST := 9 ;
                        '+' : ZUST := 7 ;
                        ',' : ZUST := 7 ;
                        '-' : ZUST := 7 ;
                        '.' : ZUST := 7 ;
                        '/' : ZUST := 10 ;
                        otherwise
                          ZUST := - 1 ;
                      end (* case *) ;
                end (* tag/ca *) ;
           32 : begin
                  case CH of
                    '''' : ZUST := 12 ;
                    otherwise
                      ZUST := - 1 ;
                  end (* case *) ;
                end (* tag/ca *) ;
           otherwise
             SCAN_ERROR ( SCB , 'S' , 'S' , 2 , ' ' , SCB . LINENR ,
                          SCB . LINEPOS ) ;
         end (* case *) ;
         if ZUST > 0 then
           begin
             SCAN_READC ( SCB , CH ) ;
             if SCB . DATEIENDE <> 0 then
               break ;
             SCB . LOOKAHEAD := CH ;
             if SCB . LSYMBOL < SCB . MAXLSYMBOL - 1 then
               begin
                 SCB . LSYMBOL := SCB . LSYMBOL + 1 ;
                 SCB . SYMBOL [ SCB . LSYMBOL ] := CH ;
               end (* then *)
           end (* then *)
       end (* while *) ;
     SCB . SYMBOL [ SCB . LSYMBOL ] := ' ' ;
     SCB . LSYMBOL := SCB . LSYMBOL - 1 ;
     SCANNER2 ( ALTZUST , SCB ) ;
   end (* SCANNER *) ;



begin (* HAUPTPROGRAMM *)
  MEMSET ( ADDR ( SCB ) , CHR ( 0 ) , SIZEOF ( SCB ) ) ;
  SCB . MAXLSYMBOL := MAXLSIZE ;
  SCB . MODUS := 1 ;
  SCB . SYMBOLNR := SYMB_UNKNOWN ;
  SCB . SLINE := ' ' ;
  SCB . LINENR := 0 ;
  SCB . LINEPOS := 1 ;
  SCB . LINELEN := 0 ;
  SCB . FEANFANG := NIL ;
  while SCB . SYMBOLNR <> SYMB_EOF do
    begin
      SCANNER ( SCB ) ;
      WRITELN ( 'pos = ' , SCB . LINENR : 4 , '/' , SCB . LINEPOS : 3 ,
                ' symb = ' , SCB . SYMBOLNR : 20 , ' ' , SCB . SYMBOL :
                SCB . LSYMBOL ) ;
      if SCB . SYMBOLNR = IDENT then
        begin
          INFO := ' ' ;
          for I := 1 to 32 do
            INFO [ I ] := SCB . SYMBOL [ I ] ;
          SCAN_ERROR ( SCB , 'I' , 'A' , 1 , INFO , SCB . LINENR , SCB
                       . LINEPOS ) ;
        end (* then *) ;
      if SCB . SYMBOLNR in [ SYKLAMMAUF , SYKLAMMZU ] then
        begin
          SCAN_ERROR ( SCB , 'I' , 'A' , 2 , ' ' , SCB . LINENR , SCB .
                       LINEPOS ) ;
        end (* then *) ;
    end (* while *) ;
  SOURCE_LISTING ( OUTPUT , SCB , TRUE ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSET  EXT PAS HEX -
program TESTSET ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



type FARBE = ( GELB , ROT , GRUEN , BLAU ) ;
     OPTYPE = ( PCTS , PCTI , PLOD , PSTR , PLDA , PLOC , PSTO , PLDC ,
              PLAB , PIND , PINC , PPOP , PCUP , PENT , PRET , PCSP ,
              PIXA , PEQU , PNEQ , PGEQ , PGRT , PLEQ , PLES , PUJP ,
              PFJP , PXJP , PCHK , PNEW , PADI , PADR , PSBI , PSBR ,
              PSCL , PFLT , PFLO , PTRC , PNGI , PNGR , PSQI , PSQR ,
              PABI , PABR , PNOT , PAND , PIOR , PDIF , PINT , PUNI ,
              PINN , PMOD , PODD , PMPI , PMPR , PDVI , PDVR , PMOV ,
              PLCA , PDEC , PSTP , PSAV , PRST , PCHR , PORD , PDEF ,
              PRND , PCRD , PXPO , PBGN , PEND , PASE , PSLD , PSMV ,
              PMST , PUXJ , PXLB , PCST , PDFC , PPAK , PADA , PSBA ,
              UNDEF_OP ) ;


var X : FARBE ;
    OPC : OPTYPE ;
    C : CHAR ;
    XSET : set of FARBE ;
    CSET : set of CHAR ;



function MAJOR ( CH : CHAR ) : CHAR ;

   begin (* MAJOR *)
     if CH in [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' ] then
       MAJOR := CHR ( ORD ( CH ) - ORD ( 'a' ) + ORD ( 'A' ) )
     else
       MAJOR := CH
   end (* MAJOR *) ;



function MINOR ( CH : CHAR ) : CHAR ;

   begin (* MINOR *)
     if CH in [ 'A' .. 'I' , 'J' .. 'R' , 'S' .. 'Z' ] then
       MINOR := CHR ( ORD ( CH ) - ORD ( 'A' ) + ORD ( 'a' ) )
     else
       MINOR := CH
   end (* MINOR *) ;



begin (* HAUPTPROGRAMM *)
  XSET := [ ] ;
  CSET := [ ] ;
  XSET := [ ROT , GRUEN ] ;
  CSET := [ 'B' , 'E' , 'R' , 'N' , 'D' ] ;
  for C := 'A' to 'Z' do
    if C in CSET then
      CSET := CSET + [ MINOR ( C ) ] ;
  CSET := CSET + [ 'o' , 'p' , 'p' , 'o' , 'l' , 'z' , 'e' , 'r' ] ;
  for C := 'a' to 'z' do
    if C in CSET then
      CSET := CSET + [ MAJOR ( C ) ] ;
  for C := CHR ( 0 ) to CHR ( 255 ) do
    if C in CSET then
      WRITE ( C ) ;
  WRITELN ;
  for X := GELB to BLAU do
    if X in XSET then
      WRITELN ( X ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSET1 EXT PAS HEX -
program TESTSET1 ( OUTPUT ) ;


const CH_CONST = X'4f' ;
      CH_BLANK = X'20' ;
      I_NEGATIV1 = - 13 ;
      I_NEGATIV2 = - 15 ;


type OPTYPE = ( PCTS , PCTI , PLOD , PSTR , PLDA , PLOC , PSTO , PLDC ,
              PLAB , PIND , PINC , PPOP , PCUP , PENT , PRET , PCSP ,
              PIXA , PEQU , PNEQ , PGEQ , PGRT , PLEQ , PLES , PUJP ,
              PFJP , PXJP , PCHK , PNEW , PADI , PADR , PSBI , PSBR ,
              PSCL , PFLT , PFLO , PTRC , PNGI , PNGR , PSQI , PSQR ,
              PABI , PABR , PNOT , PAND , PIOR , PDIF , PINT , PUNI ,
              PINN , PMOD , PODD , PMPI , PMPR , PDVI , PDVR , PMOV ,
              PLCA , PDEC , PSTP , PSAV , PRST , PCHR , PORD , PDEF ,
              PRND , PCRD , PXPO , PBGN , PEND , PASE , PSLD , PSMV ,
              PMST , PUXJ , PXLB , PCST , PDFC , PPAK , PADA , PSBA ,
              UNDEF_OP ) ;
     SET1 = set of CHAR ;
     SET2 = set of 'A' .. 'I' ;
     SET3 = set of '0' .. '9' ;
     FARBE = ( ROT , GELB , GRUEN , BLAU ) ;
     SET4 = set of FARBE ;
     SET5 = set of 10 .. 50 ;
     SET6 = set of 0 .. 255 ;
     SET7 = set of 100 .. 200 ;
     SET9 = set of 300 .. 400 ;
     SET10 = set of 0 .. 300 ;
     SET11 = set of 0 .. 1999 ;
     SET12 = set of OPTYPE ;
     TARRAY = array [ - 20 .. - 10 ] of INTEGER ;


const X1 : SET1 =
      [ 'A' .. 'J' , 'S' .. 'Z' ] ;
      X2 : SET1 =
      [ '3' .. '7' ] ;
      X5 : array [ 1 .. 5 ] of SET1 =
      ( [ '0' .. '9' ] , [ 'A' .. 'F' ] , [ 'J' .. 'M' ] , [ '0' .. '5'
        ] , [ 'S' .. 'V' ] ) ;


var S1 : SET1 ;
    S2 : SET2 ;
    S3 : SET3 ;
    S4 : SET4 ;
    S5 : SET5 ;
    S6 : SET6 ;
    S : SET6 ;
    S7 : SET7 ;
    S9 : SET9 ;
    S10 : SET10 ;
    S11 : SET11 ;
    S12 : SET12 ;
    I : INTEGER ;
    CH : CHAR ;
    R : REAL ;
    S21 : SET1 ;
    S24 : SET4 ;



procedure PRINT_SET ( S : SET1 ) ;

   var C : CHAR ;
       CP : -> CHAR ;
       I : INTEGER ;

   begin (* PRINT_SET *)
     WRITE ( 'set: ' ) ;
     for C := CHR ( 0 ) to CHR ( 255 ) do
       if C in S then
         WRITE ( C ) ;
     WRITELN ;
     WRITE ( 'set in hex: ' ) ;
     CP := ADDR ( S ) ;
     for I := 1 to 32 do
       begin
         WRITE ( ORD ( CP -> ) : 1 , ' ' ) ;
         CP := PTRADD ( CP , 1 ) ;
       end (* for *) ;
     WRITELN ;
   end (* PRINT_SET *) ;



procedure PRINT_SET6 ( S : SET6 ) ;

   var C : INTEGER ;
       CP : -> CHAR ;
       I : INTEGER ;

   begin (* PRINT_SET6 *)
     WRITE ( 'set: ' ) ;
     for C := 0 to 255 do
       if C in S then
         WRITE ( C : 1 , ' ' ) ;
     WRITELN ;
     WRITE ( 'set in hex: ' ) ;
     CP := ADDR ( S ) ;
     for I := 1 to 32 do
       begin
         WRITE ( ORD ( CP -> ) : 1 , ' ' ) ;
         CP := PTRADD ( CP , 1 ) ;
       end (* for *) ;
     WRITELN ;
   end (* PRINT_SET6 *) ;



procedure PRINT_SET5 ( S : SET5 ) ;

   var C : INTEGER ;
       CP : -> CHAR ;
       I : INTEGER ;

   begin (* PRINT_SET5 *)
     WRITE ( 'set: ' ) ;
     for C := 0 to 255 do
       if C in S then
         WRITE ( C : 1 , ' ' ) ;
     WRITELN ;
     WRITE ( 'set in hex: ' ) ;
     CP := ADDR ( S ) ;
     for I := 1 to 7 do
       begin
         WRITE ( ORD ( CP -> ) : 1 , ' ' ) ;
         CP := PTRADD ( CP , 1 ) ;
       end (* for *) ;
     WRITELN ;
   end (* PRINT_SET5 *) ;



begin (* HAUPTPROGRAMM *)
  WRITELN ( '-13 div 8 = ' , - 13 DIV 8 ) ;
  WRITELN ( '-13 mod 8 = ' , - 13 MOD 8 ) ;
  I := - 17 + 13 ;
  WRITELN ( 'i sollte -4 sein: ' , I ) ;
  R := - 3.2 + 0.4 ;
  WRITELN ( 'r sollte -2.8 sein: ' , R : 6 : 1 ) ;
  CH := 'A' ;
  S1 := [ 'J' .. 'R' , CH ] ;
  WRITELN ( 'test01' ) ;
  CH := 'A' ;
  S1 := [ 'B' , CH , 'A' .. 'R' , CH ] ;
  PRINT_SET ( S1 ) ;
  CH := 'A' ;
  WRITELN ( 'test02' ) ;
  S1 := X1 ;
  PRINT_SET ( S1 ) ;
  WRITELN ( 'test03' ) ;
  S1 := X2 ;
  PRINT_SET ( S1 ) ;

  /*****************************************/
  /*   WRITELN ( 'test04' ) ;              */
  /*   CH := 'A' ;                         */
  /*   S1 := [ 'B' , CH .. 'R' , CH ] ;    */
  /*   PRINT_SET ( S1 ) ;                  */
  /*   WRITELN ( 'test05' ) ;              */
  /*   CH := 'A' ;                         */
  /*   S1 := [ 'B' , 'A' .. CH ] ;         */
  /*   PRINT_SET ( S1 ) ;                  */
  /*****************************************/

  WRITELN ( 'test06' ) ;
  S1 := [ 'B' , 'A' .. CH_CONST ] ;
  PRINT_SET ( S1 ) ;
  WRITELN ( 'test07' ) ;
  S1 := [ 'B' , CH_BLANK .. 'A' ] ;
  PRINT_SET ( S1 ) ;
  WRITELN ( 'test08' ) ;
  S1 := [ 'J' .. 'R' ] ;
  PRINT_SET ( S1 ) ;
  WRITELN ( 'test09' ) ;
  PRINT_SET ( [ 'A' .. 'D' ] ) ;
  WRITELN ( 'test10' ) ;
  CH := 'X' ;
  S1 := [ CH ] ;
  PRINT_SET ( S1 ) ;
  WRITELN ( 'test11' ) ;
  S2 := [ 'C' .. 'E' ] ;
  PRINT_SET ( S2 ) ;
  WRITELN ( 'test12' ) ;
  S3 := [ '1' .. '6' ] ;
  S3 := S3 + [ '7' ] ;
  S3 := S3 - [ '5' ] ;
  PRINT_SET ( S3 ) ;
  S4 := [ GELB , BLAU ] ;
  WRITELN ( 'test13' ) ;
  S5 := [ 20 .. 30 ] ;
  S := S5 ;
  PRINT_SET5 ( S5 ) ;
  PRINT_SET6 ( S ) ;
  WRITELN ( 'test14' ) ;
  S6 := S5 ;
  S5 := S6 ;
  S := S6 ;
  PRINT_SET6 ( S ) ;
  WRITELN ( 'test15' ) ;
  S7 := [ 120 .. 140 ] ;
  S := S7 ;
  PRINT_SET6 ( S ) ;
  S12 := [ PADI , PADA ] ;

  /**************************/
  /* weitere aktionen: term */
  /**************************/

  S1 := X1 ;
  S1 := [ 'B' .. 'F' , 'T' , 'V' ] ;
  S1 := [ X'42' .. 'F' , 'T' , 'V' ] ;
  S1 := X1 * [ 'B' .. 'F' , 'T' , 'V' ] ;
  S1 := S21 ;
  S4 := [ GELB , BLAU ] ;
  S24 := [ ROT ] ;
  S4 := [ GELB , BLAU ] * S24 ;

  /**********************************/
  /* tests mit sets > 256 elementen */
  /**********************************/

  S9 := [ 320 .. 360 ] ;
  S11 := [ 1959 .. 1977 ] ;
  S10 := [ 270 .. 280 ] ;
  S10 := S10 + [ 100 .. 120 ] ;
  WRITELN ( 'test16' ) ;
  for I := 0 to 300 do
    if I in S10 then
      WRITE ( I : 1 , ' ' ) ;
  WRITELN ;
  WRITELN ( 'test17' ) ;
  for I := 0 to 2000 do
    if I in S11 then
      WRITE ( I : 1 , ' ' ) ;
  WRITELN ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSET2 EXT PAS HEX -
program TESTSET2 ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



type BUCHSTABE = 'A' .. 'Z' ;


var C : BUCHSTABE ;
    CSET : set of BUCHSTABE ;
    CSET2 : set of BUCHSTABE ;


begin (* HAUPTPROGRAMM *)
  CSET := [ ] ;
  CSET := [ 'B' , 'E' , 'R' , 'N' , 'D' ] ;
  WRITE ( 'Zeichen in CSET  = ' ) ;
  for C := 'A' to 'Z' do
    if C in CSET then
      WRITE ( C ) ;
  WRITELN ;
  CSET2 := CSET ;
  for C := 'A' to 'Z' do
    if C in CSET then
      begin
        CSET2 := CSET2 + [ PRED ( C ) ] ;
        CSET2 := CSET2 + [ SUCC ( C ) ] ;
      end (* then *) ;
  WRITE ( 'Zeichen in CSET2 = ' ) ;
  for C := 'A' to 'Z' do
    if C in CSET2 then
      WRITE ( C ) ;
  WRITELN ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSET4 EXT PAS HEX -
program TESTSET4 ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



type FARBE = ( GELB , ROT , GRUEN , BLAU ) ;
     SUB1 = 0 .. 255 ;


var X : FARBE ;
    XSET : set of FARBE ;
    CSET : set of FARBE ;
    SETA , SETB : set of SUB1 ;


begin (* HAUPTPROGRAMM *)
  XSET := [ ROT , GRUEN ] ;
  CSET := [ GELB , ROT , GRUEN , BLAU ] ;
  WRITELN ( 'should be true:  ' , XSET <= CSET ) ;
  WRITELN ( 'should be true:  ' , XSET <= XSET ) ;
  WRITELN ( 'should be false: ' , XSET >= CSET ) ;
  WRITELN ( 'should be true:  ' , XSET = XSET ) ;
  WRITELN ( 'should be false: ' , XSET = CSET ) ;
  WRITELN ( 'should be true:  ' , XSET = ( CSET * XSET ) ) ;

  //******************************************************************
  // WRITELN ( 'compile error:   ' , XSET < CSET ) ;
  //******************************************************************

  SETA := [ 2 , 3 , 5 , 7 ] ;
  SETB := [ 1 , 2 , 3 , 4 , 5 , 7 , 200 ] ;
  WRITELN ( 'should be true:  ' , SETA <= SETB ) ;
  WRITELN ( 'should be true:  ' , SETA <= SETA ) ;
  WRITELN ( 'should be false: ' , SETA >= SETB ) ;
  WRITELN ( 'should be true:  ' , SETA = SETA ) ;
  WRITELN ( 'should be false: ' , SETA = SETB ) ;
  WRITELN ( 'should be true:  ' , SETA = ( SETB * SETA ) ) ;

  //******************************************************************
  // WRITELN ( 'compile error:   ' , SETA < SETB ) ;
  //******************************************************************

end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSET5 EXT PAS HEX -
program TESTSET5 ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



type FARBE = ( GELB , ROT , GRUEN , BLAU ) ;


var XSET : set of FARBE ;
    CSET : set of FARBE ;



procedure PRINTSET ( X : set of FARBE ; Y : 0 .. 15 ) ;

   var F : FARBE ;

   begin (* PRINTSET *)
     WRITE ( 'test printset' ) ;
     WRITELN ;
     WRITE ( 'set = ' ) ;
     for F := GELB to BLAU do
       if F in X then
         WRITE ( F : 6 ) ;
     WRITELN ;
     WRITE ( 'y   = ' , Y ) ;
     WRITELN ;
   end (* PRINTSET *) ;



begin (* HAUPTPROGRAMM *)
  XSET := [ ROT , GRUEN ] ;
  CSET := [ GELB , ROT , GRUEN , BLAU ] ;
  PRINTSET ( XSET , 2 ) ;
  PRINTSET ( CSET , 4 ) ;

  //******************************************************************
  // range error:
  //******************************************************************
  // PRINTSET ( CSET , 30 ) ;

end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSET7 EXT PAS HEX -
program TESTSET7 ( OUTPUT ) ;

//*****
//$A+
//*****



var S : set of 0 .. 100 ;


begin (* HAUPTPROGRAMM *)
  S := [ 2 .. 10 , 12 , 15 ] ;
  if S = [ ] then
    WRITELN ( '1 leer' )
  else
    WRITELN ( '2 nicht leer' ) ;
  if S = [ 1 , 2 , 4 , 8 ] then
    WRITELN ( '3 passt' )
  else
    WRITELN ( '4 passt nicht' ) ;
  if S = [ 2 .. 10 , 12 , 15 ] then
    WRITELN ( '5 gleich' ) ;
  if S <> [ 2 .. 11 , 12 , 15 ] then
    WRITELN ( '6 ungleich' ) ;
  if S <= [ 2 .. 11 , 12 , 15 ] then
    WRITELN ( '7 kleiner' ) ;
  if S >= [ 2 .. 9 , 12 , 15 ] then
    WRITELN ( '8 groesser' ) ;
  if S = [ 2 .. 11 , 12 , 15 ] then
    WRITELN ( '9 gleich' ) ;
  if S <> [ 2 .. 10 , 12 , 15 ] then
    WRITELN ( '10 ungleich' ) ;
  if S <= [ 2 .. 9 , 12 , 15 ] then
    WRITELN ( '11 kleiner' ) ;
  if S >= [ 2 .. 11 , 12 , 15 ] then
    WRITELN ( '12 groesser' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSETH EXT PAS HEX -
program TESTSETH ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



const CH_CONST = X'D9' ;
      CH_BLANK = X'40' ;
      I_NEGATIV1 = - 13 ;
      I_NEGATIV2 = - 15 ;


type OPTYPE = ( PCTS , PCTI , PLOD , PSTR , PLDA , PLOC , PSTO , PLDC ,
              PLAB , PIND , PINC , PPOP , PCUP , PENT , PRET , PCSP ,
              PIXA , PEQU , PNEQ , PGEQ , PGRT , PLEQ , PLES , PUJP ,
              PFJP , PXJP , PCHK , PNEW , PADI , PADR , PSBI , PSBR ,
              PSCL , PFLT , PFLO , PTRC , PNGI , PNGR , PSQI , PSQR ,
              PABI , PABR , PNOT , PAND , PIOR , PDIF , PINT , PUNI ,
              PINN , PMOD , PODD , PMPI , PMPR , PDVI , PDVR , PMOV ,
              PLCA , PDEC , PSTP , PSAV , PRST , PCHR , PORD , PDEF ,
              PRND , PCRD , PXPO , PBGN , PEND , PASE , PSLD , PSMV ,
              PMST , PUXJ , PXLB , PCST , PDFC , PPAK , PADA , PSBA ,
              UNDEF_OP ) ;
     SET1 = set of CHAR ;
     SET2 = set of 'A' .. 'I' ;
     SET3 = set of '0' .. '9' ;
     FARBE = ( ROT , GELB , GRUEN , BLAU ) ;
     SET4 = set of FARBE ;
     SET5 = set of 10 .. 50 ;
     SET6 = set of 0 .. 255 ;
     SET7 = set of 100 .. 200 ;
     SET9 = set of 300 .. 400 ;
     SET10 = set of 0 .. 300 ;
     SET11 = set of 0 .. 1999 ;
     SET12 = set of OPTYPE ;
     TARRAY = array [ - 20 .. - 10 ] of INTEGER ;


const X1 : SET1 =
      [ 'A' .. 'J' , 'S' .. 'Z' ] ;
      X2 : SET1 =
      [ '3' .. '7' ] ;
      X5 : array [ 1 .. 5 ] of SET1 =
      ( [ '0' .. '9' ] , [ 'A' .. 'F' ] , [ 'J' .. 'M' ] , [ '0' .. '5'
        ] , [ 'S' .. 'V' ] ) ;


var S1 : SET1 ;
    S2 : SET2 ;
    S3 : SET3 ;
    S4 : SET4 ;
    S5 : SET5 ;
    S6 : SET6 ;
    S : SET6 ;
    S7 : SET7 ;
    S9 : SET9 ;
    S10 : SET10 ;
    S11 : SET11 ;
    S12 : SET12 ;
    I : INTEGER ;
    CH : CHAR ;
    R : REAL ;
    S21 : SET1 ;
    S24 : SET4 ;



procedure PRINT_SET ( S : SET1 ) ;

   var C : CHAR ;
       CP : -> CHAR ;
       I : INTEGER ;

   begin (* PRINT_SET *)
     WRITE ( 'set: ' ) ;
     for C := CHR ( 0 ) to CHR ( 255 ) do
       if C in S then
         WRITE ( C ) ;
     WRITELN ;
     WRITE ( 'set in hex: ' ) ;
     CP := ADDR ( S ) ;
     for I := 1 to 32 do
       begin
         WRITE ( ORD ( CP -> ) : 1 , ' ' ) ;
         CP := PTRADD ( CP , 1 ) ;
       end (* for *) ;
     WRITELN ;
   end (* PRINT_SET *) ;



procedure PRINT_SET6 ( S : SET6 ) ;

   var C : INTEGER ;
       CP : -> CHAR ;
       I : INTEGER ;

   begin (* PRINT_SET6 *)
     WRITE ( 'set: ' ) ;
     for C := 0 to 255 do
       if C in S then
         WRITE ( C : 1 , ' ' ) ;
     WRITELN ;
     WRITE ( 'set in hex: ' ) ;
     CP := ADDR ( S ) ;
     for I := 1 to 32 do
       begin
         WRITE ( ORD ( CP -> ) : 1 , ' ' ) ;
         CP := PTRADD ( CP , 1 ) ;
       end (* for *) ;
     WRITELN ;
   end (* PRINT_SET6 *) ;



procedure PRINT_SET5 ( S : SET5 ) ;

   var C : INTEGER ;
       CP : -> CHAR ;
       I : INTEGER ;

   begin (* PRINT_SET5 *)
     WRITE ( 'set: ' ) ;
     for C := 0 to 255 do
       if C in S then
         WRITE ( C : 1 , ' ' ) ;
     WRITELN ;
     WRITE ( 'set in hex: ' ) ;
     CP := ADDR ( S ) ;
     for I := 1 to 7 do
       begin
         WRITE ( ORD ( CP -> ) : 1 , ' ' ) ;
         CP := PTRADD ( CP , 1 ) ;
       end (* for *) ;
     WRITELN ;
   end (* PRINT_SET5 *) ;



begin (* HAUPTPROGRAMM *)
  WRITELN ( '-13 div 8 = ' , - 13 DIV 8 ) ;
  WRITELN ( '-13 mod 8 = ' , - 13 MOD 8 ) ;
  I := - 17 + 13 ;
  WRITELN ( 'i sollte -4 sein: ' , I ) ;
  R := - 3.2 + 0.4 ;
  WRITELN ( 'r sollte -2.8 sein: ' , R : 6 : 1 ) ;
  CH := 'A' ;
  S1 := [ 'J' .. 'R' , CH ] ;
  WRITELN ( 'test01' ) ;
  CH := 'A' ;
  S1 := [ 'B' , CH , 'A' .. 'R' , CH ] ;
  PRINT_SET ( S1 ) ;
  CH := 'A' ;
  WRITELN ( 'test02' ) ;
  S1 := X1 ;
  PRINT_SET ( S1 ) ;
  WRITELN ( 'test03' ) ;
  S1 := X2 ;
  PRINT_SET ( S1 ) ;

  /*****************************************/
  /*   WRITELN ( 'test04' ) ;              */
  /*   CH := 'A' ;                         */
  /*   S1 := [ 'B' , CH .. 'R' , CH ] ;    */
  /*   PRINT_SET ( S1 ) ;                  */
  /*   WRITELN ( 'test05' ) ;              */
  /*   CH := 'A' ;                         */
  /*   S1 := [ 'B' , 'A' .. CH ] ;         */
  /*   PRINT_SET ( S1 ) ;                  */
  /*****************************************/

  WRITELN ( 'test06' ) ;
  S1 := [ 'B' , 'A' .. CH_CONST ] ;
  PRINT_SET ( S1 ) ;
  WRITELN ( 'test07' ) ;
  S1 := [ 'B' , CH_BLANK .. 'A' ] ;
  PRINT_SET ( S1 ) ;
  WRITELN ( 'test08' ) ;
  S1 := [ 'J' .. 'R' ] ;
  PRINT_SET ( S1 ) ;
  WRITELN ( 'test09' ) ;
  PRINT_SET ( X1 ) ;
  PRINT_SET ( [ 'A' .. 'D' ] ) ;
  WRITELN ( 'test10' ) ;
  CH := 'X' ;
  S1 := [ CH ] ;
  PRINT_SET ( S1 ) ;
  WRITELN ( 'test11' ) ;
  S2 := [ 'C' .. 'E' ] ;
  PRINT_SET ( S2 ) ;
  WRITELN ( 'test12' ) ;
  S3 := [ '1' .. '6' ] ;
  S3 := S3 + [ '7' ] ;
  S3 := S3 - [ '5' ] ;
  PRINT_SET ( S3 ) ;
  S4 := [ GELB , BLAU ] ;
  WRITELN ( 'test13' ) ;
  S5 := [ 20 .. 30 ] ;
  S := S5 ;
  PRINT_SET5 ( S5 ) ;
  PRINT_SET6 ( S ) ;
  WRITELN ( 'test14' ) ;
  S6 := S5 ;
  S5 := S6 ;
  S := S6 ;
  PRINT_SET6 ( S ) ;
  WRITELN ( 'test15' ) ;
  S7 := [ 120 .. 140 ] ;
  S := S7 ;
  PRINT_SET6 ( S ) ;
  S12 := [ PADI , PADA ] ;

  /**************************/
  /* weitere aktionen: term */
  /**************************/

  S1 := X1 ;
  S1 := [ 'B' .. 'F' , 'T' , 'V' ] ;
  S1 := [ X'42' .. 'F' , 'T' , 'V' ] ;
  S1 := X1 * [ 'B' .. 'F' , 'T' , 'V' ] ;
  S1 := S21 ;
  S4 := [ GELB , BLAU ] ;
  S24 := [ ROT ] ;
  S4 := [ GELB , BLAU ] * S24 ;

  /**********************************/
  /* tests mit sets > 256 elementen */
  /**********************************/

  S9 := [ 320 .. 360 ] ;
  S11 := [ 1959 .. 1977 ] ;
  S10 := [ 270 .. 280 ] ;
  S10 := S10 + [ 100 .. 120 ] ;
  WRITELN ( 'test16' ) ;
  for I := 0 to 300 do
    if I in S10 then
      WRITE ( I : 1 , ' ' ) ;
  WRITELN ;
  WRITELN ( 'test17' ) ;
  for I := 0 to 2000 do
    if I in S11 then
      WRITE ( I : 1 , ' ' ) ;
  WRITELN ;
  if CH in [ '+' , '-' , '*' , '/' ] then
    WRITELN ( 'arithm. operator' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSETS EXT PAS HEX -
program TESTSETS ( OUTPUT ) ;


const CH_CONST = X'4f' ;
      CH_BLANK = X'20' ;
      I_NEGATIV1 = - 13 ;
      I_NEGATIV2 = - 15 ;


type OPTYPE = ( PCTS , PCTI , PLOD , PSTR , PLDA , PLOC , PSTO , PLDC ,
              PLAB , PIND , PINC , PPOP , PCUP , PENT , PRET , PCSP ,
              PIXA , PEQU , PNEQ , PGEQ , PGRT , PLEQ , PLES , PUJP ,
              PFJP , PXJP , PCHK , PNEW , PADI , PADR , PSBI , PSBR ,
              PSCL , PFLT , PFLO , PTRC , PNGI , PNGR , PSQI , PSQR ,
              PABI , PABR , PNOT , PAND , PIOR , PDIF , PINT , PUNI ,
              PINN , PMOD , PODD , PMPI , PMPR , PDVI , PDVR , PMOV ,
              PLCA , PDEC , PSTP , PSAV , PRST , PCHR , PORD , PDEF ,
              PRND , PCRD , PXPO , PBGN , PEND , PASE , PSLD , PSMV ,
              PMST , PUXJ , PXLB , PCST , PDFC , PPAK , PADA , PSBA ,
              UNDEF_OP ) ;
     SET1 = set of CHAR ;
     SET2 = set of 'A' .. 'I' ;
     SET3 = set of '0' .. '9' ;
     FARBE = ( ROT , GELB , GRUEN , BLAU ) ;
     SET4 = set of FARBE ;
     SET5 = set of 10 .. 50 ;
     SET6 = set of 0 .. 255 ;
     SET7 = set of 100 .. 200 ;
     SET8 = set of 10000 .. 11000 ;
     SET9 = set of 300 .. 400 ;
     SET10 = set of 0 .. 300 ;
     SET11 = set of - 20 .. - 10 ;
     SET12 = set of OPTYPE ;
     TARRAY = array [ - 20 .. - 10 ] of INTEGER ;


const X1 : SET1 =
      [ 'A' .. 'J' , 'S' .. 'Z' ] ;
      X2 : SET1 =
      [ '3' .. '7' ] ;
      X3 : SET8 =
      [ 10500 .. 10600 ] ;
      X4 : array [ 1 .. 3 ] of SET8 =
      ( [ 10100 .. 10200 ] , [ 10220 .. 10300 ] , [ 10500 .. 10600 ] )
        ;
      X5 : array [ 1 .. 5 ] of SET1 =
      ( [ '0' .. '9' ] , [ 'A' .. 'F' ] , [ 'J' .. 'M' ] , [ '0' .. '5'
        ] , [ 'S' .. 'V' ] ) ;


var S1 : SET1 ;
    S2 : SET2 ;
    S3 : SET3 ;
    S4 : SET4 ;
    S5 : SET5 ;
    S6 : SET6 ;
    S : SET6 ;
    S7 : SET7 ;
    S8 : SET8 ;
    S9 : SET9 ;
    S10 : SET10 ;
    S11 : SET11 ;
    S12 : SET12 ;
    I : INTEGER ;
    CH : CHAR ;
    R : REAL ;
    S21 : SET1 ;
    S24 : SET4 ;



procedure PRINT_SET ( S : SET1 ) ;

   var C : CHAR ;
       CP : -> CHAR ;
       I : INTEGER ;

   begin (* PRINT_SET *)
     WRITE ( 'set: ' ) ;
     for C := CHR ( 0 ) to CHR ( 255 ) do
       if C in S then
         WRITE ( C ) ;
     WRITELN ;
     WRITE ( 'set in hex: ' ) ;
     CP := ADDR ( S ) ;
     for I := 1 to 32 do
       begin
         WRITE ( ORD ( CP -> ) : 1 , ' ' ) ;
         CP := PTRADD ( CP , 1 ) ;
       end (* for *) ;
     WRITELN ;
   end (* PRINT_SET *) ;



procedure PRINT_SET2 ( S : SET6 ) ;

   var C : INTEGER ;
       CP : -> CHAR ;
       I : INTEGER ;

   begin (* PRINT_SET2 *)
     WRITE ( 'set: ' ) ;
     for C := 0 to 255 do
       if C in S then
         WRITE ( C ) ;
     WRITELN ;
     WRITE ( 'set in hex: ' ) ;
     CP := ADDR ( S ) ;
     for I := 1 to 32 do
       begin
         WRITE ( ORD ( CP -> ) : 1 , ' ' ) ;
         CP := PTRADD ( CP , 1 ) ;
       end (* for *) ;
     WRITELN ;
   end (* PRINT_SET2 *) ;



begin (* HAUPTPROGRAMM *)
  WRITELN ( '-13 div 8 = ' , - 13 DIV 8 ) ;
  WRITELN ( '-13 mod 8 = ' , - 13 MOD 8 ) ;
  I := - 17 + 13 ;
  WRITELN ( 'i sollte -4 sein: ' , I ) ;
  R := - 3.2 + 0.4 ;
  WRITELN ( 'r sollte -2.8 sein: ' , R : 6 : 1 ) ;
  CH := 'A' ;
  S1 := [ 'J' .. 'R' , CH ] ;
  CH := 'A' ;
  S1 := [ 'B' , CH , 'A' .. 'R' , CH ] ;
  CH := 'A' ;
  S1 := X1 ;
  S1 := X2 ;

  /*********************************/
  /* S1 := [ 'B', CH .. 'R', CH ]; */
  /*********************************/

  CH := 'A' ;

  /*******************************/
  /* S1 := [ 'B' , 'A' .. CH ] ; */
  /*******************************/

  S1 := [ 'B' , 'A' .. CH_CONST ] ;
  S1 := [ 'B' , CH_BLANK .. 'A' ] ;
  S1 := [ 'J' .. 'R' ] ;

  (**********************************)
  (* PRINT_SET ( [ 'A' .. 'D' ] ) ; *)
  (**********************************)

  PRINT_SET ( S1 ) ;
  CH := 'X' ;
  S1 := [ CH ] ;
  PRINT_SET ( S1 ) ;
  S2 := [ 'C' .. 'E' ] ;
  PRINT_SET ( S2 ) ;
  S3 := [ '1' .. '6' ] ;
  S3 := S3 + [ '7' ] ;
  S3 := S3 - [ '5' ] ;
  PRINT_SET ( S3 ) ;
  S4 := [ GELB , BLAU ] ;
  S5 := [ 20 .. 30 ] ;
  S := S5 ;
  PRINT_SET2 ( S ) ;
  S6 := S5 ;
  S5 := S6 ;
  S := S6 ;
  PRINT_SET2 ( S ) ;
  S7 := [ 120 .. 140 ] ;
  S := S7 ;
  PRINT_SET2 ( S ) ;
  S11 := [ I_NEGATIV1 , I_NEGATIV2 ] ;
  S11 := [ - 13 , - 15 , - 17 .. - 12 ] ;
  S12 := [ PADI , PADA ] ;
  for I := - 20 to - 10 do
    if I in S11 then
      WRITE ( I : 1 ) ;
  WRITELN ;
  S8 := [ 10100 .. 10200 , 10300 .. 10400 ] ;

  /**************************/
  /* weitere aktionen: term */
  /**************************/

  S1 := X1 ;
  S1 := [ 'B' .. 'F' , 'T' , 'V' ] ;
  S1 := [ x'42' .. 'F' , 'T' , 'V' ] ;
  S1 := X1 * [ 'B' .. 'F' , 'T' , 'V' ] ;
  S1 := S21 ;
  S4 := [ GELB , BLAU ] ;
  S24 := [ ROT ] ;
  S4 := [ GELB , BLAU ] * S24 ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSIN  EXT PAS HEX -
program TESTSIN ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



var X : REAL ;


begin (* HAUPTPROGRAMM *)
  X := SIN ( 3.141592654 / 2 ) ;
  X := 1.5 ;
  X := SIN ( X ) ;
  WRITELN ( 'SIN (1.5) = ' , X : 15 : 7 ) ;
  WRITELN ( 'SIN (1.0) = ' , SIN ( 1.0 ) : 15 : 7 ) ;
  WRITELN ( 'SIN (pi/2) = ' , SIN ( 3.141592654 / 2 ) : 15 : 7 ) ;
  X := 0 ;
  while X < 7.0 do
    begin
      WRITELN ( 'SIN (' , X : 2 : 1 , ') = ' , SIN ( X ) : 15 : 7 ) ;
      X := X + 0.2
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSIN2 EXT PAS HEX -
program TESTSIN2 ( OUTPUT ) ;

(**********************************************************************)
(*$A+                                                                 *)
(**********************************************************************)



var X : REAL ;



function F1 ( X : REAL ) : REAL ;

   begin (* F1 *)
     F1 := X * X
   end (* F1 *) ;



function F2 ( X : REAL ) : REAL ;

   begin (* F2 *)
     F2 := SIN ( X )
   end (* F2 *) ;



procedure F3 ( X1 : REAL ; X2 : REAL ; function F ( Y : REAL ) : REAL )
             ;

   var X : REAL ;

   begin (* F3 *)
     X := X1 ;
     while X <= X2 do
       begin
         WRITELN ( 'funktion f: ' , X : 10 : 2 , F ( X ) : 10 : 2 ) ;
         X := X + 0.1 ;
       end (* while *)
   end (* F3 *) ;



begin (* HAUPTPROGRAMM *)
  X := 1.0 ;
  while X <= 3.0 do
    begin
      WRITELN ( 'funktion f: ' , X : 10 : 2 , F2 ( X ) : 10 : 2 ) ;
      X := X + 0.1 ;
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSKIP EXT PAS HEX -
program TESTSET7 ( OUTPUT ) ;

//*****
//$A+
//*****



var S : set of 0 .. 100 ;


this is nonsense, should be skipped
more nonsense


more nonsense  begin (* HAUPTPROGRAMM *)
  S := [ 2 .. 10 , 12 , 15 ] ;
  if S = [ ] then do symbol is wrong here
    WRITELN ( '1 leer' )
  end
  else
    WRITELN ( '2 nicht leer' ) ;
  if S = [ 1 , 2 , 4 , 8 ] erroneous symbols inserted here
  then
    WRITELN ( '3 passt' ) ;
  else
    WRITELN ( '4 passt nicht' ) ;
  if S = [ 2 .. 10 , 12 , 15 ] then
    WRITELN ( '5 gleich' ) ;
  if S <> [ 2 .. 11 , 12 , 15 ] then
    WRITELN ( '6 ungleich' ) ;
  if S <= [ 2 .. 11 , 12 , 15 ] then
    WRITELN ( '7 kleiner' ) ;
  if S >= [ 2 .. 9 , 12 , 15 ] then
    WRITELN ( '8 groesser' ) ;
  if S = [ 2 .. 11 , 12 , 15 ] then
    WRITELN ( '9 gleich' ) ;
  if S <> [ 2 .. 10 , 12 , 15 ] then
    WRITELN ( '10 ungleich' ) ;
  if S <= [ 2 .. 9 , 12 , 15 ] then
    WRITELN ( '11 kleiner' ) ;
  if S >= [ 2 .. 11 , 12 , 15 ] then
    WRITELN ( '12 groesser' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSNA1 EXT PAS HEX -
program TEST1 ( OUTPUT ) ;

/********/
/*$N+,A+*/
/********/



type CHARSET = packed array [ CHAR ] of CHAR ;
     MNEM_TABLE = array [ 0 .. 255 ] of array [ 1 .. 4 ] of CHAR ;
     INTPTR = -> INTEGER ;

     (*****************************************************************)
     (*                                                               *)
     (*    WIR TESTEN HIER MAL EINEN GROESSEREN KOMMENTAR             *)
     (*    DER UEBER MEHRERE ZEILEN GEHT ..................           *)
     (*                                                               *)
     (*****************************************************************)



var CH : CHAR ;
    X : CHARSET ;
    F : packed array [ 1 .. 6 ] of CHAR ;
    I : INTEGER ;
    ZTBLN : MNEM_TABLE ;


const Y : array [ 1 .. 5 ] of INTEGER =
      ( 4 , 5 , 7 , 9 , 12 ) ;
      XTBLN : MNEM_TABLE =
      ( '(00)' , '(01)' , '(02)' , '(03)' , 'SPM ' , 'BALR' , 'BCTR' ,
        'BCR ' , 'SSK ' , 'ISK ' , 'SVC ' , '(0B)' , '(0C)' , '(0D)' ,
        'MVCL' , 'CLCL' , 'LPR ' , 'LNR ' , 'LTR ' , 'LCR ' , 'NR  ' ,
        'CLR ' , 'OR  ' , 'XR  ' , 'LR  ' , 'CR  ' , 'AR  ' , 'SR  ' ,
        'MR  ' , 'DR  ' , 'ALR ' , 'SLR ' , 'LPDR' , 'LNDR' , 'LTDR' ,
        'LCDR' , 'HDR ' , 'LRDR' , 'MXR ' , 'MXDR' , 'LDR ' , 'CDR ' ,
        'ADR ' , 'SDR ' , 'MDR ' , 'DDR ' , 'AWR ' , 'SWR ' , 'LPER' ,
        'LNER' , 'LTER' , 'LCER' , 'HER ' , 'LRER' , 'AXR ' , 'SXR ' ,
        'LER ' , 'CER ' , 'AER ' , 'SER ' , 'MER ' , 'DER ' , 'AUR ' ,
        'SUR ' , 'STH ' , 'LA  ' , 'STC ' , 'IC  ' , 'EX  ' , 'BAL ' ,
        'BCT ' , 'BC  ' , 'LH  ' , 'CH  ' , 'AH  ' , 'SH  ' , 'MH  ' ,
        '(4D)' , 'CVD ' , 'CVB ' , 'ST  ' , '(51)' , '(52)' , '(53)' ,
        'N   ' , 'CL  ' , 'O   ' , 'X   ' , 'L   ' , 'C   ' , 'A   ' ,
        'S   ' , 'M   ' , 'D   ' , 'AL  ' , 'SL  ' , 'STD ' , '(61)' ,
        '(62)' , '(63)' , '(64)' , '(65)' , '(66)' , 'MXD ' , 'LD  ' ,
        'CD  ' , 'AD  ' , 'SD  ' , 'MD  ' , 'DD  ' , 'AW  ' , 'SW  ' ,
        'STE ' , '(71)' , '(72)' , '(73)' , '(74)' , '(75)' , '(76)' ,
        '(77)' , 'LE  ' , 'CE  ' , 'AE  ' , 'SE  ' , 'ME  ' , 'DE  ' ,
        'AU  ' , 'SU  ' , 'SSM ' , '(81)' , 'LPSW' , 'DIAG' , 'WRD ' ,
        'RDD ' , 'BXH ' , 'BXLE' , 'SRL ' , 'SLL ' , 'SRA ' , 'SLA ' ,
        'SRDL' , 'SLDL' , 'SRDA' , 'SLDA' , 'STM ' , 'TM  ' , 'MVI ' ,
        'TS  ' , 'NI  ' , 'CLI ' , 'OI  ' , 'XI  ' , 'LM  ' , '(99)' ,
        '(9A)' , '(9B)' , 'SIO ' , 'TIO ' , 'HIO ' , 'TCH ' , '(A0)' ,
        '(A1)' , '(A2)' , '(A3)' , '(A4)' , '(A5)' , '(A6)' , '(A7)' ,
        '(A8)' , '(A9)' , '(AA)' , '(AB)' , '(AC)' , '(AD)' , '(AE)' ,
        '(AF)' , '(B0)' , 'LRA ' , 'STCK' , '(B3)' , '(B4)' , '(B5)' ,
        'STCT' , 'LCTL' , '(B8)' , '(B9)' , '(BA)' , '(BB)' , '(BC)' ,
        'CLM ' , 'STCM' , 'ICM ' , '(C0)' , '(C1)' , '(C2)' , '(C3)' ,
        '(C4)' , '(C5)' , '(C6)' , '(C7)' , '(C8)' , '(C9)' , '(CA)' ,
        '(CB)' , '(CC)' , '(CD)' , '(CE)' , '(CF)' , '(D0)' , 'MVN ' ,
        'MVC ' , 'MVZ ' , 'NC  ' , 'CLC ' , 'OC  ' , 'XC  ' , '(D8)' ,
        '(D9)' , '(DA)' , '(DB)' , 'TR  ' , 'TRT ' , 'ED  ' , 'EDMK' ,
        '(E0)' , '(E1)' , '(E2)' , '(E3)' , '(E4)' , '(E5)' , '(E6)' ,
        '(E7)' , '(E8)' , '(E9)' , '(EA)' , '(EB)' , '(EC)' , '(ED)' ,
        '(EE)' , '(EF)' , 'SRP ' , 'MVO ' , 'PACK' , 'UNPK' , '(F4)' ,
        '(F5)' , '(F6)' , '(F7)' , 'ZAP ' , 'CP  ' , 'AP  ' , 'SP  ' ,
        'MP  ' , 'DP  ' , '(FE)' , '(FF)' ) ;



procedure CHARSET_INI ( var X : CHARSET ) ;

   var CH : CHAR ;

   begin (* CHARSET_INI *)

     (********************************************)
     (* HIER SIND NEUERDINGS KOMMENTARE MOEGLICH *)
     (********************************************)

     for CH := CHR ( 0 ) to CHR ( 255 ) do
       X [ CH ] := ' '
   end (* CHARSET_INI *) ;



procedure CHARSET_ADD ( var X : CHARSET ; VON : CHAR ; BIS : CHAR ) ;

   var CH : CHAR ;

   begin (* CHARSET_ADD *)
     for CH := VON to BIS do
       begin
         if CH = 'F' then
           return ;
         X [ CH ] := 'J'
       end (* for *)
   end (* CHARSET_ADD *) ;



function IN_CHARSET ( var X : CHARSET ; SUCH : CHAR ) : BOOLEAN ;

   begin (* IN_CHARSET *)
     SNAPSHOT ( 5 , 10 ) ;
     IN_CHARSET := ( X [ SUCH ] <> ' ' ) ;
   end (* IN_CHARSET *) ;



function IN_CHARSET1 ( var X : CHARSET ; SUCH : CHAR ; ZUSATZ : CHAR )
                     : BOOLEAN ;

   begin (* IN_CHARSET1 *)
     IN_CHARSET1 := ( X [ SUCH ] <> ' ' ) or ( SUCH = ZUSATZ ) ;
   end (* IN_CHARSET1 *) ;



begin (* HAUPTPROGRAMM *)

  (***********************************)
  (* DIESER KOMM SOLL STEHEN BLEIBEN *)
  (***********************************)

  WRITELN ( 'DATE=' , DATE ) ;

  /*****************************************/
  /* CONTINUE; /* -- YIELDS ERROR E71 -- */*/
  /*****************************************/

  ZTBLN := XTBLN ;
  F := 'BERND ' ;
  for I := 1 to 6 do
    begin
      if F [ I ] = 'D' then
        break ;
      if F [ I ] = 'E' then
        continue ;
      WRITELN ( 'FOR-SCHLEIFE: I = ' , I : 3 , ' F(I) = ' , F [ I ] ) ;
    end (* for *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  while F [ I ] <> ' ' do
    begin
      if F [ I ] = 'D' then
        break ;
      if F [ I ] = 'R' then
        begin
          I := I + 1 ;
          continue
        end (* then *) ;
      WRITELN ( 'WHILE-SCHLEIFE: I = ' , I : 3 ) ;
      I := I + 1 ;
    end (* while *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  repeat
    if F [ I ] = 'D' then
      break ;
    if F [ I ] = 'R' then
      begin
        I := I + 1 ;
        continue
      end (* then *) ;
    WRITELN ( 'REPEAT-SCHLEIFE: I = ' , I : 3 ) ;
    I := I + 1 ;
  until F [ I ] = ' ' ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  F := 'BERND ' ;
  for I := 1 to 6 do
    begin
      WRITELN ( 'FOR-SCHLEIFE: I = ' , I : 3 , ' F(I) = ' , F [ I ] ) ;
      break ;

  (*****************************)
  (* DIESER KOMM BLEIBT STEHEN *)
  (*****************************)

    end (* for *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  while F [ I ] <> ' ' do
    begin
      WRITELN ( 'WHILE-SCHLEIFE: I = ' , I : 3 ) ;
      I := I + 1 ;
      break ;
    end (* while *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  repeat
    WRITELN ( 'REPEAT-SCHLEIFE: I = ' , I : 3 ) ;
    I := I + 1 ;
    break ;
  until F [ I ] = ' ' ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  F := 'BERND ' ;
  for I := 1 to 6 do
    begin
      WRITELN ( 'FOR-SCHLEIFE: I = ' , I : 3 , ' F(I) = ' , F [ I ] ) ;
      continue ;
    end (* for *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  while F [ I ] <> ' ' do
    begin
      WRITELN ( 'WHILE-SCHLEIFE: I = ' , I : 3 ) ;
      I := I + 1 ;
      continue ;
    end (* while *) ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  I := 1 ;
  repeat
    WRITELN ( 'REPEAT-SCHLEIFE: I = ' , I : 3 ) ;
    I := I + 1 ;
    continue ;
  until F [ I ] = ' ' ;
  WRITELN ( 'I NACH DER SCHLEIFE =' , I : 5 ) ;
  CHARSET_INI ( X ) ;
  CHARSET_ADD ( X , 'A' , 'Z' ) ;
  CH := 'A' ;
  WRITELN ( 'ORD VON A = ' , ORD ( CH ) ) ;
  WRITELN ( 'AUSGABE VON X:' ) ;
  WRITELN ( X ) ;
  WRITELN ( 'ENDE AUSGABE VON X' ) ;
  WRITELN ( F ) ;

  /*********/
  /*RETURN;*/
  /*********/

  WRITELN ( 'BUCHSTABE A IN X: ' , IN_CHARSET ( X , 'A' ) ) ;
  WRITELN ( 'ZIFFER 5 IN X: ' , IN_CHARSET ( X , '5' ) ) ;

  (*************************)
  (* KOMMENTAR ZUM SCHLUSS *)
  (*************************)

  for I := 0 to 255 do
    WRITELN ( I , ' = ' , XTBLN [ I ] ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSNA2 EXT PAS HEX -
program TESTSNAP ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



type POS_INT = 0 .. 30 ;


var I : POS_INT ;
    TIME : INTEGER ;


static TESTDUMP : INTEGER ;
       TESTCHAR : array [ 1 .. 10 ] of CHAR ;



function FIBONACCI ( J : POS_INT ) : INTEGER ;

(******************************)
(* to evaluate fibonacci # j, *)
(* for j >= 0                 *)
(* subject to int overflow    *)
(******************************)


   static ANZCALL : INTEGER ;

   var CP : -> CHAR ;
       C : CHAR ;

   begin (* FIBONACCI *)
     ANZCALL := ANZCALL + 1 ;
     if J = 5 then
       begin
         CP := ADDR ( C ) ;
         CP := PTRADD ( CP , 8000000 ) ;
         CP -> := 'A' ;
       end (* then *) ;
     if J = 0 then
       FIBONACCI := 0
     else
       if J = 1 then
         FIBONACCI := 1
       else
         FIBONACCI := FIBONACCI ( J - 1 ) + FIBONACCI ( J - 3 ) ;
   end (* FIBONACCI *) ;



begin (* HAUPTPROGRAMM *)
  TESTDUMP := 42 ;
  TESTCHAR := 'Oppolzer' ;
  for I := 10 to 25 do
    begin
      TIME := CLOCK ( 0 ) ;
      WRITELN ( ' fibonacci # ' , I : 3 , ' is ' , FIBONACCI ( I ) : 8
                , ' (Comp.time = ' , CLOCK ( 0 ) - TIME : 5 ,
                ' Milli Sec.)' ) ;
    end (* for *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSNA3 EXT PAS HEX -
program TESTSNAP ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



type POS_INT = 0 .. 30 ;


var I : POS_INT ;
    TIME : INTEGER ;


static TESTDUMP : INTEGER ;
       TESTCHAR : array [ 1 .. 10 ] of CHAR ;



function FIBONACCI ( J : POS_INT ) : INTEGER ;

(******************************)
(* to evaluate fibonacci # j, *)
(* for j >= 0                 *)
(* subject to int overflow    *)
(******************************)


   static ANZCALL : INTEGER ;

   var CP : -> CHAR ;
       C : CHAR ;

   begin (* FIBONACCI *)
     ANZCALL := ANZCALL + 1 ;
     if J = 0 then
       FIBONACCI := 0
     else
       if J = 1 then
         FIBONACCI := 1
       else
         FIBONACCI := FIBONACCI ( J - 1 ) + FIBONACCI ( J - 3 ) ;
   end (* FIBONACCI *) ;



begin (* HAUPTPROGRAMM *)
  TESTDUMP := 42 ;
  TESTCHAR := 'Oppolzer' ;
  for I := 10 to 25 do
    begin
      TIME := CLOCK ( 0 ) ;
      WRITELN ( ' fibonacci # ' , I : 3 , ' is ' , FIBONACCI ( I ) : 8
                , ' (Comp.time = ' , CLOCK ( 0 ) - TIME : 5 ,
                ' Milli Sec.)' ) ;
    end (* for *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSNAP EXT PAS HEX -
program TESTSNAP ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



type POS_INT = 0 .. 30 ;


var I : POS_INT ;
    TIME : INTEGER ;


static TESTDUMP : INTEGER ;
       TESTCHAR : array [ 1 .. 10 ] of CHAR ;



function FIBONACCI ( J : POS_INT ) : INTEGER ;

(******************************)
(* to evaluate fibonacci # j, *)
(* for j >= 0                 *)
(* subject to int overflow    *)
(******************************)


   static ANZCALL : INTEGER ;

   var CP : -> CHAR ;
       C : CHAR ;

   begin (* FIBONACCI *)
     ANZCALL := ANZCALL + 1 ;
     if J = 5 then
       begin
         CP := ADDR ( C ) ;
         CP := PTRADD ( CP , 8000000 ) ;
         CP -> := 'A' ;
       end (* then *) ;
     if J = 0 then
       FIBONACCI := 0
     else
       if J = 1 then
         FIBONACCI := 1
       else
         FIBONACCI := FIBONACCI ( J - 1 ) + FIBONACCI ( J - 3 ) ;
   end (* FIBONACCI *) ;



begin (* HAUPTPROGRAMM *)
  TESTDUMP := 42 ;
  TESTCHAR := 'Oppolzer' ;
  for I := 10 to 25 do
    begin
      TIME := CLOCK ( 0 ) ;
      WRITELN ( ' fibonacci # ' , I : 3 , ' is ' , FIBONACCI ( I ) : 8
                , ' (Comp.time = ' , CLOCK ( 0 ) - TIME : 5 ,
                ' Milli Sec.)' ) ;
    end (* for *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSPA  EXT PAS HEX -
program TESTSPA ( OUTPUT ) ;

type R = record
           X : CHAR ( 80 ) ;
         end ;

var TAB : array [ 1 .. 40000 ] of R ;
    SZ : INTEGER ;

begin (* HAUPTPROGRAMM *)
  SZ := SIZEOF ( TAB ) ;
  MEMSET ( ADDR ( TAB ) , ' ' , SZ ) ;
  WRITELN ( 'size = ' , SZ )
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSPL  EXT PAS HEX -
program TESTSPL ( INFILE , OUTFILE , OUTPUT ) ;


var INFILE : TEXT ;
    OUTFILE : TEXT ;
    ZEILE : STRING ( 5000 ) ;
    ZEILE_ALT : STRING ( 5000 ) ;
    ZNEU : STRING ( 1000 ) ;
    LINENO : INTEGER ;
    LNO1 : CHAR ( 6 ) ;
    LNO2 : STRING ( 6 ) ;
    IX1 , IX2 , L1 , L2 : INTEGER ;
    ANFANG : BOOLEAN ;



procedure INTTOSTR ( CP : VOIDPTR ; LEN : INTEGER ; VAL : INTEGER ;
                   ZEROES : BOOLEAN ) ;

   EXTERNAL ;



begin (* HAUPTPROGRAMM *)
  RESET ( INFILE ) ;
  REWRITE ( OUTFILE ) ;
  LINENO := 1 ;
  ANFANG := TRUE ;
  INTTOSTR ( ADDR ( LNO1 ) , 6 , LINENO , FALSE ) ;
  LNO2 := STR ( LNO1 ) ;
  LNO2 := TRIM ( LNO2 ) ;
  ZEILE_ALT := '' ;
  while not EOF ( INFILE ) do
    begin
      READLN ( INFILE , ZEILE ) ;
      ZEILE := ZEILE_ALT || ZEILE ;
      WRITELN ( 'neue Zeile: ' , ZEILE ) ;
      if ANFANG then
        begin
          IX1 := INDEX ( ZEILE , LNO2 ) ;
          L1 := LENGTH ( LNO2 ) ;
          ANFANG := FALSE ;
        end (* then *) ;
      repeat
        LINENO := LINENO + 1 ;
        INTTOSTR ( ADDR ( LNO1 ) , 6 , LINENO , FALSE ) ;
        LNO2 := STR ( LNO1 ) ;
        LNO2 := TRIM ( LNO2 ) ;
        IX2 := INDEX ( ZEILE , LNO2 ) ;
        L2 := LENGTH ( LNO2 ) ;
        if IX2 <> 0 then
          begin
            ZNEU := SUBSTR ( ZEILE , IX1 + L1 , IX2 - IX1 - L1 ) ;
            WRITELN ( 'gefunden fuer ' , LNO2 , ': ' , ZNEU ) ;
            WRITELN ( OUTFILE , ZNEU ) ;
            ZEILE := SUBSTR ( ZEILE , IX2 ) ;
            IX1 := 1 ;
            L1 := L2 ;
          end (* then *)
        else
          begin
            WRITELN ( 'nichts gefunden fuer ' , LNO2 ) ;
            ZEILE_ALT := ZEILE ;
            IX1 := 1 ;
            LINENO := LINENO - 1 ;
          end (* else *)
      until IX2 = 0 ;
    end (* while *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSQRT EXT PAS HEX -
program TESTSQRT ( OUTPUT ) ;


var I : INTEGER ;
    R : REAL ;


begin (* HAUPTPROGRAMM *)
  for I := 1 to 20 do
    begin
      R := I ;
      WRITELN ( 'the sqrt of ' , I : 4 , ' is ' , SQRT ( R ) : 15 : 13
                ) ;
    end (* for *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSTA2 EXT PAS HEX -
program TESTSTA2 ( INPUT , OUTPUT , PCODE , LISTING , LISTDEF , DBGINFO
                   , TRACEF ) ;

(********************************************************************)
(*$D+,N+,A+                                                         *)
(********************************************************************)
(*                                                                  *)
(*         S T A N F O R D   P A S C A L   C O M P I L E R          *)
(*                                                                  *)
(*              OPPOLZER VERSION                                    *)
(*                                                                  *)
(*                                                                  *)
(*         AUTHOR OF ORIGINAL PROGRAM:                              *)
(*                                                                  *)
(*              URS AMMANN                                          *)
(*              FACHGRUPPE COMPUTERWISSENSCHAFTEN                   *)
(*              EIDG. TECHNISCHE HOCHSCHULE                         *)
(*              CH-8006 ZUERICH                                     *)
(*                                                                  *)
(*                                                                  *)
(*         AUTHOR OF SECOND VERSION:                                *)
(*                                                                  *)
(*              KESAV NORI                                          *)
(*              COMPUTER GROUP                                      *)
(*              T.I.F.R.                                            *)
(*              HOMI BHABHA ROAD                                    *)
(*              BOMBAY - 400005                                     *)
(*              INDIA                                               *)
(*                                                                  *)
(*                                                                  *)
(*         AUTHOR OF THIRD VERSION (STANFORD PASCAL):               *)
(*                                                                  *)
(*              S. HAZEGHI                                          *)
(*              COMPUTATION RESEARCH GROUP                          *)
(*              STANFORD LINEAR ACCELERATOR CENTER                  *)
(*              STANFORD, CA. 94305.                                *)
(*                                                                  *)
(*                                                                  *)
(*         AUTHOR OF FOURTH VERSION (MCGILL PASCAL):                *)
(*                                                                  *)
(*              R. NIGEL HORSPOOL                                   *)
(*              SCHOOL OF COMPUTER SCIENCE                          *)
(*              MCGILL UNIVERSITY                                   *)
(*              MONTREAL  QUEBEC  H3A 2K6                           *)
(*                                                                  *)
(*                                                                  *)
(*         AUTHOR OF This VERSION (Oppolzer Version):               *)
(*                                                                  *)
(*              Bernd Oppolzer                                      *)
(*              Diplom-Informatiker                                 *)
(*              Baerenhofstr. 23                                    *)
(*              D-70771 Leinfelden-Echterdingen                     *)
(*              Germany                                             *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  History records - newest first                                  *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Aug 2020 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  The CHK instruction was not portable so far, because the        *)
(*  limits were always coded as integers, even if CHK was used      *)
(*  to CHK for a subrange of chars, like in 'A' .. 'Z'              *)
(*                                                                  *)
(*  This had to be fixed, because otherwise P-Code files cannot     *)
(*  be transferred across platforms                                 *)
(*                                                                  *)
(*  Now, if the limits of a char subrange are coded as char         *)
(*  constants (and not, for example, as hex constants), the         *)
(*  limits on the CHK instruction are written as char constants,    *)
(*  too, which should make the P-Code files portable.               *)
(*                                                                  *)
(*  Changes to PASCAL2 to tolerate the modificated coding of        *)
(*  the check instruction.                                          *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Aug 2020 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  More rework of READ runtime functions:                          *)
(*                                                                  *)
(*  READ of reals is implemented as Pascal function $PASRDR         *)
(*                                                                  *)
(*  READ of booleans implemented as Pascal function $PASRDB         *)
(*                                                                  *)
(*  READSTR now works for types integer, real, single char          *)
(*  and varying and fixed size character strings.                   *)
(*                                                                  *)
(*  see PASLIBX.PAS:                                                *)
(*                                                                  *)
(*  function $PASRDI ( var F : TEXT ; ...                           *)
(*  function $PASRDR ( var F : TEXT ; ...                           *)
(*  function $PASRDB ( var F : TEXT ; ...                           *)
(*  function $PASRSI ( const S : STRING ; ...                       *)
(*  function $PASRSR ( const S : STRING ; ...                       *)
(*  function $PASRSC ( const S : STRING ; ...                       *)
(*  procedure $PASRSV ( const S : STRING ; ...                      *)
(*  procedure $PASRSS ( const S : STRING ; ...                      *)
(*                                                                  *)
(*  READSTR for booleans and READ for scalar types (enums)          *)
(*  will follow soon                                                *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Aug 2020 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  I fixed some errors in PASCAL2 related to code generation,      *)
(*  see there.                                                      *)
(*                                                                  *)
(*  I had to do some rework in the way the GET standard proc        *)
(*  works, because it is heavily used in the new runtime procs      *)
(*  $PASRDI and $PASRDR (read integer and read reals, written       *)
(*  in Pascal). GET now works better, too; no surprises any         *)
(*  more. See the document which covers all the rework done to      *)
(*  the READ and WRITE procedures including formatted read          *)
(*  (with length specified) and READSTR and WRITESTR, as            *)
(*  known from Pascal/VS                                            *)
(*                                                                  *)
(*  This involved not only changes to PCINT, but also changes       *)
(*  to the Pascal monitor on the mainframe (PASMONN ASSEMBLE).      *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Apr 2020 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - New Version, although the rework on READ and WRITE is not     *)
(*    yet completed. READSTR already works for some types,          *)
(*    much the same way as defined by Pascal/VS. WRITESTR           *)
(*    is still missing.                                             *)
(*                                                                  *)
(*  - The new version is needed because of some errors which        *)
(*    have to be repaired fast (thanks to George Smith):            *)
(*                                                                  *)
(*    a) READ of single char no more reads next lines               *)
(*       without READLN ... but it should (repaired 12.04.)         *)
(*                                                                  *)
(*    b) set comparisons of sets with different (internal) size     *)
(*       are not handled at all by PCINT ... for example            *)
(*       comparisons of set variables and set constants,            *)
(*       when the base type of the set is an integer subrange       *)
(*       (will be repaired in mid April 2020)                       *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Jan 2020 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Implement new READ procedures (new CSPs) which allow          *)
(*    width parameters like in Pascal/VS. At first, the new         *)
(*    procedures are implemented for chars, char arrays and         *)
(*    strings (varchars). The new CSPs are called RFC, RFS and      *)
(*    RFV. The old CSPs RDC, RDS and RDV are obsolete now           *)
(*    and will be phased out in a later release.                    *)
(*                                                                  *)
(*  - Implement a new READ function for integers. This new          *)
(*    function is implemented in Pascal (called $PASRDI) and        *)
(*    is located in the module PASLIBX. It allows the width         *)
(*    parameter, too. The compiler generates calls to $PASRDI       *)
(*    instead of a CSP, when doing an integer READ.                 *)
(*                                                                  *)
(*  - Implement a new procedure $ERROR, which allows the            *)
(*    runtime to throw real exceptions. Up until now, the           *)
(*    runtime issued EXIT calls, which was not ok, because          *)
(*    the stack traces were not triggered in this case.             *)
(*    The new $ERROR procedure generates a P-Code instruction       *)
(*    CHK E, which throws an exception and triggers all the         *)
(*    corrective actions that a "normal" exception does.            *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Dec 2019 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Implement READ of Varchars (String of varying length)         *)
(*    new CSP RDV is needed, had to implemented in PCINT and        *)
(*    in the Pascal monitor PASMONN.ASSEMBLE. Read of               *)
(*    fixed strings fills with blanks on shorter lines;             *)
(*    read of varying strings returns true length of the            *)
(*    line.                                                         *)
(*                                                                  *)
(*  - New String functions LEFT, RIGHT and LASTINDEX                *)
(*    LEFT and RIGHT have somehow different semantics               *)
(*    from SUBSTR ...; LEFT (s, n) always returns a string          *)
(*    of length n, even if the original length of s was lower,      *)
(*    same for RIGHT. SUBSTR will show a runtime error in           *)
(*    this case.                                                    *)
(*                                                                  *)
(*  - Allow left justified output of strings using                  *)
(*    negative width specification (modification to                 *)
(*    CSP WRS; this implies changes to the interpreter              *)
(*    PCINT and to the Pascal monitor PASMONN.ASSEMBLE)             *)
(*                                                                  *)
(*    example:                                                      *)
(*                                                                  *)
(*    VAR S: CHAR (8);                                              *)
(*                                                                  *)
(*    WRITE (S : 20);   // output of S width 20 justified right     *)
(*    WRITE (S : -20)   // output of S width 20 justified left      *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Nov 2019 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Allow strings as byvalue arguments to CHAR (n) parameters     *)
(*    (was error 418 before). This involves generation of a         *)
(*    VMV P-Code to copy the string into the CHAR (n) byvalue       *)
(*    parameter field. This in turn requires the VMV P-Code         *)
(*    instruction to accept negative lengths; a negative length     *)
(*    tells the interpreter (or PASCAL2) that the order of the      *)
(*    operands on the stack is reversed.                            *)
(*                                                                  *)
(*  - and this triggers a change to PASCAL2 ...                     *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Sep 2019 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - To allow the compiler to compile the P5 compiler, it          *)
(*    is necessary to allow set expressions [ a .. b ],             *)
(*    where a and b are variable expressions.                       *)
(*                                                                  *)
(*  - This implies the creation of a new P-Code instruction         *)
(*    ASR, which sets a range of elements in a set                  *)
(*    (add set range ... similar to ASE, add set element).          *)
(*    ASR fetches three arguments from the stack: the set           *)
(*    and two elements: the two elements define the range.          *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Aug 2019 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - New procedure APPEND to open files to append data             *)
(*    (implemented by a new CSP APN)                                *)
(*                                                                  *)
(*  - procedure FIELDLIST reworked completely                       *)
(*    for better analysis and management of variant records         *)
(*    and for more consistent computation of field offsets          *)
(*                                                                  *)
(*  - this is done to prepare the keyword WITH for use              *)
(*    within record definitions ... to add fields of other          *)
(*    records into the current record's namespace; even for         *)
(*    records which are addressed by pointer                        *)
(*                                                                  *)
(*  - currently all fields of all records added via WITH            *)
(*    must have unique names; there is no mechanism to              *)
(*    change field names during insertion via WITH                  *)
(*                                                                  *)
(*  - see some YouTube videos on the WITH topic:                    *)
(*    https://www.youtube.com/watch?v=ZHqFrNyLlpA                   *)
(*    (on data orientation)                                         *)
(*                                                                  *)
(*  - this could also help to make the compiler more secure;        *)
(*    by getting rid of some dangerours variant records and         *)
(*    replace them by records with subrecords which are             *)
(*    addressed by pointers (where only the pointer for             *)
(*    the correct variant is different from nil)                    *)
(*                                                                  *)
(*  - the new WITH keyword allows for only minor source             *)
(*    changes in this case; the changes are limited to the          *)
(*    record (type) definition                                      *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Jun 2019 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Labels which are defined but not used in the code now         *)
(*    generate a warning message, not an error (P168)               *)
(*                                                                  *)
(*  - Labels which are defined and used but not referenced by       *)
(*    a goto statement generate a new warning message (P183)        *)
(*                                                                  *)
(*  - Variables and procedures/functions which are not              *)
(*    referenced generate new warning messages (P220 and P221)      *)
(*                                                                  *)
(*  - Types which are not                                           *)
(*    referenced generate new warning messages (P222)               *)
(*                                                                  *)
(*  - Parameters of procedures and functions which are not          *)
(*    referenced generate new warning messages (P223)               *)
(*                                                                  *)
(*  These extensions are published as release 2019.07               *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  May 2019 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Code generation errors with builtin functions LENGTH          *)
(*    and MAXLENGTH, when the lengths are known at compile time     *)
(*                                                                  *)
(*  When the LENGTH or MAXLENGTH function was related to an         *)
(*  array element, the compiler generated code for the              *)
(*  addressing of the element, although not needed. What made       *)
(*  things worse: this code left an unneeded item (the address      *)
(*  of the element) on the stack, which was not removed and led     *)
(*  to problems in the PASCAL2 code generation (the PCINT           *)
(*  interpreter doesn't complain, although the memory leak          *)
(*  - or stack leak in this case - is clearly visible in            *)
(*  debug mode).                                                    *)
(*                                                                  *)
(*  The solution found is:                                          *)
(*                                                                  *)
(*  to invalidate the generated code using two new P-Code           *)
(*  instructions XBG and XEN.                                       *)
(*                                                                  *)
(*  XBG <seqno> is generated, when a critical code sequence         *)
(*  starts.                                                         *)
(*                                                                  *)
(*  If later the compiler decides that the code starting from       *)
(*  the last scheduled XBG is not needed, it generates a            *)
(*  XEN <seqno>,0 ... otherwise XEN <seqno>,1                       *)
(*                                                                  *)
(*  It is important that the compiler knows the seqno of the        *)
(*  XBG to write it on the XEN ... and: it should write the         *)
(*  XEN unconditionally, because PASCAL2 and the P-Code             *)
(*  interpreter will look for it (if no XEN for a particular        *)
(*  XBG is found, the code is generated, that is, an                *)
(*  XEN <seqno>,1 is implied).                                      *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  May 2019 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Some errors were reported by Ed Lott (thanks)                 *)
(*                                                                  *)
(*    a) when the compiler generated calls to the CSP WRV           *)
(*       (write strings), it did not make sure that the             *)
(*       FCB address was loaded (see PASCAL2, LOADFCBADDRESS).      *)
(*       Corrected 13.05.2019                                       *)
(*                                                                  *)
(*    b) when accessing static strings, the compiler did not        *)
(*       add the offset of the string in the STATIC CSECT           *)
(*       during address computation (in some situations)            *)
(*       Corrected 14.05.2019                                       *)
(*                                                                  *)
(*    c) when accessing the length field of a string,               *)
(*       the compiler did not compute the address correctly         *)
(*       (especially when the string was an array element).         *)
(*       The function GETADR2 must be used in this case.            *)
(*       Corrected 15.05.2019                                       *)
(*                                                                  *)
(*    d) wrong code was generated, when a string array              *)
(*       component was passed to a procedure (again, using          *)
(*       GETADR2 solved the problem).                               *)
(*       Corrected 17.05.2019                                       *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Feb.2019 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Fields of builtin record OSPARM renamed to PSTRING and        *)
(*    PLENGTH (instead of STRING and LENGTH) due to name            *)
(*    collision with new builtin type STRING and builtin            *)
(*    function LENGTH (no real problem, but it is much nicer        *)
(*    this way)                                                     *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Jan.2019 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Error occured in PCINT.C when CASE Statement had no           *)
(*    case tags at all (empty case). Fixed.                         *)
(*                                                                  *)
(*  - Errors in structured constants involving strings. Fixed.      *)
(*                                                                  *)
(*    Example:                                                      *)
(*                                                                  *)
(*       type TMYRECORD = record                                    *)
(*                          A : INTEGER ;                           *)
(*                          B : STRING ( 5 ) ;                      *)
(*                        end ;                                     *)
(*                                                                  *)
(*       const DEFAULT : TMYRECORD =                                *)
(*             ( 100 , 'foo' ) ;                                    *)
(*                                                                  *)
(*  - No length required (or supported) for STRING constants        *)
(*                                                                  *)
(*  - Supporting typed STRING constants by converting them to       *)
(*    char arrays internally (they are constant and fixed size,     *)
(*    after all)                                                    *)
(*                                                                  *)
(*    Example:                                                      *)
(*                                                                  *)
(*       const X : STRING = 'Oppolzer' ;                            *)
(*                                                                  *)
(*    is much the same as                                           *)
(*                                                                  *)
(*       const X = 'Oppolzer' ;                                     *)
(*                                                                  *)
(*    but                                                           *)
(*                                                                  *)
(*       const X2 : CHAR ( 10 ) = 'Oppolzer' ;                      *)
(*                                                                  *)
(*    is different (8 Bytes Content plus 2 Blanks)                  *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Jul.2018 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  Error fixed: negative constants on CASE threw range errors;     *)
(*  this has been corrected ... see test program TESTCASE.PAS       *)
(*  (discovered while working on module AVLTREE.PAS)                *)
(*                                                                  *)
(*  Allow types with parameters being specified in pointer type     *)
(*  declarations, for example:                                      *)
(*                                                                  *)
(*    var S1 : STRING ( 9 ) ;                                       *)
(*        SP1 : -> STRING ( 9 ) ;                                   *)
(*                                                                  *)
(*  the second declaration (SP1) was not possible before,           *)
(*  because only type identifiers were allowed after the            *)
(*  arrow symbol (no type parameters).                              *)
(*                                                                  *)
(*  Same goes for                                                   *)
(*                                                                  *)
(*    type CP8 = -> CHAR ( 8 ) ;                                    *)
(*                                                                  *)
(*  which is a pointer type declaration; variables of this          *)
(*  type point to variables of type CHAR (8), which is an           *)
(*  abbreviation for ARRAY [ 1 .. 8 ] OF CHAR ; you can also        *)
(*  declare variables directly, like                                *)
(*                                                                  *)
(*    var PV8 : -> CHAR ( 8 ) ;                                     *)
(*                                                                  *)
(*  and then do something like this:                                *)
(*                                                                  *)
(*    PV8 := ALLOC ( 8 ) ;                                          *)
(*    PV8 -> := 'Oppolzer';                                         *)
(*    WRITELN ( PV8 -> ) ;                                          *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Jun.2018 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  MEMCMP added as standard function, similar to MEMCPY.           *)
(*  Two new PCODE instructions added to implement MEMCMP inline     *)
(*  (MCC and MCV)                                                   *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  May 2018 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  The P-Codes for Strings (starting with the letter V)            *)
(*  are now recognized and translated to 370 machine code           *)
(*  by PASCAL2 ... see there                                        *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Feb.2018 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  many tests and improvements with respect to procedure and       *)
(*  function parameters (procedures and functions passed as         *)
(*  parameters to other procedures). The compiler had some bugs     *)
(*  here. In this context I re-activated the 1982 version of the    *)
(*  compiler, to see, if the bugs were there already (they were).   *)
(*                                                                  *)
(*  I was inspired to do this all by some postings regarding        *)
(*  Knuth's Man-or-Boy test, which I didn't know before.            *)
(*                                                                  *)
(*  look here: https://en.wikipedia.org/wiki/Man_or_boy_test        *)
(*                                                                  *)
(*  and here: https://rosettacode.org/wiki/Man_or_boy_test#Pascal   *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Feb.2018 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - const Parameters (like in Pascal/VS) to allow the             *)
(*    implementation of most string functions using Pascal          *)
(*                                                                  *)
(*  - array like indexes for strings (new P-Code VIX similar        *)
(*    to IXA to index characters in strings)                        *)
(*                                                                  *)
(*  - many string functions from Pascal/VS (and more) are           *)
(*    supported; some implemented directly inline using             *)
(*    new P-Code instructions, but most (for the moment)            *)
(*    in Pascal (see PASLIBX.PAS)                                   *)
(*                                                                  *)
(*    STR          - convert to string                              *)
(*    MAXLENGTH    - maxlength of string                            *)
(*    LENGTH       - length of string                               *)
(*    STRRESULT    - result of str func                             *)
(*    STRRESULTP   - ptr to str result                              *)
(*    REPEATSTR    - repeat str n times                             *)
(*    RESULTP      - ptr to result                                  *)
(*    SUBSTR       - substring (like in PL/1)                       *)
(*    DELETE       - delete part of string (args like substr)       *)
(*    RTRIM        - trim blanks on the right                       *)
(*    LTRIM        - trim blanks on the left                        *)
(*    TRIM         - trim blanks on both sides                      *)
(*    COMPRESS     - reduce multiple blanks to one blank            *)
(*    INDEX        - search string position (like in PL/1)          *)
(*    VERIFY       - verify string (like in PL/1)                   *)
(*    TRANSLATE    - translate using tranlation table (PL/1)        *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Jan.2018 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Implementation of STRING (n)                                  *)
(*                                                                  *)
(*  - Many new P-Code instructions to support the STRING (n)        *)
(*    datatype:                                                     *)
(*                                                                  *)
(*    VC1 - varchar convert 1                                       *)
(*    VC2 - varchar convert 2                                       *)
(*    VCC - varchar concat                                          *)
(*    VLD - varchar load                                            *)
(*    VLM - varchar load maxlength                                  *)
(*    VMV - varchar move                                            *)
(*    VPO - varchar pop workarea addr                               *)
(*    VPU - varchar push workarea addr                              *)
(*    VSM - varchar set maxlength                                   *)
(*    VST - varchar store                                           *)
(*                                                                  *)
(*  - These P-Codes are not yet supported by the P-Code to          *)
(*    370 translator PASCAL2, so the STRING (n) datatype            *)
(*    only works on Windows etc. (at the moment)                    *)
(*                                                                  *)
(*  - Find more details in a separate document on the               *)
(*    New Stanford Pascal compiler website                          *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Jan.2018 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - More extensions to make Stanford Pascal a competitor          *)
(*    to Pascal/VS (or VS Pascal) and PL/1                          *)
(*                                                                  *)
(*  - New data types CHAR (n), VARCHAR (n) - aka STRING (n)         *)
(*    and DECIMAL (n, m)                                            *)
(*                                                                  *)
(*  - Only CHAR (n) is fully implemented at the moment,             *)
(*    n can be in the range 1 to 254. Shorter CHARs may             *)
(*    be assigned to longer CHARs (and passed as byvalue            *)
(*    parameters to functions). CHAR (n) is an abbreviation         *)
(*    for "array [1..n] of char" ... no need to define it.          *)
(*                                                                  *)
(*  - DECIMAL (n, m) is implemented internally as REAL              *)
(*    (at the moment)                                               *)
(*                                                                  *)
(*  - New functions DIGITSOF and PRECISIONOF, to be used on         *)
(*    DECIMAL data; WRITE with DECIMALs will by default             *)
(*    use these options:                                            *)
(*    WRITE (D);                                                    *)
(*    with D of type DECIMAL will be the same as                    *)
(*    WRITE (D: DIGITSOF(D) + 3 : PRECISIONOF(D));                  *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Dec.2017 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Extensions to EXTERNAL procedure declarations: the            *)
(*    language of the external procedure may be specified,          *)
(*    and an additional external name (8 chars), which is           *)
(*    used instead of the Pascal name (which may be longer).        *)
(*    Supported languages are FORTRAN and ASSEMBLER on the          *)
(*    mainframe and Pascal, of course. On the PC only               *)
(*    Pascal, at the moment, because the P-Code interpreter         *)
(*    cannot call external C objects at the moment.                 *)
(*                                                                  *)
(*    Example:                                                      *)
(*                                                                  *)
(*    procedure PASCAL_TO_ASSEMBLER ( X1 : INTEGER ;                *)
(*                                    var X2 : INTEGER ;            *)
(*                                    T1 : CHAR20 ;                 *)
(*                                    var T2 : CHAR20 ) ;           *)
(*                                                                  *)
(*       EXTERNAL ASSEMBLER 'PAS2ASM' ;                             *)
(*                                                                  *)
(*  - For ASSEMBLER and FORTRAN, different call sequences           *)
(*    are created. ASSEMBLER and FORTRAN both use normal            *)
(*    OS linkage conventions, and FORTRAN expects all parms         *)
(*    passed by reference, so the Pascal compiler creates           *)
(*    dummy arguments for every Pascal by-value parameter.          *)
(*                                                                  *)
(*  - External ASSEMBLER functions must return their result         *)
(*    in general register 0 (or FP register 0, for double           *)
(*    float results). This is also what FORTRAN does.               *)
(*                                                                  *)
(*  - Example programs for both languages, showing external         *)
(*    procedures and functions implemented in ASSEMBLER and         *)
(*    FORTRAN, have been created.                                   *)
(*                                                                  *)
(*  - More advanced topics: using the Pascal stack in the           *)
(*    external procedures (allowing, maybe, recursive calls         *)
(*    of the ASSEMBLER subfunctions), and calling some              *)
(*    functions of the Pascal runtime library.                      *)
(*    This is possible, too, but has not been tested yet.           *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Dec.2017 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Shorter strings (variables) can now be assigned to longer     *)
(*    strings; the longer target strings are filled with blanks     *)
(*    (no message P129: TYPE CONFLICT OF OPERANDS)                  *)
(*                                                                  *)
(*  - New P-Code instruction to support that (MFI to fill           *)
(*    a memory area with a pattern - fixed size)                    *)
(*                                                                  *)
(*  - Some error messages now have additional information,          *)
(*    for example P168: UNDEFINED LABEL - which is shown at the     *)
(*    end of a procedure block - now shows the number of the        *)
(*    missing label. Or: P117: MISSING FORWARE REFERENCE for        *)
(*    types now shows the name of the missing type. This was        *)
(*    shown before, but by doing an additional WRITELN call         *)
(*    into the source listing file, which corrupted the clean       *)
(*    layout of the listing a little bit. Now the information       *)
(*    is part of the error message, and the place, where it is      *)
(*    to be inserted, can be configured in the PASCAL.MESSAGES      *)
(*    file.                                                         *)
(*                                                                  *)
(*  - New P-Code instructions MCP to support MEMCPY and             *)
(*    MSE to support MEMSET ... no more function call               *)
(*    involving Pascal loop with bytewise copy, should              *)
(*    speed up things (maybe generating MVCL on 370 and             *)
(*    memset on PCINT-based platforms)                              *)
(*                                                                  *)
(*  - New P-Code instruction MZE to fill an area of fixed           *)
(*    length with zeroes (will generate XC instead of               *)
(*    overlapping MVC on the mainframe)                             *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Oct.2017 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - The old source program scanner (procedure INSYMBOL)           *)
(*    has been completely replaced by a new scanner called          *)
(*    PASSCAN; the new scanner is not hand-written any more,        *)
(*    but it is generated using a scanner-generating tool that      *)
(*    was written at the Computer Science department of the         *)
(*    Stuttgart University in 1980 by four students (including      *)
(*    myself). I extended this scanner generator in 1996, to        *)
(*    make a usable product out of it, and I used it in many        *)
(*    projects from 1996 until today. PASSCAN is an external        *)
(*    module, seperate from the compiler. It does all the           *)
(*    source handling and it writes the compile listing.            *)
(*                                                                  *)
(*  - The new scanner will make extensions to the compiler          *)
(*    symbol repertoire much easier, because it is generated        *)
(*    from a "grammar", which is in fact a large regular            *)
(*    expression (with attributes). The scanner generator           *)
(*    works similar to the well-known Unix tool "lex".              *)
(*                                                                  *)
(*  - With the help of the new scanner, some more extensions        *)
(*    have been made - more will follow - for example:              *)
(*                                                                  *)
(*  - C++ style comments: // the rest of the line is a comment      *)
(*                                                                  *)
(*  - binary integer constants: 0b00010010                          *)
(*                                                                  *)
(*  - write integer with negative width produces leading zeroes     *)
(*                                                                  *)
(*  - some restrictions on character strings have been removed      *)
(*                                                                  *)
(*  - some errors in the set implementation have been corrected     *)
(*                                                                  *)
(*  - the compiler listing has been slightly reworked; it is        *)
(*    now produced by the new generated scanner procedure           *)
(*                                                                  *)
(*  - this allows for lines with errors to be shown at the          *)
(*    terminal, followed immediately by the error message;          *)
(*    this way, the compile listing is needed no more for           *)
(*    error diagnosis in most cases                                 *)
(*                                                                  *)
(*  - the compiler now runs with the debug switch on (that is:      *)
(*    subrange checks etc. are now enabled on the compiler);        *)
(*    when I first tried this, I discovered that the compiler       *)
(*    up to now stored out-of-range values into scalar types        *)
(*    etc., so that the debug switch had to be turned off ...       *)
(*    this has been fixed.                                          *)
(*                                                                  *)
(*  - new operators (shift, more assignments like +=) and           *)
(*    more operator levels now seem possible without much           *)
(*    effort regarding the scanner; the extension of the            *)
(*    scanner could be done within minutes.                         *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Aug.2017 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - String constants now may be constructed of different          *)
(*    parts, seperated by blanks, some of them coded in hex         *)
(*    or binary, and others in normal char representation           *)
(*                                                                  *)
(*    Example: const S_VS_1 = X'1b' '&l12D' X'0d0a' ;               *)
(*                                                                  *)
(*    I used this to rewrite a very old BASIC program in            *)
(*    Pascal which outputs printer control sequences to             *)
(*    a HP Laserjet printer (preserving software and hardware       *)
(*    investments)                                                  *)
(*                                                                  *)
(*  - SIZEOF supports simple string constants (will be              *)
(*    problematic for expressions involving structured              *)
(*    constants, let's see later ... maybe expressions              *)
(*    should be allowed as argument to SIZEOF, not only             *)
(*    type identifiers, const identifiers - now new - and           *)
(*    variables with optional selectors).                           *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Jun.2017 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Character constants may be coded in hexadecimal and           *)
(*    binary (X'nn', B'bbbbbbbb'); this is a large topic and        *)
(*    not yet finished completely                                   *)
(*                                                                  *)
(*  - The implementation of sets will be reworked completely;       *)
(*    larger sets will be allowed (up to 2000 elements), and        *)
(*    some restrictions regarding set limits will be dropped        *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  May.2017 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  - Minor error: allow CLOSE for non-Text-Files, too.             *)
(*                                                                  *)
(*  - New standard type ANYFILE, compatible to every other          *)
(*    file type; file variables can be arguments to var             *)
(*    parameters of type ANYFILE, and so functions and              *)
(*    procedures can be written that accept files of any            *)
(*    type as parameters                                            *)
(*                                                                  *)
(*  - standard type VOIDPTR renamed to ANYPTR; VOIDPTR is           *)
(*    allowed, too (for compatibility reasons)                      *)
(*                                                                  *)
(*  - X -> is invalid (flagged by the compiler) for variables       *)
(*    of type ANYPTR or ANYFILE; two new error messages 187         *)
(*    and 188                                                       *)
(*                                                                  *)
(*  - new error message 182 for var parameters with                 *)
(*    different lengths (was 142); this error is supressed          *)
(*    when file arguments are passed to ANYFILE parameters          *)
(*    (ANYFILEs variables have no file buffers, so they             *)
(*    are shorter than other file variables)                        *)
(*                                                                  *)
(*  - yet to be done: a function that tells if an ANYFILE           *)
(*    variable is a TEXT or a binary file; a function that          *)
(*    returns the size and the address of the file buffer           *)
(*    of an ANYFILE variable. What should already work with         *)
(*    ANYFILEs: functions like ASSIGN, REWRITE, RESET, CLOSE,       *)
(*    GET, PUT, and FILEFCB, which returns the address of the       *)
(*    Pascal FCB of the file. Maybe: a function that casts          *)
(*    an ANYFILE variable to a variable of type TEXT (so that       *)
(*    functions requiring TEXT files can be used on ANYFILES).      *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  May.2017 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  The compiler now runs on MVS (Hercules), too.                   *)
(*  Same source code (PASCAL1, PASCAL2) as with CMS,                *)
(*  same runtime (PASMONN) - although there are some                *)
(*  CMS dependencies, controlled by SYSPARM(CMS).                   *)
(*  Different PASSNAP ... see below.                                *)
(*                                                                  *)
(*  Several changes and corrections to PASMONN (Pascal runtime)     *)
(*  have been made. The most important: PASMONN now supports        *)
(*  RESET and REWRITE of PO members with their name specified       *)
(*  at runtime using the new function ASSIGNMEM. After RESET,       *)
(*  success can be checked by looking at a flag in the Pascal       *)
(*  FCB, accessed by the (existing) function FILEFCB.               *)
(*                                                                  *)
(*  This has been necessary to provide a MVS variant of PASSNAP;    *)
(*  PASSNAP reads debug information at runtime, which depends       *)
(*  on the name of the source file. In CMS, this was accomplished   *)
(*  using CMS FILEDEFs, issued from the Pascal program.             *)
(*  In MVS, ASSIGNMEM is used. The version of PASSNAP for MVS       *)
(*  is located in the source file PASSNAPM. The technique to        *)
(*  open the debug information file is the only difference          *)
(*  between PASSNAP (CMS) and PASSNAPM (MVS).                       *)
(*                                                                  *)
(*  There is still room for some improvement in the area of         *)
(*  error handling etc.; some ideas:                                *)
(*                                                                  *)
(*  - register and PSW output in both PASSNAP and the simple        *)
(*    error output written by PASMONN                               *)
(*                                                                  *)
(*  - correct handling of 1006 - stack/heap collision               *)
(*                                                                  *)
(*  - control PASSNAP output by runtime option                      *)
(*                                                                  *)
(*  - control ABEND with SYSUDUMP after PASSNAP by runtime option   *)
(*                                                                  *)
(*  - use CAMLST to determine the type of the assigned dataset      *)
(*    (PS or PO) to prevent error 013-14 (which is unrecoverable)   *)
(*                                                                  *)
(*  - read directory or BLDL instead of reacting on 013-18          *)
(*    using the DCB ABEND EXIT (which is recoverable)               *)
(*                                                                  *)
(*  - if no member specified and dataset assigned is a PDS,         *)
(*    change RECFM to U on the fly and read directory               *)
(*                                                                  *)
(*  Thanks to Gerhard Postpischil and Juergen Winckelmann           *)
(*  for help and good advice and for encouraging me to do           *)
(*  the MVS port.                                                   *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Jan.2017 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  Change SEARCHID, to prevent additional errors, when             *)
(*  encountering a procedure call for a procedure without           *)
(*  declaration; the proc name was entered into the id list         *)
(*  as a dummy var declaration, which leaded to more errors.        *)
(*  Now the insert into the id list is deferred until the next      *)
(*  symbol has been read. (SEARCHID has got much more               *)
(*  parameters to be able to do this).                              *)
(*                                                                  *)
(*  New error code for "undeclared proc" (changed from 104          *)
(*  "identifier not declared" to 184 "procedure not                 *)
(*  declared").                                                     *)
(*                                                                  *)
(*  Error 184 is changed to warning, this way it is possible        *)
(*  to generate code (which makes some sense) even for              *)
(*  undeclared procedures and functions - much the same way         *)
(*  as some other languages (including PL/1 and C and FORTRAN)      *)
(*  do it. The types of the parameters are                          *)
(*  taken from the types of the arguments, which will               *)
(*  hopefully fit to the external definition of the                 *)
(*  procedure. If the arguments are variables, the args             *)
(*  are passed by reference; if not, by value.                      *)
(*                                                                  *)
(*  New field CSTNAME for declared procs (records the name          *)
(*  of the STATIC CSECT assigned to the proc). This was needed,     *)
(*  because all STATIC CSECTs of the (empty) main programs of       *)
(*  external modules had the same name #PASMAI#, which led to       *)
(*  name conflicts. The CSTNAME now is determined when the          *)
(*  procedure is created, already.                                  *)
(*                                                                  *)
(*  MODULE PASCALVS implements some of the functions that           *)
(*  are known from the PASCAL/VS compiler, e.g. DATETIME,           *)
(*  DATTIM10 (with century), TERMIN and TERMOUT, HALT               *)
(*                                                                  *)
(*  CLOSE standard function added as new CSP P-Code operation;      *)
(*  it turned out that it was not sufficient to simply set          *)
(*  the file status to zero, but instead the runtime on             *)
(*  the mainframe has to flush the buffers etc., so a true CSP      *)
(*  is the better solution. Now it is possible to close a file      *)
(*  before program termination without reopening it again.          *)
(*  Up until now this was only possible by issuing RESET or         *)
(*  REWRITE, leaving the file open until program termination.       *)
(*                                                                  *)
(*  DATE and TIME had to be added as new CSP P-Code operations,     *)
(*  too, because DATE and TIME values up until now only were        *)
(*  retrieved from the system once at initialization time.          *)
(*  Now it is done at every reference to DATE or TIME, by calling   *)
(*  the new CSP operations.                                         *)
(*                                                                  *)
(*  Floating Point output operations have been fixed;               *)
(*  WRITE (X : N) prints exponential format (n.nnnE+xx)             *)
(*  WRITE (X : N : P) prints decimal format, but if P = 0,          *)
(*  only the integer part of X is printed on all platforms          *)
(*                                                                  *)
(*  New standard function FLOOR (gets real parm, yields             *)
(*  real result), which returns the next lower "integer"            *)
(*  (but real type). This is NOT the same as TRUNC.                 *)
(*  FLOOR exists in C, too.                                         *)
(*                                                                  *)
(*  New standard function ROUNDX (round extended), which            *)
(*  rounds real values at a given positon (for example,             *)
(*  at the second decimal position) - as accurate as possible       *)
(*                                                                  *)
(*  Undefined functions don't give errors 104 and follow-up         *)
(*  errors, but a warning 186 instead (undefined function);         *)
(*  the function is assumed to have result type integer, and        *)
(*  the parameters are handled in the same way as with              *)
(*  undefined procedures, see above.                                *)
(*                                                                  *)
(*  Some errors on floating point rounding and output have been     *)
(*  fixed; now in most cases the same results are presented on      *)
(*  all platforms.                                                  *)
(*                                                                  *)
(*  The Pascal monitor PASMONN has been reworked, so that           *)
(*  the 8k limit is no problem any more (subroutines have their     *)
(*  own base register); Pascal subroutines (from PASLIBX) can       *)
(*  be called from CSP implementations written in ASSEMBLER;        *)
(*  these Pascal subroutines can in turn call other CSP             *)
(*  subroutines (and so on ...)                                     *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Jan.2017 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  First version, which was extended / improved on Windows         *)
(*  first and later moved to Hercules/VM.                           *)
(*                                                                  *)
(*  From some discussions on the FPC mailing list, I got the        *)
(*  idea to support bit operations on integer operands, too.        *)
(*                                                                  *)
(*  The operations AND, OR, NOT have been extended to do            *)
(*  bit operations, when being used with integers (was error        *)
(*  134 before). Another operation XOR is provided (new             *)
(*  reserved symbol) for exclusive or operation; can be used        *)
(*  with integer or boolean operands.                               *)
(*                                                                  *)
(*  New P-Code instruction XOR; the P-Code instructions             *)
(*  AND, IOR, NOT and XOR have a type parameter (B or I).           *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Dec.2016 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  Another portability issue:                                      *)
(*                                                                  *)
(*  the branch table used with case statements implies the          *)
(*  EBCDIC char set, if the case control variable is of type        *)
(*  char. I changed the XJP logic to a portable representation      *)
(*  of the branch table and shifted the construction of the         *)
(*  "real" branch table to the second pass. This way, XJP           *)
(*  instructions and "portable branch tables" can be moved          *)
(*  to foreign platforms with foreign character sets.               *)
(*                                                                  *)
(*  see boolean constant 'PORTABLE_BRANCHTABLE'                     *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Nov.2016 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  To enable the port to ASCII platforms, the following            *)
(*  changes have been made:                                         *)
(*                                                                  *)
(*  - the upper limit of for loops with loop control variables      *)
(*    of type char is encoded in char representation instead        *)
(*    of the internal numeric code in the P-Code source             *)
(*                                                                  *)
(*  - set constants of set of char have a new representation        *)
(*    in the P-Code, envolving char representation of the           *)
(*    chars contained in the set                                    *)
(*                                                                  *)
(*  - not related to the port: set constants in P-Code are          *)
(*    represented by hexa byte strings instead of integer           *)
(*    strings, which makes them much better readable                *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Oct.2016 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  Static variables are supported; the new keyword static          *)
(*  starts a declaration section for static variables (like         *)
(*  the keyword var does it for "normal" auto variables)            *)
(*                                                                  *)
(*  This is done the same way in IBMs Pascal VS                     *)
(*                                                                  *)
(*  There is a separate STATIC CSECT for every Code CSECT           *)
(*  (every proc/func) which can hold up to 4k of static             *)
(*  variables or structured constants ... the same CSECT            *)
(*  is used for both. The CSECT is part of the load module,         *)
(*  that is: writing into this STATIC CSECT makes the program       *)
(*  non-reentrant.                                                  *)
(*                                                                  *)
(*  The SNAPSHOT routine (now called PASSNAP) has been              *)
(*  enhanced to be able to show static variables, too.              *)
(*  To support this, the address of the STATIC CSECT is             *)
(*  stored at a certain place in the function prolog, which         *)
(*  can easily be found at run time (displacement of the            *)
(*  branch instruction at the EPA minus 4). If the address          *)
(*  at this place is zero, there are no static variables.           *)
(*                                                                  *)
(*  PASSNAP was further enhanced to show the EP addresses           *)
(*  of every function, the call offset at every call level          *)
(*  and the storage class, offset and address of every              *)
(*  variable (in addition to the variable name and the              *)
(*  value at the time of error or SNAPSHOT - in Pascal              *)
(*  notation).                                                      *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Oct.2016 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  New functions:                                                  *)
(*                                                                  *)
(*  - PTRCAST as a substitute for PTRADD with only one              *)
(*    argument; used to cast pointers of different types            *)
(*                                                                  *)
(*  - CHKHEAP to check the integrity of heap segments               *)
(*                                                                  *)
(*  - FILEFCB returns the pointer to the file control block         *)
(*    of the specified file (which contains the DCB at              *)
(*    position 36)                                                  *)
(*                                                                  *)
(*  - Pointers of any type can be written directly using            *)
(*    WRITE; the output format is 8 hex digits                      *)
(*                                                                  *)
(*  Other changes:                                                  *)
(*                                                                  *)
(*  The CSECTs of the internal procedures are now called            *)
(*  $PRVxxxx (xxxx is numbered starting from 0002).                 *)
(*                                                                  *)
(*  For external modules, the CSECT names of the internal           *)
(*  procedures are derived from the module name, for example:       *)
(*  module $PASLIBX --> CSECT names $LIBXxxx                        *)
(*                                                                  *)
(*  Only procs and funcs at level 1 are visible from outside        *)
(*  and keep their original names                                   *)
(*                                                                  *)
(*  If the new keyword LOCAL is specified in front of a             *)
(*  procedure or function declaration, the procedure is             *)
(*  local, even if it appears in an external module at level 1.     *)
(*                                                                  *)
(*  This all helps to reduce name conflicts and to allow            *)
(*  more than one external module (which was not possible           *)
(*  in original Stanford Pascal)                                    *)
(*                                                                  *)
(*  Changes to the environment:                                     *)
(*                                                                  *)
(*  in CMS the RUNPARM module was used to start Pascal programs     *)
(*  and to build an OS parm string out of the CMS tokenized         *)
(*  parameters, but: the CMS tokens were concatenated without       *)
(*  separating blanks. The new XRUNPARM module does the same,       *)
(*  but inserts blanks between the CMS tokens.                      *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Sep.2016 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  Four new standard functions have been added using               *)
(*  the library function facility:                                  *)
(*                                                                  *)
(*  - ALLOC, which gets a length and returns a pointer              *)
(*    to a new area of that length                                  *)
(*                                                                  *)
(*  - ALLOCX, which does the same, but does not use the             *)
(*    (yet to come) sophisticated logic like LE, but does a pure    *)
(*    GETMAIN on every ALLOCX call, which is simple, but slow       *)
(*                                                                  *)
(*  - FREE, which frees the storage retrieved by ALLOC              *)
(*                                                                  *)
(*  - FREEX, which frees the storage retrieved by ALLOCX,           *)
(*    that is: FREEMAIN                                             *)
(*                                                                  *)
(*  The four new functions are implemented in the module            *)
(*  PASLIBX, seperate from the compiler (in Pascal)                 *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Sep.2016 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  Standard functions and procedures may not only be               *)
(*  implemented by inline code or CSP calls; another                *)
(*  possible (new) technique is to call an external function        *)
(*  in a library module.                                            *)
(*                                                                  *)
(*  To support this, several atributes have been added to the       *)
(*  internal Standard procedure description:                        *)
(*                                                                  *)
(*     STANDARD :                                                   *)
(*       ( KEY : INTEGER ;                                          *)
(*         LIBNAME : EXTNAMTP ;                                     *)
(*         FUNCCODE : INTEGER ;                                     *)
(*         PARMCNT : INTEGER ;                                      *)
(*         PROCTYP : CHAR ) ;                                       *)
(*                                                                  *)
(*   KEY is the only attribute that was present before and          *)
(*   is the number of the CSP call.                                 *)
(*                                                                  *)
(*   If LIBNAME is not blank, the Standard Proc is implemented      *)
(*   by a library function call. It gets the FUNCCODE as first      *)
(*   parameter; PARMCNT and PROCTYP are other attributes that       *)
(*   are needed to set up the CUP call for the library function     *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Sep.2016 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  New keyword MODULE; a module is a collection of                 *)
(*  external procedures without a main program. The keyword         *)
(*  MODULE replaces the keyword PROGRAM on modules.                 *)
(*  It sets the compiler switch X implicitly and enforces that      *)
(*  the main block (which still has to be coded) is empty,          *)
(*  that is: "begin end.". No main block is generated, so           *)
(*  it is now possible to add multiply modules to a Pascal          *)
(*  program without name conflicts.                                 *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Sep.2016 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  New functions added to support the construction of a new        *)
(*  storage management library using Pascal:                        *)
(*                                                                  *)
(*  - ADDR to get the address of any variable;                      *)
(*    the result of this function is a pointer without type         *)
(*    (aka void pointer) similar to the NIL pointer,                *)
(*    which is compatible with every other pointer type             *)
(*                                                                  *)
(*  - PTRADD to add an integer expression to a pointer              *)
(*    (of any type) - this adds addresses in contrast to C,         *)
(*    where element sizes are added; PTRADD without a               *)
(*    second argument (which is the same as PTRADD (X,0))           *)
(*    can be used to convert a typed pointer to a void pointer      *)
(*                                                                  *)
(*  - PTRDIFF, that subtracts two pointers (of any type),           *)
(*    giving an integer result                                      *)
(*                                                                  *)
(*  - SIZEOF, which works much the same as the C function           *)
(*    of the same name; as with C, you can specify a variable       *)
(*    as argument or a type identifier                              *)
(*                                                                  *)
(*  - PTR2INT, which converts a pointer to an integer value         *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Sep.2016 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  a) shorter strings allowed on const initializers                *)
(*     (on structured - typed - constants)                          *)
(*                                                                  *)
(*  b) shorter string constants on assignments                      *)
(*                                                                  *)
(*  c) even strings of length 1 (single chars) and zero ('')        *)
(*                                                                  *)
(*  d) prepared for new typeclass (charstring) -                    *)
(*     but not yet used or implemented; could make some             *)
(*     things simpler                                               *)
(*                                                                  *)
(*  e) using this: idlength changed from 12 to 20,                  *)
(*     so that the first 20 characters are significant on           *)
(*     identifiers (not only 12). The initializers needed           *)
(*     not be changed; although they are still 12 bytes long,       *)
(*     the fields are filled with blanks up to length 20            *)
(*                                                                  *)
(*  f) correct output to P-Code file, where necessary;              *)
(*     format changes observed on CST, ENT and BGN                  *)
(*                                                                  *)
(*  g) no changes so far to caching routines etc.                   *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Aug.2016 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*  to support the runtime extensions (PASCSP) regarding            *)
(*  textfile I/O, the implicit RESET on INPUT on the beginning      *)
(*  of the MAIN function has been removed; RESET is now done        *)
(*  when the first READ operation is encountered. That means        *)
(*  that the char variable INPUT -> is undefined until the          *)
(*  end of the first READ operation                                 *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*  Oct.2011 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*    PASCAL 1982 ported to VM370 R6 on Hercules (from MUSIC/SP)    *)
(*                                                                  *)
(*    Summary of Changes:                                           *)
(*                                                                  *)
(*    - another substitute for brackets: (. .) - not only (/ /)     *)
(*                                                                  *)
(*    - substitute for pointer symbol: ->                           *)
(*                                                                  *)
(*    - comments like PL/1 and C: /* ... */                         *)
(*                                                                  *)
(*    - year 2000 problem fixed (still TIME DEC used in PASMONN)    *)
(*                                                                  *)
(*    - new loop control statements: BREAK and CONTINUE             *)
(*                                                                  *)
(*    - RETURN statement                                            *)
(*                                                                  *)
(*  to be done:                                                     *)
(*                                                                  *)
(*    - allow shorter String constants to be assigned               *)
(*      (padded with blanks)                                        *)
(*                                                                  *)
(*    - allow static definitions (local to procs and functions)     *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(* 02FEB2007 - Changes by Dave Edwards to use hex codes C0,D0       *)
(*    (was 8B,9B) for EBCDIC brace characters (curly brackets).     *)
(*    New constants CHLBRACE and CHRBRACE defined.                  *)
(*    VERSION date left unchanged as MAY -82.                       *)
(*    Hex C0,D0 seem to be the codes used by most curr. software    *)
(*    such as tn3270 clients, Ascii-EBCDIC translate tables, etc.   *)
(*    and conform to the standard IBM-037 US code page.             *)
(*    See additional notes in file ccde:pascal_info.txt .           *)
(*  - Also, in INITTABLES procedure, set UPSHIFT to only upshift    *)
(*    lowercase chars (e.g. exclude tilde, which is in the range    *)
(*    a to z), and add comments re. definition of SSY array.        *)
(*    Note that curly brackets and backslash are within the         *)
(*    range A to Z in the EBCDIC character set.                     *)
(*  - Also fix spacing of text for BGN output record: change        *)
(*    TIME:9 to TIME:8. Was causing last char of year to be         *)
(*    truncated, in the info text at the start of $PASMAIN          *)
(*    csect in the object file.                                     *)
(*  - Source changes are identified by flag DE near beginning       *)
(*    of lines.                                                     *)
(*    (Write date of previous source file: 14sep1983.)              *)
(*                                                                  *)
(********************************************************************)



const VERSION = '2020.09' ;
      MAXLSIZE = 120 ;
      MAXERRNO = 999 ;

      (******************************************)
      (* MAX # OF LINES PER PAGE OF LISTING     *)
      (******************************************)

      MAXINT = 2147483647 ;
      MAXADDR = 16777215 ;

      (******************************************)
      (* LARGEST ELEMENT USED IN THIS CODE      *)
      (******************************************)

      BUFLEN = 122 ;

      (******************************************)
      (* MAX LINE LENGTH + 2                    *)
      (******************************************)

      INTSIZE = 4 ;
      HINTSIZE = 2 ;
      REALSIZE = 8 ;
      STRSTACKSZ = 8 ;
      MXDATASZE = 8 ;
      CHARSIZE = 1 ;
      BOOLSIZE = 1 ;
      WORDSIZE = 4 ;

      (*****************************************)
      (*  some more size constants             *)
      (*****************************************)

      PTRSIZE = 4 ;
      FILHDRSIZE = 8 ;
      FILMINSIZE = 12 ;
      REALLNGTH = 20 ;

      (******************************************)
      (* STRING REPRESENTATION OF REAL NUMBERS  *)
      (******************************************)

      DIGMAX = 19 ;

      (******************************************)
      (* REALLNGTH - 1                          *)
      (******************************************)

      IDLENGTH = 20 ;
      ALFALNGTH = 10 ;
      MAXSTRL = 254 ;
      MAXVARCHARSIZE = 32767 ;
      DISPLIMIT = 20 ;
      MAX_BKT = 232 ;

      (******************************************)
      (* HASH TABLE SIZE                        *)
      (******************************************)

      MAXLEVEL = 9 ;
      ORDCHMAX = 255 ;

      (******************************************)
      (* SIZE OF CHAR SET OF TARGET MACHINE     *)
      (******************************************)

      OPMAX = 104 ;

      (*****************)
      (* OPCODE RANGE  *)
      (*****************)

      MAXERRNR = 999 ;

      (******************************************)
      (* MAX VAL OF ERROR CODE                  *)
      (******************************************)

      MAXRW = 50 ;

      (******************************************)
      (* room for 50 reserved words             *)
      (******************************************)

      MAXRWLEN = 9 ;

      (*****************************************)
      (* longest reserved word has length = 9  *)
      (* controls size of table frw            *)
      (*****************************************)

      CTRMAX = 16384 ;
      EXTNAMSZ = 8 ;

      (***********************************************)
      (* EXTERNAL NAME LENGTH                        *)
      (* SAVE AREAS, FUNCTION RETURN VALUE SPACE,    *)
      (* DISPLAY AREA, ETC.                          *)
      (***********************************************)

      LCAFTMST = 80 ;
      FPSAVEAREA = 32 ;
      RUNCHKAREA = 96 ;
      DISPADR = 80 ;
      FNCRSLT = 72 ;
      DISPAREA = 40 ;
      FIRSTCONSTLC = 16 ;
      FIRSTFILBUF = 248 ;

      (******************************************)
      (* = LCAFTMST + RUNCHKAREA + DSPLYAREA    *)
      (******************************************)

      TIMEDATELOC = 328 ;

      (******************************************)
      (* LOCATION OF TIME/DATE PREDEF. VARS     *)
      (******************************************)

      OSPARMLOC = 348 ;

      (******************************************)
      (* LOCATION FOR 'OSPARM' PTR.             *)
      (******************************************)

      FIRSTGVAR = 400 ;

      (******************************************)
      (* FIRST USER DEFINED GLOBAL VARIABLE     *)
      (******************************************)

      CHLBRACE = '{' ;

      (******************************************)
      (* LEFT CURLY BRACKET: EBCDIC HEX CODE C0 *)
      (******************************************)

      CHRBRACE = '}' ;

      (*******************************************)
      (* RIGHT CURLY BRACKET: EBCDIC HEX CODE D0 *)
      (* portable_branchtable: new style of B.T. *)
      (* cixmax: maximum difference of highest   *)
      (* and lowest case label                   *)
      (*******************************************)

      PORTABLE_BRANCHTABLE = TRUE ;
      CIXMAX = 405 ;

      (***************************************************)
      (* new set related constants                       *)
      (* maxsetl = maximum set length in bytes (netto)   *)
      (* setmaxsize = maximum set length in bits         *)
      (* setupplimit = upper limit for setmax            *)
      (* setlowlimit = lower limit for setmin            *)
      (*    (setupplimit - setlowlimit) div 8 has to be  *)
      (*    stored in 3 bytes internally ...             *)
      (***************************************************)

      MAXSETL = 252 ;
      SETMAXSIZE = 2000 ;
      SETUPPLIMIT = 64000000 ;
      SETLOWLIMIT = - 64000000 ;

      (***************************************************)
      (* numeric constants for pcode positions           *)
      (***************************************************)

      PCODE_ADI = 2 ;
      PCODE_ADR = 3 ;
      PCODE_AND = 4 ;
      PCODE_DIF = 5 ;
      PCODE_DVI = 6 ;
      PCODE_DVR = 7 ;
      PCODE_SBR = 8 ;
      PCODE_FLO = 9 ;
      PCODE_FLT = 10 ;
      PCODE_INN = 11 ;
      PCODE_INT = 12 ;
      PCODE_IOR = 13 ;
      PCODE_MPI = 15 ;
      PCODE_MPR = 16 ;
      PCODE_NGI = 17 ;
      PCODE_NGR = 18 ;
      PCODE_NOT = 19 ;
      PCODE_ODD = 20 ;
      PCODE_SBI = 21 ;
      PCODE_DEC = 22 ;
      PCODE_INC = 23 ;
      PCODE_STO = 26 ;
      PCODE_SCL = 29 ;
      PCODE_CSP = 30 ;
      PCODE_UNI = 31 ;
      PCODE_ENT = 32 ;
      PCODE_FJP = 33 ;
      PCODE_IND = 35 ;
      PCODE_IXA = 36 ;
      PCODE_LCA = 37 ;
      PCODE_CTS = 38 ;
      PCODE_CTI = 39 ;
      PCODE_MOV = 40 ;
      PCODE_MST = 41 ;
      PCODE_RET = 42 ;
      PCODE_STP = 43 ;
      PCODE_XJP = 44 ;
      PCODE_CHK = 45 ;
      PCODE_CUP = 46 ;
      PCODE_EQU = 47 ;
      PCODE_GEQ = 48 ;
      PCODE_GRT = 49 ;
      PCODE_LDA = 50 ;
      PCODE_LDC = 51 ;
      PCODE_LEQ = 52 ;
      PCODE_LES = 53 ;
      PCODE_LOD = 54 ;
      PCODE_NEQ = 55 ;
      PCODE_STR = 56 ;
      PCODE_UJP = 57 ;
      PCODE_NEW = 58 ;
      PCODE_SAV = 59 ;
      PCODE_RST = 60 ;
      PCODE_ORD = 61 ;
      PCODE_CHR = 62 ;
      PCODE_DEF = 63 ;
      PCODE_LAB = 64 ;
      PCODE_CRD = 65 ;
      PCODE_XPO = 66 ;
      PCODE_ASE = 67 ;
      PCODE_SLD = 68 ;
      PCODE_SMV = 69 ;
      PCODE_DFC = 70 ;
      PCODE_CST = 71 ;
      PCODE_BGN = 72 ;
      PCODE_UXJ = 73 ;
      PCODE_XLB = 74 ;
      PCODE_END = 75 ;
      PCODE_PAK = 76 ;
      PCODE_XOR = 79 ;
      PCODE_MFI = 80 ;
      PCODE_MCP = 81 ;
      PCODE_MSE = 82 ;
      PCODE_DBG = 83 ;
      PCODE_MZE = 84 ;
      PCODE_VC1 = 85 ;
      PCODE_VC2 = 86 ;
      PCODE_VCC = 87 ;
      PCODE_VLD = 88 ;
      PCODE_VST = 89 ;
      PCODE_VMV = 90 ;
      PCODE_VSM = 91 ;
      PCODE_VLM = 92 ;
      PCODE_VPU = 93 ;
      PCODE_VPO = 94 ;
      PCODE_VIX = 95 ;
      PCODE_VRP = 96 ;
      PCODE_MCC = 97 ;
      PCODE_MCV = 98 ;
      PCODE_ASR = 99 ;
      PCODE_XBG = 100 ;
      PCODE_XEN = 101 ;


type ALPHA = array [ 1 .. IDLENGTH ] of CHAR ;
     EXTNAMTP = array [ 1 .. EXTNAMSZ ] of CHAR ;
     SET_CHAR = set of CHAR ;

     /***********************************/
     /* muss mit Def. beim Scanner      */
     /* uebereinstimmen                 */
     /***********************************/

     SYMB = ( SYMB_EOF , SYMB_UNKNOWN , EOLCHAR , SEPARATOR , COMMENT1
            , COMMENT2 , COMMENT3 , COMMENT4 , COMMENT5 , STRINGCONST ,
            HEXSTRINGCONST , BINSTRINGCONST , INTCONST , INTDOTDOT ,
            REALCONST , IDENT , SYLPARENT , SYRPARENT , SYLBRACK ,
            SYRBRACK , SYCOMMA , SYSEMICOLON , SYARROW , SYPERIOD ,
            SYDOTDOT , SYCOLON , SYPLUS , SYMINUS , SYMULT , SYSLASH ,
            SYEQOP , SYNEOP , SYGTOP , SYLTOP , SYGEOP , SYLEOP ,
            SYOROP , SYANDOP , SYASSIGN , SYCONCAT , SYAND , SYDIV ,
            SYMOD , SYOR , SYXOR , SYIN , SYNOT , SYLABEL , SYCONST ,
            SYTYPE , SYVAR , SYFUNC , SYPROG , SYPROC , SYSET ,
            SYPACKED , SYARRAY , SYRECORD , SYFILE , SYFORWARD ,
            SYBEGIN , SYIF , SYCASE , SYREPEAT , SYWHILE , SYFOR ,
            SYWITH , SYGOTO , SYEND , SYELSE , SYUNTIL , SYOF , SYDO ,
            SYTO , SYDOWNTO , SYTHEN , SYFRTRN , SYEXTRN , SYOTHERWISE
            , SYBREAK , SYCONTINUE , SYRETURN , SYMODULE , SYLOCAL ,
            SYSTATIC , NOTUSED ) ;
     SYMSET = set of SYMB ;

     (***********************************)
     (* some set related definitions    *)
     (***********************************)

     SETSTRING = array [ 1 .. MAXSETL ] of CHAR ;

     (**********************************************)
     (* forward definitions of some pointer types  *)
     (**********************************************)

     SSP = -> XSTRCON ;
     CONSTP = -> XCONSTANT ;
     TTP = -> TYPEREC ;
     IDP = -> IDENTIFIER ;

     (******************)
     (* CONSTANTS      *)
     (******************)

     CSTCLASS = ( XINT , REEL , PSET , NULLSTR , STRG ) ;

     /********************************************************/
     /* neue darstellung fuer konstanten                     */
     /* typ valu entfaellt                                   */
     /* basis ist kurze einfache struktur                    */
     /* lange bereiche fuer sets und strings werden erst     */
     /* bei bedarf dazugeholt                                */
     /********************************************************/

     XSTRCON = record
                 LENGTH : INTEGER ;
                 case TAG : CHAR of
                   'S' :
                     ( SSTR : array [ 1 .. MAXSTRL ] of CHAR ) ;
                   'P' :
                     ( PSTR : SETSTRING )
               end ;
     XCONSTANT = record
                   STRTYPE : CHAR ;
                   case CONSTCLASS : CSTCLASS of
                     XINT :
                       ( IVAL : INTEGER ) ;
                     REEL :
                       ( RVAL : array [ 1 .. REALLNGTH ] of CHAR ) ;
                     PSET :
                       ( SETMIN : INTEGER ;
                         SETMAX : INTEGER ;
                         SETOFFS : INTEGER ;
                         SETTYPE : TTP ;
                         PVAL : SSP ) ;
                     NULLSTR , STRG :
                       ( SVAL : SSP )
                 end ;

     (********************)
     (* DATA STRUCTURES  *)
     (********************)

     LEVRANGE = 0 .. MAXLEVEL ;
     ADDRRANGE = 0 .. MAXADDR ;
     ALNRNG = 1 .. 8 ;
     LABELRNG = 0 .. 1000 ;
     BKT_RNG = 0 .. MAX_BKT ;
     OPRANGE = 0 .. OPMAX ;

     (*************************************************)
     (* variant structure typerec for type definition *)
     (*************************************************)
     (*************************************************)
     (* basic type classes                            *)
     (*************************************************)

     TYPECLASS = ( SCALAR , SUBRANGE , POINTER , POWER , CSTRING ,
                 ARRAYS , RECORDS , FILES , TAGFLD , VARIANT ) ;
     DECLKIND = ( STANDARD , DECLARED ) ;
     CONSTLIST = record
                   C : XCONSTANT ;
                   NEXT : -> CONSTLIST
                 end ;
     TYPEREC = record
                 SIZE : ADDRRANGE ;

     //************************************************************
     // ALIGNMENT FACTOR
     //************************************************************

                 ALN : ALNRNG ;
                 ERRORFLAG : BOOLEAN ;
                 case FORM : TYPECLASS of
                   SCALAR :
                     ( case SCALKIND : DECLKIND of
                         STANDARD :
                           ( WHATSTANDARD : CHAR ;
                             STDPARM1 : ADDRRANGE ;
                             STDPARM2 : ADDRRANGE ;
                             MINPARAMCOUNT : 0 .. 2 ;
                             MAXPARAMCOUNT : 0 .. 2 ;
                             MINPARAM : ADDRRANGE ;
                             MAXPARAM : ADDRRANGE ;
                             DEFAULTPARAM : ADDRRANGE ) ;
                         DECLARED :
                           ( FCONST : IDP ;
                             METAOFFS : ADDRRANGE ;
                             CSTNAME : EXTNAMTP ) ) ;
                   SUBRANGE :
                     ( RANGETYPE : TTP ;
                       MIN , MAX : XCONSTANT ) ;
                   POINTER :
                     ( ELTYPE : TTP ) ;

     //************************************************************
     // new fields for set definition - 06.2017
     // elset   = base type of set (subrange,
     //           scalar, maybe char)
     // setmin  = minimum value for set
     // setmax  = maximum value for set
     // setoffs = where bit string starts
     //           (minimum value div 8)
     //************************************************************

                   POWER :
                     ( ELSET : TTP ;
                       SETMIN : INTEGER ;
                       SETMAX : INTEGER ;
                       SETOFFS : INTEGER ) ;

     //************************************************************
     // conformant strings =
     // strings without length
     // used as var parameters (for example)
     //************************************************************

                   CSTRING :
                     ( CONFORMANT : BOOLEAN ;
                       DEF_COMPLETE : BOOLEAN ) ;
                   ARRAYS :
                     ( AELTYPE , INXTYPE : TTP ) ;
                   RECORDS :
                     ( FIRSTFIELD : IDP ;
                       RECTAGTYPE : TTP ;
                       NUMBER_OF_FIELDS : 0 .. 1000 ;
                       FLD_DISP_LEV : - 1 .. DISPLIMIT ) ;
                   FILES :
                     ( FILTYPE : TTP ) ;
                   TAGFLD :
                     ( TAGFIELDP : IDP ;
                       FIRSTVARIANT : TTP ;
                       VARIANT_OFFS : ADDRRANGE ) ;
                   VARIANT :
                     ( FIRSTSUBFIELD : IDP ;    // firstfield of rec
                       SUBTAGTYPE : TTP ;       // rectagtype of rec
                       VARVALS : -> CONSTLIST ; // ptr to const lst
                       NEXTVARIANT : TTP )      // ptr to nxt var
               end ;

     (**************************************************)
     (* type to store set constant infos temporarily   *)
     (**************************************************)

     PSETINFO = -> SETINFO_TEMP ;
     SETINFO_TEMP = record
                      ELEMCOUNT : INTEGER ;
                      SETMIN : INTEGER ;
                      SETMAX : INTEGER ;
                      RANGEERR : INTEGER ;
                      SETELEMS : array [ 1 .. SETMAXSIZE ] of BOOLEAN ;
                      CHARTYPE : BOOLEAN ;
                      HEXORBIN : CHAR ;
                      CONST_IN_SET : INTEGER ;
                      VARS_IN_SET : INTEGER ;
                      MODUS : CHAR ;
                    end ;

     (******************************)
     (* identifier classes         *)
     (******************************)

     IDCLASS = ( TYPES , KONST , STRUCTKONST , VARS , FIELD , PROC ,
               FUNC ) ;
     SETOFIDS = set of IDCLASS ;

     (******************************)
     (* standard procedures        *)
     (******************************)

     CSPTYPE = ( PPAG , PGET , PPUT , PRES , PREW , PRDC , PWRI , PWRE
               , PWRR , PWRC , PWRS , PWRX , PRDB , PWRB , PRDR , PRDH
               , PRDY , PEOL , PEOT , PRDD , PWRD , PCLK , PWLN , PRLN
               , PRDI , PEOF , PELN , PRDS , PTRP , PXIT , PFDF , PSIO
               , PEIO , PMSG , PSKP , PLIM , PTRA , PWRP , PCLS , PDAT
               , PTIM , PFLR , PTRC , PRND , PWRV , PAPN , PRDV , PRFC
               , PRFS , PRFV , UNDEF_CSP ) ;

     (******************************)
     (* types of parameters        *)
     (******************************)

     IDKIND = ( NORMALVAR , VALUEPARM , VARPARM , CONSTPARM ) ;

     (******************************)
     (* storage classes            *)
     (******************************)

     STORAGE_CLASS = ( XAUTO , XSTATIC ) ;
     WITH_COPY_TYPE = ( WCNONE , WCINCLUDE , WCPOINTER ) ;

     (******************************************************)
     (* identifier entries                                 *)
     (*                                                    *)
     (* some comments on new fields (since 2011):          *)
     (*                                                    *)
     (* konst - values: contains the value (xconstant)     *)
     (* structkonst: skownerproc is the external name of   *)
     (*       the proc which implements the                *)
     (*       structured constant ... the name             *)
     (*       of the static csect is derived from          *)
     (*       this; skaddr is the displ. there             *)
     (* vars: same for vownerproc and vaddr, if stklass    *)
     (*       is static. special ind., if the variable     *)
     (*       needs special treatment (TIME, DATE, for     *)
     (*       example; call a CSP at every reference)      *)
     (* proc/func: made extrn, extlang, extname global     *)
     (*       for both flavors of proc / func              *)
     (* proc/func standard: libname etc. for library       *)
     (*       functions which are not simply csps.         *)
     (*       the compiler generates calls to libname,     *)
     (*       where the first parameter is funccode.       *)
     (*       proctyp is omitted; the type of the          *)
     (*       standard function is known via proctype      *)
     (*       as in the declared case; idtype is set       *)
     (*       accordingly during enterstdnames.            *)
     (* proc/func declared: declmissing is used for        *)
     (*       procs and funcs which have no decl           *)
     (*       (works anyway, W184 and W186).               *)
     (*       frtrn attribute has been omitted.            *)
     (*       we now have extrn and extname and extlang;   *)
     (*       extname can be a different name from the     *)
     (*       (longer) internal name and extlang can be    *)
     (*       blank for Pascal or A / F for ASSEMBLER      *)
     (*       resp. FORTRAN. A and F generate different    *)
     (*       calling sequences.                           *)
     (*                                                    *)
     (* some comments on fields (extension 2019):          *)
     (*                                                    *)
     (* fieldaddr: offset of field within fieldlist        *)
     (* owner: points to record type where field is        *)
     (*       part of                                      *)
     (* tagpointer: new in 2019, points to typerec         *)
     (*       of tagfld type iff field in the actual       *)
     (*       fieldlist is part of a set of variants       *)
     (*       (in this case, the variants start at         *)
     (*       a certain offset which will later be         *)
     (*       recorded in the tagfld typerec)              *)
     (* with_copy: tells if this field has been            *)
     (*       entered into the fieldlist using a           *)
     (*       with clause; may be wcnone, wcinclude,       *)
     (*       wcpointer (scalar type)                      *)
     (* pointer_offset: if with_copy = wcpointer, then     *)
     (*       this is the offset where the field is        *)
     (*       located in the referenced structure          *)
     (*       (needs verification ...)                     *)
     (******************************************************)

     IDENTIFIER = record
                    NAME : ALPHA ;
                    IDTYPE : TTP ;
                    NEXT_IN_BKT : IDP ;
                    NEXT : IDP ;
                    PREV_VAR_IN_BLOCK : IDP ;
                    PREV_TYPE_IN_BLOCK : IDP ;
                    PREV_PROC_IN_BLOCK : IDP ;
                    DECL_LEV : LEVRANGE ;
                    case KLASS : IDCLASS of
                      TYPES :
                        ( REFERENCET : CHAR ) ;
                      KONST :
                        ( VALUES : XCONSTANT ) ;
                      STRUCTKONST :
                        ( SKOWNERPROC : EXTNAMTP ;
                          SKADDR : ADDRRANGE ) ;
                      VARS :
                        ( VKIND : IDKIND ;
                          VLEV : LEVRANGE ;
                          STKLASS : STORAGE_CLASS ;
                          REFERENCE : CHAR ;
                          VOWNERPROC : EXTNAMTP ;
                          VADDR : ADDRRANGE ;
                          SPECIAL : INTEGER ;
                          DUMMYVAR : BOOLEAN ;
                          DUMMYLEV : LEVRANGE ;
                          DUMMYADDR : ADDRRANGE ) ;
                      FIELD :
                        ( FIELDADDR : ADDRRANGE ;
                          OWNER : TTP ;
                          TAGPOINTER : TTP ;
                          WITH_COPY : WITH_COPY_TYPE ;
                          POINTER_OFFSET : ADDRRANGE ;
                          INSERTED_BY_WITH : BOOLEAN ) ;
                      PROC , FUNC :
                        ( EXTRN : BOOLEAN ;
                          EXTLANG : CHAR ;
                          EXTNAME : EXTNAMTP ;
                          REFERENCEP : CHAR ;
                          case PFDECKIND : DECLKIND of
                            STANDARD :
                              ( KEY : INTEGER ;
                                LIBNAME : EXTNAMTP ;
                                FUNCCODE : INTEGER ;
                                PARMCNT : INTEGER ;
                                WASIZE : INTEGER ) ;
                            DECLARED :
                              ( FWDECL : BOOLEAN ;
                                PFLEV : INTEGER ;
                                PFNAME : LABELRNG ;
                                PRMPTR , NXTFWRD : IDP ;
                                PFKIND : IDKIND ;
                                DECLMISSING : BOOLEAN ;
                                CSTNAME : EXTNAMTP ) )
                  end ;
     DISPRANGE = 0 .. DISPLIMIT ;
     HASH_TABLE = array [ BKT_RNG ] of IDP ;
     HASH_COUNT = array [ BKT_RNG ] of INTEGER ;
     WHERE = ( BLCK , CREC , VREC , REC ) ;

     (******************)
     (* EXPRESSIONS    *)
     (******************)

     ATTRKIND = ( CST , VARBL , EXPR ) ;
     VACCESS = ( DRCT , INDRCT , INXD , STKEXPR ) ;
     ATTR = record

     (*********************************)
     (* TYPE AS AN EXPR. ON RUN-STACK *)
     (*********************************)

              TYPTR : TTP ;

     (*********************************)
     (* TYPE AS A VARIABLE IN MEMORY  *)
     (*********************************)

              BTYPE : TTP ;
              case KIND : ATTRKIND of
                CST :
                  ( CVAL : XCONSTANT ) ;
                VARBL :
                  ( case ACCESS : VACCESS of
                      DRCT :
                        ( VLEVEL : LEVRANGE ;
                          DPLMT : ADDRRANGE ) ;
                      INDRCT :
                        ( IDPLMT : ADDRRANGE ) ;
                      STKEXPR :
                        ( STKDPLMT , STKLEN : ADDRRANGE ) )
            end ;
     TESTP = -> TESTPOINTER ;
     TESTPOINTER = record
                     ELT1 , ELT2 : TTP ;
                     LASTTESTP : TESTP
                   end ;

     (*************)
     (* LABELS    *)
     (*************)

     LBP = -> LABL ;
     LABL = record
              NEXTLAB : LBP ;
              LABVAL : INTEGER ;
              LABNAME , XNO : LABELRNG ;
              DEFINED : BOOLEAN ;
              REFERENCED : BOOLEAN
            end ;
     FRECPTR = -> FILEREC ;
     FILEREC = record
                 FILIDPTR : IDP ;
                 NEXTFILE : FRECPTR ;
               end ;
     ERRCODE = 0 .. MAXERRNR ;
     CTRRANGE = 0 .. CTRMAX ;
     CTRTYPE = ( CTRPROC , CTRLBL , CTRGOTO , CTRIF , CTRWHILE ,
               CTRREPEAT , CTRFOR , CTRCASE ) ;
     LOOPCTL = record
                 LEVEL : INTEGER ;
                 BREAKLABEL : LABELRNG ;
                 BREAKUSED : BOOLEAN ;
                 CONTLABEL : LABELRNG ;
                 CONTUSED : BOOLEAN ;
               end ;
     SUBRCTL = record
                 RETURNLABEL : LABELRNG ;
                 RETURNUSED : BOOLEAN ;
               end ;

     /******************************************/
     /* Subtypen fuer Scanner-Typen            */
     /******************************************/

     CHAR32 = array [ 1 .. 32 ] of CHAR ;
     CHAR64 = array [ 1 .. 64 ] of CHAR ;
     SOURCELINE = array [ 1 .. MAXLSIZE ] of CHAR ;
     SCAN_ERRCLASS = 'A' .. 'Z' ;
     OPTIONS_PTR = -> COMP_OPTIONS ;

     /******************************************/
     /* Liste der Fehler pro Source-Zeile usw. */
     /******************************************/
     /* muss mit Def. beim Compiler            */
     /* uebereinstimmen                        */
     /******************************************/

     SCANF_PTR = -> SCAN_FEHLER ;
     SCAN_FEHLER = record
                     ERRLEVEL : CHAR ;       // error level
                     ERRCLASS : CHAR ;       // error class
                     NUMMER : INTEGER ;      // error number
                     INFO : CHAR64 ;         // additional info
                     ZEILNR : INTEGER ;      // line number of err
                     POSITION : INTEGER ;    // position of err
                     NAECHST : SCANF_PTR ;   // ptr to next
                     ZEILNR_SKIP : INTEGER ; // line number skip
                     POS_SKIP : INTEGER ;    // position skip
                   end ;

     /***********************************/
     /* zentraler Scan-Block            */
     /***********************************/
     /* muss mit Def. beim Scanner      */
     /* uebereinstimmen                 */
     /***********************************/

     SCAN_BLOCK = record
                    MODUS : INTEGER ;        // modus of scanner
                    DATEIENDE : INTEGER ;    // end of file indicator
                    ENDOFLINE : BOOLEAN ;    // end of line indicator
                    SLINE : SOURCELINE ;     // stored source line
                    LINENR : INTEGER ;       // line number of symbol
                    LINEPOS : INTEGER ;      // line position of symb
                    LINELEN : INTEGER ;      // line length
                    SKIPPING : BOOLEAN ;     // parser is skipping
                    LOOKAHEAD : CHAR ;       // lookahead character
                    SYMBOLNR : SYMB ;        // symbol read
                    SYMBOL : SOURCELINE ;    // characters of symb
                    LSYMBOL : INTEGER ;      // no of chars in symb
                    MAXLSYMBOL : INTEGER ;   //
                    UFZAHL : INTEGER ;       // no of undef errors
                    SFZAHL : INTEGER ;       // no of severe errors
                    FEZAHL : INTEGER ;       // no of errors
                    WAZAHL : INTEGER ;       // no of warnings
                    INZAHL : INTEGER ;       // no of informations
                    FEANFANG : SCANF_PTR ;   // anchor to err list
                    FEAKT : SCANF_PTR ;      // actual err elem
                    FTTAB : ANYPTR ;         // error text table
                    FTTABA : ANYPTR ;        // same for applic.
                    OPTLINE : SOURCELINE ;   // options line
                    POPT : OPTIONS_PTR ;     // ptr to opt struct

     /******************************************/
     /* felder fuer sofortige Protokollausgabe */
     /******************************************/

                    PROTOUT : BOOLEAN ;        // switch for prot out
                    TERMOUT : BOOLEAN ;        // switch for term out
                    FEAKT_ALT : SCANF_PTR ;    // old feakt
                    LINEINFO : CHAR32 ;        // line information
                    LINEINFO_SIZE : INTEGER ;  // size of lineinfo

     /******************************************/
     /* felder fuer ueberschrift               */
     /******************************************/

                    LINECOUNT : INTEGER ;      // linecount f. heading
                    HEADLINE : SOURCELINE ;    // header line
                    HEADLINE_SIZE : INTEGER ;  // size of header line
                    PAGENR : INTEGER ;         // page number
                  end ;

     /***********************************/
     /* Optionen fuer Compiler          */
     /***********************************/
     /* muss mit Def. beim Scanner      */
     /* uebereinstimmen                 */
     /***********************************/

     COMP_OPTIONS = record
                      LMARGIN : INTEGER ;    // left margin
                      RMARGIN : INTEGER ;    // right margin
                      PAGESIZE : INTEGER ;   // pagesize of listing
                      LIST : BOOLEAN ;       // write listing
                      PRCODE : BOOLEAN ;     // print code
                      GET_STAT : BOOLEAN ;   // get statistics
                      SAVEREGS : BOOLEAN ;   // saveregs
                      SAVEFPRS : BOOLEAN ;   // save fp regs
                      DEBUG : BOOLEAN ;      // debug switch
                      MWARN : BOOLEAN ;      //
                      DEBUG_LEV : 0 .. 9 ;   // debug level
                      NOPACKING : BOOLEAN ;  // no packing
                      NESTCOMM : BOOLEAN ;   // nested comments
                      WARNING : BOOLEAN ;    // show warnings
                      ASSEMBLE : BOOLEAN ;   // show assembly
                      ASMVERB : BOOLEAN ;    // show verbose ass.
                      CTROPTION : BOOLEAN ;  // show counters
                      SHOW_LISTDEF : BOOLEAN ; // show listdef
                    end ;

     /*****************************************************/
     /* to control the allocation                         */
     /* of items on the string workarea                   */
     /*****************************************************/
     /* watch1 stays on during compilation of a           */
     /* statement or condition and controls the           */
     /* generation of VPU/VPO pairs for this statements   */
     /*****************************************************/
     /* watch2 stays on during compilation of a           */
     /* function body involving a string function         */
     /* result and controls generation of one VPU at      */
     /* the beginning of the function and one or more     */
     /* VPOs every time when there is an assignment to    */
     /* the function result                               */
     /*****************************************************/

     CTL_STRINGAREA = record
                        WATCH1 : BOOLEAN ;
                        WATCH2 : BOOLEAN ;
                        VPU1_LEVEL : LEVRANGE ;
                        VPU1_OFFSET : ADDRRANGE ;
                        VPO1_NEEDED : BOOLEAN ;
                        VPU2_DONE : BOOLEAN ;
                        VPU2_LEVEL : LEVRANGE ;
                        VPU2_OFFSET : ADDRRANGE ;
                      end ;


var MXINT2 : INTEGER ;
    MXINT10 : INTEGER ;
    MXINT16 : INTEGER ;
    PCODE : TEXT ;
    TRACEF : TEXT ;
    LISTING : TEXT ;
    LISTDEF : TEXT ;
    DBGINFO : TEXT ;
    SOURCENAME : EXTNAMTP ;
    SX : INTEGER ;
    SID_RC : INTEGER ;
    PROGNAME : ALPHA ;
    NAME_PATTERN : ALPHA ;

    /*********************************************/
    /* compiler options in new opt structure     */
    /*********************************************/

    OPT : COMP_OPTIONS ;
    SCB : SCAN_BLOCK ;

    (*******************************************************)
    (* RETURNED BY SOURCE PROGRAM SCANNER    INSYMBOL:     *)
    (*                                       *********     *)
    (* SY       - symbol read                              *)
    (* SYLENGTH - length of symbol or constant             *)
    (* SYDIGITS - digits of symbol (if const number)       *)
    (* SYPREC   - precision of symbol (if decimal const)   *)
    (* SYID     - identifier (if symbol was ident)         *)
    (* SYVAL    - constant (if symbol was constant)        *)
    (*******************************************************)

    SY : SYMB ;
    SYLENGTH : INTEGER ;
    SYDIGITS : INTEGER ;
    SYPREC : INTEGER ;
    SYID : ALPHA ;
    SYVAL : XCONSTANT ;

    (******************************************)
    (* COUNTERS:                              *)
    (* *********                              *)
    (******************************************)

    CHCNT : 0 .. BUFLEN ;

    (******************************************)
    (* CHARACTER COUNTER                      *)
    (******************************************)

    CONSTLCOUNTER , LCOUNTER : ADDRRANGE ;
    ICOUNTER , OLDICOUNTER : ADDRRANGE ;
    STRCOUNTER : ADDRRANGE ;

    (***********************************************************)
    (* CONSTLCOUNTER = DATA LOC. FOR STRUCTURED CONSTANTS      *)
    (* LCOUNTER      = DATA LOCATION                           *)
    (* ICOUNTER      = INSTRUCTION COUNTER                     *)
    (* OLDICOUNTER   = OLD INSTRUCTION COUNTER                 *)
    (* STRCOUNTER    = STRING INSTRUCTION COUNTER              *)
    (***********************************************************)

    LINECNT , OLDLN , PLCNT , ERRLN : INTEGER ;

    (******************************************)
    (* SWITCHES:                              *)
    (* *********                              *)
    (******************************************)

    HP : BOOLEAN ;

    (******************************************)
    (* HEADER PART                            *)
    (******************************************)

    PACKDATA : BOOLEAN ;

    (******************************************)
    (* ASSIGNMENT GOING ON,PACKING IN EFFECT  *)
    (******************************************)

    EXTUSED : BOOLEAN ;

    (******************************************)
    (* POSTPROCESSOR TRANSLATION, VERBOSE     *)
    (******************************************)

    IS_MODULE : BOOLEAN ;    // true, if source is a module

    (************************************)
    (* pointers to                      *)
    (* PREDEFINED FILES INPUT + OUTPUT  *)
    (************************************)

    INPUTPTR , OUTPUTPTR : IDP ;

    (************************************)
    (* pointers to                      *)
    (* PREDEFINED types                 *)
    (************************************)

    PTYPE_INT , PTYPE_REAL , PTYPE_CHAR , PTYPE_BOOL , PTYPE_ANY ,
    PTYPE_ANYFILE , PTYPE_TEXT , PTYPE_ALFA , PTYPE_VARCHAR ,
    PTYPE_DECIMAL : TTP ;

    (******************************************)
    (* pointers to                            *)
    (* ENTRIES OF STANDARD IDS                *)
    (******************************************)

    UTYPPTR , UCSTPTR , UVARPTR : IDP ;
    UFLDPTR , UPRCPTR , UFCTPTR : IDP ;

    (******************************************)
    (* POINTER TO $PASMAIN ENTRY              *)
    (******************************************)

    MAINPROG : IDP ;

    (******************************************)
    (* POINTER TO LIST OF FORTRAN PROC PARMS  *)
    (******************************************)

    FRTPARHD : IDP ;

    (******************************************)
    (* HEAD OF CHAIN OF FORW DECL TYPE IDS    *)
    (******************************************)

    FWPTR : IDP ;

    (******************************************)
    (* HEAD OF CHAIN OF EXTERNAL FILES        *)
    (******************************************)

    FILEHEAD : FRECPTR ;

    (******************************************)
    (* CURRENT RECORD OPENED BY "WITH"        *)
    (******************************************)

    OPEN_RECORD : TTP ;

    (******************************************)
    (* LAST TESTPOINTER                       *)
    (******************************************)

    GLOBTESTP : TESTP ;

    (*************************************************)
    (* listtag = LISTING TAG, D / C / N / blank      *)
    (* level = bookkeeping OF DECLARATION LEVELS     *)
    (* dcn = level printed for compile listing       *)
    (* all three are used to print compiler info     *)
    (* on each source line in the compiler listing   *)
    (* old values to act on changes ...              *)
    (*************************************************)

    LISTTAG : CHAR ;
    LEVEL : LEVRANGE ;
    DCN : ADDRRANGE ;
    OLDLISTTAG : CHAR ;
    OLDLEVEL : LEVRANGE ;
    OLDDCN : ADDRRANGE ;
    OLDCONSTLCOUNTER , OLDLCOUNTER : ADDRRANGE ;
    OLDLINENR : INTEGER ;

    (******************************************)
    (* CURRENT STATIC LEVEL                   *)
    (******************************************)

    STMTNEST : 0 .. 100 ;

    (******************************************)
    (* CURRENT STATEMENT NESTING              *)
    (* LEVEL OF LAST ID SEARCHED BY SEARCHID  *)
    (******************************************)

    DISX , TOP : - 1 .. DISPLIMIT ;

    (*******************************************)
    (* TOP OF DISPLAY                          *)
    (* WHERE:   MEANS:                         *)
    (* =BLCK:   ID IS VARIABLE ID              *)
    (* =CREC:   ID IS FIELD ID IN RECORD WITH  *)
    (*          CONSTANT ADDRESS               *)
    (* =VREC:   ID IS FIELD ID IN RECORD WITH  *)
    (*          VARIABLE ADDRESS               *)
    (*******************************************)

    DISPLAY : array [ DISPRANGE ] of record
                                       case OCCUR : WHERE of
                                         BLCK :
                                           ( FLABEL : LBP ) ;
                                         CREC :
                                           ( CLEV : LEVRANGE ;
                                             CDSPL : ADDRRANGE ) ;
                                         VREC :
                                           ( VDSPL : ADDRRANGE )
                                     end ;

    (******************************************)
    (* --> PROCEDURE WITHSTATEMENT            *)
    (* RUN-TIME PROFILER COUNTERS             *)
    (* **************************             *)
    (******************************************)

    CTRCNT : CTRRANGE ;
    CTRCNTLBL : LABELRNG ;

    (******************************************)
    (* EXPRESSION COMPILATION:                *)
    (* ***********************                *)
    (******************************************)

    GATTR : ATTR ;

    //****************************************************************
    // gattr - very important - DESCRIBES THE EXPR CURRENTLY COMPILED
    // ctls - watches the allocation of strings in the working area
    //****************************************************************

    CTLS : CTL_STRINGAREA ;

    (******************************************)
    (* DESCRIBES THE EXPR CURRENTLY COMPILED  *)
    (******************************************)

    PSIGLOB : PSETINFO ;
    OPTLINE : SOURCELINE ;
    INTLABEL , PROCLAB , XLABNO : LABELRNG ;
    CALL_LVL : array [ BOOLEAN ] of INTEGER ;

    (**********************************************************)
    (*  UPSHIFT and SSY in an ideal world should cover        *)
    (*  the whole range of characters / B.Oppolzer - 2016     *)
    (**********************************************************)
    (*  must include all chars for port to Windows / Linux    *)
    (**********************************************************)
    (*  SSY completely removed when moving to new             *)
    (*  PASSCAN scanner, same goes for table SOP and          *)
    (*  type OPERSYMB ... all symbol handling is now done     *)
    (*  in PASSCAN by generated logic / B.Oppolzer - 2017     *)
    (**********************************************************)

    UPSHIFT : array [ CHAR ] of CHAR ;
    BUCKET : HASH_TABLE ;
    BUCKET_COUNT : HASH_COUNT ;

    (******************************************)
    (* SYMBOL TABLE USAGE STATISTICS          *)
    (* ****** ***** ***** **********          *)
    (******************************************)

    FENT_CNT , SF_CNT , SF_TOT : INTEGER ;

    (******************************************)
    (* # FIELD ENTRIES, SEARCHES, PRODUCT     *)
    (******************************************)

    WE_CNT , RE_CNT : INTEGER ;

    (******************************************)
    (* # "WITH" LOOKUPS, # RECORDS            *)
    (******************************************)

    WS_CNT : INTEGER ;

    (******************************************)
    (* # WITH STATEMENTS                      *)
    (******************************************)

    PROC_CNT , ENT_CNT : array [ LEVRANGE ] of INTEGER ;
    LU_CNT : array [ LEVRANGE , DISPRANGE ] of INTEGER ;
    WLU_CNT : array [ 1 .. 10 , 1 .. 10 ] of INTEGER ;

    (******************************************)
    (* errlog stores the error types that     *)
    (* have occured during compile            *)
    (* set of errcode = bit mask              *)
    (******************************************)

    ERRLOG : set of ERRCODE ;

    (******************************************)
    (* COMPILATION TIME                       *)
    (******************************************)

    CTIME : INTEGER ;

    (******************************************)
    (* KIND OF ERROR, 'E' / 'W' (WARNING)     *)
    (******************************************)

    ERRKIND : CHAR ;

    (******************************************)
    (* ordinal number of conditional          *)
    (* code sequences, startet by XBG and     *)
    (* ended by XEN Pcode                     *)
    (******************************************)

    XBG_NUMBER : INTEGER ;

    (***********************************************************)
    (* STRUCTURED CONSTANTS, READ-ONLY TABLES                  *)
    (* ********** *********  **** **** ******                  *)
    (***********************************************************)

    xtest : string (100);

const BLANKID : ALPHA = '            ' ;
      HEXTAB : array [ 0 .. 15 ] of CHAR = '0123456789abcdef' ;
      LOW_LETTERS : SET_CHAR =
      [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' ] ;
      UP_LETTERS : SET_CHAR =
      [ 'A' .. 'I' , 'J' .. 'R' , 'S' .. 'Z' ] ;
      HEX_CHARS : SET_CHAR =
      [ 'a' .. 'f' , 'A' .. 'F' , '0' .. '9' ] ;
      BIN_CHARS : SET_CHAR =
      [ '0' .. '1' ] ;
      CONSTBEGSYS : SYMSET =
      [ SYPLUS , SYMINUS , INTCONST , REALCONST , STRINGCONST , IDENT ]
        ;
      WRITEBEGSYS : SYMSET =
      [ SYPLUS , SYMINUS , INTCONST , REALCONST , STRINGCONST , IDENT ,
        SYLPARENT ] ;
      SIMPTYPEBEGSYS : SYMSET =
      [ SYPLUS , SYMINUS , INTDOTDOT , INTCONST , STRINGCONST , IDENT ,
        SYLPARENT ] ;
      TYPEBEGSYS : SYMSET =
      [ SYARROW , SYPACKED , SYARRAY , SYRECORD , SYSET , SYFILE ,
        SYPLUS , SYMINUS , INTDOTDOT , INTCONST , STRINGCONST , IDENT ,
        SYLPARENT ] ;
      TYPEDELS : SYMSET =
      [ SYARRAY , SYRECORD , SYSET , SYFILE , SYPACKED ] ;
      BLOCKBEGSYS : SYMSET =
      [ SYLABEL , SYCONST , SYTYPE , SYVAR , SYSTATIC , SYPROC , SYFUNC
        , SYLOCAL , SYBEGIN ] ;
      SELECTSYS : SYMSET =
      [ SYARROW , SYPERIOD , SYLBRACK , SYLPARENT ] ;
      FACBEGSYS : SYMSET =
      [ INTCONST , REALCONST , STRINGCONST , IDENT , SYLPARENT ,
        SYLBRACK , SYNOT ] ;
      STATBEGSYS : SYMSET =
      [ SYBEGIN , SYGOTO , SYIF , SYWHILE , SYREPEAT , SYFOR , SYWITH ,
        SYCASE , SYBREAK , SYCONTINUE , SYRETURN ] ;
      PROCCALLENDSYS : SYMSET =
      [ SYLPARENT , SYSEMICOLON , SYEND , SYELSE , SYUNTIL ] ;
      FACTOROPS : SYMSET =
      [ SYMULT , SYSLASH , SYDIV , SYMOD , SYAND , SYANDOP ] ;
      TERMOPS : SYMSET =
      [ SYPLUS , SYMINUS , SYOR , SYOROP , SYXOR , SYCONCAT ] ;
      EXPROPS : SYMSET =
      [ SYEQOP , SYNEOP , SYGTOP , SYLTOP , SYGEOP , SYLEOP , SYIN ] ;

      (*********************************************************)
      (*   new reserved symbols in the 2011 version:           *)
      (*   break, return, continue                             *)
      (*********************************************************)

      RW : array [ 1 .. MAXRW ] of ALPHA =
      ( 'IF          ' , 'DO          ' , 'OF          ' ,
        'TO          ' , 'IN          ' , 'OR          ' ,
        'END         ' , 'FOR         ' , 'VAR         ' ,
        'DIV         ' , 'MOD         ' , 'SET         ' ,
        'AND         ' , 'NOT         ' , 'XOR         ' ,
        'THEN        ' , 'ELSE        ' , 'WITH        ' ,
        'GOTO        ' , 'CASE        ' , 'TYPE        ' ,
        'FILE        ' , 'BEGIN       ' , 'UNTIL       ' ,
        'WHILE       ' , 'ARRAY       ' , 'CONST       ' ,
        'LABEL       ' , 'LOCAL       ' , 'BREAK       ' ,
        'REPEAT      ' , 'RECORD      ' , 'DOWNTO      ' ,
        'PACKED      ' , 'RETURN      ' , 'MODULE      ' ,
        'STATIC      ' , 'FORWARD     ' , 'PROGRAM     ' ,
        'FORTRAN     ' , 'EXTERNAL    ' , 'FUNCTION    ' ,
        'CONTINUE    ' , 'PROCEDURE   ' , 'OTHERWISE   ' ,
        '            ' , '            ' , '            ' ,
        '            ' , '            ' ) ;
      FRW : array [ 1 .. 12 ] of 1 .. MAXRW =

      (**********************************************************)
      (*  1  2  3    4    5    6    7    8    9   10   11   12  *)
      (**********************************************************)

      ( 1 , 1 , 7 , 16 , 23 , 31 , 38 , 41 , 44 , 46 , - 1 , - 1 ) ;
      RSY : array [ 1 .. MAXRW ] of SYMB =
      ( SYIF , SYDO , SYOF , SYTO , SYIN , SYOR , SYEND , SYFOR , SYVAR
        , SYDIV , SYMOD , SYSET , SYAND , SYNOT , SYXOR , SYTHEN ,
        SYELSE , SYWITH , SYGOTO , SYCASE , SYTYPE , SYFILE , SYBEGIN ,
        SYUNTIL , SYWHILE , SYARRAY , SYCONST , SYLABEL , SYLOCAL ,
        SYBREAK , SYREPEAT , SYRECORD , SYDOWNTO , SYPACKED , SYRETURN
        , SYMODULE , SYSTATIC , SYFORWARD , SYPROG , SYFRTRN , SYEXTRN
        , SYFUNC , SYCONTINUE , SYPROC , SYOTHERWISE , NOTUSED ,
        NOTUSED , NOTUSED , NOTUSED , NOTUSED ) ;

      (*********************************************************)
      (*   Symbols as Text                                     *)
      (*********************************************************)

      SYMB_CHAR : array [ SYMB ] of STRING ( 15 ) = //
      ( 'SYMB_EOF' ,                                //
        'SYMB_UNKNOWN' ,                            //
        'EOLCHAR' ,                                 //
        'SEPARATOR' ,                               //
        'COMMENT1' ,                                //
        'COMMENT2' ,                                //
        'COMMENT3' ,                                //
        'COMMENT4' ,                                //
        'COMMENT5' ,                                //
        'STRINGCONST' ,                             //
        'HEXSTRINGCONST' ,                          //
        'BINSTRINGCONST' ,                          //
        'INTCONST' ,                                //
        'INTDOTDOT' ,                               //
        'REALCONST' ,                               //
        'IDENT' ,                                   //
        'LPARENT' ,                                 //
        'RPARENT' ,                                 //
        'LBRACK' ,                                  //
        'RBRACK' ,                                  //
        'COMMA' ,                                   //
        'SEMICOLON' ,                               //
        'ARROW' ,                                   //
        'PERIOD' ,                                  //
        'DOTDOT' ,                                  //
        'COLON' ,                                   //
        'PLUS' ,                                    //
        'MINUS' ,                                   //
        'MULT' ,                                    //
        'SLASH' ,                                   //
        'EQOP' ,                                    //
        'NEOP' ,                                    //
        'GTOP' ,                                    //
        'LTOP' ,                                    //
        'GEOP' ,                                    //
        'LEOP' ,                                    //
        'OROP' ,                                    //
        'ANDOP' ,                                   //
        'ASSIGN' ,                                  //
        'CONCAT' ,                                  //
        'AND' ,                                     //
        'DIV' ,                                     //
        'MOD' ,                                     //
        'OR' ,                                      //
        'XOR' ,                                     //
        'IN' ,                                      //
        'NOT' ,                                     //
        'LABEL' ,                                   //
        'CONST' ,                                   //
        'TYPE' ,                                    //
        'VAR' ,                                     //
        'FUNCTION' ,                                //
        'PROGRAM' ,                                 //
        'PROCEDURE' ,                               //
        'SET' ,                                     //
        'PACKED' ,                                  //
        'ARRAY' ,                                   //
        'RECORD' ,                                  //
        'FILE' ,                                    //
        'FORWARD' ,                                 //
        'BEGIN' ,                                   //
        'IF' ,                                      //
        'CASE' ,                                    //
        'REPEAT' ,                                  //
        'WHILE' ,                                   //
        'FOR' ,                                     //
        'WITH' ,                                    //
        'GOTO' ,                                    //
        'END' ,                                     //
        'ELSE' ,                                    //
        'UNTIL' ,                                   //
        'OF' ,                                      //
        'DO' ,                                      //
        'TO' ,                                      //
        'DOWNTO' ,                                  //
        'THEN' ,                                    //
        'FORTRAN' ,                                 //
        'EXTERNAL' ,                                //
        'OTHERWISE' ,                               //
        'BREAK' ,                                   //
        'CONTINUE' ,                                //
        'RETURN' ,                                  //
        'MODULE' ,                                  //
        'LOCAL' ,                                   //
        'STATIC' ,                                  //
        'NOTUSED' ) ;                               //

      (*********************************************************)
      (*   names of P-Code instructions                        *)
      (*********************************************************)

      MN : array [ 0 .. OPMAX ] of array [ 1 .. 4 ] of CHAR =
      ( ' ABI' , ' ABR' , ' ADI' , ' ADR' , ' AND' , ' DIF' , ' DVI' ,
        ' DVR' , ' SBR' , ' FLO' , ' FLT' , ' INN' , ' INT' , ' IOR' ,
        ' MOD' , ' MPI' , ' MPR' , ' NGI' , ' NGR' , ' NOT' , ' ODD' ,
        ' SBI' , ' DEC' , ' INC' , ' SQI' , ' SQR' , ' STO' , ' ---' ,
        ' ---' , ' SCL' , ' CSP' , ' UNI' , ' ENT' , ' FJP' , ' POP' ,
        ' IND' , ' IXA' , ' LCA' , ' CTS' , ' CTI' , ' MOV' , ' MST' ,
        ' RET' , ' STP' , ' XJP' , ' CHK' , ' CUP' , ' EQU' , ' GEQ' ,
        ' GRT' , ' LDA' , ' LDC' , ' LEQ' , ' LES' , ' LOD' , ' NEQ' ,
        ' STR' , ' UJP' , ' NEW' , ' SAV' , ' RST' , ' ORD' , ' CHR' ,
        ' DEF' , ' LAB' , ' CRD' , ' XPO' , ' ASE' , ' SLD' , ' SMV' ,
        ' DFC' , ' CST' , ' BGN' , ' UXJ' , ' XLB' , ' END' , ' PAK' ,
        ' ADA' , ' SBA' , ' XOR' , ' MFI' , ' MCP' , ' MSE' , ' DBG' ,
        ' MZE' , ' VC1' , ' VC2' , ' VCC' , ' VLD' , ' VST' , ' VMV' ,
        ' VSM' , ' VLM' , ' VPU' , ' VPO' , ' VIX' , ' VRP' , ' MCC' ,
        ' MCV' , ' ASR' , ' XBG' , ' XEN' , '    ' , '    ' , '    ' )
        ;

      (*********************************************************)
      (*   names of CSPs, index type should be CSPTYPE,        *)
      (*   but it is indexed by ORD (CSP) in GEN1 ...          *)
      (*********************************************************)

      CSPNAME : array [ 0 .. 55 ] of array [ 1 .. 3 ] of CHAR =
      ( 'PAG' , 'GET' , 'PUT' , 'RES' , 'REW' , 'RDC' , 'WRI' , 'WRE' ,
        'WRR' , 'WRC' , 'WRS' , 'WRX' , 'RDB' , 'WRB' , 'RDR' , 'RDH' ,
        'RDY' , 'EOL' , 'EOT' , 'RDD' , 'WRD' , 'CLK' , 'WLN' , 'RLN' ,
        'RDI' , 'EOF' , 'ELN' , 'RDS' , 'TRP' , 'XIT' , 'FDF' , 'SIO' ,
        'EIO' , 'MSG' , 'SKP' , 'LIM' , 'TRA' , 'WRP' , 'CLS' , 'DAT' ,
        'TIM' , 'FLR' , 'TRC' , 'RND' , 'WRV' , 'APN' , 'RDV' , 'RFC' ,
        'RFS' , 'RFV' , '   ' , '   ' , '   ' , '   ' , '   ' , '   ' )
        ;

      (*********************************************************)
      (*-------------------------------------------------------*)
      (*********************************************************)




procedure SKIP_SYMBOL ( FSYS : SYMSET ) ;

(*****************************************************)
(*   SKIP INPUT STRING UNTIL RELEVANT SYMBOL FOUND   *)
(*****************************************************)


   var PFDUMMY : SCANF_PTR ;
       S : SYMB ;
       X : STRING ( 64 ) ;
       SKIPINFO : CHAR64 ;
       SSTR : STRING ( 20 ) ;

   begin (* SKIP_SYMBOL *)
     if not ( SY in FSYS ) then
       begin
         X := '' ;
         for S := SYMB_EOF to NOTUSED do
           if S in FSYS then
             begin
               SSTR := SYMB_CHAR [ S ] ;
               if LENGTH ( X ) + LENGTH ( SSTR ) + 1 >= 60 then
                 begin
                   X := X || ',...' ;
                   break
                 end (* then *)
               else
                 X := X || ',' || SSTR ;
             end (* then *) ;
       end (* then *) ;
   end (* SKIP_SYMBOL *) ;



procedure WRITEDFC ( ELSP1 : TTP ; ELSIZE : INTEGER ; LVALU : XCONSTANT
                   ; INIT : BOOLEAN ) ;

   var CH : CHAR ;

   begin (* WRITEDFC *)
     WRITE ( PCODE , CONSTLCOUNTER : 1 , MN [ PCODE_DFC ] ) ;
   end (* WRITEDFC *) ;



begin (* HAUPTPROGRAMM *)
   xtest :=  rw [12] || symb_char [ident ];
   xtest :=  rw [12] || symb_char [ident ] || mn  [57];
   writeln (xtest);
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSTA3 EXT PAS HEX -
program TESTSTA3 ( OUTPUT ) ;

//******************************************************************************
//$A+,X+
//******************************************************************************
// assignment to const compenent inside with should throw error
//------------------------------------------------------------------------------
// in withstatement: insert information about constant in display entry
// in selector: return information about component being constant to caller
// then assignment (for example) can throw error, when assignment to constant is
// and same for passing to var parameters etc.
//******************************************************************************



type TESTREC = record
                 A : INTEGER ;
                 B : STRING ( 10 ) ;
                 C : INTEGER ;
               end ;


const C = 17 ;
      C1 : INTEGER = 27 ;
      C2 : DECIMAL ( 7 , 2 ) = 12.5 ;
      C3 : BOOLEAN = TRUE ;
      C4 : CHAR ( 10 ) = 'HUGO' ;
      C5 : STRING ( 20 ) = 'TESTSTRING' ;
      F : array [ 1 .. 5 ] of CHAR =
      ( 'a' , 'b' , 'c' ) ;
      XC : record
             A : INTEGER ;
             B : INTEGER
           end =
           ( 12 , 15 ) ;
      CNEU = C ;
      FNEU = F ;
      CT : TESTREC =
      ( 2 , 'BERND' , 12 ) ;
      CM1 , CM2 : TESTREC =
      ( 2 , 'BERND' , 12 ) ;
      CM3 , CM4 = 47 ;
      CM5 = CM3 ;
      CM6 : TESTREC = CM1 ;
      CM7 : TESTREC =
      ( C , 'HUGO' , C ) ;
      CM8 = CM1 ;
      XX : array [ 1 .. 5 ] of TESTREC =
      ( CM1 , CM7 , CM2 , CM7 , CM1 ) ;
      YY : record
             PART1 : TESTREC ;
             PART2 : TESTREC
           end =
           ( CM1 , CM7 ) ;


var X : array [ 1 .. 14 ] of INTEGER ;
    I : INTEGER ;
    CV : INTEGER := 5 ;
    V1 : INTEGER = 27 ;
    V2 : DECIMAL ( 7 , 2 ) = 12.5 ;
    V3 : BOOLEAN = TRUE ;
    V4 : CHAR ( 10 ) = 'HUGO' ;
    V5 : STRING ( 20 ) = 'TESTSTRING' ;
    VX : array [ 1 .. 14 ] of INTEGER =
         ( 2 , 3 , 5 , 7 , 11 , 13 ) ;
    VREC1 , VREC2 : TESTREC :=
                    ( 1 , 'BERND' , 7 ) ;
    VT : TESTREC = CT ;
    VVS , VVS2 : record
                   A : INTEGER ;
                   B : INTEGER
                 end :=
                 ( 12 , 15 ) ;


static S1 : INTEGER = 27 ;
       S2 : DECIMAL ( 7 , 2 ) = 12.5 ;
       S3 : BOOLEAN = TRUE ;
       S4 : CHAR ( 10 ) = 'HUGO' ;
       S5 : STRING ( 20 ) = 'TESTSTRING' ;
       SX : array [ 1 .. 14 ] of INTEGER =
            ( 2 , 3 , 5 , 7 , 11 , 13 ) ;
       SREC1 , SREC2 : TESTREC :=
                       ( 1 , 'BERND' , 7 ) ;
       ST : TESTREC = CM7 ;
       SVS , SVS2 : record
                      A : INTEGER ;
                      B : INTEGER
                    end :=
                    ( 12 , 15 ) ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( 'cm1.a = ' , CM1 . A , ' (should be 2)' ) ;
  WRITELN ( 'cm2.a = ' , CM2 . A , ' (should be 2)' ) ;
  WRITELN ( 'cm3   = ' , CM3 , ' (should be 47)' ) ;
  WRITELN ( 'cm4   = ' , CM4 , ' (should be 47)' ) ;
  WRITELN ( 'cm5   = ' , CM5 , ' (should be 47)' ) ;
  WRITELN ( 'cm6.a = ' , CM6 . A , ' (should be 2)' ) ;
  WRITELN ( 'cm7.a = ' , CM7 . A , ' (should be 17)' ) ;
  WRITELN ( 'cm7.c = ' , CM7 . C , ' (should be 17)' ) ;
  WRITELN ( 'cm8.a = ' , CM8 . A , ' (should be 2)' ) ;
  for I := 1 to 5 do
    WRITE ( XX [ I ] . A ) ;
  WRITELN ;
  WRITELN ( 'yy.1  = ' , YY . PART1 . A , ' (should be 2)' ) ;
  WRITELN ( 'yy.2  = ' , YY . PART2 . A , ' (should be 17)' ) ;
  WRITELN ( C1 , C2 , ' ' , C3 , ' ' , C4 , C5 ) ;
  WRITELN ( S1 , S2 , ' ' , S3 , ' ' , S4 , S5 ) ;
  for I := 1 to 14 do
    WRITE ( SX [ I ] : 3 ) ;
  WRITELN ;
  for I := 1 to 14 do
    WRITE ( VX [ I ] : 3 ) ;
  WRITELN ;
  WRITE ( 'array f = ' ) ;
  for I := 1 to 5 do
    WRITE ( F [ I ] : 3 ) ;
  WRITELN ;
  WRITE ( 'array fneu = ' ) ;
  for I := 1 to 5 do
    WRITE ( FNEU [ I ] : 3 ) ;
  WRITELN ;
  WRITELN ( 'srec1 = ' , SREC1 . A , ' ' , SREC1 . B : - 10 , SREC1 . C
            ) ;
  WRITELN ( 'srec2 = ' , SREC2 . A , ' ' , SREC2 . B : - 10 , SREC2 . C
            ) ;
  WRITELN ( 'vrec1 = ' , VREC1 . A , ' ' , VREC1 . B : - 10 , VREC1 . C
            ) ;
  WRITELN ( 'vrec2 = ' , VREC2 . A , ' ' , VREC2 . B : - 10 , VREC2 . C
            ) ;
  WRITELN ( 'svs   = ' , SVS . A , SVS . B ) ;
  WRITELN ( 'svs2  = ' , SVS2 . A , SVS2 . B ) ;
  for I := 1 to 14 do
    X [ I ] := 0 ;
  V5 := '' ;
  WRITELN ( V1 , V2 , ' ' , V3 , ' ' , V4 , V5 ) ;
  WRITELN ( 'vvs   = ' , VVS . A , VVS . B ) ;
  WRITELN ( 'vvs2  = ' , VVS2 . A , VVS2 . B ) ;
  WRITELN ( 'cv    = ' , CV , ' (should be 5)' ) ;
  with VVS do
    A := C ;
  WRITELN ( 'vvs   = ' , VVS . A , VVS . B ) ;
  WRITELN ( 'vvs2  = ' , VVS2 . A , VVS2 . B ) ;
  WRITELN ( 'vt    = ' , VT . A , ' ' , VT . B : - 10 , VT . C ) ;
  WRITELN ( 'st    = ' , ST . A , ' ' , ST . B : - 10 , ST . C ) ;

  //********************************
  // compiler should complain here
  // and not modify the constant
  //********************************

  C := 15 ;
  WRITELN ( 'c     = ' , C , ' (should be 17)' ) ;
  WRITELN ( 'cneu  = ' , CNEU ) ;
  CV := 7 ;
  WRITELN ( 'cv    = ' , CV ) ;
  SVS . A := 27 ;

  //********************************
  // compiler should complain here
  // and not modify the constant
  //********************************

  XC . A := SVS . A ;
  WRITELN ( 'xc.a  = ' , XC . A , ' (should be 12)' ) ;

  //********************************
  // compiler should complain here
  // and not modify the constant
  //********************************

  with XC do
    A := SVS . A ;
  WRITELN ( 'xc.a  = ' , XC . A , ' (should be 12)' ) ;
  WRITELN ( 'xc.b  = ' , XC . B ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSTA4 EXT PAS HEX -
program TESTSTA3 ( OUTPUT ) ;

//******************************************************************************
//$A+,X+
//******************************************************************************
// assignment to const compenent inside with should throw error
//------------------------------------------------------------------------------
// in withstatement: insert information about constant in display entry
// in selector: return information about component being constant to caller
// then assignment (for example) can throw error, when assignment to constant is
// and same for passing to var parameters etc.
//******************************************************************************



type TESTREC = record
                 A : INTEGER ;
                 B : STRING ( 10 ) ;
                 C : INTEGER ;
               end ;


const C = 17 ;
      C1 : INTEGER = 27 ;
      C2 : DECIMAL ( 7 , 2 ) = 12.5 ;
      C3 : BOOLEAN = TRUE ;
      C4 : CHAR ( 10 ) = 'HUGO' ;
      C5 : STRING ( 20 ) = 'TESTSTRING' ;
      F : array [ 1 .. 5 ] of CHAR =
      ( 'a' , 'b' , 'c' ) ;
      XC : record
             A : INTEGER ;
             B : INTEGER
           end =
           ( 12 , 15 ) ;
      CNEU = C ;
      FNEU = F ;
      CT : TESTREC =
      ( 2 , 'BERND' , 12 ) ;
      CM1 , CM2 : TESTREC =
      ( 2 , 'BERND' , 12 ) ;
      CM3 , CM4 = 47 ;
      CM5 = CM3 ;
      CM6 : TESTREC = CM1 ;
      CM7 : TESTREC =
      ( C , 'HUGO' , C ) ;
      CM8 = CM1 ;
      XX : array [ 1 .. 5 ] of TESTREC =
      ( CM1 , CM7 , CM2 , CM7 , CM1 ) ;
      YY : record
             PART1 : TESTREC ;
             PART2 : TESTREC
           end =
           ( CM1 , CM7 ) ;


var X : array [ 1 .. 14 ] of INTEGER ;
    I : INTEGER ;
    CV : INTEGER := 5 ;
    V1 : INTEGER = 27 ;
    V2 : DECIMAL ( 7 , 2 ) = 12.5 ;
    V3 : BOOLEAN = TRUE ;
    V4 : CHAR ( 10 ) = 'HUGO' ;
    V5 : STRING ( 20 ) = 'TESTSTRING' ;
    VX : array [ 1 .. 14 ] of INTEGER =
         ( 2 , 3 , 5 , 7 , 11 , 13 ) ;
    VREC1 , VREC2 : TESTREC :=
                    ( 1 , 'BERND' , 7 ) ;
    VT : TESTREC = CT ;
    VVS , VVS2 : record
                   A : INTEGER ;
                   B : INTEGER
                 end :=
                 ( 12 , 15 ) ;


static S1 : INTEGER = 27 ;
       S2 : DECIMAL ( 7 , 2 ) = 12.5 ;
       S3 : BOOLEAN = TRUE ;
       S4 : CHAR ( 10 ) = 'HUGO' ;
       S5 : STRING ( 20 ) = 'TESTSTRING' ;
       SX : array [ 1 .. 14 ] of INTEGER =
            ( 2 , 3 , 5 , 7 , 11 , 13 ) ;
       SREC1 , SREC2 : TESTREC :=
                       ( 1 , 'BERND' , 7 ) ;
       ST : TESTREC = CM7 ;
       SVS , SVS2 : record
                      A : INTEGER ;
                      B : INTEGER
                    end :=
                    ( 12 , 15 ) ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( 'cm1.a = ' , CM1 . A , ' (should be 2)' ) ;
  WRITELN ( 'cm2.a = ' , CM2 . A , ' (should be 2)' ) ;
  WRITELN ( 'cm3   = ' , CM3 , ' (should be 47)' ) ;
  WRITELN ( 'cm4   = ' , CM4 , ' (should be 47)' ) ;
  WRITELN ( 'cm5   = ' , CM5 , ' (should be 47)' ) ;
  WRITELN ( 'cm6.a = ' , CM6 . A , ' (should be 2)' ) ;
  WRITELN ( 'cm7.a = ' , CM7 . A , ' (should be 17)' ) ;
  WRITELN ( 'cm7.c = ' , CM7 . C , ' (should be 17)' ) ;
  WRITELN ( 'cm8.a = ' , CM8 . A , ' (should be 2)' ) ;
  for I := 1 to 5 do
    WRITE ( XX [ I ] . A ) ;
  WRITELN ;
  WRITELN ( 'yy.1  = ' , YY . PART1 . A , ' (should be 2)' ) ;
  WRITELN ( 'yy.2  = ' , YY . PART2 . A , ' (should be 17)' ) ;
  WRITELN ( C1 , C2 , ' ' , C3 , ' ' , C4 , C5 ) ;
  WRITELN ( S1 , S2 , ' ' , S3 , ' ' , S4 , S5 ) ;
  for I := 1 to 14 do
    WRITE ( SX [ I ] : 3 ) ;
  WRITELN ;
  for I := 1 to 14 do
    WRITE ( VX [ I ] : 3 ) ;
  WRITELN ;
  WRITE ( 'array f = ' ) ;
  for I := 1 to 5 do
    WRITE ( F [ I ] : 3 ) ;
  WRITELN ;
  WRITE ( 'array fneu = ' ) ;
  for I := 1 to 5 do
    WRITE ( FNEU [ I ] : 3 ) ;
  WRITELN ;
  WRITELN ( 'srec1 = ' , SREC1 . A , ' ' , SREC1 . B : - 10 , SREC1 . C
            ) ;
  WRITELN ( 'srec2 = ' , SREC2 . A , ' ' , SREC2 . B : - 10 , SREC2 . C
            ) ;
  WRITELN ( 'vrec1 = ' , VREC1 . A , ' ' , VREC1 . B : - 10 , VREC1 . C
            ) ;
  WRITELN ( 'vrec2 = ' , VREC2 . A , ' ' , VREC2 . B : - 10 , VREC2 . C
            ) ;
  WRITELN ( 'svs   = ' , SVS . A , SVS . B ) ;
  WRITELN ( 'svs2  = ' , SVS2 . A , SVS2 . B ) ;
  for I := 1 to 14 do
    X [ I ] := 0 ;
  V5 := '' ;
  WRITELN ( V1 , V2 , ' ' , V3 , ' ' , V4 , V5 ) ;
  WRITELN ( 'vvs   = ' , VVS . A , VVS . B ) ;
  WRITELN ( 'vvs2  = ' , VVS2 . A , VVS2 . B ) ;
  WRITELN ( 'cv    = ' , CV , ' (should be 5)' ) ;
  with VVS do
    A := C ;
  WRITELN ( 'vvs   = ' , VVS . A , VVS . B ) ;
  WRITELN ( 'vvs2  = ' , VVS2 . A , VVS2 . B ) ;
  WRITELN ( 'vt    = ' , VT . A , ' ' , VT . B : - 10 , VT . C ) ;
  WRITELN ( 'st    = ' , ST . A , ' ' , ST . B : - 10 , ST . C ) ;

  //********************************
  // compiler should complain here
  // and not modify the constant
  //********************************

  // C := 15 ;
  WRITELN ( 'c     = ' , C , ' (should be 17)' ) ;
  WRITELN ( 'cneu  = ' , CNEU ) ;
  CV := 7 ;
  WRITELN ( 'cv    = ' , CV ) ;
  SVS . A := 27 ;

  //********************************
  // compiler should complain here
  // and not modify the constant
  //********************************

  // XC . A := SVS . A ;
  WRITELN ( 'xc.a  = ' , XC . A , ' (should be 12)' ) ;

  //********************************
  // compiler should complain here
  // and not modify the constant
  //********************************

  // with XC do
  //   A := SVS . A ;
  WRITELN ( 'xc.a  = ' , XC . A , ' (should be 12)' ) ;
  WRITELN ( 'xc.b  = ' , XC . B ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSTAT EXT PAS HEX -
program TESTSTAT ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



var X : REAL ;
    I : INTEGER ;


type ALFA = array [ 1 .. 40 ] of CHAR ;
     TESTREC = record
                 X1 : ANYPTR ;
                 X2 : ANYPTR ;
                 C1 : CHAR ;
                 C2 : CHAR ;
                 I1 : INTEGER ;
               end ;
     TESTSET = set of CHAR ;


const TCONST = 25 ;
      B : array [ 1 .. 4 ] of ALFA =
      ( 'A' , 'B' , 'C' , 'D' ) ;
      C : array [ 1 .. 4 ] of INTEGER =
      ( 1 , 2 , 3 , 4 ) ;


static X2 : INTEGER ;
       Y2 : INTEGER ;
       ABC : ALFA ;
       LAUF : INTEGER ;
       XR : TESTREC ;
       XS : TESTSET ;
       XP : ANYPTR ;


var PXR : ANYPTR ;



procedure TSTAT ;

   static X : INTEGER ;
          Y : INTEGER ;

   const A : array [ 1 .. 4 ] of ALFA =
         ( 'A' , 'B' , 'C' , 'D' ) ;
         C : array [ 1 .. 4 ] of INTEGER =
         ( 1 , 2 , 3 , 4 ) ;


   procedure INTERN ;

      var I : INTEGER ;

      static X3 : INTEGER ;
             Y3 : INTEGER ;
             XF : INTEGER ;
             XX : REAL ;

      begin (* INTERN *)
        WRITELN ( 'Start Prozedur intern' ) ;
        XX := 3.141592654 ;
        X3 := X3 + 1 ;
        Y3 := Y3 + 1 ;
        XF := 5 ;
        WRITELN ( 'statisch mit Format aus stat: ' , X3 : XF ) ;
        WRITELN ( 'real mit Format aus stat: ' , XX : 13 : XF ) ;
        WRITELN ( 'statisch x3 = ' , X3 ) ;
        WRITELN ( 'statisch y3 = ' , Y3 ) ;
        WRITELN ( 'statisch x = ' , X ) ;
        WRITELN ( 'statisch y = ' , Y ) ;
        WRITELN ( 'statisch x2 = ' , X2 ) ;
        X2 := X2 + 1 ;
        WRITELN ( 'statisch y2 = ' , Y2 ) ;
        Y2 := Y2 + 1 ;
        WRITELN ( 'abc = ' , ABC ) ;
        ABC := 'XYZ' ;
        WRITELN ( 'abc = ' , ABC ) ;
        WRITELN ( 'testrec:' ) ;
        WRITELN ( 'testrec.x1 = ' , XR . X1 ) ;
        WRITELN ( 'testrec.x2 = ' , XR . X2 ) ;
        WRITELN ( 'testrec.c1 = ' , ORD ( XR . C1 ) ) ;
        WRITELN ( 'testrec.c2 = ' , ORD ( XR . C2 ) ) ;
        WRITELN ( 'testrec.i1 = ' , XR . I1 ) ;
        WRITELN ( 'testset:' ) ;
        for I := 0 to 255 do
          if CHR ( I ) in XS then
            WRITELN ( 'testset enthaelt char ' , I ) ;
        WRITELN ( 'Ende Prozedur intern' ) ;
      end (* INTERN *) ;


   begin (* TSTAT *)
     WRITELN ( 'a1 = ' , A [ 1 ] ) ;
     WRITELN ( 'c1 = ' , C [ 1 ] ) ;
     WRITELN ( 'statisch x = ' , X ) ;
     X := X + 1 ;
     WRITELN ( 'statisch y = ' , Y ) ;
     Y := Y + 1 ;
     INTERN ;

     /************************************************************/
     /* SNAPSHOT ( 3 , 10 ) ;                                    */
     /************************************************************/

   end (* TSTAT *) ;



begin (* HAUPTPROGRAMM *)

  //******************************************************************
  // PXR := ADDR ( XR ) ;
  // MEMSET ( PXR , '*' , SIZEOF ( TESTREC ) ) ;
  //******************************************************************

  WRITELN ( 'xp  = ' , XP ) ;
  WRITELN ( 'abc = ' , ABC ) ;
  I := 40 ;
  MEMSET ( ADDR ( ABC ) , '*' , I ) ;
  WRITELN ( 'abc = ' , ABC ) ;
  MEMSET ( ADDR ( ABC ) , '*' , 40 ) ;
  WRITELN ( 'abc = ' , ABC ) ;
  MEMSET ( ADDR ( ABC ) , '*' , SIZEOF ( ABC ) ) ;
  WRITELN ( 'abc = ' , ABC ) ;
  MEMSET ( ADDR ( ABC ) , '*' , SIZEOF ( ALFA ) ) ;
  WRITELN ( 'abc = ' , ABC ) ;
  for I := 1 to 10 do
    TSTAT ;
  WRITELN ( 'b1 = ' , B [ 1 ] ) ;
  WRITELN ( 'c1 = ' , C [ 1 ] ) ;
  WRITELN ( 'statisch x2 = ' , X2 ) ;
  X2 := X2 + 1 ;
  WRITELN ( 'statisch y2 = ' , Y2 ) ;
  Y2 := Y2 + 1 ;
  WRITELN ( 'abc = ' , ABC ) ;
  MEMSET ( ADDR ( ABC ) , '*' , SIZEOF ( ABC ) ) ;
  WRITELN ( 'abc = ' , ABC ) ;
  ABC := 'XYZ' ;
  WRITELN ( 'abc = ' , ABC ) ;
  WRITELN ( 'testrec:' ) ;
  WRITELN ( 'testrec.x1 = ' , XR . X1 ) ;
  WRITELN ( 'testrec.x2 = ' , XR . X2 ) ;
  WRITELN ( 'testrec.c1 = ' , ORD ( XR . C1 ) ) ;
  WRITELN ( 'testrec.c2 = ' , ORD ( XR . C2 ) ) ;
  WRITELN ( 'testrec.i1 = ' , XR . I1 ) ;
  WRITELN ( 'testset:' ) ;
  for I := 0 to 255 do
    if CHR ( I ) in XS then
      WRITELN ( 'testset enthaelt char ' , I ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSTR0 EXT PAS HEX -
program TESTSTR0 ( OUTPUT ) ;

//**********************************************************************
//$A+
//**********************************************************************



var C : CHAR ;
    CX : CHAR ( 5 ) ;



procedure TESTCA ( S : CHAR ( 10 ) ) ;

   begin (* TESTCA *)
     WRITELN ( 's = ' , LENGTH ( S ) : 3 , ' <' , S , '>' )
   end (* TESTCA *) ;



procedure TESTS2 ( S : STRING ( 10 ) ) ;

   begin (* TESTS2 *)
     WRITELN ( 's = ' , LENGTH ( S ) : 3 , ' <' , S , '>' )
   end (* TESTS2 *) ;



procedure TESTS ( const S : STRING ) ;

   begin (* TESTS *)
     WRITELN ( 's = ' , LENGTH ( S ) : 3 , ' <' , S , '>' )
   end (* TESTS *) ;



begin (* HAUPTPROGRAMM *)

  //******************************************************************
  // C := '' ;
  //******************************************************************

  C := '*' ;
  CX := '' ;
  CX := '*' ;
  CX := '*****' ;
  CX := '***' '' ;
  WRITELN ( 'should be ***: <' , CX , '>' ) ;
  CX := '' '' ;
  WRITELN ( 'should be empty string: <' , CX , '>' ) ;
  TESTCA ( ' ' ) ;
  TESTCA ( '' ) ;
  TESTCA ( 'bernd' ) ;
  TESTS2 ( ' ' ) ;
  TESTS2 ( '' ) ;
  TESTS2 ( 'bernd' ) ;
  TESTS ( ' ' ) ;
  TESTS ( '' ) ;
  TESTS ( 'bernd' )
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSTR1 EXT PAS HEX -
program TESTSTR1 ( OUTPUT ) ;

//**********************************************************************
//$A+
//**********************************************************************



type TRANSLATE_TAB = array [ 1 .. 128 ] of CHAR ;


var S : STRING ( 20 ) ;
    C : CHAR ( 20 ) ;
    I : INTEGER ;
    C1 : CHAR ;
    C2 : CHAR ;
    C20 : CHAR ( 20 ) ;
    C20A : CHAR ( 20 ) ;
    VC20 : STRING ( 20 ) ;
    VC200 : STRING ( 200 ) ;
    VC2000 : STRING ( 2000 ) ;
    X : BOOLEAN ;
    P1 : STRING ( 20 ) ;
    P2 : STRING ( 200 ) ;
    COUNT : INTEGER ;
    TTAB : STRING ( 256 ) ;


const IDENT_T1 : TRANSLATE_TAB =
      ( X'00' , X'01' , X'02' , X'03' , X'04' , X'05' , X'06' , X'07' ,
        X'08' , X'09' , X'0a' , X'0b' , X'0c' , X'0d' , X'0e' , X'0f' ,
        X'10' , X'11' , X'12' , X'13' , X'14' , X'15' , X'16' , X'17' ,
        X'18' , X'19' , X'1a' , X'1b' , X'1c' , X'1d' , X'1e' , X'1f' ,
        X'20' , X'21' , X'22' , X'23' , X'24' , X'25' , X'26' , X'27' ,
        X'28' , X'29' , X'2a' , X'2b' , X'2c' , X'2d' , X'2e' , X'2f' ,
        X'30' , X'31' , X'32' , X'33' , X'34' , X'35' , X'36' , X'37' ,
        X'38' , X'39' , X'3a' , X'3b' , X'3c' , X'3d' , X'3e' , X'3f' ,
        X'40' , X'41' , X'42' , X'43' , X'44' , X'45' , X'46' , X'47' ,
        X'48' , X'49' , X'4a' , X'4b' , X'4c' , X'4d' , X'4e' , X'4f' ,
        X'50' , X'51' , X'52' , X'53' , X'54' , X'55' , X'56' , X'57' ,
        X'58' , X'59' , X'5a' , X'5b' , X'5c' , X'5d' , X'5e' , X'5f' ,
        X'60' , X'61' , X'62' , X'63' , X'64' , X'65' , X'66' , X'67' ,
        X'68' , X'69' , X'6a' , X'6b' , X'6c' , X'6d' , X'6e' , X'6f' ,
        X'70' , X'71' , X'72' , X'73' , X'74' , X'75' , X'76' , X'77' ,
        X'78' , X'79' , X'7a' , X'7b' , X'7c' , X'7d' , X'7e' , X'7f' )
        ;
      IDENT_T2 : TRANSLATE_TAB =
      ( X'80' , X'81' , X'82' , X'83' , X'84' , X'85' , X'86' , X'87' ,
        X'88' , X'89' , X'8a' , X'8b' , X'8c' , X'8d' , X'8e' , X'8f' ,
        X'90' , X'91' , X'92' , X'93' , X'94' , X'95' , X'96' , X'97' ,
        X'98' , X'99' , X'9a' , X'9b' , X'9c' , X'9d' , X'9e' , X'9f' ,
        X'a0' , X'a1' , X'a2' , X'a3' , X'a4' , X'a5' , X'a6' , X'a7' ,
        X'a8' , X'a9' , X'aa' , X'ab' , X'ac' , X'ad' , X'ae' , X'af' ,
        X'b0' , X'b1' , X'b2' , X'b3' , X'b4' , X'b5' , X'b6' , X'b7' ,
        X'b8' , X'b9' , X'ba' , X'bb' , X'bc' , X'bd' , X'be' , X'bf' ,
        X'c0' , X'c1' , X'c2' , X'c3' , X'c4' , X'c5' , X'c6' , X'c7' ,
        X'c8' , X'c9' , X'ca' , X'cb' , X'cc' , X'cd' , X'ce' , X'cf' ,
        X'd0' , X'd1' , X'd2' , X'd3' , X'd4' , X'd5' , X'd6' , X'd7' ,
        X'd8' , X'd9' , X'da' , X'db' , X'dc' , X'dd' , X'de' , X'df' ,
        X'e0' , X'e1' , X'e2' , X'e3' , X'e4' , X'e5' , X'e6' , X'e7' ,
        X'e8' , X'e9' , X'ea' , X'eb' , X'ec' , X'ed' , X'ee' , X'ef' ,
        X'f0' , X'f1' , X'f2' , X'f3' , X'f4' , X'f5' , X'f6' , X'f7' ,
        X'f8' , X'f9' , X'fa' , X'fb' , X'fc' , X'fd' , X'fe' , X'ff' )
        ;



function MEMCMPX ( X : ANYPTR ; Y : ANYPTR ; L : INTEGER ) : INTEGER ;

   var PLINKS : -> CHAR ;
       PRECHTS : -> CHAR ;
       PLIMIT : -> CHAR ;
       RESULT : INTEGER ;

   begin (* MEMCMPX *)
     PLINKS := X ;
     PRECHTS := Y ;
     PLIMIT := PTRADD ( PLINKS , L ) ;
     RESULT := 0 ;
     while PTRDIFF ( PLIMIT , PLINKS ) > 0 do
       begin
         if PLINKS -> < PRECHTS -> then
           begin
             RESULT := - 1 ;
             break
           end (* then *)
         else
           if PLINKS -> > PRECHTS -> then
             begin
               RESULT := 1 ;
               break
             end (* then *)
           else
             begin
               PLINKS := PTRADD ( PLINKS , 1 ) ;
               PRECHTS := PTRADD ( PRECHTS , 1 ) ;
             end (* else *)
       end (* while *) ;
     MEMCMPX := RESULT
   end (* MEMCMPX *) ;



procedure TEIL1 ;

   begin (* TEIL1 *)
     C := 'Bernd' ;
     WRITELN ( 'c         = ' , C ) ;
     S := 'Oppolzer' ;
     WRITELN ( 'maxlength = ' , MAXLENGTH ( S ) ) ;
     WRITELN ( 'length    = ' , LENGTH ( S ) ) ;
     C := S ;
     WRITELN ( 'c         = ' , C ) ;
     for I := 1 to LENGTH ( S ) do
       WRITE ( S [ I ] , ' ' ) ;
     WRITELN ;

     //*****************************************************************
     // tests aus testvarc
     //*****************************************************************

     C1 := 'A' ;
     C2 := C1 ;
     C20 := 'Test' ;
     VC20 := STR ( 'A' ) ;
     WRITE ( 'VC20 nach Zuweisung STR (''A'') ........: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;
     VC20 := STR ( C1 ) ;
     WRITE ( 'VC20 nach Zuweisung STR (C1) .........: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;
     VC20 := 'A' ;
     WRITE ( 'VC20 nach Zuweisung ''A'' ..............: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;
     VC20 := 'Test Varchar' ;
     WRITE ( 'VC20 nach Zuweisung const char array .: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;

     //*****************************************************************
     // ist nicht zulaessig, muss Konstante sein oder Funktion STR
     //*****************************************************************
     // VC20 := C20 ;  /* sollte Fehler sein */
     //*****************************************************************
     // so korrekt
     //*****************************************************************

     VC20 := STR ( C20 ) ;
     WRITE ( 'VC20 nach Zuweisung STR (C20) ........: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;

     //*****************************************************************
     // muss erlaubt sein, mit Blanks auffuellen wie gehabt ...
     //*****************************************************************

     VC20 := 'Bernd' ;
     WRITE ( 'VC20 nach Zuweisung Bernd ............: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;
     C20 := VC20 ;
     WRITELN ( 'C20 nach Zuweisung VC20 ..............: ' , C20 ) ;
     C20 := 'Bernd '  'Oppolzer' ;
     WRITELN ( 'C20 nach Zuweisung String Expression .: ' , C20 ) ;

     //*****************************************************************
     // Verkettung usw.
     //*****************************************************************

     VC200 := VC20  VC20 ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' Oppolzer' ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' Oppolzer'  ' Leinfelden' ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ( ' Oppolzer'  ' Leinfelden' ) ;
     WRITE ( 'VC200 nach Verkettung (Klammer hinten): ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := ( VC20  ' Oppolzer' )  ' Leinfelden' ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := ( ( VC20  ' Oppolzer' )  ' Leinfelden' ) ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  STR ( ' Oppolzer' )  STR ( ' Leinfelden' ) ;
     WRITE ( 'VC200 nach Verkettung (mit STR Funk.).: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' '  VC20 ;
     WRITE ( 'VC200 nach Verkettung (mit Blank) ....: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' dazwischen '  VC20 ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' dazwischen '  STR ( C20 ) ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := STR ( C20 )  ' dazwischen '  VC20 ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;

     //*****************************************************************
     // Zuweisungen einfach oder Expression
     //*****************************************************************

     VC20 := 'Test-String' ;
     WRITE ( 'VC20 nach Zuweisung Konstante ........: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;
     VC200 := VC20 ;
     WRITE ( 'VC200 nach Zuweisung VC20 ............: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' mit Verkettung' ;
     WRITE ( 'VC200 nach Zuweisung Expression ......: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC20 := 'Bernd' ;
   end (* TEIL1 *) ;



procedure TEIL2 ;

   var ZZ : STRING ( 20 ) ;

   begin (* TEIL2 *)

     //************************************************************
     // Vergleiche von Strings
     //************************************************************

     X := C20 = 'Bernd Oppolzer' ;
     WRITELN ( 'c20 = ''Bernd Oppolzer'' ...............: ' , X ) ;
     X := C20 = 'Bernd' ;
     WRITELN ( 'c20 = ''Bernd'' ........................: ' , X ) ;
     X := C20 = 'Bernd      ' ;
     WRITELN ( 'c20 = ''Bernd      '' ..................: ' , X ) ;
     ZZ := 'Bernd' ;
     WRITELN ( 'vc20 = <' , VC20 , '>' ) ;
     WRITELN ( 'zz   = <' , ZZ , '>' ) ;
     X := VC20 = ZZ ;
     WRITELN ( 'vc20 = zz ............................: ' , X ) ;
     ZZ := 'Bornd' ;
     WRITELN ( 'vc20 = <' , VC20 , '>' ) ;
     WRITELN ( 'zz   = <' , ZZ , '>' ) ;
     X := VC20 = ZZ ;
     WRITELN ( 'vc20 = zz ............................: ' , X ) ;
     X := VC20 = 'Bernd' ;
     WRITELN ( 'vc20 = ''Bernd'' .......................: ' , X ) ;
     X := VC20 = 'Berndx' ;
     WRITELN ( 'vc20 = ''Berndx'' ......................: ' , X ) ;
     X := VC20 = 'Bornd' ;
     WRITELN ( 'vc20 = ''Bornd'' .......................: ' , X ) ;
     X := ( VC20 = 'Bernd' ) ;
     WRITELN ( 'vc20 = ''Bernd'' .......................: ' , X ) ;
     X := VC20  ' ' = 'Bernd'  ' ' ;
     WRITELN ( 'vc20 = ''Bernd'' .......................: ' , X ) ;
     X := VC20 = 'Bernd ' ;
     WRITELN ( 'vc20 = ''Bernd '' ......................: ' , X ) ;
     X := C20 = 'Bernd' ;
     WRITELN ( 'c20 = ''Bernd'' ........................: ' , X ) ;
     X := C20 = 'Bernd      ' ;
     WRITELN ( 'c20 = ''Bernd      '' ..................: ' , X ) ;
     C20A := 'Oppolzer' ;
     WRITELN ( 'c20 = ................................: ' , C20 ) ;
     WRITELN ( 'c20A = ...............................: ' , C20A ) ;
     WRITELN ( 'VC20 = ...............................: ' , VC20 ) ;
     X := C20A > C20 ;
     WRITELN ( 'c20a > c20 ...........................: ' , X ) ;
     X := C20A < C20 ;
     WRITELN ( 'c20a < c20 ...........................: ' , X ) ;
     X := STR ( C20 ) > VC20 ;
     WRITELN ( 'c20 > vc20 ...........................: ' , X ) ;
     X := STR ( C20 ) < VC20 ;
     WRITELN ( 'c20 < vc20 ...........................: ' , X ) ;
     X := VC20 < C20 ;
     WRITELN ( 'c20 > vc20 ??? .......................: ' , X ) ;
     X := VC20 > C20 ;
     WRITELN ( 'c20 < vc20 ??? .......................: ' , X ) ;
     X := VC20 = C20 ;
     WRITELN ( 'c20 = vc20 ...........................: ' , X ) ;
     X := STR ( C20A ) > VC20 ;
     WRITELN ( 'c20a > vc20 ..........................: ' , X ) ;
     X := STR ( C20A ) < VC20 ;
     WRITELN ( 'c20a < vc20 ..........................: ' , X ) ;
     X := VC20 < C20A ;
     WRITELN ( 'c20a > vc20 ..........................: ' , X ) ;
     X := VC20 > C20A ;
     WRITELN ( 'c20a < vc20 ..........................: ' , X ) ;
     if VC20  ' ' = 'Bernd'  ' ' then
       WRITELN ( 'success !!' ) ;
   end (* TEIL2 *) ;



procedure STRPROC ( X : STRING ( 20 ) ; var Y : STRING ; A : STRING (
                  200 ) ; var B : STRING ) ;

   begin (* STRPROC *)
     if TRUE then
       begin
         WRITELN ( 'maxlength (x) = ' , MAXLENGTH ( X ) ) ;
         WRITELN ( 'maxlength (y) = ' , MAXLENGTH ( Y ) ) ;
         WRITELN ( 'maxlength (a) = ' , MAXLENGTH ( A ) ) ;
         WRITELN ( 'maxlength (b) = ' , MAXLENGTH ( B ) ) ;
       end (* then *) ;
     B := X  ' Oppolzer' ;
     Y := A ;
     WRITELN ( 'In STRPROC - X = <' , X , '>' ) ;
     WRITELN ( 'In STRPROC - Y = <' , Y , '>' ) ;
     WRITELN ( 'In STRPROC - A = <' , A , '>' ) ;
     WRITELN ( 'In STRPROC - B = <' , B , '>' ) ;
   end (* STRPROC *) ;



function STRFUNC ( X : STRING ( 20 ) ; Y : STRING ( 20 ) ) : STRING ;

   begin (* STRFUNC *)
     STRFUNC := X  '/'  Y ;
   end (* STRFUNC *) ;



function IFUNC ( X : STRING ( 20 ) ; Y : STRING ( 20 ) ) : INTEGER ;

   begin (* IFUNC *)
     IFUNC := LENGTH ( X  '/'  Y ) ;
   end (* IFUNC *) ;



function STRFUNC2 ( const X : STRING ; const Y : STRING ) : STRING ;

   var P : ANYPTR ;
       PDUMP : -> ANYPTR ;

   begin (* STRFUNC2 *)
     WRITELN ( 'strfunc2: addr stack = ' , ADDR ( P ) ) ;
     P := ADDR ( X ) ;
     PDUMP := P ;
     WRITELN ( 'strfunc2: addr (x) = ' , PDUMP ) ;
     WRITE ( 'strfunc2: x = ' , PDUMP -> ) ;
     PDUMP := PTRADD ( PDUMP , 4 ) ;
     WRITELN ( ' ' , PDUMP -> ) ;
     P := ADDR ( Y ) ;
     PDUMP := P ;
     WRITELN ( 'strfunc2: addr (y) = ' , PDUMP ) ;
     WRITE ( 'strfunc2: y = ' , PDUMP -> ) ;
     PDUMP := PTRADD ( PDUMP , 4 ) ;
     WRITELN ( ' ' , PDUMP -> ) ;
     WRITELN ( 'strfunc2: x = <' , X , '>' ) ;
     WRITELN ( 'strfunc2: y = <' , Y , '>' ) ;
     STRFUNC2 := X  '/'  Y ;
   end (* STRFUNC2 *) ;



function STRFUNC3 ( var X : STRING ; var Y : STRING ) : STRING ;

   var ERG : STRING ( 200 ) ;

   begin (* STRFUNC3 *)
     WRITELN ( 'strfunc3: x = <' , X , '>' ) ;
     WRITELN ( 'strfunc3: y = <' , Y , '>' ) ;
     ERG := X  '/'  Y ;
     WRITELN ( 'strfunc3: erg = <' , ERG , '>' ) ;
     STRFUNC3 := ERG ;
   end (* STRFUNC3 *) ;



function STRFUNC5 ( var X : STRING ; var Y : STRING ) : STRING ;

   begin (* STRFUNC5 *)
     STRFUNC5 := STRFUNC3 ( X , Y ) ;
   end (* STRFUNC5 *) ;



procedure TESTSTR ( X : STRING ( 20 ) ; var Y : STRING ; const Z :
                  STRING ) ;

   type LENGTHF = - 1 .. 32767 ;
        CHARPTR = -> CHAR ;

   var CP : -> CHAR ;
       LF : -> LENGTHF ;
       LEN : LENGTHF ;
       CPP : -> CHARPTR ;

   begin (* TESTSTR *)
     LF := ADDR ( X ) ;
     WRITELN ( 'lf 1 von x    = ' , LF -> ) ;
     LEN := LF -> ;
     LF := PTRADD ( LF , 2 ) ;
     WRITELN ( 'lf 2 von x    = ' , LF -> ) ;
     CP := PTRADD ( LF , 2 ) ;
     if LEN < 0 then
       begin
         CPP := PTRADD ( CP , 0 ) ;
         CP := CPP ->
       end (* then *) ;
     WRITELN ( '1. byte von x = ' , ORD ( CP -> ) ) ;
     WRITELN ( 'x [1]         = ' , X [ 1 ] ) ;
     WRITELN ( 'x [4]         = ' , X [ 4 ] ) ;

     //************************************************************
     // y genauer anschauen
     //************************************************************

     LF := ADDR ( Y ) ;
     WRITELN ( 'lf 1 von y    = ' , LF -> ) ;
     LEN := LF -> ;
     LF := PTRADD ( LF , 2 ) ;
     WRITELN ( 'lf 2 von y    = ' , LF -> ) ;
     CP := PTRADD ( LF , 2 ) ;
     if LEN < 0 then
       begin
         CPP := PTRADD ( CP , 0 ) ;
         CP := CPP ->
       end (* then *) ;
     WRITELN ( '1. byte von y = ' , ORD ( CP -> ) ) ;
     WRITELN ( 'y [1]         = ' , Y [ 1 ] ) ;
     WRITELN ( 'y [4]         = ' , Y [ 4 ] ) ;
     Y := 'Oppolzer' ;
     Y [ 5 ] := 'S' ;

     //************************************************************
     // z genauer anschauen
     //************************************************************

     LF := ADDR ( Z ) ;
     WRITELN ( 'lf 1 von z    = ' , LF -> ) ;
     LEN := LF -> ;
     LF := PTRADD ( LF , 2 ) ;
     WRITELN ( 'lf 2 von z    = ' , LF -> ) ;
     CP := PTRADD ( LF , 2 ) ;
     if LEN < 0 then
       begin
         CPP := PTRADD ( CP , 0 ) ;
         CP := CPP ->
       end (* then *) ;
     WRITELN ( '1. byte von z = ' , ORD ( CP -> ) ) ;
     WRITELN ( 'z [1]         = ' , Z [ 1 ] ) ;
     WRITELN ( 'z [4]         = ' , Z [ 4 ] ) ;

     //************************************************************
     // Z := 'Oppolzer' ;
     // Z [ 5 ] := 'S' ;
     //************************************************************

   end (* TESTSTR *) ;



function SUBSTR1 ( const SOURCE : STRING ; START : INTEGER ; LEN :
                 INTEGER ) : STRING ;

   type LENGTHF = 0 .. 32767 ;

   var X : INTEGER ;
       Z : STRING ( 100 ) ;
       P : ANYPTR ;
       Q : ANYPTR ;
       PLF : -> LENGTHF ;

   begin (* SUBSTR1 *)
     WRITELN ( 'substr1 - source: <' , SOURCE , '>' ) ;
     WRITELN ( 'substr1 - start = ' , START ) ;
     WRITELN ( 'substr1 - len   = ' , LEN ) ;
     if LEN < 0 then
       begin
         if START > LENGTH ( SOURCE ) then
           EXIT ( 1201 ) ;
         LEN := LENGTH ( SOURCE ) - START + 1 ;
       end (* then *)
     else
       begin
         X := START + LEN - 1 ;
         if X > LENGTH ( SOURCE ) then
           EXIT ( 1201 ) ;
       end (* else *) ;
     if LEN > 100 then
       EXIT ( 1202 ) ;
     Z := '' ;
     P := ADDR ( Z ) ;
     P := PTRADD ( P , 2 ) ;
     PLF := P ;
     P := PTRADD ( P , 2 ) ;
     Q := ADDR ( SOURCE [ START ] ) ;
     PLF -> := LEN ;
     MEMCPY ( P , Q , LEN ) ;
     SUBSTR1 := Z ;
   end (* SUBSTR1 *) ;



function SUBSTR2 ( const SOURCE : STRING ; START : INTEGER ; LEN :
                 INTEGER ) : STRING ;

   type LENGTHF = 0 .. 32767 ;

   var X : INTEGER ;
       P : ANYPTR ;
       Q : ANYPTR ;

   begin (* SUBSTR2 *)
     if LEN < 0 then
       begin
         if START > LENGTH ( SOURCE ) then
           EXIT ( 1201 ) ;
         LEN := LENGTH ( SOURCE ) - START + 1 ;
       end (* then *)
     else
       begin
         X := START + LEN - 1 ;
         if X > LENGTH ( SOURCE ) then
           EXIT ( 1201 ) ;
       end (* else *) ;
     SUBSTR2 := REPEATSTR ( ' ' , LEN ) ;
     P := STRRESULTP ;
     Q := ADDR ( SOURCE [ START ] ) ;
     MEMCPY ( P , Q , LEN ) ;
   end (* SUBSTR2 *) ;



procedure TEIL3 ;

   begin (* TEIL3 *)

     //************************************************************
     // verkettung direkt in Writeln ...
     //************************************************************
     //******
     //************************************************************

     VC200 := VC20  VC20 ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     WRITE ( 'Verkettung direkt ausgeben ...........: ' ) ;
     WRITELN ( '<' , VC20  VC20 , '>' ) ;
     WRITE ( 'Verkettung nochmal direkt ausgeben ...: ' ) ;
     WRITELN ( '<' , VC20  ' '  C20A , '>' ) ;

     //*****************************************************************
     //*
     // tests mit prozeduren, call by value und by reference
     //*****************************************************************
     //*

     WRITELN ( 'Aufruf STRPROC' ) ;
     STRPROC ( 'Bernd' , P1 , 'xxxxxxxxxxxxxxx' , P2 ) ;
     WRITELN ( 'zurck von STRPROC' ) ;
     WRITE ( 'P1 nach STRPROC ......................: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'P2 nach STRPROC ......................: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //*****************************************************************
     //*
     // noch ein Test, unpassende var-Parameter
     //*****************************************************************
     //*

     WRITELN ( 'Aufruf STRPROC' ) ;
     STRPROC ( 'Bernd' , P2 , 'xxxxxxxxxxxxxxx' , P1 ) ;
     WRITELN ( 'zurck von STRPROC' ) ;
     WRITE ( 'P1 nach STRPROC ......................: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'P2 nach STRPROC ......................: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //*****************************************************************
     //*
     // length und maxlength ausprobieren
     //*****************************************************************
     //*

     WRITE ( 'maxlength von einfachem char .........: ' ) ;
     WRITELN ( MAXLENGTH ( 'a' ) ) ;
     WRITE ( 'maxlength von char-Konstante .........: ' ) ;
     WRITELN ( MAXLENGTH ( 'Bernd' ) ) ;
     WRITE ( 'maxlength von char-Variable ..........: ' ) ;
     WRITELN ( MAXLENGTH ( C1 ) ) ;
     WRITE ( 'maxlength von char-array .............: ' ) ;
     WRITELN ( MAXLENGTH ( C20A ) ) ;
     WRITE ( 'maxlength von string .................: ' ) ;
     WRITELN ( MAXLENGTH ( VC20 ) ) ;
     WRITE ( 'maxlength von string-Expression ......: ' ) ;
     WRITELN ( MAXLENGTH ( VC20  ' '  VC20 ) ) ;
     WRITE ( 'length von einfachem char ............: ' ) ;
     WRITELN ( LENGTH ( 'a' ) ) ;
     WRITE ( 'length von char-konstante ............: ' ) ;
     WRITELN ( LENGTH ( 'bernd' ) ) ;
     WRITE ( 'length von char-variable .............: ' ) ;
     WRITELN ( LENGTH ( C1 ) ) ;
     WRITE ( 'length von char-array ................: ' ) ;
     WRITELN ( LENGTH ( C20A ) ) ;
     WRITE ( 'length von string ....................: ' ) ;
     WRITELN ( LENGTH ( VC20 ) ) ;
     WRITE ( 'length von string-expression .........: ' ) ;
     WRITELN ( LENGTH ( VC20  ' '  VC20 ) ) ;

     //*****************************************************************
     //*
     // Funktion mit string ergebnis ausprobieren
     //*****************************************************************
     //*

     P1 := 'Oppolzer' ;
     I := IFUNC ( VC20 , P1 ) ;
     WRITE ( 'funktion mit Integer Ergebnis ........: ' ) ;
     WRITELN ( I ) ;
     P1 := 'Oppolzer' ;
     P2 := STRFUNC ( VC20 , P1 ) ;
     WRITE ( 'p2 = funktion mit String Ergebnis ....: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := 'Test '  STRFUNC ( VC20 , P1 )  ' nochmal Test' ;
     WRITE ( 'p2 = kombiniert mit Funktion .........: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'String Ergebnis direkt ...............: ' ) ;
     WRITELN ( '<' , STRFUNC ( VC20 , P1 ) , '>' ) ;
     WRITE ( 'String Ergebnis mit Konstanten .......: ' ) ;
     WRITELN ( '<' , STRFUNC ( 'Bernd ' , ' Oppolzer' ) , '>' ) ;

     //*****************************************************************
     //*
     // test Funktion mit const String parametern
     //*****************************************************************
     //*

     P1 := 'Oppolzer' ;
     P2 := STRFUNC3 ( VC20 , P1 ) ;
     WRITE ( 'p2 = funktion mit var String .........: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P1 := 'Oppolzer' ;
     P2 := STRFUNC5 ( VC20 , P1 ) ;
     WRITE ( 'p2 = funktion mit var String (2 mal) .: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITELN ( 'Test Funktionsaufruf mit const Parm zwei Vars' ) ;
     P1 := 'Oppolzer' ;
     WRITELN ( 'addr(s) vor strfunc2 = ' , ADDR ( S ) ) ;
     P2 := STRFUNC2 ( VC20 , P1 ) ;
     WRITELN ( 'addr(s) nach strfunc2 = ' , ADDR ( S ) ) ;
     WRITE ( 'p2 = funktion mit const String .......: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITELN ( 'Test Funktionsaufruf mit const Parm zwei Expr' ) ;
     P1 := 'Oppolzer' ;
     WRITELN ( 'addr(s) vor strfunc2 = ' , ADDR ( S ) ) ;
     P2 := STRFUNC2 ( VC20  ' ' , ' '  P1 ) ;
     WRITELN ( 'addr(s) nach strfunc2 = ' , ADDR ( S ) ) ;
     WRITE ( 'p2 = funktion mit const String .......: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITELN ( 'Test Funktionsaufruf mit const Parm zwei Const' ) ;
     WRITELN ( 'addr(s) vor strfunc2 = ' , ADDR ( S ) ) ;
     P2 := STRFUNC2 ( 'Bernd' , ' Oppolzer' ) ;
     WRITELN ( 'addr(s) nach strfunc2 = ' , ADDR ( S ) ) ;
     WRITE ( 'p2 = funktion mit const String .......: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITELN ( 'Test Funktionsaufruf mit const Parm Expr + Const' ) ;
     WRITELN ( 'addr(s) vor strfunc2 = ' , ADDR ( S ) ) ;
     P2 := STRFUNC2 ( VC20  ' ' , ' Oppolzer' ) ;
     WRITELN ( 'addr(s) nach strfunc2 = ' , ADDR ( S ) ) ;
     WRITE ( 'p2 = funktion mit const String .......: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
   end (* TEIL3 *) ;



function CHECKF : STRING ;

   var X : ANYPTR ;
       CH : CHAR ;
       COUNT : INTEGER ;
       S : STRING ( 20 ) ;

   begin (* CHECKF *)
     CH := '*' ;
     S := REPEATSTR ( CH , 10 ) ;
     WRITELN ( 'test repeatstr  = <' , S , '>' ) ;
     CH := '*' ;
     COUNT := 15 ;
     S := REPEATSTR ( CH , COUNT ) ;
     WRITELN ( 'test repeatstr  = <' , S , '>' ) ;
     X := NIL ;
     WRITELN ( 'strresultp      = ' , X ) ;
     X := STRRESULTP ;
     WRITELN ( 'strresultp      = ' , X ) ;
     WRITELN ( 'strresultp      = ' , STRRESULTP ) ;
     CHECKF := 'Bernd Oppolzer' ;
     WRITELN ( 'strresultp      = ' , STRRESULTP ) ;
     WRITELN ( 'length (result) = ' , LENGTH ( STRRESULT ) ) ;
     CHECKF := 'Bernd Oppolzer'  STRRESULT ;
     WRITELN ( 'strresultp      = ' , STRRESULTP ) ;
     WRITELN ( 'length (result) = ' , LENGTH ( STRRESULT ) ) ;
     CHECKF := REPEATSTR ( '*' , 1000 ) ;
     WRITELN ( 'strresultp      = ' , STRRESULTP ) ;
     WRITELN ( 'length (result) = ' , LENGTH ( STRRESULT ) ) ;
   end (* CHECKF *) ;



procedure TEIL4 ;

   begin (* TEIL4 *)

     //************************************************************
     // test SUBSTR1 - einfache Variante
     //************************************************************

     P1 := 'Oppolzer' ;
     P2 := 'Oppolzer' ;
     WRITELN ( 'TESTSTR Variante 1 - ueberall Variable' ) ;
     TESTSTR ( P1 , P2 , P1 ) ;
     WRITELN ( 'TESTSTR Variante 2 - Konstante byvalue' ) ;
     TESTSTR ( 'Oppolzer' , P2 , P1 ) ;
     WRITELN ( 'TESTSTR Variante 3 - Konstante byconst' ) ;
     TESTSTR ( P1 , P2 , 'Oppolzer' ) ;
     WRITE ( 'P1 nach Aufruf TESTSTR ...............: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'P2 nach Aufruf TESTSTR ...............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P1 := 'Oppolzer' ;
     WRITE ( 'Zugriff auf String ueber Index .......: ' ) ;
     WRITELN ( P1 [ 1 ] ) ;
     WRITE ( 'Zugriff auf String ueber Index .......: ' ) ;
     WRITELN ( P1 [ 5 ] ) ;
     P2 := SUBSTR1 ( P1 , 3 , 4 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR1 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := SUBSTR1 ( 'Bernd '  'Oppolzer' , 5 , 7 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR1 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := SUBSTR1 ( 'Bernd '  'Oppolzer' , 5 , - 1 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR1 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //************************************************************
     // ... geht nur in Funktion mit String Result !!
     // WRITE ( 'Testausgabe STRRESULT ................: ' ) ;
     // WRITELN ( STRRESULT ) ;
     // WRITE ( 'Testausgabe STRRESULTP ...............: ' ) ;
     // WRITELN ( STRRESULTP ) ;
     //************************************************************

     VC2000 := CHECKF ;
     WRITE ( 'Laenge des Ergebnisses von CHECKF ....: ' ) ;
     WRITELN ( LENGTH ( VC2000 ) ) ;
     WRITE ( 'Test REPEATSTR .......................: ' ) ;
     WRITELN ( REPEATSTR ( 'Bernd ' , 5 ) ) ;
     P1 := 'Oppolzer ' ;
     WRITE ( 'Test REPEATSTR .......................: ' ) ;
     WRITELN ( REPEATSTR ( P1 , 5 ) ) ;
     COUNT := 6 ;
     WRITE ( 'Test REPEATSTR .......................: ' ) ;
     WRITELN ( REPEATSTR ( 'Bernd ' , COUNT ) ) ;
     WRITE ( 'Test REPEATSTR .......................: ' ) ;
     WRITELN ( REPEATSTR ( P1 , COUNT ) ) ;

     //************************************************************
     // test SUBSTR2 - korrekte Variante mit STRRESULTP usw.
     //************************************************************

     P1 := 'Oppolzer' ;
     P2 := SUBSTR2 ( P1 , 3 , 4 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR2 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := SUBSTR2 ( 'Bernd '  'Oppolzer' , 5 , 7 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR2 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := SUBSTR2 ( 'Bernd '  'Oppolzer' , 5 , - 1 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR2 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //************************************************************
     // test SUBSTR
     //************************************************************

     P1 := 'Oppolzer' ;
     P2 := SUBSTR ( P1 , 3 , 4 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'P1 nach SUBSTR (should not change) ...: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     P2 := SUBSTR ( 'Bernd '  'Oppolzer' , 5 , 7 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := SUBSTR ( 'Bernd '  'Oppolzer' , 5 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //************************************************************
     // test DELETE
     //************************************************************

     P1 := 'Oppolzer' ;
     P2 := DELETE ( P1 , 3 , 4 ) ;
     WRITE ( 'p2 = Ergebnis von DELETE .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'P1 nach DELETE (should not change) ...: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     P2 := DELETE ( 'Bernd '  'Oppolzer' , 5 , 7 ) ;
     WRITE ( 'p2 = Ergebnis von DELETE .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := DELETE ( 'Bernd '  'Oppolzer' , 5 ) ;
     WRITE ( 'p2 = Ergebnis von DELETE .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //************************************************************
     // test RTRIM und LTRIM, TRIM und COMPRESS
     //************************************************************

     P1 := '  Bernd Oppolzer    ' ;
     P2 := RTRIM ( P1 ) ;
     WRITE ( 'p2 = Ergebnis von RTRIM ..............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'P1 nach RTRIM (should not change) ....: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'p2 = Ergebnis von RTRIM ..............: ' ) ;
     WRITELN ( '<' , RTRIM ( '  a  b  ' ) , '>' ) ;
     WRITE ( 'p2 = Ergebnis von RTRIM ..............: ' ) ;
     WRITELN ( '<' , RTRIM ( '    ' ) , '>' ) ;
     P1 := '  Bernd Oppolzer    ' ;
     P2 := LTRIM ( P1 ) ;
     WRITE ( 'p2 = Ergebnis von LTRIM ..............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'P1 nach LTRIM (should not change) ....: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'p2 = Ergebnis von LTRIM ..............: ' ) ;
     WRITELN ( '<' , LTRIM ( '  a  b  ' ) , '>' ) ;
     WRITE ( 'p2 = Ergebnis von LTRIM ..............: ' ) ;
     WRITELN ( '<' , LTRIM ( '    ' ) , '>' ) ;
     P1 := '  Bernd Oppolzer    ' ;
     P2 := TRIM ( P1 ) ;
     WRITE ( 'p2 = Ergebnis von TRIM ...............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'P1 nach TRIM (should not change) .....: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'p2 = Ergebnis von TRIM ...............: ' ) ;
     WRITELN ( '<' , TRIM ( '  a  b  ' ) , '>' ) ;
     WRITE ( 'p2 = Ergebnis von TRIM ...............: ' ) ;
     WRITELN ( '<' , TRIM ( '    ' ) , '>' ) ;
   end (* TEIL4 *) ;



function TESTCONST ( const S : STRING ) : STRING ;

//**********************************************************************
// checkout problem with const strings
//**********************************************************************


   var CP : -> CHAR ;

   begin (* TESTCONST *)
     TESTCONST := S ;
     CP := STRRESULTP ;
     CP -> := 'A' ;
   end (* TESTCONST *) ;



begin (* HAUPTPROGRAMM *)
  TEIL1 ;
  TEIL2 ;
  TEIL3 ;
  TEIL4 ;

  //************************************************************
  // XP := RESULTP ;  ... not allowed here
  //************************************************************

  P1 := '  Bernd Oppolzer    ' ;
  P2 := COMPRESS ( P1 ) ;
  WRITE ( 'p2 = Ergebnis von COMPRESS ...........: ' ) ;
  WRITELN ( '<' , P2 , '>' ) ;
  WRITE ( 'P1 nach COMPRESS (should not change) .: ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  WRITE ( 'p2 = Ergebnis von COMPRESS ...........: ' ) ;
  WRITELN ( '<' , COMPRESS ( '  a  b  ' ) , '>' ) ;
  WRITE ( 'p2 = Ergebnis von COMPRESS ...........: ' ) ;
  WRITELN ( '<' , COMPRESS ( '    ' ) , '>' ) ;

  //******************************************************************
  // test INDEX
  //******************************************************************

  P1 := '  Bernd Oppolzer    ' ;
  I := INDEX ( P1 , 'pol' ) ;
  WRITE ( 'Ergebnis von INDEX ...................: ' ) ;
  WRITELN ( I : 5 ) ;
  P1 := '  Bernd Oppolzer    ' ;
  I := INDEX ( TRIM ( P1 ) , 'pol' ) ;
  WRITE ( 'Ergebnis von INDEX ...................: ' ) ;
  WRITELN ( I : 5 ) ;
  WRITE ( 'P1 nach TRIM (should not change) .....: ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  WRITE ( 'Ergebnis von INDEX (3) ...............: ' ) ;
  WRITELN ( INDEX ( 'Oppolzer' , 'pol' ) : 5 ) ;
  WRITE ( 'Ergebnis von INDEX (0) ...............: ' ) ;
  WRITELN ( INDEX ( 'Oppolzer' , 'polizei' ) : 5 ) ;
  WRITE ( 'Ergebnis von INDEX (1) ...............: ' ) ;
  WRITELN ( INDEX ( 'Oppolzer' , 'Oppolzer' ) : 5 ) ;
  WRITE ( 'Ergebnis von INDEX (0) ...............: ' ) ;
  WRITELN ( INDEX ( 'Oppolzer' , 'Oppolzer1' ) : 5 ) ;
  WRITE ( 'Ergebnis von INDEX (1) ...............: ' ) ;
  WRITELN ( INDEX ( 'Oppolzer' , 'Oppo' ) : 5 ) ;
  WRITE ( 'Ergebnis von INDEX (6) ...............: ' ) ;
  WRITELN ( INDEX ( 'Oppolzer' , 'zer' ) : 5 ) ;

  //******************************************************************
  // test VERIFY
  //******************************************************************

  P1 := '  Bernd Oppolzer    ' ;
  I := VERIFY ( P1 , 'Berndpol ' ) ;
  WRITE ( 'Ergebnis von VERIFY (9) ..............: ' ) ;
  WRITELN ( I : 5 ) ;
  P1 := '1256735473645' ;
  I := VERIFY ( P1 , '0123456789' ) ;
  WRITE ( 'Ergebnis von VERIFY (0) ..............: ' ) ;
  WRITELN ( I : 5 ) ;
  P1 := '125673547E645' ;
  I := VERIFY ( P1 , '0123456789' ) ;
  WRITE ( 'Ergebnis von VERIFY (10) .............: ' ) ;
  WRITELN ( I : 5 ) ;
  P1 := '125 73547E645' ;
  I := VERIFY ( P1 , '0123456789' ) ;
  WRITE ( 'Ergebnis von VERIFY (4) ..............: ' ) ;
  WRITELN ( I : 5 ) ;
  P1 := '1234567890123456789 ' ;
  I := VERIFY ( P1 , '0123456789' ) ;
  WRITE ( 'Ergebnis von VERIFY (20) .............: ' ) ;
  WRITELN ( I : 5 ) ;

  //******************************************************************
  // test TRANSLATE
  //******************************************************************

  P1 := '  Bernd Oppolzer    ' ;
  WRITE ( 'P1 before testconst ..................: ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  P2 := TESTCONST ( P1 ) ;
  WRITE ( 'P2 after testconst ...................: ' ) ;
  WRITELN ( '<' , P2 , '>' ) ;
  WRITE ( 'P1 after testconst (should not change): ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  P1 := '  Bernd Oppolzer    ' ;
  P2 := TRANSLATE ( P1 , 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' ,
        'abcdefghijklmnopqrstuvwxyz' ) ;
  WRITE ( 'Ergebnis von TRANSLATE ...............: ' ) ;
  WRITELN ( '<' , P2 , '>' ) ;
  WRITE ( 'P1 nach TRANSLATE (should not change) : ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  P1 := '  Bernd Oppolzer    ' ;
  P2 := TRANSLATE ( P1 , 'y' , 'z' ) ;
  WRITE ( 'Ergebnis von TRANSLATE ...............: ' ) ;
  WRITELN ( '<' , P2 , '>' ) ;
  WRITE ( 'P1 nach TRANSLATE (should not change) : ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  P1 := '  Bernd Oppolzer    ' ;
  WRITE ( 'Ergebnis von TRANSLATE ...............: ' ) ;
  WRITELN ( '<' , TRANSLATE ( P1 , 'CAyx' , 'BOze' ) , '>' ) ;
  WRITE ( 'P1 nach TRANSLATE (should not change) : ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  P1 := '  Bernd Oppolzer    ' ;
  WRITE ( 'Ergebnis von TRANSLATE ...............: ' ) ;
  WRITELN ( '<' , TRANSLATE ( P1 , 'x' , ' ' ) , '>' ) ;
  WRITE ( 'P1 nach TRANSLATE ....................: ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  if TRUE then
    begin
      TTAB := IDENT_T1  IDENT_T2 ;
      TTAB [ ORD ( ' ' ) + 1 ] := 'y' ;
      P1 := '  Bernd Oppolzer    ' ;
      P2 := TRANSLATE ( P1 , TTAB , '' ) ;
      WRITE ( 'Ergebnis von TRANSLATE (3. P. leer) ..: ' ) ;
      WRITELN ( '<' , P2 , '>' ) ;
      WRITE ( 'Ergebnis von TRANSLATE (3. P. leer) ..: ' ) ;
      WRITELN ( '<' , TRANSLATE ( P1 , TTAB , '' ) , '>' ) ;
      WRITE ( 'P1 nach TRANSLATE (should not change) : ' ) ;
      WRITELN ( '<' , P1 , '>' ) ;
      P1 := '  Bernd Oppolzer    ' ;
      P2 := TRANSLATE ( P1 , TTAB ) ;
      WRITE ( 'Ergebnis von TRANSLATE (3. P. n.vorh.): ' ) ;
      WRITELN ( '<' , P2 , '>' ) ;
      WRITE ( 'Ergebnis von TRANSLATE (3. P. n.vorh.): ' ) ;
      WRITELN ( '<' , TRANSLATE ( P1 , TTAB ) , '>' ) ;
      WRITE ( 'P1 nach TRANSLATE (should not change) : ' ) ;
      WRITELN ( '<' , P1 , '>' ) ;
    end (* then *)

  //******************************************************************
  // Ende aller Tests
  //******************************************************************

end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSTR2 EXT PAS HEX -
program TESTSTR2 ( OUTPUT ) ;


var S : STRING ( 20 ) ;



procedure TESTVALUE ( S : STRING ( 30 ) ) ;

   begin (* TESTVALUE *)
     WRITELN ( 'testvalue: maxlength = ' , MAXLENGTH ( S ) ) ;
     WRITELN ( 'testvalue: length    = ' , LENGTH ( S ) ) ;
     WRITELN ( 'testvalue: content   = ' , S ) ;
     S := 'Hugo' ;
   end (* TESTVALUE *) ;



procedure TESTCONST ( const S : STRING ) ;

   begin (* TESTCONST *)
     WRITELN ( 'testconst: maxlength = ' , MAXLENGTH ( S ) ) ;
     WRITELN ( 'testconst: length    = ' , LENGTH ( S ) ) ;
     WRITELN ( 'testconst: content   = ' , S ) ;
   end (* TESTCONST *) ;



procedure TESTVAR ( var S : STRING ) ;

   begin (* TESTVAR *)
     WRITELN ( 'testvar: maxlength = ' , MAXLENGTH ( S ) ) ;
     WRITELN ( 'testvar: length    = ' , LENGTH ( S ) ) ;
     WRITELN ( 'testvar: content   = ' , S ) ;
     S := 'Hugo' ;
   end (* TESTVAR *) ;



begin (* HAUPTPROGRAMM *)
  S := 'Bernd' ;
  TESTVALUE ( S ) ;
  TESTVALUE ( 'Bernd '  'Oppolzer' ) ;
  TESTCONST ( S ) ;
  TESTCONST ( 'Bernd '  'Oppolzer' ) ;
  TESTVAR ( S ) ;
  WRITELN ( 'main: S after testvar = ' , S ) ;
  WRITELN ( 'main: maxlength (expr) = ' , MAXLENGTH ( 'Bernd ' 
            'Oppolzer' ) ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTSVAR EXT PAS HEX -
program TESTSVAR ( OUTPUT ) ;

(************************************************)
(*$A+                                           *)
(*                                              *)
(*                                              *)
(************************************************)



type CHAR10 = array [ 1 .. 10 ] of CHAR ;
     CHAR30 = array [ 1 .. 30 ] of CHAR ;
     CHAR21 = array [ 20 .. 40 ] of CHAR ;
     CHARL = array [ 1 .. 4000 ] of CHAR ;


var F10 : CHAR10 ;   // should be char (10), maybe ??
    F30 : CHAR30 ;   // char (30)
    F21 : CHAR21 ;   /* char (21)                  */
    L : INTEGER ;
    CH : CHAR ;
    BUF : CHARL ;
    P : ANYPTR ;


begin (* HAUPTPROGRAMM *)
  F10 := 'Oppolzer' ;
  F30 := F10 ;
  WRITELN ( F30 ) ;
  F21 := 'Teststring Length 21' ;
  F30 := F21 ;
  WRITELN ( F30 ) ;
  F30 := 'Test123456Test123456Test123456' ;

  //******************************************************************
  // F21 := F30 ;
  //******************************************************************

  L := 21 ;
  CH := '*' ;
  MEMSET ( ADDR ( F21 ) , x'00' , 21 ) ;
  MEMSET ( ADDR ( F21 ) , CHR ( 0 ) , 21 ) ;
  MEMSET ( ADDR ( F21 ) , ' ' , 21 ) ;
  MEMSET ( ADDR ( F21 ) , ' ' , L ) ;
  WRITELN ( '<' , F21 , '>' ) ;
  MEMSET ( ADDR ( F21 ) , '$' , L ) ;
  WRITELN ( '<' , F21 , '>' ) ;
  MEMSET ( ADDR ( F21 ) , CH , L ) ;
  WRITELN ( '<' , F21 , '>' ) ;
  MEMSET ( ADDR ( BUF ) , CH , 2000 ) ;
  P := ADDR ( BUF ) ;
  P := PTRADD ( P , 2000 ) ;
  MEMSET ( P , CH , 2000 ) ;
  WRITELN ( '<' , BUF , '>' ) ;
  L := 2000 ;
  MEMSET ( ADDR ( BUF ) , CH , L ) ;
  WRITELN ( '<' , BUF , '>' ) ;
  P := ADDR ( BUF ) ;
  P := PTRADD ( P , L ) ;
  MEMSET ( P , CH , L ) ;
  WRITELN ( '<' , BUF , '>' ) ;
  MEMCPY ( ADDR ( F21 ) , ADDR ( F30 ) , 21 ) ;
  WRITELN ( F21 ) ;
  L := 21 ;
  MEMCPY ( ADDR ( F21 ) , ADDR ( F30 ) , L ) ;
  WRITELN ( F21 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTTRC  EXT PAS HEX -
program TESTTRC ( OUTPUT ) ;

(********)
(*$a+   *)
(********)



var R : REAL ;
    X : REAL ;
    I : INTEGER ;
    C : array [ 1 .. 100 ] of CHAR ;



local procedure DUMP ( PVON : VOIDPTR ; PBIS : VOIDPTR ) ;

(*********************************************************)
(*  Speicherbereich von PVON bis PBIS hexadezimal        *)
(*  ausgeben                                             *)
(*********************************************************)


   var P1 : VOIDPTR ;
       P2 : VOIDPTR ;
       MOD1 : INTEGER ;
       MOD2 : INTEGER ;


   procedure DUMPCHAR ( CH : CHAR ) ;

      begin (* DUMPCHAR *)
        if CH in [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' , 'A' .. 'I' ,
        'J' .. 'R' , 'S' .. 'Z' , '0' .. '9' , ' ' , ',' , '.' , '-' ,
        ';' , ':' , '_' , '!' , '"' , '' , '$' , '%' , '&' , '/' , '('
        , ')' , '=' , '?' , '+' , '*' , '#' , '*' ] then
          WRITE ( CH )
        else
          WRITE ( '.' )
      end (* DUMPCHAR *) ;


   procedure DUMPZEILE ( ADR : VOIDPTR ; P1 : VOIDPTR ; P2 : VOIDPTR )
                       ;

      var CH : -> CHAR ;
          I : INTEGER ;

      const HEXTAB : array [ 0 .. 15 ] of CHAR = '0123456789abcdef' ;

      begin (* DUMPZEILE *)
        WRITE ( ADR , ': ' ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , 4 ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , 4 ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , 4 ) ;
        CH := ADR ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 0 )
        then
          WRITE ( '........ ' )
        else
          begin
            for I := 1 to 4 do
              begin
                WRITE ( HEXTAB [ ORD ( CH -> ) DIV 16 ] , HEXTAB [ ORD
                        ( CH -> ) MOD 16 ] ) ;
                CH := PTRADD ( CH , 1 ) ;
              end (* for *) ;
            WRITE ( ' ' ) ;
          end (* else *) ;
        ADR := PTRADD ( ADR , - 12 ) ;
        CH := ADR ;
        WRITE ( ' *' ) ;
        for I := 1 to 16 do
          begin
            DUMPCHAR ( CH -> ) ;
            CH := PTRADD ( CH , 1 )
          end (* for *) ;
        WRITELN ( '*' ) ;
      end (* DUMPZEILE *) ;


   begin (* DUMP *)
     WRITELN ( 'Dump Speicherbereich von ' , PVON , ' bis ' , PBIS ) ;
     P1 := PTRADD ( PVON , - 16 ) ;
     MOD1 := PTR2INT ( P1 ) MOD 16 ;
     P1 := PTRADD ( P1 , 16 - MOD1 ) ;
     P2 := PTRADD ( PBIS , 15 ) ;
     MOD2 := PTR2INT ( P2 ) MOD 16 ;
     P2 := PTRADD ( P2 , - MOD2 ) ;
     while PTRDIFF ( P1 , P2 ) < 0 do
       begin
         DUMPZEILE ( P1 , PVON , PBIS ) ;
         P1 := PTRADD ( P1 , 16 ) ;
       end (* while *) ;
   end (* DUMP *) ;



function TRUNC1 ( R : REAL ) : INTEGER ;

   begin (* TRUNC1 *)
     TRUNC1 := TRUNC ( R ) ;
   end (* TRUNC1 *) ;



begin (* HAUPTPROGRAMM *)
  R := 0.012345678912 ;
  WRITELN ( 'many fraction digits: ' , R : 20 ) ;
  MEMSET ( ADDR ( C ) , 'A' , 20 ) ;
  MEMSET ( PTRADD ( ADDR ( C ) , 20 ) , CHR ( 10 ) , 20 ) ;
  MEMCPY ( PTRADD ( ADDR ( C ) , 40 ) , ADDR ( R ) , SIZEOF ( REAL ) )
           ;
  MEMSET ( PTRADD ( ADDR ( C ) , 50 ) , CHR ( 0XCD ) , 20 ) ;
  DUMP ( ADDR ( C ) , PTRADD ( ADDR ( C ) , 99 ) ) ;
  R := 0.01 ;
  WRITELN ( 'should be 0.01: ' , R ) ;
  R := 0.0 ;
  R := TRUNC ( R ) + 1 ;
  WRITELN ( 'should be 1: ' , R : 7 : 4 ) ;
  R := 0.0 ;
  R := TRUNC1 ( R ) + 1 ;
  WRITELN ( 'should be 1: ' , R : 7 : 4 ) ;
  R := R + 0.5 ;
  R := ROUND ( R ) + 1 ;
  WRITELN ( 'should be 3: ' , R : 7 : 4 ) ;
  R := 0.0 ;
  R := 1 + TRUNC ( R ) ;
  WRITELN ( 'should be 1: ' , R : 7 : 4 ) ;
  R := R + 0.5 ;
  R := 1 + ROUND ( R ) ;
  WRITELN ( 'should be 3: ' , R : 7 : 4 ) ;
  WRITELN ( 'should write 3: ' , ROUND ( R ) : 7 ) ;
  R := 0.0067 ;
  WRITELN ( 'should be 0.0067: ' , R : 7 : 4 , R : 7 : 3 ) ;
  R := 12.30 ;
  while R <= 12.50 do
    begin
      WRITELN ( 'R unkorrigiert ..: ' , R : 7 : 2 , R : 7 : 1 , ROUNDX
                ( R , - 1 ) : 7 : 1 ) ;
      R := ROUNDX ( R , - 2 ) ;
      WRITELN ( 'R gerundet ......: ' , R : 7 : 2 , R : 7 : 1 , ROUNDX
                ( R , - 1 ) : 7 : 1 ) ;
      R := R + 0.01 ;
    end (* while *) ;
  for I := 2 DOWNTO - 14 do
    WRITELN ( 'test roundx (' , I : 3 , ') = ' , ROUNDX ( 12.543 *
              5.678 , I ) : 20 : 12 ) ;
  R := - 10.0 ;
  while R < 10.0 do
    begin
      WRITELN ( 'r = ' , R : 5 : 1 , ' trc = ' , TRUNC ( R ) : 3 ,
                ' RND = ' , ROUND ( R ) : 3 , ' FLR = ' , FLOOR ( R ) :
                5 : 1 ) ;
      R := R + 0.1 ;
      R := ROUND ( R * 10 ) / 10 ;
      R := ROUNDX ( R , - 1 ) ;
    end (* while *) ;
  if FALSE then
    begin
      R := - 10.0 ;
      while R < 10.0 do
        begin
          X := FLOOR ( R ) ;
          WRITELN ( 'Test Trunc:' ) ;
          DUMP ( ADDR ( R ) , PTRADD ( ADDR ( R ) , 7 ) ) ;
          DUMP ( ADDR ( X ) , PTRADD ( ADDR ( X ) , 7 ) ) ;
          R := R + 0.1 ;
          R := ROUNDX ( R , - 1 ) ;
        end (* while *)
    end (* then *)
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTUML  EXT PAS HEX -
program TESTUML ( OUTPUT ) ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( ' ![]' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTVARC EXT PAS HEX -
program TESTVARC ( OUTPUT ) ;

//**********************************************************************
// Testprogramm fuer Strings bzw. VARCHARs
//
// Oppolzer - 02.2018
//$A+
//**********************************************************************



type TRANSLATE_TAB = array [ 1 .. 128 ] of CHAR ;


var C1 : CHAR ;
    C2 : CHAR ;
    C20 : CHAR ( 20 ) ;
    C20A : CHAR ( 20 ) ;
    VC20 : STRING ( 20 ) ;
    VC200 : STRING ( 200 ) ;
    VC2000 : STRING ( 2000 ) ;
    X : BOOLEAN ;
    P1 : STRING ( 20 ) ;
    P2 : STRING ( 200 ) ;
    I : INTEGER ;
    TTAB : STRING ( 256 ) ;


const IDENT_T1 : TRANSLATE_TAB =
      ( X'00' , X'01' , X'02' , X'03' , X'04' , X'05' , X'06' , X'07' ,
        X'08' , X'09' , X'0a' , X'0b' , X'0c' , X'0d' , X'0e' , X'0f' ,
        X'10' , X'11' , X'12' , X'13' , X'14' , X'15' , X'16' , X'17' ,
        X'18' , X'19' , X'1a' , X'1b' , X'1c' , X'1d' , X'1e' , X'1f' ,
        X'20' , X'21' , X'22' , X'23' , X'24' , X'25' , X'26' , X'27' ,
        X'28' , X'29' , X'2a' , X'2b' , X'2c' , X'2d' , X'2e' , X'2f' ,
        X'30' , X'31' , X'32' , X'33' , X'34' , X'35' , X'36' , X'37' ,
        X'38' , X'39' , X'3a' , X'3b' , X'3c' , X'3d' , X'3e' , X'3f' ,
        X'40' , X'41' , X'42' , X'43' , X'44' , X'45' , X'46' , X'47' ,
        X'48' , X'49' , X'4a' , X'4b' , X'4c' , X'4d' , X'4e' , X'4f' ,
        X'50' , X'51' , X'52' , X'53' , X'54' , X'55' , X'56' , X'57' ,
        X'58' , X'59' , X'5a' , X'5b' , X'5c' , X'5d' , X'5e' , X'5f' ,
        X'60' , X'61' , X'62' , X'63' , X'64' , X'65' , X'66' , X'67' ,
        X'68' , X'69' , X'6a' , X'6b' , X'6c' , X'6d' , X'6e' , X'6f' ,
        X'70' , X'71' , X'72' , X'73' , X'74' , X'75' , X'76' , X'77' ,
        X'78' , X'79' , X'7a' , X'7b' , X'7c' , X'7d' , X'7e' , X'7f' )
        ;
      IDENT_T2 : TRANSLATE_TAB =
      ( X'80' , X'81' , X'82' , X'83' , X'84' , X'85' , X'86' , X'87' ,
        X'88' , X'89' , X'8a' , X'8b' , X'8c' , X'8d' , X'8e' , X'8f' ,
        X'90' , X'91' , X'92' , X'93' , X'94' , X'95' , X'96' , X'97' ,
        X'98' , X'99' , X'9a' , X'9b' , X'9c' , X'9d' , X'9e' , X'9f' ,
        X'a0' , X'a1' , X'a2' , X'a3' , X'a4' , X'a5' , X'a6' , X'a7' ,
        X'a8' , X'a9' , X'aa' , X'ab' , X'ac' , X'ad' , X'ae' , X'af' ,
        X'b0' , X'b1' , X'b2' , X'b3' , X'b4' , X'b5' , X'b6' , X'b7' ,
        X'b8' , X'b9' , X'ba' , X'bb' , X'bc' , X'bd' , X'be' , X'bf' ,
        X'c0' , X'c1' , X'c2' , X'c3' , X'c4' , X'c5' , X'c6' , X'c7' ,
        X'c8' , X'c9' , X'ca' , X'cb' , X'cc' , X'cd' , X'ce' , X'cf' ,
        X'd0' , X'd1' , X'd2' , X'd3' , X'd4' , X'd5' , X'd6' , X'd7' ,
        X'd8' , X'd9' , X'da' , X'db' , X'dc' , X'dd' , X'de' , X'df' ,
        X'e0' , X'e1' , X'e2' , X'e3' , X'e4' , X'e5' , X'e6' , X'e7' ,
        X'e8' , X'e9' , X'ea' , X'eb' , X'ec' , X'ed' , X'ee' , X'ef' ,
        X'f0' , X'f1' , X'f2' , X'f3' , X'f4' , X'f5' , X'f6' , X'f7' ,
        X'f8' , X'f9' , X'fa' , X'fb' , X'fc' , X'fd' , X'fe' , X'ff' )
        ;



procedure STRPROC ( X : STRING ( 20 ) ; var Y : STRING ; A : STRING (
                  200 ) ; var B : STRING ) ;

   begin (* STRPROC *)
     if TRUE then
       begin
         WRITELN ( 'maxlength (x) = ' , MAXLENGTH ( X ) ) ;
         WRITELN ( 'maxlength (y) = ' , MAXLENGTH ( Y ) ) ;
         WRITELN ( 'maxlength (a) = ' , MAXLENGTH ( A ) ) ;
         WRITELN ( 'maxlength (b) = ' , MAXLENGTH ( B ) ) ;
       end (* then *) ;
     B := X  ' Oppolzer' ;
     Y := A ;
     WRITELN ( 'In STRPROC - X = <' , X , '>' ) ;
     WRITELN ( 'In STRPROC - Y = <' , Y , '>' ) ;
     WRITELN ( 'In STRPROC - A = <' , A , '>' ) ;
     WRITELN ( 'In STRPROC - B = <' , B , '>' ) ;
   end (* STRPROC *) ;



function STRFUNC ( X : STRING ( 20 ) ; Y : STRING ( 20 ) ) : STRING ;

   begin (* STRFUNC *)
     STRFUNC := X  '/'  Y ;
   end (* STRFUNC *) ;



function IFUNC ( X : STRING ( 20 ) ; Y : STRING ( 20 ) ) : INTEGER ;

   begin (* IFUNC *)
     IFUNC := LENGTH ( X  '/'  Y ) ;
   end (* IFUNC *) ;



function STRFUNC2 ( const X : STRING ; const Y : STRING ) : STRING ;

   begin (* STRFUNC2 *)
     STRFUNC2 := X  '/'  Y ;
   end (* STRFUNC2 *) ;



function STRFUNC3 ( var X : STRING ; var Y : STRING ) : STRING ;

   begin (* STRFUNC3 *)
     STRFUNC3 := X  '/'  Y ;
   end (* STRFUNC3 *) ;



function STRFUNC5 ( var X : STRING ; var Y : STRING ) : STRING ;

   begin (* STRFUNC5 *)
     STRFUNC5 := STRFUNC3 ( X , Y ) ;
   end (* STRFUNC5 *) ;



function SUBSTR1 ( const SOURCE : STRING ; START : INTEGER ; LEN :
                 INTEGER ) : STRING ;

   type LENGTHF = 0 .. 32767 ;

   var X : INTEGER ;
       Z : STRING ( 100 ) ;
       P : ANYPTR ;
       Q : ANYPTR ;
       PLF : -> LENGTHF ;

   begin (* SUBSTR1 *)
     if LEN < 0 then
       begin
         if START > LENGTH ( SOURCE ) then
           EXIT ( 1201 ) ;
         LEN := LENGTH ( SOURCE ) - START + 1 ;
       end (* then *)
     else
       begin
         X := START + LEN - 1 ;
         if X > LENGTH ( SOURCE ) then
           EXIT ( 1201 ) ;
       end (* else *) ;
     if LEN > 100 then
       EXIT ( 1202 ) ;
     Z := '' ;
     P := ADDR ( Z ) ;
     P := PTRADD ( P , 2 ) ;
     PLF := P ;
     P := PTRADD ( P , 2 ) ;
     Q := ADDR ( SOURCE [ START ] ) ;
     PLF -> := LEN ;
     MEMCPY ( P , Q , LEN ) ;
     SUBSTR1 := Z ;
   end (* SUBSTR1 *) ;



function SUBSTR2 ( const SOURCE : STRING ; START : INTEGER ; LEN :
                 INTEGER ) : STRING ;

   type LENGTHF = 0 .. 32767 ;

   var X : INTEGER ;
       P : ANYPTR ;
       Q : ANYPTR ;

   begin (* SUBSTR2 *)
     if LEN < 0 then
       begin
         if START > LENGTH ( SOURCE ) then
           EXIT ( 1201 ) ;
         LEN := LENGTH ( SOURCE ) - START + 1 ;
       end (* then *)
     else
       begin
         X := START + LEN - 1 ;
         if X > LENGTH ( SOURCE ) then
           EXIT ( 1201 ) ;
       end (* else *) ;
     SUBSTR2 := REPEATSTR ( ' ' , LEN ) ;
     P := STRRESULTP ;
     Q := ADDR ( SOURCE [ START ] ) ;
     MEMCPY ( P , Q , LEN ) ;
   end (* SUBSTR2 *) ;



procedure TESTSTR ( X : STRING ( 20 ) ; var Y : STRING ; const Z :
                  STRING ) ;

   type LENGTHF = 0 .. 32767 ;

   var CP : -> CHAR ;
       LF : -> LENGTHF ;

   begin (* TESTSTR *)
     LF := ADDR ( X ) ;
     WRITELN ( 'lf 1 von x    = ' , LF -> ) ;
     LF := PTRADD ( LF , 2 ) ;
     WRITELN ( 'lf 2 von x    = ' , LF -> ) ;
     CP := PTRADD ( LF , 2 ) ;
     WRITELN ( '1. byte von x = ' , ORD ( CP -> ) ) ;
     WRITELN ( 'x [1]         = ' , X [ 1 ] ) ;
     WRITELN ( 'x [4]         = ' , X [ 4 ] ) ;

     //************************************************************
     // y genauer anschauen
     //************************************************************

     LF := ADDR ( Y ) ;
     WRITELN ( 'lf 1 von y    = ' , LF -> ) ;
     LF := PTRADD ( LF , 2 ) ;
     WRITELN ( 'lf 2 von y    = ' , LF -> ) ;
     CP := PTRADD ( LF , 2 ) ;
     WRITELN ( '1. byte von y = ' , ORD ( CP -> ) ) ;
     WRITELN ( 'y [1]         = ' , Y [ 1 ] ) ;
     WRITELN ( 'y [4]         = ' , Y [ 4 ] ) ;
     Y := 'Oppolzer' ;
     Y [ 5 ] := 'S' ;

     //************************************************************
     // z genauer anschauen
     //************************************************************

     LF := ADDR ( Z ) ;
     WRITELN ( 'lf 1 von z    = ' , LF -> ) ;
     LF := PTRADD ( LF , 2 ) ;
     WRITELN ( 'lf 2 von z    = ' , LF -> ) ;
     CP := PTRADD ( LF , 2 ) ;
     WRITELN ( '1. byte von z = ' , ORD ( CP -> ) ) ;
     WRITELN ( 'z [1]         = ' , Z [ 1 ] ) ;
     WRITELN ( 'z [4]         = ' , Z [ 4 ] ) ;

     //************************************************************
     // Z := 'Oppolzer' ;
     // Z [ 5 ] := 'S' ;
     //************************************************************

   end (* TESTSTR *) ;



function CHECKF : STRING ;

   var X : ANYPTR ;

   begin (* CHECKF *)
     X := STRRESULTP ;
     WRITELN ( 'strresultp      = ' , X ) ;
     WRITELN ( 'strresultp      = ' , STRRESULTP ) ;
     CHECKF := 'Bernd Oppolzer' ;
     WRITELN ( 'strresultp      = ' , STRRESULTP ) ;
     WRITELN ( 'length (result) = ' , LENGTH ( STRRESULT ) ) ;
     CHECKF := 'Bernd Oppolzer'  STRRESULT ;
     WRITELN ( 'strresultp      = ' , STRRESULTP ) ;
     WRITELN ( 'length (result) = ' , LENGTH ( STRRESULT ) ) ;
     CHECKF := REPEATSTR ( '*' , 1000 ) ;
     WRITELN ( 'strresultp      = ' , STRRESULTP ) ;
     WRITELN ( 'length (result) = ' , LENGTH ( STRRESULT ) ) ;
   end (* CHECKF *) ;



function TESTCONST ( const S : STRING ) : STRING ;

//**********************************************************************
// checkout problem with const strings
//**********************************************************************


   var CP : -> CHAR ;

   begin (* TESTCONST *)
     TESTCONST := S ;
     CP := STRRESULTP ;
     CP -> := 'A' ;
   end (* TESTCONST *) ;



procedure TEST1 ;

   begin (* TEST1 *)
     C1 := 'A' ;
     C2 := C1 ;
     C20 := 'Test' ;
     VC20 := STR ( 'A' ) ;
     WRITE ( 'VC20 nach Zuweisung STR (''A'') ........: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;
     VC20 := STR ( C1 ) ;
     WRITE ( 'VC20 nach Zuweisung STR (C1) .........: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;
     VC20 := 'A' ;
     WRITE ( 'VC20 nach Zuweisung ''A'' ..............: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;
     VC20 := 'Test Varchar' ;
     WRITE ( 'VC20 nach Zuweisung const char array .: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;

     //*************************************************************
     // ist nicht zulaessig, muss Konstante sein oder Funktion STR
     //*************************************************************
     // VC20 := C20 ;  /* sollte Fehler sein */
     //*************************************************************
     // so korrekt
     //*************************************************************

     VC20 := STR ( C20 ) ;
     WRITE ( 'VC20 nach Zuweisung STR (C20) ........: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;

     //*************************************************************
     // muss erlaubt sein, mit Blanks auffuellen wie gehabt ...
     //*************************************************************

     VC20 := 'Bernd' ;
     WRITE ( 'VC20 nach Zuweisung Bernd ............: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;
     C20 := VC20 ;
     WRITELN ( 'C20 nach Zuweisung VC20 ..............: ' , C20 ) ;
     C20 := 'Bernd '  'Oppolzer' ;
     WRITELN ( 'C20 nach Zuweisung String Expression .: ' , C20 ) ;

     //*************************************************************
     // Verkettung usw.
     //*************************************************************

     VC200 := VC20  VC20 ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' Oppolzer' ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' Oppolzer'  ' Leinfelden' ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ( ' Oppolzer'  ' Leinfelden' ) ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := ( VC20  ' Oppolzer' )  ' Leinfelden' ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := ( ( VC20  ' Oppolzer' )  ' Leinfelden' ) ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  STR ( ' Oppolzer' )  STR ( ' Leinfelden' ) ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' '  VC20 ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' dazwischen '  VC20 ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' dazwischen '  STR ( C20 ) ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := STR ( C20 )  ' dazwischen '  VC20 ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
   end (* TEST1 *) ;



procedure TEST2 ;

   begin (* TEST2 *)

     //************************************************************
     // Zuweisungen einfach oder Expression
     //************************************************************

     VC20 := 'Test-String' ;
     WRITE ( 'VC20 nach Zuweisung Konstante ........: ' ) ;
     WRITELN ( '<' , VC20 , '>' ) ;
     VC200 := VC20 ;
     WRITE ( 'VC200 nach Zuweisung VC20 ............: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC200 := VC20  ' mit Verkettung' ;
     WRITE ( 'VC200 nach Zuweisung Expression ......: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     VC20 := 'Bernd' ;

     //*************************************************************
     // Vergleiche von Strings
     //*************************************************************

     X := VC20 = 'Bernd' ;
     WRITELN ( 'vc20 = ''Bernd'' .......................: ' , X ) ;
     X := ( VC20 = 'Bernd' ) ;
     WRITELN ( 'vc20 = ''Bernd'' .......................: ' , X ) ;
     X := VC20  ' ' = 'Bernd'  ' ' ;
     WRITELN ( 'vc20 = ''Bernd'' .......................: ' , X ) ;
     X := VC20 = 'Bernd ' ;
     WRITELN ( 'vc20 = ''Bernd '' ......................: ' , X ) ;
     X := C20 = 'Bernd' ;
     WRITELN ( 'c20 = ''Bernd'' ........................: ' , X ) ;
     X := C20 = 'Bernd      ' ;
     WRITELN ( 'c20 = ''Bernd      '' ..................: ' , X ) ;
     C20A := 'Oppolzer' ;
     WRITELN ( 'c20 = ................................: ' , C20 ) ;
     WRITELN ( 'c20A = ...............................: ' , C20A ) ;
     WRITELN ( 'VC20 = ...............................: ' , VC20 ) ;
     X := C20A > C20 ;
     WRITELN ( 'c20a > c20 ...........................: ' , X ) ;
     X := C20A < C20 ;
     WRITELN ( 'c20a < c20 ...........................: ' , X ) ;
     X := STR ( C20 ) > VC20 ;
     WRITELN ( 'c20 > vc20 ...........................: ' , X ) ;
     X := STR ( C20 ) < VC20 ;
     WRITELN ( 'c20 < vc20 ...........................: ' , X ) ;
     X := VC20 < C20 ;
     WRITELN ( 'c20 > vc20 ...........................: ' , X ) ;
     X := VC20 > C20 ;
     WRITELN ( 'c20 < vc20 ...........................: ' , X ) ;
     X := VC20 = C20 ;
     WRITELN ( 'c20 = vc20 ...........................: ' , X ) ;
     X := STR ( C20A ) > VC20 ;
     WRITELN ( 'c20a > vc20 ..........................: ' , X ) ;
     X := STR ( C20A ) < VC20 ;
     WRITELN ( 'c20a < vc20 ..........................: ' , X ) ;
     X := VC20 < C20A ;
     WRITELN ( 'c20a > vc20 ..........................: ' , X ) ;
     X := VC20 > C20A ;
     WRITELN ( 'c20a < vc20 ..........................: ' , X ) ;
     if VC20  ' ' = 'Bernd'  ' ' then
       WRITELN ( 'success !!' ) ;

     //*************************************************************
     // verkettung direkt in Writeln ...
     //*************************************************************

     VC200 := VC20  VC20 ;
     WRITE ( 'VC200 nach Verkettung ................: ' ) ;
     WRITELN ( '<' , VC200 , '>' ) ;
     WRITE ( 'Verkettung direkt ausgeben ...........: ' ) ;
     WRITELN ( '<' , VC20  VC20 , '>' ) ;
     WRITE ( 'Verkettung nochmal direkt ausgeben ...: ' ) ;
     WRITELN ( '<' , VC20  ' '  C20A , '>' ) ;
   end (* TEST2 *) ;



procedure TEST3 ;

   begin (* TEST3 *)

     //************************************************************
     // tests mit prozeduren, call by value und by reference
     //************************************************************

     WRITELN ( 'Aufruf STRPROC' ) ;
     STRPROC ( 'Bernd' , P1 , 'xxxxxxxxxxxxxxx' , P2 ) ;
     WRITELN ( 'zurck von STRPROC' ) ;
     WRITE ( 'P1 nach STRPROC ......................: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'P2 nach STRPROC ......................: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //*************************************************************
     // noch ein Test, unpassende var-Parameter
     //*************************************************************

     WRITELN ( 'Aufruf STRPROC' ) ;
     STRPROC ( 'Bernd' , P2 , 'xxxxxxxxxxxxxxx' , P1 ) ;
     WRITELN ( 'zurck von STRPROC' ) ;
     WRITE ( 'P1 nach STRPROC ......................: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'P2 nach STRPROC ......................: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //*************************************************************
     // length und maxlength ausprobieren
     //*************************************************************

     WRITE ( 'maxlength von einfachem char .........: ' ) ;
     WRITELN ( MAXLENGTH ( 'a' ) ) ;
     WRITE ( 'maxlength von char-Konstante .........: ' ) ;
     WRITELN ( MAXLENGTH ( 'Bernd' ) ) ;
     WRITE ( 'maxlength von char-Variable ..........: ' ) ;
     WRITELN ( MAXLENGTH ( C1 ) ) ;
     WRITE ( 'maxlength von char-array .............: ' ) ;
     WRITELN ( MAXLENGTH ( C20A ) ) ;
     WRITE ( 'maxlength von string .................: ' ) ;
     WRITELN ( MAXLENGTH ( VC20 ) ) ;
     WRITE ( 'maxlength von string-Expression ......: ' ) ;
     WRITELN ( MAXLENGTH ( VC20  ' '  VC20 ) ) ;
     WRITE ( 'length von einfachem char ............: ' ) ;
     WRITELN ( LENGTH ( 'a' ) ) ;
     WRITE ( 'length von char-konstante ............: ' ) ;
     WRITELN ( LENGTH ( 'bernd' ) ) ;
     WRITE ( 'length von char-variable .............: ' ) ;
     WRITELN ( LENGTH ( C1 ) ) ;
     WRITE ( 'length von char-array ................: ' ) ;
     WRITELN ( LENGTH ( C20A ) ) ;
     WRITE ( 'length von string ....................: ' ) ;
     WRITELN ( LENGTH ( VC20 ) ) ;
     WRITE ( 'length von string-expression .........: ' ) ;
     WRITELN ( LENGTH ( VC20  ' '  VC20 ) ) ;

     //*************************************************************
     // Funktion mit string ergebnis ausprobieren
     //*************************************************************

     P1 := 'Oppolzer' ;
     I := IFUNC ( VC20 , P1 ) ;
     WRITE ( 'funktion mit Integer Ergebnis ........: ' ) ;
     WRITELN ( I ) ;
     P1 := 'Oppolzer' ;
     P2 := STRFUNC ( VC20 , P1 ) ;
     WRITE ( 'p2 = funktion mit String Ergebnis ....: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := 'Test '  STRFUNC ( VC20 , P1 )  ' nochmal Test' ;
     WRITE ( 'p2 = kombiniert mit Funktion .........: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'String Ergebnis direkt ...............: ' ) ;
     WRITELN ( '<' , STRFUNC ( VC20 , P1 ) , '>' ) ;
     WRITE ( 'String Ergebnis mit Konstanten .......: ' ) ;
     WRITELN ( '<' , STRFUNC ( 'Bernd ' , ' Oppolzer' ) , '>' ) ;
   end (* TEST3 *) ;



procedure TEST4 ;

   begin (* TEST4 *)

     //************************************************************
     // test Funktion mit const String parametern
     //************************************************************

     P1 := 'Oppolzer' ;
     P2 := STRFUNC3 ( VC20 , P1 ) ;
     WRITE ( 'p2 = funktion mit var String .........: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P1 := 'Oppolzer' ;
     P2 := STRFUNC5 ( VC20 , P1 ) ;
     WRITE ( 'p2 = funktion mit var String (2 mal) .: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P1 := 'Oppolzer' ;
     P2 := STRFUNC2 ( VC20 , P1 ) ;
     WRITE ( 'p2 = funktion mit const String .......: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P1 := 'Oppolzer' ;
     P2 := STRFUNC2 ( VC20  ' ' , ' Oppolzer' ) ;
     WRITE ( 'p2 = funktion mit const String .......: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //*************************************************************
     // test SUBSTR1 - einfache Variante
     //*************************************************************

     P1 := 'Oppolzer' ;
     P2 := 'Oppolzer' ;
     TESTSTR ( P1 , P2 , 'Oppolzer' ) ;
     WRITE ( 'P1 nach Aufruf TESTSTR ...............: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'P2 nach Aufruf TESTSTR ...............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P1 := 'Oppolzer' ;
     WRITE ( 'Zugriff auf String ueber Index .......: ' ) ;
     WRITELN ( P1 [ 1 ] ) ;
     WRITE ( 'Zugriff auf String ueber Index .......: ' ) ;
     WRITELN ( P1 [ 5 ] ) ;
     P2 := SUBSTR1 ( P1 , 3 , 4 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR1 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := SUBSTR1 ( 'Bernd '  'Oppolzer' , 5 , 7 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR1 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := SUBSTR1 ( 'Bernd '  'Oppolzer' , 5 , - 1 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR1 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //*************************************************************
     // ... geht nur in Funktion mit String Result !!
     // WRITE ( 'Testausgabe STRRESULT ................: ' ) ;
     // WRITELN ( STRRESULT ) ;
     // WRITE ( 'Testausgabe STRRESULTP ...............: ' ) ;
     // WRITELN ( STRRESULTP ) ;
     //*************************************************************

     VC2000 := CHECKF ;
     WRITE ( 'Laenge des Ergebnisses von CHECKF ....: ' ) ;
     WRITELN ( LENGTH ( VC2000 ) ) ;
     WRITE ( 'Test REPEATSTR .......................: ' ) ;
     WRITELN ( REPEATSTR ( 'Bernd ' , 5 ) ) ;

     //*************************************************************
     // test SUBSTR2 - korrekte Variante mit STRRESULTP usw.
     //*************************************************************

     P1 := 'Oppolzer' ;
     P2 := SUBSTR2 ( P1 , 3 , 4 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR2 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := SUBSTR2 ( 'Bernd '  'Oppolzer' , 5 , 7 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR2 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := SUBSTR2 ( 'Bernd '  'Oppolzer' , 5 , - 1 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR2 ............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //*************************************************************
     // test SUBSTR
     //*************************************************************

     P1 := 'Oppolzer' ;
     P2 := SUBSTR ( P1 , 3 , 4 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'P1 nach SUBSTR (should not change) ...: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     P2 := SUBSTR ( 'Bernd '  'Oppolzer' , 5 , 7 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := SUBSTR ( 'Bernd '  'Oppolzer' , 5 ) ;
     WRITE ( 'p2 = Ergebnis von SUBSTR .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
   end (* TEST4 *) ;



procedure TEST5 ;

   begin (* TEST5 *)

     //************************************************************
     // test DELETE
     //************************************************************

     P1 := 'Oppolzer' ;
     P2 := DELETE ( P1 , 3 , 4 ) ;
     WRITE ( 'p2 = Ergebnis von DELETE .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'P1 nach DELETE (should not change) ...: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     P2 := DELETE ( 'Bernd '  'Oppolzer' , 5 , 7 ) ;
     WRITE ( 'p2 = Ergebnis von DELETE .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     P2 := DELETE ( 'Bernd '  'Oppolzer' , 5 ) ;
     WRITE ( 'p2 = Ergebnis von DELETE .............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;

     //*************************************************************
     // test RTRIM und LTRIM, TRIM und COMPRESS
     //*************************************************************

     P1 := '  Bernd Oppolzer    ' ;
     P2 := RTRIM ( P1 ) ;
     WRITE ( 'p2 = Ergebnis von RTRIM ..............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'P1 nach RTRIM (should not change) ....: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'p2 = Ergebnis von RTRIM ..............: ' ) ;
     WRITELN ( '<' , RTRIM ( '  a  b  ' ) , '>' ) ;
     WRITE ( 'p2 = Ergebnis von RTRIM ..............: ' ) ;
     WRITELN ( '<' , RTRIM ( '    ' ) , '>' ) ;
     P1 := '  Bernd Oppolzer    ' ;
     P2 := LTRIM ( P1 ) ;
     WRITE ( 'p2 = Ergebnis von LTRIM ..............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'P1 nach LTRIM (should not change) ....: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'p2 = Ergebnis von LTRIM ..............: ' ) ;
     WRITELN ( '<' , LTRIM ( '  a  b  ' ) , '>' ) ;
     WRITE ( 'p2 = Ergebnis von LTRIM ..............: ' ) ;
     WRITELN ( '<' , LTRIM ( '    ' ) , '>' ) ;
     P1 := '  Bernd Oppolzer    ' ;
     P2 := TRIM ( P1 ) ;
     WRITE ( 'p2 = Ergebnis von TRIM ...............: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'P1 nach TRIM (should not change) .....: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'p2 = Ergebnis von TRIM ...............: ' ) ;
     WRITELN ( '<' , TRIM ( '  a  b  ' ) , '>' ) ;
     WRITE ( 'p2 = Ergebnis von TRIM ...............: ' ) ;
     WRITELN ( '<' , TRIM ( '    ' ) , '>' ) ;
   end (* TEST5 *) ;



procedure TEST6 ;

   begin (* TEST6 *)

     //************************************************************
     // XP := RESULTP ;  ... not allowed here
     //************************************************************

     P1 := '  Bernd Oppolzer    ' ;
     P2 := COMPRESS ( P1 ) ;
     WRITE ( 'p2 = Ergebnis von COMPRESS ...........: ' ) ;
     WRITELN ( '<' , P2 , '>' ) ;
     WRITE ( 'P1 nach COMPRESS (should not change) .: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'p2 = Ergebnis von COMPRESS ...........: ' ) ;
     WRITELN ( '<' , COMPRESS ( '  a  b  ' ) , '>' ) ;
     WRITE ( 'p2 = Ergebnis von COMPRESS ...........: ' ) ;
     WRITELN ( '<' , COMPRESS ( '    ' ) , '>' ) ;

     //*************************************************************
     // test INDEX
     //*************************************************************

     P1 := '  Bernd Oppolzer    ' ;
     I := INDEX ( P1 , 'pol' ) ;
     WRITE ( 'Ergebnis von INDEX ...................: ' ) ;
     WRITELN ( I : 5 ) ;
     P1 := '  Bernd Oppolzer    ' ;
     I := INDEX ( TRIM ( P1 ) , 'pol' ) ;
     WRITE ( 'Ergebnis von INDEX ...................: ' ) ;
     WRITELN ( I : 5 ) ;
     WRITE ( 'P1 nach TRIM (should not change) .....: ' ) ;
     WRITELN ( '<' , P1 , '>' ) ;
     WRITE ( 'Ergebnis von INDEX (3) ...............: ' ) ;
     WRITELN ( INDEX ( 'Oppolzer' , 'pol' ) : 5 ) ;
     WRITE ( 'Ergebnis von INDEX (0) ...............: ' ) ;
     WRITELN ( INDEX ( 'Oppolzer' , 'polizei' ) : 5 ) ;
     WRITE ( 'Ergebnis von INDEX (1) ...............: ' ) ;
     WRITELN ( INDEX ( 'Oppolzer' , 'Oppolzer' ) : 5 ) ;
     WRITE ( 'Ergebnis von INDEX (0) ...............: ' ) ;
     WRITELN ( INDEX ( 'Oppolzer' , 'Oppolzer1' ) : 5 ) ;
     WRITE ( 'Ergebnis von INDEX (1) ...............: ' ) ;
     WRITELN ( INDEX ( 'Oppolzer' , 'Oppo' ) : 5 ) ;
     WRITE ( 'Ergebnis von INDEX (6) ...............: ' ) ;
     WRITELN ( INDEX ( 'Oppolzer' , 'zer' ) : 5 ) ;

     //*************************************************************
     // test VERIFY
     //*************************************************************

     P1 := '  Bernd Oppolzer    ' ;
     I := VERIFY ( P1 , 'Berndpol ' ) ;
     WRITE ( 'Ergebnis von VERIFY (9) ..............: ' ) ;
     WRITELN ( I : 5 ) ;
     P1 := '1256735473645' ;
     I := VERIFY ( P1 , '0123456789' ) ;
     WRITE ( 'Ergebnis von VERIFY (0) ..............: ' ) ;
     WRITELN ( I : 5 ) ;
     P1 := '125673547E645' ;
     I := VERIFY ( P1 , '0123456789' ) ;
     WRITE ( 'Ergebnis von VERIFY (10) .............: ' ) ;
     WRITELN ( I : 5 ) ;
     P1 := '125 73547E645' ;
     I := VERIFY ( P1 , '0123456789' ) ;
     WRITE ( 'Ergebnis von VERIFY (4) ..............: ' ) ;
     WRITELN ( I : 5 ) ;
     P1 := '1234567890123456789 ' ;
     I := VERIFY ( P1 , '0123456789' ) ;
     WRITE ( 'Ergebnis von VERIFY (20) .............: ' ) ;
     WRITELN ( I : 5 ) ;
   end (* TEST6 *) ;



begin (* HAUPTPROGRAMM *)
  TEST1 ;
  TEST2 ;
  TEST3 ;
  TEST4 ;
  TEST5 ;
  TEST6 ;

  //******************************************************************
  // test TRANSLATE
  //******************************************************************

  P1 := '  Bernd Oppolzer    ' ;
  WRITE ( 'P1 before testconst ..................: ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  P2 := TESTCONST ( P1 ) ;
  WRITE ( 'P2 after testconst ...................: ' ) ;
  WRITELN ( '<' , P2 , '>' ) ;
  WRITE ( 'P1 after testconst (should not change): ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  P1 := '  Bernd Oppolzer    ' ;
  P2 := TRANSLATE ( P1 , 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' ,
        'abcdefghijklmnopqrstuvwxyz' ) ;
  WRITE ( 'Ergebnis von TRANSLATE ...............: ' ) ;
  WRITELN ( '<' , P2 , '>' ) ;
  WRITE ( 'P1 nach TRANSLATE (should not change) : ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  P1 := '  Bernd Oppolzer    ' ;
  P2 := TRANSLATE ( P1 , 'y' , 'z' ) ;
  WRITE ( 'Ergebnis von TRANSLATE ...............: ' ) ;
  WRITELN ( '<' , P2 , '>' ) ;
  WRITE ( 'P1 nach TRANSLATE (should not change) : ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  P1 := '  Bernd Oppolzer    ' ;
  WRITE ( 'Ergebnis von TRANSLATE ...............: ' ) ;
  WRITELN ( '<' , TRANSLATE ( P1 , 'CAyx' , 'BOze' ) , '>' ) ;
  WRITE ( 'P1 nach TRANSLATE (should not change) : ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  P1 := '  Bernd Oppolzer    ' ;
  WRITE ( 'Ergebnis von TRANSLATE ...............: ' ) ;
  WRITELN ( '<' , TRANSLATE ( P1 , 'x' , ' ' ) , '>' ) ;
  WRITE ( 'P1 nach TRANSLATE ....................: ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;
  TTAB := IDENT_T1  IDENT_T2 ;
  TTAB [ ORD ( ' ' ) + 1 ] := 'y' ;
  P1 := '  Bernd Oppolzer    ' ;
  WRITE ( 'Ergebnis von TRANSLATE ...............: ' ) ;
  WRITELN ( '<' , TRANSLATE ( P1 , TTAB ) , '>' ) ;
  WRITE ( 'P1 nach TRANSLATE (should not change) : ' ) ;
  WRITELN ( '<' , P1 , '>' ) ;

  //******************************************************************
  // Ende aller Tests
  //******************************************************************

end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTVC2  EXT PAS HEX -
program TESTVC2 ( OUTPUT ) ;

//**********************************************************************
//$A+
//**********************************************************************



var STAB : array [ 1 .. 20 ] of STRING ( 25 ) ;
    N : INTEGER ;
    M : INTEGER ;


begin (* HAUPTPROGRAMM *)
  STAB [ 1 ] := 'AB' ;
  STAB [ 2 ] := 'CD' ;
  STAB [ 3 ] := STAB [ 1 ]  STAB [ 2 ] ;
  N := 2 ;
  M := 3 ;
  STAB [ 4 ] := STAB [ M ]  STAB [ N ] ;
  STAB [ 5 ] := SUBSTR ( STAB [ N - 1 ] , 1 , 1 )  STAB [ N ] 
                SUBSTR ( STAB [ N ] , 1 , 1 ) ;
  STAB [ 5 ] := SUBSTR ( STAB [ N - 1 ] , 1 , 1 )  STAB [ N ] 
                SUBSTR ( STAB [ N ] , 1 , 1 )  STAB [ N ] ;
  WRITELN ( 'stab/4  = <' , STAB [ 4 ] , '>' ) ;
  WRITELN ( 'stab/4  = <' , STAB [ M ]  STAB [ N ] , '>' ) ;
  WRITELN ( 'stab/5  = <' , STAB [ 5 ] , '>' ) ;
  WRITELN ( 'stab/5a = <' , SUBSTR ( STAB [ N - 1 ] , 1 , 1 ) , '>' ) ;
  WRITELN ( 'stab/5b = <' , SUBSTR ( STAB [ N - 1 ] , 1 , 1 )  STAB [
            N ] , '>' ) ;
  WRITELN ( 'stab/5  = <' , SUBSTR ( STAB [ N - 1 ] , 1 , 1 )  STAB [
            N ]  SUBSTR ( STAB [ N ] , 1 , 1 )  STAB [ N ] , '>' )
            ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTVS   EXT PAS HEX -
program TESTVS ( EINGABE , AUSGABE ) ;

(********)
(*$A+   *)
(********)



type CHAR8 = array [ 1 .. 8 ] of CHAR ;
     CHAR10 = array [ 1 .. 10 ] of CHAR ;


var EINGABE , AUSGABE : TEXT ;
    ZAHL : INTEGER ;
    SAVETIME : CHAR8 ;
    DATE8 , TIME8 : CHAR8 ;
    DATE10 , TIME10 : CHAR10 ;
    I : INTEGER ;
    F : REAL ;



procedure TEST ( X : REAL ; T : CHAR10 ) ;

   begin (* TEST *)
     WRITELN ( 'test: ' , T , X : 7 : 0 , X : 10 : 5 , X : 15 , X ) ;
   end (* TEST *) ;



begin (* HAUPTPROGRAMM *)
  TERMIN ( EINGABE ) ;
  TERMOUT ( AUSGABE ) ;
  WRITELN ( AUSGABE , 'Bitte Zahl:' ) ;
  READ ( EINGABE , ZAHL ) ;
  WRITELN ( AUSGABE , 'Zahl + 1 = ' , ZAHL + 1 ) ;
  DATETIME ( DATE8 , TIME8 ) ;
  DATTIM10 ( DATE10 , TIME10 ) ;
  WRITELN ( AUSGABE , 'datum8 ...: ' , DATE8 , ' ' , TIME8 ) ;
  WRITELN ( AUSGABE , 'datum10 ..: ' , DATE10 , ' ' , TIME10 ) ;
  SAVETIME := TIME8 ;
  repeat
    DATETIME ( DATE8 , TIME8 ) ;
  until TIME8 <> SAVETIME ;
  DATTIM10 ( DATE10 , TIME10 ) ;
  WRITELN ( AUSGABE , 'datum8 ...: ' , DATE8 , ' ' , TIME8 ) ;
  WRITELN ( AUSGABE , 'datum10 ..: ' , DATE10 , ' ' , TIME10 ) ;
  if TRUE then
    begin
      WRITELN ( AUSGABE , 'close-Aufruf fuer Eingabe folgt' ) ;
      CLOSE ( EINGABE ) ;
      WRITELN ( AUSGABE , 'close-Aufruf fuer Ausgabe folgt' ) ;
      CLOSE ( AUSGABE ) ;
      WRITELN ( OUTPUT , 'Ausgabe ueber File Eingabe ' ) ;
      WRITELN ( OUTPUT , 'muesste nach Close klappen ' ) ;
      WRITELN ( EINGABE , 'Ausgabe ueber File Eingabe ' ) ;
      WRITELN ( EINGABE , 'muesste nach Close klappen ' ) ;
    end (* then *) ;
  TEST ( 5.1 , 'x=5.1' ) ;
  TEST ( 5.0 , 'x=5.0' ) ;
  TEST ( 5 , 'x=5' ) ;
  F := 5.1 ;
  TEST ( F , 'x=f' ) ;
  I := 5 ;
  TEST ( I , 'x=i' ) ;
  HALT
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTWRB  EXT PAS HEX -
program TESTWRB ( OUTPUT ) ;

//*****
//$A+
//*****



type COLOR = ( YELLOW , RED , GREEN , BLUE ) ;


var B : BOOLEAN ;
    I : INTEGER ;
    CH : CHAR ( 10 ) ;
    V : STRING ( 10 ) ;
    C : COLOR ;
    X : INTEGER ;
    R : REAL ;



procedure TERMIN ( var X : TEXT ) ;

   EXTERNAL ;



procedure TERMOUT ( var X : TEXT ) ;

   EXTERNAL ;



procedure $PASWRI ( var F : TEXT ; WIDTH : INTEGER ; V : INTEGER ) ;

   EXTERNAL ;



procedure $PASWRR ( var F : TEXT ; WIDTH : INTEGER ; SCALE : INTEGER ;
                  V : REAL ) ;

   EXTERNAL ;



begin (* HAUPTPROGRAMM *)
  TERMIN ( INPUT ) ;
  TERMOUT ( OUTPUT ) ;
  WRITELN ( 'give width for various outputs:' ) ;
  READLN ( I ) ;
  X := 27 ;
  WRITELN ( X : I , ' <===' ) ;
  X := - 27 ;
  WRITELN ( X : I , ' <===' ) ;
  X := 27 ;
  $PASWRI ( OUTPUT , I , X ) ;
  WRITELN ( ' <===' ) ;
  X := - 27 ;
  $PASWRI ( OUTPUT , I , X ) ;
  WRITELN ( ' <===' ) ;
  X := 0 ;
  $PASWRI ( OUTPUT , I , X ) ;
  WRITELN ( ' <===' ) ;
  R := 12.37 ;
  WRITELN ( R : I : 1 , ' <===' ) ;
  R := - 12.37 ;
  WRITELN ( R : I : 1 , ' <===' ) ;
  R := 0.0 ;
  WRITELN ( R : I : 1 , ' <===' ) ;
  R := 12.37 ;
  WRITELN ( R : I : - 1 , ' <===' ) ;
  R := - 12.37 ;
  WRITELN ( R : I : - 1 , ' <===' ) ;
  R := 0.0 ;
  WRITELN ( R : I : - 1 , ' <===' ) ;
  $PASWRR ( OUTPUT , I , 2 , R ) ;
  WRITELN ( ' <===' ) ;
  $PASWRR ( OUTPUT , I , 1 , R ) ;
  WRITELN ( ' <===' ) ;
  $PASWRR ( OUTPUT , I , - 1 , R ) ;
  WRITELN ( ' <===' ) ;
  R := 123456.78 ;
  $PASWRR ( OUTPUT , I , 2 , R ) ;
  WRITELN ( ' <===' ) ;
  $PASWRR ( OUTPUT , I , 1 , R ) ;
  WRITELN ( ' <===' ) ;
  $PASWRR ( OUTPUT , I , - 1 , R ) ;
  WRITELN ( ' <===' ) ;
  B := TRUE ;
  WRITELN ( B : I , ' <===' ) ;
  B := FALSE ;
  WRITELN ( B : I , ' <===' ) ;
  CH := 'Bernd' ;
  WRITELN ( CH : I , ' <===' ) ;
  V := 'Oppolzer' ;
  WRITELN ( V : I , ' <===' ) ;
  C := GREEN ;
  WRITELN ( C : I , ' <===' ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTWRS  EXT PAS HEX -
program TESTWRS ( OUTPUT ) ;


begin (* HAUPTPROGRAMM *)
  WRITELN ( 'Test mit Laenge 3' ) ;
  WRITELN ( '<' , 'BERND' : 3 , '>' ) ;
  WRITELN ( 'Test mit Laenge -3' ) ;
  WRITELN ( '<' , 'BERND' : - 3 , '>' ) ;
  WRITELN ( 'Test mit Laenge 12' ) ;
  WRITELN ( '<' , 'BERND' : 12 , '>' ) ;
  WRITELN ( 'Test mit Laenge -12' ) ;
  WRITELN ( '<' , 'BERND' : - 12 , '>' ) ;
  WRITELN ( 'Test mit Laenge 0' ) ;
  WRITELN ( '<' , 'BERND' : 0 , '>' ) ;
  WRITELN ( 25 : 7 ) ;
  WRITELN ( 25 : 20 ) ;
  WRITELN ( 25 : - 7 ) ;
  WRITELN ( 25 : - 20 ) ;
  WRITELN ( - 25 : 7 ) ;
  WRITELN ( - 25 : 20 ) ;
  WRITELN ( - 25 : - 7 ) ;
  WRITELN ( - 25 : - 20 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTXB   EXT PAS HEX -
program TESTXB ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



const CC = 'A' ;
      CHEX = X'67' ;
      CSET =
      [ 'a' .. 'e' ] ;
      CSETHEX =
      [ 'a' .. X'66' ] ;


type SET_CHAR = set of CHAR ;
     ALPHA = array [ 1 .. 20 ] of CHAR ;


var C : CHAR ;
    S1 : SET_CHAR ;
    S2 : SET_CHAR ;
    S3 : SET_CHAR ;
    S4 : SET_CHAR ;
    S5 : SET_CHAR ;
    S6 : SET_CHAR ;
    I : INTEGER ;


const RW : array [ 1 .. 50 ] of ALPHA =
      ( 'IF          ' , 'DO          ' , 'OF          ' ,
        'TO          ' , 'IN          ' , 'OR          ' ,
        'END         ' , 'FOR         ' , 'VAR         ' ,
        'DIV         ' , 'MOD         ' , 'SET         ' ,
        'AND         ' , 'NOT         ' , 'XOR         ' ,
        'THEN        ' , 'ELSE        ' , 'WITH        ' ,
        'GOTO        ' , 'CASE        ' , 'TYPE        ' ,
        'FILE        ' , 'BEGIN       ' , 'UNTIL       ' ,
        'WHILE       ' , 'ARRAY       ' , 'CONST       ' ,
        'LABEL       ' , 'LOCAL       ' , 'BREAK       ' ,
        'REPEAT      ' , 'RECORD      ' , 'DOWNTO      ' ,
        'PACKED      ' , 'RETURN      ' , 'MODULE      ' ,
        'STATIC      ' , 'FORWARD     ' , 'PROGRAM     ' ,
        'FORTRAN     ' , 'EXTERNAL    ' , 'FUNCTION    ' ,
        'CONTINUE    ' , 'PROCEDURE   ' , 'OTHERWISE   ' ,
        X'30313a3b3d3e' , B'101101011011' , B'0100011001001100' ,
        '            ' , '            ' ) ;



procedure PRINT_SET ( S : SET_CHAR ) ;

   var C : CHAR ;
       CP : -> CHAR ;

   begin (* PRINT_SET *)
     WRITE ( 'set: ' ) ;
     for C := CHR ( 0 ) to CHR ( 255 ) do
       if C in S then
         WRITE ( C ) ;
     WRITELN ;
     WRITE ( 'set in hex: ' ) ;
     CP := ADDR ( S ) ;
     for I := 1 to 32 do
       begin
         WRITE ( ORD ( CP -> ) : 1 , ' ' ) ;
         CP := PTRADD ( CP , 1 ) ;
       end (* for *) ;
     WRITELN ;
   end (* PRINT_SET *) ;



begin (* HAUPTPROGRAMM *)
  C := 'A' ;
  WRITELN ( 'c = <' , C , '>' , ORD ( C ) ) ;
  C := X'31' ;
  WRITELN ( 'c = <' , C , '>' , ORD ( C ) ) ;
  C := B'110011' ;
  WRITELN ( 'c = <' , C , '>' , ORD ( C ) ) ;
  C := CHEX ;
  WRITELN ( 'c = <' , C , '>' , ORD ( C ) ) ;
  case C of
    '1' : WRITELN ( 'eins' ) ;
    '5' : WRITELN ( 'fuenf' ) ;
    X'31' : WRITELN ( 'nochmal eins' ) ;
    X'32' : WRITELN ( 'nochmal zwei' ) ;
    X'33' : WRITELN ( 'drei als hex' ) ;
    B'1000110' :
      WRITELN ( 'f binaer' ) ;
    X'41' .. 'E' :
      WRITELN ( 'a als hex' ) ;
    CHEX : WRITELN ( 'konstante chex' ) ;
  end (* case *) ;
  WRITELN ( 'text normal' ) ;
  WRITELN ( X'4142434445_414b4c44e' ) ;
  WRITELN ( X'4142434445_414b4c4d4e' ) ;
  WRITELN ( B'01001111_01000011' ) ;
  WRITELN ( 'chex = ' , CHEX ) ;
  S1 := [ 'A' .. 'E' ] ;
  S2 := [ X'41' .. 'E' ] ;

  /**********************************/
  /* will not work on ASCII machine */
  /* s := [ x'C1' .. 'E' ];         */
  /**********************************/

  S3 := [ X'41' .. X'45' ] ;

  /***********************************/
  /* will not work on EBCDIC machine */
  /***********************************/

  S4 := [ 'A' .. X'45' ] ;
  S5 := [ 'a' .. CHEX ] ;
  S6 := CSETHEX ;
  PRINT_SET ( S1 ) ;
  PRINT_SET ( S2 ) ;
  PRINT_SET ( S3 ) ;
  PRINT_SET ( S4 ) ;
  PRINT_SET ( S5 ) ;
  PRINT_SET ( S6 ) ;
  PRINT_SET ( CSETHEX ) ;
  for I := 44 to 48 do
    WRITELN ( RW [ I ] ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB TESTXBM  EXT PAS HEX -
program TESTXB ( OUTPUT ) ;

(********)
(*$A+   *)
(********)



const CC = 'A' ;
      CHEX = X'87' ;
      CSET =
      [ 'a' .. 'e' ] ;
      CSETHEX =
      [ 'a' .. X'86' ] ;


type SET_CHAR = set of CHAR ;
     ALPHA = array [ 1 .. 20 ] of CHAR ;


var C : CHAR ;
    S1 : SET_CHAR ;
    S2 : SET_CHAR ;
    S3 : SET_CHAR ;
    S4 : SET_CHAR ;
    S5 : SET_CHAR ;
    I : INTEGER ;


const RW : array [ 1 .. 50 ] of ALPHA =
      ( 'IF          ' , 'DO          ' , 'OF          ' ,
        'TO          ' , 'IN          ' , 'OR          ' ,
        'END         ' , 'FOR         ' , 'VAR         ' ,
        'DIV         ' , 'MOD         ' , 'SET         ' ,
        'AND         ' , 'NOT         ' , 'XOR         ' ,
        'THEN        ' , 'ELSE        ' , 'WITH        ' ,
        'GOTO        ' , 'CASE        ' , 'TYPE        ' ,
        'FILE        ' , 'BEGIN       ' , 'UNTIL       ' ,
        'WHILE       ' , 'ARRAY       ' , 'CONST       ' ,
        'LABEL       ' , 'LOCAL       ' , 'BREAK       ' ,
        'REPEAT      ' , 'RECORD      ' , 'DOWNTO      ' ,
        'PACKED      ' , 'RETURN      ' , 'MODULE      ' ,
        'STATIC      ' , 'FORWARD     ' , 'PROGRAM     ' ,
        'FORTRAN     ' , 'EXTERNAL    ' , 'FUNCTION    ' ,
        'CONTINUE    ' , 'PROCEDURE   ' , 'OTHERWISE   ' ,
        X'f0f1fafbfdfe' , B'101101011011' , B'0100011001001100' ,
        '            ' , '            ' ) ;



procedure PRINT_SET ( S : SET_CHAR ) ;

   var C : CHAR ;
       CP : -> CHAR ;

   begin (* PRINT_SET *)
     WRITE ( 'set: ' ) ;
     for C := CHR ( 0 ) to CHR ( 255 ) do
       if C in S then
         WRITE ( C ) ;
     WRITELN ;
     WRITE ( 'set in hex: ' ) ;
     CP := ADDR ( S ) ;
     for I := 1 to 32 do
       begin
         WRITE ( ORD ( CP -> ) : 1 , ' ' ) ;
         CP := PTRADD ( CP , 1 ) ;
       end (* for *) ;
     WRITELN ;
   end (* PRINT_SET *) ;



begin (* HAUPTPROGRAMM *)
  C := 'A' ;
  WRITELN ( 'c = <' , C , '>' , ORD ( C ) ) ;
  C := X'f1' ;
  WRITELN ( 'c = <' , C , '>' , ORD ( C ) ) ;
  C := B'11110011' ;
  WRITELN ( 'c = <' , C , '>' , ORD ( C ) ) ;
  C := CHEX ;
  WRITELN ( 'c = <' , C , '>' , ORD ( C ) ) ;
  case C of
    '1' : WRITELN ( 'eins' ) ;
    '5' : WRITELN ( 'fuenf' ) ;
    X'f2' : WRITELN ( 'nochmal zwei' ) ;
    X'f3' : WRITELN ( 'drei als hex' ) ;
    B'10000110' :
      WRITELN ( 'f binaer' ) ;
    X'C1' .. 'E' :
      WRITELN ( 'a als hex' ) ;
    CHEX : WRITELN ( 'konstante chex' ) ;
  end (* case *) ;
  WRITELN ( 'text normal' ) ;
  WRITELN ( X'c1c2c3c4c5_c1cbccc4e' ) ;
  WRITELN ( X'c1c2c3c4c5_c1cbcccdce' ) ;
  WRITELN ( B'11001111_11000011' ) ;
  WRITELN ( 'chex = ' , CHEX ) ;
  S1 := [ 'A' .. 'E' ] ;
  S2 := [ X'c1' .. 'E' ] ;

  /**********************************/
  /* will not work on ASCII machine */
  /* s := [ x'C1' .. 'E' ];         */
  /**********************************/

  S3 := [ X'c1' .. X'c5' ] ;

  /***********************************/
  /* will not work on EBCDIC machine */
  /***********************************/

  S4 := [ 'A' .. X'c5' ] ;
  S5 := [ 'a' .. CHEX ] ;
  PRINT_SET ( S1 ) ;
  PRINT_SET ( S2 ) ;
  PRINT_SET ( S3 ) ;
  PRINT_SET ( S4 ) ;
  PRINT_SET ( S5 ) ;
  PRINT_SET ( CSETHEX ) ;
  for I := 44 to 48 do
    WRITELN ( RW [ I ] ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB XCOMP    EXT PAS HEX -
program XCOMP ( INPUT , OUTPUT , INFILE1 , INFILE2 ) ;

(***************************************************************)
(*                                                             *)
(*   XCOMP.C                                                   *)
(*                                                             *)
(*   Vergleich zweier Dateien analog DIFF;                     *)
(*   erzeugt Eingabe fuer XUPD                                 *)
(*                                                             *)
(*   angepasst und ueberarbeitet / xs95opp / 28.6.1998         *)
(*                                                             *)
(***************************************************************)
(*                                                             *)
(*   Offene Punkte:                                            *)
(*                                                             *)
(*   - abbrechen, wenn Synchro nicht klappt                    *)
(*                                                             *)
(***************************************************************)
(***************************************************************)
(*                                                             *)
(*   XCOMP <file1> <file2> [optionen]                          *)
(*                                                             *)
(*   <file1> und <file2> sind die beiden zu vergleichenden     *)
(*   Dateien.                                                  *)
(*                                                             *)
(*   Moegliche Optionen werden durch Eingabe von               *)
(*   XCOMP ohne Parameter angezeigt (siehe auch                *)
(*   Funktion cmndformat)                                      *)
(*                                                             *)
(*   Alte Funktionen ohne Garantie:                            *)
(*                                                             *)
(*   ------ following for update deck generation only ------   *)
(*                                                             *)
(*   -U[<update deck>]                                         *)
(*                   Generate update deck to make file1        *)
(*                   into file2; <update deck> defaults to     *)
(*                   the <name of file1>.UPT                   *)
(*   -sx,y           Generate internal sequence numbers        *)
(*                   starting with x and increment by y.       *)
(*                   Default if -s is omitted is 1,1           *)
(*                   if -s is specified without x and y        *)
(*                   then x = 10000; y defaults to x           *)
(*   -x              File1 already contains sequence numbers   *)
(*                                                             *)
(*   ------ following for aide with editor shells only -----   *)
(*                                                             *)
(*   -i              Use a sequence file                       *)
(*                   (generated from UPDATE command)           *)
(*                   name is <name of file1>.SEQ               *)
(*                   will be deleted                           *)
(*                                                             *)
(*   ------ neue bzw. noch gueltige Optionen ---------------   *)
(*   ------ nicht alle werden in der Pascal-Version --------   *)
(*   ------ bzw. im CMS funktionieren ----------------------   *)
(*                                                             *)
(*   Folgende Optionen sind moeglich:                          *)
(*                                                             *)
(*   -a              Vergleiche ALLIANZ-Testfalldateien        *)
(*                                                             *)
(*   -b              Einlesen mit fgets, nicht binaer          *)
(*                                                             *)
(*   -cx,y           Nur Spalten x bis y vergleichen           *)
(*                   (evtl. auch -v setzen)                    *)
(*                                                             *)
(*   -dx,y           Spalten x bis y nicht vergleichen         *)
(*                                                             *)
(*   -ex             Environment, d.h. auch die Umgebung       *)
(*                   einer Differenz anzeigen (# lines)        *)
(*                                                             *)
(*   -mn             Resync on n lines (default is 2)          *)
(*                                                             *)
(*   -t              Ignore case                               *)
(*                                                             *)
(*   -v              Trailing Blanks ignorieren                *)
(*                                                             *)
(*   -w              Ignore white space between words          *)
(*                                                             *)
(*   -*              Begrenzungszeichen in Vergleichsliste     *)
(*                                                             *)
(*                                                             *)
(***************************************************************)



const MAXLEN = 1024 ;
      VERSION = 'XCOMP (Pascal Version 1.1) - 20.10.2016' ;


type OSPARM_TYPE = array [ 1 .. 254 ] of CHAR ;
     CHAR3 = array [ 1 .. 3 ] of CHAR ;
     CHAR64 = array [ 1 .. 64 ] of CHAR ;
     ZEILE = array [ 1 .. MAXLEN ] of CHAR ;
     VOIDPTR = -> INTEGER ;

     /************************************************/
     /*   s_line:                                    */
     /*                                              */
     /*   next    - Pointer to the next line         */
     /*   seqnum  - Current sequence number          */
     /*   len     - Length of the current line       */
     /*   text    - Pointer to the current line      */
     /************************************************/

     LINEPTR = -> S_LINE ;
     S_LINE = record
                NEXT : LINEPTR ;
                LINENO : INTEGER ;
                SEQNUM : INTEGER ;
                LEN : INTEGER ;
                TEXT : ZEILE ;
              end ;

     /************************************************/
     /*   s_fanker:                                  */
     /*                                              */
     /*   curr     - Ptr to the current line buffer  */
     /*   head     - Ptr to the head of the list     */
     /*   tail     - Ptr to the last line in storage */
     /*   cline    - Line number of current          */
     /*   hline    - Line number of head             */
     /*   tline    - Line number of tail             */
     /************************************************/

     S_FANKER = record
                  FILENO : INTEGER ;
                  FILEH : CHAR ;
                  CURR : LINEPTR ;
                  CURR_SAVE : LINEPTR ;
                  HEAD : LINEPTR ;
                  TAIL : LINEPTR ;
                  CLINE : INTEGER ;
                  CLINE_SAVE : INTEGER ;
                  HLINE : INTEGER ;
                  TLINE : INTEGER ;

     /******************************************/
     /*  char *fbuffer;                        */
     /*  char *fbuf2;                          */
     /*  int lbuf2;                            */
     /*  char *cp2;                            */
     /******************************************/

                end ;

     /************************************************/
     /*   s_options:                                 */
     /*                                              */
     /*   edit      - Edit-File erzeugen ?           */
     /*   white     - ignore whitespace              */
     /*   case      - ignore case                    */
     /*   limits    - Begrenzungszeichen in Liste    */
     /*   colstart  - colstart fuer Vergleich        */
     /*   colend    - colende fuer Vergleich         */
     /*   ncolstart - colstart fuer Vergleich        */
     /*   ncolend   - colende fuer Vergleich         */
     /*   alli...   - ALLIANZ-Testfall               */
     /************************************************/

     S_OPTIONS = record
                   EDIT : BOOLEAN ;
                   TRAIL : BOOLEAN ;
                   WHITE : BOOLEAN ;
                   BINARY : BOOLEAN ;
                   ICASE : BOOLEAN ;
                   LIMITS : BOOLEAN ;
                   COLSTART : INTEGER ;
                   COLEND : INTEGER ;
                   NCOLSTART : INTEGER ;
                   NCOLEND : INTEGER ;
                   MINMATCH : INTEGER ;
                   ALLI_TESTFALL : BOOLEAN ;
                   ENVIRON : INTEGER ;
                 end ;

     /************************************************/
     /*   s_seqinfo:                                 */
     /*                                              */
     /*   seqtype  - Type of sequencing              */
     /*   seqstrt  - Start SeqNumber                 */
     /*   seqincr  - Increment SeqNumber             */
     /*   seqcur   - Current SeqNumber               */
     /*   seqname  - Name des SEQ-Files              */
     /*   lastmseq - last matched SeqNumber          */
     /************************************************/

     S_SEQINFO = record
                   SEQTYPE : INTEGER ;
                   SEQSTRT : INTEGER ;
                   SEQINCR : INTEGER ;
                   SEQCUR : INTEGER ;
                   SEQNAME : array [ 1 .. 258 ] of CHAR ;
                   LASTMSEQ : INTEGER ;
                 end ;


var PARM_FEHLER : BOOLEAN ;
    INFILE1 : TEXT ;
    INFILE2 : TEXT ;
    OPT : S_OPTIONS ;
    SEQ : S_SEQINFO ;
    DIFFERENT : BOOLEAN ;
    A : S_FANKER ;
    B : S_FANKER ;
    TRACE : BOOLEAN ;
    FCB1 : VOIDPTR ;
    FCB2 : VOIDPTR ;
    X : INTEGER ;
    PSTRING : OSPARM_TYPE ;



procedure DUMP ( PVON : VOIDPTR ; PBIS : VOIDPTR ) ;

(*********************************************************)
(*  Speicherbereich von PVON bis PBIS hexadezimal        *)
(*  ausgeben                                             *)
(*********************************************************)


   var P1 : VOIDPTR ;
       P2 : VOIDPTR ;
       MOD1 : INTEGER ;
       MOD2 : INTEGER ;


   procedure DUMPCHAR ( CH : CHAR ) ;

      begin (* DUMPCHAR *)
        if CH in [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' , 'A' .. 'I' ,
        'J' .. 'R' , 'S' .. 'Z' , '0' .. '9' ] then
          WRITE ( CH )
        else
          WRITE ( '.' )
      end (* DUMPCHAR *) ;


   procedure DUMPZEILE ( ADR : VOIDPTR ; P1 : VOIDPTR ; P2 : VOIDPTR )
                       ;

      type INT2PTR = record
                       case INTEGER of
                         0 :
                           ( P : VOIDPTR ) ;
                         1 :
                           ( I : INTEGER ) ;
                     end ;

      var IP : INT2PTR ;
          CH : -> CHAR ;
          I : INTEGER ;

      begin (* DUMPZEILE *)
        CH := PTRCAST ( ADR ) ;
        WRITE ( ADR , ': ' ) ;
        IP . I := ADR -> ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 4 )
        then
          WRITE ( '........ ' )
        else
          WRITE ( IP . P , ' ' ) ;
        ADR := PTRADD ( ADR , 4 ) ;
        IP . I := ADR -> ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 4 )
        then
          WRITE ( '........ ' )
        else
          WRITE ( IP . P , ' ' ) ;
        ADR := PTRADD ( ADR , 4 ) ;
        IP . I := ADR -> ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 4 )
        then
          WRITE ( '........ ' )
        else
          WRITE ( IP . P , ' ' ) ;
        ADR := PTRADD ( ADR , 4 ) ;
        IP . I := ADR -> ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 4 )
        then
          WRITE ( '........ ' )
        else
          WRITE ( IP . P , ' ' ) ;
        WRITE ( ' *' ) ;
        for I := 1 to 16 do
          begin
            DUMPCHAR ( CH -> ) ;
            CH := PTRADD ( CH , 1 )
          end (* for *) ;
        WRITELN ( '*' ) ;
      end (* DUMPZEILE *) ;


   begin (* DUMP *)
     WRITELN ( 'Dump Speicherbereich von ' , PVON , ' bis ' , PBIS ) ;
     P1 := PTRADD ( PVON , - 16 ) ;
     MOD1 := PTR2INT ( P1 ) MOD 16 ;
     P1 := PTRADD ( P1 , 16 - MOD1 ) ;
     P2 := PTRADD ( PBIS , 15 ) ;
     MOD2 := PTR2INT ( P2 ) MOD 16 ;
     P2 := PTRADD ( P2 , - MOD2 ) ;
     while PTRDIFF ( P1 , P2 ) < 0 do
       begin
         DUMPZEILE ( P1 , PVON , PBIS ) ;
         P1 := PTRADD ( P1 , 16 ) ;
       end (* while *) ;
   end (* DUMP *) ;



procedure CHECKFILE ( FCB : VOIDPTR ) ;

   var PBUFNO : -> CHAR ;
       PBUFCB : -> VOIDPTR ;
       PBUF : VOIDPTR ;
       BUFPTR : VOIDPTR ;
       PSIZE : VOIDPTR ;
       BUFSIZE : INTEGER ;
       BUFSIZE1 : INTEGER ;
       BUFSIZE2 : INTEGER ;
       CHKPTR : INTEGER ;
       CHKPTR2 : INTEGER ;

   begin (* CHECKFILE *)
     PBUFCB := PTRADD ( FCB , 56 ) ;
     PBUFNO := PTRCAST ( PBUFCB ) ;
     PBUF := PBUFCB -> ;
     PBUFCB := PTRCAST ( PBUF ) ;
     BUFPTR := PBUFCB -> ;
     PSIZE := PTRADD ( PBUFCB , 4 ) ;
     BUFSIZE := PSIZE -> ;
     BUFSIZE1 := BUFSIZE DIV 65536 ;
     BUFSIZE2 := BUFSIZE MOD 65536 ;
     WRITELN ( '*** checkfile +++ pbuf = ' , PBUF , ' bufptr = ' ,
               BUFPTR ) ;
     CHKPTR := PTR2INT ( BUFPTR ) ;
     CHKPTR2 := PTR2INT ( PBUF ) MOD 16777216 + 8 ;
     if ( BUFSIZE1 <> ORD ( PBUFNO -> ) ) or ( CHKPTR < CHKPTR2 ) or (
     CHKPTR > CHKPTR2 + ( BUFSIZE1 - 1 ) * BUFSIZE2 ) then
       begin
         WRITELN ( '+++ bufno von infile = ' , ORD ( PBUFNO -> ) ) ;
         WRITELN ( '+++ bufsize1 = ' , BUFSIZE1 ) ;
         WRITELN ( '+++ bufsize2 = ' , BUFSIZE2 ) ;
         WRITELN ( '+++ pbuf = ' , PBUF ) ;
         WRITELN ( '+++ bufptr = ' , BUFPTR ) ;
         WRITELN ( '+++ fcb des files:' ) ;
         DUMP ( FCB , PTRADD ( FCB , 132 ) ) ;
         WRITELN ( '+++ anfang buffer von infile:' ) ;
         DUMP ( PBUF , PTRADD ( PBUF , 64 ) ) ;
         EXIT ( 1999 ) ;
       end (* then *)
   end (* CHECKFILE *) ;



function TOLOWER ( X : CHAR ) : CHAR ;

   begin (* TOLOWER *)
     if X in [ 'A' .. 'I' , 'J' .. 'R' , 'S' .. 'Z' ] then
       TOLOWER := CHR ( ORD ( X ) - ORD ( 'A' ) + ORD ( 'a' ) )
     else
       TOLOWER := X
   end (* TOLOWER *) ;



procedure INITFANKER ( var X : S_FANKER ; DATEI : INTEGER ) ;

   begin (* INITFANKER *)
     X . FILENO := DATEI ;
     X . FILEH := CHR ( ORD ( '0' ) + DATEI ) ;
     X . CURR := NIL ;
     X . HEAD := NIL ;
     X . TAIL := NIL ;
     X . CLINE := 0 ;
     X . CLINE_SAVE := 0 ;
     X . HLINE := 0 ;
     X . TLINE := 0 ;
   end (* INITFANKER *) ;



procedure TRACE1 ( X : CHAR64 ) ;

   begin (* TRACE1 *)
     return ;
     WRITELN ( 'Trace1: ' , X ) ;
   end (* TRACE1 *) ;



procedure TRACE2 ( FILEH : CHAR ; L : LINEPTR ) ;

   var I : INTEGER ;

   begin (* TRACE2 *)
     return ;
     WRITELN ( 'gelesen von Datei ' , FILEH , ' (' , L , '):' ) ;
     for I := 1 to L -> . LEN do
       WRITE ( L -> . TEXT [ I ] ) ;
     WRITELN ;
   end (* TRACE2 *) ;



procedure TESTPUT ;

   begin (* TESTPUT *)
     return ;
     WRITELN ( 'Testput' ) ;
   end (* TESTPUT *) ;



function READLINE ( var X : S_FANKER ) : INTEGER ;

   type SHOWPTR = record
                    case BOOLEAN of
                      FALSE :
                        ( X1 : LINEPTR ) ;
                      TRUE :
                        ( X2 : INTEGER )
                  end ;

   var RC : INTEGER ;
       NEWLINE : LINEPTR ;
       L : INTEGER ;
       LAENGE : INTEGER ;
       GELESEN : BOOLEAN ;
       ANZ : INTEGER ;
       TEMP_LEN : INTEGER ;
       EOFX : BOOLEAN ;
       Z : SHOWPTR ;

   begin (* READLINE *)

     /************************************************/
     /*   Zeile einlesen aus ALLI-Testfalldatei      */
     /************************************************/

     if OPT . ALLI_TESTFALL then
       begin

     /***********************/
     /* zunaechst weglassen */
     /***********************/

         GELESEN := FALSE
       end (* then *)

     /************************************************/
     /*   Zeile einlesen binaer                      */
     /************************************************/

     else
       if OPT . BINARY then
         begin

     /***********************/
     /* zunaechst weglassen */
     /***********************/

           GELESEN := FALSE
         end (* then *)

     /************************************************/
     /*   Zeile einlesen normal Text                 */
     /************************************************/

       else
         begin
           if X . FILEH = '1' then
             EOFX := EOF ( INFILE1 )
           else
             EOFX := EOF ( INFILE2 ) ;
           if not EOFX then
             begin

     /************************************************/
     /*   WRITELN ( 'checkfile vor alloc' ) ;        */
     /*   if FCB1 <> NIL then                        */
     /*     CHECKFILE ( FCB1 ) ;                     */
     /*   if FCB2 <> NIL then                        */
     /*     CHECKFILE ( FCB2 )                       */
     /************************************************/

               NEWLINE := ALLOC ( SIZEOF ( S_LINE ) ) ;

     /************************************************/
     /*   WRITELN ( 'checkfile nach alloc' ) ;       */
     /*   if FCB1 <> NIL then                        */
     /*     CHECKFILE ( FCB1 ) ;                     */
     /*   if FCB2 <> NIL then                        */
     /*     CHECKFILE ( FCB2 )                       */
     /************************************************/

               with NEWLINE -> do
                 begin
                   NEXT := NIL ;
                   LINENO := 0 ;
                   SEQNUM := 0 ;
                   LEN := 0 ;
                   if X . FILEH = '1' then
                     begin
                       READ ( INFILE1 , TEXT ) ;
                       READLN ( INFILE1 ) ;
                     end (* then *)
                   else
                     begin
                       READ ( INFILE2 , TEXT ) ;
                       READLN ( INFILE2 ) ;
                     end (* else *)
                 end (* with *) ;
               GELESEN := TRUE
             end (* then *)
           else
             begin
               GELESEN := FALSE ;
               NEWLINE := NIL ;
             end (* else *) ;
           if GELESEN then
             begin
               LAENGE := MAXLEN ;
               while LAENGE > 0 do
                 begin
                   if NEWLINE -> . TEXT [ LAENGE ] <> ' ' then
                     break ;
                   LAENGE := LAENGE - 1 ;
                 end (* while *) ;
               NEWLINE -> . LEN := LAENGE ;
             end (* then *) ;
         end (* else *) ;
     if GELESEN then
       begin
         if X . TAIL = NIL then
           begin
             X . HEAD := NEWLINE ;
             X . TLINE := 1 ;
             X . HLINE := 1 ;
           end (* then *)
         else
           begin
             X . TAIL -> . NEXT := NEWLINE ;
             X . TLINE := X . TLINE + 1 ;
           end (* else *) ;
         X . TAIL := NEWLINE ;
         NEWLINE -> . LINENO := X . TLINE ;
       end (* then *) ;
     RC := 4 ;
     if GELESEN then
       RC := 0 ;
     READLINE := RC
   end (* READLINE *) ;



procedure REPORT_LINE ( LINENO : INTEGER ; PATTERN : CHAR3 ; var BUF :
                      ZEILE ; LEN : INTEGER ; LIMITS : BOOLEAN ) ;

   var I : INTEGER ;

   begin (* REPORT_LINE *)
     WRITE ( LINENO : 6 , ' ' , PATTERN , ' ' ) ;
     if LIMITS then
       WRITE ( '*' ) ;
     for I := 1 to LEN do
       WRITE ( BUF [ I ] ) ;
     if LIMITS then
       WRITE ( '*' ) ;
     WRITELN ;
   end (* REPORT_LINE *) ;



procedure REPORT ;

   var STATE : INTEGER ;
       LINENO : INTEGER ;
       P : LINEPTR ;
       ALAST : LINEPTR ;

       /***************************************************/
       /*   Pointer to the last unmatched lines in file a */
       /***************************************************/

       BLAST : LINEPTR ;

       /****************/
       /*   and file b */
       /****************/

       SEQ1 : INTEGER ;
       SEQ2 : INTEGER ;
       SEQ3 : INTEGER ;
       SEQ4 : INTEGER ;
       LINENOA : INTEGER ;
       LINENOB : INTEGER ;
       PA : LINEPTR ;
       PB : LINEPTR ;
       ENV : INTEGER ;
       ABWEICHUNG : BOOLEAN ;
       DUMMYRC : INTEGER ;

   const LINE1 : CHAR64 =
    '================================================================'
         ;
         LINE2 : CHAR64 =
    '----------------------------------------------------------------'
         ;

   begin (* REPORT *)
     if not OPT . EDIT then
       begin
         WRITELN ;
         WRITELN ( LINE1 ) ;

     /***************************************************/
     /*   Ausgabe, wenn von links etwas (mehr) da ist   */
     /***************************************************/

         if A . HEAD <> A . CURR then
           begin

     /***************************************************/
     /*   head ist evtl. nicht die Stelle der           */
     /*   Abweichung, sondern schon vorher, siehe       */
     /*   environ. Dann werden ein paar Zeilen mehr     */
     /*   ausgegeben, aber mit Punkten (weil dort       */
     /*   keine Abweichung ist), entsprechend auch      */
     /*   nach der Abweichung. Die echte Abweichung     */
     /*   wird mit <<< gekennzeichnet                   */
     /***************************************************/

             ABWEICHUNG := FALSE ;
             LINENO := A . HLINE ;
             P := A . HEAD ;
             while ( P <> NIL ) and ( P <> A . CURR ) do
               begin
                 if ( LINENO >= A . CLINE_SAVE - OPT . ENVIRON ) then
                   begin
                     if P = A . CURR_SAVE then
                       ABWEICHUNG := TRUE ;
                     if not ABWEICHUNG then
                       begin
                         REPORT_LINE ( LINENO , '...' , P -> . TEXT , P
                                       -> . LEN , OPT . LIMITS ) ;
                       end (* then *)
                     else
                       begin
                         REPORT_LINE ( LINENO , '<<<' , P -> . TEXT , P
                                       -> . LEN , OPT . LIMITS ) ;
                       end (* else *)
                   end (* then *) ;
                 LINENO := LINENO + 1 ;
                 P := P -> . NEXT
               end (* while *) ;

     /***************************************************/
     /*   ggf. ein paar Zeilen nach der Abweichung      */
     /*   ausgeben, mit Punkten                         */
     /***************************************************/

             ENV := 0 ;
             LINENO := A . CLINE ;
             P := A . CURR ;
             while ( ENV < OPT . ENVIRON ) and ( P <> NIL ) do
               begin
                 REPORT_LINE ( LINENO , '...' , P -> . TEXT , P -> .
                               LEN , OPT . LIMITS ) ;
                 if P -> . NEXT = NIL then
                   begin
                     DUMMYRC := READLINE ( A ) ;
                   end (* then *) ;
                 ENV := ENV + 1 ;
                 LINENO := LINENO + 1 ;
                 P := P -> . NEXT
               end (* while *) ;
           end (* then *) ;

     /***************************************************/
     /*   Trennstrich, wenn links und rechts vorh.      */
     /***************************************************/

         if ( ( A . CLINE_SAVE <> A . CLINE ) and ( B . CLINE_SAVE <> B
         . CLINE ) ) or ( OPT . ENVIRON > 0 ) then
           begin
             WRITELN ( LINE2 ) ;
           end (* then *) ;

     /***************************************************/
     /*   Ausgabe, wenn von rechts etwas (mehr) da ist  */
     /***************************************************/

         ABWEICHUNG := FALSE ;
         if B . HEAD <> B . CURR then
           begin
             LINENO := B . HLINE ;
             P := B . HEAD ;
             while ( P <> NIL ) and ( P <> B . CURR ) do
               begin
                 if ( LINENO >= B . CLINE_SAVE - OPT . ENVIRON ) then
                   begin
                     if P = B . CURR_SAVE then
                       ABWEICHUNG := TRUE ;
                     if not ABWEICHUNG then
                       begin
                         REPORT_LINE ( LINENO , '...' , P -> . TEXT , P
                                       -> . LEN , OPT . LIMITS ) ;
                       end (* then *)
                     else
                       begin
                         REPORT_LINE ( LINENO , '>>>' , P -> . TEXT , P
                                       -> . LEN , OPT . LIMITS ) ;
                       end (* else *)
                   end (* then *) ;
                 LINENO := LINENO + 1 ;
                 P := P -> . NEXT
               end (* while *) ;
             ENV := 0 ;
             LINENO := B . CLINE ;
             P := B . CURR ;
             while ( ENV < OPT . ENVIRON ) and ( P <> NIL ) do
               begin
                 REPORT_LINE ( LINENO , '...' , P -> . TEXT , P -> .
                               LEN , OPT . LIMITS ) ;
                 if P -> . NEXT = NIL then
                   begin
                     DUMMYRC := READLINE ( B ) ;
                   end (* then *) ;
                 ENV := ENV + 1 ;
                 LINENO := LINENO + 1 ;
                 P := P -> . NEXT
               end (* while *) ;
           end (* then *) ;
       end (* then *) ;
   end (* REPORT *) ;



function COMPX ( L1 : LINEPTR ; L2 : LINEPTR ) : BOOLEAN ;

   var SBUF1 : ZEILE ;
       SBUF2 : ZEILE ;
       SBUFK1 : CHAR64 ;
       SBUFK2 : CHAR64 ;
       I : INTEGER ;
       IPOS : INTEGER ;
       IREST : INTEGER ;
       ILEN1 : INTEGER ;
       ILEN2 : INTEGER ;
       CH : CHAR ;

   begin (* COMPX *)
     if ( L1 -> . LEN <= 64 ) and ( L2 -> . LEN <= 64 ) then
       begin
         SBUFK1 := ' ' ;
         SBUFK2 := ' ' ;
         I := 0 ;
         for IPOS := OPT . COLSTART to OPT . COLEND do
           begin
             if ( IPOS >= OPT . NCOLSTART ) and ( IPOS <= OPT . NCOLEND
             ) then
               continue ;
             if ( IPOS > L1 -> . LEN ) then
               break ;
             CH := L1 -> . TEXT [ IPOS ] ;
             if CH <> ' ' then
               begin
                 I := I + 1 ;
                 if OPT . ICASE then
                   SBUFK1 [ I ] := TOLOWER ( CH )
                 else
                   SBUFK1 [ I ] := CH ;
               end (* then *)
           end (* for *) ;
         ILEN1 := I ;
         I := 0 ;
         for IPOS := OPT . COLSTART to OPT . COLEND do
           begin
             if ( IPOS >= OPT . NCOLSTART ) and ( IPOS <= OPT . NCOLEND
             ) then
               continue ;
             if ( IPOS > L2 -> . LEN ) then
               break ;
             CH := L2 -> . TEXT [ IPOS ] ;
             if CH <> ' ' then
               begin
                 I := I + 1 ;
                 if OPT . ICASE then
                   SBUFK2 [ I ] := TOLOWER ( CH )
                 else
                   SBUFK2 [ I ] := CH ;
               end (* then *)
           end (* for *) ;
         ILEN2 := I ;
         if ILEN1 <> ILEN2 then
           begin
             COMPX := FALSE ;
             return
           end (* then *) ;
         COMPX := ( SBUFK1 = SBUFK2 ) ;
       end (* then *)
     else
       begin
         I := 0 ;
         for IPOS := OPT . COLSTART to OPT . COLEND do
           begin
             if ( IPOS >= OPT . NCOLSTART ) and ( IPOS <= OPT . NCOLEND
             ) then
               continue ;
             if ( IPOS > L1 -> . LEN ) then
               break ;
             CH := L1 -> . TEXT [ IPOS ] ;
             if CH <> ' ' then
               begin
                 I := I + 1 ;
                 if OPT . ICASE then
                   SBUF1 [ I ] := TOLOWER ( CH )
                 else
                   SBUF1 [ I ] := CH ;
               end (* then *)
           end (* for *) ;
         ILEN1 := I ;
         I := 0 ;
         for IPOS := OPT . COLSTART to OPT . COLEND do
           begin
             if ( IPOS >= OPT . NCOLSTART ) and ( IPOS <= OPT . NCOLEND
             ) then
               continue ;
             if ( IPOS > L2 -> . LEN ) then
               break ;
             CH := L2 -> . TEXT [ IPOS ] ;
             if CH <> ' ' then
               begin
                 I := I + 1 ;
                 if OPT . ICASE then
                   SBUF2 [ I ] := TOLOWER ( CH )
                 else
                   SBUF2 [ I ] := CH ;
               end (* then *)
           end (* for *) ;
         ILEN2 := I ;
         if ILEN1 <> ILEN2 then
           begin
             COMPX := FALSE ;
             return
           end (* then *) ;
         for IREST := ILEN1 + 1 to MAXLEN do
           SBUF1 [ IREST ] := ' ' ;
         for IREST := ILEN2 + 1 to MAXLEN do
           SBUF2 [ IREST ] := ' ' ;
         COMPX := ( SBUF1 = SBUF2 ) ;
       end (* else *)
   end (* COMPX *) ;



function COMPARE_LINE : BOOLEAN ;

(******************************************)
(*   cea/ceb sind die Endespalten der     *)
(*   Dateien A und B                      *)
(******************************************)


   var CEA , CEB : INTEGER ;
       MATCH : BOOLEAN ;
       I : INTEGER ;

   begin (* COMPARE_LINE *)
     if ( A . CURR = NIL ) or ( B . CURR = NIL ) then
       begin
         COMPARE_LINE := ( A . CURR = NIL ) and ( B . CURR = NIL ) ;
         return
       end (* then *) ;
     if OPT . WHITE then
       begin
         COMPARE_LINE := COMPX ( A . CURR , B . CURR ) ;
         return
       end (* then *) ;
     if A . CURR -> . LEN < OPT . COLEND then
       CEA := A . CURR -> . LEN
     else
       CEA := OPT . COLEND ;
     if B . CURR -> . LEN < OPT . COLEND then
       CEB := B . CURR -> . LEN
     else
       CEB := OPT . COLEND ;
     if CEA <> CEB then
       begin
         COMPARE_LINE := FALSE ;
         return
       end (* then *) ;

     /****************************************/
     /*   Die Laengen sind gleich;           */
     /*   jetzt werden die Inhalte ver-      */
     /*   glichen.                           */
     /****************************************/

     if CEA <= OPT . COLSTART then
       begin
         COMPARE_LINE := TRUE ;
         return
       end (* then *) ;
     for I := OPT . COLSTART to CEA do
       begin
         if ( I >= OPT . NCOLSTART ) and ( I <= OPT . NCOLEND ) then
           continue ;
         if OPT . ICASE then
           MATCH := ( TOLOWER ( A . CURR -> . TEXT [ I ] ) = TOLOWER (
                    B . CURR -> . TEXT [ I ] ) )
         else
           MATCH := ( A . CURR -> . TEXT [ I ] = B . CURR -> . TEXT [ I
                    ] ) ;
         if not MATCH then
           break ;
       end (* for *) ;
     COMPARE_LINE := MATCH ;
     return
   end (* COMPARE_LINE *) ;



procedure MARK ( var X : S_FANKER ) ;

(*****************************************************************)
(*   Alles, was vor der aktuellen Position liegt, ist nicht      *)
(*   mehr interessant; deshalb werden die Zeilen zwischen        *)
(*   head und curr weggeworfen (free); head wird auf curr        *)
(*   positioniert.                                               *)
(*****************************************************************)
(*   neu am 07.10.2014: ein paar Zeilen behalten fuer das        *)
(*   Anzeigen des Environments bei Abweichungen                  *)
(*****************************************************************)


   var P : LINEPTR ;

   begin (* MARK *)
     while ( X . HEAD <> X . TAIL ) and ( X . HEAD -> . NEXT <> NIL )
     and ( X . HEAD -> . LINENO < X . CLINE - OPT . ENVIRON ) do
       begin

     /***************************/
     /*   Speicher freigeben    */
     /***************************/

         P := X . HEAD -> . NEXT ;
         FREE ( X . HEAD ) ;
         X . HEAD := P ;
       end (* while *) ;
     if X . HEAD <> NIL then
       begin
         X . HLINE := X . HEAD -> . LINENO ;
       end (* then *)
   end (* MARK *) ;



function MOVECURR ( var X : S_FANKER ) : BOOLEAN ;

   var RC : INTEGER ;

   begin (* MOVECURR *)

     /********************************************************/
     /*   wenn schon eof, raus mit Fehler 8                  */
     /********************************************************/

     if ( X . CURR = NIL ) and ( X . TAIL <> NIL ) then
       begin
         MOVECURR := TRUE ;
         return
       end (* then *) ;

     /********************************************************/
     /*   wenn noch nichts gelesen, eine Zeile lesen         */
     /********************************************************/

     if X . TAIL = NIL then
       begin
         RC := READLINE ( X ) ;
         if RC <> 0 then
           begin
             X . CURR := NIL ;
             X . CLINE := 1 ;
             MOVECURR := TRUE ;
             return
           end (* then *) ;
         X . CURR := X . HEAD ;
         X . CLINE := 1 ;
         MOVECURR := FALSE ;
         return
       end (* then *) ;

     /********************************************************/
     /*   wenn kein weiterer Satz an Tail dranhaengt,        */
     /*   nochmal lesen                                      */
     /********************************************************/

     if X . CURR = X . TAIL then
       begin
         RC := READLINE ( X ) ;
       end (* then *) ;

     /********************************************************/
     /*   wenn kein weiterer Satz an Tail dranhaengt,        */
     /*   sind wir am Dateiende                              */
     /********************************************************/

     if X . CURR = X . TAIL then
       begin
         X . CURR := NIL ;
         X . CLINE := X . CLINE + 1 ;
         MOVECURR := TRUE ;
         return
       end (* then *) ;

     /********************************************************/
     /*   weitersetzen auf naechsten Satz                    */
     /********************************************************/

     X . CURR := X . CURR -> . NEXT ;
     X . CLINE := X . CLINE + 1 ;
     MOVECURR := FALSE ;
   end (* MOVECURR *) ;



procedure BACKTRACK ( var X : S_FANKER ; var XLINES : INTEGER ) ;

   var CLINE : INTEGER ;

   begin (* BACKTRACK *)
     CLINE := X . CLINE + 1 ;
     if X . CURR_SAVE <> NIL then
       begin
         XLINES := CLINE - X . CURR_SAVE -> . LINENO ;
         X . CURR := X . CURR_SAVE ;
         X . CLINE := X . CURR_SAVE -> . LINENO ;
       end (* then *)
     else
       begin
         XLINES := 0 ;
         X . CURR := NIL ;
       end (* else *)
   end (* BACKTRACK *) ;



function CHECKFULLMATCH ( var X : S_FANKER ; var Y : S_FANKER ) :
                        BOOLEAN ;

   var MATCH : BOOLEAN ;
       N : INTEGER ;
       SAVEXCUR , SAVEYCUR : LINEPTR ;
       SAVEXLINE , SAVEYLINE : INTEGER ;
       DUMMYX , DUMMYY : BOOLEAN ;

   begin (* CHECKFULLMATCH *)
     SAVEXCUR := X . CURR ;
     SAVEYCUR := Y . CURR ;
     SAVEXLINE := X . CLINE ;
     SAVEYLINE := Y . CLINE ;
     MATCH := COMPARE_LINE ;
     N := OPT . MINMATCH - 1 ;
     while MATCH and ( N <> 0 ) do
       begin
         DUMMYX := MOVECURR ( X ) ;
         DUMMYY := MOVECURR ( Y ) ;
         MATCH := COMPARE_LINE ;
         N := N - 1 ;
       end (* while *) ;
     X . CURR := SAVEXCUR ;
     X . CLINE := SAVEXLINE ;
     Y . CURR := SAVEYCUR ;
     Y . CLINE := SAVEYLINE ;
     CHECKFULLMATCH := MATCH ;
   end (* CHECKFULLMATCH *) ;



function SEARCH ( var X : S_FANKER ; var Y : S_FANKER ) : BOOLEAN ;

   var COUNT : INTEGER ;
       MATCH : BOOLEAN ;
       EOFY : BOOLEAN ;
       EOFX : BOOLEAN ;

   begin (* SEARCH *)
     EOFY := MOVECURR ( Y ) ;
     EOFX := ( X . CURR_SAVE = NIL ) ;
     if EOFX and EOFY then
       begin
         SEARCH := TRUE ;
         return ;
       end (* then *) ;
     BACKTRACK ( X , COUNT ) ;
     MATCH := CHECKFULLMATCH ( X , Y ) ;
     COUNT := COUNT - 1 ;
     while ( COUNT > 0 ) and not MATCH do
       begin
         EOFX := MOVECURR ( X ) ;
         COUNT := COUNT - 1 ;
         MATCH := CHECKFULLMATCH ( X , Y ) ;
       end (* while *) ;
     SEARCH := MATCH ;
   end (* SEARCH *) ;



procedure SUCHE_GLEICH ;

   var ADVANCEB : BOOLEAN ;
       MATCH : BOOLEAN ;

   begin (* SUCHE_GLEICH *)
     ADVANCEB := FALSE ;
     A . CURR_SAVE := A . CURR ;
     B . CURR_SAVE := B . CURR ;
     A . CLINE_SAVE := A . CLINE ;
     B . CLINE_SAVE := B . CLINE ;
     while TRUE do
       begin
         ADVANCEB := not ADVANCEB ;
         if ADVANCEB then
           begin
             MATCH := SEARCH ( A , B ) ;
           end (* then *)
         else
           begin
             MATCH := SEARCH ( B , A ) ;
           end (* else *) ;
         if MATCH then
           break ;
       end (* while *) ;
     REPORT ;
   end (* SUCHE_GLEICH *) ;



procedure SUCHE_UNGLEICH ;

   var MATCH : BOOLEAN ;
       EOFA : BOOLEAN ;
       EOFB : BOOLEAN ;

   begin (* SUCHE_UNGLEICH *)
     A . CURR_SAVE := NIL ;
     B . CURR_SAVE := NIL ;
     A . CLINE_SAVE := - 1 ;
     B . CLINE_SAVE := - 1 ;
     while TRUE do
       begin
         EOFA := MOVECURR ( A ) ;
         EOFB := MOVECURR ( B ) ;
         if EOFA and EOFB then
           break ;
         MARK ( A ) ;
         MARK ( B ) ;
         MATCH := COMPARE_LINE ;

     /**********************************/
     /*   Sequence Number merken       */
     /**********************************/

         if MATCH then
           SEQ . LASTMSEQ := A . CURR -> . SEQNUM ;
         if not MATCH then
           break ;
       end (* while *)
   end (* SUCHE_UNGLEICH *) ;



function COMPARE_FILES : BOOLEAN ;

   var MATCH : BOOLEAN ;
       DIFFERENT : BOOLEAN ;

   begin (* COMPARE_FILES *)
     MATCH := TRUE ;
     DIFFERENT := FALSE ;
     while TRUE do
       begin
         if MATCH then
           begin
             SUCHE_UNGLEICH ;
             MATCH := FALSE ;
           end (* then *)
         else
           begin
             DIFFERENT := TRUE ;
             SUCHE_GLEICH ;
             MATCH := TRUE ;
           end (* else *) ;
         if ( A . CURR = NIL ) and ( B . CURR = NIL ) then
           break ;
       end (* while *) ;
     COMPARE_FILES := DIFFERENT ;
   end (* COMPARE_FILES *) ;



procedure ERROR ( ERRNO : INTEGER ) ;

   begin (* ERROR *)
     case ERRNO of
       1 : WRITELN ( '+++ Falsches Argument (beginnt nicht mit Minus)'
                     ) ;
       2 : WRITELN ( '+++ Unbekannte Option' ) ;
       3 : WRITELN ( '+++ Falsches Zeichen in Option' ) ;
       4 : WRITELN ( '+++ Nur eine Suboption (Zahl) erlaubt' ) ;
       5 : WRITELN ( '+++ Zwei mit Komma getrennte Zahlen erforderlich'
                     ) ;
     end (* case *) ;
     PARM_FEHLER := TRUE ;
   end (* ERROR *) ;



procedure CHKPARM ( LENGTH : INTEGER ; STRING : OSPARM_TYPE ; var OPT :
                  S_OPTIONS ; var SEQ : S_SEQINFO ) ;

(********************************************************)
(*   Parameter abarbeiten                               *)
(*   fuer einzelne Parameter Prozedur CHKPARM2          *)
(*   aufrufen                                           *)
(********************************************************)


   var I : INTEGER ;
       INPARM : BOOLEAN ;
       CH : CHAR ;
       PARM : OSPARM_TYPE ;
       X : INTEGER ;


   procedure CHKPARM2 ( PARM : OSPARM_TYPE ; var OPT : S_OPTIONS ; var
                      SEQ : S_SEQINFO ) ;


      procedure READPARM ( PARM : OSPARM_TYPE ; ANZAHL : INTEGER ; var
                         ERG1 : INTEGER ; var ERG2 : INTEGER ) ;

         var CP : -> CHAR ;
             CH : CHAR ;
             WERT1 : INTEGER ;
             WERT2 : INTEGER ;
             WERTFELD : INTEGER ;

         begin (* READPARM *)
           WERT1 := 0 ;
           WERT2 := 0 ;
           CP := ADDR ( PARM [ 2 ] ) ;
           WERTFELD := 1 ;
           while CP -> <> ' ' do
             begin
               CH := CP -> ;
               case CH of
                 '0' .. '9' :
                   begin
                     if WERTFELD = 1 then
                       WERT1 := WERT1 * 10 + ORD ( CH ) - ORD ( '0' )
                     else
                       WERT2 := WERT2 * 10 + ORD ( CH ) - ORD ( '0' )
                   end (* tag/ca *) ;
                 ',' : if ANZAHL = 1 then
                         ERROR ( 4 )
                       else
                         WERTFELD := 2 ;
                 otherwise
                   ERROR ( 3 )
               end (* case *) ;
               CP := PTRADD ( CP , 1 ) ;
             end (* while *) ;
           if ANZAHL = 2 then
             if WERTFELD = 1 then
               ERROR ( 5 ) ;
           ERG1 := WERT1 ;
           if ANZAHL = 2 then
             ERG2 := WERT2 ;
         end (* READPARM *) ;


      begin (* CHKPARM2 *)
        case PARM [ 1 ] of
          'T' : OPT . ICASE := TRUE ;
          'A' : OPT . ALLI_TESTFALL := TRUE ;
          'V' : OPT . TRAIL := TRUE ;
          'W' : OPT . WHITE := TRUE ;
          'B' : OPT . BINARY := FALSE ;
          '*' : OPT . LIMITS := TRUE ;
          'C' : begin
                  READPARM ( PARM , 2 , OPT . COLSTART , OPT . COLEND )
                             ;
                end (* tag/ca *) ;
          'D' : begin
                  READPARM ( PARM , 2 , OPT . NCOLSTART , OPT . NCOLEND
                             ) ;
                end (* tag/ca *) ;
          'E' : begin
                  READPARM ( PARM , 1 , OPT . ENVIRON , OPT . ENVIRON )
                             ;
                end (* tag/ca *) ;
          'M' : begin
                  READPARM ( PARM , 1 , OPT . MINMATCH , OPT . MINMATCH
                             ) ;
                  WRITELN ( 'eingelesen: minmatch : ' , OPT . MINMATCH
                            ) ;
                end (* tag/ca *) ;
          'L' : begin

        /******************/
        /* ausgabedatei ? */
        /******************/


                end (* tag/ca *) ;
          'U' : begin

        /*****************/
        /* lstfilename ? */
        /*****************/

                  OPT . EDIT := TRUE ;
                end (* tag/ca *) ;
          'X' : begin
                  TRACE := TRUE ;
                end (* tag/ca *) ;
          'S' : begin

        /***********/
        /* userseq */
        /***********/


                end (* tag/ca *) ;
          'Y' : begin

        /***********/
        /* fileseq */
        /***********/


                end (* tag/ca *) ;
          otherwise
            ERROR ( 2 )
        end (* case *) ;
      end (* CHKPARM2 *) ;


   begin (* CHKPARM *)
     I := 1 ;
     INPARM := FALSE ;
     while I <= LENGTH do
       begin
         CH := STRING [ I ] ;
         if INPARM then
           begin
             if CH = ' ' then
               begin
                 INPARM := FALSE ;
                 CHKPARM2 ( PARM , OPT , SEQ ) ;
               end (* then *)
             else
               begin
                 X := X + 1 ;
                 PARM [ X ] := CH ;
               end (* else *) ;
             I := I + 1 ;
           end (* then *)
         else
           begin
             if CH = ' ' then
               begin
                 I := I + 1 ;
                 continue
               end (* then *) ;
             if CH <> '-' then
               begin
                 ERROR ( 1 ) ;
                 EXIT ( 8 ) ;
               end (* then *) ;
             INPARM := TRUE ;
             X := 0 ;
             PARM := '  ' ;
             I := I + 1 ;
           end (* else *)
       end (* while *) ;
     if INPARM then
       CHKPARM2 ( PARM , OPT , SEQ ) ;
   end (* CHKPARM *) ;



begin (* HAUPTPROGRAMM *)
  TRACE := FALSE ;
  PARM_FEHLER := FALSE ;
  FCB1 := NIL ;
  FCB2 := NIL ;
  WRITELN ;
  WRITELN ( VERSION ) ;
  WRITELN ( 'Vergleich Datei 1 <<< ' , 'mit Datei 2 >>>' ) ;

  /*****************************************/
  /* moegliche Erweiterung:                */
  /* Standardfunktion zur typgerechten     */
  /* Initialisierung einer Struktur        */
  /*****************************************/
  "INIT ( SEQ ) ;                           "

  SEQ . SEQTYPE := 0 ;
  SEQ . SEQSTRT := 1 ;
  SEQ . SEQINCR := 1 ;
  SEQ . SEQCUR := 0 ;
  SEQ . LASTMSEQ := 0 ;

  "**************"
  "INIT ( OPT ) ;"
  "**************"

  OPT . EDIT := FALSE ;
  OPT . WHITE := FALSE ;
  OPT . TRAIL := FALSE ;
  OPT . BINARY := FALSE ;
  OPT . ICASE := FALSE ;
  OPT . LIMITS := FALSE ;
  OPT . COLSTART := 1 ;
  OPT . COLEND := MAXLEN ;
  OPT . NCOLSTART := - 1 ;
  OPT . NCOLEND := - 1 ;
  OPT . MINMATCH := 2 ;
  OPT . ALLI_TESTFALL := FALSE ;
  OPT . ENVIRON := 0 ;

  /********************************************************/
  /*   Testen bzw. Erweiterung                            */
  /*   Command Line Options abarbeiten                    */
  /*   siehe Coding aus XCOMP.C                           */
  /********************************************************/
  /*   Achtung bei MVS:                                   */
  /*   der OSPARM ist tatsaechlich physisch nur so        */
  /*   lang wie LENGTH angibt, also muss er in ein        */
  /*   Hilfsfeld kopiert werden (zeichenweise);           */
  /*   weiterarbeiten dann mit dem Hilfsfeld              */
  /********************************************************/

  if OSPARM <> NIL then
    begin
      with OSPARM -> do
        begin
          WRITELN ( 'Eingelesene Parameter: ' ) ;
          WRITELN ( 'parm: length = ' , LENGTH : 3 ) ;
          PSTRING := ' ' ;
          WRITE ( 'parm: <' ) ;
          for X := 1 to LENGTH do
            begin
              WRITE ( STRING [ X ] ) ;
              PSTRING [ X ] := STRING [ X ] ;
            end (* for *) ;
          WRITELN ( '>' ) ;
          CHKPARM ( LENGTH , PSTRING , OPT , SEQ ) ;
        end (* with *) ;
    end (* then *)
  else
    WRITELN ( 'parm: osparm is nil' ) ;
  if PARM_FEHLER then
    EXIT ( 8 ) ;

  /********************************************************/
  /*   hier geht der eigentliche Vergleich los            */
  /********************************************************/

  INITFANKER ( A , 1 ) ;
  INITFANKER ( B , 2 ) ;
  DIFFERENT := COMPARE_FILES ;
  if not DIFFERENT then
    begin
      WRITELN ( 'Datei 1 und Datei 2 sind identisch.' ) ;
    end (* then *) ;
  CHKHEAP ( 0 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.PAS                          MEMB XCOMPN   EXT PAS HEX -
program XCOMPN ( INPUT , OUTPUT , INFILE1 , INFILE2 ) ;

(********************************************************************)
(*                                                                  *)
(*   XCOMP.C                                                        *)
(*                                                                  *)
(*   Vergleich zweier Dateien analog DIFF;                          *)
(*   erzeugt Eingabe fuer XUPD                                      *)
(*                                                                  *)
(*   angepasst und ueberarbeitet / xs95opp / 28.6.1998              *)
(*                                                                  *)
(********************************************************************)
(*                                                                  *)
(*   Neue Version 20.01.2019 - massive Ueberarbeitung               *)
(*                                                                  *)
(*   Aufgrund von Feedback der Benutzer bei Ergo Direkt war es      *)
(*   noetig, eine Ueberarbeitung der Synchronisationslogik          *)
(*   vorzunehmen (es war eigentlich schon laenger klar, dass        *)
(*   das irgendwann noetig sein wuerde).                            *)
(*                                                                  *)
(*   Neue Features z.B.:                                            *)
(*                                                                  *)
(*   - Erstellen einer Zeilen-Kopie direkt beim Einlesen, die       *)
(*     die Optionen wie IGNCASE, IGNWHITE, Spalteneinschraenkungen  *)
(*     usw. direkt implementiert (Vergleich laeuft dann auf der     *)
(*     Zeilen-Kopie und nicht mehr auf der Original-Zeile);         *)
(*     das sollte einiges an Geschwindigkeit bringen, insbesondere  *)
(*     wenn Zeilen im Zuge der Synchronisation mehrfach geprueft    *)
(*     werden muessen.                                              *)
(*                                                                  *)
(*   - Gleichzeitig auch Vergabe eines Signifikanz-Markers fuer     *)
(*     Zeilen, was ebenfalls bei der Synchronisation eine Rolle     *)
(*     spielen sollte.                                              *)
(*                                                                  *)
(********************************************************************)



const MAXLEN = 1024 ;
      MAXCOLEND = 254 ;
      VERSION = 'XCOMP (Pascal Version 1.2) - 20.01.2019' ;


type OSPARM_TYPE = array [ 1 .. 254 ] of CHAR ;
     ZEILE = array [ 1 .. MAXLEN ] of CHAR ;

     //**********************************************
     //   s_line:
     //
     //   next    - Pointer to the next line
     //   len     - Length of the current line
     //   text    - Pointer to the current line
     //**********************************************
     //   typedef struct line
     //   {
     //      // soll spaeter weg
     //
     //      struct line *next;
     //      struct line *prev;
     //
     //      // ende - soll spaeter weg
     //
     //      int lineno;
     //      char *text_mod;
     //      int len_mod;
     //      char *text_orig;
     //      int len_orig;
     //      int signifikanz;
     //      char errtag [4];
     //      struct symbtab *psymb;
     //      struct line *matchline;
     //      unsigned int rep_status;
     //   }
     //   s_line;
     //**********************************************

     LINEPTR = -> S_LINE ;
     MATCHPTR = -> S_MATCH ;
     S_LINE = record
                NEXT : LINEPTR ;
                PREV : LINEPTR ;
                LINENO : INTEGER ;
                TEXT_MOD : STRING ( 254 ) ;
                LEN_MOD : INTEGER ;
                TEXT_ORIG : ZEILE ;
                LEN_ORIG : INTEGER ;
                SIGNIFIKANZ : INTEGER ;
                PMATCH : MATCHPTR ;
                ERRTAG : CHAR ( 3 ) ;
                PEQLINE : LINEPTR ;
                NUMBEREQ : INTEGER ;
                REP_STATUS : INTEGER
              end ;
     S_MATCH = record
                 COUNT_FILE1 : INTEGER ;
                 COUNT_FILE2 : INTEGER ;
                 LP1 : LINEPTR ;
                 LP2 : LINEPTR ;
               end ;

     /************************************************/
     /*   s_fanker:                                  */
     /*                                              */
     /*   curr     - Ptr to the current line buffer  */
     /*   head     - Ptr to the head of the list     */
     /*   tail     - Ptr to the last line in storage */
     /*   cline    - Line number of current          */
     /*   hline    - Line number of head             */
     /*   tline    - Line number of tail             */
     /************************************************/

     S_FANKER = record
                  FILENO : INTEGER ;
                  FILEH : CHAR ;

     //************************************************************
     // neu:
     // LTAB = Zeiger auf Zeilen-Vektor
     // LALLOC = Anzahl allokierte Zeilen
     // LCOUNT = Anzahl gelesene Zeilen
     // LCOMPARED = Anzahl korrekt verglichene Zeilen
     // IXMAX = Anzahl Zeilen in Arbeit (nach Vergleich)
     // FIRSTLNUM = Nummer der ersten Zeile im Zeilenvektor
     //************************************************************

                  LTAB : -> S_LINE ;
                  LALLOC : INTEGER ;
                  LCOUNT : INTEGER ;
                  LCOMPARED : INTEGER ;
                  IXMAX : INTEGER ;
                  FIRSTLNUM : INTEGER ;

     //************************************************************
     // alt, soll weg:
     //************************************************************

                  CURR : LINEPTR ;
                  CURR_SAVE : LINEPTR ;
                  HEAD : LINEPTR ;
                  TAIL : LINEPTR ;
                  CLINE : INTEGER ;
                  CLINE_SAVE : INTEGER ;
                  HLINE : INTEGER ;
                  TLINE : INTEGER ;

     /******************************************/
     /*  char *fbuffer;                        */
     /*  char *fbuf2;                          */
     /*  int lbuf2;                            */
     /*  char *cp2;                            */
     /******************************************/

                end ;

     //**********************************************
     //   s_options:
     //
     //   white     - ignore whitespace
     //   case      - ignore case
     //   limits    - Begrenzungszeichen in Liste
     //   colstart  - colstart fuer Vergleich
     //   colend    - colende fuer Vergleich
     //   ncolstart - colstart fuer Vergleich
     //   ncolend   - colende fuer Vergleich
     //**********************************************
     // char trail;
     // char white;
     // char binary;
     // char icase;
     // char limits;
     // int colstart;
     // int colend;
     // int ncolstart;
     // int ncolend;
     // int minmatch;
     // int environ;
     // int showall;
     // char newkennung [4];
     // char oldkennung [4];
     // int bufsize;
     //**********************************************

     S_OPTIONS = record
                   TRAIL : BOOLEAN ;
                   WHITE : BOOLEAN ;
                   BINARY : BOOLEAN ;
                   ICASE : BOOLEAN ;
                   LIMITS : BOOLEAN ;
                   COLSTART : INTEGER ;
                   COLEND : INTEGER ;
                   NCOLSTART : INTEGER ;
                   NCOLEND : INTEGER ;
                   MINMATCH : INTEGER ;
                   ENVIRON : INTEGER ;
                   SHOWALL : BOOLEAN ;
                   NEWKENNUNG : CHAR ( 3 ) ;
                   OLDKENNUNG : CHAR ( 3 ) ;
                   BUFSIZE : INTEGER ;
                 end ;


var PARM_FEHLER : BOOLEAN ;
    INFILE1 : TEXT ;
    INFILE2 : TEXT ;
    OPT : S_OPTIONS ;
    DIFFERENT : BOOLEAN ;
    SF1 : S_FANKER ;
    SF2 : S_FANKER ;
    TRACE : BOOLEAN ;
    FCB1 : VOIDPTR ;
    FCB2 : VOIDPTR ;
    X : INTEGER ;
    PARMSTRING : OSPARM_TYPE ;



function AVLSRCH ( SKEY : VOIDPTR ;           // ptr to key
                 SKEYLEN : INTEGER ;          // keylen (if deep copy)
                 var POBJ : VOIDPTR ;         // ptr to obj ptr
                 var POBJLEN : VOIDPTR ;      // ptr to objlen field
                 var GEFUNDEN : BOOLEAN ;     // true if found
                 var PP : VOIDPTR ;           // tree pointer
                 var HCHANGED : BOOLEAN ;     // height changed
                 EINFUEGEN : BOOLEAN ;        // if insert then true
                 function AVLCOMP ( X1 : VOIDPTR ; L1 : INTEGER ; X2 :
                 VOIDPTR ; L2 : INTEGER ) : INTEGER ) : VOIDPTR ;

   EXTERNAL ;



function AVLGET ( MODUS : CHAR ;            // mode = F(irst), N(ext)
                START : VOIDPTR ;           // starting position
                var RESULT : VOIDPTR ;      // new position
                var PKEY : VOIDPTR ;        // pointer to key
                var KEYLEN : INTEGER ;      // keylen
                var POBJ : VOIDPTR ;        // pointer to obj
                var OBJLEN : INTEGER )      // objlen
                : INTEGER ;                 // zero, if OK

   EXTERNAL ;



procedure AVLPRINT ( P : VOIDPTR ;            // tree to print
                   var AUSGFILE : TEXT ;      // output file
                   EINRUECK : INTEGER ;       // indentation count
                   PV : VOIDPTR ;             // nil on top level call
                   RICHTUNG : CHAR ;          // blank on top level call
                   procedure AVLPKEY ( var F : TEXT ; P : VOIDPTR ) ) ;

   EXTERNAL ;



procedure AVLFREE ( P : VOIDPTR ) ;

   EXTERNAL ;



function AVLCACHE ( FUNKCODE : CHAR ( 8 ) ;   // Funktionscode
                  PHANDLE : VOIDPTR ;         // Cachehandle
                  var SEQKEY : VOIDPTR ;      // seq. Keyposition,
                  var PKEY : VOIDPTR ;        // Zeiger auf Key
                  var LKEY : INTEGER ;        // Laenge Key
                  var PDAT : VOIDPTR ;        // Zeiger auf Daten
                  var LDAT : INTEGER )        // Laenge Daten
                  : INTEGER ;

   EXTERNAL ;



function TOUPPER ( C : CHAR ) : CHAR ;

   begin (* TOUPPER *)
     if C in [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' ] then
       C := CHR ( ORD ( C ) - ORD ( 'a' ) + ORD ( 'A' ) ) ;
     TOUPPER := C ;
   end (* TOUPPER *) ;



function TOLOWER ( C : CHAR ) : CHAR ;

   begin (* TOLOWER *)
     if C in [ 'A' .. 'I' , 'J' .. 'R' , 'S' .. 'Z' ] then
       C := CHR ( ORD ( C ) - ORD ( 'A' ) + ORD ( 'a' ) ) ;
     TOLOWER := C ;
   end (* TOLOWER *) ;



procedure S_TOLOWER ( var S : STRING ) ;

   var I : INTEGER ;

   begin (* S_TOLOWER *)
     for I := 1 to LENGTH ( S ) do
       S [ I ] := TOLOWER ( S [ I ] )
   end (* S_TOLOWER *) ;



function COMPARE ( X1 : VOIDPTR ; L1 : INTEGER ; X2 : VOIDPTR ; L2 :
                 INTEGER ) : INTEGER ;

//**********************************************************************
// compare function for AVL tree key values (here: integer keys)
// this function is passed as a parameter to avlsrch
//**********************************************************************


   var I1 : INTEGER ;
       IP1 : -> INTEGER ;
       I2 : INTEGER ;
       IP2 : -> INTEGER ;

   begin (* COMPARE *)
     IP1 := X1 ;
     IP2 := X2 ;
     I1 := IP1 -> ;
     I2 := IP2 -> ;
     if I1 > I2 then
       COMPARE := 1
     else
       if I1 < I2 then
         COMPARE := - 1
       else
         COMPARE := 0 ;
   end (* COMPARE *) ;



procedure PRINTELEM ( var F : TEXT ; X : VOIDPTR ) ;

//**********************************************************************
// print key value
// this function is passed as a parameter to avlprint
//**********************************************************************


   var I1 : INTEGER ;
       IP1 : -> INTEGER ;

   begin (* PRINTELEM *)
     IP1 := X ;
     I1 := IP1 -> ;
     WRITE ( F , I1 : 8 ) ;
   end (* PRINTELEM *) ;



procedure DUMP ( PVON : VOIDPTR ; PBIS : VOIDPTR ) ;

(*********************************************************)
(*  Speicherbereich von PVON bis PBIS hexadezimal        *)
(*  ausgeben                                             *)
(*********************************************************)


   var P1 : VOIDPTR ;
       P2 : VOIDPTR ;
       MOD1 : INTEGER ;
       MOD2 : INTEGER ;


   procedure DUMPCHAR ( CH : CHAR ) ;

      begin (* DUMPCHAR *)
        if CH in [ 'a' .. 'i' , 'j' .. 'r' , 's' .. 'z' , 'A' .. 'I' ,
        'J' .. 'R' , 'S' .. 'Z' , '0' .. '9' ] then
          WRITE ( CH )
        else
          WRITE ( '.' )
      end (* DUMPCHAR *) ;


   procedure DUMPZEILE ( ADR : VOIDPTR ; P1 : VOIDPTR ; P2 : VOIDPTR )
                       ;

      var CH : -> CHAR ;
          I : INTEGER ;

      begin (* DUMPZEILE *)
        CH := PTRCAST ( ADR ) ;
        WRITE ( ADR , ': ' ) ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 4 )
        then
          WRITE ( '........ ' )
        else
          WRITE ( ADR , ' ' ) ;
        ADR := PTRADD ( ADR , 4 ) ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 4 )
        then
          WRITE ( '........ ' )
        else
          WRITE ( ADR , ' ' ) ;
        ADR := PTRADD ( ADR , 4 ) ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 4 )
        then
          WRITE ( '........ ' )
        else
          WRITE ( ADR , ' ' ) ;
        ADR := PTRADD ( ADR , 4 ) ;
        if ( PTRDIFF ( ADR , P1 ) < 0 ) or ( PTRDIFF ( ADR , P2 ) > 4 )
        then
          WRITE ( '........ ' )
        else
          WRITE ( ADR , ' ' ) ;
        WRITE ( ' *' ) ;
        for I := 1 to 16 do
          begin
            DUMPCHAR ( CH -> ) ;
            CH := PTRADD ( CH , 1 )
          end (* for *) ;
        WRITELN ( '*' ) ;
      end (* DUMPZEILE *) ;


   begin (* DUMP *)
     WRITELN ( 'Dump Speicherbereich von ' , PVON , ' bis ' , PBIS ) ;
     P1 := PTRADD ( PVON , - 16 ) ;
     MOD1 := PTR2INT ( P1 ) MOD 16 ;
     P1 := PTRADD ( P1 , 16 - MOD1 ) ;
     P2 := PTRADD ( PBIS , 15 ) ;
     MOD2 := PTR2INT ( P2 ) MOD 16 ;
     P2 := PTRADD ( P2 , - MOD2 ) ;
     while PTRDIFF ( P1 , P2 ) < 0 do
       begin
         DUMPZEILE ( P1 , PVON , PBIS ) ;
         P1 := PTRADD ( P1 , 16 ) ;
       end (* while *) ;
   end (* DUMP *) ;



procedure CHECKFILE ( FCB : VOIDPTR ) ;

   var PBUFNO : -> CHAR ;
       PBUFCB : -> VOIDPTR ;
       PBUF : VOIDPTR ;
       BUFPTR : VOIDPTR ;
       PSIZE : -> INTEGER ;
       BUFSIZE : INTEGER ;
       BUFSIZE1 : INTEGER ;
       BUFSIZE2 : INTEGER ;
       CHKPTR : INTEGER ;
       CHKPTR2 : INTEGER ;

   begin (* CHECKFILE *)
     PBUFCB := PTRADD ( FCB , 56 ) ;
     PBUFNO := PTRCAST ( PBUFCB ) ;
     PBUF := PBUFCB -> ;
     PBUFCB := PTRCAST ( PBUF ) ;
     BUFPTR := PBUFCB -> ;
     PSIZE := PTRADD ( PBUFCB , 4 ) ;
     BUFSIZE := PSIZE -> ;
     BUFSIZE1 := BUFSIZE DIV 65536 ;
     BUFSIZE2 := BUFSIZE MOD 65536 ;
     WRITELN ( '*** checkfile +++ pbuf = ' , PBUF , ' bufptr = ' ,
               BUFPTR ) ;
     CHKPTR := PTR2INT ( BUFPTR ) ;
     CHKPTR2 := PTR2INT ( PBUF ) MOD 16777216 + 8 ;
     if ( BUFSIZE1 <> ORD ( PBUFNO -> ) ) or ( CHKPTR < CHKPTR2 ) or (
     CHKPTR > CHKPTR2 + ( BUFSIZE1 - 1 ) * BUFSIZE2 ) then
       begin
         WRITELN ( '+++ bufno von infile = ' , ORD ( PBUFNO -> ) ) ;
         WRITELN ( '+++ bufsize1 = ' , BUFSIZE1 ) ;
         WRITELN ( '+++ bufsize2 = ' , BUFSIZE2 ) ;
         WRITELN ( '+++ pbuf = ' , PBUF ) ;
         WRITELN ( '+++ bufptr = ' , BUFPTR ) ;
         WRITELN ( '+++ fcb des files:' ) ;
         DUMP ( FCB , PTRADD ( FCB , 132 ) ) ;
         WRITELN ( '+++ anfang buffer von infile:' ) ;
         DUMP ( PBUF , PTRADD ( PBUF , 64 ) ) ;
         EXIT ( 1999 ) ;
       end (* then *)
   end (* CHECKFILE *) ;



procedure INITFANKER ( var X : S_FANKER ; DATEI : INTEGER ) ;

   begin (* INITFANKER *)
     X . FILENO := DATEI ;
     X . FILEH := CHR ( ORD ( '0' ) + DATEI ) ;
     X . CURR := NIL ;
     X . HEAD := NIL ;
     X . TAIL := NIL ;
     X . CLINE := 0 ;
     X . CLINE_SAVE := 0 ;
     X . HLINE := 0 ;
     X . TLINE := 0 ;
     X . LTAB := NIL ;
     X . LALLOC := 0 ;
     X . LCOUNT := 0 ;
     X . LCOMPARED := 0 ;
     X . FIRSTLNUM := 1 ;
   end (* INITFANKER *) ;



procedure TRACE1 ( X : CHAR ( 64 ) ) ;

   begin (* TRACE1 *)
     return ;
     WRITELN ( 'Trace1: ' , X ) ;
   end (* TRACE1 *) ;



procedure TRACE2 ( FILEH : CHAR ; L : LINEPTR ) ;

   var I : INTEGER ;

   begin (* TRACE2 *)
     return ;
     WRITELN ( 'gelesen von Datei ' , FILEH , ' (' , L , '):' ) ;
     for I := 1 to L -> . LEN_ORIG do
       WRITE ( L -> . TEXT_ORIG [ I ] ) ;
     WRITELN ;
   end (* TRACE2 *) ;



procedure TESTPUT ;

   begin (* TESTPUT *)
     return ;
     WRITELN ( 'Testput' ) ;
   end (* TESTPUT *) ;



function READLINE ( var X : S_FANKER ) : INTEGER ;

   type SHOWPTR = record
                    case BOOLEAN of
                      FALSE :
                        ( X1 : LINEPTR ) ;
                      TRUE :
                        ( X2 : INTEGER )
                  end ;

   var RC : INTEGER ;
       NEWLINE : LINEPTR ;
       L : INTEGER ;
       LAENGE : INTEGER ;
       GELESEN : BOOLEAN ;
       ANZ : INTEGER ;
       TEMP_LEN : INTEGER ;
       EOFX : BOOLEAN ;
       Z : SHOWPTR ;

   begin (* READLINE *)

     /************************************************/
     /*   Zeile einlesen binaer                      */
     /************************************************/

     if OPT . BINARY then
       begin

     /***********************/
     /* zunaechst weglassen */
     /***********************/

         GELESEN := FALSE
       end (* then *)

     /************************************************/
     /*   Zeile einlesen normal Text                 */
     /************************************************/

     else
       begin
         if X . FILEH = '1' then
           EOFX := EOF ( INFILE1 )
         else
           EOFX := EOF ( INFILE2 ) ;
         if not EOFX then
           begin

     /************************************************/
     /*   WRITELN ( 'checkfile vor alloc' ) ;        */
     /*   if FCB1 <> NIL then                        */
     /*     CHECKFILE ( FCB1 ) ;                     */
     /*   if FCB2 <> NIL then                        */
     /*     CHECKFILE ( FCB2 )                       */
     /************************************************/

             NEWLINE := ALLOC ( SIZEOF ( S_LINE ) ) ;

     /************************************************/
     /*   WRITELN ( 'checkfile nach alloc' ) ;       */
     /*   if FCB1 <> NIL then                        */
     /*     CHECKFILE ( FCB1 ) ;                     */
     /*   if FCB2 <> NIL then                        */
     /*     CHECKFILE ( FCB2 )                       */
     /************************************************/

             with NEWLINE -> do
               begin
                 NEXT := NIL ;
                 LINENO := 0 ;
                 LEN_ORIG := 0 ;
                 if X . FILEH = '1' then
                   begin
                     READ ( INFILE1 , TEXT_ORIG ) ;
                     READLN ( INFILE1 ) ;
                   end (* then *)
                 else
                   begin
                     READ ( INFILE2 , TEXT_ORIG ) ;
                     READLN ( INFILE2 ) ;
                   end (* else *)
               end (* with *) ;
             GELESEN := TRUE
           end (* then *)
         else
           begin
             GELESEN := FALSE ;
             NEWLINE := NIL ;
           end (* else *) ;
         if GELESEN then
           begin
             LAENGE := MAXLEN ;
             while LAENGE > 0 do
               begin
                 if NEWLINE -> . TEXT_ORIG [ LAENGE ] <> ' ' then
                   break ;
                 LAENGE := LAENGE - 1 ;
               end (* while *) ;
             NEWLINE -> . LEN_ORIG := LAENGE ;
           end (* then *) ;
       end (* else *) ;
     if GELESEN then
       begin
         if X . TAIL = NIL then
           begin
             X . HEAD := NEWLINE ;
             X . TLINE := 1 ;
             X . HLINE := 1 ;
           end (* then *)
         else
           begin
             X . TAIL -> . NEXT := NEWLINE ;
             X . TLINE := X . TLINE + 1 ;
           end (* else *) ;
         X . TAIL := NEWLINE ;
         NEWLINE -> . LINENO := X . TLINE ;
       end (* then *) ;
     RC := 4 ;
     if GELESEN then
       RC := 0 ;
     READLINE := RC
   end (* READLINE *) ;



procedure REPORT_LINE ( KENNUNG : CHAR ( 3 ) ; LINENO : INTEGER ;
                      PATTERN : CHAR ( 3 ) ; var BUF : ZEILE ; LEN :
                      INTEGER ; LIMITS : BOOLEAN ) ;

   var I : INTEGER ;

   begin (* REPORT_LINE *)
     if KENNUNG = ' ' then
       WRITE ( LINENO : 6 )
     else
       WRITE ( KENNUNG , ' ' , LINENO : - 6 ) ;
     WRITE ( ' ' , PATTERN , ' ' ) ;
     if LIMITS then
       WRITE ( '*' ) ;
     for I := 1 to LEN do
       WRITE ( BUF [ I ] ) ;
     if LIMITS then
       WRITE ( '*' ) ;
     WRITELN ;
   end (* REPORT_LINE *) ;



procedure REPORT ;

   var STATE : INTEGER ;
       LINENO : INTEGER ;
       P : LINEPTR ;
       ALAST : LINEPTR ;

       /***************************************************/
       /*   Pointer to the last unmatched lines in file a */
       /***************************************************/

       BLAST : LINEPTR ;

       /****************/
       /*   and file b */
       /****************/

       LINENOA : INTEGER ;
       LINENOB : INTEGER ;
       PA : LINEPTR ;
       PB : LINEPTR ;
       ENV : INTEGER ;
       ABWEICHUNG : BOOLEAN ;
       DUMMYRC : INTEGER ;

   const LINE1 : CHAR ( 64 ) =
    '================================================================'
         ;
         LINE2 : CHAR ( 64 ) =
    '----------------------------------------------------------------'
         ;

   begin (* REPORT *)
     WRITELN ;
     WRITELN ( LINE1 ) ;

     /***************************************************/
     /*   Ausgabe, wenn von links etwas (mehr) da ist   */
     /***************************************************/

     if SF1 . HEAD <> SF1 . CURR then
       begin

     /***************************************************/
     /*   head ist evtl. nicht die Stelle der           */
     /*   Abweichung, sondern schon vorher, siehe       */
     /*   environ. Dann werden ein paar Zeilen mehr     */
     /*   ausgegeben, aber mit Punkten (weil dort       */
     /*   keine Abweichung ist), entsprechend auch      */
     /*   nach der Abweichung. Die echte Abweichung     */
     /*   wird mit <<< gekennzeichnet                   */
     /***************************************************/

         ABWEICHUNG := FALSE ;
         LINENO := SF1 . HLINE ;
         P := SF1 . HEAD ;
         while ( P <> NIL ) and ( P <> SF1 . CURR ) do
           begin
             if ( LINENO >= SF1 . CLINE_SAVE - OPT . ENVIRON ) then
               begin
                 if P = SF1 . CURR_SAVE then
                   ABWEICHUNG := TRUE ;
                 if not ABWEICHUNG then
                   begin
                     REPORT_LINE ( '   ' , LINENO , '...' , P -> .
                                   TEXT_ORIG , P -> . LEN_ORIG , OPT .
                                   LIMITS ) ;
                   end (* then *)
                 else
                   begin
                     REPORT_LINE ( '   ' , LINENO , '<<<' , P -> .
                                   TEXT_ORIG , P -> . LEN_ORIG , OPT .
                                   LIMITS ) ;
                   end (* else *)
               end (* then *) ;
             LINENO := LINENO + 1 ;
             P := P -> . NEXT
           end (* while *) ;

     /***************************************************/
     /*   ggf. ein paar Zeilen nach der Abweichung      */
     /*   ausgeben, mit Punkten                         */
     /***************************************************/

         ENV := 0 ;
         LINENO := SF1 . CLINE ;
         P := SF1 . CURR ;
         while ( ENV < OPT . ENVIRON ) and ( P <> NIL ) do
           begin
             REPORT_LINE ( '   ' , LINENO , '...' , P -> . TEXT_ORIG ,
                           P -> . LEN_ORIG , OPT . LIMITS ) ;
             if P -> . NEXT = NIL then
               begin
                 DUMMYRC := READLINE ( SF1 ) ;
               end (* then *) ;
             ENV := ENV + 1 ;
             LINENO := LINENO + 1 ;
             P := P -> . NEXT
           end (* while *) ;
       end (* then *) ;

     /***************************************************/
     /*   Trennstrich, wenn links und rechts vorh.      */
     /***************************************************/

     if ( ( SF1 . CLINE_SAVE <> SF1 . CLINE ) and ( SF2 . CLINE_SAVE <>
     SF2 . CLINE ) ) or ( OPT . ENVIRON > 0 ) then
       begin
         WRITELN ( LINE2 ) ;
       end (* then *) ;

     /***************************************************/
     /*   Ausgabe, wenn von rechts etwas (mehr) da ist  */
     /***************************************************/

     ABWEICHUNG := FALSE ;
     if SF2 . HEAD <> SF2 . CURR then
       begin
         LINENO := SF2 . HLINE ;
         P := SF2 . HEAD ;
         while ( P <> NIL ) and ( P <> SF2 . CURR ) do
           begin
             if ( LINENO >= SF2 . CLINE_SAVE - OPT . ENVIRON ) then
               begin
                 if P = SF2 . CURR_SAVE then
                   ABWEICHUNG := TRUE ;
                 if not ABWEICHUNG then
                   begin
                     REPORT_LINE ( '   ' , LINENO , '...' , P -> .
                                   TEXT_ORIG , P -> . LEN_ORIG , OPT .
                                   LIMITS ) ;
                   end (* then *)
                 else
                   begin
                     REPORT_LINE ( '   ' , LINENO , '>>>' , P -> .
                                   TEXT_ORIG , P -> . LEN_ORIG , OPT .
                                   LIMITS ) ;
                   end (* else *)
               end (* then *) ;
             LINENO := LINENO + 1 ;
             P := P -> . NEXT
           end (* while *) ;
         ENV := 0 ;
         LINENO := SF2 . CLINE ;
         P := SF2 . CURR ;
         while ( ENV < OPT . ENVIRON ) and ( P <> NIL ) do
           begin
             REPORT_LINE ( '   ' , LINENO , '...' , P -> . TEXT_ORIG ,
                           P -> . LEN_ORIG , OPT . LIMITS ) ;
             if P -> . NEXT = NIL then
               begin
                 DUMMYRC := READLINE ( SF2 ) ;
               end (* then *) ;
             ENV := ENV + 1 ;
             LINENO := LINENO + 1 ;
             P := P -> . NEXT
           end (* while *) ;
       end (* then *) ;
   end (* REPORT *) ;



function COMPX ( L1 : LINEPTR ; L2 : LINEPTR ) : BOOLEAN ;

   var SBUF1 : ZEILE ;
       SBUF2 : ZEILE ;
       SBUFK1 : CHAR ( 64 ) ;
       SBUFK2 : CHAR ( 64 ) ;
       I : INTEGER ;
       IPOS : INTEGER ;
       IREST : INTEGER ;
       ILEN1 : INTEGER ;
       ILEN2 : INTEGER ;
       CH : CHAR ;

   begin (* COMPX *)
     if ( L1 -> . LEN_ORIG <= 64 ) and ( L2 -> . LEN_ORIG <= 64 ) then
       begin
         SBUFK1 := ' ' ;
         SBUFK2 := ' ' ;
         I := 0 ;
         for IPOS := OPT . COLSTART to OPT . COLEND do
           begin
             if ( IPOS >= OPT . NCOLSTART ) and ( IPOS <= OPT . NCOLEND
             ) then
               continue ;
             if ( IPOS > L1 -> . LEN_ORIG ) then
               break ;
             CH := L1 -> . TEXT_ORIG [ IPOS ] ;
             if CH <> ' ' then
               begin
                 I := I + 1 ;
                 if OPT . ICASE then
                   SBUFK1 [ I ] := TOLOWER ( CH )
                 else
                   SBUFK1 [ I ] := CH ;
               end (* then *)
           end (* for *) ;
         ILEN1 := I ;
         I := 0 ;
         for IPOS := OPT . COLSTART to OPT . COLEND do
           begin
             if ( IPOS >= OPT . NCOLSTART ) and ( IPOS <= OPT . NCOLEND
             ) then
               continue ;
             if ( IPOS > L2 -> . LEN_ORIG ) then
               break ;
             CH := L2 -> . TEXT_ORIG [ IPOS ] ;
             if CH <> ' ' then
               begin
                 I := I + 1 ;
                 if OPT . ICASE then
                   SBUFK2 [ I ] := TOLOWER ( CH )
                 else
                   SBUFK2 [ I ] := CH ;
               end (* then *)
           end (* for *) ;
         ILEN2 := I ;
         if ILEN1 <> ILEN2 then
           begin
             COMPX := FALSE ;
             return
           end (* then *) ;
         COMPX := ( SBUFK1 = SBUFK2 ) ;
       end (* then *)
     else
       begin
         I := 0 ;
         for IPOS := OPT . COLSTART to OPT . COLEND do
           begin
             if ( IPOS >= OPT . NCOLSTART ) and ( IPOS <= OPT . NCOLEND
             ) then
               continue ;
             if ( IPOS > L1 -> . LEN_ORIG ) then
               break ;
             CH := L1 -> . TEXT_ORIG [ IPOS ] ;
             if CH <> ' ' then
               begin
                 I := I + 1 ;
                 if OPT . ICASE then
                   SBUF1 [ I ] := TOLOWER ( CH )
                 else
                   SBUF1 [ I ] := CH ;
               end (* then *)
           end (* for *) ;
         ILEN1 := I ;
         I := 0 ;
         for IPOS := OPT . COLSTART to OPT . COLEND do
           begin
             if ( IPOS >= OPT . NCOLSTART ) and ( IPOS <= OPT . NCOLEND
             ) then
               continue ;
             if ( IPOS > L2 -> . LEN_ORIG ) then
               break ;
             CH := L2 -> . TEXT_ORIG [ IPOS ] ;
             if CH <> ' ' then
               begin
                 I := I + 1 ;
                 if OPT . ICASE then
                   SBUF2 [ I ] := TOLOWER ( CH )
                 else
                   SBUF2 [ I ] := CH ;
               end (* then *)
           end (* for *) ;
         ILEN2 := I ;
         if ILEN1 <> ILEN2 then
           begin
             COMPX := FALSE ;
             return
           end (* then *) ;
         for IREST := ILEN1 + 1 to MAXLEN do
           SBUF1 [ IREST ] := ' ' ;
         for IREST := ILEN2 + 1 to MAXLEN do
           SBUF2 [ IREST ] := ' ' ;
         COMPX := ( SBUF1 = SBUF2 ) ;
       end (* else *)
   end (* COMPX *) ;



function COMPARE_LINE : BOOLEAN ;

(******************************************)
(*   cea/ceb sind die Endespalten der     *)
(*   Dateien SF1 und SF2                  *)
(*                                        *)
(******************************************)


   var CEA , CEB : INTEGER ;
       MATCH : BOOLEAN ;
       I : INTEGER ;

   begin (* COMPARE_LINE *)
     if ( SF1 . CURR = NIL ) or ( SF2 . CURR = NIL ) then
       begin
         COMPARE_LINE := ( SF1 . CURR = NIL ) and ( SF2 . CURR = NIL )
                         ;
         return
       end (* then *) ;
     if OPT . WHITE then
       begin
         COMPARE_LINE := COMPX ( SF1 . CURR , SF2 . CURR ) ;
         return
       end (* then *) ;
     if SF1 . CURR -> . LEN_ORIG < OPT . COLEND then
       CEA := SF1 . CURR -> . LEN_ORIG
     else
       CEA := OPT . COLEND ;
     if SF2 . CURR -> . LEN_ORIG < OPT . COLEND then
       CEB := SF2 . CURR -> . LEN_ORIG
     else
       CEB := OPT . COLEND ;
     if CEA <> CEB then
       begin
         COMPARE_LINE := FALSE ;
         return
       end (* then *) ;

     /****************************************/
     /*   Die Laengen sind gleich;           */
     /*   jetzt werden die Inhalte ver-      */
     /*   glichen.                           */
     /****************************************/

     if CEA <= OPT . COLSTART then
       begin
         COMPARE_LINE := TRUE ;
         return
       end (* then *) ;
     for I := OPT . COLSTART to CEA do
       begin
         if ( I >= OPT . NCOLSTART ) and ( I <= OPT . NCOLEND ) then
           continue ;
         if OPT . ICASE then
           MATCH := ( TOLOWER ( SF1 . CURR -> . TEXT_ORIG [ I ] ) =
                    TOLOWER ( SF2 . CURR -> . TEXT_ORIG [ I ] ) )
         else
           MATCH := ( SF1 . CURR -> . TEXT_ORIG [ I ] = SF2 . CURR -> .
                    TEXT_ORIG [ I ] ) ;
         if not MATCH then
           break ;
       end (* for *) ;
     COMPARE_LINE := MATCH ;
     return
   end (* COMPARE_LINE *) ;



procedure MARK ( var X : S_FANKER ) ;

(*****************************************************************)
(*   Alles, was vor der aktuellen Position liegt, ist nicht      *)
(*   mehr interessant; deshalb werden die Zeilen zwischen        *)
(*   head und curr weggeworfen (free); head wird auf curr        *)
(*   positioniert.                                               *)
(*****************************************************************)
(*   neu am 07.10.2014: ein paar Zeilen behalten fuer das        *)
(*   Anzeigen des Environments bei Abweichungen                  *)
(*****************************************************************)


   var P : LINEPTR ;

   begin (* MARK *)
     while ( X . HEAD <> X . TAIL ) and ( X . HEAD -> . NEXT <> NIL )
     and ( X . HEAD -> . LINENO < X . CLINE - OPT . ENVIRON ) do
       begin

     /***************************/
     /*   Speicher freigeben    */
     /***************************/

         P := X . HEAD -> . NEXT ;
         FREE ( X . HEAD ) ;
         X . HEAD := P ;
       end (* while *) ;
     if X . HEAD <> NIL then
       begin
         X . HLINE := X . HEAD -> . LINENO ;
       end (* then *)
   end (* MARK *) ;



function MOVECURR ( var X : S_FANKER ) : BOOLEAN ;

   var RC : INTEGER ;

   begin (* MOVECURR *)

     /********************************************************/
     /*   wenn schon eof, raus mit Fehler 8                  */
     /********************************************************/

     if ( X . CURR = NIL ) and ( X . TAIL <> NIL ) then
       begin
         MOVECURR := TRUE ;
         return
       end (* then *) ;

     /********************************************************/
     /*   wenn noch nichts gelesen, eine Zeile lesen         */
     /********************************************************/

     if X . TAIL = NIL then
       begin
         RC := READLINE ( X ) ;
         if RC <> 0 then
           begin
             X . CURR := NIL ;
             X . CLINE := 1 ;
             MOVECURR := TRUE ;
             return
           end (* then *) ;
         X . CURR := X . HEAD ;
         X . CLINE := 1 ;
         MOVECURR := FALSE ;
         return
       end (* then *) ;

     /********************************************************/
     /*   wenn kein weiterer Satz an Tail dranhaengt,        */
     /*   nochmal lesen                                      */
     /********************************************************/

     if X . CURR = X . TAIL then
       begin
         RC := READLINE ( X ) ;
       end (* then *) ;

     /********************************************************/
     /*   wenn kein weiterer Satz an Tail dranhaengt,        */
     /*   sind wir am Dateiende                              */
     /********************************************************/

     if X . CURR = X . TAIL then
       begin
         X . CURR := NIL ;
         X . CLINE := X . CLINE + 1 ;
         MOVECURR := TRUE ;
         return
       end (* then *) ;

     /********************************************************/
     /*   weitersetzen auf naechsten Satz                    */
     /********************************************************/

     X . CURR := X . CURR -> . NEXT ;
     X . CLINE := X . CLINE + 1 ;
     MOVECURR := FALSE ;
   end (* MOVECURR *) ;



procedure BACKTRACK ( var X : S_FANKER ; var XLINES : INTEGER ) ;

   var CLINE : INTEGER ;

   begin (* BACKTRACK *)
     CLINE := X . CLINE + 1 ;
     if X . CURR_SAVE <> NIL then
       begin
         XLINES := CLINE - X . CURR_SAVE -> . LINENO ;
         X . CURR := X . CURR_SAVE ;
         X . CLINE := X . CURR_SAVE -> . LINENO ;
       end (* then *)
     else
       begin
         XLINES := 0 ;
         X . CURR := NIL ;
       end (* else *)
   end (* BACKTRACK *) ;



function CHECKFULLMATCH ( var X : S_FANKER ; var Y : S_FANKER ) :
                        BOOLEAN ;

   var MATCH : BOOLEAN ;
       N : INTEGER ;
       SAVEXCUR , SAVEYCUR : LINEPTR ;
       SAVEXLINE , SAVEYLINE : INTEGER ;
       DUMMYX , DUMMYY : BOOLEAN ;

   begin (* CHECKFULLMATCH *)
     SAVEXCUR := X . CURR ;
     SAVEYCUR := Y . CURR ;
     SAVEXLINE := X . CLINE ;
     SAVEYLINE := Y . CLINE ;
     MATCH := COMPARE_LINE ;
     N := OPT . MINMATCH - 1 ;
     while MATCH and ( N <> 0 ) do
       begin
         DUMMYX := MOVECURR ( X ) ;
         DUMMYY := MOVECURR ( Y ) ;
         MATCH := COMPARE_LINE ;
         N := N - 1 ;
       end (* while *) ;
     X . CURR := SAVEXCUR ;
     X . CLINE := SAVEXLINE ;
     Y . CURR := SAVEYCUR ;
     Y . CLINE := SAVEYLINE ;
     CHECKFULLMATCH := MATCH ;
   end (* CHECKFULLMATCH *) ;



function SEARCH ( var X : S_FANKER ; var Y : S_FANKER ) : BOOLEAN ;

   var COUNT : INTEGER ;
       MATCH : BOOLEAN ;
       EOFY : BOOLEAN ;
       EOFX : BOOLEAN ;

   begin (* SEARCH *)
     EOFY := MOVECURR ( Y ) ;
     EOFX := ( X . CURR_SAVE = NIL ) ;
     if EOFX and EOFY then
       begin
         SEARCH := TRUE ;
         return ;
       end (* then *) ;
     BACKTRACK ( X , COUNT ) ;
     MATCH := CHECKFULLMATCH ( X , Y ) ;
     COUNT := COUNT - 1 ;
     while ( COUNT > 0 ) and not MATCH do
       begin
         EOFX := MOVECURR ( X ) ;
         COUNT := COUNT - 1 ;
         MATCH := CHECKFULLMATCH ( X , Y ) ;
       end (* while *) ;
     SEARCH := MATCH ;
   end (* SEARCH *) ;



procedure SUCHE_GLEICH ;

   var ADVANCEB : BOOLEAN ;
       MATCH : BOOLEAN ;

   begin (* SUCHE_GLEICH *)
     ADVANCEB := FALSE ;
     SF1 . CURR_SAVE := SF1 . CURR ;
     SF2 . CURR_SAVE := SF2 . CURR ;
     SF1 . CLINE_SAVE := SF1 . CLINE ;
     SF2 . CLINE_SAVE := SF2 . CLINE ;
     while TRUE do
       begin
         ADVANCEB := not ADVANCEB ;
         if ADVANCEB then
           begin
             MATCH := SEARCH ( SF1 , SF2 ) ;
           end (* then *)
         else
           begin
             MATCH := SEARCH ( SF2 , SF1 ) ;
           end (* else *) ;
         if MATCH then
           break ;
       end (* while *) ;
     REPORT ;
   end (* SUCHE_GLEICH *) ;



procedure SUCHE_UNGLEICH ;

   var MATCH : BOOLEAN ;
       EOFA : BOOLEAN ;
       EOFB : BOOLEAN ;

   begin (* SUCHE_UNGLEICH *)
     SF1 . CURR_SAVE := NIL ;
     SF2 . CURR_SAVE := NIL ;
     SF1 . CLINE_SAVE := - 1 ;
     SF2 . CLINE_SAVE := - 1 ;
     while TRUE do
       begin
         EOFA := MOVECURR ( SF1 ) ;
         EOFB := MOVECURR ( SF2 ) ;
         if EOFA and EOFB then
           break ;
         MARK ( SF1 ) ;
         MARK ( SF2 ) ;
         MATCH := COMPARE_LINE ;

     /**********************************/
     /*   Sequence Number merken       */
     /**********************************/

         if not MATCH then
           break ;
       end (* while *)
   end (* SUCHE_UNGLEICH *) ;



function COMPARE_FILES : BOOLEAN ;

   var MATCH : BOOLEAN ;
       DIFFERENT : BOOLEAN ;

   begin (* COMPARE_FILES *)
     MATCH := TRUE ;
     DIFFERENT := FALSE ;
     while TRUE do
       begin
         if MATCH then
           begin
             SUCHE_UNGLEICH ;
             MATCH := FALSE ;
           end (* then *)
         else
           begin
             DIFFERENT := TRUE ;
             SUCHE_GLEICH ;
             MATCH := TRUE ;
           end (* else *) ;
         if ( SF1 . CURR = NIL ) and ( SF2 . CURR = NIL ) then
           break ;
       end (* while *) ;
     COMPARE_FILES := DIFFERENT ;
   end (* COMPARE_FILES *) ;



function LTAB ( var SF : S_FANKER ; I : INTEGER ) : LINEPTR ;

//**********************************************************
// returns pointer to i-th element of table ltab
// inside s_fanker (if already allocated and if
// i inside allocated range, otherwise nil)
//**********************************************************


   begin (* LTAB *)
     if ( I < 1 ) or ( I > SF . LALLOC ) or ( SF . LTAB = NIL ) then
       LTAB := NIL
     else
       LTAB := PTRADD ( SF . LTAB , ( I - 1 ) * SIZEOF ( S_LINE ) )
   end (* LTAB *) ;



function LINEINDEX ( X : LINEPTR ; var SF : S_FANKER ) : INTEGER ;

//**********************************************************
// computes lineindex (1 to sf.lalloc) from
// value of passed pointer x
//**********************************************************


   var P : INTEGER ;

   begin (* LINEINDEX *)
     P := 0 ;
     if ( X <> NIL ) and ( SF . LTAB <> NIL ) then
       begin
         P := PTRDIFF ( X , SF . LTAB ) ;
         P := P DIV SIZEOF ( S_LINE ) ;
         P := P + 1 ;
         if ( P < 1 ) or ( P > SF . LALLOC ) then
           P := 0
       end (* then *) ;
     LINEINDEX := P
   end (* LINEINDEX *) ;



function READLINE_NEU ( var X : S_FANKER ; var OPT : S_OPTIONS ; LP :
                      LINEPTR ; LINENO_PARM : INTEGER ) : BOOLEAN ;

//**********************************************************
// read line from file (x) into ltab-element addressed
// by lp; the line gets the line number lineno_parm;
// returns true, if no line could be read (eof)
//**********************************************************


   var RC : INTEGER ;
       NEWLINE : LINEPTR ;
       L : INTEGER ;
       LAENGE : INTEGER ;
       GELESEN : BOOLEAN ;
       EOFX : BOOLEAN ;
       PPART1 : -> CHAR ( 254 ) ;
       CP : -> CHAR ;
       C : CHAR ;
       I : INTEGER ;
       INEU : INTEGER ;
       TEXT_NOBL : CHAR ( 254 ) ;
       CALT : CHAR ;
       SIG : INTEGER ;

   begin (* READLINE_NEU *)

     /************************************************/
     /*   Zeile einlesen binaer                      */
     /************************************************/

     if OPT . BINARY then
       begin

     /***********************/
     /* zunaechst weglassen */
     /***********************/

         GELESEN := FALSE
       end (* then *)

     /************************************************/
     /*   Zeile einlesen normal Text                 */
     /************************************************/

     else
       begin
         if X . FILEH = '1' then
           EOFX := EOF ( INFILE1 )
         else
           EOFX := EOF ( INFILE2 ) ;
         if not EOFX then
           begin
             with LP -> do
               begin
                 NEXT := NIL ;
                 LINENO := 0 ;
                 LEN_ORIG := 0 ;
                 if X . FILEH = '1' then
                   begin
                     READ ( INFILE1 , TEXT_ORIG ) ;
                     READLN ( INFILE1 ) ;
                   end (* then *)
                 else
                   begin
                     READ ( INFILE2 , TEXT_ORIG ) ;
                     READLN ( INFILE2 ) ;
                   end (* else *)
               end (* with *) ;
             GELESEN := TRUE
           end (* then *)
         else
           begin
             GELESEN := FALSE ;
           end (* else *) ;
       end (* else *) ;
     if GELESEN then
       begin

     //**************************************************
     // compute length by scanning for last
     // non-blank character in array text_orig
     //**************************************************

         LAENGE := MAXLEN ;
         while LAENGE > 0 do
           begin
             if LP -> . TEXT_ORIG [ LAENGE ] <> ' ' then
               break ;
             LAENGE := LAENGE - 1 ;
           end (* while *) ;
         with LP -> do
           begin
             LEN_ORIG := LAENGE ;
             LINENO := LINENO_PARM ;
             NEXT := NIL ;
             PREV := NIL ;
             L := OPT . COLEND ;
             if L > LAENGE then
               L := LAENGE ;

     //**************************************************
     // syntax error when applying substr
     // directly to text_orig
     // but it works, if applying to
     // overlaid ppart1 (of length 254)
     //**************************************************

             PPART1 := ADDR ( TEXT_ORIG ) ;
             TEXT_MOD := SUBSTR ( PPART1 -> , 1 , L ) ;
             LEN_MOD := LENGTH ( TEXT_MOD ) ;

     //**************************************************
     // if colstart > 1
     // move spaces to columns before colstart
     // caution: addr of string has to take care of
     // length fields
     //**************************************************

             L := OPT . COLSTART - 1 ;
             if L > LEN_MOD then
               L := LEN_MOD ;
             if L > 0 then
               begin
                 CP := PTRADD ( ADDR ( TEXT_MOD ) , 4 ) ;
                 MEMSET ( CP , ' ' , L ) ;
               end (* then *) ;

     //**************************************************
     // if ncolstart > 0
     // move spaces to columns between
     // ncolstart and ncolend
     // caution: addr of string has to take care of
     // length fields
     //**************************************************

             if OPT . NCOLSTART > 0 then
               begin
                 L := OPT . NCOLEND ;
                 if L > OPT . COLEND then
                   L := OPT . COLEND ;
                 if L > LEN_MOD then
                   L := LEN_MOD ;
                 L := L - OPT . NCOLSTART + 1 ;
                 if L > 0 then
                   begin
                     CP := PTRADD ( ADDR ( TEXT_MOD ) , 4 + OPT .
                           NCOLSTART - 1 ) ;
                     MEMSET ( CP , ' ' , L ) ;
                   end (* then *)
               end (* then *) ;

     //**************************************************
     // if opt.icase then convert all chars to lower case
     //**************************************************

             if OPT . ICASE then
               S_TOLOWER ( TEXT_MOD ) ;

     //**************************************************
     // if opt.icase then convert all chars to lower case
     //**************************************************

             if OPT . TRAIL then
               TEXT_MOD := RTRIM ( TEXT_MOD ) ;

     //**************************************************
     // if opt.while all spaces are irrelevant
     // needs maybe platform specific extensions
     // (tabs etc.)
     //**************************************************

             if OPT . WHITE then
               begin
                 TEXT_NOBL := ' ' ;
                 INEU := 0 ;
                 for I := 1 to LENGTH ( TEXT_MOD ) do
                   begin
                     C := TEXT_MOD [ I ] ;
                     if not ( C in [ ' ' , x'0d' ] ) then
                       begin
                         INEU := INEU + 1 ;
                         TEXT_NOBL [ INEU ] := C ;
                       end (* then *)
                   end (* for *) ;
                 TEXT_MOD := SUBSTR ( TEXT_NOBL , 1 , INEU ) ;
               end (* then *) ;

     //**************************************************
     // compute significance of line
     //**************************************************

             SIG := 0 ;
             CALT := x'00' ;
             for I := 1 to LENGTH ( TEXT_MOD ) do
               begin
                 C := TEXT_MOD [ I ] ;
                 if C in [ ' ' , x'0d' ] then
                   C := x'00' ;
                 if C > CALT then
                   SIG := SIG + ORD ( C ) - ORD ( CALT )
                 else
                   SIG := SIG + ORD ( CALT ) - ORD ( C ) ;
                 CALT := C
               end (* for *) ;
             SIGNIFIKANZ := SIG ;

     //**************************************************
     // initialize remaining fields
     //**************************************************

             PMATCH := NIL ;
             ERRTAG := ' ' ;
             PEQLINE := NIL ;
             NUMBEREQ := 0 ;
             REP_STATUS := 0 ;
           end (* with *) ;
       end (* then *) ;
     READLINE_NEU := not GELESEN ;
   end (* READLINE_NEU *) ;



procedure FILL_BUFFER ( var SF : S_FANKER ; var OPT : S_OPTIONS ) ;

   var P1 : LINEPTR ;
       P2 : LINEPTR ;
       ANZREAD : INTEGER ;
       I : INTEGER ;
       X : INTEGER ;
       ENDE : BOOLEAN ;

   begin (* FILL_BUFFER *)

     //************************************************
     // allocate ltab, if needed (one time)
     //************************************************

     if SF . LTAB = NIL then
       begin
         SF . LTAB := ALLOC ( OPT . BUFSIZE * SIZEOF ( S_LINE ) ) ;
         SF . LALLOC := OPT . BUFSIZE ;
         SF . LCOMPARED := 0 ;
         SF . FIRSTLNUM := 1 ;
         ANZREAD := OPT . BUFSIZE ;
         SF . LCOUNT := 0 ;
       end (* then *)

     //************************************************
     // otherwise shift compared part of buffer
     // to the beginning and set number of
     // lines to be read to fill buffer again
     // and position (sf.lcount)
     //************************************************

     else
       begin
         X := SF . LCOUNT - SF . LCOMPARED ;
         for I := 1 to X do
           begin
             P1 := LTAB ( SF , I ) ;
             P2 := LTAB ( SF , SF . LCOMPARED + I ) ;
             P1 -> := P2 ->
           end (* for *) ;
         SF . FIRSTLNUM := SF . FIRSTLNUM + SF . LCOMPARED ;
         SF . LCOMPARED := 0 ;
         ANZREAD := OPT . BUFSIZE - X ;
         SF . LCOUNT := X ;
       end (* else *) ;

     //************************************************
     // read loop
     // ended by break, if readline_neu returns eof
     //************************************************

     for I := 1 to ANZREAD do
       begin
         P1 := LTAB ( SF , SF . LCOUNT + 1 ) ;
         ENDE := READLINE_NEU ( SF , OPT , P1 , SF . FIRSTLNUM + I - 1
                 ) ;
         if ENDE then
           break ;
         SF . LCOUNT := SF . LCOUNT + 1 ;
       end (* for *) ;
   end (* FILL_BUFFER *) ;



function COMP_S_LINE ( P1 : VOIDPTR ; L1 : INTEGER ; P2 : VOIDPTR ; L2
                     : INTEGER ) : INTEGER ;

   var RC : INTEGER ;
       LP1 : LINEPTR ;
       LP2 : LINEPTR ;

   begin (* COMP_S_LINE *)
     RC := 1 ;
     LP1 := P1 ;
     LP2 := P2 ;
     RC := LP1 -> . SIGNIFIKANZ - LP2 -> . SIGNIFIKANZ ;
     if RC = 0 then
       begin
         RC := LP1 -> . LEN_MOD - LP2 -> . LEN_MOD ;
         if RC = 0 then
           begin
             if LP1 -> . TEXT_MOD > LP2 -> . TEXT_MOD then
               RC := 1
             else
               if LP1 -> . TEXT_MOD < LP2 -> . TEXT_MOD then
                 RC := - 1
               else
                 RC := 0
           end (* then *)
         else
           if RC > 0 then
             RC := 1
           else
             RC := - 1
       end (* then *)
     else
       if RC > 0 then
         RC := 1
       else
         RC := - 1 ;
     COMP_S_LINE := RC ;
   end (* COMP_S_LINE *) ;



function COMPARE_BUFFERS ( var SF1 : S_FANKER ; var SF2 : S_FANKER ;
                         var OPT : S_OPTIONS ; var PBAUM : VOIDPTR ;
                         var MATCHV : MATCHPTR ) : BOOLEAN ;

   type TPINT = -> INTEGER ;
        TPPINT = -> TPINT ;

   var P : LINEPTR ;
       P2 : LINEPTR ;
       I : INTEGER ;
       X : INTEGER ;
       HCHANGED : BOOLEAN ;
       POBJ : VOIDPTR ;
       POBJLEN : VOIDPTR ;
       GEFUNDEN : BOOLEAN ;
       PELEMENT : VOIDPTR ;
       PPM : -> MATCHPTR ;
       PM : MATCHPTR ;
       PI : -> INTEGER ;
       DIFF : BOOLEAN ;
       X1SUM : INTEGER ;
       X2SUM : INTEGER ;
       X1 : INTEGER ;
       X2 : INTEGER ;
       PSAVE : LINEPTR ;
       P2SAVE : LINEPTR ;
       FOUND1 : BOOLEAN ;
       MATCH_USED : INTEGER ;

   begin (* COMPARE_BUFFERS *)

     //************************************************
     // alloc vektor of 2 * bufsize of s_match
     //************************************************

     MATCHV := ALLOC ( 2 * OPT . BUFSIZE * SIZEOF ( S_MATCH ) ) ;
     MATCH_USED := 0 ;

     //************************************************
     // build AVL tree to find unique lines
     //************************************************

     PBAUM := NIL ;

     //************************************************
     // enter lines from file 1 into AVL tree
     // because object is not allocated and needs not
     // be freed with avl tree, objlen must be set to
     // zero in not found case
     //************************************************

     X := SF1 . LCOUNT ;
     for I := 1 to X do
       begin
         P := LTAB ( SF1 , I ) ;
         HCHANGED := FALSE ;
         PELEMENT := AVLSRCH ( P , 0 , POBJ , POBJLEN , GEFUNDEN ,
                     PBAUM , HCHANGED , TRUE , COMP_S_LINE ) ;
         if GEFUNDEN then
           begin
             PPM := POBJ ;
             PM := PPM -> ;
             PM -> . COUNT_FILE1 := PM -> . COUNT_FILE1 + 1 ;
             PM -> . LP1 := P ;
             P -> . PMATCH := PM ;
           end (* then *)
         else
           begin
             PM := PTRADD ( MATCHV , MATCH_USED * SIZEOF ( S_MATCH ) )
                   ;
             MATCH_USED := MATCH_USED + 1 ;
             PM -> . COUNT_FILE1 := 1 ;
             PM -> . COUNT_FILE2 := 0 ;
             PM -> . LP1 := P ;
             PM -> . LP2 := NIL ;
             P -> . PMATCH := PM ;
             PPM := POBJ ;
             PPM -> := PM ;
             PI := POBJLEN ;
             PI -> := 0
           end (* else *)
       end (* for *) ;

     //************************************************
     // enter lines from file 2 into AVL tree
     // because object is not allocated and needs not
     // be freed with avl tree, objlen must be set to
     // zero in not found case
     //************************************************

     X := SF2 . LCOUNT ;
     for I := 1 to X do
       begin
         P := LTAB ( SF2 , I ) ;
         HCHANGED := FALSE ;
         PELEMENT := AVLSRCH ( P , 0 , POBJ , POBJLEN , GEFUNDEN ,
                     PBAUM , HCHANGED , TRUE , COMP_S_LINE ) ;
         if GEFUNDEN then
           begin
             PPM := POBJ ;
             PM := PPM -> ;
             PM -> . COUNT_FILE2 := PM -> . COUNT_FILE2 + 1 ;
             PM -> . LP2 := P ;
             P -> . PMATCH := PM ;
           end (* then *)
         else
           begin
             PM := PTRADD ( MATCHV , MATCH_USED * SIZEOF ( S_MATCH ) )
                   ;
             MATCH_USED := MATCH_USED + 1 ;
             PM -> . COUNT_FILE2 := 1 ;
             PM -> . COUNT_FILE1 := 0 ;
             PM -> . LP2 := P ;
             PM -> . LP1 := NIL ;
             P -> . PMATCH := PM ;
             PPM := POBJ ;
             PPM -> := PM ;
             PI := POBJLEN ;
             PI -> := 0
           end (* else *)
       end (* for *) ;

     //************************************************
     // for all line pairs that have count = 1 on
     // both sides, match lines - and check if
     // neighbor lines match, too
     //************************************************

     X := SF1 . LCOUNT ;
     for I := 1 to X do
       begin
         P := LTAB ( SF1 , I ) ;
         PM := P -> . PMATCH ;
         if ( PM -> . COUNT_FILE1 = 1 ) and ( PM -> . COUNT_FILE2 = 1 )
         then
           begin
             P2 := PM -> . LP2 ;
             P -> . PEQLINE := P2 ;
             P2 -> . PEQLINE := P ;
             DIFF := FALSE ;
             while not DIFF do
               begin
                 P := PTRADD ( P , - SIZEOF ( S_LINE ) ) ;
                 P2 := PTRADD ( P2 , - SIZEOF ( S_LINE ) ) ;
                 if P -> . PEQLINE <> NIL then
                   break ;
                 if PTRDIFF ( P , SF1 . LTAB ) < 0 then
                   begin
                     DIFF := TRUE ;
                     break
                   end (* then *) ;
                 if PTRDIFF ( P2 , SF2 . LTAB ) < 0 then
                   begin
                     DIFF := TRUE ;
                     break
                   end (* then *) ;
                 if COMP_S_LINE ( P , 0 , P2 , 0 ) <> 0 then
                   begin
                     DIFF := TRUE ;
                     break
                   end (* then *) ;
                 P -> . PEQLINE := P2 ;
                 P2 -> . PEQLINE := P ;
               end (* while *) ;
             P := PM -> . LP1 ;
             P2 := PM -> . LP2 ;
             DIFF := FALSE ;
             while not DIFF do
               begin
                 P := PTRADD ( P , SIZEOF ( S_LINE ) ) ;
                 P2 := PTRADD ( P2 , SIZEOF ( S_LINE ) ) ;
                 if P -> . PEQLINE <> NIL then
                   break ;
                 if PTRDIFF ( P , SF1 . LTAB ) >= SF1 . LCOUNT * SIZEOF
                 ( S_LINE ) then
                   begin
                     DIFF := TRUE ;
                     break
                   end (* then *) ;
                 if PTRDIFF ( P2 , SF2 . LTAB ) >= SF2 . LCOUNT *
                 SIZEOF ( S_LINE ) then
                   begin
                     DIFF := TRUE ;
                     break
                   end (* then *) ;
                 if COMP_S_LINE ( P , 0 , P2 , 0 ) <> 0 then
                   begin
                     DIFF := TRUE ;
                     break
                   end (* then *) ;
                 P -> . PEQLINE := P2 ;
                 P2 -> . PEQLINE := P ;
               end (* while *) ;
           end (* then *)
       end (* for *) ;

     //************************************************
     // look for really matching line pairs
     // mark others as "moved"
     //************************************************

     X1 := SF1 . LCOUNT ;
     SF1 . IXMAX := 0 ;
     X2 := SF2 . LCOUNT ;
     SF2 . IXMAX := 0 ;
     while TRUE do
       begin
         P := LTAB ( SF1 , X1 ) ;
         while TRUE do
           begin
             P2 := P -> . PEQLINE ;
             if P2 <> NIL then
               if LINEINDEX ( P2 , SF2 ) <= X2 then
                 break ;
             X1 := X1 - 1 ;
             if X1 = 0 then
               break ;
             P := LTAB ( SF1 , X1 ) ;
           end (* while *) ;
         if X1 = 0 then
           break ;

     //************************************************************
     // WRITELN ( 'match 1: ' , X1 , LINEINDEX ( P2 , SF2 ) ) ;
     //************************************************************

         X1SUM := X1 + LINEINDEX ( P2 , SF2 ) ;
         PSAVE := P ;
         P2SAVE := P2 ;
         P2 := LTAB ( SF2 , X2 ) ;
         while TRUE do
           begin
             P := P2 -> . PEQLINE ;
             if P <> NIL then
               if LINEINDEX ( P , SF1 ) <= X1 then
                 break ;
             X2 := X2 - 1 ;
             if X2 = 0 then
               break ;
             P2 := LTAB ( SF2 , X2 ) ;
           end (* while *) ;
         if X2 = 0 then
           break ;

     //************************************************************
     // WRITELN ( 'match 2: ' , LINEINDEX ( P , SF1 ) , X2 ) ;
     //************************************************************

         X2SUM := X2 + LINEINDEX ( P , SF1 ) ;
         if X1SUM > X2SUM then
           begin
             P := PSAVE ;
             P2 := P2SAVE ;
           end (* then *) ;
         if SF1 . IXMAX = 0 then
           SF1 . IXMAX := LINEINDEX ( P , SF1 ) ;
         if SF2 . IXMAX = 0 then
           SF2 . IXMAX := LINEINDEX ( P2 , SF2 ) ;
         P -> . ERRTAG := '===' ;
         P2 -> . ERRTAG := '===' ;

     //************************************************************
     // WRITELN ( 'tag eq : ' , LINEINDEX ( P , SF1 ) ,
     //           LINEINDEX ( P2 , SF2 ) ) ;
     //************************************************************

         while TRUE do
           begin
             P := PTRADD ( P , - SIZEOF ( S_LINE ) ) ;
             P2 := PTRADD ( P2 , - SIZEOF ( S_LINE ) ) ;
             if PTRDIFF ( P , SF1 . LTAB ) < 0 then
               begin
                 X1 := 0 ;
                 break
               end (* then *) ;
             if PTRDIFF ( P2 , SF2 . LTAB ) < 0 then
               begin
                 X2 := 0 ;
                 break
               end (* then *) ;
             if P -> . PEQLINE <> P2 then
               begin
                 X1 := LINEINDEX ( P , SF1 ) ;
                 X2 := LINEINDEX ( P2 , SF2 ) ;
                 break
               end (* then *) ;
             P -> . ERRTAG := '===' ;
             P2 -> . ERRTAG := '===' ;

     //************************************************************
     // WRITELN ( 'tag eq : ' , LINEINDEX ( P , SF1 ) ,
     //           LINEINDEX ( P2 , SF2 ) ) ;
     //************************************************************

           end (* while *) ;
         if ( X1 = 0 ) or ( X2 = 0 ) then
           break ;
       end (* while *) ;
     if ( SF1 . IXMAX = 0 ) or ( SF2 . IXMAX = 0 ) then
       begin
         WRITELN (
             '+++ Keine Uebereinstimmung gefunden bei COMPARE_BUFFERS'
                   ) ;
         EXIT ( 16 ) ;
       end (* then *) ;

     //************************************************
     // lines that are isolated on one side
     // must be insertions or deletions
     //************************************************
     // lines that match but have no === tag so far
     // must be moves
     //************************************************

     for X1 := 1 to SF1 . IXMAX do
       begin
         P := LTAB ( SF1 , X1 ) ;
         P2 := P -> . PEQLINE ;
         if P2 <> NIL then
           if P -> . ERRTAG = ' ' then
             P -> . ERRTAG := 'MOV' ;
       end (* for *) ;
     for X2 := 1 to SF2 . IXMAX do
       begin
         P2 := LTAB ( SF2 , X2 ) ;
         P := P2 -> . PEQLINE ;
         if P <> NIL then
           if P2 -> . ERRTAG = ' ' then
             P2 -> . ERRTAG := 'MOV' ;
       end (* for *) ;
     COMPARE_BUFFERS := FALSE ;

     //************************************************
     // free avl tree
     //************************************************

     if TRUE then
       AVLFREE ( PBAUM ) ;
     PBAUM := NIL ;
     FREE ( MATCHV ) ;
     MATCHV := NIL ;
   end (* COMPARE_BUFFERS *) ;



procedure FREE_BUFFERS ( var SF1 : S_FANKER ; var SF2 : S_FANKER ; var
                       OPT : S_OPTIONS ; var PBAUM : VOIDPTR ; var
                       MATCHV : MATCHPTR ) ;

   begin (* FREE_BUFFERS *)

     //************************************************
     // sets different to false
     // sets compared to count (all lines compared)
     //************************************************

     SF1 . LCOMPARED := SF1 . IXMAX - OPT . ENVIRON ;
     SF2 . LCOMPARED := SF2 . IXMAX - OPT . ENVIRON ;
   end (* FREE_BUFFERS *) ;



procedure SHOW_DIFFS ( var SF1 : S_FANKER ; var SF2 : S_FANKER ; var
                     OPT : S_OPTIONS ) ;

   var P : LINEPTR ;
       P2 : LINEPTR ;
       X1 : INTEGER ;
       X2 : INTEGER ;
       FOUND1 : BOOLEAN ;
       FOUND2 : BOOLEAN ;

   const LINE1 : CHAR ( 64 ) =
    '================================================================'
         ;
         LINE2 : CHAR ( 64 ) =
    '----------------------------------------------------------------'
         ;

   begin (* SHOW_DIFFS *)

     //************************************************
     // for the moment only shows the buffer
     // does no compare
     //************************************************

     X1 := 1 ;
     X2 := 1 ;
     while TRUE do
       begin
         if ( X1 > SF1 . IXMAX ) and ( X2 > SF2 . IXMAX ) then
           break ;
         if X1 <= SF1 . IXMAX then
           P := LTAB ( SF1 , X1 )
         else
           P := NIL ;
         if X2 <= SF2 . IXMAX then
           P2 := LTAB ( SF2 , X2 )
         else
           P2 := NIL ;
         FOUND1 := FALSE ;
         if P <> NIL then
           if P -> . ERRTAG <> '===' then
             FOUND1 := TRUE ;
         FOUND2 := FALSE ;
         if P2 <> NIL then
           if P2 -> . ERRTAG <> '===' then
             FOUND2 := TRUE ;
         if not FOUND1 and not FOUND2 then
           begin
             X1 := X1 + 1 ;
             X2 := X2 + 1 ;
             continue
           end (* then *) ;
         WRITELN ;
         WRITELN ( LINE1 ) ;
         while TRUE do
           begin
             if P = NIL then
               break ;
             if P -> . ERRTAG = '===' then
               break ;
             if P -> . ERRTAG <> ' ' then
               REPORT_LINE ( OPT . NEWKENNUNG , P -> . LINENO , P -> .
                             ERRTAG , P -> . TEXT_ORIG , P -> .
                             LEN_ORIG , OPT . LIMITS )
             else
               if FOUND2 then
                 REPORT_LINE ( OPT . NEWKENNUNG , P -> . LINENO , 'CHG'
                               , P -> . TEXT_ORIG , P -> . LEN_ORIG ,
                               OPT . LIMITS )
               else
                 REPORT_LINE ( OPT . NEWKENNUNG , P -> . LINENO , 'INS'
                               , P -> . TEXT_ORIG , P -> . LEN_ORIG ,
                               OPT . LIMITS ) ;
             X1 := X1 + 1 ;
             if X1 <= SF1 . IXMAX then
               P := LTAB ( SF1 , X1 )
             else
               P := NIL ;
           end (* while *) ;
         if FOUND1 and FOUND2 then
           WRITELN ( LINE2 ) ;
         while TRUE do
           begin
             if P2 = NIL then
               break ;
             if P2 -> . ERRTAG = '===' then
               break ;
             if P2 -> . ERRTAG <> ' ' then
               REPORT_LINE ( OPT . OLDKENNUNG , P2 -> . LINENO , P2 ->
                             . ERRTAG , P2 -> . TEXT_ORIG , P2 -> .
                             LEN_ORIG , OPT . LIMITS )
             else
               if FOUND1 then
                 REPORT_LINE ( OPT . OLDKENNUNG , P2 -> . LINENO ,
                               'CHG' , P2 -> . TEXT_ORIG , P2 -> .
                               LEN_ORIG , OPT . LIMITS )
               else
                 REPORT_LINE ( OPT . OLDKENNUNG , P2 -> . LINENO ,
                               'DEL' , P2 -> . TEXT_ORIG , P2 -> .
                               LEN_ORIG , OPT . LIMITS ) ;
             X2 := X2 + 1 ;
             if X2 <= SF1 . IXMAX then
               P2 := LTAB ( SF2 , X2 )
             else
               P2 := NIL ;
           end (* while *) ;
       end (* while *) ;
   end (* SHOW_DIFFS *) ;



function COMPARE_FILES_NEU ( var SF1 : S_FANKER ; var SF2 : S_FANKER ;
                           var OPT : S_OPTIONS ) : BOOLEAN ;

   var MATCH : BOOLEAN ;
       DIFFERENT : BOOLEAN ;
       EOF1 : BOOLEAN ;
       EOF2 : BOOLEAN ;
       DIFF : BOOLEAN ;
       PBAUM : VOIDPTR ;
       MATCHV : MATCHPTR ;

   begin (* COMPARE_FILES_NEU *)
     DIFFERENT := FALSE ;

     //************************************************
     // different is false at the beginning
     // fill buffers again and again
     // until there are no more lines
     // compare buffers and logical or the results
     //************************************************

     repeat
       FILL_BUFFER ( SF1 , OPT ) ;
       FILL_BUFFER ( SF2 , OPT ) ;
       if ( SF1 . LCOUNT = 0 ) and ( SF2 . LCOUNT = 0 ) then
         break ;
       DIFF := COMPARE_BUFFERS ( SF1 , SF2 , OPT , PBAUM , MATCHV ) ;
       DIFFERENT := DIFFERENT or DIFF ;
       SHOW_DIFFS ( SF1 , SF2 , OPT ) ;
       FREE_BUFFERS ( SF1 , SF2 , OPT , PBAUM , MATCHV ) ;
     until FALSE ;
     COMPARE_FILES_NEU := DIFFERENT ;
   end (* COMPARE_FILES_NEU *) ;



procedure ERROR ( ERRNO : INTEGER ) ;

   begin (* ERROR *)
     case ERRNO of
       1 : WRITELN ( '+++ Falsches Argument (beginnt nicht mit Minus)'
                     ) ;
       2 : WRITELN ( '+++ Unbekannte Option' ) ;
       3 : WRITELN ( '+++ Falsches Zeichen in Option' ) ;
       4 : WRITELN ( '+++ Nur eine Suboption (Zahl) erlaubt' ) ;
       5 : WRITELN ( '+++ Zwei mit Komma getrennte Zahlen erforderlich'
                     ) ;
     end (* case *) ;
     PARM_FEHLER := TRUE ;
   end (* ERROR *) ;



procedure CHKPARM ( PARMLENGTH : INTEGER ; PARMSTRING : OSPARM_TYPE ;
                  var OPT : S_OPTIONS ) ;

//*****************************************************
//   Parameter abarbeiten
//   fuer einzelne Parameter Prozedur CHKPARM2
//   aufrufen
//*****************************************************
//   siehe Tabelle der Keywords
//   Keywords werden in KW-Tags uebersetzt, die dann
//   in case-Statement benutzt werden koennen
//*****************************************************


   var I : INTEGER ;
       INPARM : BOOLEAN ;
       CH : CHAR ;
       PARM : OSPARM_TYPE ;
       X : INTEGER ;

   const ANZKEYWORDS = 10 ;
         PARMKEYWORDS : array [ 1 .. ANZKEYWORDS ] of STRING ( 20 ) =
         ( 'TAGNEW=' ,        // tag for new file (3 letters)
           'TAGOLD=' ,        // tag for old file
           'INPMODE=' ,       // b or t (binary or text)
           'COLS=' ,          // cols for comparison (two integers)
           'IGNCOLS=' ,       // cols to ignore (two integers)
           'ENV=' ,           // environment to show (number of lines)
           'BUFSIZE=' ,       // bufsize (number of lines)
           'IGNCASE=' ,       // y if case is to be ignored
           'IGNTRAILB=' ,     // y if trailing blanks should be ignored
           'IGNWHITE=' ) ;    // y if white space is to be ignored
         PARMKEYTAGS : array [ 1 .. ANZKEYWORDS ] of CHAR =
         '12MCXEBITW' ;


   procedure CHKPARM2 ( PARM : OSPARM_TYPE ; var OPT : S_OPTIONS ) ;

      var I : INTEGER ;
          KWTAG : CHAR ;
          POS : INTEGER ;


      procedure READPARM ( PARM : OSPARM_TYPE ; ANZAHL : INTEGER ; var
                         ERG1 : INTEGER ; var ERG2 : INTEGER ) ;

         var CP : -> CHAR ;
             CH : CHAR ;
             WERT1 : INTEGER ;
             WERT2 : INTEGER ;
             WERTFELD : INTEGER ;

         begin (* READPARM *)
           WERT1 := 0 ;
           WERT2 := 0 ;
           CP := ADDR ( PARM [ 1 ] ) ;
           WERTFELD := 1 ;
           while CP -> <> ' ' do
             begin
               CH := CP -> ;
               case CH of
                 '0' .. '9' :
                   begin
                     if WERTFELD = 1 then
                       WERT1 := WERT1 * 10 + ORD ( CH ) - ORD ( '0' )
                     else
                       WERT2 := WERT2 * 10 + ORD ( CH ) - ORD ( '0' )
                   end (* tag/ca *) ;
                 ',' : if ANZAHL = 1 then
                         ERROR ( 4 )
                       else
                         WERTFELD := 2 ;
                 otherwise
                   ERROR ( 3 )
               end (* case *) ;
               CP := PTRADD ( CP , 1 ) ;
             end (* while *) ;
           if ANZAHL = 2 then
             if WERTFELD = 1 then
               ERROR ( 5 ) ;
           ERG1 := WERT1 ;
           if ANZAHL = 2 then
             ERG2 := WERT2 ;
         end (* READPARM *) ;


      function IS_YES ( C : CHAR ) : BOOLEAN ;

         begin (* IS_YES *)
           case C of
             'J' : IS_YES := TRUE ;
             'j' : IS_YES := TRUE ;
             'Y' : IS_YES := TRUE ;
             'y' : IS_YES := TRUE ;
             otherwise
               IS_YES := FALSE
           end (* case *)
         end (* IS_YES *) ;


      begin (* CHKPARM2 *)
        KWTAG := ' ' ;

        //*********************************************
        // translate keywords to kw-tags
        // which can be used in subsequent case stmt
        //*********************************************

        for I := 1 to ANZKEYWORDS do
          begin
            if SUBSTR ( PARM , 1 , LENGTH ( PARMKEYWORDS [ I ] ) ) =
            PARMKEYWORDS [ I ] then
              begin
                KWTAG := PARMKEYTAGS [ I ] ;
                POS := LENGTH ( PARMKEYWORDS [ I ] ) + 1 ;
                break ;
              end (* then *) ;
          end (* for *) ;

        //*********************************************
        // depending on kw-tag:
        // parse parameter values
        // the parameter values start at offset pos
        //*********************************************

        case KWTAG of
          'I' : OPT . ICASE := IS_YES ( PARM [ POS ] ) ;
          'T' : OPT . TRAIL := IS_YES ( PARM [ POS ] ) ;
          'W' : OPT . WHITE := IS_YES ( PARM [ POS ] ) ;
          'M' : OPT . BINARY := ( PARM [ POS ] = 'B' ) or ( PARM [ POS
                                ] = 'b' ) ;
          'C' : begin
                  PARM := SUBSTR ( PARM , POS , SIZEOF ( PARM ) - POS +
                          1 ) ;
                  READPARM ( PARM , 2 , OPT . COLSTART , OPT . COLEND )
                             ;
                  WRITELN ( 'eingelesen: colstart  = ' , OPT . COLSTART
                            ) ;
                  WRITELN ( 'eingelesen: colend    = ' , OPT . COLEND )
                            ;
                end (* tag/ca *) ;
          'X' : begin
                  PARM := SUBSTR ( PARM , POS , SIZEOF ( PARM ) - POS +
                          1 ) ;
                  READPARM ( PARM , 2 , OPT . NCOLSTART , OPT . NCOLEND
                             ) ;
                  WRITELN ( 'eingelesen: ncolstart = ' , OPT .
                            NCOLSTART ) ;
                  WRITELN ( 'eingelesen: ncolend   = ' , OPT . NCOLEND
                            ) ;
                end (* tag/ca *) ;
          'E' : begin
                  PARM := SUBSTR ( PARM , POS , SIZEOF ( PARM ) - POS +
                          1 ) ;
                  READPARM ( PARM , 1 , OPT . ENVIRON , OPT . ENVIRON )
                             ;
                end (* tag/ca *) ;
          'B' : begin
                  PARM := SUBSTR ( PARM , POS , SIZEOF ( PARM ) - POS +
                          1 ) ;
                  READPARM ( PARM , 1 , OPT . BUFSIZE , OPT . BUFSIZE )
                             ;
                  WRITELN ( 'eingelesen: bufsize   = ' , OPT . BUFSIZE
                            ) ;
                end (* tag/ca *) ;
          otherwise
            ERROR ( 2 )
        end (* case *) ;
      end (* CHKPARM2 *) ;


   begin (* CHKPARM *)
     I := 1 ;
     INPARM := FALSE ;

     //************************************************
     // extract keyword parameters from parm string
     // and call CHKPARM2 for every single keyword parm
     //************************************************

     while I <= PARMLENGTH do
       begin
         CH := PARMSTRING [ I ] ;
         if INPARM then
           begin
             if CH = ' ' then
               begin
                 INPARM := FALSE ;
                 CHKPARM2 ( PARM , OPT ) ;
               end (* then *)
             else
               begin
                 X := X + 1 ;
                 PARM [ X ] := TOUPPER ( CH ) ;
               end (* else *) ;
             I := I + 1 ;
           end (* then *)
         else
           begin
             if CH = ' ' then
               begin
                 I := I + 1 ;
                 continue
               end (* then *) ;
             INPARM := TRUE ;
             X := 1 ;
             PARM := ' ' ;
             PARM [ 1 ] := TOUPPER ( CH ) ;
             I := I + 1 ;
           end (* else *)
       end (* while *) ;

     //************************************************
     // call CHKPARM2 one more time at the end
     // if there is another keyword parm
     //************************************************

     if INPARM then
       CHKPARM2 ( PARM , OPT ) ;
   end (* CHKPARM *) ;



begin (* HAUPTPROGRAMM *)
  TRACE := FALSE ;
  PARM_FEHLER := FALSE ;
  FCB1 := NIL ;
  FCB2 := NIL ;
  WRITELN ;
  WRITELN ( VERSION ) ;
  WRITELN ( 'Vergleich Datei 1 <<< ' , 'mit Datei 2 >>>' ) ;

  /*****************************************/
  /* moegliche Erweiterung:                */
  /* Standardfunktion zur typgerechten     */
  /* Initialisierung einer Struktur        */
  /*****************************************/

  OPT . WHITE := FALSE ;
  OPT . TRAIL := FALSE ;
  OPT . BINARY := FALSE ;
  OPT . ICASE := FALSE ;
  OPT . LIMITS := FALSE ;
  OPT . COLSTART := 1 ;
  OPT . COLEND := MAXCOLEND ;
  OPT . NCOLSTART := - 1 ;
  OPT . NCOLEND := - 1 ;
  OPT . MINMATCH := 2 ;
  OPT . ENVIRON := 0 ;
  OPT . BUFSIZE := 1000 ;
  OPT . NEWKENNUNG := '<<<' ;
  OPT . OLDKENNUNG := '>>>' ;

  /********************************************************/
  /*   Testen bzw. Erweiterung                            */
  /*   Command Line Options abarbeiten                    */
  /*   siehe Coding aus XCOMP.C                           */
  /********************************************************/
  /*   Achtung bei MVS:                                   */
  /*   der OSPARM ist tatsaechlich physisch nur so        */
  /*   lang wie PLENGTH angibt, also muss er in ein       */
  /*   Hilfsfeld kopiert werden (zeichenweise);           */
  /*   weiterarbeiten dann mit dem Hilfsfeld              */
  /********************************************************/

  if OSPARM <> NIL then
    begin
      with OSPARM -> do
        begin
          WRITELN ( 'Eingelesene Parameter: ' ) ;
          WRITELN ( 'parm: length = ' , PLENGTH : 3 ) ;
          PARMSTRING := ' ' ;
          WRITE ( 'parm: <' ) ;
          for X := 1 to PLENGTH do
            begin
              WRITE ( PSTRING [ X ] ) ;
              PARMSTRING [ X ] := PSTRING [ X ] ;
            end (* for *) ;
          WRITELN ( '>' ) ;
          CHKPARM ( PLENGTH , PARMSTRING , OPT ) ;
        end (* with *) ;
    end (* then *)
  else
    WRITELN ( 'parm: osparm is nil' ) ;
  if PARM_FEHLER then
    EXIT ( 8 ) ;

  //***************************************************
  //   hier geht der eigentliche Vergleich los
  //   old variant is compare_files
  //   new variant is compare_files_neu
  //***************************************************

  INITFANKER ( SF1 , 1 ) ;
  INITFANKER ( SF2 , 2 ) ;
  if FALSE then
    DIFFERENT := COMPARE_FILES
  else
    DIFFERENT := COMPARE_FILES_NEU ( SF1 , SF2 , OPT ) ;
  if not DIFFERENT then
    begin
      WRITELN ( 'Datei 1 und Datei 2 sind identisch.' ) ;
    end (* then *) ;
  CHKHEAP ( 0 ) ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.TESTPGM.CNTL                         MEMB DOWNLOAD EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CL DOWNLOAD',CLASS=A,MSGCLASS=X,               00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000300
//********************************************************************  00000400
//* Test compiler                                                       00000500
//********************************************************************  00000600
//*                                                                     00000700
//COMP    EXEC PASNCL,MEM=DOWNLOAD,                                     00000800
//        SRC='PASCALN.TESTPGM.PAS',                                    00000900
//        MOD='PASCALN.TESTPGM.LOAD'                                    00001000
//*                                                                     00001100
++FILE PASCALN.TESTPGM.CNTL                         MEMB DRUCK    EXT JOB HEX -
//PASCALND JOB (PASCAL),'PASCAL COMPILE',CLASS=A,MSGCLASS=X,            00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000300
//DRUCK    EXEC PGM=IEBGENER                                            00000400
//SYSPRINT DD  DUMMY                                                    00000500
//SYSIN    DD  *                                                        00000604
//SYSUT1   DD  DISP=SHR,DSN=SYS2.PROCLIB(PASNCLG)                       00000705
//SYSUT1X  DD  DISP=SHR,DSN=SYS2.PROCLIB(PASNC)                         00000805
//         DD  DISP=SHR,DSN=SYS2.PROCLIB(PASNCG)                        00000902
//         DD  DISP=SHR,DSN=SYS2.PROCLIB(PASNCL)                        00001002
//         DD  DISP=SHR,DSN=SYS2.PROCLIB(PASNCLG)                       00001102
//         DD  DISP=SHR,DSN=SYS2.PROCLIB(PASNCOMP)                      00001201
//         DD  DISP=SHR,DSN=SYS2.PROCLIB(PASNLINK)                      00001301
//         DD  DISP=SHR,DSN=SYS2.PROCLIB(PASNCLNK)                      00001401
//SYSUT2   DD  SYSOUT=A                                                 00001500
++FILE PASCALN.TESTPGM.CNTL                         MEMB DUMPJOB  EXT JOB HEX -
//DUMP   EXEC  PGM=DSSDUMP
//SYSPRINT DD  SYSOUT=*
//TAPE     DD  UNIT=TAPE,VOL=SER=PASCAL,DSN=PASCALN.DSSDUMP,
//         DISP=(,KEEP),LABEL=(1,SL)
//SYSIN    DD  *
INCLUDE PASCALN.
/*
++FILE PASCALN.TESTPGM.CNTL                         MEMB ENCOD001 EXT JOB HEX -
//PASCALN3 JOB (PASCAL),                                                00000100
//             'ENCOD PASCAL1',                                         00000200
//             CLASS=A,                                                 00000300
//             MSGCLASS=X,                                              00000400
//             TIME=1440,REGION=0M,
//             MSGLEVEL=(1,1)                                           00000600
//********************************************************************  00000700
//*                                                                     00000800
//* Job to ENCODE first pass of Pascal compiler                         00000900
//*                                                                     00001000
//********************************************************************  00001100
//ENCODE1  EXEC PASCG,PARM.GO='//STACK=8400K'                           00001200
//COMPILE.SYSIN DD DISP=SHR,DSN=PASCALN.COMPILER.PAS(ENCOD)             00001300
//GO.INPUT  DD DISP=SHR,DSN=PASCALN.COMPILER.DECOD(PASCAL1)             00001400
//GO.OUTPUT DD DISP=SHR,DSN=PASCALN.COMPILER.TEXT(PASCAL1)              00001500
++FILE PASCALN.TESTPGM.CNTL                         MEMB ENCOD002 EXT JOB HEX -
//PASCALN3 JOB (PASCAL),                                                00000100
//             'ENCOD PASCAL1',                                         00000200
//             CLASS=A,                                                 00000300
//             MSGCLASS=X,                                              00000400
//             TIME=1440,REGION=0M,
//             MSGLEVEL=(1,1)                                           00000600
//********************************************************************  00000700
//*                                                                     00000800
//* Job to ENCODE first pass of Pascal compiler                         00000900
//*                                                                     00001000
//********************************************************************  00001100
//ENCODE1  EXEC PASCG,PARM.GO='//STACK=8400K'                           00001200
//COMPILE.SYSIN DD DISP=SHR,DSN=PASCALN.COMPILER.PAS(ENCOD)             00001300
//GO.INPUT  DD DISP=SHR,DSN=PASCALN.COMPILER.DECOD(PASCAL2)             00001400
//GO.OUTPUT DD DISP=SHR,DSN=PASCALN.COMPILER.TEXT(PASCAL2)              00001500
++FILE PASCALN.TESTPGM.CNTL                         MEMB ENCOD003 EXT JOB HEX -
//PASCALN3 JOB (PASCAL),                                                00000100
//             'ENCOD PASCAL1',                                         00000200
//             CLASS=A,                                                 00000300
//             MSGCLASS=X,                                              00000400
//             TIME=1440,REGION=0M,
//             MSGLEVEL=(1,1)                                           00000600
//********************************************************************  00000700
//*                                                                     00000800
//* Job to ENCODE first pass of Pascal compiler                         00000900
//*                                                                     00001000
//********************************************************************  00001100
//ENCODE1  EXEC PASCG,PARM.GO='//STACK=8400K'                           00001200
//COMPILE.SYSIN DD DISP=SHR,DSN=PASCALN.COMPILER.PAS(ENCOD)             00001300
//GO.INPUT  DD DISP=SHR,DSN=PASCALN.COMPILER.DECOD(PASLIBX)             00001400
//GO.OUTPUT DD DISP=SHR,DSN=PASCALN.COMPILER.TEXT(PASLIBX)              00001500
++FILE PASCALN.TESTPGM.CNTL                         MEMB ENCOD004 EXT JOB HEX -
//PASCALN3 JOB (PASCAL),                                                00000100
//             'ENCOD PASCAL1',                                         00000200
//             CLASS=A,                                                 00000300
//             MSGCLASS=X,                                              00000400
//             TIME=1440,REGION=0M,
//             MSGLEVEL=(1,1)                                           00000600
//********************************************************************  00000700
//*                                                                     00000800
//* Job to ENCODE first pass of Pascal compiler                         00000900
//*                                                                     00001000
//********************************************************************  00001100
//ENCODE1  EXEC PASCG,PARM.GO='//STACK=8400K'                           00001200
//COMPILE.SYSIN DD DISP=SHR,DSN=PASCALN.COMPILER.PAS(ENCOD)             00001300
//GO.INPUT  DD DISP=SHR,DSN=PASCALN.COMPILER.DECOD(PASUTILS)            00001400
//GO.OUTPUT DD DISP=SHR,DSN=PASCALN.COMPILER.TEXT(PASUTILS)             00001500
++FILE PASCALN.TESTPGM.CNTL                         MEMB ENCOD005 EXT JOB HEX -
//PASCALNG JOB (PASCAL),'ENCOD OBJECT',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* ENCOD Objects of RUNTIME.MATHTEXT (= SYS1.FORTLIB)
//********************************************************************
//*
//COMPILE  EXEC PASNCL,MEM=ENCOD,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
//GO001    EXEC PGM=ENCOD
//STEPLIB  DD   DISP=SHR,DSN=PASCALN.TESTPGM.LOAD
//INPUT    DD   DISP=SHR,DSN=PASCALN.RUNTIME.MATHXXXX(STIMER)           00001400
//OUTPUT   DD   DISP=SHR,DSN=PASCALN.RUNTIME.MATHTEXT(STIMER)           00001400
//PASTRACE DD   SYSOUT=*
++FILE PASCALN.TESTPGM.CNTL                         MEMB ENCODALL EXT JOB HEX -
//PASCALNG JOB (PASCAL),'ENCOD OBJECT',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* ENCOD Objects of RUNTIME.MATHTEXT (= SYS1.FORTLIB)
//* using instream procedure
//********************************************************************
//*
//COMPILE  EXEC PASNCL,MEM=ENCOD,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
//*
//ENCOD    PROC MEMB='nix'
//ENCOD    EXEC PGM=ENCOD
//STEPLIB  DD   DISP=SHR,DSN=PASCALN.TESTPGM.LOAD
//INPUT    DD   DISP=SHR,DSN=PASCALN.RUNTIME.MATHXXXX(&MEMB)
//OUTPUT   DD   DISP=SHR,DSN=PASCALN.RUNTIME.MATHTEXT(&MEMB),
//         DCB=(RECFM=FB,LRECL=80,BLKSIZE=19040)
//PASTRACE DD   SYSOUT=*
//         PEND
//*
//GO001    EXEC ENCOD,MEMB=DIMAG
//GO002    EXEC ENCOD,MEMB=DREAL
//GO003    EXEC ENCOD,MEMB=FIOCS#
//GO004    EXEC ENCOD,MEMB=IHCADJST
//GO005    EXEC ENCOD,MEMB=IHCCGOTO
//GO006    EXEC ENCOD,MEMB=IHCCLABS
//GO007    EXEC ENCOD,MEMB=IHCCLAS
//GO008    EXEC ENCOD,MEMB=IHCCLEXP
//GO009    EXEC ENCOD,MEMB=IHCCLLOG
//GO010    EXEC ENCOD,MEMB=IHCCLSCN
//GO011    EXEC ENCOD,MEMB=IHCCLSQT
//GO012    EXEC ENCOD,MEMB=IHCCSABS
//GO013    EXEC ENCOD,MEMB=IHCCSAS
//GO014    EXEC ENCOD,MEMB=IHCCSEXP
//GO015    EXEC ENCOD,MEMB=IHCCSLOG
//GO016    EXEC ENCOD,MEMB=IHCCSSCN
//GO017    EXEC ENCOD,MEMB=IHCCSSQT
//GO018    EXEC ENCOD,MEMB=IHCDBUG
//GO019    EXEC ENCOD,MEMB=IHCDIOSE
//GO020    EXEC ENCOD,MEMB=IHCECOMH
//GO021    EXEC ENCOD,MEMB=IHCEDIOS
//GO022    EXEC ENCOD,MEMB=IHCEFIOS
//GO023    EXEC ENCOD,MEMB=IHCEFNTH
//GO024    EXEC ENCOD,MEMB=IHCERRM
//GO025    EXEC ENCOD,MEMB=IHCETRCH
//GO026    EXEC ENCOD,MEMB=IHCFAINT
//GO027    EXEC ENCOD,MEMB=IHCFCDXI
//GO028    EXEC ENCOD,MEMB=IHCFCOME
//GO029    EXEC ENCOD,MEMB=IHCFCOMH
//GO030    EXEC ENCOD,MEMB=IHCFCVTH
//GO031    EXEC ENCOD,MEMB=IHCFCXPI
//GO032    EXEC ENCOD,MEMB=IHCFDUMP
//GO033    EXEC ENCOD,MEMB=IHCFDVCH
//GO034    EXEC ENCOD,MEMB=IHCFDXPD
//GO035    EXEC ENCOD,MEMB=IHCFDXPI
//GO036    EXEC ENCOD,MEMB=IHCFEXIT
//GO037    EXEC ENCOD,MEMB=IHCFIFIX
//GO038    EXEC ENCOD,MEMB=IHCFINTH
//GO039    EXEC ENCOD,MEMB=IHCFIXPI
//GO040    EXEC ENCOD,MEMB=IHCFMAXD
//GO041    EXEC ENCOD,MEMB=IHCFMAXI
//GO042    EXEC ENCOD,MEMB=IHCFMAXR
//GO043    EXEC ENCOD,MEMB=IHCFMODI
//GO044    EXEC ENCOD,MEMB=IHCFMODR
//GO045    EXEC ENCOD,MEMB=IHCFOPT
//GO046    EXEC ENCOD,MEMB=IHCFOVER
//GO047    EXEC ENCOD,MEMB=IHCFRXPI
//GO048    EXEC ENCOD,MEMB=IHCFRXPR
//GO049    EXEC ENCOD,MEMB=IHCFSLIT
//GO050    EXEC ENCOD,MEMB=IHCIBERH
//GO051    EXEC ENCOD,MEMB=IHCIBERR
//GO052    EXEC ENCOD,MEMB=IHCLASCN
//GO053    EXEC ENCOD,MEMB=IHCLATAN
//GO054    EXEC ENCOD,MEMB=IHCLATN2
//GO055    EXEC ENCOD,MEMB=IHCLERF
//GO056    EXEC ENCOD,MEMB=IHCLEXP
//GO057    EXEC ENCOD,MEMB=IHCLGAMA
//GO058    EXEC ENCOD,MEMB=IHCLLOG
//GO059    EXEC ENCOD,MEMB=IHCLSCN
//GO060    EXEC ENCOD,MEMB=IHCLSCNH
//GO061    EXEC ENCOD,MEMB=IHCLSQRT
//GO062    EXEC ENCOD,MEMB=IHCLTANH
//GO063    EXEC ENCOD,MEMB=IHCLTNCT
//GO064    EXEC ENCOD,MEMB=IHCNAMEL
//GO065    EXEC ENCOD,MEMB=IHCSASCN
//GO066    EXEC ENCOD,MEMB=IHCSATAN
//GO067    EXEC ENCOD,MEMB=IHCSATN2
//GO068    EXEC ENCOD,MEMB=IHCSERF
//GO069    EXEC ENCOD,MEMB=IHCSEXP
//GO070    EXEC ENCOD,MEMB=IHCSGAMA
//GO071    EXEC ENCOD,MEMB=IHCSLOG
//GO072    EXEC ENCOD,MEMB=IHCSSCN
//GO073    EXEC ENCOD,MEMB=IHCSSCNH
//GO074    EXEC ENCOD,MEMB=IHCSSQRT
//GO075    EXEC ENCOD,MEMB=IHCSTAE
//GO076    EXEC ENCOD,MEMB=IHCSTANH
//GO077    EXEC ENCOD,MEMB=IHCSTNCT
//GO078    EXEC ENCOD,MEMB=IHCTRCH
//GO079    EXEC ENCOD,MEMB=IHCUATBL
//GO080    EXEC ENCOD,MEMB=IHCUOPT
//GO081    EXEC ENCOD,MEMB=STIMER
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB FIBDEMO  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG FIBDEMO',CLASS=A,MSGCLASS=X,               00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000300
//********************************************************************  00000400
//* Test FIBDEMO (will produce SNAP DUMP)                               00000500
//********************************************************************  00000600
//*                                                                     00000700
//COMPGO  EXEC PASNCG,MEM=FIBDEMO,GOPARM=NOSNAP,                        00000800
//        SRC='PASCALN.TESTPGM.PAS'                                     00000900
//*                                                                     00001000
++FILE PASCALN.TESTPGM.CNTL                         MEMB FIBOK    EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG FIBOK',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000301
//********************************************************************  00000401
//* Test FIBOK
//********************************************************************  00000601
//*                                                                     00000701
//COMPGO  EXEC PASNCG,MEM=FIBOK,GOPARM=NOSNAP,
//        SRC='PASCALN.TESTPGM.PAS'                                     00000901
//*                                                                     00001001
++FILE PASCALN.TESTPGM.CNTL                         MEMB FIB1982  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG FIB1982',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000301
//********************************************************************  00000401
//* Test FIB1982
//********************************************************************  00000601
//*                                                                     00000701
//COMPGO  EXEC PAS1982T,MEM=FIB1982,GOPARM=NOSNAP,
//        SRC='PASCALN.TESTPGM.PAS'                                     00000901
//*                                                                     00001001
++FILE PASCALN.TESTPGM.CNTL                         MEMB GODOWNL  EXT JOB HEX -
//PASCALNC JOB (PASCAL),'DOWNLOAD',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//*
//* Download complete Stanford Pascal System - MVS edition - 12.2017
//*
//********************************************************************
//*
//GO      EXEC PGM=DOWNLOAD,PARM='/NOSNAP'
//STEPLIB  DD  DISP=SHR,DSN=PASCALN.TESTPGM.LOAD
//SYSPRINT DD  SYSOUT=A
//INPUT    DD  *
//OUTPUT   DD  SYSOUT=A,DCB=(RECFM=VB,LRECL=133)
//PASTRACE DD  SYSOUT=A
//CONTROL  DD  *
************************************************************
  1 PASCALN.COMPILER.PAS         DECOD      PAS
  1 PASCALN.COMPILER.PAS         ENCOD      PAS
  1 PASCALN.COMPILER.PAS         PASCAL1    PAS
  1 PASCALN.COMPILER.PAS         PASCAL1A   PAS
  1 PASCALN.COMPILER.PAS         PASCAL1B   PAS
  1 PASCALN.COMPILER.PAS         PASCAL2    PAS
  1 PASCALN.COMPILER.PAS         PASCAL2A   PAS
  1 PASCALN.COMPILER.PAS         PASCAL2B   PAS
  1 PASCALN.COMPILER.PAS         PASFORM    PAS
  1 PASCALN.COMPILER.PAS         PASFORMA   PAS
  1 PASCALN.COMPILER.PAS         PASLIBX    PAS
  1 PASCALN.COMPILER.PAS         PASSCAN    PAS
  1 PASCALN.COMPILER.PAS         PASSCANA   PAS
  1 PASCALN.COMPILER.PAS         PASSNAP    PAS
  1 PASCALN.COMPILER.PAS         PASSNAPC   PAS
  1 PASCALN.COMPILER.PAS         PASUTILS   PAS
************************************************************
  2 PASCALN.COMPILER.CNTL        ASMMON     JOB
  2 PASCALN.COMPILER.CNTL        COMPCOLD   JOB
  2 PASCALN.COMPILER.CNTL        COMPCOMP   JOB
  2 PASCALN.COMPILER.CNTL        COMPOBJ    JOB
  2 PASCALN.COMPILER.CNTL        INSTALL    JOB
  2 PASCALN.COMPILER.CNTL        LINKRUNT   JOB
  2 PASCALN.COMPILER.CNTL        PASFORM    JOB
  2 PASCALN.COMPILER.CNTL        PASLIBX    JOB
  2 PASCALN.COMPILER.CNTL        PASSNAP    JOB
  2 PASCALN.COMPILER.CNTL        PASUTILS   JOB
************************************************************
  3 PASCALN.COMPILER.MESSAGES    MESSAGES   TXT
  3 PASCALN.COMPILER.MESSAGES    STDINC     TXT
************************************************************
  4 PASCALN.COMPILER.PROCLIB     PASNC      PRC
  4 PASCALN.COMPILER.PROCLIB     PASNCG     PRC
  4 PASCALN.COMPILER.PROCLIB     PASNCL     PRC
  4 PASCALN.COMPILER.PROCLIB     PASNCLG    PRC
************************************************************
  5 PASCALN.RUNTIME.ASM          PASMONN    ASS
************************************************************
  6 PASCALN.TESTPGM.ASM          PAS2AF     ASS
  6 PASCALN.TESTPGM.ASM          PAS2ASM    ASS
  6 PASCALN.TESTPGM.ASM          PAS2FF     ASS
  6 PASCALN.TESTPGM.ASM          PAS2FTN    ASS
************************************************************
  7 PASCALN.TESTPGM.PAS          AUFBADR    PAS
  7 PASCALN.TESTPGM.PAS          COPYREAL   PAS
  7 PASCALN.TESTPGM.PAS          COPYTEXT   PAS
  7 PASCALN.TESTPGM.PAS          DECOD      PAS
  7 PASCALN.TESTPGM.PAS          DOWNLOAD   PAS
  7 PASCALN.TESTPGM.PAS          ENCOD      PAS
  7 PASCALN.TESTPGM.PAS          FIBDEMO    PAS
  7 PASCALN.TESTPGM.PAS          FIBOK      PAS
  7 PASCALN.TESTPGM.PAS          KALENDER   PAS
  7 PASCALN.TESTPGM.PAS          MODRAND    PAS
  7 PASCALN.TESTPGM.PAS          PASFORM    PAS
  7 PASCALN.TESTPGM.PAS          PAS2PAS    PAS
  7 PASCALN.TESTPGM.PAS          PRIMZERL   PAS
  7 PASCALN.TESTPGM.PAS          SHOWHEX    PAS
  7 PASCALN.TESTPGM.PAS          SPLITPAS   PAS
  7 PASCALN.TESTPGM.PAS          TESTAND    PAS
  7 PASCALN.TESTPGM.PAS          TESTASM    PAS
  7 PASCALN.TESTPGM.PAS          TESTCA2    PAS
  7 PASCALN.TESTPGM.PAS          TESTCA3    PAS
  7 PASCALN.TESTPGM.PAS          TESTCEIN   PAS
  7 PASCALN.TESTPGM.PAS          TESTCOLL   PAS
  7 PASCALN.TESTPGM.PAS          TESTDUPL   PAS
  7 PASCALN.TESTPGM.PAS          TESTERR1   PAS
  7 PASCALN.TESTPGM.PAS          TESTERR2   PAS
  7 PASCALN.TESTPGM.PAS          TESTFILE   PAS
  7 PASCALN.TESTPGM.PAS          TESTFIL1   PAS
  7 PASCALN.TESTPGM.PAS          TESTFUNC   PAS
  7 PASCALN.TESTPGM.PAS          TESTIEIN   PAS
  7 PASCALN.TESTPGM.PAS          TESTINN    PAS
  7 PASCALN.TESTPGM.PAS          TESTINP    PAS
  7 PASCALN.TESTPGM.PAS          TESTLAB    PAS
  7 PASCALN.TESTPGM.PAS          TESTLSTR   PAS
  7 PASCALN.TESTPGM.PAS          TESTMAJ    PAS
  7 PASCALN.TESTPGM.PAS          TESTMOD    PAS
  7 PASCALN.TESTPGM.PAS          TESTM1     PAS
  7 PASCALN.TESTPGM.PAS          TESTPDS    PAS
  7 PASCALN.TESTPGM.PAS          TESTRDS    PAS
  7 PASCALN.TESTPGM.PAS          TESTREAD   PAS
  7 PASCALN.TESTPGM.PAS          TESTREAL   PAS
  7 PASCALN.TESTPGM.PAS          TESTRL     PAS
  7 PASCALN.TESTPGM.PAS          TESTRND    PAS
  7 PASCALN.TESTPGM.PAS          TESTSCAL   PAS
  7 PASCALN.TESTPGM.PAS          TESTSCAN   PAS
  7 PASCALN.TESTPGM.PAS          TESTSET    PAS
  7 PASCALN.TESTPGM.PAS          TESTSET1   PAS
  7 PASCALN.TESTPGM.PAS          TESTSET2   PAS
  7 PASCALN.TESTPGM.PAS          TESTSETH   PAS
  7 PASCALN.TESTPGM.PAS          TESTSETS   PAS
  7 PASCALN.TESTPGM.PAS          TESTSIN    PAS
  7 PASCALN.TESTPGM.PAS          TESTSNAP   PAS
  7 PASCALN.TESTPGM.PAS          TESTSNA1   PAS
  7 PASCALN.TESTPGM.PAS          TESTSNA2   PAS
  7 PASCALN.TESTPGM.PAS          TESTSNA3   PAS
  7 PASCALN.TESTPGM.PAS          TESTSQRT   PAS
  7 PASCALN.TESTPGM.PAS          TESTSTAT   PAS
  7 PASCALN.TESTPGM.PAS          TESTSVAR   PAS
  7 PASCALN.TESTPGM.PAS          TESTTRC    PAS
  7 PASCALN.TESTPGM.PAS          TESTVS     PAS
  7 PASCALN.TESTPGM.PAS          TESTXB     PAS
  7 PASCALN.TESTPGM.PAS          TESTXBM    PAS
  7 PASCALN.TESTPGM.PAS          TEST1      PAS
  7 PASCALN.TESTPGM.PAS          XCOMP      PAS
************************************************************
  8 PASCALN.TESTPGM.CNTL         DOWNLOAD   JOB
  8 PASCALN.TESTPGM.CNTL         DRUCK      JOB
  8 PASCALN.TESTPGM.CNTL         DUMPJOB    JOB
  8 PASCALN.TESTPGM.CNTL         ENCOD001   JOB
  8 PASCALN.TESTPGM.CNTL         ENCOD002   JOB
  8 PASCALN.TESTPGM.CNTL         ENCOD003   JOB
  8 PASCALN.TESTPGM.CNTL         ENCOD004   JOB
  8 PASCALN.TESTPGM.CNTL         FIBDEMO    JOB
  8 PASCALN.TESTPGM.CNTL         FIBOK      JOB
  8 PASCALN.TESTPGM.CNTL         GODOWNL    JOB
  8 PASCALN.TESTPGM.CNTL         ICKDSF     JOB
  8 PASCALN.TESTPGM.CNTL         PASFORM    JOB
  8 PASCALN.TESTPGM.CNTL         PAS2ASM    JOB
  8 PASCALN.TESTPGM.CNTL         PAS2PAS    JOB
  8 PASCALN.TESTPGM.CNTL         PRIMASM    JOB
  8 PASCALN.TESTPGM.CNTL         PRIMZERL   JOB
  8 PASCALN.TESTPGM.CNTL         SHOWHEX    JOB
  8 PASCALN.TESTPGM.CNTL         SPLITPAS   JOB
  8 PASCALN.TESTPGM.CNTL         TESTAND    JOB
  8 PASCALN.TESTPGM.CNTL         TESTASM    JOB
  8 PASCALN.TESTPGM.CNTL         TESTCA3    JOB
  8 PASCALN.TESTPGM.CNTL         TESTDUPL   JOB
  8 PASCALN.TESTPGM.CNTL         TESTERR1   JOB
  8 PASCALN.TESTPGM.CNTL         TESTERR2   JOB
  8 PASCALN.TESTPGM.CNTL         TESTFILE   JOB
  8 PASCALN.TESTPGM.CNTL         TESTINP    JOB
  8 PASCALN.TESTPGM.CNTL         TESTLAB    JOB
  8 PASCALN.TESTPGM.CNTL         TESTM1     JOB
  8 PASCALN.TESTPGM.CNTL         TESTPAS    JOB
  8 PASCALN.TESTPGM.CNTL         TESTPDS    JOB
  8 PASCALN.TESTPGM.CNTL         TESTSCAL   JOB
  8 PASCALN.TESTPGM.CNTL         TESTSETH   JOB
  8 PASCALN.TESTPGM.CNTL         TESTSIN    JOB
  8 PASCALN.TESTPGM.CNTL         TESTSNA1   JOB
  8 PASCALN.TESTPGM.CNTL         TESTSNA2   JOB
  8 PASCALN.TESTPGM.CNTL         TESTSNA3   JOB
  8 PASCALN.TESTPGM.CNTL         TESTSQRT   JOB
  8 PASCALN.TESTPGM.CNTL         TESTSTAT   JOB
  8 PASCALN.TESTPGM.CNTL         TESTSVAR   JOB
  8 PASCALN.TESTPGM.CNTL         XCOMP      JOB
************************************************************
  9 PASCALN.COMPILER.TEXT        PASCAL1    OBJ    H
  9 PASCALN.COMPILER.TEXT        PASCAL2    OBJ    H
  9 PASCALN.COMPILER.TEXT        PASSCAN    OBJ    H
  9 PASCALN.COMPILER.TEXT        PASSCANA   OBJ    H
************************************************************
  A PASCALN.RUNTIME.TEXT         PASLIBX    OBJ    H
  A PASCALN.RUNTIME.TEXT         PASMONN    OBJ    H
  A PASCALN.RUNTIME.TEXT         PASSNAP    OBJ    H
  A PASCALN.RUNTIME.TEXT         PASUTILS   OBJ    H
************************************************************
//PDS001   DD  DISP=SHR,DSN=PASCALN.COMPILER.PAS
//PDS002   DD  DISP=SHR,DSN=PASCALN.COMPILER.CNTL
//PDS003   DD  DISP=SHR,DSN=PASCALN.COMPILER.MESSAGES
//PDS004   DD  DISP=SHR,DSN=PASCALN.COMPILER.PROCLIB
//PDS005   DD  DISP=SHR,DSN=PASCALN.RUNTIME.ASM
//PDS006   DD  DISP=SHR,DSN=PASCALN.TESTPGM.ASM
//PDS007   DD  DISP=SHR,DSN=PASCALN.TESTPGM.PAS
//PDS008   DD  DISP=SHR,DSN=PASCALN.TESTPGM.CNTL
//PDS009   DD  DISP=SHR,DSN=PASCALN.COMPILER.TEXT
//PDS00A   DD  DISP=SHR,DSN=PASCALN.RUNTIME.TEXT
//SYSUDUMP DD  SYSOUT=A
//QRD      DD  DISP=SHR,DSN=PASCALN.DBGINFO
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB MANORBOY EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG MANORBOY',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test MANORBOY
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=MANORBOY,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB PASFORM  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'PASFORM',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//***************************************************************
//*        pascal source code formatter
//***************************************************************
//*
//GO       EXEC PGM=PASFORM
//QRD      DD  DISP=SHR,DSN=PASCALN.DBGINFO
//STEPLIB  DD  DISP=SHR,DSN=PASCALN.COMPILER.LOAD                       00001000
//SYSPRINT DD  SYSOUT=A                                                 00001100
//OUTPUT   DD  SYSOUT=A                                                 00001200
//EINGABE  DD  DISP=SHR,DSN=PASCALN.COMPILER.PAS(PASCAL1)               00001300
//AUSGABE  DD  DISP=SHR,DSN=PASCALN.TESTPGM.PAS(PASCAL1)                00001400
//LISTING  DD  SYSOUT=A                                                 00001200
//TRACEF   DD  SYSOUT=A                                                 00001500
//PASTRACE DD  SYSOUT=A                                                 00001600
//SYSUDUMP DD  SYSOUT=A                                                 00001700
//*                                                                     00001800
++FILE PASCALN.TESTPGM.CNTL                         MEMB PAS2ASM  EXT JOB HEX -
//PASCALN2 JOB (ACCNT),'ASM PAS2ASM',CLASS=A,MSGCLASS=X,                00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000300
//********************************************************************  00000400
//*                                                                     00000500
//* assemble test programs                                              00000600
//*                                                                     00000700
//********************************************************************  00000800
//*                                                                     00000900
//ASSEMB1   EXEC ASMFC,PARM.ASM=(OBJ,DECK),                             00001000
//          MAC1='SYS2.MACLIB',                                         00001100
//          MAC2='SYS1.AMACLIB',                                        00001200
//          MAC3='SYS1.AMODGEN'                                         00001300
//ASM.SYSIN DD DISP=SHR,DSN=PASCALN.TESTPGM.ASM(PAS2ASM)                00001400
//ASM.SYSGO DD DISP=SHR,DSN=PASCALN.TESTPGM.TEXT(PAS2ASM)               00001500
//*                                                                     00001600
//ASSEMB2   EXEC ASMFC,PARM.ASM=(OBJ,DECK),                             00001700
//          MAC1='SYS2.MACLIB',                                         00001800
//          MAC2='SYS1.AMACLIB',                                        00001900
//          MAC3='SYS1.AMODGEN'                                         00002000
//ASM.SYSIN DD DISP=SHR,DSN=PASCALN.TESTPGM.ASM(PAS2FTN)                00002100
//ASM.SYSGO DD DISP=SHR,DSN=PASCALN.TESTPGM.TEXT(PAS2FTN)               00002200
//*                                                                     00002300
//ASSEMB3   EXEC ASMFC,PARM.ASM=(OBJ,DECK),                             00002400
//          MAC1='SYS2.MACLIB',                                         00002500
//          MAC2='SYS1.AMACLIB',                                        00002600
//          MAC3='SYS1.AMODGEN'                                         00002700
//ASM.SYSIN DD DISP=SHR,DSN=PASCALN.TESTPGM.ASM(PAS2AF)                 00002800
//ASM.SYSGO DD DISP=SHR,DSN=PASCALN.TESTPGM.TEXT(PAS2AF)                00002900
//*                                                                     00003000
//ASSEMB4   EXEC ASMFC,PARM.ASM=(OBJ,DECK),                             00003100
//          MAC1='SYS2.MACLIB',                                         00003200
//          MAC2='SYS1.AMACLIB',                                        00003300
//          MAC3='SYS1.AMODGEN'                                         00003400
//ASM.SYSIN DD DISP=SHR,DSN=PASCALN.TESTPGM.ASM(PAS2FF)                 00003500
//ASM.SYSGO DD DISP=SHR,DSN=PASCALN.TESTPGM.TEXT(PAS2FF)                00003600
++FILE PASCALN.TESTPGM.CNTL                         MEMB PAS2PAS  EXT JOB HEX -
//PASCALNT JOB (PASCAL),'COMP PAS2PAS',CLASS=A,MSGCLASS=X,              00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000300
//COMPOBJ  EXEC PASNC,MEM=PAS2PAS,                                      00000401
//         SRC='PASCALN.TESTPGM.PAS',                                   00000500
//         OBJ='PASCALN.TESTPGM.TEXT'                                   00000600
++FILE PASCALN.TESTPGM.CNTL                         MEMB PRIMASM  EXT JOB HEX -
//PASCALN2 JOB (ACCNT),                                                 00000101
//             'Eratosthenes Sieve',                                    00000200
//             CLASS=A,                                                 00000300
//             MSGCLASS=X,                                              00000401
//             TIME=1440,                                               00000500
//             MSGLEVEL=(1,1)                                           00000600
//********************************************************************  00000700
//*                                                                     00000800
//* Name: SYS2.JCLLIB(PRIMASM)                                          00000900
//*                                                                     00001000
//* Desc: Sieve of Eratosthenes programmed in Basic Assembler Language  00001100
//*       All prime numbers up to the value entered via PARM.GO         00001200
//*       are computed.                                                 00001300
//*                                                                     00001400
//********************************************************************  00001500
//PRIMES  EXEC ASMFCG,PARM.ASM=(OBJ,NODECK),MAC1='SYS2.MACLIB',         00001600
//             REGION.GO=128K,PARM.GO='/2000'                           00001700
//ASM.SYSIN DD *                                                        00001800
PRIMASM  TITLE 'Sieve of Eratosthenes: Find Prime Numbers'              00001900
*********************************************************************** 00002000
***                                                                 *** 00002100
*** Program:  PRIMASM                                               *** 00002200
***                                                                 *** 00002300
*** Purpose:  Find all prime numbers up to a given limit            *** 00002400
***           using Eratothenes' sieve algorithm.                   *** 00002500
***                                                                 *** 00002600
*** Usage:    The following JCL is required to run PRIMASM:         *** 00002700
***                                                                 *** 00002800
***           //PRIMASM EXEC PGM=PRIMASM,REGION=<size>,PARM=<limit> *** 00002900
***           //STEPLIB  DD  DSN=<loadlib>,DISP=SHR                 *** 00003000
***           //SYSPRINT DD  SYSOUT=*                               *** 00003100
***                                                                 *** 00003200
***           The parameters are defined as follows:                *** 00003300
***                                                                 *** 00003400
***           <limit>   the largest number to sieve. All primes     *** 00003500
***                     up to this number will be found. If the     *** 00003600
***                     limit given is too high for the algorithm   *** 00003700
***                     to execute within the bounds of the         *** 00003800
***                     available virtual storage, <limit> will be  *** 00003900
***                     adjusted to fit into the given region. If   *** 00004000
***                     no PARM value is given, a default limit of  *** 00004100
***                     2000 will be used.                          *** 00004200
***                                                                 *** 00004300
***           <size>    the amount of virtual storage the program   *** 00004400
***                     is allowed to use. The program will always  *** 00004500
***                     allocate the maximum amount of storage      *** 00004600
***                     allowed by the REGION parameter. If no      *** 00004700
***                     REGION parameter is specified, results will *** 00004800
***                     be unpredictable.                           *** 00004900
***                                                                 *** 00005000
***           <loadlib> the load library containing the PRIMASM     *** 00005100
***                     program.                                    *** 00005200
***                                                                 *** 00005300
*** Function: 1. Allocate all virtual storage available and adjust  *** 00005400
***              the sieve limit if necessary. This storage is      *** 00005500
***              used as flags, where each bit indicates whether    *** 00005600
***              the odd number corresponding to the bit's position *** 00005700
***              is prime or not. Odd numbers are assigned to these *** 00005800
***              bits in sequence, i.e. numbers 1,3,5,7,9,11,13,15  *** 00005900
***              correspond to bits 0,1,2,3,4,5,6,7 and so forth.   *** 00006000
***                                                                 *** 00006100
***           2. Set all prime flags to one, except the first.      *** 00006200
***              The first flag corresponds to the number one,      *** 00006300
***              which isn't prime. Note that there don't exist     *** 00006400
***              flags for even numbers, because even numbers       *** 00006500
***              (except the two) are never prime.                  *** 00006600
***                                                                 *** 00006700
***           3. Run Eratothenes' sieve which will result in        *** 00006800
***              clearing the prime flags of all none prime numbers *** 00006900
***              up to the given limit.                             *** 00007000
***                                                                 *** 00007100
***           4. Print all numbers having their prime flag set to   *** 00007200
***              SYSPRINT. The "irregular" two is printed manually  *** 00007300
***              for the sake of completeness.                      *** 00007400
***                                                                 *** 00007500
***           5. Print a summary message indicating the number of   *** 00007600
***              primes found up to the given limit to SYSPRINT and *** 00007700
***              to the job log.                                    *** 00007800
***                                                                 *** 00007900
***           6. Release the allocated storage.                     *** 00008000
***                                                                 *** 00008100
***           7. Exit.                                              *** 00008200
***                                                                 *** 00008300
*** Updates:  2014/07/18 original implementation.                   *** 00008400
***           2014/07/21 eliminate even numbers from prime flags.   *** 00008500
***                                                                 *** 00008600
*** Author:   Juergen Winkelmann, ETH Zuerich.                      *** 00008700
***                                                                 *** 00008800
*********************************************************************** 00008900
PRIMASM  CSECT                                                          00009000
         SAVE  (14,12),,*       save registers                          00009100
         LR    R12,R15          establish module addressability         00009200
         USING PRIMASM,R12      tell assembler of base                  00009300
         LA    R2,SAVEA         chain ..                                00009400
         ST    R13,4(,R2)         .. the ..                             00009500
         ST    R2,8(,R13)           .. save ..                          00009600
         LR    R13,R2                 .. areas                          00009700
*                                                                       00009800
* Initialize sieve limit and virtual storage                            00009900
*                                                                       00010000
         L     R2,0(,R1)        parameter list address                  00010100
         LH    R1,0(,R2)        length of PARM field                    00010200
         LTR   R1,R1            PARM field specified?                   00010300
         BZ    NOPARM           no, use default sieve limit             00010400
         L     R3,HIGHLIM       maximum PARM allowed                    00010500
         LA    R4,10            maximum PARM length allowed             00010600
         CR    R1,R4            maximum PARM length exceeded?           00010700
         BH    HIGHPARM         yes -> use maximum as sieve limit       00010800
         LA    R3,PARM+10       right justify ..                        00010900
         SR    R3,R1              .. to 10 digits                       00011000
         BCTR  R1,0             decrement for EXecute                   00011100
         EX    R1,MOVEPARM      get PARM                                00011200
         PACK  NUMDEC(8),PARM(10) pack PARM and ..                      00011300
         CVB   R3,NUMDEC            .. convert to binary                00011400
HIGHPARM ST    R3,LIMIT         set sieve limit                         00011500
NOPARM   OPEN  (SYSPRINT,OUTPUT) open SYSPRINT                          00011600
         GETMAIN VU,LA=GETMAX,A=ISPRIME allocate all available storage  00011700
         L     R7,MAXMEM        storage amount obtained times 16 ..     00011800
         SLL   R7,4               .. is maximum sieve limit possible    00011900
         C     R7,LIMIT         does requested limit fit into storage?  00012000
         BNL   *+8              yes -> use requested limit              00012100
         ST    R7,LIMIT         no  -> use maximum possible             00012200
         L     R6,ISPRIME       address of storage obtained             00012300
         L     R8,LIMIT         sieve limit                             00012400
         XR    R9,R9            clear R9 for modulo                     00012500
         SRDL  R8,4             divide sieve limit by 16                00012600
         LR    R7,R8            amount of storage to be initialized     00012700
         LTR   R9,R9            sieve limit modulo 16 = 0?              00012800
         BZ    *+8              yes -> use computed storage amount      00012900
         LA    R7,1(,R7)        no  -> increment amount by one          00013000
         XR    R8,R8            clear R8 for MVCL                       00013100
         L     R9,FF            get initialization pattern for MVCL     00013200
         MVCL  R6,R8            initialize prime indication flags       00013300
         L     R6,ISPRIME       start of prime indication flags         00013400
         MVI   0(R6),X'7F'      make one not prime                      00013500
*                                                                       00013600
* Sieve of Eratosthenes                                                 00013700
*                                                                       00013800
         L     R1,ISPRIME       address of prime flag array             00013900
         LA    R2,CROSSOUT      masks to cross out primes               00014000
         XR    R3,R3            clear for prime test EXecuted later     00014100
         LA    R4,PRIMFLGS      masks for prime test                    00014200
         LA    R5,1             candidate bit offset \  sieve starts    00014300
         LR    R6,R1            candidate address     >      at         00014400
         LA    R7,3             candidate value      /     three        00014500
         LA    R14,2            incrementor for large numbers           00014600
SIEVE    LR    R9,R7            is square of ..                         00014700
         MR    R8,R7              .. candidate value ..                 00014800
         C     R9,LIMIT             .. higher than sieve limit?         00014900
         BH    PRNTPRIM         yes -> sieve complete, go print         00015000
         IC    R3,0(R5,R4)      is prime flag for ..                    00015100
         EX    R3,TESTPRIM        .. this candidate set?                00015200
         BNO   SIEVENXT         no  -> check next candidate             00015300
CLRMULT  SLL   R7,1             only odd multiples need to be cleared   00015400
CLRMULTL LR    R10,R9           current prime multiple                  00015500
         BCTR  R10,0            decrement for addressing                00015600
         SRL   R10,1            divide by two (address compression)     00015700
         SRDL  R10,3            divide by eight                         00015800
         AR    R10,R1           address of prime multiple               00015900
         SRL   R11,29           bit offset of prime multiple            00016000
         IC    R3,0(R11,R2)     get cross out mask                      00016100
         EX    R3,CLRPRIM       cross out prime multiple                00016200
         AR    R9,R7            is next odd prime multiple ..           00016300
         C     R9,LIMIT           .. not higher than sieve limit?       00016400
         BNH   CLRMULTL         yes -> go cross it out                  00016500
         SRL   R7,1             restore candidate value                 00016600
SIEVENXT AR    R7,R14           next please, skip even numbers          00016700
         LA    R5,1(,R5)        next bit position                       00016800
         CH    R5,EIGHT         end of byte reached                     00016900
         BL    SIEVE            no  -> check candidate                  00017000
         LA    R5,0             yes -> reset candidate bit offset ..    00017100
         LA    R6,1(,R6)                 .. and increment to next byte  00017200
         B     SIEVE            go check it                             00017300
*                                                                       00017400
* Print primes                                                          00017500
*                                                                       00017600
PRNTPRIM LA    R5,1             candidate bit offset \  print starts    00017700
         LR    R6,R1            candidate address     >      at         00017800
         LA    R7,3             candidate value      /     three        00017900
         LA    R2,2             incrementor for large limits            00018000
         LA    R8,1             number of primes found, the two is ..   00018100
         LA    R10,1              .. pre set and ..                     00018200
         LA    R9,PRNTLINE+11     .. pre printed                        00018300
         XR    R11,R11          no lines printed on this page yet       00018400
         B     *+16             skip page initialization on first page  00018500
NEWLINE  MVC   CC(166),NL       new line                                00018600
         LA    R9,PRNTLINE      current print position                  00018700
         XR    R10,R10          no numbers printed on this line yet     00018800
         CH    R11,LPP          page full?                              00018900
         BNE   CHKPRIME         no -> check next number                 00019000
         XR    R11,R11          no lines printed on this page yet       00019100
         MVI   CC,C'1'          next line starts a new page             00019200
CHKPRIME C     R7,LIMIT         sieve limit reached?                    00019300
         BH    LASTLINE         yes -> print last line                  00019400
         IC    R3,0(R5,R4)      is prime flag for ..                    00019500
         EX    R3,TESTPRIM        .. this candidate set?                00019600
         BNO   CHKNEXT          no  -> check next candidate             00019700
         LA    R8,1(,R8)        yes -> increment number of primes found 00019800
         CVD   R7,NUMDEC        convert prime to decimal                00019900
         MVC   0(11,R9),EDIT    get print format into print position    00020000
         ED    1(11,R9),NUMDEC+3 format prime                           00020100
         LA    R10,1(,R10)      increment number of primes and ..       00020200
         LA    R9,11(,R9)         .. print position                     00020300
         CH    R10,NPL          is current line filled up?              00020400
         BNE   CHKNEXT          no  -> check next candidate             00020500
         PUT   SYSPRINT,CC      yes -> print line                       00020600
         LA    R11,1(,R11)      increment number of lines on this page  00020700
         LA    R15,NEWLINE      next loop initializes a new line        00020800
         B     *+8              skip adding to current line             00020900
CHKNEXT  LA    R15,CHKPRIME     next loop adds to current line          00021000
         AR    R7,R2            next please, skip even numbers          00021100
         LA    R5,1(,R5)        next bit position                       00021200
         CH    R5,EIGHT         end of byte reached                     00021300
         BLR   R15              no  -> check candidate                  00021400
         LA    R5,0             yes -> reset candidate bit offset ..    00021500
         LA    R6,1(,R6)                 .. and increment to next byte  00021600
         BR    R15              go check it                             00021700
LASTLINE LTR   R10,R10          not yet printed primes in this line?    00021800
         BZ    SUMMARY          no  -> print summary                    00021900
         PUT   SYSPRINT,CC      yes -> print last primes                00022000
         MVC   CC(166),NL       new line                                00022100
         LA    R11,1(,R11)      increment number of lines on this page  00022200
SUMMARY  CLI   CC,C'1'          new page already started?               00022300
         BE    PRINTSUM         yes -> print summary line               00022400
         LA    R11,1(,R11)      no  -> increment number of lines        00022500
         CH    R11,LPP          page almost full?                       00022600
         BNL   *+12             yes -> start new page                   00022700
         MVI   CC,C'0'          no  -> skip one line                    00022800
         B     *+8              print summary                           00022900
         MVI   CC,C'1'          start new page                          00023000
PRINTSUM CVD   R8,NUMDEC        convert number of primes to decimal     00023100
         MVC   PRNTLINE(LSUMMARY),EDIT get summary line and formats     00023200
         ED    PRNTLINE+1(11),NUMDEC+3 format number of lines           00023300
         L     R8,LIMIT         get sieve limit                         00023400
         CVD   R8,NUMDEC        convert to decimal                      00023500
         ED    PRNTLINE+LIMITEBC+1(11),NUMDEC+3 format sieve limit      00023600
         PUT   SYSPRINT,CC      print number of primes and sieve limit  00023700
         MVC   TELLUSER(4),SUMWTOP get WTO prefix and suffix ..         00023800
         MVC   PRNTLINE+LSUMMARY(4),SUMWTOS .. around summary line      00023900
         WTO   MF=(E,TELLUSER)  print summary line in job log           00024000
*                                                                       00024100
* Cleanup and return                                                    00024200
*                                                                       00024300
         FREEMAIN VU,A=ISPRIME  release storage                         00024400
         CLOSE SYSPRINT         close printer                           00024500
         L     R13,4(,R13)      caller's save area pointer              00024600
         RETURN (14,12),RC=0    restore registers and return            00024700
*                                                                       00024800
* Data area                                                             00024900
*                                                                       00025000
SAVEA    DS    18F              save area                               00025100
MOVEPARM MVC   0(1,R3),2(R2)    EXecuted to retrieve PARM field         00025200
TESTPRIM TM    0(R6),0          EXecuted to test for being prime        00025300
CLRPRIM  NI    0(R10),0         EXecuted to cross out a prime multiple  00025400
NUMDEC   DS    D                target for decimal conversion           00025500
HIGHLIM  DC    F'2147483647'    highest possible fullword value         00025600
LIMIT    DC    F'2000'          default sieve limit                     00025700
FF       DC    X'FF000000'      prime flags initialization pattern      00025800
LPP      DC    H'64'            lines to print per page                 00025900
NPL      DC    H'15'            prime numbers to print per line         00026000
EIGHT    DC    H'8'             used for loops and comparisons          00026100
PARM     DC    10C' '           PARM field goes here                    00026200
PRIMFLGS DC    B'10000000'      .. the set      ..                      00026300
         DC    B'01000000'        .. bit's        ..                    00026400
         DC    B'00100000'          .. position     ..                  00026500
         DC    B'00010000'            .. represents   ..                00026600
         DC    B'00001000'              .. a            ..              00026700
         DC    B'00000100'                .. potential    ..            00026800
         DC    B'00000010'                  .. prime        ..          00026900
         DC    B'00000001'                    .. number       ..        00027000
CROSSOUT DC    B'01111111'      .. masks        ..                      00027100
         DC    B'10111111'        .. used         ..                    00027200
         DC    B'11011111'          .. to           ..                  00027300
         DC    B'11101111'            .. cross        ..                00027400
         DC    B'11110111'              .. out          ..              00027500
         DC    B'11111011'                .. none         ..            00027600
         DC    B'11111101'                  .. prime        ..          00027700
         DC    B'11111110'                    .. numbers      ..        00027800
         DS    0F                                                       00027900
TELLUSER DS    H                WTO plist for summary message goes here 00028000
NL       DC    C' '             newline carriage control                00028100
CC       DC    C'1'             formfeed on first output line           00028200
PRNTLINE DC    10C' '           line to be printed ..                   00028300
         DC    C'2'               .. the prime two is ..                00028400
         DC    154C' '            .. pre printed on initial line        00028500
         DC    C' '             filler to receive EDit garbage          00028600
SUMWTOP  DC    X'002D8000'      prefix for summary message WTO          00028700
SUMWTOS  DC    X'02000020'      suffix for summery message WTO          00028800
EDIT     DC    2C' ',9X'20'     EDit pattern to format 9 digits         00028900
         DC    C' primes up to' .. skeleton ..                          00029000
LIMITEBC EQU   *-EDIT             .. for      ..                        00029100
         DC    2C' ',9X'20'         .. summary  ..                      00029200
         DC    C' found'              .. line     ..                    00029300
LSUMMARY EQU   *-EDIT           summary line length                     00029400
SYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,                      X00029500
               RECFM=FBA,LRECL=166,BLKSIZE=16600  DCB for SYSPRINT      00029600
GETMAX   DC    F'8'             GETMAIN plist to obtain maximum ..      00029700
         DC    X'00FFFFF8'        .. storage available in region        00029800
ISPRIME  DS    F                address of allocated storage            00029900
MAXMEM   DS    F                amount of storage allocated             00030000
         YREGS ,                register equates                        00030100
         END   PRIMASM          end of PRIMASM                          00030200
/*                                                                      00030300
//GO.SYSPRINT DD SYSOUT=*                                               00030400
//                                                                      00030500
++FILE PASCALN.TESTPGM.CNTL                         MEMB PRIMZERL EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG PRIMZERL',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test PRIMZERL
//********************************************************************
//*
//COMPILE  EXEC PASNCL,MEM=PRIMZERL,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
//*
//GO       EXEC PGM=PRIMZERL
//STEPLIB  DD  DISP=SHR,DSN=PASCALN.TESTPGM.LOAD
//INPUT    DD  *
10000 11000
//OUTPUT   DD  SYSOUT=A,DCB=(RECFM=VB,LRECL=133)
//PASTRACE DD  SYSOUT=A
//SYSUDUMP DD  SYSOUT=A
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB SHOWHEX  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG SHOWHEX',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test SHOWHEX
//********************************************************************
//*
//COMPILE  EXEC PASNCL,MEM=SHOWHEX,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
//*
//GO       EXEC  PGM=SHOWHEX
//STEPLIB  DD  DISP=SHR,DSN=PASCALN.TESTPGM.LOAD
//SYSPRINT DD  SYSOUT=A
//OUTPUT   DD  SYSOUT=A,DCB=(RECFM=VB,LRECL=133)
//DRUCKER  DD  SYSOUT=A
//PASTRACE DD  SYSOUT=A
//INPTEXT  DD  DISP=SHR,DSN=PASCALN.RUNTIME.TEXT(PASMONN)
//SYSUDUMP DD  SYSOUT=A
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB SPLITMVS EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CL SPLITMVS',CLASS=A,MSGCLASS=X,               00000101
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000300
//********************************************************************  00000400
//* compile SPLITMVS utility                                            00000501
//* needed to SPLIT transfer file into individual members               00000601
//* distributed as object file on RUNTIME.TEXT                          00000701
//* needs to be linked before initial load of Pascal system             00000801
//********************************************************************  00000900
//*                                                                     00001000
//COMPOBJ EXEC PASNC,MEM=SPLITMVS,                                      00001101
//        SRC='PASCALN.TESTPGM.PAS',                                    00001200
//        OBJ='PASCALN.RUNTIME.TEXT'                                    00001301
//*                                                                     00001401
//LNKSPLIT EXEC PGM=IEWLF880                                            00001501
//SYSLIB   DD  DISP=SHR,DSN=PASCALN.RUNTIME.TEXT                        00001601
//SYSLMOD  DD  DISP=SHR,DSN=PASCALN.TESTPGM.LOAD                        00001701
//SYSPRINT DD  SYSOUT=*                                                 00001801
//SYSUT1   DD  UNIT=SYSDA,SPACE=(CYL,(1,1))                             00001901
//SYSLIN   DD  DDNAME=SYSIN                                             00002001
//SYSIN    DD  *                                                        00002101
  INCLUDE SYSLIB(SPLITMVS)                                              00002201
  INCLUDE SYSLIB(PASMONN)                                               00002301
  INCLUDE SYSLIB(PASLIBX)                                               00002401
  INCLUDE SYSLIB(PASUTILS)                                              00002501
  NAME SPLITMVS(R)                                                      00002601
//*                                                                     00002701
//COMP    EXEC PASNCL,MEM=SPLITMVS,                                     00002801
//        SRC='PASCALN.TESTPGM.PAS',                                    00002901
//        MOD='PASCALN.TESTPGM.LOAD'                                    00003001
//*                                                                     00003100
++FILE PASCALN.TESTPGM.CNTL                         MEMB SPLITPAS EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CL SPLITPAS',CLASS=A,MSGCLASS=X,               00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000300
//********************************************************************  00000400
//* Test compiler                                                       00000500
//********************************************************************  00000600
//*                                                                     00000700
//COMP    EXEC PASNCL,MEM=SPLITPAS,                                     00000800
//        SRC='PASCALN.TESTPGM.PAS',                                    00000900
//        MOD='PASCALN.TESTPGM.LOAD'                                    00001000
//*                                                                     00001100
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTAND  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTAND',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTAND
//********************************************************************
//*
//COMPGO  EXEC PASNCG,MEM=TESTAND,
//        SRC='PASCALN.TESTPGM.PAS'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTASM  EXT JOB HEX -
//PASCALNT JOB (PASCAL),'TEST TESTASM',CLASS=A,MSGCLASS=X,              00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000300
//COMPGO   EXEC PASNCLG,MEM=TESTASM,                                    00000400
//         SRC='PASCALN.TESTPGM.PAS',                                   00000500
//         MOD='PASCALN.TESTPGM.LOAD'                                   00000600
//LKED.ASMLIB DD DISP=SHR,DSN=PASCALN.TESTPGM.TEXT                      00000700
//LKED.SYSIN  DD *                                                      00000800
  INCLUDE ASMLIB(PAS2PAS)                                               00000901
  INCLUDE ASMLIB(PAS2ASM)                                               00001001
  INCLUDE ASMLIB(PAS2FTN)                                               00001100
  INCLUDE ASMLIB(PAS2FF)                                                00001200
  INCLUDE ASMLIB(PAS2AF)                                                00001300
//*                                                                     00001400
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTAVL  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTFPAR
//********************************************************************
//*
//COMP1   EXEC PASNCL,MEM=AVLTREE,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
//COMPGO  EXEC PASNCLG,MEM=TESTAVL,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//LKED.OBJLIB DD DISP=SHR,DSN=PASCALN.TESTPGM.LOAD                      00000700
//LKED.SYSIN  DD *                                                      00000800
  INCLUDE OBJLIB(AVLTREE)                                               00000901
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTCA3  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTCA3',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTCA3
//********************************************************************
//*
//COMPGO  EXEC PASNCG,MEM=TESTCA3,
//        SRC='PASCALN.TESTPGM.PAS'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTCOPY EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTCOPY
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTCOPY,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//GO.INP1    DD  DISP=SHR,DSN=PASCALN.TESTPGM.PAS(TESTCOPY)
//GO.OUT1    DD  SYSOUT=*
//GO.OUT2    DD  SYSOUT=*
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTDUPL EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTDUPL',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTDUPL
//********************************************************************
//*
//COMPGO  EXEC PASNCG,MEM=TESTDUPL,
//        SRC='PASCALN.TESTPGM.PAS'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTERR1 EXT JOB HEX -
//PASCALNT JOB (PASCAL),'TESTERR1',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//COMPGO   EXEC PASNCLG,MEM=TESTERR1,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTERR2 EXT JOB HEX -
//PASCALNT JOB (PASCAL),'TESTERR2',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//COMPGO   EXEC PASNCLG,MEM=TESTERR2,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTERR3 EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTERR3
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTERR3,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTFILE EXT JOB HEX -
//PASCALNT JOB (PASCAL),'TEST TESTFILE',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//COMPGO   EXEC PASNCLG,MEM=TESTFILE,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
//*
//GO.OUTFILE_  DD DISP=SHR,DSN=PASCALN.TESTPGM.PAS(X)
//GO.TXTFILE_  DD DISP=SHR,DSN=PASCALN.TESTPGM.PAS(Y)
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTFPAR EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTFPAR
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTFPAR,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTINP  EXT JOB HEX -
//PASCALNT JOB (PASCAL),'CLG TESTINP',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//COMPGO   EXEC PASNCLG,MEM=TESTINP,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
//LKED.SYSIN DD *
  INCLUDE SYSLIB(PASUTILS)
//*
//GO.INPUT DD  *
123
456
789
//*
//GO.EINGABE DD *
123456
//*
//GO.OUTPUT DD SYSOUT=A,DCB=(RECFM=VB,LRECL=133)
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTINTS EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTINTS
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTINTS,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTLAB  EXT JOB HEX -
//PASCALNT JOB (PASCAL),'TEST TESTLAB',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//COMPGO   EXEC PASNCLG,MEM=TESTLAB,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTM1   EXT JOB HEX -
//PASCALNT JOB (PASCAL),'TESTM1',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//COMPGO   EXEC PASNCLG,MEM=TESTM1,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTNF   EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTNF
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTNF,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTPAS  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTPAS',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTPAS
//********************************************************************
//*
//COMPGO  EXEC PASNCG
//*
//COMPILE.INPUT DD *
program Eratosthenes(input,output);
var a:ARRAY[1..800000] of boolean;
    N,i,j,m:integer;
begin
 read(N);
 i:=3;
 while i <= N do begin a[i]:=TRUE; i:=i+2; end;
 m:=trunc(sqrt(N));
 i:=3;
 while i <= m do begin
     if a[i] then begin
       j:=i;
       while j <= N DIV i do begin a[i*j]:=FALSE; j:=j+2; end;
     end;
     i:=i+2;
   end;
 i:=3;
 j:=1;
 write(2:8);
 while i <= N do begin if a[i] then begin j:=j+1; write(i:8); end;
   i:=i+2;
 end;
 m := 20-(j mod 20);
 if m <> 20 then for i:=1 to m do write('        ');
 writeln('0', j:7, ' primes up to ', N:7, ' found');
end.
/*
//GO.SYSIN  DD *
4000
/*
//
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTPDS  EXT JOB HEX -
//PASCALNT JOB (PASCAL),'TEST TESTPDS',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//COMPGO   EXEC PASNCLG,MEM=TESTPDS,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
//LKED.SYSIN DD *
  INCLUDE SYSLIB(PASUTILS)
//GO.PDS   DD  DISP=SHR,DSN=PASCALN.TESTPGM.CNTL
//GO.PDSOUT  DD  DISP=SHR,DSN=PASCALN.TESTPGM.COPY
//*O.PDS   DD  DISP=SHR,DSN=PASCALN.TEST.EINGABE
//*O.PDS   DD  DISP=SHR,DSN=PASCALN.TESTPGM.PAS
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTPTR2 EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTPTR2
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTPTR2,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTREAD EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTREAD
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTREAD,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//GO.INPFILE DD  DISP=SHR,DSN=PASCALN.TESTPGM.PAS(TESTREAD)
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSCAL EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTSCAL',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTSCAL
//********************************************************************
//*
//COMPGO  EXEC PASNCG,MEM=TESTSCAL,
//        SRC='PASCALN.TESTPGM.PAS'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSETH EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTSETH',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTSETH
//********************************************************************
//*
//COMPGO  EXEC PASNCG,MEM=TESTSETH,
//        SRC='PASCALN.TESTPGM.PAS'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSET5 EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTSET5
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTSET5,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSIN  EXT JOB HEX -
//PASCALNT JOB (PASCAL),'TESTSIN',CLASS=A,MSGCLASS=X,                   00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000300
//COMPGO   EXEC PASNCLG,MEM=TESTSIN,                                    00000400
//         SRC='PASCALN.TESTPGM.PAS',                                   00000500
//         MOD='PASCALN.TESTPGM.LOAD'                                   00000600
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSIN2 EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTSIN2',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTSIN2
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTSIN2,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSNA1 EXT JOB HEX -
//PASCALNT JOB (PASCAL),'TESTSNA1 SNAP',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//COMPGO   EXEC PASNCLG,MEM=TESTSNA1,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSNA2 EXT JOB HEX -
//PASCALNT JOB (PASCAL),'TESTSNA2 SNAP',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//COMPGO   EXEC PASNCLG,MEM=TESTSNA2,GOPARM='DUMP',
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSNA3 EXT JOB HEX -
//PASCALNT JOB (PASCAL),'TESTSNA3 SNAP',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//COMPGO   EXEC PASNCLG,MEM=TESTSNA3,
//         SRC='PASCALN.TESTPGM.PAS',
//         MOD='PASCALN.TESTPGM.LOAD'
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSQRT EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTSQRT',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTSQRT
//********************************************************************
//*
//COMPGO  EXEC PASNCG,MEM=TESTSQRT,
//        SRC='PASCALN.TESTPGM.PAS'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSTAT EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTSTAT',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTSTAT
//********************************************************************
//*
//COMPGO  EXEC PASNCG,MEM=TESTSTAT,
//        SRC='PASCALN.TESTPGM.PAS'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSTR1 EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTSTR1',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTSTR1
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTSTR1,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTSVAR EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTSVAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTSVAR
//********************************************************************
//*
//COMPGO  EXEC PASNCG,MEM=TESTSVAR,
//        SRC='PASCALN.TESTPGM.PAS'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTVARC EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTFPAR
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTVARC,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTVC2  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTFPAR
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTVC2,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTWRS  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTFPAR',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTWRS
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTWRS,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB TESTUML  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG TESTUML',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*
//********************************************************************
//* Test TESTUML
//********************************************************************
//*
//COMPGO  EXEC PASNCLG,MEM=TESTUML,
//        SRC='PASCALN.TESTPGM.PAS',
//        MOD='PASCALN.TESTPGM.LOAD'
//*
++FILE PASCALN.TESTPGM.CNTL                         MEMB XCOMP    EXT JOB HEX -
//PASCALNC JOB (PASCAL),'PASCAL COMPILE',CLASS=A,MSGCLASS=X,            00000102
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)
//*                                                                     00000302
//********************************************************************  00000402
//*                                                                     00000502
//* Test compiler                                                       00000602
//*                                                                     00000702
//********************************************************************  00000802
//*                                                                     00000902
//COMPILE EXEC PASNCL,MEM=XCOMP,                                        00001002
//        SRC='PASCALN.TESTPGM.PAS',                                    00001102
//        MOD='PASCALN.TESTPGM.LOAD'                                    00001202
//*                                                                     00001305
//GO      EXEC PGM=XCOMP,PARM='-W -M9'                                  00001402
//STEPLIB  DD  DISP=SHR,DSN=PASCALN.TESTPGM.LOAD                        00001500
//SYSPRINT DD  SYSOUT=A                                                 00001600
//INPUT    DD  *                                                        00001700
//OUTPUT   DD  SYSOUT=A,DCB=(RECFM=VB,LRECL=133)                        00001800
//DRUCKER  DD  SYSOUT=A                                                 00001900
//PASTRACE DD  SYSOUT=A                                                 00002000
//INFILE1  DD  DISP=SHR,DSN=PASCALN.COMPILER.PAS(PASSNAPC)              00002106
//INFILE2  DD  DISP=SHR,DSN=PASCALN.COMPILER.PAS(PASSNAP)               00002204
//SYSUDUMP DD  SYSOUT=A                                                 00002300
//QRD      DD  DISP=SHR,DSN=PASCALN.DBGINFO                             00002404
//*                                                                     00002500
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB DIMAG    EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040001040400001C4C9D4C1C7404040000000004000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4C9D4C1F0F0F0F1
++DATA1   80    0 02E3E7E3400000B840400038404000010000000000000000000000000000
++DATA2   80   30 00004E0000000000000000000000000000004E0000000000000000000000
++DATA3   80   60 000000000000000000000000C4C9D4C1F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000304040000147F0F00C06C4C9D4C1C7404090EC
++DATA2   80   30 D00C9823F028184D58D0F02450D040089034D00007F20000000000000000
++DATA3   80   60 000000004040404040404040C4C9D4C1F0F0F0F3
++DATA1   80    0 02E3E7E3400000F0404000384040000158201000D20FD078200007000520
++DATA2   80   30 5830200607F3000000005810D0045810101858201000D20F2000D0786800
++DATA3   80   60 D07058D0D00458E0D00C982CC4C9D4C1F0F0F0F4
++DATA1   80    0 02E3E7E3400001284040002840400001D01C92FFD00C07FE6800D0786820
++DATA2   80   30 D0806000D0606020D0686800D0686000D0701BFF5810D00007F140404040
++DATA3   80   60 404040404040404040404040C4C9D4C1F0F0F0F5
++DATA1   80    0 02E3E7E34000007840400010404000010000003000001020000020100000
++DATA2   80   30 300040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4C9D4C1F0F0F0F6
++DATA1   80    0 02E3E7E34000010440400004404000010000013040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4C9D4C1F0F0F0F7
++DATA1   80    0 02E3E7E34000002C40400004404000010000010840404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4C9D4C1F0F0F0F8
++DATA1   80    0 02E3E7E3400000284040000440400001000000F040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4C9D4C1F0F0F0F9
++DATA1   80    0 02E3E7E34000002440400004404000010000003040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4C9D4C1F0F0F1F0
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D00007C0D0000800D00
++DATA2   80   30 00840D0001040D00002C0D0000280D0000240C0000784040404040404040
++DATA3   80   60 404040404040404040404040C4C9D4C1F0F0F1F1
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040400000
++DATA2   80   30 015040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4C9D4C1F0F0F1F2
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB DREAL    EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040001040400001C4D9C5C1D3404040000000004000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4D9C5C1F0F0F0F1
++DATA1   80    0 02E3E7E3400000B840400038404000010000000000000000000000000000
++DATA2   80   30 00004E0000000000000000000000000000004E0000000000000000000000
++DATA3   80   60 000000000000000000000000C4D9C5C1F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000304040000147F0F00C06C4D9C5C1D3404090EC
++DATA2   80   30 D00C9823F028184D58D0F02450D040089034D00007F20000000000000000
++DATA3   80   60 000000004040404040404040C4D9C5C1F0F0F0F3
++DATA1   80    0 02E3E7E3400000F0404000384040000158201000D20FD078200007000520
++DATA2   80   30 5830200607F3000000005810D0045810101858201000D20F2000D0786800
++DATA3   80   60 D07058D0D00458E0D00C982CC4D9C5C1F0F0F0F4
++DATA1   80    0 02E3E7E3400001284040002840400001D01C92FFD00C07FE6800D0786820
++DATA2   80   30 D0806000D0606020D0686800D0606000D0701BFF5810D00007F140404040
++DATA3   80   60 404040404040404040404040C4D9C5C1F0F0F0F5
++DATA1   80    0 02E3E7E34000007840400010404000010000003000001020000020100000
++DATA2   80   30 300040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4D9C5C1F0F0F0F6
++DATA1   80    0 02E3E7E34000010440400004404000010000013040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4D9C5C1F0F0F0F7
++DATA1   80    0 02E3E7E34000002C40400004404000010000010840404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4D9C5C1F0F0F0F8
++DATA1   80    0 02E3E7E3400000284040000440400001000000F040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4D9C5C1F0F0F0F9
++DATA1   80    0 02E3E7E34000002440400004404000010000003040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4D9C5C1F0F0F1F0
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D00007C0D0000800D00
++DATA2   80   30 00840D0001040D00002C0D0000280D0000240C0000784040404040404040
++DATA3   80   60 404040404040404040404040C4D9C5C1F0F0F1F1
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040400000
++DATA2   80   30 015040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C4D9C5C1F0F0F1F2
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB FIOCS#   EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C6C9D6C3E27B4040000000004000
++DATA2   80   30 0160E2C5E3C2F9F940400100008C40000001D9C5E2C2F9F94040010000A6
++DATA3   80   60 400000014040404040404040E3D7F9F9F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040400002C9C8C3C5C6C9D6E2020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E3D7F9F9F0F0F0F2
++DATA1   80    0 02E3E7E3400000004040003840400001503010B418309500300047801020
++DATA2   80   30 9502300047201028583010B4581010BC07F191F0300147101032D20310BC
++DATA3   80   60 10C447F01016910420004710E3D7F9F9F0F0F0F3
++DATA1   80    0 02E3E7E340000038404000384040000110289101200047101074D502115D
++DATA2   80   30 200147701028D20310BC10C0910F30014780106A982310D0924020000630
++DATA3   80   60 0630443010AE982310D01810E3D7F9F9F0F0F0F4
++DATA1   80    0 02E3E7E340000070404000384040000147F1000658320000D502115D3001
++DATA2   80   30 183047F010485810103447F0106A501D0018D203F044100058110004D203
++DATA3   80   60 F0481000581D001807FED207E3D7F9F9F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040000C40400001F02AF02207FED200200120004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E3D7F9F9F0F0F0F6
++DATA1   80    0 02E3E7E3400000B840400020404000010000000000000084000000840000
++DATA2   80   30 0000000000D800000085000000D800000085404040404040404040404040
++DATA3   80   60 404040404040404040404040E3D7F9F9F0F0F0F7
++DATA1   80    0 02E3E7E34000015D40400003404000010000634040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E3D7F9F9F0F0F0F8
++DATA1   80    0 02D9D3C4404040404040002040404040000100010D0000B80D0000BC0D00
++DATA2   80   30 00C00D0000C80C0000D0000200011C0000C4404040404040404040404040
++DATA3   80   60 404040404040404040404040E3D7F9F9F0F0F0F9
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 4040F1C1E2D4C7F2F1C4C5C340F0F2F0F7F7F4F3F2F440F1F57AF5F37AF4
++DATA3   80   60 F540F2F040D5D6E540F7F440E3D7F9F9F0F0F1F0
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCADJST EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040001040400001C9C8C3C1C4D1E2E3000000004000
++DATA2   80   30 04E640404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C1C4D1E2F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0E00C07C2D5C4D9C1C4D1D217
++DATA2   80   30 E36810005020E3805810E374982DF0089101100B4710E32C9200E3E19200
++DATA3   80   60 E3E258F0100854F0E3C44BF0C1C4D1E2F0F0F0F2
++DATA1   80    0 02E3E7E3400000384040003840400001E3D4914010084710E30AD203E3C0
++DATA2   80   30 F0009580E3C047B0E2C0955FE3C047D0E2249201E3E09190E3C14770E31E
++DATA3   80   60 910FE3C04780E2809102E3C0C1C4D1E2F0F0F0F3
++DATA1   80    0 02E3E7E34000007040400038404000014710E2789101E3C04780E0849104
++DATA2   80   30 E3C04780E278D21FE3481000D201E1BAE3C095FFE3E34780E09C94F0E1BB
++DATA3   80   60 5810E37C950010004770E0E0C1C4D1E2F0F0F0F4
++DATA1   80    0 02E3E7E3400000A840400038404000015810E37895FF10054770E0C69500
++DATA2   80   30 10064780E0E04321000606204221000658F0E36CD201E0D2E37245E00000
++DATA3   80   60 58EE000847F0E0E000000000C1C4D1E2F0F0F0F5
++DATA1   80    0 02E3E7E3400000E04040003840400001182E4110E0EE0511000004800C00
++DATA2   80   30 0A0E18E25010E3885820E3645810E3C05410E3C81BFF95FFE3E34780E130
++DATA3   80   60 43F0E3C154F0E3CC4780E130C1C4D1E2F0F0F0F6
++DATA1   80    0 02E3E7E340000118404000384040000149F0E3D64780E2884720E29049F0
++DATA2   80   30 E3D84780E29844F0E3E443F0E3C28AF000044780E15449F0E3D64780E2A0
++DATA3   80   60 4720E2A849F0E3D84780E2B0C1C4D1E2F0F0F0F7
++DATA1   80    0 02E3E7E340000150404000384040000144F0E3E45010E38495FFE3E34780
++DATA2   80   30 E2E041F0000740F0E3DC44F0E3E6182E4110E17A0511020003F4095D0A0E
++DATA3   80   60 18E29501E3E04780E1BA98F2C1C4D1E2F0F0F0F8
++DATA1   80    0 02E3E7E3400001884040003840400001E35895FFE3E34780E1BA91F0E3C1
++DATA2   80   30 4710E1BA91E0E3C147E0E1BA9610E3E29200E1BB5800E3549101E3E247E0
++DATA3   80   60 E1BA5810E3585A00E3A050F0C1C4D1E2F0F0F0F9
++DATA1   80    0 02E3E7E3400001C04040003840400001E39005F050F0E38C58F0E3909501
++DATA2   80   30 E3E04780E1F29510E3E24740E2B84780E1E45010E3585000E3545810E374
++DATA3   80   60 D213100CE3549510E3E14770C1C4D1E2F0F0F1F0
++DATA1   80    0 02E3E7E3400001F84040003840400001E2045810E374D2001008E38C9501
++DATA2   80   30 E3E14770E2185810E38448F0E3DC44F0E3EC5810E3880A0E58E0E36807FE
++DATA3   80   60 9200E3E09550E3C04780E280C1C4D1E2F0F0F1F1
++DATA1   80    0 02E3E7E34000023040400038404000014740E258955CE3C04780E2484740
++DATA2   80   30 E270955DE3C04770E2789601E3E29110E3C14710E31E47F0E084954EE3C0
++DATA3   80   60 4780E2804720E0849544E3C0C1C4D1E2F0F0F1F2
++DATA1   80    0 02E3E7E34000026840400038404000014780E31E47F0E0649558E3C04780
++DATA2   80   30 E0849610E3E147F0E0849601E3E147F0E0845E10E35447F0E1305E10E358
++DATA3   80   60 47F0E1305E10E36047F0E130C1C4D1E2F0F0F1F3
++DATA1   80    0 02E3E7E3400002A040400038404000015E10E35447F0E1545E10E35847F0
++DATA2   80   30 E1545E10E36047F0E15490F2E35847F0E1E89598E3C04780E2D49590E3C0
++DATA3   80   60 4770E31E9201E3E192FFE3E3C1C4D1E2F0F0F1F4
++DATA1   80    0 02E3E7E3400002D840400038404000019200E3E047F0E0841BFF43F0E3C1
++DATA2   80   30 54F0E3D08AF0000440F0E3DE43F0E3C154F0E3CC4BF0E3DE4AF0E3D88BF0
++DATA3   80   60 000247F0E164918010084780C1C4D1E2F0F0F1F5
++DATA1   80    0 02E3E7E3400003104040003240400001E31A4BF0E3DA47F0E31E4AF0E3DA
++DATA2   80   30 50F0E3505810E374D2021009E3515820E36807004110E33E051100000000
++DATA3   80   60 00000A0E07F2404040404040C1C4D1E2F0F0F1F6
++DATA1   80    0 02E3E7E3400003C4404000184040000100FFFFFF00000FFF0000000F0000
++DATA2   80   30 00F00004000E000100024040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C1C4D1E2F0F0F1F7
++DATA1   80    0 02E3E7E3400003E04040001240400001000000001E10D200E3A01000D200
++DATA2   80   30 1000E3A04040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C1C4D1E2F0F0F1F8
++DATA1   80    0 02E3E7E3400003F4404000104040000150E0F01058E0F00C47F0E4080000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C1C4D1E2F0F0F1F9
++DATA1   80    0 02E3E7E34000040840400038404000019507100747D0E4DC9001E3709510
++DATA2   80   30 E3E14780E422D2001008E350D2021009E3519501E3E04780E46A9510E3E2
++DATA3   80   60 4740E4744780E448D2031010C1C4D1E2F0F0F2F0
++DATA1   80    0 02E3E7E34000044040400038404000011018D2031018E360D203100C1014
++DATA2   80   30 D2031014E35C5810E3880A0E58F0E36C9801E37058E0E40447F0F004D213
++DATA3   80   60 100CE35447F0E454D203100CC1C4D1E2F0F0F2F1
++DATA1   80    0 02E3E7E3400004784040001840400001E35447F0E454070050EF001058EF
++DATA2   80   30 000C47F0E494000000004040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C1C4D1E2F0F0F2F2
++DATA1   80    0 02E3E7E3400004944040003840400001D203E368E4905010E374D2021009
++DATA2   80   30 E351D213100CE35458F0E36CD201E4B6E37245E0000058EE000847F0E4C4
++DATA3   80   60 000000005810E38005010400C1C4D1E2F0F0F2F3
++DATA1   80    0 02E3E7E3400004CC4040001A4040000158F0E35054F0E3C44BF0E3D447F0
++DATA2   80   30 E31ED203E368E40447F0E49A404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C1C4D1E2F0F0F2F4
++DATA1   80    0 02D9D3C4404040404040001C40404040000100010D0000DC090000E90900
++DATA2   80   30 01750D0004000D00048C0C0004C040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C1C4D1E2F0F0F2F5
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F74BF5F44040F161F0F661
++DATA3   80   60 F7F140404040404040404040C1C4D1E2F0F0F2F6
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCGOTO EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040002040400001C9C8C3C3C7D6E3D6000000004000
++DATA2   80   30 0038C3C7D6E3D67B40400100000040000001404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E3400000004040003240400001122247C0F00E492E000047C0F01A
++DATA2   80   30 483E00008B30000147F3E0068B200001D203F034E0025830F0344A32E004
++DATA3   80   60 5823000007F240404040404040404040F0F0F0F2
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F74BF5F44040F161F0F661
++DATA3   80   60 F7F14040404040404040404040404040F0F0F0F3
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCLABS EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3D3C1C2E2000000004000
++DATA2   80   30 00BCC4E2D8D9E34040400200000040404040C3C4C1C2E240404001000000
++DATA3   80   60 400000014040404040404040C3D3C1C2F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C3C4C1C2E290E1D00C
++DATA2   80   30 58110000686100006821000830663022296247A0F02A2802282628602806
++DATA3   80   60 2F0229064780F0722D262422C3D3C1C2F0F0F0F2
++DATA1   80    0 02E3E7E34000003840400038404000012C226E20F0B018ED41D0F08C50ED
++DATA2   80   30 000450DE00086020F0A84110F08458F0F08805EF4700030258D0E03698E1
++DATA3   80   60 D00C7960F0B84740F07A2C06C3D3C1C2F0F0F0F3
++DATA1   80    0 02E3E7E34000007040400012404000012A002B2292FFD00C07FE2A662C06
++DATA2   80   30 47F0F0724040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C1C2F0F0F0F4
++DATA1   80    0 02E3E7E3400000844040000840400001800000A800000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C1C2F0F0F0F5
++DATA1   80    0 02E3E7E3400000B04040000C404000014040000000000001002000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C1C2F0F0F0F6
++DATA1   80    0 02D9D3C44040404040400010404040400001000108000085000200010C00
++DATA2   80   30 008840404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C1C2F0F0F0F7
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F74BF5F44040F161F0F661
++DATA3   80   60 F7F140404040404040404040C3D3C1C2F0F0F0F8
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCLAS  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3D3C1E240000000004000
++DATA2   80   30 00D8C3C4D4D7E87B40400100000040000001C3C4C4E5C47B40400100001C
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C3C4D4D7E87B0090EF
++DATA2   80   30 D00C9201F0BA41FF001C47F0F01447F0F00C06C3C4C4E5C47B0090EFD00C
++DATA3   80   60 9200F09E58E10000680E000040404040F0F0F0F2
++DATA1   80    0 02E3E7E3400000384040003840400001682E000858E10004684E0000686E
++DATA2   80   30 00086040F0A46060F0AC9101F09E4780F0582C622C2428406C40F0AC6C00
++DATA3   80   60 F0A42B062A2458ED000C92FF40404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000704040003840400001D00C07FE2044206629466840F0A4
++DATA2   80   30 6860F0AC4720F07628602802232623646840F0AC2D042D242D6428462C66
++DATA3   80   60 6A60F0B46060F0A428642C4240404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000A840400012404000012C602A042B266D00F0A46D20F0A4
++DATA2   80   30 47F0F04E4040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000D040400008404000014110000000000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F74BF5F44040F161F0F661
++DATA3   80   60 F7F14040404040404040404040404040F0F0F0F7
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCLEXP EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3D3C5E7D7000000004000
++DATA2   80   30 0239C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C4C5E7D740404040020000004040
++DATA2   80   30 4040C4E2C9D5404040400200000040404040C4C3D6E24040404002000000
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040001040404040C3C4C5E7D7404040010000004000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F0F3
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C3C4C5E7D790E2D00C
++DATA2   80   30 182F18FD41D0212450FD000450DF000858E10000680E0000682E00086020
++DATA3   80   60 211030227920217047A02090C3D3C5E7F0F0F0F4
++DATA1   80    0 02E3E7E34000003840400038404000017900216C4720208258F0217805EF
++DATA2   80   30 4700030828604110217458F0217C05EF4700030A600021084110217458F0
++DATA3   80   60 218005EF4700030C58D02128C3D3C5E7F0F0F0F5
++DATA1   80    0 02E3E7E340000070404000384040000128262C026C20210898E2D00C92FF
++DATA2   80   30 D00C07FE411021FC92F121A51BEE47F0209C4110221C92F221A541E00008
++DATA3   80   60 D20321AE1004D21421E51008C3D3C5E7F0F0F0F6
++DATA1   80    0 02E3E7E3400000A84040003840400001600021085010219458F02120902E
++DATA2   80   30 D00C413021B7412E2108440F005A0501081710004133001C440F004E0501
++DATA3   80   60 0810982ED00C58F021844110C3D3C5E7F0F0F0F7
++DATA1   80    0 02E3E7E3400000E04040002840400001218C180E05EF411021989500218B
++DATA2   80   30 4770201E6800211812004780204A58D021282B002B2247F0207840404040
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F0F8
++DATA1   80    0 02E3E7E3400001184040000C404000017FFFFFFFFFFFFFFF000000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F0F9
++DATA1   80    0 02E3E7E34000016C4040001C4040000142AEAC4F4DC90FDA800001100000
++DATA2   80   30 000000000000000000000000000040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F1F0
++DATA1   80    0 02E3E7E34000018C40400008404000010000019C00000188404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F1F1
++DATA1   80    0 02E3E7E3400001984040001640400001800001080000005AC9C8C3F2F85C
++DATA2   80   30 C940C3C4C5E7D74040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F1F2
++DATA1   80    0 02E3E7E3400001B2404000054040000140C1D9C77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F1F3
++DATA1   80    0 02E3E7E3400001CE40400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F1F4
++DATA1   80    0 02E3E7E3400001E340400002404000015D40404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F1F5
++DATA1   80    0 02E3E7E3400001FA4040003840400001000000000119D9C5C1D3C7E340F1
++DATA2   80   30 F7F44BF6F7F340404040404040404040400000000000011AC9D4C1C7C1C2
++DATA3   80   60 E240E5C1D3E4C540C7C540D7C3D3C5E7F0F0F1F6
++DATA1   80    0 02E3E7E3400002324040000740400001C95CF25C5CF5F040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F1F7
++DATA1   80    0 02D9D3C440404040404000344040404000010001090001750D00018C0D00
++DATA2   80   30 019008000199000200011C000120000300011C000184000400010C000178
++DATA3   80   60 000500010C00017C40404040C3D3C5E7F0F0F1F8
++DATA1   80    0 02D9D3C4404040404040000840404040000600010C000180404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3C5E7F0F0F1F9
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F74BF5F54040F161F0F661
++DATA3   80   60 F7F140404040404040404040C3D3C5E7F0F0F2F0
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCLLOG EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3D3D3D6C7000000004000
++DATA2   80   30 01D5C4D3D6C7404040400200000040404040C4C1E3C1D5F2404002000000
++DATA3   80   60 404040404040404040404040C3D3D3C7F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C3C4D3D6C7404040010000004000
++DATA2   80   30 0001C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040C3D3D3C7F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C3C4D3D6C790E2D00C
++DATA2   80   30 182F18FD41D0213850FD000450DF000858E10000680E0000682E000850E0
++DATA3   80   60 218441EE000850E021809280C3D3D3C7F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001218430003022290247A0204A2840
++DATA2   80   30 280228242F202E2070002100702021041B0041E00041430021001B0E8B00
++DATA3   80   60 000247A0207410005E002130C3D3D3C7F0F0F0F4
++DATA1   80    0 02E3E7E340000070404000384040000141E0004042E0210042E021045600
++DATA2   80   30 21345000212078002100782021042C002C222A02478020D8600021004110
++DATA3   80   60 218058F0218805EF47000310C3D3D3C7F0F0F0F5
++DATA1   80    0 02E3E7E3400000A8404000384040000160002108411021A058F0218C05EF
++DATA2   80   30 47000312684021206C40212824002A046820210858D0213C98E2D00C92FF
++DATA3   80   60 D00C07FE6000210860002110C3D3D3C7F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400020404000014110219058F021A405EF4110219C
++DATA2   80   30 950021AF4770201E2B226800211847F020CA404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3D3C7F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040002040400001FFFFFFFFFFFFFFFF000000000000
++DATA2   80   30 000040B17217F7D1CF7B7FFFFFFC46000000404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3D3C7F0F0F0F8
++DATA1   80    0 02E3E7E34000018840400024404000010000000000000000000001B00000
++DATA2   80   30 01AC000001A88000010880000100000000000000011B4040404040404040
++DATA3   80   60 404040404040404040404040C3D3D3C7F0F0F0F9
++DATA1   80    0 02E3E7E3400001B0404000254040000100000021C9C8C3F2F8F3C940C3C4
++DATA2   80   30 D3D6C740C1D9C7E4D4C5D5E37EF04BC4F04EF04BC4F0C940404040404040
++DATA3   80   60 404040404040404040404040C3D3D3C7F0F0F1F0
++DATA1   80    0 02D9D3C4404040404040003040404040000100010D0001900D0001940D00
++DATA2   80   30 01980900019D080001A1000200010C00018C000300010C00018800050001
++DATA3   80   60 1C0001A44040404040404040C3D3D3C7F0F0F1F1
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F74BF5F54040F161F0F661
++DATA3   80   60 F7F140404040404040404040C3D3D3C7F0F0F1F2
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCLSCN EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3D3E2C3D5000000004000
++DATA2   80   30 0308C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040C3D3E2C3F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C4E2C9D540404040020000004040
++DATA2   80   30 4040C4C3D6E2404040400200000040404040C4C5E7D74040404002000000
++DATA3   80   60 404040404040404040404040C3D3E2C3F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040002040404040C3C4E2C9D5404040010000164000
++DATA2   80   30 0001C3C4C3D6E24040400100000040000001404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2C3F0F0F0F3
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C3C4C3D6E290E3D00C
++DATA2   80   30 9200F0B945F0F02847F0F00A05C3C4E2C9D590E3D00C92F0F0A3183D41D0
++DATA3   80   60 F1FA50D300085030F1FE182FC3D3E2C3F0F0F0F4
++DATA1   80    0 02E3E7E340000038404000384040000158E10000680E0000682E00086020
++DATA2   80   30 21AA3000790021EA47A020FA58F0224205EF470003146000219258130018
++DATA3   80   60 58F0224605EF470003166000C3D3E2C3F0F0F0F5
++DATA1   80    0 02E3E7E3400000704040003840400001219A682021AA3022792021EE4720
++DATA2   80   30 2108602021A24110226658F0224A05EF4700031818D3684021B22D406820
++DATA3   80   60 21A2792021F2474020C62B04C3D3E2C3F0F0F0F6
++DATA1   80    0 02E3E7E3400000A84040003840400001242028022A04918021AA478020A2
++DATA2   80   30 3122470020B46C00219A6C202192332247F020BC6C0021926C20219A98E3
++DATA3   80   60 D00C92FFD00C07FE792021F6C3D3E2C3F0F0F0F7
++DATA1   80    0 02E3E7E3400000E04040003840400001474020942C2228026C0021BA6A00
++DATA2   80   30 21C22C026A0021CA2C026A0021D22C026A0021DA2C206C2021A26A2021A2
++DATA3   80   60 47F020944110226A92F4229BC3D3E2C3F0F0F0F8
++DATA1   80    0 02E3E7E34000011840400038404000011BEE47F021144110227E41E00008
++DATA2   80   30 92F5229B5833001858330000D20721A23000D20322AB1004D20A22E61008
++DATA3   80   60 5010226258F0224E502D000CC3D3E2C3F0F0F0F9
++DATA1   80    0 02E3E7E3400001504040003840400001413022B6412E21A2440F005A0501
++DATA2   80   30 081710004133001C440F004E05010810582D000C58F022564110225A180E
++DATA3   80   60 05EF41102266583D00045013C3D3E2C3F0F0F1F0
++DATA1   80    0 02E3E7E34000018840400020404000010018950022554770202218D32B00
++DATA2   80   30 2B221200478020BC680021E2282047F02098404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2C3F0F0F1F1
++DATA1   80    0 02E3E7E3400001C8404000384040000141100000000000003A6C11A069B2
++DATA2   80   30 EA823C2E3BA8BC90245F3DD00D01083D72C53F222222221F51A6402AAAAA
++DATA3   80   60 AAAAAB667F7FFFFFFFFFFFFFC3D3E2C3F0F0F1F2
++DATA1   80    0 02E3E7E34000020040400010404000014DC90FDA42AEAC4F407B30B33A10
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2C3F0F0F1F3
++DATA1   80    0 02E3E7E34000025840400010404000010000000000000000000000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2C3F0F0F1F4
++DATA1   80    0 02E3E7E34000026C4040000C4040000100000000000002A8000002684040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2C3F0F0F1F5
++DATA1   80    0 02E3E7E34000027C4040003840400001800001B80000011CD9C5C1D3C7C5
++DATA2   80   30 40D7C95CF25C5CF5F0000000011DC9D4C1C7C7E340F1F7F44BF6F7F34000
++DATA3   80   60 0000005BC9C8C3F2F85CC940C3D3E2C3F0F0F1F6
++DATA1   80    0 02E3E7E3400002B44040000D40400001C3C4E2C9D560C3C4C3D6E2406140
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2C3F0F0F1F7
++DATA1   80    0 02E3E7E3400002C5404000074040000140C1D9C7617E6140404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2C3F0F0F1F8
++DATA1   80    0 02E3E7E3400002E340400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2C3F0F0F1F9
++DATA1   80    0 02E3E7E3400002F840400004404000015D616B4040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2C3F0F0F2F0
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D0002700D0002740800
++DATA2   80   30 027D000200010C000264000300011C00026C000400010C00025800050001
++DATA3   80   60 0C00025C000600010C000260C3D3E2C3F0F0F2F1
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F84BF1F84040F161F0F661
++DATA3   80   60 F7F140404040404040404040C3D3E2C3F0F0F2F2
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCLSQT EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3D3E2D8E3000000004000
++DATA2   80   30 0134C4E2D8D9E34040400200000040404040C3C4E2D8D9E3404001000000
++DATA3   80   60 400000014040404040404040C3D3E2D9F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C3C4E2D8D9E34090E3
++DATA2   80   30 D00C183F18FD41D030F050FD000450DF0008582100006862000068220008
++DATA3   80   60 306630222846296247A0303CC3D3E2D9F0F0F0F2
++DATA1   80    0 02E3E7E34000003840400038404000012862282428062F02290658F030EC
++DATA2   80   30 478030DE2D2624222C226E20311860203110411030E805EF470003046822
++DATA3   80   60 0000302279203130474030C4C3D3E2D9F0F0F0F3
++DATA1   80    0 02E3E7E340000070404000384040000124222C067900310C47A030D06860
++DATA2   80   30 31202A0260003110411030E805EF47000306682200087842000058D030F4
++DATA3   80   60 98E3D00C2C064780F0BE2D20C3D3E2D9F0F0F0F4
++DATA1   80    0 02E3E7E3400000A840400038404000012422324447A0F0BE284020023222
++DATA2   80   30 47A0F0BC3144282492FFD00C07FE2A662C066860312847F0308024002422
++DATA3   80   60 686031282A6647F030802904C3D3E2D9F0F0F0F5
++DATA1   80    0 02E3E7E3400000E040400008404000014780307C47F030C8404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2D9F0F0F0F6
++DATA1   80    0 02E3E7E3400000E840400008404000018000011000000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2D9F0F0F0F7
++DATA1   80    0 02E3E7E34000010C40400004404000017F80000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2D9F0F0F0F8
++DATA1   80    0 02E3E7E3400001184040001C404000014040000000000001411000000000
++DATA2   80   30 000040B504F333F9DE650020000040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2D9F0F0F0F9
++DATA1   80    0 02D9D3C440404040404000104040404000010001080000E9000200010C00
++DATA2   80   30 00EC40404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3D3E2D9F0F0F1F0
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F84BF1F94040F161F0F661
++DATA3   80   60 F7F140404040404040404040C3D3E2D9F0F0F1F1
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCSABS EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3E2C1C2E2000000004000
++DATA2   80   30 00B4E2D8D9E3404040400200000040404040C3C1C2E24040404001000000
++DATA3   80   60 400000014040404040404040C3E2C1C2F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C3C1C2E24090E1D00C
++DATA2   80   30 58110000786100007821000430663022396247A0F02A3802382638603806
++DATA3   80   60 3F0239064780F0723D263422C3E2C1C2F0F0F0F2
++DATA1   80    0 02E3E7E34000003840400038404000013C227E20F0AC18ED41D0F08C50ED
++DATA2   80   30 000450DE00087020F0A84110F08458F0F08805EF4700020258D0E03698E1
++DATA3   80   60 D00C7960F0B04740F07A3C06C3E2C1C2F0F0F0F3
++DATA1   80    0 02E3E7E34000007040400012404000013A003B2292FFD00C07FE3A663C06
++DATA2   80   30 47F0F0724040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2C1C2F0F0F0F4
++DATA1   80    0 02E3E7E3400000844040000840400001800000A800000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2C1C2F0F0F0F5
++DATA1   80    0 02E3E7E3400000AC40400008404000014040000100200000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2C1C2F0F0F0F6
++DATA1   80    0 02D9D3C44040404040400010404040400001000108000085000200010C00
++DATA2   80   30 008840404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2C1C2F0F0F0F7
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F84BF2F04040F161F0F661
++DATA3   80   60 F7F140404040404040404040C3E2C1C2F0F0F0F8
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCSAS  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3E2C1E240000000004000
++DATA2   80   30 00C4C3D4D7E87B4040400100000040000001C3C4E5C47B4040400100001A
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C3D4D7E87B90EFD00C
++DATA2   80   30 9201F0B641FF001A47F0F01247F0F00A05C3C4E5C47B90EFD00C9200F09C
++DATA3   80   60 58E10000780E0000782E000440404040F0F0F0F2
++DATA1   80    0 02E3E7E340000038404000384040000158E10004784E0000786E00047040
++DATA2   80   30 F09E7060F0A29101F09C4780F0563C623C2438407C40F0A27C00F09E3B06
++DATA3   80   60 3A2458ED000C92FFD00C07FE40404040F0F0F0F3
++DATA1   80    0 02E3E7E34000007040400038404000013044306639467840F09E7860F0A2
++DATA2   80   30 4720F07438603802332633647840F0A23D043D243D6438463C667A60F0A6
++DATA3   80   60 7060F09E38643C423C603A0440404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000A84040000E404000013B267D00F09E7D20F09E47F0F04C
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000C040400004404000014110000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F84BF2F14040F161F0F661
++DATA3   80   60 F7F14040404040404040404040404040F0F0F0F7
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCSEXP EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3E2C5E7D7000000004000
++DATA2   80   30 021DC9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040C3E2C5E7F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C5E7D74040404040020000004040
++DATA2   80   30 4040E2C9D540404040400200000040404040C3D6E2404040404002000000
++DATA3   80   60 404040404040404040404040C3E2C5E7F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040001040404040C3C5E7D740404040010000004000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2C5E7F0F0F0F3
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C3C5E7D74090E2D00C
++DATA2   80   30 182F18FD41D020EC50FD000450DF000858E10000780E0000782E00047020
++DATA3   80   60 213830227920214047A0208CC3E2C5E7F0F0F0F4
++DATA1   80    0 02E3E7E34000003840400038404000017900213C4720208258F0214805EF
++DATA2   80   30 4700020838604110214458F0214C05EF4700020A700021344110214458F0
++DATA3   80   60 215005EF4700020C58D020F0C3E2C5E7F0F0F0F5
++DATA1   80    0 02E3E7E340000070404000384040000138263C027C20213498E2D00C92FF
++DATA2   80   30 D00C07FE4110216C1BEE47F02094411021C041E000047000213458F02154
++DATA3   80   60 9013D00C4131002A412E2134C3E2C5E7F0F0F0F6
++DATA1   80    0 02E3E7E3400000A84040003840400001440F00560501040E070041330013
++DATA2   80   30 440F004E050104089813D00C58F02168180E05EF41102178950021674770
++DATA3   80   60 201E7800215812004780204AC3E2C5E7F0F0F0F7
++DATA1   80    0 02E3E7E3400000E04040000C4040000158D020F03B003B2247F020784040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2C5E7F0F0F0F8
++DATA1   80    0 02E3E7E34000013C404000284040000142AEAC4F45C90000800001380000
++DATA2   80   30 00000000000000000000000000007FFFFFFF0000010F0000011040404040
++DATA3   80   60 404040404040404040404040C3E2C5E7F0F0F0F9
++DATA1   80    0 02E3E7E3400001684040002E40400001000000000000017C000001640000
++DATA2   80   30 015C800001340000003EC9C8C3F2F7F1C940C3C5E7D740D9C5C1D340C1D9
++DATA3   80   60 C77E40404040404040404040C3E2C5E7F0F0F1F0
++DATA1   80    0 02E3E7E3400001A440400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2C5E7F0F0F1F1
++DATA1   80    0 02E3E7E3400001B140400038404000015D6B40C7E340F1F7F44BF6F7F300
++DATA2   80   30 00000001D000000164000001608000013400000049C9C8C3F2F7F2C940C3
++DATA3   80   60 C5E7D740C9D4C1C740C1D9C7C3E2C5E7F0F0F1F2
++DATA1   80    0 02E3E7E3400001E940400001404000017E40404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2C5E7F0F0F1F3
++DATA1   80    0 02E3E7E3400001F840400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2C5E7F0F0F1F4
++DATA1   80    0 02E3E7E34000020540400018404000015D6B40C1C2E240E5C1D3E4C540C7
++DATA2   80   30 C540D7C95CF25C5CF1F84040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2C5E7F0F0F1F5
++DATA1   80    0 02D9D3C440404040404000384040404000010001090001450D00016C0D00
++DATA2   80   30 01700D000174090001790D0001C00D0001C40D0001C8080001CD00020001
++DATA3   80   60 0C000154000300011C000168C3E2C5E7F0F0F1F6
++DATA1   80    0 02D9D3C4404040404040001840404040000400010C000148000500010C00
++DATA2   80   30 014C000600010C0001504040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2C5E7F0F0F1F7
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F84BF2F14040F161F0F661
++DATA3   80   60 F7F140404040404040404040C3E2C5E7F0F0F1F8
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCSLOG EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3E2D3D6C7000000004000
++DATA2   80   30 01BAC9C8C3C5D9D9D4400200000040404040C1D3D6C74040404002000000
++DATA3   80   60 404040404040404040404040C3E2D3C7F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C1E3C1D5F2404040020000004040
++DATA2   80   30 4040C9C2C3D6D47B40400200000040404040C3D3D6C74040404001000000
++DATA3   80   60 400000014040404040404040C3E2D3C7F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C3D3D6C74090E2D00C
++DATA2   80   30 182F18FD41D020FC50FD000450DF000858E10000780E0000782E000450E0
++DATA3   80   60 216841EE000450E021649280C3E2D3C7F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001216830003022390247A0204A3840
++DATA2   80   30 380238243F203E2070002154702021581B0041E00041430021541B0E8B00
++DATA3   80   60 000247A0207410005E002178C3E2D3C7F0F0F0F4
++DATA1   80    0 02E3E7E340000070404000384040000141E0004042E0215442E021587800
++DATA2   80   30 2154782021585600217C500021583C003C223A02478020D4700021544110
++DATA3   80   60 216458F0217005EF47000210C3E2D3C7F0F0F0F5
++DATA1   80    0 02E3E7E3400000A8404000384040000138604110216C58F0217405EF4700
++DATA2   80   30 0212784021587C40215C34002A04382658D0210098E2D00C92FFD00C07FE
++DATA3   80   60 700021807000218441102144C3E2D3C7F0F0F0F6
++DATA1   80    0 02E3E7E3400000E04040001C4040000158F0218805EF411021509500218F
++DATA2   80   30 4770201E3B227800219447F020C640404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2D3C7F0F0F0F7
++DATA1   80    0 02E3E7E3400001444040001040400001000001980000018C000001908000
++DATA2   80   30 018040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2D3C7F0F0F0F8
++DATA1   80    0 02E3E7E34000015C404000084040000140B1721900000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2D3C7F0F0F0F9
++DATA1   80    0 02E3E7E34000016C40400014404000018000015400000000000000007FFF
++DATA2   80   30 FFFC46000000404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2D3C7F0F0F1F0
++DATA1   80    0 02E3E7E34000018840400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2D3C7F0F0F1F1
++DATA1   80    0 02E3E7E3400001904040002A4040000100000111FFFFFFFF0000001EC9C8
++DATA2   80   30 C3F2F7F3C940C3D3D6C740C1D9C7E4D4C5D5E37EF04BF04EF04BF0C94040
++DATA3   80   60 404040404040404040404040C3E2D3C7F0F0F1F2
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D0001440D0001480D00
++DATA2   80   30 014C090001510800016D000200011C000188000300010C00017400040001
++DATA3   80   60 0C000170000500010C000160C3E2D3C7F0F0F1F3
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F84BF2F24040F161F0F661
++DATA3   80   60 F7F140404040404040404040C3E2D3C7F0F0F1F4
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCSSCN EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3E2E2C3D5000000004000
++DATA2   80   30 02C4C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040C3E2E2C3F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004E2C9D54040404040020000004040
++DATA2   80   30 4040C3D6E240404040400200000040404040C5E7D7404040404002000000
++DATA3   80   60 404040404040404040404040C3E2E2C3F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040002040404040C3E2C9D540404040010000164000
++DATA2   80   30 0001C3C3D6E2404040400100000040000001404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2C3F0F0F0F3
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C3C3D6E24090E3D00C
++DATA2   80   30 9200F0BD45F0F02847F0F00A04C3E2C9D54090E3D00C92F0F0A7183D41D0
++DATA3   80   60 F16E50D300085030F172182FC3E2E2C3F0F0F0F4
++DATA1   80    0 02E3E7E340000038404000384040000158E10000780E0000782E00047000
++DATA2   80   30 21BE702021C23000790021DA47A020EC58F0216205EF47000214700021B6
++DATA3   80   60 5813001858F0216605EF4700C3E2E2C3F0F0F0F5
++DATA1   80    0 02E3E7E34000007040400038404000010216700021BA782021C230227920
++DATA2   80   30 21DE472020F6702021BE4110225E58F0216A05EF4700021818D3784021EA
++DATA3   80   60 3D40782021BE792021E24740C3E2E2C3F0F0F0F6
++DATA1   80    0 02E3E7E3400000A8404000384040000120CA3B04342038023A04918021C2
++DATA2   80   30 478020A63122470020B87C0021BA7C2021B6332247F020C07C0021B67C20
++DATA3   80   60 21BA98E3D00C92FFD00C07FEC3E2E2C3F0F0F0F7
++DATA1   80    0 02E3E7E3400000E04040003840400001792021E6474020983C2238027C00
++DATA2   80   30 21EE7A0021F23C207C2021BE7A2021BE47F0209841E021F61B3347F020FE
++DATA3   80   60 41E022524130000458F0215EC3E2E2C3F0F0F0F8
++DATA1   80    0 02E3E7E34000011840400038404000019023D00C412321BE413E0032440F
++DATA2   80   30 00560501040E070041330013440F004E05010408181E9823D00C58F021C6
++DATA3   80   60 05EF18E3583D000441102202C3E2E2C3F0F0F0F9
++DATA1   80    0 02E3E7E340000150404000344040000150130018950021CD477020223B00
++DATA2   80   30 3B2218D312EE478020C0780021D6382047F0209C00000000000000000000
++DATA3   80   60 000000000000000040404040C3E2E2C3F0F0F1F0
++DATA1   80    0 02E3E7E3400001DC40400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2C3F0F0F1F1
++DATA1   80    0 02E3E7E3400001E4404000384040000100000112000001137F7FFFFF45C9
++DATA2   80   30 000042AEAC4F4058B90C3E100000411000003F2244F1402AAA960000021C
++DATA3   80   60 000001E0000001E4800001D4C3E2E2C3F0F0F1F2
++DATA1   80    0 02E3E7E34000021C404000224040000100000048C9C8C3F2F7F4C940C3E2
++DATA2   80   30 C9D560C3C3D6E24061D9C5C1D340C1D9C7617E6140404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2C3F0F0F1F3
++DATA1   80    0 02E3E7E34000024C40400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2C3F0F0F1F4
++DATA1   80    0 02E3E7E34000025940400038404000015D616B40C7C540D7C95CF25C5CF1
++DATA2   80   30 F800000278000001E0000001E8800001D400000047C9C8C3F2F7F5C940C3
++DATA3   80   60 E2C9D560C3C3D6E24061C9D4C3E2E2C3F0F0F1F5
++DATA1   80    0 02E3E7E3400002914040000940400001C1C740C1D9C7617E614040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2C3F0F0F1F6
++DATA1   80    0 02E3E7E3400002A840400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2C3F0F0F1F7
++DATA1   80    0 02E3E7E3400002B54040000E404000015D616B40C7E340F1F7F44BF6F7F3
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2C3F0F0F1F8
++DATA1   80    0 02D9D3C4404040404040003440404040000100010D00020C0D0002100D00
++DATA2   80   30 0214090002190D0002680D00026C0D00027008000275000200010C000174
++DATA3   80   60 000300011C0001DC40404040C3E2E2C3F0F0F1F9
++DATA1   80    0 02D9D3C4404040404040001840404040000400010C000178000500010C00
++DATA2   80   30 017C000600010C0001804040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2C3F0F0F2F0
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F84BF2F34040F161F0F661
++DATA3   80   60 F7F140404040404040404040C3E2E2C3F0F0F2F1
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCCSSQT EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C3E2E2D8E3000000004000
++DATA2   80   30 0120E2D8D9E3404040400200000040404040C3E2D8D9E340404001000000
++DATA3   80   60 400000014040404040404040C3E2E2D9F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C3E2D8D9E390E3D00C
++DATA2   80   30 183F18FD41D030EC50FD000450DF00085821000078620000782200043066
++DATA3   80   60 30223846396247A0303A3862C3E2E2D9F0F0F0F2
++DATA1   80    0 02E3E7E3400000384040003840400001382438063F02390658F030E84780
++DATA2   80   30 30D83D2634223C227E20310C70203108411030E405EF4700020438247920
++DATA3   80   60 311C474030BE34223C067900C3E2E2D9F0F0F0F3
++DATA1   80    0 02E3E7E3400000704040003840400001311847A030CA786031103A027000
++DATA2   80   30 3108411030E405EF47000206782200047842000058D030F098E3D00C3C06
++DATA3   80   60 4780F0B83D203422324447A0C3E2E2D9F0F0F0F4
++DATA1   80    0 02E3E7E3400000A84040003840400001F0B838403002322247A0F0B63144
++DATA2   80   30 382492FFD00C07FE3A663C067860311447F0307A34003422786031143A66
++DATA3   80   60 47F0307A39044780307647F0C3E2E2D9F0F0F0F5
++DATA1   80    0 02E3E7E3400000E0404000024040000130C2404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2D9F0F0F0F6
++DATA1   80    0 02E3E7E3400000E440400008404000018000010800000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2D9F0F0F0F7
++DATA1   80    0 02E3E7E34000010C4040001440400001404000014110000040B504F37F80
++DATA2   80   30 000000200000404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2D9F0F0F0F8
++DATA1   80    0 02D9D3C440404040404000104040404000010001080000E5000200010C00
++DATA2   80   30 00E840404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C3E2E2D9F0F0F0F9
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F3F0E2C5D7F6F940F1F84BF2F34040F161F0F661
++DATA3   80   60 F7F140404040404040404040C3E2E2D9F0F0F1F0
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCDBUG  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C4C2E4C740000000004000
++DATA2   80   30 07F9C1C4C3D6D57B40400200000040404040C4C5C2E4C77B404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400003C9C8C3E4C1E3C2D3020000004040
++DATA2   80   30 4040C6C9D6C3E27B40400200000040404040C9C2C3D6D47B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F03447F0F05A47F0F07A47F0
++DATA2   80   30 F08C47F0F09647F0F0C247F0F12447F0F19E47F0F21A47F0F22047F0F226
++DATA3   80   60 47F0F28247F0F29291F0F76C40404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000014780E004900DF6944140F64FD205
++DATA2   80   30 F649F7985820E0004510F42041E0E00447F0F4AA900DF6944140F658D208
++DATA3   80   60 F649F7BC5890D0045890901040404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001D205F652900547F0F4AA900DF694
++DATA2   80   30 4140F65AD210F649F7C547F0F4AAD203F690E00047F0E004D300F77CE009
++DATA3   80   60 D100F779E009D201F77AE00A40404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040003840400001900DF6944400F7781BCC43C0E008
++DATA2   80   30 4510F3FE41E0E00C47F0F35ED300F77CE009D100F779E009D201F77AE00A
++DATA3   80   60 900DF6944400F7781BCC43C040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E04040003840400001E0084510F3FE924D400041404001
++DATA2   80   30 189B5830E00C9500E00C4780F100583030001B931B881B334330E0081D83
++DATA3   80   60 412090014510F420925D400040404040F0F0F0F7
++DATA1   80    0 02E3E7E34000011840400038404000014140400141E0E01047F0F35E9500
++DATA2   80   30 F76D4770F184909EF6CCD207F164E000D200F16CE00CD300F16DE00D1BAA
++DATA3   80   60 43AE000C18CA58BE001058BB40404040F0F0F0F8
++DATA1   80    0 02E3E7E340000150404000144040000100001CAA189B58BE00081A9B50B0
++DATA2   80   30 F17045E0F0C2404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E34000016C40400004404000010000B00040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02E3E7E34000017440400038404000011ABC19B94740F160989EF6CC47F0
++DATA2   80   30 E014900EF69492FFF649D202F64AF6CD4140F64D41E0E01447F0F4AAD100
++DATA3   80   60 F779E009D201F77AE00A900D40404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001AC4040003840400001F6944400F7785830E00C9500E00C
++DATA2   80   30 4780F1C2583030005840E010585040001B664360E0081C461BB315B547B0
++DATA3   80   60 F1E2980DF69447F0E014D20640404040F0F0F1F2
++DATA1   80    0 02E3E7E3400001E44040003840400001F649F7D64140F6504510F402924D
++DATA2   80   30 4000414040011BAA1B224320E0081DA24120B0014510F420925D40004140
++DATA3   80   60 400141E0E01447F0F4AA96F040404040F0F0F1F3
++DATA1   80    0 02E3E7E34000021C4040003840400001F76C07FE940FF76C07FE900EF694
++DATA2   80   30 9500F76D4780F244D219F649F79E4140F66341E0E00847F0F4AA1B225A20
++DATA3   80   60 F6904770F2565830F780432040404040F0F0F1F4
++DATA1   80    0 02E3E7E3400002544040001C4040000130065020F270D203F274E000182F
++DATA2   80   30 58F0E00458F0F000070045E0F00040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F5
++DATA1   80    0 02E3E7E340000278404000384040000118F2980EF69447F0E00892FBF777
++DATA2   80   30 9280F76DD203F768F78407FED200F76EF76D9200F76D9140F76E078E900E
++DATA3   80   60 F72C188F9608876C9507876F40404040F0F0F1F6
++DATA1   80    0 02E3E7E3400002B040400038404000014780833C9120876E471082C45830
++DATA2   80   30 876892073000D2028769877141D086E44140864945C08562495087B84780
++DATA3   80   60 82FA495087BA478082F2425040404040F0F0F1F7
++DATA1   80    0 02E3E7E3400002E8404000384040000140004140400147F082D245C085B4
++DATA2   80   30 47F082CE45C085624250864D45C085624250864E45C085624250864F5830
++DATA3   80   60 864CD2138324300018F8070040404040F0F0F1F8
++DATA1   80    0 02E3E7E340000320404000044040000145E0F01840404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F9
++DATA1   80    0 02E3E7E340000338404000384040000147F082CE9120876E47808352D218
++DATA2   80   30 864987DD4140866245C085B418F894F7876C980EF72C07FED2024000F7F6
++DATA3   80   60 41404003D203F630B0001B5540404040F0F0F2F0
++DATA1   80    0 02E3E7E34000037040400038404000014350F77C885000021B22416000F8
++DATA2   80   30 14658860000147F6F38447F0F3C447F0F3DA47F0F3E6924D400041404001
++DATA3   80   60 88C0000145A0F472412BC00040404040F0F0F2F1
++DATA1   80    0 02E3E7E3400003A84040003840400001926B40004140400145A0F47889C0
++DATA2   80   30 0001925D40004140400147F0F4AA92C640004405F3E612224780F3BC92E3
++DATA3   80   60 400047F0F3BC4405F3E6451040404040F0F0F2F2
++DATA1   80    0 02E3E7E3400003E04040003840400001F42047F0F4AA45A0F47247F0F4AA
++DATA2   80   30 4320F6305820F6304820F6305820F6304140F649183E92403006D2004000
++DATA3   80   60 30004140400141303001954040404040F0F0F2F3
++DATA1   80    0 02E3E7E340000418404000384040000130004770F40807F112224770F430
++DATA2   80   30 92F040004140400107F14720F43C92604000414040014E20F630F3F7F630
++DATA3   80   60 F63096F0F63F4130F630412040404040F0F0F2F4
++DATA1   80    0 02E3E7E3400004504040003840400001001095F030004770F46241303001
++DATA2   80   30 4620F4524420F46C4142400007F1D20040003000187E188F182B18345810
++DATA3   80   60 F7885811003C47FCF48247F040404040F0F0F2F5
++DATA1   80    0 02E3E7E3400004884040003840400001F49A05010817100018E718F84144
++DATA2   80   30 001707FA0501040E070018E718F84144000E07FA41D0F6E4187E188F9500
++DATA3   80   60 876D477084DE58F0878C95FF40404040F0F0F2F6
++DATA1   80    0 02E3E7E3400004C04040003840400001F07C478084D058E0F06C980D8694
++DATA2   80   30 07FE45C085B418E718F8980DF69407FE9640876D413086499120876D4710
++DATA3   80   60 84D44350300045C0850C413040404040F0F0F2F7
++DATA1   80    0 02E3E7E3400004F8404000384040000130011934474084E64150001545C0
++DATA2   80   30 850C47F084D4582087745860876895FB87774770854C4510852A00000100
++DATA3   80   60 0000076820000A0412FF478040404040F0F0F2F8
++DATA1   80    0 02E3E7E3400005304040003840400001853C920760009620876D07FC9237
++DATA2   80   30 6000D203600187681B225860876842506000412020014160600150208774
++DATA3   80   60 5060876807FC58608768953740404040F0F0F2F9
++DATA1   80    0 02E3E7E340000568404000384040000160004780857A95076000477085A4
++DATA2   80   30 9601876ED203876860014510858E000001000000077000000A059101876E
++DATA3   80   60 4710833C586087685060877040404040F0F0F3F0
++DATA1   80    0 02E3E7E3400005A0404000384040000147F0856E1B554350600041606001
++DATA2   80   30 5060876807FC95008693477085C658308780D200869330065810878C90EF
++DATA3   80   60 107C9108876C471085E0D20740404040F0F0F3F1
++DATA1   80    0 02E3E7E3400005D840400038404000011084869447F085ECD2071084872C
++DATA2   80   30 D203107C87644120869058108790050100FF47F0861E5B408794194347D0
++DATA3   80   60 86081843064044408628412440404040F0F0F3F2
++DATA1   80    0 02E3E7E3400006104040001E404000010001581087900501020047000000
++DATA2   80   30 58F0878C92FFF07C07FCD200200086484040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F3
++DATA1   80    0 02E3E7E34000064840400001404000014040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F4
++DATA1   80    0 02E3E7E34000069040400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F5
++DATA1   80    0 02E3E7E34000076C40400003404000010000004040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F6
++DATA1   80    0 02E3E7E34000077440400009404000010000000041B00000004040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F7
++DATA1   80    0 02E3E7E3400007804040003840400001000000000000076F000000000000
++DATA2   80   30 00000000000000000648E3D9C1C3C540C4C9E2D7D3C1E840C4E4D9C9D5C7
++DATA3   80   60 40C961D640E2D2C9D7D7C5C440404040F0F0F3F8
++DATA1   80    0 02E3E7E3400007B8404000384040000100FF0015E2E4C2E3D9C1C3C540E2
++DATA2   80   30 E4C2E3D9C1C3C5405CD9C5E3E4D9D55CE2E4C2C3C8D240E2D6D4C540C4C5
++DATA3   80   60 C2E4C740D6E4E3D7E4E340D440404040F0F0F3F9
++DATA1   80    0 02E3E7E3400007F04040000940400001C9E2E2C9D5C7407E404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F0
++DATA1   80    0 02D9D3C4404040404040003440404040000100010D0005240D0005880D00
++DATA2   80   30 07840C000794000200011C000788000300011C000780000400011C000790
++DATA3   80   60 000500011C00078C4040404040404040F0F0F4F1
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F0F8C1D7D9F7F040F0F74BF0F14040F361F2F261
++DATA3   80   60 F7F14040404040404040404040404040F0F0F4F2
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCDIOSE EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C4C9D6E2C5000000004000
++DATA2   80   30 0A08C4C9D6C3E27B40400100000040000001C6C4C9D6C3E27B4002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400003C9C2C3D6D47B4040020000004040
++DATA2   80   30 4040C9C8C3E4C1E3C2D30200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C4C9D6C3E27B0090EC
++DATA2   80   30 D00C58C0F91C184D41D0F92850D40008504D000458A0F91018411B22D500
++DATA3   80   60 4000A0044780F0684324000040404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000014580F6D49101200F4780F0509101
++DATA2   80   30 20034780F0605042000C918040084710F0704144000C47F0F028411000EB
++DATA3   80   60 47F0F5D0411000EA47F0F5D040404040F0F0F0F4
++DATA1   80    0 02E3E7E34000007040400038404000015830F91850C0300058D0F92C98EC
++DATA2   80   30 D00C92FFD00C07FE90EC18AE50D018A658C0189641D018EA58A0C88A58B0
++DATA3   80   60 C93218401B55435400008B5040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040003840400001000247F5C02847F0C03C47F0C3A8
++DATA2   80   30 47F0C44447F0C4C447F0C5581842914040004780C04A9640C95258240000
++DATA3   80   60 910140004780C05A5822000040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000014020A000412200004580C64E9101
++DATA2   80   30 200F4710C5145872000CD203C93E7008910120034780C376584700045844
++DATA3   80   60 000095E470044770C0948B4040404040F0F0F0F7
++DATA1   80    0 02E3E7E340000118404000384040000100025940C94647B0C52C410000B8
++DATA2   80   30 4510C0A40A0A5012000018B19200B000D24EB001B0004150B0505050B020
++DATA3   80   60 5050B03C4040B01E4040B03A40404040F0F0F0F8
++DATA1   80    0 02E3E7E3400001504040003840400001D267B050C76E4040B08E4040B068
++DATA2   80   30 4860A0004E60C89AF342C89AC89F96F0C89ED201B07AC89D9200C7D650B0
++DATA3   80   60 C93607004510C1020000000040404040F0F0F0F9
++DATA1   80    0 02E3E7E340000188404000384040000150510000928010000A409500C7D6
++DATA2   80   30 4780C51C9120C83A4780C1209620B0749120C83A47E0C12C9620B0749201
++DATA3   80   60 B0649501C82E4780C140920240404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001C04040003840400001B0649620B00191C0C82D4740C280
++DATA2   80   30 5840C8B6910F40014780C3624150B05059B0C9364770C0F0943FC82D9640
++DATA3   80   60 C82D9202B0649202B098924040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001F84040001A40400001B06A9200B0829220B0839200B084
++DATA2   80   30 9120C83B4780C18C9220B084404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02E3E7E340000212404000384040000107004510C1960000000050510000
++DATA2   80   30 928F10000A169680B0014580C61A4840B01E1A445850B0244580C67C5867
++DATA3   80   60 0000586600004190B018509040404040F0F0F1F3
++DATA1   80    0 02E3E7E34000024A4040003840400001B0084150B0345050B0109220B008
++DATA2   80   30 9220B01018199220100558F1000858F0F03005EF94DFB0084580C63E4580
++DATA3   80   60 C6B64660C1D64880B062498040404040F0F0F1F4
++DATA1   80    0 02E3E7E3400002824040003840400001B08E4740C20A4160000147F0C1D6
++DATA2   80   30 4580C63E4580C6B64150B0504510C21E0000000050510000928010000A14
++DATA3   80   60 947FB0019200B0989220B06A40404040F0F0F1F5
++DATA1   80    0 02E3E7E3400002BA40400038404000019229B0829228B0839201B0849120
++DATA2   80   30 B0014710C2C44110B05058F010149601101748E0F0044CE0F00691011020
++DATA3   80   60 4710C26C4100E00847F0C27040404040F0F0F1F6
++DATA1   80    0 02E3E7E3400002F240400038404000014100E0104110F0000A0A9201B064
++DATA2   80   30 D702B065B0651B004300B064890000084300B08E890000084300B08F4110
++DATA3   80   60 B0504000101888000010400040404040F0F0F1F7
++DATA1   80    0 02E3E7E34000032A40400038404000011016410000001311070045F0C2C2
++DATA2   80   30 0000034000000000C9C5C3D8C2C6C7F10A064150B05007004510C2D20000
++DATA3   80   60 000050510000928410000A1340404040F0F0F1F8
++DATA1   80    0 02E3E7E34000036240400038404000019610B00158670000586600005060
++DATA2   80   30 B0044150B0185050B0084150B0345050B0104580C61A9220B0089220B010
++DATA3   80   60 4150B00D5050B0304150B01540404040F0F0F1F9
++DATA1   80    0 02E3E7E34000039A40400038404000015050B04C5840C8B6D200B0004001
++DATA2   80   30 5850C8BE91F0B0004780C352586500085960C93A47D0C35A586600001266
++DATA3   80   60 47C0C5240660910FB000471040404040F0F0F2F0
++DATA1   80    0 02E3E7E3400003D24040003840400001C50047F0C3B05865000447F0C332
++DATA2   80   30 4166000047F0C33E5840C8BE914040004710C4E8411000EC47F0C53458B0
++DATA3   80   60 20009110B0014710C318415040404040F0F0F2F1
++DATA1   80    0 02E3E7E34000040A4040003840400001B0509180B0014780C0D84510C396
++DATA2   80   30 0000000050510000928010000A14947FB00147F0C0D85860C94241660001
++DATA3   80   60 5960B00447B0C5245060C94240404040F0F0F2F2
++DATA1   80    0 02E3E7E34000044240400038404000015890B0084580C612596400004780
++DATA2   80   30 C4389120B0014780C4044580C63E4580C612596400004780C4389120B008
++DATA3   80   60 4710C4089140B0084710C40440404040F0F0F2F3
++DATA1   80    0 02E3E7E34000047A40400038404000019180B0084780C4084580C63E4580
++DATA2   80   30 C6124580C6B65064000018199608100558F0100858F0F03005EF9280B008
++DATA3   80   60 9140C9524710C4C44580C6B640404040F0F0F2F4
++DATA1   80    0 02E3E7E3400004B240400038404000015829000C4830B01E47F0C4C491C0
++DATA2   80   30 B0084780C40C47F0C4205890B0084580C612586400005960B00447B0C524
++DATA3   80   60 5060C942181994C6100558F040404040F0F0F2F5
++DATA1   80    0 02E3E7E3400004EA4040003840400001100858F0F03005EF9240B0084166
++DATA2   80   30 00019120B0014780C4904580C63E9120B0084710C49491C0B0084780C494
++DATA3   80   60 4580C6B64580C6125064000040404040F0F0F2F6
++DATA1   80    0 02E3E7E3400005224040003840400001943FB0085829000C4830B01E1843
++DATA2   80   30 185291F0B0004710C4F84580C6AE5840C8B6950040004780C5FC5840C93E
++DATA3   80   60 5850C942415500019140C95240404040F0F0F2F7
++DATA1   80    0 02E3E7E34000055A40400038404000014710C4DC415500019101C93E4710
++DATA2   80   30 C4F05054000094BFC95247F0C5FC4054000047F0C4E84580C67C47F0C4C4
++DATA3   80   60 5960B00447B0C5245890B00840404040F0F0F2F8
++DATA1   80    0 02E3E7E34000059240400038404000015060C94247F0C480411000E747F0
++DATA2   80   30 C534411000DB47F0C534411000E847F0C534411000E947F0C53458F0C88E
++DATA3   80   60 58D0F0B8D20FD00CF07C50D040404040F0F0F2F9
++DATA1   80    0 02E3E7E3400005CA4040003840400001F0C841D0F0C45010C97A4110C96E
++DATA2   80   30 58F0C94E07FF4120A008414000104850A0024155A000910120034710C5F8
++DATA3   80   60 9101200F4710C5F858B2000040404040F0F0F3F0
++DATA1   80    0 02E3E7E34000060240400038404000019190B0014780C5E45890B0084580
++DATA2   80   30 C6B691A0B0014780C59C4580C63E4580C6B64160B050181658F010149601
++DATA3   80   60 101748E0F0044CE0F006910140404040F0F0F3F1
++DATA1   80    0 02E3E7E34000063A404000384040000110204710C5C24100E00847F0C5C6
++DATA2   80   30 4100E0104110F0000A0A07004510C5D60000000050610000928010000A14
++DATA3   80   60 946FB001410000B8181B411140404040F0F0F3F2
++DATA1   80    0 02E3E7E340000672404000384040000100000A0A960120039601200F8724
++DATA2   80   30 C56850B0C93258D0C8A698E1C8AE984CC8C6181047F01006584900180640
++DATA3   80   60 07F85850B06441505008505040404040F0F0F3F3
++DATA1   80    0 02E3E7E3400006AA4040003840400001B0249501B0644780C6364A50B068
++DATA2   80   30 5050B040D201B068B08E07F85890B010D203B010B0085090B00807F81222
++DATA3   80   60 47C0C66806208B200004492040404040F0F0F3F4
++DATA1   80    0 02E3E7E3400006E24040003840400001A00247B0C6684122A00807F84180
++DATA2   80   30 80005980C896411000DC4740C54A47F0C534924050000640124407884940
++DATA3   80   60 C94A4720C69606404440C6A840404040F0F0F3F5
++DATA1   80    0 02E3E7E34000071A404000384040000107F8D2FF500150004B40C94A4155
++DATA2   80   30 010047F0C686D200500150009200500047F0C6809120B008071841109000
++DATA3   80   60 58E0100858F0E03405EF962040404040F0F0F3F6
++DATA1   80    0 02E3E7E3400007524040003840400001B0089140B0014710C6D807F894BF
++DATA2   80   30 B001181547F0C5349640B001914090014710C778911090024710C7729180
++DATA3   80   60 90014710C772188E9180B00140404040F0F0F3F7
++DATA1   80    0 02E3E7E34000078A40400038404000014780C72041F0F000070056F0C716
++DATA2   80   30 47F0C71A020000000A4447F0C73441F0F000070056F0C72E47F0C7320400
++DATA3   80   60 00000A44185141000070451040404040F0F0F3F8
++DATA1   80    0 02E3E7E3400007C24040003840400001C73E0A0A5010C96ED21A1004C953
++DATA2   80   30 D24C101F5032415000685050100041F0F000070056F0C76647F0C76AFF00
++DATA3   80   60 00000A44415000DA07F8415040404040F0F0F3F9
++DATA1   80    0 02E3E7E3400007FA4040000A4040000100E807FE415000ED07FE40404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F0
++DATA1   80    0 02E3E7E34000080440400038404000010000000000000001000020000000
++DATA2   80   30 0001000000018000090CC6E3E7E7C6F0F0F1020029280100000100000768
++DATA3   80   60 00000000000000010000000140404040F0F0F4F1
++DATA1   80    0 02E3E7E34000083C40400020404000010000000100000001000000000000
++DATA2   80   30 000100000001000000010000000100000001404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F2
++DATA1   80    0 02E3E7E34000085C40400038404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F4F3
++DATA1   80    0 02E3E7E34000089440400038404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F4F4
++DATA1   80    0 02E3E7E3400008CC40400038404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F4F5
++DATA1   80    0 02E3E7E340000904404000384040000100000000000000008700085C0000
++DATA2   80   30 000000000000000000000000008600000000000000000000000000000000
++DATA3   80   60 00000970000000000000000040404040F0F0F4F6
++DATA1   80    0 02E3E7E34000093C40400038404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F4F7
++DATA1   80    0 02E3E7E34000097440400038404000010000092800000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F4F8
++DATA1   80    0 02E3E7E3400009AC4040000C404000010000000000000000000000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F9
++DATA1   80    0 02E3E7E3400009C040400038404000010100000000000000000000000000
++DATA2   80   30 7FF9010000100000000000C9C8C3F2F1F8C940C4C9D6C3E2406040C961D6
++DATA3   80   60 40C5D9D9D6D940400000000040404040F0F0F5F0
++DATA1   80    0 02E3E7E3400009F840400010404000010000000080000A00000000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F5F1
++DATA1   80    0 02D9D3C4404040404040003440404040000100010D000338090008190D00
++DATA2   80   30 082C0900090D0D00091C0D0009300D000974080009FD000200011C000918
++DATA3   80   60 000300011C0009144040404040404040F0F0F5F2
++DATA1   80    0 02D9D3C4404040404040001040404040000400011C000910000500011C00
++DATA2   80   30 09D440404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F5F3
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F5F4
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCECOMH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C5C3D6D4C8000000004000
++DATA2   80   30 0F49C9C2C3D6D47B40400100000040000001C6C4C9D6C3E27B40010000BC
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400002C1C4C3D6D57B4040020000004040
++DATA2   80   30 4040C6C9D6C3E27B40400200000040404040C1D9C9E3C87B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040003040400005C1C4D1E2E6E3C3C8020000004040
++DATA2   80   30 4040C9C8C3E4D6D7E3400200000040404040C9D5E3E2E6E3C3C801000F2E
++DATA3   80   60 40000001404040404040404040404040F0F0F0F3
++DATA1   80    0 02C5E2C4404040404040003040400007C6C3E5C5D6E4E3D7020000004040
++DATA2   80   30 4040C6C3E5D3D6E4E3D70200000040404040C6C3E5C9D6E4E3D702000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02C5E2C440404040404000304040000AC6C3E5C3D6E4E3D7020000004040
++DATA2   80   30 4040C6C3E5C1D6E4E3D70200000040404040C6C3E5E9D6E4E3D702000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++DATA1   80    0 02C5E2C440404040404000304040000DE2C5D8C4C1E2C440020000004040
++DATA2   80   30 4040C9C8C3C5D9D9C5400200000040404040C9C8C3C3D6D4C8F202000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02C5E2C4404040404040003040400010C9C8C3C5D9D9D440020000004040
++DATA2   80   30 4040C9C8C3C3D6D4C8F200000F5040000651E2C5D8C4C1E2C440010012BC
++DATA3   80   60 40000011404040404040404040404040F0F0F0F7
++DATA1   80    0 02C5E2C4404040404040001040400012C9C2C3D6D47B4040020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E340000000404000384040000147F0F11C47F0F12447F0F50647F0
++DATA2   80   30 F53E47F0F68047F0FAE847F0FAF047F0FB3647F0FB8447F0FCD847F0FD4E
++DATA3   80   60 47F0FD7447F0FD8847F0FD9C40404040F0F0F0F9
++DATA1   80    0 02E3E7E340000038404000044040000147F0FDB040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02E3E7E340000040404000384040000147F0FDC447F0FDD400005810FE2C
++DATA2   80   30 5810FE505810FE445810FE3C5810FE3C5810FE405810FE485810FE4C0000
++DATA3   80   60 000001F0000092FFFF2E920040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400000784040000340400001FF2E004040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02E3E7E34000007C4040003840400001FF00000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F1F3
++DATA1   80    0 02E3E7E3400000B44040000C404000010000000000000000000000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F4
++DATA1   80    0 02E3E7E3400000C440400004404000010000013C40404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F5
++DATA1   80    0 02E3E7E3400001144040003840400001000000000000000092F0F1A547F0
++DATA2   80   30 F12892FFF1A595FFF07C4770F1F090EDF07C4130000841D0F19E50E0FE00
++DATA3   80   60 9200FE2B1B111B229012F10C40404040F0F0F1F6
++DATA1   80    0 02E3E7E34000014C40400038404000015810FE2C182ED207FE88E0009180
++DATA2   80   30 FE884780F1685810F0BC413030049110FE884780F17C585320005050F10C
++DATA3   80   60 413030049120FE884780F19040404040F0F0F1F7
++DATA1   80    0 02E3E7E3400001844040003840400001585320005050F1104130300441E2
++DATA2   80   30 300050E0F07C5010FE3007FD41E0F1B60501000047F0F1D45020FE984183
++DATA3   80   60 2000189207FE1B775070FF0040404040F0F0F1F8
++DATA1   80    0 02E3E7E3400001BC40400038404000015070FE1C5070FF0458A0FE8C91FF
++DATA2   80   30 FE8C4750F7D847F0F1F892FFFF004120F69C1926078692FFFE2B9200FF01
++DATA3   80   60 9200FE2A47F0F4EC5850FE0C40404040F0F0F1F9
++DATA1   80    0 02E3E7E3400001F44040001A4040000147F053321B554350A0008B500001
++DATA2   80   30 4950F25A47A0F25C47F5F20E404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F0
++DATA1   80    0 02E3E7E34000020E404000384040000147F0F9A647F0F29047F0F2A247F0
++DATA2   80   30 F2D447F0F2E247F0F48247F0F48847F0F48847F0F4A047F0F2EC47F0F4A8
++DATA3   80   60 47F0F4B047F0F31C47F0F35240404040F0F0F2F1
++DATA1   80    0 02E3E7E340000246404000384040000147F0F3AC47F0F3EE47F0F46C47F0
++DATA2   80   30 F3FA47F0F4B8004C5830FDE4D20730803054924030A450A0300C9280300C
++DATA3   80   60 45E0F6F847F0F27E47F0F1F840404040F0F0F2F2
++DATA1   80    0 02E3E7E34000027E404000384040000149D0FEFC4740F3FAD209FE14FE20
++DATA2   80   30 47F0F3FA41A0A0011BDD50A0FE1450D0FE1847F0F1F84370A00141D0D001
++DATA3   80   60 49D0FEFC4740F2C4D203FE2040404040F0F0F2F3
++DATA1   80    0 02E3E7E3400002B64040003840400001FE14D201FE28FE1CD203FE24FE18
++DATA2   80   30 4270FE1C4270FE1D41A0A00247F0F296D200FE1EA00141A0A00247F0F1F8
++DATA3   80   60 D200FE1FA00147F0F2DA437040404040F0F0F2F4
++DATA1   80    0 02E3E7E3400002EE4040003840400001A00106705840FE981A471B484740
++DATA2   80   30 F3084550F6AE1A4947F0F30A1A485990FF0447C0F3165090FF04189447F0
++DATA3   80   60 F2DA4370A00141A0A002910F40404040F0F0F2F5
++DATA1   80    0 02E3E7E3400003264040003840400001F1A54710F3381A9719984720F6AE
++DATA2   80   30 47F0F1F819984740F3424550F6AE92409000419090014670F33847F0F1F8
++DATA3   80   60 4370A00141A0A00218481B4940404040F0F0F2F6
++DATA1   80    0 02E3E7E34000035E4040003840400001197447D0F38A910FF1A54780F6AE
++DATA2   80   30 12444780F3821B7406404440FEE24194900141A4A0014550F6AE47F0F35A
++DATA3   80   60 0670910FF1A54710F39C447040404040F0F0F2F7
++DATA1   80    0 02E3E7E3400003964040003840400001FEDC47F0F3A04470FEE241979001
++DATA2   80   30 41A7A00147F0F1F841A0A00191FEFE1C4750F3D806D049D0FEFA4740F1F8
++DATA3   80   60 D203FE14FE20D201FE1CFE2840404040F0F0F2F8
++DATA1   80    0 02E3E7E3400003CE4040003840400001D203FE18FE2447F0F1F858A0FE14
++DATA2   80   30 58D0FE184370FE1C06704270FE1C47F0F1F84560F42041A0A00147F0F1F8
++DATA3   80   60 92FFFF0047F0F4EC91FFFE2B40404040F0F0F2F9
++DATA1   80    0 02E3E7E34000040640400038404000014710F4EC4560F420D200FE1CFE1D
++DATA2   80   30 58A0FE1458D0FE1847F0F1F89023FE90910FF1A54710F4349201F45647F0
++DATA3   80   60 F4509202F45618295920FF0440404040F0F0F3F0
++DATA1   80    0 02E3E7E34000043E404000384040000147A0F4465820FF04D703FF04FF04
++DATA2   80   30 5B20FE985810FE300501000047F0F1D45020FE984183200018929823FE90
++DATA3   80   60 07F692FFFF03D200F480A00240404040F0F0F3F1
++DATA1   80    0 02E3E7E3400004764040003840400001D200F481FE1F47F0F49200001B55
++DATA2   80   30 47F0F48C41500001D200F625FE1FD201F623A00141A0A00347F0F4CC4150
++DATA3   80   60 000547F0F4BC4150000A47F040404040F0F0F3F2
++DATA1   80    0 02E3E7E3400004AE4040003840400001F4BC4150000347F0F4BC4150000B
++DATA2   80   30 D200F623A001D201F624FEF841A0A0028B500003910FF1A54780F4DC4150
++DATA3   80   60 500491FFFF004780F4EC920040404040F0F0F3F3
++DATA1   80    0 02E3E7E3400004E64040003840400001FF004560F5AA91FFFE2A4710F5AA
++DATA2   80   30 91FFFF014710F59C904DFE6098EDF07C07FED203FE90E00041E0E00490ED
++DATA3   80   60 F07CD200F622FE90D300FF0840404040F0F0F3F4
++DATA1   80    0 02E3E7E34000051E4040003840400001FE919400FE90940FFE91D603FE90
++DATA2   80   30 FEF44400FE90984DFE604560F5AA47F0F4ECD207FE90E00041E0E00890ED
++DATA3   80   60 F07C984DFE60D200F622FE9440404040F0F0F3F5
++DATA1   80    0 02E3E7E3400005564040003840400001D300FF08FE959400FE94940FFE95
++DATA2   80   30 58C0FE945820FE9092FFFF011BBB43B0F62291FFFE904780F58243B0FE90
++DATA3   80   60 9180FF084780F5984370F62240404040F0F0F3F6
++DATA1   80    0 02E3E7E34000058E40400038404000018A7000014270F6221BB74560F5AA
++DATA2   80   30 1A2B46C0F5989200FF0147F0F4EC91FFFF004710F4029180FF084710F64E
++DATA3   80   60 91FFFF034780F5EED201F62440404040F0F0F3F7
++DATA1   80    0 02E3E7E3400005C64040003840400001F480415000609560FF0847A0F5DE
++DATA2   80   30 D201F624FEF84350FF088A500001910FF1A54780F5EE415050044370F623
++DATA3   80   60 127747C0F62A41479000194840404040F0F0F3F8
++DATA1   80    0 02E3E7E3400005FE404000384040000147D0F61618429057FDF44550F6AE
++DATA2   80   30 9857FDF4182447F0F5F818395810FE345815100005010000000041979000
++DATA3   80   60 91FEFE1E4780F6464370FE1E40404040F0F0F3F9
++DATA1   80    0 02E3E7E340000636404000384040000106704270FE1E91FFFE2A4710F672
++DATA2   80   30 07F69200FF0347F0F1F891FFFE2A4710F67292FFFE2A91FFFF014710F5BA
++DATA3   80   60 4370F6228A7000014270F62240404040F0F0F4F0
++DATA1   80    0 02E3E7E34000066E404000384040000147F0F5BA9200FE2A4370F6221A27
++DATA2   80   30 47F0F5BA90EDF07C984DFE60910FF1A54780F69C91FFFE2B4710F69C4560
++DATA3   80   60 F4201B221B339023F10C980D40404040F0F0F4F1
++DATA1   80    0 02E3E7E3400006A64040003840400001F08492FFF07C07FE910FF1A54780
++DATA2   80   30 F6BA4560F4205830FDE85020FE9045E0F74447F0F6CE47F0F1D4910FF1A5
++DATA3   80   60 4780F1D45810FE2C5820FE0040404040F0F0F4F2
++DATA1   80    0 02E3E7E3400006DE404000384040000145E0F1A258E0FDE09180E0334780
++DATA2   80   30 F6F2419090015820FE9007F590BFFE6418CF18B39280300C9180CE884710
++DATA3   80   60 C764910FC1A54780C764181940404040F0F0F4F3
++DATA1   80    0 02E3E7E34000071640400038404000015B10CE9812114780C7645020CE90
++DATA2   80   30 182118014510C72C0A0A5010CE0458D0CE9806204420C7D24020CE6047F0
++DATA3   80   60 C76490BFFE6418CF18B3583040404040F0F0F4F4
++DATA1   80    0 02E3E7E34000074E4040003840400001300058E030004133E0004120C03C
++DATA2   80   30 4400C05205010404181B58D0C0B8D20FD00CC07C50D0C0C841D0C0C458F0
++DATA3   80   60 CE1005EF58D0CE0412DD478040404040F0F0F4F5
++DATA1   80    0 02E3E7E3400007864040003840400001C7BE5810CE2C5820CE0018FC45E0
++DATA2   80   30 C1A25810CE984820CE604420C7D241202001419290001802181D41110000
++DATA3   80   60 0A0A1B225020CE045820CE9040404040F0F0F4F6
++DATA1   80    0 02E3E7E3400007BE40400038404000015830B00498BFCE64583030001233
++DATA2   80   30 078E47F0E004D2001000D0009016FEA41B331B445040FEA04160F9A55060
++DATA3   80   60 FE149200F9A1D203F9A2F9A140404040F0F0F4F7
++DATA1   80    0 02E3E7E3400007F64040001640400001181A1B225860FE0CDDFF10006394
++DATA2   80   30 4772F80C4110110040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F8
++DATA1   80    0 02E3E7E34000080C404000384040000147F0F7FA47F0F8AC47F0F8CE47F0
++DATA2   80   30 FA1C47F0FA2447F0FA2C47F0FA1447F0F9BA47F0F9C247F0FA3447F0FA3C
++DATA3   80   60 47F0FA4447F0FA4C47F0FA0240404040F0F0F4F9
++DATA1   80    0 02E3E7E340000844404000384040000147F0F9D447F0FA5447F0FA6247F0
++DATA2   80   30 F9F647F0F9EE47F0F90047F0F91047F0F8644160F7FA9016FEBC5830FDE4
++DATA3   80   60 D2073080305CD20030A4100040404040F0F0F5F0
++DATA1   80    0 02E3E7E34000087C40400038404000015010300C9280300C45E0F6F847F0
++DATA2   80   30 F89047F0F9B49816FEBC4930FEFC47D0F918D205FE18FE24D203FED4FE20
++DATA3   80   60 47F0F918D100FE9F10008B4040404040F0F0F5F1
++DATA1   80    0 02E3E7E3400008B4404000384040000100035A40FEA05A40FEA05A40FE9C
++DATA2   80   30 5040FEA04110100147F0F7FA413030014930FEFC47C0F8ECD203FE20FED4
++DATA3   80   60 D201FE28FE1CD203FE24FE1840404040F0F0F5F2
++DATA1   80    0 02E3E7E3400008EC40400038404000015010FED44240FE1C4240FE1D5030
++DATA2   80   30 FE1847F0FA0A4560F960921EF9A24560F98447F0FA0A4560F9604630F92C
++DATA3   80   60 9222F9A24560F9845810FED440404040F0F0F5F3
++DATA1   80    0 02E3E7E34000092440400038404000015830FE1847F0FA0A91FEFE1C4750
++DATA2   80   30 F9524930FEFA47C0FA0AD203FED4FE20D201FE1CFE28D203FE18FE2447F0
++DATA3   80   60 FA0A4340FE1C06404240FE1C40404040F0F0F5F4
++DATA1   80    0 02E3E7E34000095C404000384040000147F0F92091FFF9A2078691FFFF09
++DATA2   80   30 4780F97A4240F9A49200FF0947F0F97E4240F9A391FFF9A307869016FEBC
++DATA3   80   60 9816FEA441A0F9A291FEF9A140404040F0F0F5F5
++DATA1   80    0 02E3E7E34000099440400038404000014780F1F841A0F9A047F0F1F80600
++DATA2   80   30 000000009200F9A1D203F9A2F9A19016FEA49816FEBC07F69280F9A347F0
++DATA3   80   60 F8C69208F9A2D600F9A3FEA340404040F0F0F5F6
++DATA1   80    0 02E3E7E3400009CC40400038404000014560F98447F0FA0A12444720F9DE
++DATA2   80   30 414000019218F9A24240F9A34560F98447F0FA0A4560F96047F0FA0A4240
++DATA3   80   60 F9A392FFFF0947F0FA0A921240404040F0F0F5F7
++DATA1   80    0 02E3E7E340000A044040003840400001F9A24240F9A11B445040FEA047F0
++DATA2   80   30 F8C69210F9A247F0FA069214F9A247F0FA069216F9A247F0FA069224F9A2
++DATA3   80   60 47F0FA06920AF9A247F0FA0640404040F0F0F5F8
++DATA1   80    0 02E3E7E340000A3C4040003840400001920CF9A247F0FA06920EF9A247F0
++DATA2   80   30 FA069220F9A247F0FA064560FABE1B445040FEA047F0F7FA9200FF0AD200
++DATA3   80   60 FF0B10005010FED81B44D50040404040F0F0F5F9
++DATA1   80    0 02E3E7E340000A7440400038404000011001FF0B4780FA88414040014110
++DATA2   80   30 100147F0FA72D5001002FF0B4770FAA64140400141101001910FF1A54780
++DATA3   80   60 FA7C47F0FAAA92FFFF0A581040404040F0F0F6F0
++DATA1   80    0 02E3E7E340000AAC4040003840400001FED84560FABE91FFFF0A4710FA0A
++DATA2   80   30 47F0FA6C12444110100107C618A10640910FF1A54710FADA4440FEDC47F0
++DATA3   80   60 FADE4440FEE241949001411440404040F0F0F6F1
++DATA1   80    0 02E3E7E340000AE44040003840400001A00107F69200FB0B47F0FAF4920F
++DATA2   80   30 FB0B95FFF07C4770F1F090EDF07C4130000445D0F13C0501000092FFFE2B
++DATA3   80   60 41A2000041832000189A1BBB40404040F0F0F6F2
++DATA1   80    0 02E3E7E340000B1C40400038404000011B77910FFB0B4780FB2A41700006
++DATA2   80   30 1B55904CFE6098EDF07C07FE90EDF07CD203FE90E000D200FF0CFE909400
++DATA3   80   60 FE90940FFE91D603FE90FEF440404040F0F0F6F3
++DATA1   80    0 02E3E7E340000B5440400038404000014400FE90984CFE609200FF0D43B0
++DATA2   80   30 FF0C18C81BC919CB4740FBC406B044B7FEE8419B9001904CFE60980CF084
++DATA3   80   60 47F0E00490EDF07C984CFE6040404040F0F0F6F4
++DATA1   80    0 02E3E7E340000B8C4040003840400001D207FE90E0005820FE9058B0FE94
++DATA2   80   30 54B0FF10D200FF0FE0044CB0FF0E4830FF0E4140010011635060FF1418C8
++DATA3   80   60 1BC919C347B0FBF492FFFF0D40404040F0F0F6F5
++DATA1   80    0 02E3E7E340000BC4404000384040000112774770FC389180FE884710FC38
++DATA2   80   30 12CC4780FC3806C044C0FEE8412C20011BBC46B0FC3891FFFF0D4780FB78
++DATA3   80   60 47F0FC2C186C19BC4720FBFE40404040F0F0F6F6
++DATA1   80    0 02E3E7E340000BFC4040003840400001186B196447D0FC06186412774770
++DATA2   80   30 FC149180FE8847C0FC185460FF1406604467FEE841969001412620011BB6
++DATA3   80   60 46B0FBB6904CFE60980CF08440404040F0F0F6F7
++DATA1   80    0 02E3E7E340000C34404000384040000147F0E0089023FE9091FFFE2B4780
++DATA2   80   30 FC5091FFFF0D4780FB7847F0FC2C12774770FC8C9201FCB89180FE884710
++DATA3   80   60 FCB24BA0FEFE9101A002471040404040F0F0F6F8
++DATA1   80    0 02E3E7E340000C6C4040003840400001FCB25830FDEC45E0F74447000000
++DATA2   80   30 58E0F07C189892FFFE2B9823FE9047F0FC449202FCB81B9A18299180FE88
++DATA3   80   60 4710FCB24BA0FEFE9601A00240404040F0F0F6F9
++DATA1   80    0 02E3E7E340000CA4404000384040000112554780FCAE9602A00241505001
++DATA2   80   30 5810FE300501000047F0FC7E41A2000041832000189A9823FE9091FFFF0D
++DATA3   80   60 4780FB6E47F0FBB690EDF07C40404040F0F0F7F0
++DATA1   80    0 02E3E7E340000CDC4040003840400001984CFE6091FFFE2B4710FD3C910F
++DATA2   80   30 FB0B4710FD169180FE884710FD3C4BA0FEFE9101A0024780FD3C5810FE2C
++DATA3   80   60 0501010047F0FD3C18A247F040404040F0F0F7F1
++DATA1   80    0 02E3E7E340000D144040003840400001FCF81B9A18299180FE884710FD30
++DATA2   80   30 4BA0FEFE12554780FD309602A0025810FE3005010200470000001B221B33
++DATA3   80   60 9023F10C980CF08492FFF07C40404040F0F0F7F2
++DATA1   80    0 02E3E7E340000D4C404000384040000107FE95FFF07C4770F1F090EDF07C
++DATA2   80   30 182E5810FE2C05010300470000009804F08492FFF07C47F0E00495FFF07C
++DATA3   80   60 4770F1F090EDF07C5850FE0C40404040F0F0F7F3
++DATA1   80    0 02E3E7E340000D84404000384040000147F051C895FFF07C4770F1F090ED
++DATA2   80   30 F07C5850FE0C47F051D095FFF07C4770F1F090E6F07C5850FE0C47F051F0
++DATA3   80   60 95FFF07C4770F1F090E6F07C40404040F0F0F7F4
++DATA1   80    0 02E3E7E340000DBC40400038404000015850FE0C47F051FA50D0FF1890E5
++DATA2   80   30 F07C5850FE0C47F051445850FE0C47F050940000000000000000000013E4
++DATA3   80   60 000013F4000014040000141440404040F0F0F7F5
++DATA1   80    0 02E3E7E340000E0440400010404000010000000004000000000000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F6
++DATA1   80    0 02E3E7E340000E1C40400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F7
++DATA1   80    0 02E3E7E340000E2840400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F8
++DATA1   80    0 02E3E7E340000E2C40400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F9
++DATA1   80    0 02E3E7E340000E3440400028404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F0
++DATA1   80    0 02E3E7E340000E9C40400008404000010000000000000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F1
++DATA1   80    0 02E3E7E340000ED440400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F2
++DATA1   80    0 02E3E7E340000EDC4040002440400001D200A0009000D2009000A000D200
++DATA2   80   30 20009000D200900020004120000007000001000200044040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F3
++DATA1   80    0 02E3E7E340000F0040400014404000010000000000000000000000000000
++DATA2   80   30 0000000FFFFF404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F4
++DATA1   80    0 02E3E7E340000F2040400029404000010000000000000000000000000000
++DATA2   80   30 00F2C940E2E3D6D74040F1C140D7C1E4E2C5400000000000000000404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F5
++DATA1   80    0 02E3E7E340000F50404000384040001190ECD00C5880F04050D0F05018CD
++DATA2   80   30 41D0F04C50D0C0081871186041308F445030F0484100F02A47F0F032C9C8
++DATA3   80   60 C3E2E3C1C5401B110A0892FF40404040F0F0F8F6
++DATA1   80    0 02E3E7E340000F8840400010404000118F4818F00700053F000000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F7
++DATA1   80    0 02E3E7E340000FE44040003840400011186F4840E00041D060C458F06DDC
++DATA2   80   30 05EF58106E2C0501040047F0509A4100536C581060BC1901478050C60501
++DATA3   80   60 040047F0509A58106E58950040404040F0F0F8F8
++DATA1   80    0 02E3E7E34000101C40400038404000111000478050E492001000450050E2
++DATA2   80   30 C9C8C3C1C4D1E2E30A0958106E5C1211478050F60A0E47F0510407004110
++DATA3   80   60 510205110000000000000A0E40404040F0F0F8F9
++DATA1   80    0 02E3E7E340001054404000144040001195FF6F484770512658106F449824
++DATA2   80   30 1020986F1030404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F9F0
++DATA1   80    0 02E3E7E3400010684040000E4040001147F05120C00000F05810511C0A0D
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F9F1
++DATA1   80    0 02E3E7E3400010764040003840400011410000040A3C58D06F1858E0D00C
++DATA2   80   30 58206E109200201318F4980CD01407FE182F584D0010504020C058402E54
++DATA3   80   60 58302E38914040044780517A40404040F0F0F9F2
++DATA1   80    0 02E3E7E3400010AE40400038404000114110516A051102000000025D5030
++DATA2   80   30 1000920210000A0E47F05190070041105186051102000000005D50301000
++DATA3   80   60 920210000A0E50102E5C581040404040F0F0F9F3
++DATA1   80    0 02E3E7E3400010E640400038404000112E2C184241202E08050100FF4700
++DATA2   80   30 0000182492FF207C451051B800000F500000000041000000411100000A3C
++DATA3   80   60 98E5207C07FE920151DF47F040404040F0F0F9F4
++DATA1   80    0 02E3E7E34000111E404000224040001151D4920251DF186F182E58106E2C
++DATA2   80   30 050103004700000092FF607C9806608447F0E00440404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F9F5
++DATA1   80    0 02E3E7E3400011404040003840400011186F92FF6F2D47F05204186F9200
++DATA2   80   30 6F2D94BF6F28075091FF6F2D4710521CD20852A16F384110529047F05226
++DATA3   80   60 D20852A16F2F411052981B4440404040F0F0F9F6
++DATA1   80    0 02E3E7E34000117840400038404000114340E0001834494052E847C0523A
++DATA2   80   30 483052E806304430532C95006F2D4780525CF2246F2552AA4F406F204040
++DATA3   80   60 53041244478052FC4120301340404040F0F0F9F7
++DATA1   80    0 02E3E7E3400011B04040003840400011402052985A20530891FF6F2D4710
++DATA2   80   30 527ED201200052EC9280200247F05288D201200052EA9240200292002003
++DATA3   80   60 47F052EE01000F2C00000F2840404040F0F0F9F8
++DATA1   80    0 02E3E7E3400011E8404000384040001100008000C9C8C3F0F04040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F9F9
++DATA1   80    0 02E3E7E34000122040400014404000114040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F0F0
++DATA1   80    0 02E3E7E3400012384040000640400011003A020040004040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F0F1
++DATA1   80    0 02E3E7E34000123E40400038404000110A2392FF607C91FF6F2D4780530C
++DATA2   80   30 98E6607C45E0F04400000000000011E858E0607C41E4E00150E0607C92FF
++DATA3   80   60 607C41106F28410000010A0140404040F0F1F0F2
++DATA1   80    0 02E3E7E340001276404000384040001198E6607C07FED20052AAE0014120
++DATA2   80   30 FE081B005000F1105810FE2C050100FF47F05362D2432001560D92F02000
++DATA3   80   60 412000455810FE2C0501020040404040F0F1F0F3
++DATA1   80    0 02E3E7E3400012AE4040000E404000114700000092FFF07C45E0F0440010
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F0F4
++DATA1   80    0 02E3E7E3400012BC40400028404000119101200058202000478010105820
++DATA2   80   30 20004020F03E5830FDF0189045E0F744470000001B3347F0900240404040
++DATA3   80   60 40404040404040404040404040404040F0F1F0F5
++DATA1   80    0 02E3E7E3400012E440400038404000115454545454545454545454545454
++DATA2   80   30 545454545454545454545454545454545454545454545454545454545454
++DATA3   80   60 54545454545454545454545440404040F0F1F0F6
++DATA1   80    0 02E3E7E34000131C40400038404000115454545454545454005454545454
++DATA2   80   30 54545444544450085454545454545454545454545454545054541C4C5454
++DATA3   80   60 54545454544854480854545440404040F0F1F0F7
++DATA1   80    0 02E3E7E34000135440400038404000115454545454545454545454544040
++DATA2   80   30 545454545454545454545454545454545454545454545454545454545454
++DATA3   80   60 54545454545454545454545440404040F0F1F0F8
++DATA1   80    0 02E3E7E34000138C40400038404000115454545454545454545454545454
++DATA2   80   30 54545454545454545454540C54542C2824303C1854545454545454545410
++DATA3   80   60 54545420545454545454545440404040F0F1F0F9
++DATA1   80    0 02E3E7E3400013C440400038404000115454543454545438541454545454
++DATA2   80   30 545404040404040404040404545454545454000014480000143400001424
++DATA3   80   60 000000000000148C0000143440404040F0F1F1F0
++DATA1   80    0 02E3E7E3400013FC4040003840400011000014288000003C000014CC0000
++DATA2   80   30 14340000142C8000003C0000150C00001434000014308000003C000000D3
++DATA3   80   60 000000D4000000D5000000E740404040F0F1F1F1
++DATA1   80    0 02E3E7E340001434404000384040001100000000C3D6D4D7C9D3C5C4E5C1
++DATA2   80   30 D9C9C1C2D3C50000003DC9C8C3F2F1F1C940C9C2C3D6D4406040C9D3D3C5
++DATA3   80   60 C7C1D340404040404040404040404040F0F1F1F2
++DATA1   80    0 02E3E7E34000146C404000384040001140C6D6D9D4C1E340C3C8C1D9C1C3
++DATA2   80   30 E3C5D940E2D7C5C3C9C6C9C5C4404000000000000039C9C8C3F2F1F2C940
++DATA3   80   60 C9C2C3D6D4406040C6D6D9D440404040F0F1F1F3
++DATA1   80    0 02E3E7E3400014A44040003840400011C1E3E3C5C440C961D66B40C5D5C4
++DATA2   80   30 40D6C640D9C5C3D6D9C440D6D540E4D5C9E340404040400000000000003C
++DATA3   80   60 C9C8C3F2F1F3C940C9C2C3D640404040F0F1F1F4
++DATA1   80    0 02E3E7E3400014DC4040003840400011D4406040E4D5C6D6D9D4C1E3E3C5
++DATA2   80   30 C440D9C5C1C46B40C5D5C440D6C640D9C5C3D6D9C440D6D540E4D5C9E340
++DATA3   80   60 404040400000004DC9C8C3F240404040F0F1F1F5
++DATA1   80    0 02E3E7E3400015144040003840400011F3F1C940C9C2C3D6D4406040C4C9
++DATA2   80   30 D9C5C3E340C1C3C3C5E2E240E2E3C1E3C5D4C5D5E340E4E2C5C440E6C9E3
++DATA3   80   60 C8D6E4E340C4C5C6C9D5C54040404040F0F1F1F6
++DATA1   80    0 02E3E7E34000154C4040003840400011C6C9D3C540D6D540E4D5C9E34040
++DATA2   80   30 404040C9C8C3F9F0F4C940C1E3E3C5D4D7E340E3D640C4D640C961D640C4
++DATA3   80   60 E4D9C9D5C740C6C9E7E4D74040404040F0F1F1F7
++DATA1   80    0 02E3E7E3400015844040001D40400011D9D6E4E3C9D5C540C6D6D940C1D5
++DATA2   80   30 40C961D640E3E8D7C540C5D9D9D6D9404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F1F8
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D00006C0C0000C40002
++DATA2   80   30 00010C000E34000300010C000E2C000400010C000E38000500010C000E58
++DATA3   80   60 000600011D000DE00C000E5440404040F0F1F1F9
++DATA1   80    0 02D9D3C4404040404040003840404040000700010C000E3C000800010C00
++DATA2   80   30 0E40000900010C000E44000A00010C000E48000B00010C000E4C000C0001
++DATA3   80   60 0C000E50000D00011C0000BC40404040F0F1F2F0
++DATA1   80    0 02D9D3C4404040404040003840404040000E00011C000DDC000F00011C00
++DATA2   80   30 0E0C001000011C000E10001100010D000DE40D000DE80D000DEC0C000DF0
++DATA3   80   60 00010011090011E10C0011E440404040F0F1F2F1
++DATA1   80    0 02D9D3C44040404040400038404040400001001109001401090014110800
++DATA2   80   30 1421001000111C000F94001100110D0011000D0012580D0013E40D0013E8
++DATA3   80   60 0D0013EC0D0013F40C0013F840404040F0F1F2F2
++DATA1   80    0 02D9D3C4404040404040002840404040001100110D0013FC0D0014040D00
++DATA2   80   30 14080D00140C0D0014140D0014180C00141C001200111C000F9040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F2F3
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F0F8C1D7D9F7F040F0F74BF0F34040F361F2F261
++DATA3   80   60 F7F14040404040404040404040404040F0F1F2F4
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCEDIOS EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C5C4C9D6E2000000004000
++DATA2   80   30 0E56C4C9D6C3E27B40400100000040000001C6C4C9D6C3E27B4002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400003C9C2C3D6D47B4040020000004040
++DATA2   80   30 4040C9C8C3E4C1E3C2D30200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C4C9D6C3E27B0090EC
++DATA2   80   30 D00C58C0F9FC184D41D0FA0850D40008504D000458A0F9F018411B22D500
++DATA3   80   60 4000A0044780F06C4324000040404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000014580F7589101200F4780F0509101
++DATA2   80   30 20034780F0605042000C918040084710F07E4144000C47F0F02841E0FB38
++DATA3   80   60 4160F05047F0F62441E0FB2840404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001D200FB9B40004160F05047F0F624
++DATA2   80   30 5830F9F850C0300058D0FA0C98ECD00C92FFD00C07FE90EC198050D01978
++DATA3   80   60 58C0196841D019BC58A0C95C40404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A8404000384040000158B0CA0418401B55435400008B50
++DATA2   80   30 000247F5C02847F0C03C47F0C3AA47F0C44647F0C4C647F0C5C618429140
++DATA3   80   60 40004780C04A9640CA24582440404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000010000910140004780C05A58220000
++DATA2   80   30 4020A000412200004580C6C49101200F4710C5165872000CD203CA107008
++DATA3   80   60 910120034780C3785847000440404040F0F0F0F7
++DATA1   80    0 02E3E7E34000011840400038404000015844000095E470044770C0948B40
++DATA2   80   30 00025940CA1847B0C55C410000B84510C0A40A0A5012000018B19200B000
++DATA3   80   60 D24EB001B0004150B050505040404040F0F0F0F8
++DATA1   80    0 02E3E7E3400001504040003840400001B0205050B03C4040B01E4040B03A
++DATA2   80   30 D267B050C8404040B08E4040B0684860A0004E60C96CF342C96CC97196F0
++DATA3   80   60 C970D201B07AC96F9200C8A840404040F0F0F0F9
++DATA1   80    0 02E3E7E340000188404000384040000150B0CA084510C100000000005051
++DATA2   80   30 0000928010000A409500C8A84780C52E9120C90C4780C11E9620B0749120
++DATA3   80   60 C90C47E0C12A9620B074920140404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001C04040003840400001B0649501C9004780C13E9202B064
++DATA2   80   30 9620B00191C0C8FF4740C27E5840C988910F40014780C3604150B05059B0
++DATA3   80   60 CA084770C0F0943FC8FF964040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001F84040002640400001C8FF9202B0649202B0989240B06A
++DATA2   80   30 9200B0829220B0839200B0849120C90D4780C18A9220B084404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02E3E7E34000021E404000384040000107004510C1940000000050510000
++DATA2   80   30 928F10000A169680B0014580C6904840B01E1A445850B0244580C70A5867
++DATA3   80   60 0000586600004190B018509040404040F0F0F1F3
++DATA1   80    0 02E3E7E3400002564040003840400001B0084150B0345050B0109220B008
++DATA2   80   30 9220B01018199220100558F1000858F0F03005EF94DFB0084580C6B44580
++DATA3   80   60 C7444660C1D44880B062498040404040F0F0F1F4
++DATA1   80    0 02E3E7E34000028E4040003840400001B08E4740C2084160000147F0C1D4
++DATA2   80   30 4580C6B44580C7444150B0504510C21C0000000050510000928010000A14
++DATA3   80   60 947FB0019200B0989220B06A40404040F0F0F1F5
++DATA1   80    0 02E3E7E3400002C640400038404000019229B0829228B0839201B0849120
++DATA2   80   30 B0014710C2C24110B05058F010149601101748E0F0044CE0F00691011020
++DATA3   80   60 4710C26A4100E00847F0C26E40404040F0F0F1F6
++DATA1   80    0 02E3E7E3400002FE40400038404000014100E0104110F0000A0A9201B064
++DATA2   80   30 D702B065B0651B004300B064890000084300B08E890000084300B08F4110
++DATA3   80   60 B0504000101888000010400040404040F0F0F1F7
++DATA1   80    0 02E3E7E34000033640400038404000011016410000001311070045F0C2C0
++DATA2   80   30 0000034C00000000C9C5C3D8C2C6C7F10A064150B05007004510C2D00000
++DATA3   80   60 000050510000928410000A1340404040F0F0F1F8
++DATA1   80    0 02E3E7E34000036E40400038404000019610B00158670000586600005060
++DATA2   80   30 B0044150B0185050B0084150B0345050B0104580C6909220B0089220B010
++DATA3   80   60 4150B00D5050B0304150B01540404040F0F0F1F9
++DATA1   80    0 02E3E7E3400003A640400038404000015050B04C5840C988D200B0004001
++DATA2   80   30 5850C99091F0B0004780C350586500085960CA0C47D0C358586600001266
++DATA3   80   60 47C0C53E0660910FB000471040404040F0F0F2F0
++DATA1   80    0 02E3E7E3400003DE4040003840400001C50247F0C3B25865000447F0C330
++DATA2   80   30 4166000047F0C33C5840C990914040004710C4EA41E0CAB44560C57A47F0
++DATA3   80   60 C51E58B020009110B001471040404040F0F0F2F1
++DATA1   80    0 02E3E7E3400004164040003840400001C3164150B0509180B0014780C0D8
++DATA2   80   30 4510C3980000000050510000928010000A14947FB00147F0C0D85860CA14
++DATA3   80   60 416600015960B00447B0C53A40404040F0F0F2F2
++DATA1   80    0 02E3E7E34000044E40400038404000015060CA145890B0084580C6885964
++DATA2   80   30 00004780C43A9120B0014780C4064580C6B44580C688596400004780C43A
++DATA3   80   60 9120B0084710C40A9140B00840404040F0F0F2F3
++DATA1   80    0 02E3E7E34000048640400038404000014710C4069180B0084780C40A4580
++DATA2   80   30 C6B44580C6884580C7445064000018199608100558F0100858F0F03005EF
++DATA3   80   60 9280B0089140CA244710C4C640404040F0F0F2F4
++DATA1   80    0 02E3E7E3400004BE40400038404000014580C7445829000C4830B01E47F0
++DATA2   80   30 C4C691C0B0084780C40E47F0C4225890B0084580C688586400005960B004
++DATA3   80   60 47B0C53A5060CA14181994C640404040F0F0F2F5
++DATA1   80    0 02E3E7E3400004F64040003840400001100558F0100858F0F03005EF9240
++DATA2   80   30 B008416600019120B0014780C4924580C6B49120B0084710C49691C0B008
++DATA3   80   60 4780C4964580C7444580C68840404040F0F0F2F6
++DATA1   80    0 02E3E7E34000052E404000384040000150640000943FB0085829000C4830
++DATA2   80   30 B01E1843185291F0B0004710C4FA4580C73C5840C988950040004780C66A
++DATA3   80   60 5840CA105850CA144155000140404040F0F0F2F7
++DATA1   80    0 02E3E7E34000056640400038404000019140CA244710C4DE415500019101
++DATA2   80   30 CA104710C4F25054000094BFCA2447F0C66A4054000047F0C4EA4580C70A
++DATA3   80   60 47F0C4C65960B00447B0C53A40404040F0F0F2F8
++DATA1   80    0 02E3E7E34000059E40400038404000015890B0085060CA1447F0C48241E0
++DATA2   80   30 CA604560C57A58D0C97898ECC9801B33181047F0100241E0CA404560C57A
++DATA3   80   60 47F0C51E416060015060CA1440404040F0F0F2F9
++DATA1   80    0 02E3E7E3400005D640400038404000014120CA144130CBF94500C8440406
++DATA2   80   30 41E0CA704560C57A47F0C51E41E0CA8418424560C57A18249501CB034780
++DATA3   80   60 C51E5840CA28064047F0C09C40404040F0F0F3F0
++DATA1   80    0 02E3E7E34000060E404000384040000158F0C96058D0F0B8D20FD00CF07C
++DATA2   80   30 50D0F0C841D0F0C450F0C97458F0E008D503F000CAD84780C5B85830E000
++DATA3   80   60 58F030004133F0004120CB0440404040F0F0F3F1
++DATA1   80    0 02E3E7E34000064640400038404000014500C8440404181E58F0CA2005EF
++DATA2   80   30 58F0C97407F64120A008414000104850A0024155A000910120034710C666
++DATA3   80   60 9101200F4710C66658B2000040404040F0F0F3F2
++DATA1   80    0 02E3E7E34000067E40400038404000019190B0014780C6525890B0084580
++DATA2   80   30 C74491A0B0014780C60A4580C6B44580C7444160B050181658F010149601
++DATA3   80   60 101748E0F0044CE0F006910140404040F0F0F3F3
++DATA1   80    0 02E3E7E3400006B6404000384040000110204710C6304100E00847F0C634
++DATA2   80   30 4100E0104110F0000A0A07004510C6440000000050610000928010000A14
++DATA3   80   60 946FB001410000B8181B411140404040F0F0F3F4
++DATA1   80    0 02E3E7E3400006EE404000384040000100000A0A960120039601200F8724
++DATA2   80   30 C5D650B0CA0458F0C9609023F11458D0C97898E1C980984CC998181047F0
++DATA3   80   60 100658490018064007F8585040404040F0F0F3F5
++DATA1   80    0 02E3E7E3400007264040003840400001B064415050085050B0249501B064
++DATA2   80   30 4780C6AC4A50B0685050B040D201B068B08E07F85890B010D203B010B008
++DATA3   80   60 5090B00807F85020CB04581040404040F0F0F3F6
++DATA1   80    0 02E3E7E34000075E4040003840400001C9605020103C122247C0C6EA0620
++DATA2   80   30 8B2000044920A00247B0C6EA4122A00807F8418080005980C96841E0CA50
++DATA3   80   60 4740C7024560C57A47F0C51E40404040F0F0F3F7
++DATA1   80    0 02E3E7E34000079640400038404000014560C59047F0F050924050000640
++DATA2   80   30 124407884940CA1C4720C72406404440C73607F8D2FF500150004B40CA1C
++DATA3   80   60 4155010047F0C714D200500140404040F0F0F3F8
++DATA1   80    0 02E3E7E3400007CE404000384040000150009200500047F0C70E9120B008
++DATA2   80   30 07184110900058E0100858F0E03405EF9620B0089140B0014710C76607F8
++DATA3   80   60 94BFB00118E54560C57A47F040404040F0F0F3F9
++DATA1   80    0 02E3E7E3400008064040003840400001C51E9640B001914090014710C836
++DATA2   80   30 911090024710C80C918090014710C80C188E9180B0014780C7B241F0F000
++DATA3   80   60 070056F0C7A847F0C7AC020040404040F0F0F4F0
++DATA1   80    0 02E3E7E34000083E404000384040000100000A4447F0C7C641F0F0000700
++DATA2   80   30 56F0C7C047F0C7C4040000000A441851410000704510C7D00A0A5010CA2C
++DATA3   80   60 D21A1004CB08D24C101F503240404040F0F0F4F1
++DATA1   80    0 02E3E7E3400008764040003840400001415000685050100041F0F0000700
++DATA2   80   30 56F0C7F847F0C7FCFF0000000A444150CA2C5090CA3C9280CA3C07F85820
++DATA3   80   60 90180620582020004120200140404040F0F0F4F2
++DATA1   80    0 02E3E7E3400008AE40400034404000015020CA144120CA144130CBF94500
++DATA2   80   30 C8440406943FB0084150CA7007FE5090CAD49280CAD44150CAC407FE58F0
++DATA3   80   60 C9604400F05207F14040404040404040F0F0F4F3
++DATA1   80    0 02E3E7E3400008E440400038404000010000000000000001000020000000
++DATA2   80   30 000100000001800009ECC6E3E7E7C6F0F0F1020029280100000100000808
++DATA3   80   60 00000000000000010000000140404040F0F0F4F4
++DATA1   80    0 02E3E7E34000091C40400020404000010000000100000001000000000000
++DATA2   80   30 000100000001000000010000000100000001404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F5
++DATA1   80    0 02E3E7E34000093C40400038404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F4F6
++DATA1   80    0 02E3E7E34000097440400038404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F4F7
++DATA1   80    0 02E3E7E3400009AC40400038404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F4F8
++DATA1   80    0 02E3E7E3400009E4404000384040000100000000000000008700093C0000
++DATA2   80   30 000000000000000000000000009400000000000000000000000000000000
++DATA3   80   60 00000A50000000000000000040404040F0F0F4F9
++DATA1   80    0 02E3E7E340000A1C40400038404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F5F0
++DATA1   80    0 02E3E7E340000A54404000384040000100000A0800000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F5F1
++DATA1   80    0 02E3E7E340000A8C4040000C404000010000000000000000000000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F5F2
++DATA1   80    0 02E3E7E340000AA040400038404000010100000000000000000000000000
++DATA2   80   30 7FF901000010000000000000000000007D0000000B9C00000B9400000B6C
++DATA3   80   60 00000B988000000000000BB840404040F0F0F5F3
++DATA1   80    0 02E3E7E340000AD8404000384040000100000B9400000B7080000B980000
++DATA2   80   30 0BE800000B9400000B7480000B9800000C2000000B9400000B7880000B98
++DATA3   80   60 00000C6C00000B9400000B7C40404040F0F0F5F4
++DATA1   80    0 02E3E7E340000B10404000384040000100000B9880000AA800000CAC0000
++DATA2   80   30 0B9400000B8080000B9800000CF800000B9400000B8480000B9800000D5C
++DATA3   80   60 00000B9400000B8880000B9840404040F0F0F5F5
++DATA1   80    0 02E3E7E340000B48404000384040000100000DCC00000B9400000B8C8000
++DATA2   80   30 0B9800000E1400000B9400000B9000000B9880000000000000DA000000DB
++DATA3   80   60 000000DC000000E7000000E840404040F0F0F5F6
++DATA1   80    0 02E3E7E340000B804040003840400001000000E9000000EA000000EB0000
++DATA2   80   30 00EC000000ED0000000000000000C9C8C3F2F1F8C940C4C9D6C3E2406040
++DATA3   80   60 C961D640C5D9D9D6D940400040404040F0F0F5F7
++DATA1   80    0 02E3E7E340000BB840400038404000010000002CC9C8C3F2F1F9C940C4C9
++DATA2   80   30 D6C3E2406040D4C9E2E2C9D5C740C4C440C3C1D9C440C6D6D940E4D5C9E3
++DATA3   80   60 4040404000000033C9C8C3F240404040F0F0F5F8
++DATA1   80    0 02E3E7E340000BF04040003840400001F2F0C940C4C9D6C3E2406040E4D5
++DATA2   80   30 C9E340D5E4D4C2C5D940D6E4E340D6C640D9C1D5C7C54B40E4D5C9E37E40
++DATA3   80   60 4040400000000048C9C8C3F240404040F0F0F5F9
++DATA1   80    0 02E3E7E340000C284040003840400001F3F1C940C4C9D6C3E2406040C4C9
++DATA2   80   30 D9C5C3E340C1C3C3C5E2E240E2E3C1E3C5D4C5D5E340E4E2C5C440C6D6D9
++DATA3   80   60 40E2C5D8E4C5D5E3C9C1D34040404040F0F0F6F0
++DATA1   80    0 02E3E7E340000C604040003840400001C4C1E3C140E2C5E3404040400000
++DATA2   80   30 003CC9C8C3F2F3F2C940C4C9D6C3E2406040D9C5C3D6D9C440D5E4D4C2C5
++DATA3   80   60 D940404040404040D6E4E34040404040F0F0F6F1
++DATA1   80    0 02E3E7E340000C984040003840400001D6C640D9C1D5C7C540D6D540E4D5
++DATA2   80   30 C9E34040404000000047C9C8C3F2F3F3C940C4C9D6C3E2406040D9C5C3D6
++DATA3   80   60 D9C440D3C5D5C7E3C840C7D940404040F0F0F6F2
++DATA1   80    0 02E3E7E340000CD04040003840400001C5C1E3C5D940E3C8C1D540F3F2D2
++DATA2   80   30 60F140E2D7C5C3C9C6C9C5C440C6D6D940E4D5C9E340404040000000005E
++DATA3   80   60 C9C8C3F2F3F4C940C4C9D6C340404040F0F0F6F3
++DATA1   80    0 02E3E7E340000D084040003840400001E2406040C1E3E3C5D4D7E340E3D6
++DATA2   80   30 40C4C5C6C9D5C540E3C8C540D6C2D1C5C3E340C5D9D9D6D940E4D5C9E340
++DATA3   80   60 C1E240C140C4C9D9C5C3E34040404040F0F0F6F4
++DATA1   80    0 02E3E7E340000D404040003840400001C1C3C3C5E2E240C4C1E3C140E2C5
++DATA2   80   30 E34B40E4D5C9E37E40404040000000000069C9C8C3F2F3F5C940C4C9D6C3
++DATA3   80   60 E2406040C4C5C6C9D5C540C140404040F0F0F6F5
++DATA1   80    0 02E3E7E340000D78404000384040000140C4C1E3C140E2C5E340E6C8C9C3
++DATA2   80   30 C840C8C1E240C2C5C5D540E4E2C5C440E2C5D8E4C5D5E3C9C1D3D3E840C1
++DATA3   80   60 E240C140C4C9D9C5C3E340C140404040F0F0F6F6
++DATA1   80    0 02E3E7E340000DB04040003840400001C3C3C5E2E240C4C1E3C140E2C5E3
++DATA2   80   30 4B40E4D5C9E37E4040404000000000000042C9C8C3F2F3F6C940C4C9D6C3
++DATA3   80   60 E2406040D9C5C1C440D9C5D840404040F0F0F6F7
++DATA1   80    0 02E3E7E340000DE84040003840400001E4C5E2E340C6D6D940C1D540E4D5
++DATA2   80   30 C3D9C5C1E3C5C440C4C1E3C140E2C5E340D6D540E4D5C9E3404040400000
++DATA3   80   60 0000003EC9C8C3F2F3F7C94040404040F0F0F6F8
++DATA1   80    0 02E3E7E340000E204040003640400001C4C9D6C3E2406040C9D5C3D6D9D9
++DATA2   80   30 C5C3E340D9C5C3D6D9C440D3C5D5C7E3C840E2D7C5C3C9C6C9C5C440C6D6
++DATA3   80   60 D940E4D5C9E340404040404040404040F0F0F6F9
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D000344090008F90D00
++DATA2   80   30 090C090009ED0D0009FC0D000A100D000A540D000AC00D000AC40D000AC8
++DATA3   80   60 0D000ACC0D000AD40C000AD840404040F0F0F7F0
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D000ADC09000AE10D00
++DATA2   80   30 0AE40D000AE80D000AEC09000AF10D000AF40D000AF80D000AFC09000B01
++DATA3   80   60 0D000B040D000B080C000B0C40404040F0F0F7F1
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D000B1009000B150D00
++DATA2   80   30 0B180D000B1C0D000B2009000B250D000B280D000B2C0D000B3009000B35
++DATA3   80   60 0D000B380D000B3C0C000B4040404040F0F0F7F2
++DATA1   80    0 02D9D3C44040404040400038404040400001000109000B450D000B480D00
++DATA2   80   30 0B4C0D000B5009000B550D000B580D000B5C0D000B600C000B6400020001
++DATA3   80   60 1C0009F8000300011C0009F440404040F0F0F7F3
++DATA1   80    0 02D9D3C4404040404040001040404040000400011C0009F0000500011C00
++DATA2   80   30 0AB440404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F4
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F5
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCEFIOS EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C5C6C9D6E2000000004000
++DATA2   80   30 1368C6C9D6C3E2C240400100000040000001C6C9D6C3E2C2C5D701000006
++DATA3   80   60 400000014040404040404040C9D6C3E2F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400002C9C8C3C5D9D9D440020000004040
++DATA2   80   30 4040C9C8C3E4C1E3C2D30200000040404040C9C2C3D6D47B404002000000
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F0F2
++DATA1   80    0 02E3E7E3400000004040003840400001071047F01022071058101F9A90EC
++DATA2   80   30 D00C41B0111850B0D00818BD9201108647F0102E50D010B090EC10B841B0
++DATA3   80   60 10AC50B0111C98BD1F9C1840C9D6C3E2F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040002840400001D200C08040001BAA43A400008BA0
++DATA2   80   30 000247FAC04C47F0C20447F0C24847F0C51447F0CA6247F0CD9840404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F0F4
++DATA1   80    0 02E3E7E34000006040400010404000010000000000000000000000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F0F5
++DATA1   80    0 02E3E7E3400000764040001B404000010011000400100000010000000008
++DATA2   80   30 080000000000000000108000004040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F0F6
++DATA1   80    0 02E3E7E34000009440400010404000010000000000000000000000000000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F0F7
++DATA1   80    0 02E3E7E3400000AC40400038404000010000000000000000000001180000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 000000000000000000000000C9D6C3E2F0F0F0F8
++DATA1   80    0 02E3E7E3400000E440400038404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 000000000000000000000000C9D6C3E2F0F0F0F9
++DATA1   80    0 02E3E7E34000011C4040003840400001000000AC00000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 000000000000000000000000C9D6C3E2F0F0F1F0
++DATA1   80    0 02E3E7E34000015440400038404000010000000000000000000000000000
++DATA2   80   30 00000000000000000FF4000001E4000001CC800001E80000104C000001E4
++DATA3   80   60 000001D0800001E800000000C9D6C3E2F0F0F1F1
++DATA1   80    0 02E3E7E34000018C4040003840400001000001E4000001D4000001E88000
++DATA2   80   30 000000001168000001E4000001D8800001E80000107C000001E4000001DC
++DATA3   80   60 800001E8000010B8000001E4C9D6C3E2F0F0F1F2
++DATA1   80    0 02E3E7E3400001C44040003840400001000001E0800001E8000000D60000
++DATA2   80   30 00D9000000DA000000DB000000DC000000E7000000000000000000000000
++DATA3   80   60 006C8000000000000000110CC9D6C3E2F0F0F1F3
++DATA1   80    0 02E3E7E3400001FC40400038404000010000111C0000000045A0C65647F0
++DATA2   80   30 C2344110C1BC45A0CE8058D0D00498ECD00C950110864780122858D0D004
++DATA3   80   60 920010861B33181047F01002C9D6C3E2F0F0F1F4
++DATA1   80    0 02E3E7E3400002344040003840400001911060024710C24045A0CD54910F
++DATA2   80   30 C0854710C3F49868C094910F600047E0C26445A0C33445A0C2F647000000
++DATA3   80   60 47F0C990910860014710C2AEC9D6C3E2F0F0F1F5
++DATA1   80    0 02E3E7E34000026C40400038404000014590C3B641245000914070244710
++DATA2   80   30 C296483070521A5350506010495080064740C2929608600147F0CF40D201
++DATA3   80   60 C07020004830C0701A534B30C9D6C3E2F0F0F1F6
++DATA1   80    0 02E3E7E3400002A44040003840400001C0784A20C07847F0C28291106001
++DATA2   80   30 4710C2BE45A0C37A45A0C33445A0C2F647F0CEFE5820800C910260014710
++DATA3   80   60 C2EE4830703E585080104B35C9D6C3E2F0F0F1F7
++DATA1   80    0 02E3E7E3400002DC4040003840400001000E910660014780CF4040308006
++DATA2   80   30 47F0C26C4830200047F0C2DE9680600194EF6001950080174780A0049200
++DATA3   80   60 8017181858E0100858F0E034C9D6C3E2F0F0F1F8
++DATA1   80    0 02E3E7E340000314404000384040000105EF910260024710C984D200C082
++DATA2   80   30 6001943F600191C0C0824710CEDE47FA000495017014078A4540C3625080
++DATA3   80   60 60149501C0864770C354D503C9D6C3E2F0F0F1F9
++DATA1   80    0 02E3E7E34000034C4040003840400001C0A0C0944770C3585080C09C5080
++DATA2   80   30 C0A89720600107FA5850600841806034912060010714585060044180601C
++DATA3   80   60 07F492018017928080041818C9D6C3E2F0F0F2F0
++DATA1   80    0 02E3E7E3400003844040003840400001928010055071000858F1000858F0
++DATA2   80   30 F03005EF07FA92018017920080041818922010055071000858F1000858F0
++DATA3   80   60 F03005EF07FA910860014780C9D6C3E2F0F0F2F1
++DATA1   80    0 02E3E7E3400003BC4040003840400001C3EE58206004950170144780C3D8
++DATA2   80   30 4540C362575060185880601418251B33914070244780C3E6413000049023
++DATA3   80   60 600C970860019845600C07F9C9D6C3E2F0F0F2F2
++DATA1   80    0 02E3E7E3400003F44040003840400001910F60004710C46CD2006000C085
++DATA2   80   30 96106003910860014780C444910460014780C430910260014710C430D501
++DATA3   80   60 6012703E47B0C43094F76001C9D6C3E2F0F0F2F3
++DATA1   80    0 02E3E7E34000042C404000384040000147F0C44445A0C3344590C3B645A0
++DATA2   80   30 C2F647F0C46447F0C460950170144780C45C45A0C33445A0C2FA47F0C45C
++DATA3   80   60 45A0CC9045A0C33445A0CC90C9D6C3E2F0F0F2F4
++DATA1   80    0 02E3E7E340000464404000384040000145A0C8C494EF6003910860014710
++DATA2   80   30 C5024590C3B6483070524124500091C070244710CF40914070244780CF40
++DATA3   80   60 91F0C0854710C4B04830703EC9D6C3E2F0F0F2F5
++DATA1   80    0 02E3E7E34000049C40400038404000011B354B30C078D2012002C0884120
++DATA2   80   30 200447F0CF404800703E1B0591F0C0904710C4F84930C08E4780C4E81903
++DATA3   80   60 47B0C49E4950C0784780C4FCC9D6C3E2F0F0F2F6
++DATA1   80    0 02E3E7E3400004D440400038404000011A054B00C078190347B0C5CA96F0
++DATA2   80   30 C09047F0C5CA4950C0784780C4FC96F0C09047F0C5CA97F0C090183047F0
++DATA3   80   60 C49E4540C362575060181825C9D6C3E2F0F0F2F7
++DATA1   80    0 02E3E7E34000050C40400038404000014830703E47F0CF404020C0749501
++DATA2   80   30 C0864780C5569868C094910660014780C5DA9845600C4800703E91407024
++DATA3   80   60 4710C55E483070521A531B05C9D6C3E2F0F0F2F8
++DATA1   80    0 02E3E7E340000544404000384040000119034740C5D64124500050506010
++DATA2   80   30 47F0CF409868C0A047F0C5241222412200044770C574910670244780C574
++DATA3   80   60 4122000241A450004020C070C9D6C3E2F0F0F2F9
++DATA1   80    0 02E3E7E34000057C4040003840400001D201A000C0701A52412450005050
++DATA2   80   30 6010910460014780C5C291F0C0854710C5B01B054B00C0784900C08C4740
++DATA3   80   60 C5C2183047F0C4A21B054900C9D6C3E2F0F0F3F0
++DATA1   80    0 02E3E7E3400005B4404000384040000170524740C5C24830705247F0C49E
++DATA2   80   30 914070244780C5D658506010895000105054000096086001D501C074C076
++DATA3   80   60 4720C5E89212C075D2018006C9D6C3E2F0F0F3F1
++DATA1   80    0 02E3E7E3400005EC4040003840400001C07445A0C39845A0C33445A0C2F6
++DATA2   80   30 470000004540C60E910660014780CF4047F0C47491F0C08507845890800C
++DATA3   80   60 924090004830703E06300630C9D6C3E2F0F0F3F2
++DATA1   80    0 02E3E7E34000062440400038404000014430C6501B225D20C07C12334780
++DATA2   80   30 C64641929001D2FF90019000419901004630C6385820800C4830703E07F4
++DATA3   80   60 D20090019000D200C0854001C9D6C3E2F0F0F3F3
++DATA1   80    0 02E3E7E34000065C4040003840400001D200C08120009101C0814780C66E
++DATA2   80   30 58220000582200009104C0814780C67E4322B004415200004020B0009501
++DATA3   80   60 C0864780C69E5050C1E858F0C9D6C3E2F0F0F3F4
++DATA1   80    0 02E3E7E3400006944040003840400001CFA85050F03C47F0C6A25050C1EC
++DATA2   80   30 122547D0C6B606208B2000044920B0024740C6C24110C1AC41A0C21447F0
++DATA3   80   60 CE804122B0089101200F4710C9D6C3E2F0F0F3F5
++DATA1   80    0 02E3E7E3400006CC4040003840400001C6D247FA0004910120034780C70A
++DATA2   80   30 410000A44510C6E20A0A50120000186192006000D26260016000D247605C
++DATA3   80   60 CFAC4170604C507060244180C9D6C3E2F0F0F3F6
++DATA1   80    0 02E3E7E3400007044040003840400001601C508060145862000058706024
++DATA2   80   30 588060149501C0864770C7269068C0A047F0C72A9068C0949500C0804770
++DATA3   80   60 C73E910FC0854710C75247F0C9D6C3E2F0F0F3F7
++DATA1   80    0 02E3E7E34000073C4040003840400001C74E9503C0804770C74E9500C085
++DATA2   80   30 4780C75294FD600391C0600247C0C762914060034780C8F4910860024710
++DATA3   80   60 C77A9103C0804780C77A9102C9D6C3E2F0F0F3F8
++DATA1   80    0 02E3E7E3400007744040003840400001C0854780CA6A912060024710C790
++DATA2   80   30 4590C8E4D201702AC06E47F0C912910860024780C7EA914060034710C7F4
++DATA3   80   60 964060029503C0804770C7B6C9D6C3E2F0F0F3F9
++DATA1   80    0 02E3E7E3400007AC40400038404000019501C0854740CC84078A07004510
++DATA2   80   30 C7C0000000005071000092B010000A14943F6002F212C066702D4F50C060
++DATA3   80   60 415500014590C8E4D202702DC9D6C3E2F0F0F4F0
++DATA1   80    0 02E3E7E3400007E44040003840400001C06D47F0C912D202702DCFC947F0
++DATA2   80   30 C9129503C0804770C80E9500C0854770C80E91046001071A47F0C89C94BF
++DATA3   80   60 6003910460014780C8909500C9D6C3E2F0F0F4F1
++DATA1   80    0 02E3E7E34000081C4040003840400001C0804770C890910FC0854710C83A
++DATA2   80   30 918060034710C87E94F7600147F0C26C910260034780C84A947D600347F0
++DATA3   80   60 C89C45A0C8C4918060034710C9D6C3E2F0F0F4F2
++DATA1   80    0 02E3E7E3400008544040003840400001C87A950170144780C87A96106003
++DATA2   80   30 45A0C33445A0C2F647F0C87694EF600345A0CC9045A0C33445A0CC90947F
++DATA3   80   60 6003942060019103C080071AC9D6C3E2F0F0F4F3
++DATA1   80    0 02E3E7E34000088C404000384040000147F0C994947F6003910460014710
++DATA2   80   30 C87E911060024780C8AE9103C080071A47F0C99050A0C07045A0CD5458A0
++DATA3   80   60 C0709103C080071A47F0C984C9D6C3E2F0F0F4F4
++DATA1   80    0 02E3E7E3400008C4404000384040000191F0C085078A5890800C5A906010
++DATA2   80   30 924090004830703E5B3060104540C62007FA4E50C060F373C068C06496F0
++DATA3   80   60 C06F07F991026001071A91F0C9D6C3E2F0F0F4F5
++DATA1   80    0 02E3E7E3400008FC4040003840400001C085071A9103C080071A4110C168
++DATA2   80   30 41A0C21447F0CE809200C0879103C0804710C93E910FC0854710C93E0700
++DATA3   80   60 4510C9300000000050710000C9D6C3E2F0F0F4F6
++DATA1   80    0 02E3E7E3400009344040003840400001928310000A1347F0C95207004510
++DATA2   80   30 C9480000000050710000928710000A1395FFC0874780C214911070304710
++DATA3   80   60 C9845050C2005850C1F807F5C9D6C3E2F0F0F4F7
++DATA1   80    0 02E3E7E34000096C40400016404000014110C19C58A01000D207A0287028
++DATA2   80   30 41A0C21447F0CEAC40404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F4F8
++DATA1   80    0 02E3E7E340000984404000384040000192FC6002920060034540CA329208
++DATA2   80   30 6001D2006000C08591C070244710C9CE914070244780C9AE960260019110
++DATA3   80   60 70244780C9CE960460019108C9D6C3E2F0F0F4F9
++DATA1   80    0 02E3E7E3400009BC404000384040000160014710C9CE910F60004710C474
++DATA2   80   30 47F0CA129103C0804710CA724180601C508060149501C0864780C9EA5080
++DATA3   80   60 C09C920060339200604B9501C9D6C3E2F0F0F5F0
++DATA1   80    0 02E3E7E3400009F44040002E4040000170144780C9FE962060019103C080
++DATA2   80   30 4710CB08910FC0854710CA2245A0C37A950170144780C2BE45A0C33447F0
++DATA3   80   60 C2B640404040404040404040C9D6C3E2F0F0F5F1
++DATA1   80    0 02E3E7E340000A2240400038404000014540C60E910660014780CF4047F0
++DATA2   80   30 C474585070145895000050906004509060289501701407844A9500065090
++DATA3   80   60 600850906040D20360186004C9D6C3E2F0F0F5F2
++DATA1   80    0 02E3E7E340000A5A4040003840400001D7036018600807F445A0C65647F0
++DATA2   80   30 CA72412000F047F0CF409501C0854720CCD24780CC96910460014710CAE6
++DATA3   80   60 918060034710CABE96106003C9D6C3E2F0F0F5F3
++DATA1   80    0 02E3E7E340000A92404000384040000145A0C33445A0C2FA47F0CABE94EF
++DATA2   80   30 6003910F60004780CAB24590CCF647F0CABE950170144780CABE45A0CC90
++DATA3   80   60 45A0CC9091F060004710CADEC9D6C3E2F0F0F5F4
++DATA1   80    0 02E3E7E340000ACA40400038404000014590CC765820800C910220064710
++DATA2   80   30 CABA45A0CC9096C0600347F0CF40910260034780CB2894FD600391106002
++DATA3   80   60 4710CB0845A0CD54D203600CC9D6C3E2F0F0F5F5
++DATA1   80    0 02E3E7E340000B024040003840400001600447F0C9D64590CC7296C06003
++DATA2   80   30 4820703E58A080104B2A000E910260014710CC0447F0CBA6910260014710
++DATA3   80   60 CBB21B22592060104770CB8EC9D6C3E2F0F0F5F6
++DATA1   80    0 02E3E7E340000B3A4040003840400001910F60004780CB5E914060034710
++DATA2   80   30 CB564590CCF647F0CAFE45A0C3344590CC6E47F0CB0C918060034710CB56
++DATA3   80   60 950170144780CB5696106003C9D6C3E2F0F0F5F7
++DATA1   80    0 02E3E7E340000B72404000384040000145A0C33445A0C2F647F0CB5294EF
++DATA2   80   30 600345A0C3344190CB0C47F0CC6A914060034710CBA2910F60004710CB4A
++DATA3   80   60 96406003582060104B207052C9D6C3E2F0F0F5F8
++DATA1   80    0 02E3E7E340000BAA40400038404000015020601047F0CF40412000045920
++DATA2   80   30 60104770CBD2910F60004780CBF0914060034710CBF047F0CB4AD201CC8C
++DATA3   80   60 6012914060034710CBEC910FC9D6C3E2F0F0F5F9
++DATA1   80    0 02E3E7E340000BE2404000384040000160004710CB4A9640600345A0CC16
++DATA2   80   30 918060034710CB56910F60004780CB6647F0CB565840600CD201CC8C4000
++DATA3   80   60 45A0CC1647F0CB561B224020C9D6C3E2F0F0F6F0
++DATA1   80    0 02E3E7E340000C1A4040003840400001CC8E41200004502060105A20600C
++DATA2   80   30 910220024710CC36D201CC8E6012D2016048200058206048892000018820
++DATA3   80   60 00115A206010502060104920C9D6C3E2F0F0F6F1
++DATA1   80    0 02E3E7E340000C524040003840400001CC8C4770CC241B224920CC8E078A
++DATA2   80   30 D2016012CC8E47F0CF4045A0CC9045A0CC9045A0CC9045A0C37A45A0C2F6
++DATA3   80   60 4700000007F996C2600347F0C9D6C3E2F0F0F6F2
++DATA1   80    0 02E3E7E340000C8A4040000240400001CF40404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F6F3
++DATA1   80    0 02E3E7E340000C90404000064040000118170A4507FA4040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F6F4
++DATA1   80    0 02E3E7E340000C96404000384040000145A0CE1645A0C334910F60004780
++DATA2   80   30 CCAA9680600145A0C2FA4700000007004510CCBC00000000507100009290
++DATA3   80   60 10000A14943760024590CD1CC9D6C3E2F0F0F6F5
++DATA1   80    0 02E3E7E340000CCE404000384040000147F0CF4045A0CE1645A0C33445A0
++DATA2   80   30 C2F647F0CCEA968070304590CCF694BF60024590CD1C47F0CF4045A0CE16
++DATA3   80   60 45A0C33445A0C2F647000000C9D6C3E2F0F0F6F6
++DATA1   80    0 02E3E7E340000D06404000384040000107004510CD100000000050710000
++DATA2   80   30 92B010000A1707F9911060020789181758F010149601101748E0F0044CE0
++DATA3   80   60 F006910110204710CD444100C9D6C3E2F0F0F6F7
++DATA1   80    0 02E3E7E340000D3E4040003840400001E00847F0CD484100E0104110F000
++DATA2   80   30 0A0A94EF600207F91B0043007014890000104A00703E1817400010188800
++DATA3   80   60 001040001016410000001311C9D6C3E2F0F0F6F8
++DATA1   80    0 02E3E7E340000D764040003840400001070045F0CD8C00000D8400000000
++DATA2   80   30 C9C5C3D8C2C6C7F10A064540CA329610600207FA4120B008414000104850
++DATA3   80   60 B0024155B000910120034710C9D6C3E2F0F0F6F9
++DATA1   80    0 02E3E7E340000DAE4040003840400001CE0E9101200F4780CE0E58620000
++DATA2   80   30 5050C0705880601458706024911070304780CDF645A0CE1645A0C33445A0
++DATA3   80   60 C2F6470000004510CDE80000C9D6C3E2F0F0F7F0
++DATA1   80    0 02E3E7E340000DE64040003840400001000050710000928010000A144590
++DATA2   80   30 CD1C1816410000A4411100000A0A960120035850C070414000108724CDA8
++DATA3   80   60 47F0CF54902AC0F4910F6000C9D6C3E2F0F0F7F1
++DATA1   80    0 02E3E7E340000E1E4040003840400001078A91046001078A91086001071A
++DATA2   80   30 960860011B33914070244780CE3E4B30C0785A30601047C0CE7A4890703E
++DATA3   80   60 914070244710CE5A4030703EC9D6C3E2F0F0F7F2
++DATA1   80    0 02E3E7E340000E56404000384040000147F0CE669845600C895000105054
++DATA2   80   30 000045A0C3984090703E45A0C33445A0C2F647000000982AC0F407FA18E1
++DATA3   80   60 5830100058F03000413F3000C9D6C3E2F0F0F7F3
++DATA1   80    0 02E3E7E340000E8E404000384040000158F0CFA84120C1E89501C0864770
++DATA2   80   30 CEA24120C1EC4400F05205010404181E58F0CFA858D0F0B8D20FD00CF07C
++DATA3   80   60 50D0F0C841D0F0C45830C11CC9D6C3E2F0F0F7F4
++DATA1   80    0 02E3E7E340000EC640400038404000014300C08558F0C16005EF4200C085
++DATA2   80   30 41D0C1185030C11C07FAD500B001B0044780CEF44110C18845A0CEAC47F0
++DATA3   80   60 C2145050C2005850C1FC07F5C9D6C3E2F0F0F7F5
++DATA1   80    0 02E3E7E340000EFE40400038404000015830CFA85820310C412020001222
++DATA2   80   30 4780CF2092FF307C18E2980D308458E0E00007FED200C08560004110C178
++DATA3   80   60 45A0CE8058E0C1E412EE4770C9D6C3E2F0F0F7F6
++DATA1   80    0 02E3E7E340000F364040003840400001C2144590CD1C47F0C7B658F0CFA8
++DATA2   80   30 412020009501C0864780CF769023F11458D0D00498E1D00C984CD0249501
++DATA3   80   60 108647801F6C58D0D0049200C9D6C3E2F0F0F7F7
++DATA1   80    0 02E3E7E340000F6E4040002C404000011086181047F010065920F1144770
++DATA2   80   30 CF549200F114D206F115F11447F0CF5494BF60024590CD1C58A0C0AC07FA
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F7F8
++DATA1   80    0 02E3E7E340000F9C40400038404000010000000000000000000000000000
++DATA2   80   30 00000000000000000001000040000000000100001228000011A0C6E3E7E7
++DATA3   80   60 C6F0F0F10200202000000001C9D6C3E2F0F0F7F9
++DATA1   80    0 02E3E7E340000FD44040002040400001000011A800000000000000000000
++DATA2   80   30 000100000001000000010000000000000001404040404040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F8F0
++DATA1   80    0 02E3E7E340000F9C40400010404000010000000000000000000001180000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F8F1
++DATA1   80    0 02E3E7E340000FF4404000384040000100000053C9C8C3F2F1F4C940C6C9
++DATA2   80   30 D6C3E2406040E4D5C6D6D9D4C1E3E3C5C440C961D66B40D9C5C3D6D9C440
++DATA3   80   60 C6D6D9D4C1E340E2D7C5C3C9C9D6C3E2F0F0F8F2
++DATA1   80    0 02E3E7E34000102C4040003840400001C6C9C5C440C1E240C66B40E440D6
++DATA2   80   30 D940E540D6D540E4D5C9E3404040404040000000002CC9C8C3F2F1F7C940
++DATA3   80   60 C6C9D6C3E2406040C5D5C440C9D6C3E2F0F0F8F3
++DATA1   80    0 02E3E7E3400010644040003840400001D6C640C4C1E3C140E2C5E340D6D5
++DATA2   80   30 40E4D5C9E3404040404000000035C9C8C3F2F2F0C940C6C9D6C3E2406040
++DATA3   80   60 E4D5C9E340D5E4D4C2C5D940C9D6C3E2F0F0F8F4
++DATA1   80    0 02E3E7E34000109C4040003840400001D6E4E340D6C640D9C1D5C7C54B40
++DATA2   80   30 E4D5C9E3407E404040404000000000000050C9C8C3F2F3F1C940C6C9D6C3
++DATA3   80   60 E2406040E2C5D8E4C5D5E3C9C9D6C3E2F0F0F8F5
++DATA1   80    0 02E3E7E3400010D44040003840400001C1D340C961D640E2E3C1E3C5D4C5
++DATA2   80   30 D5E3E240E4E2C5C440C6D6D940C4C9D9C5C3E340C1C3C3C5E2E240C4C1E3
++DATA3   80   60 C140E2C5E340404040404040C9D6C3E2F0F0F8F6
++DATA1   80    0 02E3E7E34000110C4040003840400001D500B001B0044770C96C92FFC1F4
++DATA2   80   30 05509200C0865810C16092FF10139500C1F44780502AD20750747028D203
++DATA3   80   60 504C50804110504C0A2347F0C9D6C3E2F0F0F8F7
++DATA1   80    0 02E3E7E3400011444040003840400001503C5810C188D2031000C1F0D203
++DATA2   80   30 106C507C0A235850C20058F0CFA845E0F044001000000000002CC9C8C3F2
++DATA3   80   60 F1F9C940C6C9D6C3E2406040C9D6C3E2F0F0F8F8
++DATA1   80    0 02E3E7E34000117C4040002440400001D4C9E2E2C9D5C740C4C440C3C1D9
++DATA2   80   30 C440C6D6D940404040404040404002000020003080004040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F8F9
++DATA1   80    0 02E3E7E3400011A040400008404000018500124887000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F9F0
++DATA1   80    0 02E3E7E3400011A840400038404000010550965060019180600107EE184E
++DATA2   80   30 5000C1989280C19841F0F000070056F0502247F05026020000000A4418A1
++DATA3   80   60 41000070451050320A0A5010C9D6C3E2F0F0F9F1
++DATA1   80    0 02E3E7E3400011E04040003840400001C188D21A10045062D24C101FA032
++DATA2   80   30 41A0006850A0100041F0F000070056F0505A47F0505EFF0000000A4407F4
++DATA3   80   60 C9C8C3F2F1F8C940C6C9D6C3C9D6C3E2F0F0F9F2
++DATA1   80    0 02E3E7E3400012184040003040400001E2406040C961D640C5D9D9D6D940
++DATA2   80   30 400050A0C0AC4590CD06920060339200604B911060034780CF8C94EF6003
++DATA3   80   60 47F0CF944040404040404040C9D6C3E2F0F0F9F3
++DATA1   80    0 02E3E7E340001248404000384040000105304150308C91F0C08507159103
++DATA2   80   30 C0800715950070244770301E9648702407F591C070244710304091487024
++DATA3   80   60 0715910FC085471030409140C9D6C3E2F0F0F9F4
++DATA1   80    0 02E3E7E340001280404000384040000170244780304047F0308845903060
++DATA2   80   30 12114770308291C070244710305A91407024471030889248702407F54110
++DATA3   80   60 C168184250E0C0AC5030C164C9D6C3E2F0F0F9F5
++DATA1   80    0 02E3E7E3400012B8404000384040000145A0CE805830C16458E0C0AC1824
++DATA2   80   30 5810C1E407F992FFC08707F596087024412020041B994990703E477030A0
++DATA3   80   60 D201703E2002950070244770C9D6C3E2F0F0F9F6
++DATA1   80    0 02E3E7E3400012F0404000384040000130AED20070242004950170144780
++DATA2   80   30 30BE920270149202704849907052477030CCD2017052200648A0703E9180
++DATA3   80   60 7024471030DC4BA0C0784990C9D6C3E2F0F0F9F7
++DATA1   80    0 02E3E7E340001328404000384040000170524780310E91F0C085471030F4
++DATA2   80   30 9148702447103112D5017052C08E4780310E91C070244710310E49A07052
++DATA3   80   60 47B0311240A0705291806002C9D6C3E2F0F0F9F8
++DATA1   80    0 02E3E7E3400013604040000840400001078E9602600207FE404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F0F9F9
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D0000B40D00011C0D00
++DATA2   80   30 01680D00016C0D000170090001750D0001780D00017C0D00018009000185
++DATA3   80   60 0D00018C0D0001900C000194C9D6C3E2F0F1F0F0
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D00019C0D0001A00D00
++DATA2   80   30 01A4090001A90D0001AC0D0001B00D0001B4090001B90D0001BC0D0001C0
++DATA3   80   60 0D0001C4090001C90C0001F8C9D6C3E2F0F1F0F1
++DATA1   80    0 02D9D3C4404040404040003440404040000100010D0001FC0D000D7C0D00
++DATA2   80   30 0FA00D000FA409000FBD09000FC10D000FD4080011A1000200011C000160
++DATA3   80   60 000300011C000F9C40404040C9D6C3E2F0F1F0F2
++DATA1   80    0 02D9D3C4404040404040000840404040000400011C000FA8404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040C9D6C3E2F0F1F0F3
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F0F8C1D7D9F7F040F0F84BF3F84040F361F2F261
++DATA3   80   60 F7F140404040404040404040C9D6C3E2F0F1F0F4
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCEFNTH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C5C6D5E3C8000000004000
++DATA2   80   30 0512C9C2C3D6D47B40400200000040404040C9D5E3E2E6E3C3C802000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C9D5E3F6E2E6C3C8020000004040
++DATA2   80   30 4040C9C8C3E4D6D7E3400200000040404040C1C4C3D6D57B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040003040400007C6C9D6C3E27B4040020000004040
++DATA2   80   30 4040C1D9C9E3C87B40400100000040000001C1C4D1E2E6E3C3C80100036C
++DATA3   80   60 40000001404040404040404040404040F0F0F0F3
++DATA1   80    0 02C5E2C4404040404040001040400008C9C8C3C5D9D9D440020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02E3E7E340000000404000384040000150E0F3545010F360903DF3E4D20B
++DATA2   80   30 F3D81014D207F410100C5880F3BC18914840100691C010084780F0D44B40
++DATA3   80   60 F3A08B4000024780F04A494040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000384040001640400001F07847A0F31C58A0F3C091FFA000
++DATA2   80   30 4710F14247F4F05040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02E3E7E340000050404000384040000147F0F32247F0F31C47F0F20247F0
++DATA2   80   30 F0AE47F0F20247F0F0AE47F0F07A47F0F09447F0F20247F0F0AE002892FF
++DATA3   80   60 804896F0807A92CFF49792F740404040F0F0F0F7
++DATA1   80    0 02E3E7E3400000884040003840400001F4A1D20BF4BFF43847F0F142920F
++DATA2   80   30 804892D0F49792F8F4A1D20BF4BFF444960F807A47F0F14292FF804992D1
++DATA3   80   60 F49792F9F4A1D20BF4BFF45040404040F0F0F0F8
++DATA1   80    0 02E3E7E3400000C04040003840400001950F10074770F0CC47F0F1429400
++DATA2   80   30 F3BB47F0F20258A0F3C091FFA0004710F31C92D2F497D201F4A0F510D20B
++DATA3   80   60 F4BFF45E894000145040F3B840404040F0F0F0F9
++DATA1   80    0 02E3E7E3400000F840400038404000018940000112444720F0F889400001
++DATA2   80   30 12444780F112D20BF4BFF45C9144F3B847A0F11E92FF80499110F3B84780
++DATA3   80   60 F12E920F8048960F807A912040404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001304040003840400001F3B847E0F20292FF804896F0807A
++DATA2   80   30 47F0F202950C10074770F1524170000147F0F156417000095860100896FF
++DATA3   80   60 F3BB1B551BBB412000021F6240404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001684040003840400001126647B0F1701F62954460004770
++DATA2   80   30 F1CC1B554110F3D8484060028C400010434060018D40001041B0003C4130
++DATA3   80   60 0FFF1434884000064100000240404040F0F0F1F2
++DATA1   80    0 02E3E7E3400001A0404000384040000188400004182B14244780F1B04400
++DATA2   80   30 F3B44600F1A0884000041863182B14244780F1C643521003430060011650
++DATA3   80   60 4100000396FFF3BA9110600040404040F0F0F1F3
++DATA1   80    0 02E3E7E3400001D840400038404000014710F1E49400F3BA410000074130
++DATA2   80   30 00F01A7012BB4770F1F44350600114534450F39291FFA0004710F2885820
++DATA3   80   60 F3BC41D020C45830F40C583040404040F0F0F1F4
++DATA1   80    0 02E3E7E340000210404000384040000130045030D0045840F3C85810405C
++DATA2   80   30 4130F4D65820F36041202004050108125810405C4130F4FE4120F3D00501
++DATA3   80   60 08124110F478D200F493F3D040404040F0F0F1F5
++DATA1   80    0 02E3E7E3400002484040003840400001947FF493184F180E95FF43BB4780
++DATA2   80   30 427E41F0004C50F044989280448058F0443405EF9200448041F0007450F0
++DATA3   80   60 449892F044A047F0428458F040404040F0F0F1F6
++DATA1   80    0 02E3E7E3400002804040003840400001443405EF18F418E095FFF3BB4770
++DATA2   80   30 F31C9501F48F4770F2DC4270F3B89407F3B84370F3B84457F3A6910A6000
++DATA3   80   60 47E0F31C94CF90089180F3D040404040F0F0F1F7
++DATA1   80    0 02E3E7E3400002B840400038404000014780F2C49610900847F0F31C1845
++DATA2   80   30 8840000416544457F3AE4780F31C9620900847F0F31C950F90074780F31C
++DATA3   80   60 950D90074780F2F04457F39240404040F0F0F1F8
++DATA1   80    0 02E3E7E3400002F040400038404000011845884000041654950D90074770
++DATA2   80   30 F3104457F392910A600047E0F31094CF90089180F3D04780F31C4450F3A4
++DATA3   80   60 983DF3E407FE9500F36C478040404040F0F0F1F9
++DATA1   80    0 02E3E7E3400003284040002440400001F36ED201F4A0F51092D2F497D20B
++DATA2   80   30 F4BFF46A9400F3BB5820F3C44110F35498EFF34C07FE4040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F0
++DATA1   80    0 02E3E7E3400003504040000440400001000003D840404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F1
++DATA1   80    0 02E3E7E3400003584040000840400001000000000000F202404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F2
++DATA1   80    0 02E3E7E340000364404000384040000100000000000000000000182F4100
++DATA2   80   30 F37847F0F380C9C8C3C1C4D1E2E31B110A0818F29201F36C5000F34C47F0
++DATA3   80   60 F32A6000F3D07800F418680040404040F0F0F2F3
++DATA1   80    0 02E3E7E34000039C4040001C40400001F4183B0000062B0031006800F3D0
++DATA2   80   30 7800F3D02200000032005E32100040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F4
++DATA1   80    0 02E3E7E3400003BC40400010404000010000000000000000000000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F5
++DATA1   80    0 02E3E7E34000041840400038404000017FFFFFFFFFFFFFFF04000000F0C9
++DATA2   80   30 C8C3F2F1F0C940D7D9D6C7D9C1D4000000004040D6E5C5D9C6D3D6E64040
++DATA3   80   60 40E4D5C4C5D9C6D3D6E6404040404040F0F0F2F6
++DATA1   80    0 02E3E7E3400004504040003840400001C4C9E5C9C4C540C3C8C5C3D2D44B
++DATA2   80   30 C9D4D7D9C5C3C9E2C540404040C1D3C9C7D5D4C5D5E34040000000000498
++DATA3   80   60 0000048C00000494000003D040404040F0F0F2F7
++DATA1   80    0 02E3E7E34000048840400038404000018000049000000000000000000000
++DATA2   80   30 000000000074C9C8C3F2F040C940C9C2C3D6D4406040D7D9D6C7D9C1D440
++DATA3   80   60 C9D5E3C5D9D9E4D7E360404040404040F0F0F2F8
++DATA1   80    0 02E3E7E3400004C04040003840400001404040404040404040404040D6D3
++DATA2   80   30 C440D7E2E640C9E2404040404040404040404040404040404040404B40D9
++DATA3   80   60 C5C7C9E2E3C5D940C3D6D5E340404040F0F0F2F9
++DATA1   80    0 02E3E7E3400004F84040001840400001C1C9D5C5C4404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F0
++DATA1   80    0 02E3E7E3400005104040000240400001F1F0404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F1
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D0003500D0003580D00
++DATA2   80   30 04780D00047C0D0004800D00048408000489000200010C0003BC00030001
++DATA3   80   60 0C0003C0000400010C00036840404040F0F0F3F2
++DATA1   80    0 02D9D3C4404040404040002040404040000500010C000364000600010C00
++DATA2   80   30 03C8000700010C0003C4000800011C000434404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F3
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F4
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCERRM  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C5D9D9D440000000004000
++DATA2   80   30 05BCC5D9D9D4D6D540400100000040000001C9C8C3C5D9D9C54001000018
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400002C9C8C3E4D6D7E340020000004040
++DATA2   80   30 4040C9C2C3D6D47B40400200000040404040C9C8C3E3D9C3C84002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040001040400005C6C9D6C3E2C2C5D7020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C5D9D9D4D6D50090EC
++DATA2   80   30 D00C4700000047F0F02858F0F59091FFF013071E92FFF43207FF18CF189D
++DATA3   80   60 41D0C3E850D090085090D00440404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000384040003840400001186145A0C23C9240200006300630
++DATA2   80   30 4430C3DC95FFC4324780C33E5880C5AC58A0600858A0A0001B2258F0C5B0
++DATA3   80   60 49A0C3D04770C07492FFC43140404040F0F0F0F5
++DATA1   80    0 02E3E7E34000007040400038404000015820F11091FFC4334710C29040A0
++DATA2   80   30 C3D292FFC4334BA0C3D612AA47D0C31E59A080004720C31E89A00003418A
++DATA3   80   60 800091FF800247E0C0B2912040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000A8404000384040000180034710C0BE9620800343A08002
++DATA2   80   30 41A0A00142A080024120200012224780C0D492FFC4305020C3E447F0C0FC
++DATA3   80   60 950080004780C0FCD500800040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400000E0404000384040000180024720C0FC4130C56B45E0C30C
++DATA2   80   30 D2454001C5294590C2F047F0C2B041A0C12692FFC43C910480034710C256
++DATA3   80   60 912080034710C11ED500800140404040F0F0F0F8
++DATA1   80    0 02E3E7E3400001184040003840400001800247B0C2569200C43C47F0C18C
++DATA2   80   30 911080034780C17858A0600895EDA0034780C14295FFC4314770C15E58A0
++DATA3   80   60 601058B0A00C5890A008487040404040F0F0F0F9
++DATA1   80    0 02E3E7E3400001504040003840400001903E58A0A0104B70A00E47F0C170
++DATA2   80   30 58F0C5B058B0F11412BB4780C1785870F1184BB0C3CC45A0C25E95FFC434
++DATA3   80   60 4780C2BC910280034780C18C40404040F0F0F1F0
++DATA1   80    0 02E3E7E340000188404000384040000145A0C22658B06004910180074710
++DATA2   80   30 C1AE41A0000150A0B0004110600458F0800405EF47F0C1B41BAA50A0B000
++DATA3   80   60 95FFC43C4770C1E69200C43C40404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001C0404000384040000145A0C23C9101B0034710C1D6D20D
++DATA2   80   30 4001C56F47F0C1DCD20D4001C57DD21C400FC58B4590C2F045A0C2D695FF
++DATA3   80   60 C4304780C20058D0D004920040404040F0F0F1F2
++DATA1   80    0 02E3E7E3400001F84040003840400001C43398ECD00C07FE58F0C5B09200
++DATA2   80   30 C43392FFF07C1B221B339023F10C58E0C3E49200C430980DF08458E0E000
++DATA3   80   60 07FE5890D00458B0900450B040404040F0F0F1F3
++DATA1   80    0 02E3E7E3400002304040003840400001D00458F0C5B405EF5090D0049200
++DATA2   80   30 C2FE92FFC2FF4120C4384590C2F89202C2FE9200C2FF07FA58B060005870
++DATA3   80   60 B0001277078A19754720C27A40404040F0F0F1F4
++DATA1   80    0 02E3E7E340000268404000384040000106704470C2744590C2F007FAD200
++DATA2   80   30 4001B004183506304430C27441B3B0011B754590C2F047F0C262189A4130
++DATA3   80   60 C4E545E0C30C4090C3D2413040404040F0F0F1F5
++DATA1   80    0 02E3E7E3400002A04040003840400001C4CA45E0C30CD26E4001C47A4590
++DATA2   80   30 C2F045A0C25692FFC43447F0C1269200C43445A0C22645A0C2D69200C433
++DATA3   80   60 58F0C5B045E0F044001095FF40404040F0F0F1F6
++DATA1   80    0 02E3E7E3400002D84040003840400001C431077A9200C431581060004100
++DATA2   80   30 0070411100000A0A07FA92F04000412050015810C5B80501020047000000
++DATA3   80   60 18421853065007F958F0C5B040404040F0F0F1F7
++DATA1   80    0 02E3E7E34000031040400038404000014400F0524120C3D20501020407FE
++DATA2   80   30 4130C45945E0C30CD2354001C4444590C2F0586060041BAA50A0600047F0
++DATA3   80   60 C1E65860C5AC58B0600089B040404040F0F0F1F8
++DATA1   80    0 02E3E7E3400003484040003840400001000318861A8B88B000031B771BAA
++DATA2   80   30 43A08002912080034780C36A4AA0C3D894DF800312AA4780C3BC4970C3D8
++DATA3   80   60 47B0C38A4A70C3D8D23F400140404040F0F0F1F9
++DATA1   80    0 02E3E7E3400003804040003840400001C4E992F140004590C2F441E0B0CE
++DATA2   80   30 40E0C3D24130402245E0C30C4130403140A0C3D245E0C30C49A0C3DA4770
++DATA3   80   60 C3B4D2064036C43D4590C2F040404040F0F0F2F0
++DATA1   80    0 02E3E7E3400003B84040003840400001427080024B80C3D446B0C3549200
++DATA2   80   30 C43247F0C1F2000400D900DA0000000800CE010001FFD200200120000000
++DATA3   80   60 00000000000000000000000040404040F0F0F2F1
++DATA1   80    0 02E3E7E3400003F040400038404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F2F2
++DATA1   80    0 02E3E7E3400004284040000D404000010000000000000000000000000040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F3
++DATA1   80    0 02E3E7E34000043840400038404000010400000000D6D940D6E5C5D9C9C8
++DATA2   80   30 C3F9F0F2C940C5D9D9D6D940D5E4D4C2C5D940404040404040D6E4E340D6
++DATA3   80   60 C640D9C1D5C7C540D6C640C540404040F0F0F2F4
++DATA1   80    0 02E3E7E3400004704040003840400001D9D9D6D940E3C1C2D3C5C9C8C3F9
++DATA2   80   30 F0F1C940C5E7C5C3E4E3C9D6D540E3C5D9D4C9D5C1E3C9D5C740C4E4C540
++DATA3   80   60 E3D640E2C5C3D6D5C4C1D9E840404040F0F0F2F5
++DATA1   80    0 02E3E7E3400004A8404000384040000140C5D5E3D9E840E3D640C5D9D9D6
++DATA2   80   30 D940D4D6D5C9E3D6D940C6D6D940C5D9D9D6D9404040404040E6C8C9D3C5
++DATA3   80   60 40D7D9D6C3C5E2E2C9D5C74040404040F0F0F2F6
++DATA1   80    0 02E3E7E3400004E04040003840400001C5D9D9D6D940404040E2E4D4D4C1
++DATA2   80   30 D9E840D6C640C5D9D9D6D9E240C6D6D940E3C8C9E240D1D6C2404040C5D9
++DATA3   80   60 D9D6D940D5E4D4C2C5D9404040404040F0F0F2F7
++DATA1   80    0 02E3E7E340000518404000384040000140D5E4D4C2C5D940D6C640C5D9D9
++DATA2   80   30 D6D9E2C9C8C3F9F0F0C940C5E7C5C3E4E3C9D6D540E3C5D9D4C9D5C1E3C9
++DATA3   80   60 D5C740C4E4C540E3D640C5D940404040F0F0F2F8
++DATA1   80    0 02E3E7E3400005504040003840400001D9D6D940C3D6E4D5E340C6D6D940
++DATA2   80   30 C5D9D9D6D940D5E4D4C2C5D94040404040E2E3C1D5C4C1D9C440C6C9E7E4
++DATA3   80   60 D74040E4E2C5D940C6C9E7E440404040F0F0F2F9
++DATA1   80    0 02E3E7E3400005884040002040400001D7404040E3C1D2C5D5406B40C5E7
++DATA2   80   30 C5C3E4E3C9D6D540C3D6D5E3C9D5E4C9D5C7404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F0
++DATA1   80    0 02E3E7E3400005A840400014404000010000000000000000000000000000
++DATA2   80   30 000000000000404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F1
++DATA1   80    0 02D9D3C4404040404040002840404040000100010C0005A8000200011C00
++DATA2   80   30 05AC000300011C0005B0000400011C0005B4000500011C0005B840404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F2
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F3
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCETRCH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C5E3D9C3C8000000004000
++DATA2   80   30 028EC9C8C3E3D9C3C8400100000040000001C5D9D9E3D9C1404001000008
++DATA3   80   60 400000014040404040404040E3D9C3C8F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400002C9C2C3D6D47B4040020000004040
++DATA2   80   30 4040C1C4C3D6D57B40400200000040404040C6C9D6C3E2C2C5D702000000
++DATA3   80   60 404040404040404040404040E3D9C3C8F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000192FFF1FC41F0F00847F0F00A05E3
++DATA2   80   30 D9C1C3C590ECD00C5880F16C91FFF1F44710F02E95FF807C4780F02E18F8
++DATA3   80   60 58E0F06C980CD01407FE50D0E3D9C3C8F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001F1B041D0F1AC4120F1785810F174
++DATA2   80   30 050100FF4700000092F020004030F250D24E2001F1FA4570F152589D0004
++DATA3   80   60 91FFF1F44780F06858909004E3D9C3C8F0F0F0F4
++DATA1   80    0 02E3E7E340000070404000384040000141A000041BBB5859001019584780
++DATA2   80   30 F1381A5A950050004780F098436500009508500047D0F092416000080660
++DATA3   80   60 4460F2805859000CD5015000E3D9C3C8F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040003840400001F24E4770F0B8486500024E60F258
++DATA2   80   30 F332201FF25D96F020224150202541C0000418354120900C4570F1441A9A
++DATA3   80   60 4150500B46C0F0C04B90F1F8E3D9C3C8F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000014570F152D503901080C04780F106
++DATA2   80   30 4150002C875AF0FC1BCC86CAF12A599CF1784770F0F0D2132016F2604570
++DATA3   80   60 F152D20B2001F2744132000DE3D9C3C8F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040003840400001412800C04570F1444570F15258D0
++DATA2   80   30 D0049200F1F498ECD00C07FE509BF17C5890900418BC47F0F06E41600005
++DATA3   80   60 4150F24847F0F0925810F170E3D9C3C8F0F0F0F8
++DATA1   80    0 02E3E7E34000015040400038404000015811005C0501040A07F74820F250
++DATA2   80   30 5810F174050102004700000092F020004030F25007F70000000000000000
++DATA3   80   60 000000000400000000000001E3D9C3C8F0F0F0F9
++DATA1   80    0 02E3E7E3400001884040002C404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 404040404040404040404040E3D9C3C8F0F0F1F0
++DATA1   80    0 02E3E7E3400001FC4040003840400001000000F00010E3D9C1C3C5C2C1C3
++DATA2   80   30 D24040D9D6E4E3C9D5C54040C3C1D3D3C5C440C6D9D6D440C9E2D5404040
++DATA3   80   60 D9C5C74B4040F1F4404040D9E3D9C3C8F0F0F1F1
++DATA1   80    0 02E3E7E3400002344040002640400001C5C74B4040F1F5404040D9C5C74B
++DATA2   80   30 404040F0404040D9C5C74B404040F1C9C2C3D6D447000000404040404040
++DATA3   80   60 404040404040404040404040E3D9C3C8F0F0F1F2
++DATA1   80    0 02E3E7E3400002604040002E404000010000000000000000E3D9C1C3C5C2
++DATA2   80   30 C1C3D240E3C5D9D4C9D5C1E3C5C4C5D5E3D9E840D7D6C9D5E37ED200200C
++DATA3   80   60 500140404040404040404040E3D9C3C8F0F0F1F3
++DATA1   80    0 02D9D3C4404040404040001840404040000200011C000174000300011C00
++DATA2   80   30 0178000400011C00017C4040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E3D9C3C8F0F0F1F4
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E3D9C3C8F0F0F1F5
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFAINT EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040002040400001C9C8C3C6C1C9D5E3000000004000
++DATA2   80   30 0048C1C9D5E3404040400100000040000001404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C1C9D5E30090E2D00C
++DATA2   80   30 58201000780020007900F03C47A0F02C7900F04047C0F02C3B0047F0F030
++DATA3   80   60 7A00F04498E2D00C92FFD00C40404040F0F0F0F2
++DATA1   80    0 02E3E7E340000038404000024040000107FE404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003C4040000C4040000141100000C1100000470000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFCDXI EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C3C4E7C9000000004000
++DATA2   80   30 01FEC9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C3C4D4D7E87B4040020000004040
++DATA2   80   30 4040C3C4C4E5C47B40400200000040404040C6C3C4E7C97B404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C6C3C4E7C97B0090E5
++DATA2   80   30 D00C183D41D0F0F8503D000450D300080550583100006800300068203008
++DATA3   80   60 58301004582030002200476040404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001502022224780509A1B4412224720
++DATA2   80   30 503247805084132241440001D20F5130514060005120602051288C200001
++DATA3   80   60 123347A0505C4110515458F040404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001516005EF60005130602051381222
++DATA2   80   30 478050704110515858F0516005EF47F0503812444780508C4110515058F0
++DATA3   80   60 516405EF47F0508C6800514040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A840400038404000016820514858DD000498E5D00C92FF
++DATA2   80   30 D00C07FE12224720508C60005120602051285020518498EF516841205184
++DATA3   80   60 413051CD440F00520501040B40404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400018404000014110517018FE05EF9500518B4780
++DATA2   80   30 508C4110517C47F050004040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02E3E7E34000015040400038404000014110000000000000000000000000
++DATA2   80   30 000041100000000000000000000000000000000001600000015000000140
++DATA3   80   60 00000140000000000000000040404040F0F0F0F8
++DATA1   80    0 02E3E7E3400001884040001C404000010000000000000000000001B00000
++DATA2   80   30 01A8000001AC00000140800001A440404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E3400001AC4040003840400001000000F70000004AC9C8C3F2F4F7
++DATA2   80   30 C940C6C3C4E7C940C3D6D4D7D3C5E75CF1F640C2C1E2C57EF04BF04EF04B
++DATA3   80   60 F0C96B40C9D5E3C5C7C5D94040404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001E44040000940400001C5E7D7D6D5C5D5E37E4040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001F840400006404000016B40D3C540F04040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D0001700D0001740D00
++DATA2   80   30 01780D00017C0D0001900D0001940D0001980D00019C080001A100020001
++DATA3   80   60 0C00018C000300011C00018840404040F0F0F1F3
++DATA1   80    0 02D9D3C4404040404040001040404040000400010C000180000500010C00
++DATA2   80   30 018440404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F4
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F5
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFCOME EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C3D6D4C5000000004000
++DATA2   80   30 17CCC9C2C3D6D47B40400100000040000001C6C9D6C3E27B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040404040C6C4C9D6C3E27B40010000BC4000
++DATA2   80   30 0001C9D5E3E2E6E3C3C801000BC640000001C9C8C3C5D9D9D44001000818
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040001040404040C5D9D9D4D6D54040010008184000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E340000000404000384040000147F0F11C47F0F12447F0F3AA47F0
++DATA2   80   30 F3DC47F0F46047F0F48E47F0F49647F0F4C047F0F50E47F0F62A47F0F68C
++DATA3   80   60 47F0F6A647F0F6AE47F0F73240404040F0F0F0F4
++DATA1   80    0 02E3E7E340000038404000384040000147F0F73A47F0F81C47F0F8B847F0
++DATA2   80   30 FB0800005810F0B45810FBB05810F6E05810F6D85810F6D85810FBB05810
++DATA3   80   60 F6D85810F6E807000004000040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000704040000B40400001000092FFFBC69200FBC600404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02E3E7E34000007C4040001040400001FF00000000000000000000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02E3E7E34000008C40400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000009040400008404000010000000041200000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E34000009C4040003840400001D200A0009000D2009000A000D200
++DATA2   80   30 20009000D2009000200000000000000006EC00000C1E0000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F1F0
++DATA1   80    0 02E3E7E3400000D440400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02E3E7E34000010C40400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02E3E7E34000011840400038404000010000000092F0F15947F0F12892FF
++DATA2   80   30 F159900CF0D84150F1729400F06E182E58A0E0045810F0B49180E0004780
++DATA3   80   60 F15296FFF06E41E0E004581040404040F0F0F1F3
++DATA1   80    0 02E3E7E3400001504040003840400001F0BC5010F0980501000047000000
++DATA2   80   30 1B771B889078F08C5070F11841832000189207F55020F11041E0E0081B55
++DATA3   80   60 4350A0008B5000014950F1D840404040F0F0F1F4
++DATA1   80    0 02E3E7E340000188404000084040000147A0F1DA47F5F190404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F5
++DATA1   80    0 02E3E7E340000190404000384040000147F0F1DA47F0F1EA47F0F1F647F0
++DATA2   80   30 F20A47F0F21847F0F33C47F0F34447F0F34447F0F35C47F0F22247F0F364
++DATA3   80   60 47F0F1DA47F0F24647F0F27840404040F0F0F1F6
++DATA1   80    0 02E3E7E3400001C8404000384040000147F0F2AC47F0F2CA47F0F1DA47F0
++DATA2   80   30 F2D6004841E000D350E0F72C4110F72047F0F03C41A0A00150A0F11447F0
++DATA3   80   60 F17A4370A0014270F090427040404040F0F0F1F7
++DATA1   80    0 02E3E7E3400002004040003840400001F09141A0A00247F0F1EED200F092
++DATA2   80   30 A00141A0A00247F0F17AD200F093A00147F0F2104370A00106705840F110
++DATA3   80   60 1A47194847A0F47A5990F11840404040F0F0F1F8
++DATA1   80    0 02E3E7E340000238404000384040000147C0F2405090F118189447F0F210
++DATA2   80   30 4370A00141A0A002910FF1594710F2621A9719984720F47A47F0F17A1998
++DATA3   80   60 47A0F47A924090004190900140404040F0F0F1F9
++DATA1   80    0 02E3E7E34000027040400038404000014670F26247F0F17A4370A00141A0
++DATA2   80   30 A00218481B4919744720F47A0670910FF1594710F29C4470F09C47F0F2A0
++DATA3   80   60 4470F0A24197900141A7A00140404040F0F0F2F0
++DATA1   80    0 02E3E7E3400002A8404000384040000147F0F17A41A0A00191FEF0904780
++DATA2   80   30 F17A58A0F1144370F09006704270F09047F0F17A4560F2F041A0A00147F0
++DATA3   80   60 F17A92FFF08C47F0F398456040404040F0F0F2F1
++DATA1   80    0 02E3E7E3400002E04040003840400001F2F0D200F090F09158A0F11447F0
++DATA2   80   30 F17A9023F720910FF1594710F3049201F32647F0F3209202F32618295920
++DATA3   80   60 F11847A0F3165820F118D70340404040F0F0F2F2
++DATA1   80    0 02E3E7E3400003184040003840400001F118F1185B20F1105810F0980501
++DATA2   80   30 0000470000005020F1104183200018929823F72007F64150000047F0F348
++DATA3   80   60 41500001D201F445A001D20040404040F0F0F2F3
++DATA1   80    0 02E3E7E3400003504040003840400001F447F09341A0A00347F0F3784150
++DATA2   80   30 000247F0F36841500003D200F445A001D201F446F06A41A0A0028B500003
++DATA3   80   60 910FF1594780F3884150500440404040F0F0F2F4
++DATA1   80    0 02E3E7E340000388404000384040000191FFF08C4780F3989200F08C4560
++DATA2   80   30 F42091FFF08D4710F412904CF6EC980CF0D807FE900CF0D8D203F720E000
++DATA3   80   60 41E0E004D200F444F720940040404040F0F0F2F5
++DATA1   80    0 02E3E7E3400003C04040003840400001F720940FF721D603F720F0944400
++DATA2   80   30 F720984CF6EC4560F42047F0F398900CF0D8984CF6ECD207F720E00041E0
++DATA3   80   60 E008D200F444F7249400F72440404040F0F0F2F6
++DATA1   80    0 02E3E7E3400003F84040003840400001940FF72558C0F7245820F7201BBB
++DATA2   80   30 43B0F44492FFF08D4560F4201A2B46C0F40E9200F08D47F0F39891FFF08C
++DATA3   80   60 4710F2DE4370F445127747C040404040F0F0F2F7
++DATA1   80    0 02E3E7E3400004304040003840400001F44C4147900019484720F47A1839
++DATA2   80   30 5815F6CC0501000000004197900091FEF0924780F17A4370F09206704270
++DATA3   80   60 F09207F6900CF0D8984CF6EC40404040F0F0F2F8
++DATA1   80    0 02E3E7E3400004684040003840400001910FF1594780F4744560F2F0980C
++DATA2   80   30 F0D807FE910FF1594780F4864560F2F041E000D447F0F1DE9200F15947F0
++DATA3   80   60 F49A920FF159900CF0D8455040404040F0F0F2F9
++DATA1   80    0 02E3E7E3400004A04040003840400001F13018A21BBB910FF1594780F4B2
++DATA2   80   30 417000061B55904CF6EC980CF0D847F0E004900CF0D8D203F720E000D200
++DATA3   80   60 F08FF7209400F720940FF72140404040F0F0F3F0
++DATA1   80    0 02E3E7E3400004D84040003840400001D603F720F0944400F720984CF6EC
++DATA2   80   30 9200F71A43B0F08F18C81BC919CB4740F54E06B044B7F0A8419B9001904C
++DATA3   80   60 F6EC980CF0D847F0E004900C40404040F0F0F3F1
++DATA1   80    0 02E3E7E3400005104040003840400001F0D8984CF6ECD207F720E0005820
++DATA2   80   30 F72058B0F72454B0F714D200F719E0044CB0F7184830F718414001001163
++DATA3   80   60 5060F71018C81BC919C347B040404040F0F0F3F2
++DATA1   80    0 02E3E7E3400005484040003840400001F57292FFF71A12774770F5B691FF
++DATA2   80   30 F06E4710F5B612CC4780F5B606C044C0F0A8412C20011BBC46B0F5B6186C
++DATA3   80   60 19BC4720F57C186B196447D040404040F0F0F3F3
++DATA1   80    0 02E3E7E3400005804040003840400001F584186412774770F59291FFF06E
++DATA2   80   30 47C0F5965460F71006604467F0A841969001412620011BB646B0F540904C
++DATA3   80   60 F6EC980CF0D847F0E008902340404040F0F0F3F4
++DATA1   80    0 02E3E7E3400005B84040003840400001F72012774770F5E09201F60C91FF
++DATA2   80   30 F06E4710F6064BA0F06C9101A0024710F60641E000D547F0F1DE9202F60C
++DATA3   80   60 1B9A182991FFF06E4710F60640404040F0F0F3F5
++DATA1   80    0 02E3E7E3400005F040400038404000014BA0F06C9601A00212554780F602
++DATA2   80   30 9602A002415050015810F098050100004700000018A24183200018929823
++DATA3   80   60 F72091FFF71A4780F4F847F040404040F0F0F3F6
++DATA1   80    0 02E3E7E3400006284040003840400001F540900CF0D8984CF6EC910FF159
++DATA2   80   30 4710F66091FFF06E4710F6864BA0F06C9101A0024780F6865810F0B40501
++DATA3   80   60 01004700000018A247F0F64240404040F0F0F3F7
++DATA1   80    0 02E3E7E34000066040400038404000011B9A182991FFF06E4710F67A4BA0
++DATA2   80   30 F06C12554780F67A9602A0025810F0980501020047000000980CF0D807FE
++DATA3   80   60 9004F0D8182E5810F0B4050140404040F0F0F3F8
++DATA1   80    0 02E3E7E34000069840400034404000010300470000009804F0D847F0E004
++DATA2   80   30 9201F6BF47F0F6B29202F6BF9003F0D8182E5810F0B40501030047000000
++DATA3   80   60 9803F0D847F0E0044040404040404040F0F0F3F9
++DATA1   80    0 02E3E7E3400006CC404000204040000100000EB8000010A200000EB80000
++DATA2   80   30 148200000D0E00000FDA00000C8800000CD2404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F0
++DATA1   80    0 02E3E7E3400007144040000740400001000FFFFF00000040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F1
++DATA1   80    0 02E3E7E3400007284040000A404000010000072C0000000000F140404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F2
++DATA1   80    0 02E3E7E340000732404000384040000192FFFBC547F0F7429200FBC594BF
++DATA2   80   30 FBB490E5FB64055091FF547D47105016D208508154884110507047F05020
++DATA3   80   60 D2085081547F411050781B4440404040F0F0F4F3
++DATA1   80    0 02E3E7E34000076A40400038404000014340E00018344940509447C05034
++DATA2   80   30 4830509406304430547441203013402050785A20509C91FF547D4710505C
++DATA3   80   60 D201200050989280200247F040404040F0F0F4F4
++DATA1   80    0 02E3E7E3400007A240400038404000015066D20120005096924020029200
++DATA2   80   30 200347F050A0070001000BC400000BB400008000C9C8C3F0F04040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F5
++DATA1   80    0 02E3E7E3400007DA4040000E4040000140400006020040000000000007C0
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F6
++DATA1   80    0 02E3E7E3400007E840400038404000010A2391FF547D478050B498E5541C
++DATA2   80   30 45E0F044000058E0541C41E4E00150E0541C4110546C410000010A0198E5
++DATA3   80   60 541C07FE58F0F39058E0100840404040F0F0F4F7
++DATA1   80    0 02E3E7E34000082040400038404000015820E0004E20F7201841F321FBDD
++DATA2   80   30 F72696F0FBDF4120FBB85810F0B4050100FF47000000D2072000FBD94150
++DATA3   80   60 000895D8E0034780F87095DA40404040F0F0F4F8
++DATA1   80    0 02E3E7E3400008584040003840400001E0034780F87095E6E0034780F870
++DATA2   80   30 D501E002F7304740F89E581040005850100019534740F880185318350630
++DATA3   80   60 4430F8B295DAE0034770F89E40404040F0F0F4F9
++DATA1   80    0 02E3E7E340000890404000384040000141005004183F411100000A0A18F3
++DATA2   80   30 18255810F0B4050102004700000045E0F0440010D2002001100490D5FB60
++DATA3   80   60 05504110500C0511020008EA40404040F0F0F5F0
++DATA1   80    0 02E3E7E3400008C84040003840400001005D0A0E501052E65810F0B41842
++DATA2   80   30 412052FA050100FF47000000182498E552A607FE92D7F312903DF286D20B
++DATA3   80   60 F27A1014D207F2B2100C588040404040F0F0F5F1
++DATA1   80    0 02E3E7E3400009004040002840400001F2BE1891484010064B40F2068B40
++DATA2   80   30 00024780F03A4940F06647A0F1F291FFF2DC4710F08C47F4F03E40404040
++DATA3   80   60 40404040404040404040404040404040F0F0F5F2
++DATA1   80    0 02E3E7E340000930404000384040000147F0F14A47F0F08047F0F14A47F0
++DATA2   80   30 F08047F0F06847F0F07447F0F14A47F0F080002892FF804896F0807A47F0
++DATA3   80   60 F08C920F8048960F807A47F040404040F0F0F5F3
++DATA1   80    0 02E3E7E3400009684040003840400001F08C92FF80499400F21547F0F14A
++DATA2   80   30 950C10074770F09C4170000147F0F0A0417000095860100896FFF2151B55
++DATA3   80   60 1BBB412000021F62126647B040404040F0F0F5F4
++DATA1   80    0 02E3E7E3400009A04040003840400001F0BA1F62954460004770F1144110
++DATA2   80   30 F27A484060028C400010434060018D40001041B0003C41300FFF14348840
++DATA3   80   60 00064100000288400004182B40404040F0F0F5F5
++DATA1   80    0 02E3E7E3400009D8404000384040000114244780F0F84400F20C4600F0E8
++DATA2   80   30 884000041863182B14244780F10E435210034300600116504100000396FF
++DATA3   80   60 F214911060004710F12C940040404040F0F0F5F6
++DATA1   80    0 02E3E7E340000A104040003840400001F21441000007413000F01A7012BB
++DATA2   80   30 4770F13C4350600114534450F1F891FFF2DC4710F1BA4120F2CE5810F2C2
++DATA3   80   60 050100FF47000000D227200040404040F0F0F5F7
++DATA1   80    0 02E3E7E340000A484040003840400001F2F7413020281829412020045810
++DATA2   80   30 F2C6050108144120003C95FFF2154770F1A6D211301EF31F413030304120
++DATA3   80   60 F03E5810F2C605010814412040404040F0F0F5F8
++DATA1   80    0 02E3E7E340000A804040003840400001006C95FFF2144770F1A6D207300C
++DATA2   80   30 30145810F2C2050102004700000095FFF2154770F1F2950D90074780F1C6
++DATA3   80   60 4457F1F8184588400004165440404040F0F0F5F9
++DATA1   80    0 02E3E7E340000AB84040003840400001950D90074770F1E64457F1F8910A
++DATA2   80   30 600047E0F1E694CF90089180F03E4780F1F24450F20A983DF28607FE6000
++DATA3   80   60 F03E7800F2166800F2163B0040404040F0F0F6F0
++DATA1   80    0 02E3E7E340000AF04040000A4040000100062B0031005E32100040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F6F1
++DATA1   80    0 02E3E7E340000B0040400038404000017FFFFFFFFFFFFFFF05504840E000
++DATA2   80   30 581050A20501040047000000410051145810F0BC19014780503805010400
++DATA3   80   60 470000005810509A1211478040404040F0F0F6F2
++DATA1   80    0 02E3E7E340000B38404000284040000150380A0E47F05046070041105044
++DATA2   80   30 05110000000000000A0E58D0505658E0D00C18F4980CD01407FE40404040
++DATA3   80   60 40404040404040404040404040404040F0F0F6F3
++DATA1   80    0 02E3E7E340000BA84040003840400001000000000000000000000C260000
++DATA2   80   30 000004000000D200F7D2E0010008000000F2C940E2E3D6D74040F1C140D7
++DATA3   80   60 C1E4E2C540F0C9C8C340404040404040F0F0F6F4
++DATA1   80    0 02E3E7E340000BE04040003840400001C9F0C9C8C3F2F1F0C940D7D9D6C7
++DATA2   80   30 D9C1D440C9D5E3C5D9D9E4D7E34D405D40D6D3C440D7E2E640C9E2D9C5C7
++DATA3   80   60 C9E2E3C5D940C3D6D5E3C1C940404040F0F0F6F5
++DATA1   80    0 02E3E7E340000C184040000640400001D5C5C4F2F1F84040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F6F6
++DATA1   80    0 02E3E7E340000C1E404000084040000141E000E747F0F1DE404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F6F7
++DATA1   80    0 02E3E7E340000C2640400038404000019026195218501B441B6643405000
++DATA2   80   30 436050011A241A360620F32119A92000D30119A919A8DC0119A919F50630
++DATA3   80   60 D200300019AA4660103A47F040404040F0F0F6F8
++DATA1   80    0 02E3E7E340000C5E4040002A4040000110580630D200300019A94660104A
++DATA2   80   30 47F01058464010160630924030004660104E98261952181047F010024040
++DATA3   80   60 40404040404040404040404040404040F0F0F6F9
++DATA1   80    0 02E3E7E340000C884040003840400001902618F018501B441B6643405000
++DATA2   80   30 436050011B64474010421A36064044401978126647A01038106641242001
++DATA3   80   60 92402000412020014660102C40404040F0F0F7F0
++DATA1   80    0 02E3E7E340000CC04040001240400001982618F0181047F0100243405001
++DATA2   80   30 47F0101A4040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F1
++DATA1   80    0 02E3E7E340000CD24040003840400001902618A618501B441B6643405000
++DATA2   80   30 436050011B6447C010349240300041303001466010180640444019349826
++DATA3   80   60 18A6181047F010024340500140404040F0F0F7F2
++DATA1   80    0 02E3E7E340000D0A404000044040000147F0102440404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F3
++DATA1   80    0 02E3E7E340000D0E4040003840400001902C186A454010309140190C4780
++DATA2   80   30 101211BB910450004780102850B02000982C186A181047F0100240B02000
++DATA3   80   60 47F0101E05C018501B661B7740404040F0F0F7F4
++DATA1   80    0 02E3E7E340000D4640400038404000019067C87843605001437050021B88
++DATA2   80   30 1BAA1BBB90ABC8689200C8DA95F030004740C0AE95F930004720C0AE9680
++DATA3   80   60 C8DAD100C87B300055A0C8B840404040F0F0F7F5
++DATA1   80    0 02E3E7E340000D7E40400038404000014720C0A28DA000034590C08C4590
++DATA2   80   30 C08C5EB0C87847C0C05A4AA0C8D290ABC8689120C8DA4780C06A41707001
++DATA3   80   60 413030014660C0209110C8DA40404040F0F0F7F6
++DATA1   80    0 02E3E7E340000DB6404000384040000107849108C8DA4780C08211BB50B0
++DATA2   80   30 C87C98ABC87007F45EB0C86C47C0C09C4AA0C8D24710C0A25AA0C86807E9
++DATA3   80   60 98ABC8684180800147F0C05E40404040F0F0F7F7
++DATA1   80    0 02E3E7E340000DEE4040003840400001954030004780C0FC5040CA84D502
++DATA2   80   30 CA85CA894780C140954B30004780C10C95C530004780C11E95C430004780
++DATA3   80   60 C11E954E30004780C14C955040404040F0F0F7F8
++DATA1   80    0 02E3E7E340000E26404000384040000130004780C14C956030004780C160
++DATA2   80   30 41E000D747F0F1DE9180C8DA4780C06A9200C87B47F0C03A9130C8DA4750
++DATA3   80   60 C0F496A0C8DA1B7747F0C06A40404040F0F0F7F9
++DATA1   80    0 02E3E7E340000E5E40400038404000019110C8DA4710C0F49610C8DAD207
++DATA2   80   30 C870C8681BAA1BBB90ABC86894DFC8DA47F0C06A9180C8DA4780C0DC47F0
++DATA3   80   60 C0F49180C8DA4780C06A911040404040F0F0F8F0
++DATA1   80    0 02E3E7E340000E964040002240400001C8DA4710C06A47F0C1269180C8DA
++DATA2   80   30 4710C1709640C8DA47F0C06A9608C8DA47F0C15440404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F1
++DATA1   80    0 02E3E7E340000EB84040003840400001902D16C018DF58F017304400F072
++DATA2   80   30 58901734054912BB4770102612AA477010262B2247F010F490AB16F891FF
++DATA3   80   60 16F84780105A8CA0000490AB40404040F0F0F8F2
++DATA1   80    0 02E3E7E340000EF0404000384040000116F8910F16F8478010528CA00004
++DATA2   80   30 90AB16F8925016F847F0105E924F16F847F0105E924E16F8682017086A20
++DATA3   80   60 16F81B875A8017049110176240404040F0F0F8F3
++DATA1   80    0 02E3E7E340000F28404000384040000147101092D2001703500391801703
++DATA2   80   30 4780108E947F17035A80170047F010925B801700128847A0109C96041762
++DATA3   80   60 10B849B0171047C010CC910440404040F0F0F8F4
++DATA1   80    0 02E3E7E340000F6040400038404000011762471010B6682018B847F010F4
++DATA2   80   30 4BB0171249B01710474010C82B2247F010F46D2016B81BAA5DA017448FA0
++DATA3   80   60 0003684A163012BB478010E440404040F0F0F8F5
++DATA1   80    0 02E3E7E340000F9840400038404000016C4B167891041762478010F22D24
++DATA2   80   30 47F010F42C2491401762478010FE2122910450004780111A702020004400
++DATA3   80   60 F07618FD982D16C0181047F040404040F0F0F8F6
++DATA1   80    0 02E3E7E340000FD04040000A4040000110046020200047F0110A40404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F7
++DATA1   80    0 02E3E7E340000FDA40400038404000019027159E18501B66436050011A36
++DATA2   80   30 910450004780101E5870200047F01022487020009240164012774780105E
++DATA3   80   60 47201034926016404E7015FE40404040F0F0F8F8
++DATA1   80    0 02E3E7E3400010124040003840400001F3E715FE15FE96F0160C4120160D
++DATA2   80   30 415015FE4140000F95F0500047701072415050014640104E063092F03000
++DATA3   80   60 466010929827159E181047F040404040F0F0F8F9
++DATA1   80    0 02E3E7E34000104A404000384040000110021964474010B4478010AC0620
++DATA2   80   30 0630D200300020004660108E47F010684640107C0630D200300016404660
++DATA3   80   60 10A247F0106806309240300040404040F0F0F9F0
++DATA1   80    0 02E3E7E340001082404000204040000147F0109A956016404770107C5830
++DATA2   80   30 15A2925C300041303001466010B847F01068404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F9F1
++DATA1   80    0 02E3E7E3400010A24040003840400001902D14D69202157845401016982D
++DATA2   80   30 14D6181047F0100405C018501B771B661B88910450004780C1482B667860
++DATA3   80   60 200032667060C4EE4780C36C40404040F0F0F9F2
++DATA1   80    0 02E3E7E3400010DA404000384040000192FFFBC69180C4EE4780C0389640
++DATA2   80   30 C560947FC4EE7860C4EE4360C4EE5460C6BE9108C4EE4780C04C41660008
++DATA3   80   60 41A6C5966C60A0008A60000240404040F0F0F9F3
++DATA1   80    0 02E3E7E340001112404000384040000141A6C6C64A8A00007060C4EE9548
++DATA2   80   30 C4EE47A0C1529539C4EE47C0C15A953CC4EE4780C16E9545C4EE4780C162
++DATA3   80   60 4360C4EE5460C6C28960000340404040F0F0F9F4
++DATA1   80    0 02E3E7E34000114A404000384040000141A6C6166C60A0008A60000241A6
++DATA2   80   30 C6E64A8A00007060C4EE9540C4EE4770C0644980C50E4720C0CC6A60C6AE
++DATA3   80   60 6960C6164740C0CC6C60C61E40404040F0F0F9F5
++DATA1   80    0 02E3E7E34000118240400038404000014A80C6E86C60C66E416000186E60
++DATA2   80   30 C6A67060C4EE9200C4EE58A0C4EE4EA6C5764B60C6F44780C11441B6C576
++DATA3   80   60 940FB00F4FA6C57E50A6C57640404040F0F0F9F6
++DATA1   80    0 02E3E7E3400011BA40400038404000015076C57A9246B0006B66C5766C60
++DATA2   80   30 C67647F0C0D4F363C51EC592F353C524C58AF353C529C5829200FBC64190
++DATA3   80   60 C51E41D0001095F09000477040404040F0F0F9F7
++DATA1   80    0 02E3E7E3400011F24040003840400001C1AA4B80C5584190900106D047F0
++DATA2   80   30 C13268602000226647F0C0184160004047F0C0904160004847F0C0909180
++DATA3   80   60 C4EF4780C17A47F0C186918040404040F0F0F9F8
++DATA1   80    0 02E3E7E34000122A4040003840400001C4EF4780C19247F0C19E6C60C696
++DATA2   80   30 4A80C6F047F0C0A46C60C63E4A80C70647F0C0A46C60C69E4B80C70647F0
++DATA3   80   60 C0A46C60C6764B80C6F047F040404040F0F0F9F9
++DATA1   80    0 02E3E7E3400012624040003840400001C0A41B225020C50291FF50034780
++DATA2   80   30 C1DAD200C50550039180C5054780C1D2947FC5055B20C50247F0C1D65A20
++DATA3   80   60 C5025020C5029101C560471040404040F0F1F0F0
++DATA1   80    0 02E3E7E34000129A4040003840400001C1E41A28436050014370500218A2
++DATA2   80   30 1AA712AA4740C24C49A0C51247A0C24C1AA995F5A0004740C24C06A019A9
++DATA3   80   60 4740C23295F9A0004780C22A40404040F0F1F0F1
++DATA1   80    0 02E3E7E3400012D240400038404000011BBB43B0A00041B0B00142B0A000
++DATA2   80   30 47F0C24C92F0A00047F0C20892F1A000189A41D0D0014A80C5589101C560
++DATA3   80   60 4710C24C4A20C55841A0700140404040F0F1F0F2
++DATA1   80    0 02E3E7E34000130A4040003840400001122247C0C2581AA29102C5604710
++DATA2   80   30 C26441A0A0041B6A4740C3544780C34C1A365030C53A12224780C2B64720
++DATA3   80   60 C2AC1022924B30004130300140404040F0F1F0F3
++DATA1   80    0 02E3E7E34000134240400038404000019620C560127747C0C30092F03000
++DATA2   80   30 413030014670C2A247F0C3004620C29218B747F0C2CA9604C56018B247F0
++DATA3   80   60 C2CA924B300041303001962040404040F0F1F0F4
++DATA1   80    0 02E3E7E34000137A4040003840400001C560127747C0C30018B712DD47C0
++DATA2   80   30 C2ECD20030009000413030014190900146B0C2E806D047F0C2F846D0C2D0
++DATA3   80   60 92F030004130300146B0C2EC40404040F0F1F0F5
++DATA1   80    0 02E3E7E3400013B240400038404000019120C5604780C2B6126607845830
++DATA2   80   30 C53A9104C5604710C32C06309140C5604780C3224960C5584780C33692F0
++DATA3   80   60 30004660C32C07F49140C56040404040F0F1F0F6
++DATA1   80    0 02E3E7E3400013EA40400038404000014780C3400630926030004660C340
++DATA2   80   30 07F40630924030004660C34007F49140C5604780C26E1A6A925C30004130
++DATA3   80   60 30014660C356982DC4BE181040404040F0F1F0F7
++DATA1   80    0 02E3E7E340001422404000384040000147F0100443605001437050029240
++DATA2   80   30 3000413030014660C37441D0000312774770C38E41D0000241A070039101
++DATA3   80   60 C5604780C39E41A0A004419040404040F0F1F0F8
++DATA1   80    0 02E3E7E34000145A4040002840400001C5711B3A5930C4C247A0C3C04130
++DATA2   80   30 30014190900146D0C3A44360500147F0C35644D0C55247F0C36240404040
++DATA3   80   60 40404040404040404040404040404040F0F1F0F9
++DATA1   80    0 02E3E7E3400014824040003840400001902D10F6920111985890116E0549
++DATA2   80   30 583011721A3A4B301192910450004780102892C5300047F0102C92C43000
++DATA3   80   60 5B80113A12884740103E924040404040F0F1F1F0
++DATA1   80    0 02E3E7E3400014BA4040002A40400001300147F010449260300110884E80
++DATA2   80   30 1156F3111156115C96F01157D20130021156982D10F6181047F010044040
++DATA3   80   60 40404040404040404040404040404040F0F1F1F1
++DATA1   80    0 02E3E7E3400014E84040003840400001411000000000000041A000000000
++DATA2   80   30 00004264000000000000433E800000000000442710000000000045186A00
++DATA3   80   60 0000000045F424000000000040404040F0F1F1F2
++DATA1   80    0 02E3E7E34000152040400010404000014698968000000000475F5E100000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F1F3
++DATA1   80    0 02E3E7E3400015304040003840400001483B9ACA00000000492540BE4000
++DATA2   80   30 00005156BC75E2D6310059C9F2C9CD04674F621D6329F1C35CA56A446C3B
++DATA3   80   60 15F99267729F4F2726179A2340404040F0F1F1F4
++DATA1   80    0 02E3E7E34000156840400010404000017B172EBAD6DDC73C508AC7230489
++DATA2   80   30 E80040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F1F5
++DATA1   80    0 02E3E7E3400015C040400012404000014E00000000000000004B00130010
++DATA2   80   30 000000004040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F1F6
++DATA1   80    0 02E3E7E3400015E84040000C404000010000000000000D3E000010B84040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F1F7
++DATA1   80    0 02E3E7E3400015F840400037404000010FFFFFFF0000000AD20020003000
++DATA2   80   30 D20030002000D20030009000000100040005000800F0F1F2F3F4F5F6F7F8
++DATA3   80   60 F9C1C2C3C4C5C640F04BF04040404040F0F1F1F8
++DATA1   80    0 02E3E7E34000165040400038404000017B172EBAD6DDC73C729F4F272617
++DATA2   80   30 9A236A446C3B15F99267621D6329F1C35CA5621D6329F1C35CA559C9F2C9
++DATA3   80   60 CD04674F5156BC75E2D6310040404040F0F1F1F9
++DATA1   80    0 02E3E7E3400016884040003840400001492540BE40000000411000000000
++DATA2   80   30 00003944B82FA09B5A52302F3942192484462814484BFEEBC2A11F8B6131
++DATA3   80   60 3BBABCF9173BDCF495A9704640404040F0F1F2F0
++DATA1   80    0 02E3E7E3400016C040400010404000010F19B604AAACA62B06B0AF48EC79
++DATA2   80   30 AD2140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F2F1
++DATA1   80    0 02E3E7E3400016D040400038404000014110000000000000401999999999
++DATA2   80   30 999A3F28F5C28F5C28F63E4189374BC6A7F03D68DB8BAC710CB23C10C6F7
++DATA3   80   60 A0B5ED8D3B1AD7F29ABCAF4840404040F0F1F2F2
++DATA1   80    0 02E3E7E34000170840400038404000013A2AF31DC46118733944B82FA09B
++DATA2   80   30 5A52483B9ACA00000000475F5E1000000000469896800000000045186A00
++DATA3   80   60 00000000442710000000000040404040F0F1F2F3
++DATA1   80    0 02E3E7E3400017404040003840400001433E800000000000426400000000
++DATA2   80   30 00003CA7C5AC471B478445F4240000000000460000000000000040000000
++DATA3   80   60 000000047FFFFFFFFFFFFFFF40404040F0F1F2F4
++DATA1   80    0 02E3E7E3400017784040003840400001000000F00000000FFFBAFFC4FFCE
++DATA2   80   30 FFD8FFD8FFE2FFECFFF6000000090014001E00280032003C004600000001
++DATA3   80   60 00020003000400050007000840404040F0F1F2F5
++DATA1   80    0 02E3E7E3400017B040400014404000010009FFF7FFF8FFF9FFFAFFFCFFFD
++DATA2   80   30 FFFE0006FFFB404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F2F6
++DATA1   80    0 02E3E7E3400017C8404000044040000100000D1640404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F2F7
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D0000B80D0000BC0D00
++DATA2   80   30 06CC0D0006D00D0006D40D0006D80D0006DC0D0006E00D0006E40D0006E8
++DATA3   80   60 0D000728090007B90C0007BC40404040F0F1F2F8
++DATA1   80    0 02D9D3C4404040404040003040404040000100010D0007E4090008C50D00
++DATA2   80   30 0BA80D000BB00D0015E80D0015EC0D0015F00C0017C8000200010D0000B4
++DATA3   80   60 0C000BAC404040404040404040404040F0F1F2F9
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F1F3F0
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFCOMH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C3D6D4C8000000004000
++DATA2   80   30 0CD9C9C2C3D6D47B40400100000040000001C6C4C9D6C3E27B40010000BC
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400002C1C4C3D6D57B4040020000004040
++DATA2   80   30 4040C6C9D6C3E27B40400200000040404040C1D9C9E3C87B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040003040400005C1C4D1E2E6E3C3C8020000004040
++DATA2   80   30 4040C9C8C3E4D6D7E3400200000040404040C9D5E3E2E6E3C3C801000CBE
++DATA3   80   60 40000001404040404040404040404040F0F0F0F3
++DATA1   80    0 02C5E2C4404040404040003040400007C6C3E5C5D6E4E3D7020000004040
++DATA2   80   30 4040C6C3E5D3D6E4E3D70200000040404040C6C3E5C9D6E4E3D702000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02C5E2C440404040404000304040000AC6C3E5C3D6E4E3D7020000004040
++DATA2   80   30 4040C6C3E5C1D6E4E3D70200000040404040C6C3E5E9D6E4E3D702000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++DATA1   80    0 02C5E2C440404040404000304040000DE2C5D8C4C1E2C440020000004040
++DATA2   80   30 4040C9C8C3C3D6D4C8F20200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02C5E2C4404040404040003040400010C9C8C3C3D6D4C8F200000CE04000
++DATA2   80   30 0428E2C5D8C4C1E2C44001000FFE40000010C9C2C3D6D47B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02E3E7E340000000404000384040000147F0F11447F0F11C47F0F49247F0
++DATA2   80   30 F4CA47F0F5F847F0F8FA47F0F90247F0F94047F0F98E47F0FAB847F0FB26
++DATA3   80   60 47F0FB4447F0FB5047F0FB5C40404040F0F0F0F8
++DATA1   80    0 02E3E7E340000038404000044040000147F0FB6840404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E340000040404000384040000147F0FB7447F0FB8400005810FBC0
++DATA2   80   30 5810FBE45810FBD85810FBD05810FBD05810FBD45810FBDC5810FBE00000
++DATA3   80   60 00000B84000092FFFCBE920040404040F0F0F1F0
++DATA1   80    0 02E3E7E3400000784040000340400001FCBE004040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02E3E7E34000007C4040003840400001FF00000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000000000000
++DATA3   80   60 00000000000000000000000040404040F0F0F1F2
++DATA1   80    0 02E3E7E3400000B44040000C404000010000000000000000000000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++DATA1   80    0 02E3E7E3400000C440400004404000010000012C40404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F4
++DATA1   80    0 02E3E7E340000114404000384040000192F0F18D47F0F12092FFF18D90ED
++DATA2   80   30 F07C4130000841D0F1861B111B229012F10C5810FBC0182ED207FC1CE000
++DATA3   80   60 9180FC1C4780F1505810F0BC40404040F0F0F1F5
++DATA1   80    0 02E3E7E34000014C4040003840400001413030049110FC1C4780F1645853
++DATA2   80   30 20005050F10C413030049120FC1C4780F178585320005050F11041303004
++DATA3   80   60 41E2300050E0F07C5010FBC440404040F0F0F1F6
++DATA1   80    0 02E3E7E340000184404000384040000107FD41E0F19E0501000047F0F1BC
++DATA2   80   30 5020FC2C41832000189207FE1B775070FC945070FBB05070FC9858A0FC20
++DATA3   80   60 91FFFC204750F63247F0F1C240404040F0F0F1F7
++DATA1   80    0 02E3E7E3400001BC4040001C4040000145E0F04400101B554350A0008B50
++DATA2   80   30 00014950F22447A0F22647F5F1D840404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F8
++DATA1   80    0 02E3E7E3400001D8404000384040000147F0F7B847F0F24A47F0F25C47F0
++DATA2   80   30 F28E47F0F29C47F0F40E47F0F41447F0F41447F0F42C47F0F2A647F0F434
++DATA3   80   60 47F0F43C47F0F2D647F0F30C40404040F0F0F1F9
++DATA1   80    0 02E3E7E340000210404000384040000147F0F34047F0F38247F0F3F847F0
++DATA2   80   30 F38E47F0F444004C411000D35010FB984110FB8C58D0F0B8D20FD00CF07C
++DATA3   80   60 50D0F0C841D0F0C458F0FBA440404040F0F0F2F0
++DATA1   80    0 02E3E7E340000248404000384040000107FF41A0A0011BDD50A0FBA850D0
++DATA2   80   30 FBAC47F0F1C24370A00141D0D00149D0FC904740F27ED203FBB4FBA8D201
++DATA3   80   60 FBBCFBB0D203FBB8FBAC427040404040F0F0F2F1
++DATA1   80    0 02E3E7E3400002804040003840400001FBB04270FBB141A0A00247F0F250
++DATA2   80   30 D200FBB2A00141A0A00247F0F1C2D200FBB3A00147F0F2944370A0010670
++DATA3   80   60 5840FC2C1A471B484740F2C240404040F0F0F2F2
++DATA1   80    0 02E3E7E3400002B840400038404000014550F61E1A4947F0F2C41A485990
++DATA2   80   30 FC9847C0F2D05090FC98189447F0F2944370A00141A0A002910FF18D4710
++DATA3   80   60 F2F21A9719984720F61E47F040404040F0F0F2F3
++DATA1   80    0 02E3E7E3400002F04040003840400001F1C219984740F2FC4550F61E9240
++DATA2   80   30 9000419090014670F2F247F0F1C24370A00141A0A00218481B4919744720
++DATA3   80   60 F61E0670910FF18D4710F33040404040F0F0F2F4
++DATA1   80    0 02E3E7E34000032840400038404000014470FC7047F0F3344470FC764197
++DATA2   80   30 900141A7A00147F0F1C241A0A00191FEFBB04750F36C06D049D0FC8E4740
++DATA3   80   60 F1C2D203FBA8FBB4D201FBB040404040F0F0F2F5
++DATA1   80    0 02E3E7E3400003604040003840400001FBBCD203FBACFBB847F0F1C258A0
++DATA2   80   30 FBA858D0FBAC4370FBB006704270FBB047F0F1C24560F3AC41A0A00147F0
++DATA3   80   60 F1C292FFFC9447F0F478456040404040F0F0F2F6
++DATA1   80    0 02E3E7E3400003984040003840400001F3ACD200FBB0FBB158A0FBA858D0
++DATA2   80   30 FBAC47F0F1C29023FC24910FF18D4710F3C09201F3E247F0F3DC9202F3E2
++DATA3   80   60 18295920FC9847A0F3D2582040404040F0F0F2F7
++DATA1   80    0 02E3E7E3400003D04040003840400001FC98D703FC98FC985B20FC2C5810
++DATA2   80   30 FBC40501000047F0F1BC5020FC2C4183200018929823FC2407F692FFFC97
++DATA3   80   60 D200F40CA002D200F40DFBB340404040F0F0F2F8
++DATA1   80    0 02E3E7E340000408404000384040000147F0F41E00001B5547F0F4184150
++DATA2   80   30 0001D200F59DFBB3D201F59BA00141A0A00347F0F4584150000547F0F448
++DATA3   80   60 4150000A47F0F4484150000340404040F0F0F2F9
++DATA1   80    0 02E3E7E340000440404000384040000147F0F4484150000BD200F59BA001
++DATA2   80   30 D201F59CFC8C41A0A0028B500003910FF18D4780F4684150500491FFFC94
++DATA3   80   60 4780F4789200FC944560F53640404040F0F0F3F0
++DATA1   80    0 02E3E7E340000478404000384040000191FFFBBE4710F53691FFFC954710
++DATA2   80   30 F528904DFBF498EDF07C07FED203FC24E00041E0E00490EDF07CD200F59A
++DATA3   80   60 FC24D300FC9CFC259400FC2440404040F0F0F3F1
++DATA1   80    0 02E3E7E3400004B04040003840400001940FFC25D603FC24FC884400FC24
++DATA2   80   30 984DFBF44560F53647F0F478D207FC24E00041E0E00890EDF07C984DFBF4
++DATA3   80   60 D200F59AFC28D300FC9CFC2940404040F0F0F3F2
++DATA1   80    0 02E3E7E3400004E840400038404000019400FC28940FFC2958C0FC285820
++DATA2   80   30 FC2492FFFC951BBB43B0F59A91FFFC244780F50E43B0FC249180FC9C4780
++DATA3   80   60 F5244370F59A8A700001427040404040F0F0F3F3
++DATA1   80    0 02E3E7E3400005204040003840400001F59A1BB74560F5361A2B46C0F524
++DATA2   80   30 9200FC9547F0F47891FFFC944710F3969180FC9C4710F5C691FFFC974780
++DATA3   80   60 F57AD201F59CF40C4150006040404040F0F0F3F4
++DATA1   80    0 02E3E7E34000055840400038404000019560FC9C47A0F56AD201F59CFC8C
++DATA2   80   30 4350FC9C8A500001910FF18D4780F57A415050044370F59B127747C0F5A2
++DATA3   80   60 4147900019484720F61E183940404040F0F0F3F5
++DATA1   80    0 02E3E7E34000059040400038404000015810FBC858151000050100000000
++DATA2   80   30 4197900091FEFBB24780F5BE4370FBB206704270FBB291FFFBBE4710F5EA
++DATA3   80   60 07F69200FC9747F0F1C291FF40404040F0F0F3F6
++DATA1   80    0 02E3E7E3400005C84040003840400001FBBE4710F5EA92FFFBBE91FFFC95
++DATA2   80   30 4710F5464370F59A8A7000014270F59A47F0F5469200FBBE4370F59A1A27
++DATA3   80   60 47F0F54690EDF07C984DFBF440404040F0F0F3F7
++DATA1   80    0 02E3E7E3400006004040003840400001910FF18D4780F60C4560F3AC1B22
++DATA2   80   30 1B339023F10C980DF08492FFF07C07FE910FF18D4780F62A4560F3AC4110
++DATA3   80   60 00D447F0F22A9016FC381B3340404040F0F0F3F8
++DATA1   80    0 02E3E7E3400006384040002E404000011B445040FC344160F7B75060FBA8
++DATA2   80   30 9200F7B3D203F7B4F7B3181A1B225860FBA0DDFF100063284772F6664110
++DATA3   80   60 11004040404040404040404040404040F0F0F3F9
++DATA1   80    0 02E3E7E340000666404000384040000147F0F65447F0F6BE47F0F6E047F0
++DATA2   80   30 F82E47F0F83647F0F83E47F0F82647F0F7CC47F0F7D447F0F84647F0F84E
++DATA3   80   60 47F0F85647F0F85E47F0F81440404040F0F0F4F0
++DATA1   80    0 02E3E7E34000069E404000384040000147F0F7E647F0F86647F0F87447F0
++DATA2   80   30 F80847F0F80047F0F71247F0F72247F0F226D100FC3310008B4000035A40
++DATA3   80   60 FC345A40FC345A40FC30504040404040F0F0F4F1
++DATA1   80    0 02E3E7E3400006D64040003840400001FC344110100147F0F65441303001
++DATA2   80   30 4930FC9047C0F6FED203FBB4FC68D201FBBCFBB0D203FBB8FBAC5010FC68
++DATA3   80   60 4240FBB04240FBB15030FBAC40404040F0F0F4F2
++DATA1   80    0 02E3E7E34000070E404000384040000147F0F81C4560F772921EF7B44560
++DATA2   80   30 F79647F0F81C4560F7724630F73E9222F7B44560F7965810FC685830FBAC
++DATA3   80   60 47F0F81C91FEFBB04750F76440404040F0F0F4F3
++DATA1   80    0 02E3E7E34000074640400038404000014930FC8E47C0F81CD203FC68FBB4
++DATA2   80   30 D201FBB0FBBCD203FBACFBB847F0F81C4340FBB006404240FBB047F0F732
++DATA3   80   60 91FFF7B4078691FFFC9D478040404040F0F0F4F4
++DATA1   80    0 02E3E7E34000077E4040003840400001F78C4240F7B69200FC9D47F0F790
++DATA2   80   30 4240F7B591FFF7B507869016FC509816FC3841A0F7B491FEF7B34780F1C2
++DATA3   80   60 41A0F7B247F0F1C20600000040404040F0F0F4F5
++DATA1   80    0 02E3E7E3400007B6404000384040000100009200F7B3D203F7B4F7B39016
++DATA2   80   30 FC389816FC5007F69280F7B547F0F6D89208F7B4D600F7B5FC374560F796
++DATA3   80   60 47F0F81C12444720F7F0414040404040F0F0F4F6
++DATA1   80    0 02E3E7E3400007EE404000384040000100019218F7B44240F7B54560F796
++DATA2   80   30 47F0F81C4560F77247F0F81C4240F7B592FFFC9D47F0F81C9212F7B44240
++DATA3   80   60 F7B31B445040FC3447F0F6D840404040F0F0F4F7
++DATA1   80    0 02E3E7E34000082640400038404000019210F7B447F0F8189214F7B447F0
++DATA2   80   30 F8189216F7B447F0F8189224F7B447F0F818920AF7B447F0F818920CF7B4
++DATA3   80   60 47F0F818920EF7B447F0F81840404040F0F0F4F8
++DATA1   80    0 02E3E7E34000085E40400038404000019220F7B447F0F8184560F8D01B44
++DATA2   80   30 5040FC3447F0F6549200FC9ED200FC9F10005010FC6C1B44D5001001FC9F
++DATA3   80   60 4780F89A414040014110100140404040F0F0F4F9
++DATA1   80    0 02E3E7E340000896404000384040000147F0F884D5001002FC9F4770F8B8
++DATA2   80   30 4140400141101001910FF18D4780F88E47F0F8BC92FFFC9E5810FC6C4560
++DATA3   80   60 F8D091FFFC9E4710F81C47F040404040F0F0F5F0
++DATA1   80    0 02E3E7E3400008CE4040003840400001F87E12444110100107C618A10640
++DATA2   80   30 910FF18D4710F8EC4440FC7047F0F8F04440FC76419490014114A00107F6
++DATA3   80   60 9200F91547F0F906920FF91540404040F0F0F5F1
++DATA1   80    0 02E3E7E340000906404000384040000190EDF07C4130000445D0F12C0501
++DATA2   80   30 00004700000041A2000041832000189A1BBB1B77910FF9154780F9344170
++DATA3   80   60 00061B55904CFBF498EDF07C40404040F0F0F5F2
++DATA1   80    0 02E3E7E34000093E404000384040000107FE90EDF07CD203FC24E000D200
++DATA2   80   30 FCA0FC249400FC24940FFC25D603FC24FC884400FC24984CFBF49200FCA1
++DATA3   80   60 43B0FCA018C81BC919CB474040404040F0F0F5F3
++DATA1   80    0 02E3E7E3400009764040003840400001F9CE06B044B7FC7C419B9001904C
++DATA2   80   30 FBF4980CF08447F0E00490EDF07C984CFBF4D207FC24E0005820FC2458B0
++DATA3   80   60 FC2854B0FCA4D200FCA3E00440404040F0F0F5F4
++DATA1   80    0 02E3E7E3400009AE40400038404000014CB0FCA24830FCA2414001001163
++DATA2   80   30 5060FCA818C81BC919C347B0F9FE92FFFCA112774770FA429180FC1C4710
++DATA3   80   60 FA4212CC4780FA4206C044C040404040F0F0F5F5
++DATA1   80    0 02E3E7E3400009E64040003840400001FC7C412C20011BBC46B0FA4291FF
++DATA2   80   30 FCA14780F98247F0FA36186C19BC4720FA08186B196447D0FA1018641277
++DATA3   80   60 4770FA1E9180FC1C47C0FA2240404040F0F0F5F6
++DATA1   80    0 02E3E7E340000A1E40400038404000015460FCA806604467FC7C41969001
++DATA2   80   30 412620011BB646B0F9C0904CFBF4980CF08447F0E0089023FC2412774770
++DATA3   80   60 FA6C9201FA989180FC1C471040404040F0F0F5F7
++DATA1   80    0 02E3E7E340000A564040003840400001FA924BA0FC929101A0024710FA92
++DATA2   80   30 411000D547F0F22A9202FA981B9A18299180FC1C4710FA924BA0FC929601
++DATA3   80   60 A00212554780FA8E9602A00240404040F0F0F5F8
++DATA1   80    0 02E3E7E340000A8E4040003840400001415050015810FBC4050100004700
++DATA2   80   30 000041A2000041832000189A9823FC2491FFFCA14780F97847F0F9C090ED
++DATA3   80   60 F07C984CFBF4910FF915471040404040F0F0F5F9
++DATA1   80    0 02E3E7E340000AC64040003840400001FAEE9180FC1C4710FB144BA0FC92
++DATA2   80   30 9101A0024780FB145810FBC00501010047F0FB1418A247F0FAD01B9A1829
++DATA3   80   60 9180FC1C4710FB084BA0FC9240404040F0F0F6F0
++DATA1   80    0 02E3E7E340000AFE404000384040000112554780FB089602A0025810FBC4
++DATA2   80   30 05010200470000001B221B339023F10C980CF08492FFF07C07FE90EDF07C
++DATA3   80   60 182E5810FBC005010300470040404040F0F0F6F1
++DATA1   80    0 02E3E7E340000B36404000384040000100009804F08492FFF07C47F0E004
++DATA2   80   30 90EDF07C5850FBA047F051B490EDF07C5850FBA047F051BC90E6F07C5850
++DATA3   80   60 FBA047F051DC90E6F07C585040404040F0F0F6F2
++DATA1   80    0 02E3E7E340000B6E4040003840400001FBA047F051E650D0FCAC90E5F07C
++DATA2   80   30 5850FBA047F051305850FBA047F05094000000000000000080000B980000
++DATA3   80   60 00000400000000000000000040404040F0F0F6F3
++DATA1   80    0 02E3E7E340000BA640400002404000010000404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F6F4
++DATA1   80    0 02E3E7E340000BB040400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F6F5
++DATA1   80    0 02E3E7E340000BBC40400003404000010000004040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F6F6
++DATA1   80    0 02E3E7E340000BC040400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F6F7
++DATA1   80    0 02E3E7E340000BC840400028404000010000000000000000000000000000
++DATA2   80   30 000000000000000000000000000000000000000000000000000040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F6F8
++DATA1   80    0 02E3E7E340000C3040400008404000010000000000000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F6F9
++DATA1   80    0 02E3E7E340000C6840400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F0
++DATA1   80    0 02E3E7E340000C704040002440400001D200A0009000D2009000A000D200
++DATA2   80   30 20009000D200900020004120000007000001000200044040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F1
++DATA1   80    0 02E3E7E340000C9440400014404000010000000000000000000000000000
++DATA2   80   30 0000000FFFFF404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F2
++DATA1   80    0 02E3E7E340000CB040400029404000010000000000000000000000000000
++DATA2   80   30 00F2C940E2E3D6D74040F1C140D7C1E4E2C5400000000000000000404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F3
++DATA1   80    0 02E3E7E340000CE0404000384040001090ECD00C5880F04050D0F05018CD
++DATA2   80   30 41D0F04C50D0C0081871186041308CD45030F0484100F02A47F0F032C9C8
++DATA3   80   60 C3E2E3C1C5401B110A0892FF40404040F0F0F7F4
++DATA1   80    0 02E3E7E340000D1840400010404000108CD818F00700053F000000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F5
++DATA1   80    0 02E3E7E340000D744040003840400010186F4840E00058106BC005010400
++DATA2   80   30 47F0509A4100531E581060BC1901478050BC0501040047F0509A58106BEC
++DATA3   80   60 95001000478050DA9200100040404040F0F0F7F6
++DATA1   80    0 02E3E7E340000DAC4040003840400010450050D8C9C8C3C1C4D1E2E30A09
++DATA2   80   30 58106BF01211478050EA0A0E47F050F8411050F605110000000000000A0E
++DATA3   80   60 95FF6CD84770511A58106CD440404040F0F0F7F7
++DATA1   80    0 02E3E7E340000DE4404000084040001098241020986F1030404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F8
++DATA1   80    0 02E3E7E340000DEC4040000E4040001047F05114C00000F0581051100A0D
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F9
++DATA1   80    0 02E3E7E340000DFA4040003840400010410000040A3C58D06CAC58E0D00C
++DATA2   80   30 18F4980CD01407FE182F584D0010504020C058402BE858302BCC91404004
++DATA3   80   60 47805166411051560511020040404040F0F0F8F0
++DATA1   80    0 02E3E7E340000E3240400038404000100000025D50301000920210000A0E
++DATA2   80   30 47F0517C070041105172051102000000005D50301000920210000A0E5010
++DATA3   80   60 2BF058102BC0184241202B9C40404040F0F0F8F1
++DATA1   80    0 02E3E7E340000E6A4040003840400010050100FF47000000182492FF207C
++DATA2   80   30 451051A400000CE00000000041000000411100000A3C98E5207C07FE9201
++DATA3   80   60 51CB47F051C0920251CB186F40404040F0F0F8F2
++DATA1   80    0 02E3E7E340000EA24040001A40400010182E58106BC00501030047000000
++DATA2   80   30 92FF607C9806608447F0E004404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F3
++DATA1   80    0 02E3E7E340000EBC4040003840400010186F92FF6CBD47F051F0186F9200
++DATA2   80   30 6CBD94BF6CB8075091FF6CBD47105208D208528D6CC84110527C47F05212
++DATA3   80   60 D208528D6CBF411052841B4440404040F0F0F8F4
++DATA1   80    0 02E3E7E340000EF440400038404000104340E0001834494052D447C05226
++DATA2   80   30 483052D406304430531895006CBD47805248F2246CB552964F406CB04040
++DATA3   80   60 52F01244478052E84120301340404040F0F0F8F5
++DATA1   80    0 02E3E7E340000F2C4040003840400010402052845A2052F491FF6CBD4710
++DATA2   80   30 526AD201200052D89280200247F05274D201200052D69240200292002003
++DATA3   80   60 47F052DA01000CBC00000CB840404040F0F0F8F6
++DATA1   80    0 02E3E7E340000F64404000384040001000008000C9C8C3F0F04040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F7
++DATA1   80    0 02E3E7E340000F9C40400014404000104040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F8
++DATA1   80    0 02E3E7E340000FB44040000640400010003A020040004040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F9
++DATA1   80    0 02E3E7E340000FBA40400038404000100A2392FF607C91FF6CBD478052F8
++DATA2   80   30 98E6607C45E0F0440000000000000F6458E0607C41E4E00150E0607C92FF
++DATA3   80   60 607C41106CB8410000010A0140404040F0F0F9F0
++DATA1   80    0 02E3E7E340000FF24040000C4040001098E6607C07FED2005296E0014040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F9F1
++DATA1   80    0 02E3E7E340000FFE4040000840400010411000E747F0F22A404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F9F2
++DATA1   80    0 02E3E7E34000100840400038404000105454545454545454545454545454
++DATA2   80   30 545454545454545454545454545454545454545454545454545454545454
++DATA3   80   60 54545454545454545454545440404040F0F0F9F3
++DATA1   80    0 02E3E7E34000104040400038404000105454545454545454005454545454
++DATA2   80   30 54545444544450085454545454545454545454545454545054541C4C5454
++DATA3   80   60 54545454544854480854545440404040F0F0F9F4
++DATA1   80    0 02E3E7E34000107840400038404000105454545454545454545454544040
++DATA2   80   30 545454545454545454545454545454545454545454545454545454545454
++DATA3   80   60 54545454545454545454545440404040F0F0F9F5
++DATA1   80    0 02E3E7E3400010B040400038404000105454545454545454545454545454
++DATA2   80   30 54545454545454545454540C54542C2824303C1854545454545454545410
++DATA3   80   60 54545420545454545454545440404040F0F0F9F6
++DATA1   80    0 02E3E7E3400010E840400020404000105454543454545438541454545454
++DATA2   80   30 545404040404040404040404545454545454404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F9F7
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D00006C0D0000C40800
++DATA2   80   30 0B95000200010C000BC8000300010C000BC0000400010C000BCC00050001
++DATA3   80   60 0C000BEC000600010C000BE840404040F0F0F9F8
++DATA1   80    0 02D9D3C4404040404040003840404040000700010C000BD0000800010C00
++DATA2   80   30 0BD4000900010C000BD8000A00010C000BDC000B00010C000BE0000C0001
++DATA3   80   60 0C000BE4000D00011C0000BC40404040F0F0F9F9
++DATA1   80    0 02D9D3C4404040404040003840404040000E00011C000BA0000F00011C00
++DATA2   80   30 0BA40001001009000F5D0C000F60000F00101C000D24001000100D000E7C
++DATA3   80   60 0C000FD4001100101C000D2040404040F0F1F0F0
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F0F8C1D7D9F7F040F0F84BF4F14040F361F2F261
++DATA3   80   60 F7F14040404040404040404040404040F0F1F0F1
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFCVTH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C3E5E3C8000000004000
++DATA2   80   30 119DC1C4C3D6D57B40400100000040000001C9C2C3D6D47B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040404040C9D5E3F6E2E6C3C80100103B4000
++DATA2   80   30 0001C6C3E5C5D6E4E3D701000B3A40000001C6C3E5D3D6E4E3D70100013A
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040003040404040C6C3E5C9D6E4E3D7010006384000
++DATA2   80   30 0001C6C3E5C3D6E4E3D701000D5440000001C6C3E5C1D6E4E3D7010000AA
++DATA3   80   60 40000001404040404040404040404040F0F0F0F3
++DATA1   80    0 02C5E2C4404040404040002040400003C6C3E5E9D6E4E3D70100028A4000
++DATA2   80   30 0001C9C8C3C5D9D9D4400200000040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000004040003840400001000004F80000071A000004F80000
++DATA2   80   30 0B3A000000E60000013A000000E60000013A000002E600000638000002E6
++DATA3   80   60 00000638000004F800000BA440404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000384040002840400001000004F800000BA400000C7A0000
++DATA2   80   30 0D5400000C7A00000D5400000060000000AA0000018E0000028A40404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02E3E7E340000060404000384040000190261FA018501B441B6643405000
++DATA2   80   30 436050011B64474010421A36064044401F8C126647A01038106641242001
++DATA3   80   60 92402000412020014660102C40404040F0F0F0F7
++DATA1   80    0 02E3E7E340000098404000124040000198261FA0181047F0100243405001
++DATA2   80   30 47F0101A4040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E3400000AA404000384040000190261F5618501B441B6643405000
++DATA2   80   30 436050011B6447C01034924030004130300146601018064044401F489826
++DATA3   80   60 1F56181047F010024340500140404040F0F0F0F9
++DATA1   80    0 02E3E7E3400000E2404000044040000147F0102440404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02E3E7E3400000E6404000384040000190261F1A18501B66436050011B44
++DATA2   80   30 95E330004780104C95C6300047801026413030014660100E910450004780
++DATA3   80   60 104492FF1F5550402000920040404040F0F0F1F1
++DATA1   80    0 02E3E7E34000011E4040001C404000011F5598261F1A181047F010024240
++DATA2   80   30 200047F0103A4140000147F0102640404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02E3E7E34000013A404000384040000190261EC618501B66436050019240
++DATA2   80   30 3000413030014660100C0630910450004780104292FF1F01584020009200
++DATA3   80   60 1F0112444770104C92C6300040404040F0F0F1F3
++DATA1   80    0 02E3E7E3400001724040001C4040000198261EC6181047F010021B444340
++DATA2   80   30 200047F0102E92E3300047F0103840404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F4
++DATA1   80    0 02E3E7E34000018E404000384040000190291E7218501B441B6643405000
++DATA2   80   30 436050011A241A3692001EA641701EA541800002126647C010D6063095F0
++DATA3   80   60 30004740107095F93000472040404040F0F0F1F5
++DATA1   80    0 02E3E7E3400001C640400038404000011070D20070003000066006704680
++DATA2   80   30 1022F2121EA21EA40620D20020001EA24640101A91FF1EA6478010669680
++DATA3   80   60 200098291E72181047F0100240404040F0F0F1F6
++DATA1   80    0 02E3E7E3400001FE404000384040000195C130004740109095C630004720
++DATA2   80   30 1090D20070003000DC0070001DE647F0104095403000478010CA954E3000
++DATA3   80   60 478010D695503000478010D640404040F0F0F1F7
++DATA1   80    0 02E3E7E340000236404000384040000195603000478010D292F21FE2D20A
++DATA2   80   30 1FF81FCD92E11FB54190102A90C11F2A47F012AC92F0700047F0104092FF
++DATA3   80   60 1EA6468010EE940F1EA5062040404040F0F0F1F8
++DATA1   80    0 02E3E7E34000026E4040001C40400001D20020001EA5464010EE47F0105A
++DATA2   80   30 062092002000464010EE47F0105A40404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F9
++DATA1   80    0 02E3E7E34000028A404000384040000190261DEA18501B441B6643405000
++DATA2   80   30 436050011A241A3606200630F3211DA72000DC011DA71DA2D20030001DA8
++DATA3   80   60 4660103447F010520630D20040404040F0F0F2F0
++DATA1   80    0 02E3E7E3400002C2404000244040000130001DA74660104447F010524640
++DATA2   80   30 10160630924030004660104898261DEA181047F010024040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F1
++DATA1   80    0 02E3E7E3400002E64040003840400001902C1D1A4540104891401D4E4780
++DATA2   80   30 101211BB9105500092FF1D5547801038910450004780104050B02000982C
++DATA3   80   60 1D1A92001D55181047F0100240404040F0F0F2F2
++DATA1   80    0 02E3E7E34000031E404000384040000140B0200047F0102A42B0200047F0
++DATA2   80   30 102A05C018501B661B779067CDB043605001437050021B881BAA1BBB90AB
++DATA3   80   60 CDA09200CD0495F03000474040404040F0F0F2F3
++DATA1   80    0 02E3E7E3400003564040003840400001C0AE95F930004720C0AE9680CD04
++DATA2   80   30 D100CDB3300055A0CDD84720C0A28DA000034590C08C4590C08C5EB0CDB0
++DATA3   80   60 47C0C05A4AA0CC9A90ABCDA040404040F0F0F2F4
++DATA1   80    0 02E3E7E34000038E40400038404000019120CD044780C06A417070014130
++DATA2   80   30 30014660C0209110CD0407849108CD044780C08211BB50B0CDB498ABCDA8
++DATA3   80   60 07F45EB0CDA447C0C09C4AA040404040F0F0F2F5
++DATA1   80    0 02E3E7E3400003C64040003840400001CC9A4710C0A25AA0CDA007E998AB
++DATA2   80   30 CDA04180800147F0C05E954030004780C14C5040CE18D502CE19CE1D4780
++DATA3   80   60 C190954B30004780C15C95C540404040F0F0F2F6
++DATA1   80    0 02E3E7E3400003FE404000384040000130004780C16E95C430004780C16E
++DATA2   80   30 954E30004780C19C955030004780C19C956030004780C1B092F1CE40D20A
++DATA3   80   60 CE56CE2092D7CE134190C02040404040F0F0F2F7
++DATA1   80    0 02E3E7E340000436404000384040000190C1CD8805C058F0CBC058D0F0B8
++DATA2   80   30 D20FD00CF07C50D0F0C841D0F0C44110CCF45030100C9280100CD200CD60
++DATA3   80   60 300058F0CBBC05EF58D0CD0840404040F0F0F2F8
++DATA1   80    0 02E3E7E34000046E404000384040000112DD98C1CC7C077992F0300007F9
++DATA2   80   30 9180CD044780C06A9200CDB347F0C03A9130CD044750C0F496A0CD041B77
++DATA3   80   60 47F0C06A9110CD044710C0F440404040F0F0F2F9
++DATA1   80    0 02E3E7E3400004A640400038404000019610CD04D207CDA8CDA01BAA1BBB
++DATA2   80   30 90ABCDA094DFCD0447F0C06A9180CD044780C0DC47F0C0F49180CD044780
++DATA3   80   60 C06A9110CD044710C06A47F040404040F0F0F3F0
++DATA1   80    0 02E3E7E3400004DE4040001A40400001C1769180CD044710C1C09640CD04
++DATA2   80   30 47F0C06A9608CD0447F0C1A4404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F1
++DATA1   80    0 02E3E7E3400004F84040003840400001902D1B0860201BB060401BB818DF
++DATA2   80   30 58F01B044400F07258901B44054912BB4770102E12AA4770102E2B2247F0
++DATA3   80   60 110290AB1BE091FF1BE0478040404040F0F0F3F2
++DATA1   80    0 02E3E7E340000530404000384040000110628CA0000490AB1BE0910F1BE0
++DATA2   80   30 4780105A8CA0000490AB1BE092501BE047F01066924F1BE047F01066924E
++DATA3   80   60 1BE0682019586A201BE01B8740404040F0F0F3F3
++DATA1   80    0 02E3E7E34000056840400038404000015A801BEC91101B3C4710109AD200
++DATA2   80   30 1BEB500391801BEB47801096947F1BEB5A801BE847F0109A5B801BE81288
++DATA3   80   60 47A010A496041B3C10B849B040404040F0F0F3F4
++DATA1   80    0 02E3E7E3400005A040400038404000011BF047C010D491041B3C471010BE
++DATA2   80   30 68201AA047F011024BB01BF249B01BF0474010D02B2247F011026D201918
++DATA3   80   60 1BAA5DA01C148FA000028BB040404040F0F0F3F5
++DATA1   80    0 02E3E7E3400005D8404000384040000100012B44784A18F012BB478010F2
++DATA2   80   30 6C4B191891041B3C478011002D2447F011022C2491401B3C4780110C2122
++DATA3   80   60 9104500092FF1B434780113840404040F0F0F3F6
++DATA1   80    0 02E3E7E3400006104040002840400001702020004400F07692001B4318FD
++DATA2   80   30 68201BB068401BB8982D1B08181047F010046020200047F0111C40404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F7
++DATA1   80    0 02E3E7E3400006384040003840400001902719C818501B66436050011A36
++DATA2   80   30 92FF1A03910550004780102A91045000478010825870200047F0102E4870
++DATA3   80   60 2000924019FC92001A03127740404040F0F0F3F8
++DATA1   80    0 02E3E7E34000067040400038404000014780106E47201044926019FC4E70
++DATA2   80   30 1AB8F3E71AB81AB896F01AC641201AC741501AB84140000F95F050004770
++DATA3   80   60 108C415050014640105E063040404040F0F0F3F9
++DATA1   80    0 02E3E7E3400006A8404000384040000192F03000466010AC982719C81810
++DATA2   80   30 47F010021B774370200047F0102E1964474010CE478010C606200630D200
++DATA3   80   60 30002000466010A847F0107840404040F0F0F4F0
++DATA1   80    0 02E3E7E3400006E04040003840400001464010960630D200300019FC4660
++DATA2   80   30 10BC47F0107806309240300047F010B4956019FC47701096583019CC925C
++DATA3   80   60 300041303001466010D247F040404040F0F0F4F1
++DATA1   80    0 02E3E7E34000071840400002404000011078404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F2
++DATA1   80    0 02E3E7E34000071A4040003840400001902D18E66060199E9202191A4540
++DATA2   80   30 101E6860199E982D18E6181047F0100405C018501B661B771B8892FFC901
++DATA3   80   60 910450004780C01E2B66786040404040F0F0F4F3
++DATA1   80    0 02E3E7E3400007524040003840400001200047F0C022686020006060C996
++DATA2   80   30 9200C9019180C9964780C03E9640C8FA947FC9966860C99622664780C3A0
++DATA3   80   60 189F58F0C8C24400F072436040404040F0F0F4F4
++DATA1   80    0 02E3E7E34000078A4040003840400001C9965460C8669108C9964780C062
++DATA2   80   30 4166000841A6C73E6C60A0008A60000241A6C86E4A8A00007060C9969548
++DATA3   80   60 C99647A0C12A9539C99647C040404040F0F0F4F5
++DATA1   80    0 02E3E7E3400007C24040003840400001C132953CC9964780C1469545C996
++DATA2   80   30 4780C13A4360C9965460C86A8960000341A6C7BE6C60A0008A60000241A6
++DATA3   80   60 C88E4A8A00007060C996954040404040F0F0F4F6
++DATA1   80    0 02E3E7E3400007FA4040003840400001C9964770C07A4980C9AE4720C0E2
++DATA2   80   30 6A60C8566960C7BE4740C0E26C60C7C64A80C8906C60C816416000186E60
++DATA3   80   60 C84E7060C9969200C99658A040404040F0F0F4F7
++DATA1   80    0 02E3E7E3400008324040003840400001C9964EA6C71E4B60C89C4780C182
++DATA2   80   30 41B6C71E940FB00F4FA6C72650A6C71E5076C7229246B0006B66C71E6C60
++DATA3   80   60 C81E47F0C0EA4160004047F040404040F0F0F4F8
++DATA1   80    0 02E3E7E34000086A4040003840400001C0A64160004847F0C0A69180C997
++DATA2   80   30 4780C15247F0C15E9180C9974780C16A47F0C1766C60C83E4A80C89847F0
++DATA3   80   60 C0BA6C60C7E64A80C8AE47F040404040F0F0F4F9
++DATA1   80    0 02E3E7E3400008A24040003840400001C0BA6C60C8464B80C8AE47F0C0BA
++DATA2   80   30 6C60C81E4B80C89847F0C0BAF363C9B6C73AF353C9BCC732F353C9C1C72A
++DATA3   80   60 4400F07618F94190C9B641D040404040F0F0F5F0
++DATA1   80    0 02E3E7E3400008DA4040003840400001001095F090004770C1B84B80C890
++DATA2   80   30 4190900106D047F0C1A21B225020C9AA91FF50034780C1E8D200C9AD5003
++DATA3   80   60 9180C9AD4780C1E0947FC9AD40404040F0F0F5F1
++DATA1   80    0 02E3E7E34000091240400038404000015B20C9AA47F0C1E45A20C9AA5020
++DATA2   80   30 C9AA9101C8FA4710C1F21A28436050014370500291FFC9E04780C2041B72
++DATA3   80   60 18A21AA712AA4740C27049A040404040F0F0F5F2
++DATA1   80    0 02E3E7E34000094A4040003840400001C9B247A0C2701AA995F5A0004740
++DATA2   80   30 C27006A019A94740C24A95F9A0004780C2421BBB43B0A00041B0B00142B0
++DATA3   80   60 A00047F0C27092F0A00047F040404040F0F0F5F3
++DATA1   80    0 02E3E7E3400009824040003840400001C22092F1A000189A41D0D0014A80
++DATA2   80   30 C8909101C8FA4710C2704A20C89091FFC9E04780C2704B70C89041A07001
++DATA3   80   60 122247C0C27C1AA29102C8FA40404040F0F0F5F4
++DATA1   80    0 02E3E7E3400009BA40400038404000014710C28841A0A0041B6A4740C378
++DATA2   80   30 4780C3701A365030C9C612224780C2DA4720C2D01022924B300041303001
++DATA3   80   60 9620C8FA127747C0C32492F040404040F0F0F5F5
++DATA1   80    0 02E3E7E3400009F240400038404000013000413030014670C2C647F0C324
++DATA2   80   30 4620C2B618B747F0C2EE9604C8FA18B247F0C2EE924B3000413030019620
++DATA3   80   60 C8FA127747C0C32418B712DD40404040F0F0F5F6
++DATA1   80    0 02E3E7E340000A2A404000384040000147C0C310D2003000900041303001
++DATA2   80   30 4190900146B0C30C06D047F0C31C46D0C2F492F030004130300146B0C310
++DATA3   80   60 9120C8FA4780C2DA1266078440404040F0F0F5F7
++DATA1   80    0 02E3E7E340000A6240400038404000015830C9C69104C8FA4710C3500630
++DATA2   80   30 9140C8FA4780C3464960C8904780C35A92F030004660C35007F49140C8FA
++DATA3   80   60 4780C364063092603000466040404040F0F0F5F8
++DATA1   80    0 02E3E7E340000A9A4040003840400001C36407F40630924030004660C364
++DATA2   80   30 07F49140C8FA4780C2921A6A91FFC9E04780C3864A60C896925C30004130
++DATA3   80   60 30014660C3866860C97E982D40404040F0F0F5F9
++DATA1   80    0 02E3E7E340000AD24040003840400001C8C6181047F01004436050014370
++DATA2   80   30 500292403000413030014660C3A841D0000312774770C3C241D0000241A0
++DATA3   80   60 70039101C8FA4780C3D241A040404040F0F0F6F0
++DATA1   80    0 02E3E7E340000B0A4040003040400001A0044190C9F21B3A5930C8CA47A0
++DATA2   80   30 C3F8413030014190900146D0C3D8436050015830C8CA47F0C38644D0C9DA
++DATA3   80   60 47F0C392404040404040404040404040F0F0F6F1
++DATA1   80    0 02E3E7E340000B3A4040003840400001902D14C66060157E920114FA5890
++DATA2   80   30 15060549583015C61A3A4B301496910450004780102C92C5300047F01030
++DATA3   80   60 92C430005B8015AA1288474040404040F0F0F6F2
++DATA1   80    0 02E3E7E340000B72404000324040000110429240300147F0104892603001
++DATA2   80   30 10884E8015B6F31115B615BC96F015B7D201300215B66860157E982D14C6
++DATA3   80   60 181047F0100440404040404040404040F0F0F6F3
++DATA1   80    0 02E3E7E340000BA44040003840400001900714B06040151C606015240540
++DATA2   80   30 185092FF448991045000478040182B667860200047F0401C686020002066
++DATA3   80   60 6960434E92004489474040A640404040F0F0F6F4
++DATA1   80    0 02E3E7E340000BDC40400038404000011B77437050021B665D60455A8F60
++DATA2   80   30 00028B7000012B447846423612774780404E6C47425E2964472040A6D202
++DATA3   80   60 409A500092FF456891FF456940404040F0F0F6F5
++DATA1   80    0 02E3E7E340000C144040003840400001471040941B664360409B4B60441E
++DATA2   80   30 472040884A60441E925C3000413030014660407847F0409E4260409B1A63
++DATA3   80   60 D2036000455E5810449A050140404040F0F0F6F6
++DATA1   80    0 02E3E7E340000C4C4040002E40400001000000009200456847F040B6D203
++DATA2   80   30 40B250005810449E0501000000006840450E68604516980744A2181047F0
++DATA3   80   60 10044040404040404040404040404040F0F0F6F7
++DATA1   80    0 02E3E7E340000C7A4040003840400001902913FA18501B441B6643405000
++DATA2   80   30 436050018A400001424010B2D20110B45002954D30004780103C956C3000
++DATA3   80   60 4780103C413030014660102040404040F0F0F6F8
++DATA1   80    0 02E3E7E340000CB2404000384040000147F010BC413030015030148A1B77
++DATA2   80   30 47F0105A956B30004780106241707001413030014660104A47F010BC4590
++DATA3   80   60 109E413030015030148A1B7740404040F0F0F6F9
++DATA1   80    0 02E3E7E340000CEA40400038404000011A2447F0108E955D300047801096
++DATA2   80   30 954C30004780109641707001413030014660107647F010BC4590109E47F0
++DATA3   80   60 10D0427010B39003141A058040404040F0F0F7F0
++DATA1   80    0 02E3E7E340000D224040003240400001583083E258108322050100000000
++DATA2   80   30 9803837207F9582013FA434050009200200041202001464010C4982913FA
++DATA3   80   60 181047F0100440404040404040404040F0F0F7F1
++DATA1   80    0 02E3E7E340000D5440400038404000019029132092FF13C718501B441B66
++DATA2   80   30 43405000436050018A4000014240106CD201106E50021A241A360630925D
++DATA3   80   60 3000459010521B240630926B40404040F0F0F7F2
++DATA1   80    0 02E3E7E340000D8C40400038404000013000459010520630924D30009200
++DATA2   80   30 13C798291320181047F010044B60127647C010444260106D1B3690011340
++DATA3   80   60 05805810828E05010000000040404040F0F0F7F3
++DATA1   80    0 02E3E7E340000DC44040002240400001980182DA1B66954030004770108A
++DATA2   80   30 416060014130300147F01076126647C0104407F940404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F4
++DATA1   80    0 02E3E7E340000DE840400028404000014110000041A0000042640000433E
++DATA2   80   30 80004427100045186A0045F4240046989680475F5E10483B9ACA40404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F5
++DATA1   80    0 02E3E7E340000E104040003840400001508AC7230489E800492540BE4000
++DATA2   80   30 00005156BC75E2D6310059C9F2C9CD04674F621D6329F1C35CA56A446C3B
++DATA3   80   60 15F99267729F4F2726179A2340404040F0F0F7F6
++DATA1   80    0 02E3E7E340000E4840400010404000017B172EBAD6DDC73C4E0000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F7F7
++DATA1   80    0 02E3E7E340000E7840400038404000017B172EBAD6DDC73C729F4F272617
++DATA2   80   30 9A236A446C3B15F99267621D6329F1C35CA5621D6329F1C35CA559C9F2C9
++DATA3   80   60 CD04674F5156BC75E2D6310040404040F0F0F7F8
++DATA1   80    0 02E3E7E340000EB04040003840400001492540BE40000000411000000000
++DATA2   80   30 00003944B82FA09B5A52302F3942192484462814484BFEEBC2A11F8B6131
++DATA3   80   60 3BBABCF9173BDCF495A9704640404040F0F0F7F9
++DATA1   80    0 02E3E7E340000EE840400010404000010F19B604AAACA62B06B0AF48EC79
++DATA2   80   30 AD2140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F0
++DATA1   80    0 02E3E7E340000EF840400038404000014110000000000000401999999999
++DATA2   80   30 999A3F28F5C28F5C28F63E4189374BC6A7F03D68DB8BAC710CB23C10C6F7
++DATA3   80   60 A0B5ED8D3B1AD7F29ABCAF4840404040F0F0F8F1
++DATA1   80    0 02E3E7E340000F3040400038404000013A2AF31DC46118733944B82FA09B
++DATA2   80   30 5A52483B9ACA00000000475F5E1000000000469896800000000045186A00
++DATA3   80   60 00000000442710000000000040404040F0F0F8F2
++DATA1   80    0 02E3E7E340000F684040003840400001433E800000000000426400000000
++DATA2   80   30 00003CA7C5AC471B478445F4240000000000460000000000000040000000
++DATA3   80   60 000000047FFFFFFFFFFFFFFF40404040F0F0F8F3
++DATA1   80    0 02E3E7E340000FA04040003840400001000000F00000000FFFBAFFC4FFCE
++DATA2   80   30 FFD8FFD8FFE2FFECFFF6000000090014001E00280032003C004600000001
++DATA3   80   60 00020003000400050007000840404040F0F0F8F4
++DATA1   80    0 02E3E7E340000FD840400028404000010009FFF7FFF8FFF9FFFAFFFCFFFD
++DATA2   80   30 FFFE0006FFFBD20020003000D20030002000000000000000000040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F5
++DATA1   80    0 02E3E7E34000103040400024404000010000000000FAFBFCFDFEFF000000
++DATA2   80   30 032E00000738000004F800000BA40000071A00000B3A4040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F6
++DATA1   80    0 02E3E7E3400010E84040000640400001004B001300104040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F7
++DATA1   80    0 02E3E7E34000110840400038404000010FFFFFFF0000000A40404040D200
++DATA2   80   30 300090000000F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C640F04BF000001168
++DATA3   80   60 00001144000011400000000040404040F0F0F8F8
++DATA1   80    0 02E3E7E34000114040400008404000010000000000000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F8F9
++DATA1   80    0 02E3E7E34000114C4040003840400001000002EE4040C4C5C3C9D4C1D340
++DATA2   80   30 40C8C5E7C1C4C5C3C9D4C1D3000000000031C9C8C3F240F5C940C3D6D5E5
++DATA3   80   60 C5D9E3406040C9D3D3C5C7C140404040F0F0F9F0
++DATA1   80    0 02E3E7E3400011844040001940400001D340404040404040404040404040
++DATA2   80   30 C3C8C1D9C1C3E3C5D9404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F9F1
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D0000000D0000040D00
++DATA2   80   30 00080D00000C0D0000100D0000140D0000180D00001C0D0000200D000024
++DATA3   80   60 0D0000280D00002C0C00003040404040F0F0F9F2
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D0000340D0000380D00
++DATA2   80   30 003C0D0000400D0000440D0000480D00004C0D0000500D0000540D000058
++DATA3   80   60 0D00005C0D00103C0C00104040404040F0F0F9F3
++DATA1   80    0 02D9D3C4404040404040003440404040000100010D0010440D0010480D00
++DATA2   80   30 104C0D0010500D0011300D0011340D0011380C00114C000200010C000FFC
++DATA3   80   60 000300011C000FF84040404040404040F0F0F9F4
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F9F5
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFCXPI EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C3E7D7C9000000004000
++DATA2   80   30 01E5C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C3D4D7E87B404040020000004040
++DATA2   80   30 4040C3C4E5C47B4040400200000040404040C6C3E7D7C97B404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C6C3E7D7C97B0090E5
++DATA2   80   30 D00C0550183D41D050E6503D000450D30008583010007800300078203004
++DATA3   80   60 58301004582030003200476040404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001502E3222478050A81B4412224720
++DATA2   80   30 504047805092132241440001D2075136513E7000512E702051328C200001
++DATA3   80   60 123347A0506A4110514A58F040404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001515605EF700051367020513A1222
++DATA2   80   30 4780507E4110514E58F0515605EF47F0504612444780509A4110514658F0
++DATA3   80   60 515A05EF47F0509A7800513E40404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A840400038404000017820514258DD000498E5D00C92FF
++DATA2   80   30 D00C07FE12224720509A7000512E702051325020516641205166413051C2
++DATA3   80   60 98EF515E440F00520501040B40404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400018404000014110516A18FE05EF950051854780
++DATA2   80   30 509A4110517647F0500E4040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02E3E7E34000014840400030404000014110000000000000411000000000
++DATA2   80   30 000000000150000001480000014000000140000000000000000000000000
++DATA3   80   60 00000000404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000017C40400018404000010000019800000194000001900000
++DATA2   80   30 014080000178000000F64040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E340000198404000384040000100000049C9C8C3F2F4F6C940C6C3
++DATA2   80   30 E7D7C940C3D6D4D7D3C5E75CF840C2C1E2C57EF04BF04EF04BF0C96B40C9
++DATA3   80   60 D5E3C5C7C5D940C5E7D7D6D540404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001D04040000440400001C5D5E37E40404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001DF40400006404000016B40D3C540F04040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D0001580D00015C0D00
++DATA2   80   30 01600D0001640D00017C0D0001800D0001840D0001880800018D00020001
++DATA3   80   60 0C000174000300011C00017040404040F0F0F1F3
++DATA1   80    0 02D9D3C4404040404040001040404040000400010C000168000500010C00
++DATA2   80   30 016C40404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F4
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F5
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFDUMP EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C4E4D4D7000000004000
++DATA2   80   30 0201C4E4D4D7404040400100000040000001D7C4E4D4D740404001000016
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040400002C9C2C3D6D47B4040020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C4E4D4D70090ECD00C
++DATA2   80   30 92FFF1FC47F0F02847F0F00A05D7C4E4D4D790ECD00C9200F1E605C058F0
++DATA3   80   60 C1B695FFC1D24780C01E95FF40404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001F07C4780C01E58E0F06C980CD014
++DATA2   80   30 07FED20FF07CD00C18414120C1BA4400F04A050100FF47F0C16E1B224400
++DATA3   80   60 F04A0501020047F0C16E185240404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001416320004170003292F120009200
++DATA2   80   30 C1D31B88D203C1BE400091FF40004780C06C1B9947F0C08C589040045490
++DATA3   80   60 C1C25B90400047A0C084109940404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040003840400001D203C1BE400491FF40044780C096
++DATA2   80   30 92FFC1D31BBB47F0C0C091FF40084780C0A292FFC1D358B0400854B0C1C2
++DATA3   80   60 49B0C1C647C0C0C058B0B00040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E0404000384040000149B0C1C647C0C0C01BBB43ABC1C8
++DATA2   80   30 42A0C1138BB0000258ABC18E50A0C1164380C1161A98413020014120C1BF
++DATA3   80   60 4400F04E05010306D202300640404040F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040003840400001C1D4413030095820C1BE18A34380
++DATA2   80   30 C1171AA819A647C0C11045A0C14047F0C0DA07004400F000050100000000
++DATA3   80   60 1A384380C1161A281B98472040404040F0F0F0F8
++DATA1   80    0 02E3E7E3400001504040003840400001C0F845A0C14091FFC1D34710C16E
++DATA2   80   30 4140400C92F0200047F0C0585020C1BE1B3518234400F04A0501020047F0
++DATA3   80   60 C16E1852416320004670C16840404040F0F0F0F9
++DATA1   80    0 02E3E7E34000018840400030404000014170003292F1200007FA92402000
++DATA2   80   30 07FA91FFC1D292FFF07C4710C18498ECD00C92FFD00C07FE980CD01445E0
++DATA3   80   60 F0440000404040404040404040404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001B84040003040400001040A070001030700040307000207
++DATA2   80   30 0700040C0700041108000819100008230800103310000404070000000000
++DATA3   80   60 04000000404040404040404040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001EC404000154040000100FFFFFF00094E5E5E5252565A62
++DATA2   80   30 626600004040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02D9D3C4404040404040000840404040000200010C0001E0404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F4
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFDVCH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C4E5C3C8000000004000
++DATA2   80   30 0044C4E5C3C8D24040400100000040000001C9C2C3D6D47B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C4E5C3C8D290E4D00C
++DATA2   80   30 07F0582010005830F04091FF30494780F0284140000147F0F02C41400002
++DATA3   80   60 504020009200304998E4D00C40404040F0F0F0F2
++DATA1   80    0 02E3E7E340000038404000064040000192FFD00C07FE4040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E34000004040400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02D9D3C4404040404040000840404040000200010C000040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFDXPD EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C4E7D7C4000000004000
++DATA2   80   30 01A0C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C4D3D6C740404040020000004040
++DATA2   80   30 4040C4C5E7D7404040400200000040404040C6C4E7D7C47B404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C6C4E7D7C47B0090E3
++DATA2   80   30 D00C0520183D41D020D6503D000450D30008583010006800300058301004
++DATA3   80   60 6820300022004780205E222240404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000014780204C602020A658F020CA05EF
++DATA2   80   30 682020A62C02600020A6411020C658F020CE05EF47F02050680020BE58DD
++DATA3   80   60 000498E3D00C92FFD00C07FE40404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001222247202050600020AE602020B6
++DATA2   80   30 4130217158F020D218E2412020B6440F005A050108171000182E41102126
++DATA3   80   60 58F0211E05EF9500213D478040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040000A4040000120504110213247F0200E40404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000D040400018404000014110000000000000000000B80000
++DATA2   80   30 000000000000000000004040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400001304040001C4040000100000000000000F5000001500000
++DATA2   80   30 014C00000134000000C0800000C840404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000015040400033404000010000004CC9C8C3F2F4F5C940C6C4
++DATA2   80   30 E7D7C440D9C5C1D35CF840C2C1E2C57EF04BF06B40D9C5C1D35CF840C5E7
++DATA3   80   60 D7D6D5C5D5E37E404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E34000019A40400006404000016B40D3C540F04040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02D9D3C4404040404040003440404040000100010D0000D80D0001380D00
++DATA2   80   30 013C0D0001400D00014408000149000200010C0000E4000300011C000130
++DATA3   80   60 000400010C0000DC4040404040404040F0F0F1F1
++DATA1   80    0 02D9D3C4404040404040000840404040000500010C0000E0404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFDXPI EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C4E7D7C9000000004000
++DATA2   80   30 014DC9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040404040C6C4E7D7C97B4040010000004000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C6C4E7D7C97B0090E3
++DATA2   80   30 D00C5830100068003000583010045820300022004780F0781B0012224720
++DATA3   80   60 F0384780F06A13224100000140404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000016820F0D08C200001123347A0F048
++DATA2   80   30 2C2012224780F0542C0047F0F03C12004780F0646800F0D02D0247F0F06E
++DATA3   80   60 280247F0F06E6800F0D098E340404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001D00C92FFD00C07FE12224720F06E
++DATA2   80   30 6000F0D85020F0E04120F0E04130F13C18EF181D58F0F0E441DF00C4501D
++DATA3   80   60 000450D10008440F0052050140404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040002440400001040B180E4110E0EC58F0E0E805EF
++DATA2   80   30 18F058DD00049500F1074780F06E4110F0F847F0F0104040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000D040400008404000014110000000000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400000E440400020404000010000000000000000000001080000
++DATA2   80   30 010400000100000000D8800000E0000000F3404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E340000108404000344040000100000041C9C8C3F2F4F3C940C6C4
++DATA2   80   30 E7D7C940D9C5C1D35CF840C2C1E2C57EF04BF06B40C9D5E3C5C7C5D940C5
++DATA3   80   60 E7D7D6D5C5D5E37E4040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E34000014740400006404000016B40D3C540F04040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02D9D3C4404040404040002840404040000100010D0000EC0D0000F00D00
++DATA2   80   30 00F40D0000F8080000FD000200010C0000E4000300011C0000E840404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFEXIT EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C5E7C9E3000000004000
++DATA2   80   30 001CC5E7C9E3404040400100000040000001C9C2C3D6D47B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000184040000147F0F00A04C5E7C9E30090EFD00C
++DATA2   80   30 58F0F01845E0F04400004040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E34000001840400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02D9D3C4404040404040000840404040000200010C000018404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFIFIX EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C9C6C9E7000000004000
++DATA2   80   30 0078C9C6C9E7404040400100000040000001C9D5E3404040404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040404040C9C4C9D5E34040400100001A4000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00803C9D5E390E2D00C5820
++DATA2   80   30 10002B447840200047F0F03047F0F00A05C9C4C9D5E390E2D00C58201000
++DATA3   80   60 6840200005F091402000478040404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040002E40400001F00E22444770F0141B0047F0F02A
++DATA2   80   30 20646E60F0366060F03E5800F042224447A0F02A11009812D01892FFD00C
++DATA3   80   60 07FE4040404040404040404040404040F0F0F0F4
++DATA1   80    0 02E3E7E34000006840400008404000014E00000000000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFINTH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C9D5E3C8000000004000
++DATA2   80   30 039EC9C2C3D6D47B40400200000040404040C9D5E3E2E6E3C3C802000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C9D5E3F6E2E6C3C8020000004040
++DATA2   80   30 4040C9C8C3E4D6D7E3400200000040404040C1C4C3D6D57B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040003040400007C6C9D6C3E27B4040020000004040
++DATA2   80   30 4040C1D9C9E3C87B40400100000040000001C1C4D1E2E6E3C3C8010002B8
++DATA3   80   60 40000001404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E340000000404000384040000192D7F37F50E0F2A05010F2AC903D
++DATA2   80   30 F324D20BF3181014D207F350100C5880F2FC18914840100691C010084780
++DATA3   80   60 F0A24B40F2EC8B400002478040404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000384040001A40400001F04E4940F07C47A0F27458A0F300
++DATA2   80   30 91FFA0004710F10247F4F054404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++DATA1   80    0 02E3E7E340000054404000384040000147F0F27A47F0F27447F0F1C247F0
++DATA2   80   30 F09647F0F1C247F0F09647F0F07E47F0F08A47F0F1C247F0F096002892FF
++DATA3   80   60 804896F0807A47F0F102920F40404040F0F0F0F6
++DATA1   80    0 02E3E7E34000008C40400038404000018048960F807A47F0F10292FF8049
++DATA2   80   30 9400F2FB47F0F1C258A0F30091FFA0004710F27492C9F37F894000145040
++DATA3   80   60 F2F88940000112444720F0BA40404040F0F0F0F7
++DATA1   80    0 02E3E7E3400000C440400038404000018940000112444780F0D292D4F37F
++DATA2   80   30 9144F2F847A0F0DE92FF80499110F2F84780F0EE920F8048960F807A9120
++DATA3   80   60 F2F847E0F1C292FF804896F040404040F0F0F0F8
++DATA1   80    0 02E3E7E3400000FC4040003840400001807A47F0F1C2950C10074770F112
++DATA2   80   30 4170000147F0F116417000095860100896FFF2FB1B551BBB412000021F62
++DATA3   80   60 126647B0F1301F629544600040404040F0F0F0F9
++DATA1   80    0 02E3E7E34000013440400038404000014770F18C1B554110F31848406002
++DATA2   80   30 8C400010434060018D40001041B0003C41300FFF14348840000641000002
++DATA3   80   60 88400004182B14244780F17040404040F0F0F1F0
++DATA1   80    0 02E3E7E34000016C40400038404000014400F2F24600F160884000041863
++DATA2   80   30 182B14244780F186435210034300600116504100000396FFF2FA91106000
++DATA3   80   60 4710F1A49400F2FA4100000740404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001A44040003840400001413000F01A7012BB4770F1B44350
++DATA2   80   30 600114534450F2DE91FFA0004710F2344120F3605810F304050100FF4700
++DATA3   80   60 0000D2272000F3644130202840404040F0F0F1F2
++DATA1   80    0 02E3E7E3400001DC40400038404000015820F2AC412020045810F3085810
++DATA2   80   30 105C050108144120003C95FFF2FB4770F228D211301EF38C413030304120
++DATA3   80   60 F3105810F3085810105C050140404040F0F0F1F3
++DATA1   80    0 02E3E7E340000214404000384040000108144120006C95FFF2FA4770F228
++DATA2   80   30 D207300C30145810F304050102004700000095FFF2FB4770F274950D9007
++DATA3   80   60 4780F2484457F2DE1845884040404040F0F0F1F4
++DATA1   80    0 02E3E7E34000024C404000384040000100041654950D90074770F2684457
++DATA2   80   30 F2DE910A600047E0F26894CF90089180F3104780F2744450F2F0983DF324
++DATA3   80   60 07FE9500F2B84780F2BA92C140404040F0F0F1F5
++DATA1   80    0 02E3E7E3400002844040001440400001F37F9400F2FB5820F3044110F2A0
++DATA2   80   30 98EFF29807FE404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F6
++DATA1   80    0 02E3E7E34000029C40400004404000010000031840404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F7
++DATA1   80    0 02E3E7E3400002A44040000840400001000000000000F1C2404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F8
++DATA1   80    0 02E3E7E3400002B0404000384040000100000000000000000000182F4100
++DATA2   80   30 F2C447F0F2CCC9C8C3C1C4D1E2E31B110A0818F29201F2B85000F29847F0
++DATA3   80   60 F2826000F3107800F358680040404040F0F0F1F9
++DATA1   80    0 02E3E7E3400002E84040000E40400001F3583B0000062B0031005E321000
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F0
++DATA1   80    0 02E3E7E3400002FC40400010404000010000000000000000000000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F1
++DATA1   80    0 02E3E7E34000035840400038404000017FFFFFFFFFFFFFFF04000000F0C9
++DATA2   80   30 C8C3F2F1F0C940D7D9D6C7D9C1D440C9D5E3C5D9D9E4D7E34D405D40D6D3
++DATA3   80   60 C440D7E2E640C9E2D9C5C7C940404040F0F0F2F2
++DATA1   80    0 02E3E7E3400003904040000E40400001E2E3C5D940C3D6D5E3C1C9D5C5C4
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F3
++DATA1   80    0 02D9D3C4404040404040003440404040000100010D00029C0C0002A40002
++DATA2   80   30 00010C0002FC000300010C000300000400010C0002B4000500010C0002B0
++DATA3   80   60 000600010C0003084040404040404040F0F0F2F4
++DATA1   80    0 02D9D3C4404040404040000840404040000700010C000304404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F5
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F6
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFIXPI EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6C9E7D7C9000000004000
++DATA2   80   30 014FC9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040404040C6C9E7D7C97B4040010000004000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C6C9E7D7C97B0090E7
++DATA2   80   30 D00C58701000585070005870100458607000180512554780F08C12664780
++DATA3   80   60 F07A065012554780F07E415540404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001000212554780F07012664720F04C
++DATA2   80   30 1B0047F0F07E18505830F0DC8C600001127747A0F05E1C2512664780F06A
++DATA3   80   60 1C4547F0F052180347F0F07E40404040F0F0F0F4
++DATA1   80    0 02E3E7E34000007040400038404000018C60000112774740F07E5800F0DC
++DATA2   80   30 98EFD00C9827D01C92FFD00C07FE12664720F07E9056F0FC4120F1004130
++DATA3   80   60 F13E187D184F98EFF0E041DF40404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A8404000384040000100C4507D000450D70008440F0052
++DATA2   80   30 0501040B411040E818FE05EF18F458DD00045800F10812004780F07E9856
++DATA3   80   60 F0FC47F0F02000000000000140404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E04040001C4040000100000000000000000000010C0000
++DATA2   80   30 010800000104000000FC8000010040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400001044040000440400001000000F140404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000010C40400032404000010000003FC9C8C3F2F4F1C940C6C9
++DATA2   80   30 E7D7C940C9D5E3C5C7C5D940C2C1E2C57EF06BC9D5E3C5C7C5D940C5E7D7
++DATA3   80   60 D6D5C5D5E37E40404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E34000014940400006404000016B40D3C540F04040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02D9D3C4404040404040002840404040000100010D0000E80D0000EC0D00
++DATA2   80   30 00F00D0000F4080000F9000200010C0000E4000300011C0000E040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFMAXD EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6D4C1E7C4000000004000
++DATA2   80   30 006DC4D4C1E7F14040400100000040000001C4D4C9D5F140404001000016
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C4D4C1E7F190E3D00C
++DATA2   80   30 92A0F06C47F0F02847F0F00A05C4D4C9D5F190E3D00C92C0F05605F04330
++DATA3   80   60 F0425430F03A58201000680040404040F0F0F0F2
++DATA1   80    0 02E3E7E3400000384040002C40400001200047F0F0284110100458201000
++DATA2   80   30 690020004430F03E6800200091FF10004780F01498E3D00C92FFD00C07FE
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000644040000940400001000000F04700F028004040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFMAXI EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6D4C1E7C9000000004000
++DATA2   80   30 00C9D4C1E7F0404040400100000040000001D4C9D5F04040404001000016
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040002040404040C1D4C1E7F04040400100002C4000
++DATA2   80   30 0001C1D4C9D5F04040400100004240000001404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04D4C1E7F00090E3D00C
++DATA2   80   30 92A0F0C847F0F05447F0F00A04D4C9D5F00090E3D00C92C0F0B247F0F03E
++DATA3   80   60 47F0F00A05C1D4C1E7F090E340404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001D00C92AFF09C47F0F02847F0F00A
++DATA2   80   30 05C1D4C9D5F090E3D00C92CFF08605F04330F0725430F06A582010005800
++DATA3   80   60 200047F0F02841101004582040404040F0F0F0F4
++DATA1   80    0 02E3E7E34000007040400038404000011000590020004430F06E58002000
++DATA2   80   30 91FF10004780F014910FF0724780F04E10305030F05E6800F0626A00F05A
++DATA3   80   60 120047A0F04E31009813D01840404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A8404000064040000192FFD00C07FE4040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000B040400019404000014E000000000000004E0000000000
++DATA2   80   30 0000000000F04700F0280040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFMAXR EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6D4C1E7D9000000004000
++DATA2   80   30 00C9D4C1E7F1404040400100000040000001D4C9D5F14040404001000016
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040002040404040C1D4C1E7F14040400100002C4000
++DATA2   80   30 0001C1D4C9D5F14040400100004240000001404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04D4C1E7F10090E3D00C
++DATA2   80   30 92AFF0C847F0F05447F0F00A04D4C9D5F10090E3D00C92CFF0B247F0F03E
++DATA3   80   60 47F0F00A05C1D4C1E7F190E340404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001D00C92A0F09C47F0F02847F0F00A
++DATA2   80   30 05C1D4C9D5F190E3D00C92C0F08605F04330F0725430F06A582010007800
++DATA3   80   60 200047F0F02841101004582040404040F0F0F0F4
++DATA1   80    0 02E3E7E34000007040400038404000011000790020004430F06E78002000
++DATA2   80   30 91FF10004780F014910FF0724780F0502B2230206E20F05A6020F0625800
++DATA3   80   60 F066320047A0F0501100981340404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040000840400001D01892FFD00C07FE404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000B040400008404000014E00000000000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400000C04040000940400001000000F04700F028004040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F9
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFMODI EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040002040400001C9C8C3C6D4D6C4C9000000004000
++DATA2   80   30 0030D4D6C440404040400100000040000001404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000304040000147F0F00803D4D6C490E4D00C5830
++DATA2   80   30 100058003000583010045840300018208E2000201D2418029814D01892FF
++DATA3   80   60 D00C07FE404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFMODR EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6D4D6C4D9000000004000
++DATA2   80   30 0068C1D4D6C4404040400100000040000001C4D4D6C44040404001000026
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C1D4D6C40090E2D00C
++DATA2   80   30 582010002B0078002000582010042B667860200047F0F04447F0F00A04C4
++DATA3   80   60 D4D6C40090E2D00C5820100040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000038404000244040000168002000582010046860200005F0
++DATA2   80   30 28402D466E40F01A2C462B0498E2D00C92FFD00C07FE4040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E34000006040400008404000014E00000000000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFOPT  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6D6D7E340000000004000
++DATA2   80   30 0304C5D9D9E2C5E340400100000040000001C5D9D9E2C1E54040010001FA
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400002C5D9D9E2E3D94040010002204000
++DATA2   80   30 0001C9C8C3E4D6D7E3400200000040404040C6C9D6C3E27B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040001040400004C9C2C3D6D47B4040020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C07C9C8C3C6D6D7E390EC
++DATA2   80   30 D00C58201000583020005030F26C4580F12A12444780F0EE1B554560F1CC
++DATA3   80   60 122247D0F04242204000592040404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000384040003840400001F2644740F042920040004560F1CC
++DATA2   80   30 12224720F0564780F0661B2294FB4003422040015920F2644740F0669604
++DATA3   80   60 40034560F1CC122247D0F08840404040F0F0F0F5
++DATA1   80    0 02E3E7E34000007040400038404000014920F2544720F0884780F08494FD
++DATA2   80   30 400347F0F088960240034560F1CC12224780F0965020400495FFF2744780
++DATA3   80   60 F0B4D501F26EF2584780F0C840404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000A840400038404000014560F1CC92FFF2745020F2685830
++DATA2   80   30 F26C413030015930F2684720F0DC47F0F0184560F1CC947F40034920F252
++DATA3   80   60 4770F0DC968040039200F27440404040F0F0F0F7
++DATA1   80    0 02E3E7E3400000E040400038404000019200F27598ECD00C92FFD00C07FE
++DATA2   80   30 95FFF2744780F0B4D501F26EF2584780F0DC41600004417000101B554125
++DATA3   80   60 1000918020004710F0DC875640404040F0F0F0F8
++DATA1   80    0 02E3E7E3400001184040003840400001F10A4B50F25647F0F0A858201000
++DATA2   80   30 583020005030F25C5850F2F0584050005930F26047D0F1E65B30F2601934
++DATA3   80   60 4720F1E6893000034143500040404040F0F0F0F9
++DATA1   80    0 02E3E7E34000015040400038404000019140400307185850D0105950F2F4
++DATA2   80   30 07884140F2AD415000414160F2E995FFF2754780F18E92FFF2754120F270
++DATA3   80   60 18B15810F2F8050100FF470040404040F0F0F1F0
++DATA1   80    0 02E3E7E34000018840400038404000010000189218A318364120F25C187F
++DATA2   80   30 58F0F2FC4400F05218F705010405195A47D0F1AC185A06504450F24C5810
++DATA3   80   60 F2F84125000205010200470040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001C040400038404000010000189218A31B44181B07F84125
++DATA2   80   30 1000918020004710F0DC41505004582510005820200007F64140F2774150
++DATA3   80   60 00364160F28C4580F16C47F040404040F0F0F1F2
++DATA1   80    0 02E3E7E3400001F84040003840400001F0DC47F0F00C06C5D9D9E2C1E500
++DATA2   80   30 90ECD00C58F0F1064580F12258201004D2072000400047F0F0DC47F0F00C
++DATA3   80   60 06C5D9D9E2E3D90090ECD00C40404040F0F0F1F3
++DATA1   80    0 02E3E7E340000230404000384040000158F0F0E04580F12212444780F0DC
++DATA2   80   30 58201004D2074000200047F0F0DCD2009001400000010002000800D40008
++DATA3   80   60 00000000000000CE0000010040404040F0F0F1F4
++DATA1   80    0 02E3E7E34000026840400038404000010000000000000000040000000000
++DATA2   80   30 00C9C8C3F9F0F2C940C5D9D9D6D940D5E4D4C2C5D940404040404040D6E4
++DATA3   80   60 E340D6C640D9C1D5C7C540D640404040F0F0F1F5
++DATA1   80    0 02E3E7E3400002A04040003840400001C640C5D9D9D6D940E3C1C2D3C5C9
++DATA2   80   30 C8C3F9F0F3C940C1E3E3C5D4D7E340E3D640C3C8C1D5C7C540E4D5D4D6C4
++DATA3   80   60 C9C6C9C1C2D3C540E3C1C2D340404040F0F0F1F6
++DATA1   80    0 02E3E7E3400002D84040001640400001C540C5D5E3D9E84B40D5E4D4C2C5
++DATA2   80   30 D97E40404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F7
++DATA1   80    0 02E3E7E3400002F0404000144040000100000000000001FA000000000000
++DATA2   80   30 000000000000404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F8
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D0002F40C0003000002
++DATA2   80   30 00011C0002F0000300011C0002F8000400011C0002FC4040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F9
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F0
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFOVER EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6D6E5C5D9000000004000
++DATA2   80   30 0050D6E5C5D9C6D340400100000040000001C9C2C3D6D47B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06D6E5C5D9C6D30090E4
++DATA2   80   30 D00C07F0582010005830F04C91FF30484710F02E4740F0364140000247F0
++DATA3   80   60 F03A4140000147F0F03A414040404040F0F0F0F2
++DATA1   80    0 02E3E7E34000003840400014404000010003504020009200304898E4D00C
++DATA2   80   30 92FFD00C07FE404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E34000004C40400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02D9D3C4404040404040000840404040000200010C00004C404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFRXPI EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6D9E7D7C9000000004000
++DATA2   80   30 0141C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040404040C6D9E7D7C97B4040010000004000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C6D9E7D7C97B0090E3
++DATA2   80   30 D00C5830100078003000583010045820300032004780F0781B0012224720
++DATA3   80   60 F0384780F06A13224100000140404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000017820F0CC8C200001123347A0F048
++DATA2   80   30 3C2012224780F0543C0047F0F03C12004780F0647800F0CC3D0247F0F06E
++DATA3   80   60 380247F0F06E7800F0CC98E340404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001D00C92FFD00C07FE12224720F06E
++DATA2   80   30 7000F0EC5020F0F04120F0F04130F13018EF181D58F0F0D041DF00C4501D
++DATA3   80   60 000450D10008440F0052050140404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040002440400001040B4110E0D858F0E0D4180E05EF
++DATA2   80   30 18F058DD00049500F0FB4780F06E4110F0E447F0F0104040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000CC40400020404000014110000000000000000000000000
++DATA2   80   30 00FC000000F8000000F4000000EC800000F0404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400000F44040000440400001000000F240404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E3400000FC404000344040000100000041C9C8C3F2F4F2C940C6D9
++DATA2   80   30 E7D7C940D9C5C1D35CF440C2C1E2C57EF04BF06B40C9D5E3C5C7C5D940C5
++DATA3   80   60 E7D7D6D5C5D5E37E4040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E34000013B40400006404000016B40D3C540F04040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02D9D3C4404040404040002840404040000100010D0000D80D0000DC0D00
++DATA2   80   30 00E00D0000E4080000E9000200010C0000D0000300011C0000D440404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFRXPR EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6D9E7D7D9000000004000
++DATA2   80   30 0183C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C1D3D6C740404040020000004040
++DATA2   80   30 4040C5E7D740404040400200000040404040C6D9E7D7D97B404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C6D9E7D7D97B0090E3
++DATA2   80   30 D00C0520183D41D020A2503D000450D30008583010007800300058301004
++DATA3   80   60 7820300032004780205E322240404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000014780204C702020EA58F020F605EF
++DATA2   80   30 782020EA3C02700020EA411020F258F020FA05EF47F02050780020EE58DD
++DATA3   80   60 000498E3D00C92FFD00C07FE40404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001322247202050700021067020210A
++DATA2   80   30 4130215D58F020FE18E24120210A440F00560501040E0700182E58F02102
++DATA3   80   60 4110211605EF95002115478040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040000A4040000120504110212247F0200E40404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02E3E7E340000100404000184040000141100000000000FC000000000000
++DATA2   80   30 000000000000000000004040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400001204040000440400001000000F440404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000012840400038404000010000013C00000124000001200000
++DATA2   80   30 01188000011C00000043C9C8C3F2F4F4C940C6D9E7D7D940D9C5C1D35CF4
++DATA3   80   60 40C2C1E2C57EF04BF06B40D940404040F0F0F0F9
++DATA1   80    0 02E3E7E3400001604040000F40400001C5C1D35CF440C5E7D7D6D5C5D5E3
++DATA2   80   30 7E4040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02E3E7E34000017D40400006404000016B40D3C540F04040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02D9D3C4404040404040003440404040000100010D0001040D0001280D00
++DATA2   80   30 012C0D0001300D00013408000139000200010C000110000300011C000114
++DATA3   80   60 000400010C0001084040404040404040F0F0F1F2
++DATA1   80    0 02D9D3C4404040404040000840404040000500010C00010C404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F4
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCFSLIT EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C6E2D3C9E3000000004000
++DATA2   80   30 0169E2D3C9E3C54040400100000040000001E2D3C9E3C5E340400100004E
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040002040400002C9C2C3D6D47B4040020000004040
++DATA2   80   30 4040C9C8C3C5D9D9D4400200000040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05E2D3C9E3C590E4D00C
++DATA2   80   30 58201000583020004930F1104720F0A212334740F0A24780F0344133F10B
++DATA3   80   60 92FF300047F0F0444830F11040404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000014123F10B920020004630F03898E3
++DATA2   80   30 D00C92FFD00C07FE47F0F00C06E2D3C9E3C5E30090E4D00C582010005830
++DATA3   80   60 2000582010044930F0C2472040404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001F054123347C0F0544133F0BD91FF
++DATA2   80   30 30004780F03E4140000147F0F04241400002504020009200300098E4D00C
++DATA3   80   60 92FFD00C07FE05E05020E08040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A840400038404000015030E0844120E0844130E0AD58F0
++DATA2   80   30 E064440F005205010404182E183D41DF00C4503D000450D3000858F0208C
++DATA3   80   60 4110207005EF18D358FD001040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400028404000014110207C95002093478020549506
++DATA2   80   30 F004474F000E47FF00109506F0044740F0445821000447F0F03E40404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400001084040001C404000010000000000000000000400000000
++DATA2   80   30 0138000001340000012C8000012840404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000012C4040000840400001000000D800000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E34000013840400019404000010000002DC9C8C3F2F1F6C940E2D3
++DATA2   80   30 C9E3C560E2D3C9E3C5E34040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02E3E7E340000155404000144040000140C9E240C1D540C9D3D3C5C7C1D3
++DATA2   80   30 40E5C1D3E4C5404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D0001140D0001180D00
++DATA2   80   30 011C08000121000200010C000108000300011C0001304040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCIBERH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C9C2C5D9C8000000004000
++DATA2   80   30 00C8C9C2C5D9C87B40400100000040000001C9C2C3D6D47B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040400003C9C8C3C5D9D9D440020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000158C0F05890E1D00C581100004820
++DATA2   80   30 10024E20F050F342F092F05596F0F096581D0004581100101B2243210004
++DATA3   80   60 06204420F0C250D0C0C841D040404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040001440400001C0C44110F06058F0F05C05EF18FC
++DATA2   80   30 45E0F0440010404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02E3E7E34000005840400038404000010000000000000000000000700000
++DATA2   80   30 00508000006C000000E60000004DC9C8C3F2F3F0C9406040E2D6E4D9C3C5
++DATA3   80   60 40C5D9D9D6D940C1E340C9E240404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000904040003840400001D540E7E7E7E7E7406040C5E7C5C3
++DATA2   80   30 E4E3C9D6D540C6C1C9D3C5C440C1E340E2E4C2D9D6E4E3C9D5C560404040
++DATA3   80   60 404040404000D200F0B9100540404040F0F0F0F6
++DATA1   80    0 02D9D3C4404040404040002040404040000100010D0000600D0000640800
++DATA2   80   30 0069000200011C000058000300011C00005C404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCIBERR EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3C9C2C5D9D9000000004000
++DATA2   80   30 0076C9C2C5D9D97B40400100000040000001C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E3400000004040001C404000014820E0024E20F020F342F05EF025
++DATA2   80   30 96F0F0624110F02858F0F03405EF40404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E34000002840400038404000010000003C00000000800000380000
++DATA2   80   30 0000000000E600000036C9C8C3F2F3F0C9406040E2D6E4D9C3C540C5D9D9
++DATA3   80   60 D6D940C1E340C9E2D540E7E740404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000604040001640400001E7E7E7406040C5E7C5C3E4E3C9D6
++DATA2   80   30 D540C6C1C9D3C5C440404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02D9D3C4404040404040001440404040000100010D000028080000310002
++DATA2   80   30 00011C000034404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLASCN EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D3C1E2C3D5000000004000
++DATA2   80   30 024FC4E2D8D9E34040400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C9C2C3D6D47B4040020000004040
++DATA2   80   30 4040C4C1D9E2C9D540400100001840000001C4C1D9C3D6E2404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C4C1D9C3D6E20090E4
++DATA2   80   30 D00C9200F0DF45F0F02C47F0F00C06C4C1D9E2C9D50090E4D00C92F0F0C7
++DATA3   80   60 58210000184F68620000200640404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001921040AD7900418047C040649280
++DATA2   80   30 40AD3100183D41D041A850D30008503041AC6A004168474040D824602A00
++DATA3   80   60 60004118411041A458F0419040404040F0F0F0F4
++DATA1   80    0 02E3E7E340000070404000384040000105EF4700010618D347F040707900
++DATA2   80   30 41844720406E2B662C66684041602A46682041582D246A2041502A266840
++DATA3   80   60 41482D426A4041402A46682040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A8404000384040000141382D246A2041302A2668404128
++DATA2   80   30 2D426A4041202C462C40918040C7471040B86B4041686B0041702A042000
++DATA3   80   60 91802000478040CE310047F040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E0404000384040000140CE6A00417898E4D00C92FFD00C
++DATA2   80   30 07FE6060411098EF41884120411041304219440F005A0501081710004110
++DATA3   80   60 419418FE05EF58DD0004950040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040000C4040000141F74770401A3B0047F040CE4040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000013840400038404000013F180CD96B42A610C07FE6DD798C
++DATA2   80   30 BF27C1470EC5E7C7075CC1489A752C6A6B54C13A5496A02A788DC06B411D
++DATA3   80   60 9ED01722C11BFB2E6EB617AA40404040F0F0F0F9
++DATA1   80    0 02E3E7E3400001704040003840400001BF99119272C87E78C11323D9C96F
++DATA2   80   30 1661411000000000000040921FB54442D184413243F6A8885A3040800000
++DATA3   80   60 3A100000000000000000000040404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001A8404000184040000100000000000002100000020C0000
++DATA2   80   30 020880000128800001304040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02E3E7E34000020840400004404000010000010B40404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02E3E7E34000021040400021404000010000003BC9C8C3F2F6F7C940C4C1
++DATA2   80   30 D9E2C9D560C4C1D9C3D6E24061C1D9C7617E614040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++DATA1   80    0 02E3E7E3400002484040000740400001616B40C7E340F140404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F4
++DATA1   80    0 02D9D3C4404040404040003040404040000100010D0001AC0D0001B00D00
++DATA2   80   30 01B4090001B9080001BD000200010C0001A8000300011C0001A000040001
++DATA3   80   60 0C0001A4404040404040404040404040F0F0F1F5
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F6
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLATAN EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040002040400001C9C8C3D3C1E3C1D5000000004000
++DATA2   80   30 0124C4C1E3C1D54040400100000040000001404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3D5F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C4C1E3C1D590EFD00C
++DATA2   80   30 58110000680100005801000030006840F0F01B1141E0F100390447C0F036
++DATA3   80   60 28242D202802411000107900D3C1E3D5F0F0F0F2
++DATA1   80    0 02E3E7E3400000384040003840400001F0AC47C0F08C7900F12047C0F05A
++DATA2   80   30 28206C00F0E82B042A026A20F0F82D0241EE000828602C006840F0E02A40
++DATA3   80   60 6820F0D82D246A20F0D02A20D3C1E3D5F0F0F0F3
++DATA1   80    0 02E3E7E34000007040400038404000016840F0C82D426A40F0C02A406820
++DATA2   80   30 F0B82D246A20F0B02C022C062A066A01E00011116B01F1003000120047A0
++DATA3   80   60 F0A0310058ED000C92FFD00CD3C1E3D5F0F0F0F4
++DATA1   80    0 02E3E7E3400000A8404000024040000107FE404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3D5F0F0F0F5
++DATA1   80    0 02E3E7E3400000AC40400004404000013A10000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3D5F0F0F0F6
++DATA1   80    0 02E3E7E3400000B04040003840400001BF1E31FF1784B965C0ACDB34C0D1
++DATA2   80   30 B35D412B7CE45AF5C165C11A8F923B178C78412AB4FD5D433FF6C02298BB
++DATA3   80   60 68CFD86941154CEE8B70CA99D3C1E3D5F0F0F0F7
++DATA1   80    0 02E3E7E3400000E8404000384040000140BB67AE8584CAA8411000000000
++DATA2   80   30 0000411BB67AE8584CAB000000000000000040860A91C16B9B2CC0921FB5
++DATA3   80   60 4442D184BFC152382D736574D3C1E3D5F0F0F0F8
++DATA1   80    0 02E3E7E34000012040400004404000014044985140404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3D5F0F0F0F9
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3D5F0F0F1F0
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLATN2 EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D3C1E3D5F2000000004000
++DATA2   80   30 0251C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040D3C1E3F2F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040002040404040C4C1E3C1D5404040010000184000
++DATA2   80   30 0001C4C1E3C1D5F240400100000040000001404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3F2F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C4C1E3C1D5F20090E0
++DATA2   80   30 D00C9280F20845F0F02A47F0F00A05C4C1E3C1D590EFD00C9200F1F058E1
++DATA3   80   60 0000680E0000580E00003000D3C1E3F2F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000019180F1F04780F07A58E10004686E
++DATA2   80   30 000020264780F0667000F1F058E0F1F07020F1F05BE0F1F07060F1F059E0
++DATA3   80   60 F1E44720F06C326647A0F078D3C1E3F2F0F0F0F4
++DATA1   80    0 02E3E7E340000070404000384040000159E0F1E847A0F0782B0047F0F0FE
++DATA2   80   30 32004780F1166800F1A06B00F1C047F0F1042D026840F1A01B1141E0F1B0
++DATA3   80   60 390447C0F09428242D202802D3C1E3F2F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040003840400001411000107900F1EC47C0F0EA7900
++DATA2   80   30 F1F447C0F0B828206C00F1982B042A026A20F1A82D0241EE000828602C00
++DATA3   80   60 6840F1882A406820F1802D24D3C1E3F2F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000016A20F1782A206840F1702D426A40
++DATA2   80   30 F1682A406820F1602D246A20F1582C022C062A066A01E00011116B01F1B0
++DATA3   80   60 30009180F1F04780F1046B00D3C1E3F2F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040003840400001F1903000120047A0F10C330058ED
++DATA2   80   30 000C92FFD00C07FE6000F1D06060F1D8501D001818EF181D58F0F1F841DF
++DATA3   80   60 00C4501D000450D10008180ED3C1E3F2F0F0F0F8
++DATA1   80    0 02E3E7E340000150404000204040000158F0E1E04110E1FC05EF18F058DD
++DATA2   80   30 00049500F2174780F10C4110F20847F0F012404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3F2F0F0F0F9
++DATA1   80    0 02E3E7E3400001704040003840400001BF1E31FF1784B965C0ACDB34C0D1
++DATA2   80   30 B35D412B7CE45AF5C165C11A8F923B178C78412AB4FD5D433FF6C02298BB
++DATA3   80   60 68CFD86941154CEE8B70CA99D3C1E3F2F0F0F1F0
++DATA1   80    0 02E3E7E3400001A84040003840400001413243F6A8885A3140BB67AE8584
++DATA2   80   30 CAA84110000000000000411BB67AE8584CAB000000000000000040860A91
++DATA3   80   60 C16B9B2CC0921FB54442D184D3C1E3F2F0F0F1F1
++DATA1   80    0 02E3E7E3400001E04040000840400001BFC152382D736574404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3F2F0F0F1F2
++DATA1   80    0 02E3E7E3400001F84040001040400001000000000E000000F20000003A10
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3F2F0F0F1F3
++DATA1   80    0 02E3E7E34000020C40400020404000014044985100000000000002300000
++DATA2   80   30 022C00000228000001E8800001F000000109404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3F2F0F0F1F4
++DATA1   80    0 02E3E7E34000023040400020404000010000001CC9C8C3F2F6F5C940C4C1
++DATA2   80   30 E3C1D5F240C1D9C7E4D4C5D5E3E27EF04BF0404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3F2F0F0F1F5
++DATA1   80    0 02D9D3C4404040404040002840404040000100010D0002140D0002180D00
++DATA2   80   30 021C0D00022008000225000200010C000210000300011C0001F840404040
++DATA3   80   60 404040404040404040404040D3C1E3F2F0F0F1F6
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C1E3F2F0F0F1F7
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLERF  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D3C5D9C640000000004000
++DATA2   80   30 02F4C4C5D9C6404040400100001640000001C4C5D9C6C340404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040400002C4C5E7D740404040020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C4C5D9C6C390E5D00C
++DATA2   80   30 9200F0AF45F0F02847F0F00A04C4C5D9C60090E5D00C92F0F09958210000
++DATA3   80   60 6822000020429835F29E794040404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001F2AE47A0F0A07940F29247A0F082
++DATA2   80   30 6800F1727940F2AA4740F0502C22415500206800F11A2C026A03F1228734
++DATA3   80   60 F0462C042A049180F099471040404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001F0626B00F2923000918020004780
++DATA2   80   30 F0789180F0994710F0766B00F29A330098E5D00C92FFD00C07FE41550058
++DATA3   80   60 6B40F17A6800F1822C046A0340404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040003840400001F18A8734F08E4700F05C47F0F062
++DATA2   80   30 7940F2B24740F0CA7800F11E9180F0994710F05C918020004710F0727940
++DATA3   80   60 F2B64740F0CA2C0047F0F07840404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000012C226860F21A2A6228066863F25A
++DATA2   80   30 2D606A63F2228734F0D02D6431226020F1124110F2D6184D41D0F2BA50D4
++DATA3   80   60 00085040F2BE183F58F0F2DA40404040F0F0F0F7
++DATA1   80    0 02E3E7E340000118404000104040000105EF4700010818F318D42C0647F0
++DATA2   80   30 F09840404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E3400001304040003840400001B93575CB032888883A3AE362DA85
++DATA2   80   30 FB5BBB2B80E5106F29333C1B97FD43205DA9BCFA6526BD76ED333D7E68AE
++DATA3   80   60 AA7DF3C6BE3805B607BC880840404040F0F0F0F9
++DATA1   80    0 02E3E7E34000016840400038404000013F1565BCCF92B9D6BF6E0B38C47E
++DATA2   80   30 A601401CE2F21A040D17C06049D1AC0DE6F54020DD750429B6D2411B5A00
++DATA3   80   60 000000003B167F03888C890D40404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001A040400038404000013B9FD941F87D786C3AC808E74EBC
++DATA2   80   30 9B87BC37F7ABFD1918623C6E75AECE8102D43CF38568C997EC42BD50F5F5
++DATA3   80   60 06D2E9A03D2AFBA45E9EA01040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001D840400038404000013E1C591036E309F0BE4642A0283F
++DATA2   80   30 3525BE1855E9E68608D03F198E1E4DA67774BF2BDE716F1D2638BF115722
++DATA3   80   60 75A37AED3FC98FE2BB6FE2CA40404040F0F0F1F2
++DATA1   80    0 02E3E7E3400002104040003840400001C01919E57C233961401A925CDF5B
++DATA2   80   30 78DABFF8B37923BCC1683F3FFFFB678ECA0C41138FECB70009CB413E5E34
++DATA3   80   60 C316AA854170C114C5AD499D40404040F0F0F1F3
++DATA1   80    0 02E3E7E34000024840400038404000014174A6EBF5930F544157F3CD5564
++DATA2   80   30 93C74137FFFA4C4FE1894117FFFFFFD414E340906EBA8214DB0EC114FC5D
++DATA3   80   60 7B70143CC17B2C0FAAD4F47740404040F0F0F1F4
++DATA1   80    0 02E3E7E3400002804040003840400001C1E847FA259245A1C1A67578C4A4
++DATA2   80   30 803CC14FFE9B53FB1274C117FFFFE7BADE7FC048375D4109A0B441100000
++DATA3   80   60 00000000412000000000000040404040F0F0F1F5
++DATA1   80    0 02E3E7E3400002B8404000184040000100000008000000303A1000004120
++DATA2   80   30 A5B141617A5641D4E5604040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F6
++DATA1   80    0 02E3E7E3400002EC40400008404000018000012800000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F7
++DATA1   80    0 02D9D3C440404040404000104040404000010001080002ED000200010C00
++DATA2   80   30 02F040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F8
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F9
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLEXP  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D3C5E7D740000000004000
++DATA2   80   30 0288C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040D3C5E7D7F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040404040C4C5E7D740404040010000004000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C5E7D7F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C4C5E7D74090EFD00C
++DATA2   80   30 58E10000680E00007900F1504720F0EA7900F15447C0F0E038207D20F14C
++DATA3   80   60 7E20F2307020F1587C20F14CD3C5E7D7F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000012B026820F1586C20F1A02B025800
++DATA2   80   30 F15847C0F05C130006006A00F2284720F04E47F0F06C6900F2284720F06C
++DATA3   80   60 6B00F2284B00F19A1B118C00D3C5E7D7F0F0F0F4
++DATA1   80    0 02E3E7E34000007040400038404000010004881000198C00000289000018
++DATA2   80   30 13E01B008D0000027900F1704720F0B628207C00F1746A00F1782C026A00
++DATA3   80   60 F1802C026A00F1882C026A00D3C5E7D7F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040003840400001F1902C026A00F1982C026C01F1A8
++DATA2   80   30 6A01F1A812004780F0C624004600F0C07000F1585AE0F15850E0F1587800
++DATA3   80   60 F15858ED000C92FFD00C07FED3C5E7D7F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000017800F17C2C0047F0F0D66000F160
++DATA2   80   30 9001D01418EF58F0E148181D41DF00C4501D000450D100089023D00C4120
++DATA3   80   60 E1604130E265440F00560501D3C5E7D7F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040003840400001081710009823D00C4110E23C58F0
++DATA2   80   30 E23405EF58DD000458FD001041E0F1609500F24F4770F0126800F16847F0
++DATA3   80   60 F0D600000000000040B17218D3C5E7D7F0F0F0F8
++DATA1   80    0 02E3E7E340000150404000104040000142AEAC4EC2B437DF000000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C5E7D7F0F0F0F9
++DATA1   80    0 02E3E7E34000016840400038404000017FFFFFFFFFFFFFFFB21000003E59
++DATA2   80   30 18933F2220559A15E1583FAAAA9D6AC1D734402AAAAAA794AA99407FFFFF
++DATA3   80   60 FFFAB64A40FFFFFFFFFFFCFCD3C5E7D7F0F0F1F0
++DATA1   80    0 02E3E7E3400001A04040003840400001B982E308654361C4411000000000
++DATA2   80   30 000040F5257D152486CD40EAC0C6E7DD243A40E0CCDEEC2A94E140D744FC
++DATA3   80   60 CAD69D6B40CE248C151F8481D3C5E7D7F0F0F1F1
++DATA1   80    0 02E3E7E3400001D8404000384040000140C5672A115506DB40BD08A39F58
++DATA2   80   30 0C3740B504F333F9DE6540AD583EEA42A14B40A5FED6A9B15139409EF532
++DATA3   80   60 6091A112409837F0518DB8AAD3C5E7D7F0F0F1F2
++DATA1   80    0 02E3E7E34000021040400038404000014091C3D373AB11C4408B95C1E3EA
++DATA2   80   30 8BD74085AAC367CC487CBFB17217F7D1CF7A450000000000000000000106
++DATA3   80   60 000002500000024C00000238D3C5E7D7F0F0F1F3
++DATA1   80    0 02E3E7E34000024840400004404000018000016040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C5E7D7F0F0F1F4
++DATA1   80    0 02E3E7E340000250404000154040000100000034C9C8C3F2F6F2C940C4C5
++DATA2   80   30 E7D740C1D9C77E4040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C5E7D7F0F0F1F5
++DATA1   80    0 02E3E7E34000027C4040000C404000016B40C7E340F1F7F44BF6F7F34040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C5E7D7F0F0F1F6
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D00023C0D0002400D00
++DATA2   80   30 024408000249000200010C000148000300011C0002344040404040404040
++DATA3   80   60 404040404040404040404040D3C5E7D7F0F0F1F7
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3C5E7D7F0F0F1F8
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLGAMA EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D3C7C1D4C1000000004000
++DATA2   80   30 03EBC4C7C1D4D4C140400100001C40000001C4D3C7C1D4C1404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400002C4C5E7D740404040020000004040
++DATA2   80   30 4040C4D3D6C7404040400200000040404040C9C2C3D6D47B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040001040400005C9C8C3C5D9D9D440020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C4D3C7C1D4C10090E5
++DATA2   80   30 D00C9200F0E941FF001C47F0F01247F0F00A05C4C7C1D4D490E5D00C92F0
++DATA3   80   60 F0CD182F185D41D022C450D540404040F0F0F0F4
++DATA1   80    0 02E3E7E34000003840400038404000010008505D00045831000068230000
++DATA2   80   30 58F0230C792022B447202050918020CD47102168322247C0217405EF4700
++DATA3   80   60 010A330047F020DE792022B840404040F0F0F0F5
++DATA1   80    0 02E3E7E340000070404000384040000147C02068918020CD471021687920
++DATA2   80   30 22BC47202174792022B047A020EC7920228C47402092922C20CA6840228C
++DATA3   80   60 792022AC47C020A06B20228C40404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000A840400038404000012C4247F02080922D20CA28426B20
++DATA2   80   30 228447F020A46B20229C680021E42C026860221C2A62983522A06A0321EC
++DATA3   80   60 2C022C626A632224873420B440404040F0F0F0F7
++DATA1   80    0 02E3E7E3400000E040400038404000012D066A0022542C0447F020DE6000
++DATA2   80   30 21D44110232C05EF4700010C58D022C898E5D00C92FFD00C07FE2B667920
++DATA3   80   60 22C04720211E6800228C2D0240404040F0F0F0F8
++DATA1   80    0 02E3E7E340000118404000384040000128402C447860225C3C647A602260
++DATA2   80   30 3C646A6022642C646A60226C2C646A6022742C60606021D405EF4700010E
++DATA3   80   60 24206B00228C6C0300006B2040404040F0F0F0F9
++DATA1   80    0 02E3E7E340000150404000384040000121D46B20227C700021D4D2002294
++DATA2   80   30 21D46E0022942B02918020CD478020DE600021D44110232C58F0231005EF
++DATA3   80   60 4700011047F020DE92F0237940404040F0F0F1F0
++DATA1   80    0 02E3E7E340000188404000384040000141E0233047F0217C92F1237941E0
++DATA2   80   30 2350602021D4D203237CE004D21523B9E00850E0232898EF231441302387
++DATA3   80   60 1842412021D4440F005A050140404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001C04040002E40400001081710004133001C440F004E0501
++DATA2   80   30 081018244110232018FE05EF4110232C9500231F47702022680021DC47F0
++DATA3   80   60 20DE4040404040404040404040404040F0F0F1F2
++DATA1   80    0 02E3E7E3400001F840400038404000017FFFFFFFFFFFFFFFC0C1B71B59A1
++DATA2   80   30 A1F641B33F20CFA73CB34153CF867C239860C23EBA40FFB0397B43441182
++DATA3   80   60 D7048BE643C3CDE7AC8F223240404040F0F0F1F3
++DATA1   80    0 02E3E7E340000230404000384040000142E8A532ACC72020C1A5004D8798
++DATA2   80   30 29C541E62A3573ECF95D42C97F1D84DC37A0C327558408F56C71C358DA53
++DATA3   80   60 5E2785864411F52476FDA8AB40404040F0F0F1F4
++DATA1   80    0 02E3E7E3400002684040003840400001441C1A16BED21CC540E2DFC48DA7
++DATA2   80   30 7B563E31E4F7BE26EC113E340314721524AFBEB60B60907F58F240155555
++DATA3   80   60 55554ADC40EB3F8E4325F5C540404040F0F0F1F5
++DATA1   80    0 02E3E7E3400002A040400038404000014080000000000000411000000000
++DATA2   80   30 000000000000000000014118000000000000000000080000002841200000
++DATA3   80   60 41800000021000004239930C40404040F0F0F1F6
++DATA1   80    0 02E3E7E3400002D840400008404000017E184D2F47200000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F7
++DATA1   80    0 02E3E7E34000032840400010404000010000000000000000000000000000
++DATA2   80   30 000040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F8
++DATA1   80    0 02E3E7E34000033C40400008404000010000038C00000338404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F9
++DATA1   80    0 02E3E7E3400003484040003840400001800001F00000012CC4C7C1D4F25C
++DATA2   80   30 5C60F2F5F240D6D940C7C540F5F74BF5F7F4F44000000000012DC4D3C7C1
++DATA3   80   60 F04B40D6D940C7C540F44BF240404040F0F0F2F0
++DATA1   80    0 02E3E7E3400003804040001840400001F9F3F75CF1F05C5CF7F300000000
++DATA2   80   30 005BC9C8C3F3F05CC9404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F1
++DATA1   80    0 02E3E7E34000039C4040000740400001D4C140C1D9C77E40404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F2
++DATA1   80    0 02E3E7E3400003BA40400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F3
++DATA1   80    0 02E3E7E3400003CF40400006404000015D6B40D3C5404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F4
++DATA1   80    0 02D9D3C4404040404040003040404040000100010D00033C0D0003400800
++DATA2   80   30 0349000200010C00032C000300010C000328000400010C00033400050001
++DATA3   80   60 1C000330404040404040404040404040F0F0F2F5
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F6
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLLOG  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D3D3D6C740000000004000
++DATA2   80   30 0200C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040D3D3D6C7F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040002040404040C4D3D6C740404040010000184000
++DATA2   80   30 0001C4D3D6C7F1F040400100000040000001404040404040404040404040
++DATA3   80   60 404040404040404040404040D3D3D6C7F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C4D3D6C7F1F04090E3
++DATA2   80   30 D00C926CF0BC45F0F02A47F0F00A04C4D3D6C74090E3D00C9291F0A45821
++DATA3   80   60 000098232000120247C0F0B2D3D3D6C7F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000018C000018890000024000F1528810
++DATA2   80   30 001D4311F1808D2010009023F1109240F1101B226800F1107900F1884720
++DATA3   80   60 F05641200008411100012420D3D3D6C7F0F0F0F4
++DATA1   80    0 02E3E7E34000007040400038404000016B02F1686A22F1702D0228202C22
++DATA2   80   30 6840F1202A426860F1282D646A60F1302A626840F1382D466A40F1402A42
++DATA3   80   60 6C40F1482C422C402A406800D3D3D6C7F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040003840400001F150411101004010F1527B00F150
++DATA2   80   30 6C00F1582A046C00F1609823D01C92FFD00C07FE9023F11018EF4120F110
++DATA3   80   60 4130F1C858F0F18C440F0056D3D3D6C7F0F0F0F6
++DATA1   80    0 02E3E7E3400000E04040003840400001050108171000183D41DF00C4503D
++DATA2   80   30 000450D30008183E4110319858F0319005EF18F358DD000458ED000C9500
++DATA3   80   60 F1AB4770F016947FF1105800D3D3D6C7F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040001040400001F11012004770F0166800F11847F0
++DATA2   80   30 F0A840404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3D3D6C7F0F0F0F8
++DATA1   80    0 02E3E7E3400001304040003840400001FFFFFFFFFFFFFFFFC158FA4E0E40
++DATA2   80   30 C0A5C12A017578F548D1C16F2A64DDFCC1FDC38E5A1C55CEB1C4422FC604
++DATA3   80   60 E13C20FE3DDABB6C9F18C6DDD3D3D6C7F0F0F0F9
++DATA1   80    0 02E3E7E3400001684040003840400001460000000000000040B17217F7D1
++DATA2   80   30 CF7B406F2DEC549B943A4110000000000000408000000000000040400000
++DATA3   80   60 000000000302010100000000D3D3D6C7F0F0F1F0
++DATA1   80    0 02E3E7E3400001A0404000204040000140B504F300000000000000000000
++DATA2   80   30 0107000001C4000001C0000001AC80000128404040404040404040404040
++DATA3   80   60 404040404040404040404040D3D3D6C7F0F0F1F1
++DATA1   80    0 02E3E7E3400001C44040001C4040000100000037C9C8C3F2F6F3C940C4D3
++DATA2   80   30 D6C760C4D3D6C7F1F040C1D9C77E40404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3D3D6C7F0F0F1F2
++DATA1   80    0 02E3E7E3400001F7404000084040000140D3C540E9C5D9D6404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3D3D6C7F0F0F1F3
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D0001B00D0001B40D00
++DATA2   80   30 01B8080001BD000200010C0001A4000300011C0001A84040404040404040
++DATA3   80   60 404040404040404040404040D3D3D6C7F0F0F1F4
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3D3D6C7F0F0F1F5
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLSCN  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D3E2C3D540000000004000
++DATA2   80   30 026CC9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040D3E2C3D5F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040002040404040C4C3D6E240404040010000004000
++DATA2   80   30 0001C4E2C9D5404040400100001A40000001404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E2C3D5F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C4C3D6E24090E0D00C
++DATA2   80   30 4100000258E1000045F0F03A47F0F00A04C4E2C9D54090E0D00C58E10000
++DATA3   80   60 1B009180E0004780F0204100D3E2C3D5F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000010004680E000030007900F1D247A0
++DATA2   80   30 F0C06D00F1AE28206E20F1BE6020F13E6A20F1BE2B025E00F1425000F13E
++DATA3   80   60 9101F1414780F0566B00F1B6D3E2C3D5F0F0F0F4
++DATA1   80    0 02E3E7E340000070404000384040000120401B119103F1414740F0664110
++DATA2   80   30 00087940F1CE4720F0702B002C0028206C01F1466A01F1562C026A01F166
++DATA3   80   60 2C026A01F1762C026A01F186D3E2C3D5F0F0F0F5
++DATA1   80    0 02E3E7E3400000A840400038404000012C026A01F1962C026A01F1A61211
++DATA2   80   30 4780F0A62C0447F0F0AC2C026A00F1B69104F1414780F0B6310058ED000C
++DATA3   80   60 92FFD00C07FED207F13EE000D3E2C3D5F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000015000F1D6501D001818EF181D58F0
++DATA2   80   30 F1DA41DF00C4501D000450D100089023D0144120E13E4130E2174400F05A
++DATA3   80   60 0501081710004130E2334400D3E2C3D5F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040003840400001F04E05010810180E9823D0144110
++DATA2   80   30 E1E258F0E1DE05EF18F041E0F13E58DD00046800F1C69500F1F54780F0B6
++DATA3   80   60 5800F1D69102F1D94710F020D3E2C3D5F0F0F0F8
++DATA1   80    0 02E3E7E340000150404000044040000147F0F01240404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E2C3D5F0F0F0F9
++DATA1   80    0 02E3E7E3400001604040003840400001B66C992E84B6AA373778FCE0E5AD
++DATA2   80   30 1685387E731045017594B978C01C6BEF8CB3BA69B47B1E41AEF63B541E0B
++DATA3   80   60 F684B5273C3C3EA0D06ABC29D3E2C3D5F0F0F1F0
++DATA1   80    0 02E3E7E3400001984040003840400001BD265A599C5CB632BE155D3C7E3C
++DATA2   80   30 90F83EA335E33BAC3FBD3F40F07C206D6AB1C014ABBCE625BE41C04EF4F3
++DATA3   80   60 26F9177740C90FDAA22168C2D3E2C3D5F0F0F1F1
++DATA1   80    0 02E3E7E3400001D0404000204040000141100000000000004E0000000000
++DATA2   80   30 000040B504F333F9DE703A1000004DC90FDA404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E2C3D5F0F0F1F2
++DATA1   80    0 02E3E7E3400001F440400018404000010000000000000000000002140000
++DATA2   80   30 020C00000210800001584040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E2C3D5F0F0F1F3
++DATA1   80    0 02E3E7E34000021040400021404000010000010800000054C9C8C3F2F6F4
++DATA2   80   30 C940C4E2C9D560C4C3D6E24061C1D9C7617E614040404040404040404040
++DATA3   80   60 404040404040404040404040D3E2C3D5F0F0F1F4
++DATA1   80    0 02E3E7E34000024840400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E2C3D5F0F0F1F5
++DATA1   80    0 02E3E7E34000025D4040000F404000015D616B40C7C540D7C95CF25C5CF5
++DATA2   80   30 F04040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E2C3D5F0F0F1F6
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D0001FC0D0002000D00
++DATA2   80   30 020408000209000200010C0001F4000300011C0001F84040404040404040
++DATA3   80   60 404040404040404040404040D3E2C3D5F0F0F1F7
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E2C3D5F0F0F1F8
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLSCNH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D3E2C3D5C8000000004000
++DATA2   80   30 022FC4C5E7D7404040400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C9C2C3D6D47B4040020000004040
++DATA2   80   30 4040C4E2C9D5C84040400100001640000001C4C3D6E2C840404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C4C3D6E2C890E2D00C
++DATA2   80   30 9230F0B245F0F02847F0F00A05C4E2C9D5C890E2D00C9231F09C182F5811
++DATA3   80   60 00006841000020049101209C40404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001478020647900216647A020667900
++DATA2   80   30 211A474020AE2C0028206C00211A6A0021222C026A00212A2C026A002132
++DATA3   80   60 2C026A00213A2C026A00214240404040F0F0F0F4
++DATA1   80    0 02E3E7E34000007040400038404000012C022C042A0447F020B6304418ED
++DATA2   80   30 41D0218250DE000850E0218679002162472020C06A002152600021124110
++DATA3   80   60 217E58F0216E05EF4700010440404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A8404000384040000158D021866820214A2D2031226000
++DATA2   80   30 21122A026C00215A2A026A002112324447A020B6310098E2D00C92FFD00C
++DATA3   80   60 07FED207211210009023D00C40404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E0404000384040000158F0216A413021F541202112440F
++DATA2   80   30 005A0501001710009823D00C4110217258F021CA05EF6800210A58D02186
++DATA3   80   60 950021D1478020B64110217E40404040F0F0F0F7
++DATA1   80    0 02E3E7E340000118404000044040000147F0201440404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000012040400008404000017FFFFFFFFFFFFFFF404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E340000130404000384040000138B2D4C184418A973A6B96B8975A
++DATA2   80   30 16363C2E3BC881345D913DD00D00CB06A6F53F2222222222BACE402AAAAA
++DATA3   80   60 AAAAAA4D403FDF9434F03D2640404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001684040003040400001C0B1B300000000003E40F0434B74
++DATA2   80   30 1C6D42AF5DC040E1A1B80000000000000000000001EC000001E4000001E8
++DATA3   80   60 80000128404040404040404040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001E040400004404000010000000040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02E3E7E3400001E840400023404000010000010A0000003FC9C8C3F2F6F6
++DATA2   80   30 C940C4E2C9D5C860C4C3D6E2C84061C1D9C7617E61404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++DATA1   80    0 02E3E7E3400002224040000D40400001616B40C7C540F1F7F54BF3F6F640
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F4
++DATA1   80    0 02D9D3C4404040404040002C40404040000100010D0001880D00018C0D00
++DATA2   80   30 019008000195000200010C000184000300011C0001E0000400010C000180
++DATA3   80   60 40404040404040404040404040404040F0F0F1F5
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F6
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLSQRT EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D3E2D8D9E3000000004000
++DATA2   80   30 014BC9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040D3E2D8D9F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040404040C4E2D8D9E3404040010000004000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E2D8D9F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C4E2D8D9E390EFD00C
++DATA2   80   30 58E10000680E000022404740F07E4780F0747040F0E45800F0E45E00F0EC
++DATA3   80   60 8C0000194200F0E44200F0F0D3E2D8D9F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000017820F0E47A20F0F07C20F0F41211
++DATA2   80   30 47A0F04E3A223A223D423E42344438203D243E24342228402D422E422444
++DATA3   80   60 2D042B0434007F00F0F07E00D3E2D8D9F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001F0F02A0458ED000C92FFD00C07FE
++DATA2   80   30 6000F0E09001D01418EF181D58F0F0E841DF00C450D10008501D00049023
++DATA3   80   60 D0144120E0E04130E134440FD3E2D8D9F0F0F0F5
++DATA1   80    0 02E3E7E3400000A8404000384040000100560501081710009823D0144110
++DATA2   80   30 E0FC58F0E0DC180E05EF58DD000418F09500F10F4770F0D29780F0E041E0
++DATA3   80   60 F0E047F0F012000000000000D3E2D8D9F0F0F0F6
++DATA1   80    0 02E3E7E3400000E84040002440400001000000003100000000423A2A4838
++DATA2   80   30 5F0700000105000001100000010C000000F8800000E04040404040404040
++DATA3   80   60 404040404040404040404040D3E2D8D9F0F0F0F7
++DATA1   80    0 02E3E7E340000110404000244040000100000037C9C8C3F2F6F1C940C4E2
++DATA2   80   30 D8D9E340D5C5C7C1E3C9E5C540C1D9C7E4D4C5D5E37E4040404040404040
++DATA3   80   60 404040404040404040404040D3E2D8D9F0F0F0F8
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D0000FC0D0001000D00
++DATA2   80   30 010408000109000200010C0000E8000300011C0000DC4040404040404040
++DATA3   80   60 404040404040404040404040D3E2D8D9F0F0F0F9
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E2D8D9F0F0F1F0
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLTANH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D3E3C1D5C8000000004000
++DATA2   80   30 011CC4C5E7D7404040400200000040404040C4E3C1D5C840404001000000
++DATA3   80   60 400000014040404040404040D3E3D5C8F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C4E3C1D5C890EFD00C
++DATA2   80   30 58110000686100006840F0F820067900F0BC47C0F0767900F0B447A0F070
++DATA3   80   60 2A006000F0C041E0F10050EDD3E3D5C8F0F0F0F2
++DATA1   80    0 02E3E7E3400000384040003840400001000850D0F10418DE4110F0AC58F0
++DATA2   80   30 F0B005EF4700010258D0E0BA98EFD00C2A0428242A222D2028042B023266
++DATA3   80   60 47A0F06A310092FFD00C07FED3E3D5C8F0F0F0F3
++DATA1   80    0 02E3E7E3400000704040003840400001280447F0F0627900F0B847C0F062
++DATA2   80   30 2C006840F0F02A406820F0E82D246A20F0E02A206840F0D82D426A40F0D0
++DATA3   80   60 2A406C00F0C82D042C062A06D3E3D5C8F0F0F0F4
++DATA1   80    0 02E3E7E3400000A8404000044040000147F0F06A40404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E3D5C8F0F0F0F5
++DATA1   80    0 02E3E7E3400000AC4040001440400001800000C000000000421419DB3A10
++DATA2   80   30 0000408C9F95404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E3D5C8F0F0F0F6
++DATA1   80    0 02E3E7E3400000C84040003840400001C0F6E12F40F5590A419DA5D6FD3D
++DATA2   80   30 BC84C31C504FEF537AF6424D2FA31CAD8D00C3136E2A5891D8E94219B3AC
++DATA3   80   60 A4C6E7904110000000000000D3E3D5C8F0F0F0F7
++DATA1   80    0 02D9D3C440404040404000104040404000010001080000AD000200010C00
++DATA2   80   30 00B040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E3D5C8F0F0F0F8
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040D3E3D5C8F0F0F0F9
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCLTNCT EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D3E3D5C3E3000000004000
++DATA2   80   30 02C4C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040404040C4E3C1D540404040010000184000
++DATA2   80   30 0001C4C3D6E3C1D540400100000040000001D8C4E3C1D5404040010001BC
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C4C3D6E3C1D50090E1
++DATA2   80   30 D00C9297F09045F0F02A47F0F00A04C4E3C1D50090E1D00C9291F0786840
++DATA3   80   60 F19058E10000680E0000300040404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000017900F1E847A0F0E86D00F1A87000
++DATA2   80   30 F188D200F1A0F188390447A0F05C9200F18F9102F0784780F0767900F1EC
++DATA3   80   60 4720F0764110F22492F9F25140404040F0F0F0F4
++DATA1   80    0 02E3E7E340000070404000384040000147F0F0F028206E20F1986020F188
++DATA2   80   30 6A20F1982B029101F18F4780F0762B0420609701F18F6820F1C87960F1F0
++DATA3   80   60 4740F0A22C0028406A40F1B040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A840400038404000012C406A40F1B82C206A20F1D02C20
++DATA2   80   30 6A20F1D82C206A20F1E02C046A00F1C02C069103F18F4740F0BE2D0247F0
++DATA3   80   60 F0CA6960F1A047C0F0502D2040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E0404000384040000128029102F18F4780F0D433009180
++DATA2   80   30 E0004780F0DE330058ED000C92FFD00C07FE4110F20092F8F251D207F180
++DATA3   80   60 E0005010F170D207F178100440404040F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040003840400001D215F296100C181D180F58F0F1F4
++DATA2   80   30 41DF00C4501D000450D100089024D00C18404130426741204180440F005A
++DATA3   80   60 05010817100041304283440F40404040F0F0F0F8
++DATA1   80    0 02E3E7E3400001504040003040400001004E050108104110416858F041FC
++DATA2   80   30 18049824D00C05EF18F058DD0004680100104110F1749500F1FB4780F0DE
++DATA3   80   60 47F0F012404040404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E34000018040400008404000010000026000000210404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02E3E7E34000018C40400004404000018000019840404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001A8404000384040000141100000000000004E0000000000
++DATA2   80   30 0000000000000000000840C90FDAA22168C2C325FD4A87357CAF44AFFA63
++DATA3   80   60 93159226C58AFDD0A41992D440404040F0F0F1F2
++DATA1   80    0 02E3E7E3400001E04040003040400001422376F171F72282C41926DBBB1F
++DATA2   80   30 469B4532644B1E45A133C5B0F82C871A3B684DC90FDA02145F3135400000
++DATA3   80   60 00000000404040404040404040404040F0F0F1F3
++DATA1   80    0 02E3E7E3400002144040003840400001000000000000010C411000000000
++DATA2   80   30 0000C7C540D7C95CF25C5CF5F0404040404040404040404000000000010D
++DATA3   80   60 7FFFFFFFFFFFFFFFC1D7D7D940404040F0F0F1F4
++DATA1   80    0 02E3E7E34000024C4040003340400001D6C1C3C8C5E240E2C9D5C7E4D3C1
++DATA2   80   30 D9C9E3E8000000000060C9C8C3F2F65CC940C4E3C1D560C4C3D6E3C1D540
++DATA3   80   60 61C1D9C7617E61404040404040404040F0F0F1F5
++DATA1   80    0 02E3E7E34000029640400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F6
++DATA1   80    0 02E3E7E3400002AB40400003404000015D61404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F7
++DATA1   80    0 02D9D3C4404040404040002040404040000100010D0001800D0001840800
++DATA2   80   30 018D000200010C00020C000300011C000214404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F8
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F9
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCNAMEL EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3D5C1D4C5D3000000004000
++DATA2   80   30 0AA7C6D9C4D5D37B40400100000040000001C6E6D9D5D37B4040010005E8
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400002C9C2C3D6D47B4040020000004040
++DATA2   80   30 4040C1C4C3D6D57B40400200000040404040C6C9D6C3E27B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040001040400005C9C8C3C5D9D9D440020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000004040000B4040000147F0F00C06C6D9C4D5D37B404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F4
++DATA1   80    0 02E3E7E34000000C404000384040000190EDF838187F58A0E00458F07878
++DATA2   80   30 95FFF07C478070285820F06C07F2D23FF07C7838413000085820F0C405D2
++DATA3   80   60 50E07838050100F047F0754240404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000444040003840400001418320009550200147807068955B
++DATA2   80   30 2001478070685810787C0501010347F0754247F0704441D0000841202002
++DATA3   80   60 98457884954020004780708C40404040F0F0F0F6
++DATA1   80    0 02E3E7E34000007C40400038404000018D400008435020004120200146D0
++DATA2   80   30 70749045788CD507788CA000477070584190200141A0A00850A078981BCC
++DATA3   80   60 1BFF9200790392007904920040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400000B44040003840400001790941D000089845788495409000
++DATA2   80   30 4780710E956B90004780710E9550900047807528955B900047807528954D
++DATA3   80   60 900047807124956C9000478040404040F0F0F0F8
++DATA1   80    0 02E3E7E3400000EC40400038404000017124957E900047807128957B9000
++DATA2   80   30 4780712812DD478075828D4000084350900006D0419090011998474070BE
++DATA3   80   60 49D078C44780724A47F075A240404040F0F0F0F9
++DATA1   80    0 02E3E7E340000124404000384040000192FF790458A078989045788CD503
++DATA2   80   30 A00078E447807594D507788CA0004780714C4560778E47F07130D2007380
++DATA3   80   60 A00DDC00738078EDD200738240404040F0F0F1F0
++DATA1   80    0 02E3E7E34000015C4040003840400001A00DDC00738278F8456077A891FF
++DATA2   80   30 79044780723C91FFA00C478075B41BDD43D0A00E4130A0101B554350A00F
++DATA3   80   60 505078AC41F000011B66419040404040F0F0F1F1
++DATA1   80    0 02E3E7E34000019440400038404000019001509078B8199847A075A6956B
++DATA2   80   30 9000478071C4955D9000478071FE954C9000478071FE4160600141909001
++DATA3   80   60 47F0719A4540755806F01C4F40404040F0F0F1F2
++DATA1   80    0 02E3E7E3400001CC40400038404000011A2591FFA010478071EA58C03004
++DATA2   80   30 5850C0004130300446D0718C47F0720858C030005850C0005C4078AC5050
++DATA3   80   60 78AC47F071DE4540755806F040404040F0F0F1F3
++DATA1   80    0 02E3E7E34000020440400038404000011C4F1A251B4418525B5078B45B50
++DATA2   80   30 78B047A075B41355505078B01D4B18C541909001199847A075A6957E9000
++DATA3   80   60 4780723C957B90004770722240404040F0F0F1F4
++DATA1   80    0 02E3E7E34000023C404000384040000192FF79034199000119984740727A
++DATA2   80   30 502078B45810787C0501010347F075424183200041902001582078B491FF
++DATA3   80   60 79034710727A12CC47C070AE40404040F0F0F1F5
++DATA1   80    0 02E3E7E340000274404000384040000112FF4720727E41F000011B669540
++DATA2   80   30 9000477072964190900119984740728047F0724A92007903509078B8957E
++DATA3   80   60 900047807512957B9000478040404040F0F0F1F6
++DATA1   80    0 02E3E7E3400002AC40400038404000017512954D90004780750C956C9000
++DATA2   80   30 4780750C955C9000478073CE956B90004780731C955090004780751E955B
++DATA3   80   60 90004780751E95E99000478040404040F0F0F1F7
++DATA1   80    0 02E3E7E3400002E4404000384040000173E095C89000478073E8957D9000
++DATA2   80   30 4780742E957C90004780742E416060014190900119984740729E06909540
++DATA3   80   60 900047707346066047F0730C40404040F0F0F1F8
++DATA1   80    0 02E3E7E34000031C404000384040000191FF7905471073469108A00D4780
++DATA2   80   30 733492FF790547F072FE12664720734641607884506078B8416000019200
++DATA3   80   60 7905583078B81B554350A00D40404040F0F0F1F9
++DATA1   80    0 02E3E7E340000354404000384040000191FF79064780736E920079064130
++DATA2   80   30 30010660920773824150000B8B5000034260738158107880581510000501
++DATA3   80   60 00000000584078B046F073A440404040F0F0F2F0
++DATA1   80    0 02E3E7E34000038C40400038404000011A2B06C01B4B504078B041909001
++DATA2   80   30 199847A0724A47F0726612CC47C0738C1B5543507380065046C073BA47F0
++DATA3   80   60 738C413B2000445078D21B4B40404040F0F0F2F1
++DATA1   80    0 02E3E7E3400003C44040003840400001182346F073B247F0738C45407558
++DATA2   80   30 41909001199847A0724A47F0727E92FF790647F072FE126647C0751250F0
++DATA3   80   60 78AC18F6584078B89540400040404040F0F0F2F2
++DATA1   80    0 02E3E7E3400003FC40400038404000014780741095F040004740751295F9
++DATA2   80   30 4000472075124140400146F073F8502078B445407558186F454074CA58F0
++DATA3   80   60 78AC47F07482502078B4920040404040F0F0F2F3
++DATA1   80    0 02E3E7E34000043440400038404000017907D20079089000509078B81B66
++DATA2   80   30 D5009001790847807458416060014190900147F07442D500900279084770
++DATA3   80   60 746A4160600147F0746E92FF40404040F0F0F2F4
++DATA1   80    0 02E3E7E34000046C40400038404000017907589078B8454074CA91FF7907
++DATA2   80   30 4780743C41909001199847A074A2956B9000478074A295409000477074A0
++DATA3   80   60 4190900147F074820690584040404040F0F0F2F5
++DATA1   80    0 02E3E7E3400004A4404000384040000178B01244478074BA185292405000
++DATA2   80   30 41505001464074AE582078B4185C1C4B505078B047F0738491FF79044780
++DATA3   80   60 74DE59B078B047A074DE50B040404040F0F0F2F6
++DATA1   80    0 02E3E7E3400004DC404000384040000178B012D64190900107C459D078B0
++DATA2   80   30 47C074F258D078B006D044D078C641D0D0011A2D1A965BD078B013DD50D0
++DATA3   80   60 78B007F4126647C072FE589040404040F0F0F2F7
++DATA1   80    0 02E3E7E340000514404000384040000178B89200790647F070A612664720
++DATA2   80   30 730C92FF7909D502900178944780754291FF7909478070FE9200790947F0
++DATA3   80   60 72FE58F078781B221B33902340404040F0F0F2F8
++DATA1   80    0 02E3E7E34000054C4040003840400001F10C92FFF07C98ED783807FE1266
++DATA2   80   30 07C442607577902378A0412078BC583078B8581078805810102805010400
++DATA3   80   60 58F078BC982378A007F44B9040404040F0F0F2F9
++DATA1   80    0 02E3E7E340000584404000384040000178C4D20779A490004110790C47F0
++DATA2   80   30 75BED20779EA788C4110791C47F075BE9045788CD2077A3A788C4110792C
++DATA3   80   60 47F075BED2077A9F788C411040404040F0F0F3F0
++DATA1   80    0 02E3E7E3400005BC4040002A40400001793C58F0787858E0F03C50E0794C
++DATA2   80   30 58D0F0B8D20FD00CF07C50D0F0C841D0F0C458F0796405EF47F075424040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F1
++DATA1   80    0 02E3E7E3400005E84040000B4040000147F0F00C06C6E6D9D5D37B404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F3F2
++DATA1   80    0 02E3E7E3400005F4404000384040000190EDF250187F58A0E00458F07290
++DATA2   80   30 95FFF07C478070285820F06C07F2D23FF07C72505820F0C44130000805D2
++DATA3   80   60 50E07250050100FF47F0716C40404040F0F0F3F3
++DATA1   80    0 02E3E7E34000062C4040003840400001D2012000730041D00007183A9540
++DATA2   80   30 3000477070604130300146D0705044D072F04120D0054560718841A0A008
++DATA3   80   60 D503A00072FC4780707AD20040404040F0F0F3F4
++DATA1   80    0 02E3E7E34000066440400038404000017110A00DDC00711073051B554350
++DATA2   80   30 A00D8B5000014145723AD201711140008B50000258107298581510045010
++DATA3   80   60 72C041C00001456071C041D040404040F0F0F3F5
++DATA1   80    0 02E3E7E34000069C40400038404000010007183A95403000477070C84130
++DATA2   80   30 300146D070B8414D90021948474070DE902372B845607182982372B844D0
++DATA3   80   60 72F6419D9001927E9000419040404040F0F0F3F6
++DATA1   80    0 02E3E7E3400006D4404000384040000190011B44434071111A4919484740
++DATA2   80   30 7108502072D045607182582072D0581072C018390501000000001B444340
++DATA3   80   60 71111A94414090011948472040404040F0F0F3F7
++DATA1   80    0 02E3E7E34000070C4040003840400001712C926B900018941A2B46C070EE
++DATA2   80   30 456071A6D503A00072FC4770707A0690956B90004770714E924090005990
++DATA3   80   60 72B447C0715A45607182D20440404040F0F0F3F8
++DATA1   80    0 02E3E7E34000074440400038404000012000730041200005581072940501
++DATA2   80   30 020358F072901B221B339023F10C92FFF07C98ED725007FE18295B2072B4
++DATA3   80   60 581072940501020347F0716C40404040F0F0F3F9
++DATA1   80    0 02E3E7E34000077C4040003840400001502072B441832000924020004190
++DATA2   80   30 200107F605101B4491FFA00C478010124340A00E8B40000241A4A01007F6
++DATA3   80   60 0510D202110BA0095820110A40404040F0F0F4F0
++DATA1   80    0 02E3E7E3400007B440400038404000011BBB50B01106D2001109A00DDC00
++DATA2   80   30 1109114391FFA00C078691FFA010478010421B445850A01043B0A00F5450
++DATA3   80   60 1116505011061D4B18C507F640404040F0F0F4F1
++DATA1   80    0 02E3E7E3400007EC40400036404000014130A01058C030005850C00043B0
++DATA2   80   30 A00E47F010624130300458C030005C40C00046B0105618454C4011085040
++DATA3   80   60 110643B0A00F47F0103E404040404040F0F0F4F2
++DATA1   80    0 02E3E7E34000082240400016404000010F080F080107010706070B071710
++DATA2   80   30 0F0831102108040740404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F3
++DATA1   80    0 02E3E7E34000087840400014404000010000000000000000000000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F4
++DATA1   80    0 02E3E7E3400008944040000340400001C5D5C44040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F4F5
++DATA1   80    0 02E3E7E3400008BC40400038404000010000000000FFFFFF0008D2002000
++DATA2   80   30 9000D20020003000D20030002000D20020023000D2009000300000000000
++DATA3   80   60 4050C5D5C40404010402040840404040F0F0F4F6
++DATA1   80    0 02E3E7E3400008F440400038404000010410080400000707070700000000
++DATA2   80   30 070000000000000000000000096800000950000009548000094C000009B0
++DATA3   80   60 00000950000009588000094C40404040F0F0F4F7
++DATA1   80    0 02E3E7E34000092C4040003840400001000009F4000009500000095C8000
++DATA2   80   30 094C00000A4400000950000009608000094C0000000000000000000000DD
++DATA3   80   60 000000DE000000DF000000E040404040F0F0F4F8
++DATA1   80    0 02E3E7E34000096440400038404000010000000000000043C9C8C3F2F2F1
++DATA2   80   30 C940D5C1D4C5D3406040D5C1D4C540D3C1D9C7C5D940E3C8C1D540C5C9C7
++DATA3   80   60 C8E340C3C8C1D9C1C3E3C5D940404040F0F0F4F9
++DATA1   80    0 02E3E7E34000099C4040003840400001E24B40D5C1D4C57E404040404040
++DATA2   80   30 40404B4B4B000000003EC9C8C3F2F2F2C940D5C1D4C5D3406040D5C1D4C5
++DATA3   80   60 40D5D6E340C9D540D5C1D4C540404040F0F0F5F0
++DATA1   80    0 02E3E7E3400009D44040003840400001D3C9E2E340C4C9C3E3C9D6D5C1D9
++DATA2   80   30 E84B40D5C1D4C57E404040404040404000000000004AC9C8C3F2F2F3C940
++DATA3   80   60 D5C1D4C5D3406040C5D5C44040404040F0F0F5F1
++DATA1   80    0 02E3E7E340000A0C4040003840400001D6C640D9C5C3D6D9C440C5D5C3D6
++DATA2   80   30 E4D5E3C5D9C5C440C2C5C6D6D9C540C5D8E4C1D340E2C9C7D54B40D5C1D4
++DATA3   80   60 C57E4040404040404040000040404040F0F0F5F2
++DATA1   80    0 02E3E7E340000A4440400038404000010000005FC9C8C3F2F2F4C940D5C1
++DATA2   80   30 D4C5D3406040E2E4C2E2C3D9C9D7E340C6D6D940D5D6D560C4C9D4C5D5E2
++DATA3   80   60 C9D6D5C5C440E5C1D9C9C1C240404040F0F0F5F3
++DATA1   80    0 02E3E7E340000A7C4040002B40400001D3C540D6D940E2E4C2E2C3D9C9D7
++DATA2   80   30 E340D6E4E340D6C640D9C1D5C7C54B40D5C1D4C57E404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F5F4
++DATA1   80    0 02D9D3C4404040404040003840404040000100010D00090C0D0009100D00
++DATA2   80   30 0914090009190D00091C0D0009200D000924090009290D00092C0D000930
++DATA3   80   60 0D000934090009390C00093C40404040F0F0F5F5
++DATA1   80    0 02D9D3C4404040404040003040404040000100010D0009400D0009440800
++DATA2   80   30 0949000200010C000878000300010C000880000400010C00087C00050001
++DATA3   80   60 1C000964404040404040404040404040F0F0F5F6
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F5F7
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSASCN EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E2C1E2C3D5000000004000
++DATA2   80   30 01DFE2D8D9E3404040400200000040404040C9C2C3D6D47B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C9C8C3C5D9D9D440020000004040
++DATA2   80   30 4040C1D9E2C9D54040400100001640000001C1D9C3D6E240404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C1D9C3D6E290E4D00C
++DATA2   80   30 9200F0C145F0F02847F0F00A05C1D9E2C9D590E4D00C92F0F0AB184F5821
++DATA3   80   60 00007862000030069210409740404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000017900418247C04066928040973100
++DATA2   80   30 4110410E7A00417A47804092183D41D0411250D3000850304116474040BC
++DATA3   80   60 34603A007000415A58F040FA40404040F0F0F0F4
++DATA1   80    0 02E3E7E340000070404000384040000105EF4700000618D347F040707900
++DATA2   80   30 418647C040923C66784041763A46782041723D247A20416E3A267C60416A
++DATA3   80   60 3D626820416238203C062A0240404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040003840400001918040AB471040A031006A004162
++DATA2   80   30 91802000478040B2310047F040B27A00417E98E4D00C92FFD00C07FE7060
++DATA3   80   60 418A98EF40F24120418A413040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E0404000384040000141B54400F0560501040E07004110
++DATA2   80   30 40FE18FE05EF58DD000495004191477040183B0047F040B2000000000000
++DATA3   80   60 0000000000000000000001AC40404040F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040001040400001000001A4000001A8800001A08000
++DATA2   80   30 017040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E3400001784040002840400001411921FB5FFFFFFFC08143C7C13B
++DATA2   80   30 446AC11406BFC11DB03441100000413243F7408000003E10000040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E3400001A84040002340400001000001010000002FC9C8C3F2F5F7
++DATA2   80   30 C940C1D9E2C9D560C1D9C3D6E24061C1D9C7617E61404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001D940400006404000016140C7E340F14040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02D9D3C4404040404040003040404040000100010D0001140D0001180D00
++DATA2   80   30 011C0900012108000125000200010C000110000300010C00010C00040001
++DATA3   80   60 1C000108404040404040404040404040F0F0F1F2
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSATAN EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040002040400001C9C8C3E2C1E3C1D5000000004000
++DATA2   80   30 00BCC1E3C1D5404040400100000040000001404040404040404040404040
++DATA3   80   60 404040404040404040404040E2C1E3D5F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C1E3C1D50090EFD00C
++DATA2   80   30 58110000780100005801000030007840F0981B11390447C0F03238243D20
++DATA3   80   60 3802411000087900F0A447C0E2C1E3D5F0F0F0F2
++DATA1   80    0 02E3E7E3400000384040003840400001F0727900F0A847C0F05638207C00
++DATA2   80   30 F0A03B043A027A20F09C3D024111000438403C0038207C00F0907A20F088
++DATA3   80   60 7860F08C3D623A067A00F094E2C1E3D5F0F0F0F3
++DATA1   80    0 02E3E7E34000007040400016404000013C047A01F0AC3000120047A0F080
++DATA2   80   30 310092FFD00C07FE40404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2C1E3D5F0F0F0F4
++DATA1   80    0 02E3E7E340000088404000344040000141168A5E408F239CBFD35F49409A
++DATA2   80   30 652441100000411BB67B40BB67AF3E100000404498510000000040860A92
++DATA3   80   60 C11921FBC110C15240404040E2C1E3D5F0F0F0F5
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2C1E3D5F0F0F0F6
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSATN2 EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E2C1E3D5F2000000004000
++DATA2   80   30 01CBC9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040E2C1E3F2F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040002040404040C1E3C1D540404040010000144000
++DATA2   80   30 0001C1E3C1D5F24040400100000040000001404040404040404040404040
++DATA3   80   60 404040404040404040404040E2C1E3F2F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C1E3C1D5F290E0D00C
++DATA2   80   30 180145F0F02447F0F00A04C1E3C1D54090E0D00C1B0058E10000780E0000
++DATA3   80   60 7000F170300012004780F072E2C1E3F2F0F0F0F3
++DATA1   80    0 02E3E7E340000038404000384040000158E10004786E000030264780F062
++DATA2   80   30 7000F1745800F1747020F1745B00F1745900F1404720F0685900F144580E
++DATA3   80   60 000047A0F07012004720F070E2C1E3F2F0F0F0F4
++DATA1   80    0 02E3E7E34000007040400038404000013B0047F0F0D432004780F0EE7800
++DATA2   80   30 F16847F0F0D83D027840F1481B11390447C0F08838243D20380241100008
++DATA3   80   60 7900F15847C0F0C87900F15CE2C1E3F2F0F0F0F5
++DATA1   80    0 02E3E7E3400000A8404000384040000147C0F0AC38207C00F1543B043A02
++DATA2   80   30 7A20F1503D024111000438403C0038207C00F1387A20F1307860F1343D62
++DATA3   80   60 3A067A00F13C3C047A01F160E2C1E3F2F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000013000120047A0F0DA7B00F14C3000
++DATA2   80   30 9180F1704780F0E4330058ED000C92FFD00C07FE7060F174501D0018181D
++DATA3   80   60 58E0F12C41DE00C4501D0004E2C1E3F2F0F0F0F7
++DATA1   80    0 02E3E7E340000118404000384040000150D100084110F17C180F58F0F178
++DATA2   80   30 05EF58DD000418F09500F1934780F0E44110F18847F0F010000000000000
++DATA3   80   60 41168A5E408F239CBFD35F49E2C1E3F2F0F0F0F8
++DATA1   80    0 02E3E7E3400001504040003440400001409A652406000000FA0000004110
++DATA2   80   30 0000413243F7411BB67B40BB67AF3E100000404498510000000040860A92
++DATA3   80   60 C11921FBC110C15240404040E2C1E3F2F0F0F0F9
++DATA1   80    0 02E3E7E34000018C404000184040000100000000000001AC000001A40000
++DATA2   80   30 01A800000184800001884040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2C1E3F2F0F0F1F0
++DATA1   80    0 02E3E7E3400001A84040002340400001000000FF0000001BC9C8C3F2F5F5
++DATA2   80   30 C940C1E3C1D5F240C1D9C7E4D4C5D5E3E27EF04BF0404040404040404040
++DATA3   80   60 404040404040404040404040E2C1E3F2F0F0F1F1
++DATA1   80    0 02D9D3C4404040404040002840404040000100010D0001900D0001940D00
++DATA2   80   30 01980D00019C080001A1000200010C000140000300011C00018C40404040
++DATA3   80   60 404040404040404040404040E2C1E3F2F0F0F1F2
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2C1E3F2F0F0F1F3
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSERF  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E2C5D9C640000000004000
++DATA2   80   30 01ECC5D9C640404040400100001640000001C5D9C6C34040404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040400002C5E7D74040404040020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C5D9C6C30090E5D00C
++DATA2   80   30 9200F0A945F0F02647F0F00803C5D9C690E5D00C92F0F093582100007822
++DATA3   80   60 000030427940F16A47A0F09A40404040F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000019835F1527940F15E4720F07C7800
++DATA2   80   30 F18E7940F1664740F04A3C227800F17A3C027A03F17E8734F0403C043A04
++DATA3   80   60 9180F0934710F05C7B00F15E40404040F0F0F0F4
++DATA1   80    0 02E3E7E34000007040400038404000013000918020004780F0729180F093
++DATA2   80   30 4710F0707B00F162330098E5D00C92FFD00C07FE415500107B40F1767800
++DATA3   80   60 F1923C047A03F1968734F08840404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A840400038404000014700F05647F0F05C7940F16E4740
++DATA2   80   30 F0C47800F1D29180F0934710F056918020004710F06C7940F1724740F0C4
++DATA3   80   60 3C0047F0F0723C2238027A0040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E04040003840400001F1CA3C027A00F1CE3C027860F1BE
++DATA2   80   30 3C627A60F1C23C627A60F1C63D607A60F1BA3D6431227020F1464110F14A
++DATA3   80   60 184D41D0F11A50D40008504040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040001840400001F11E183F58F0F14E05EF47000008
++DATA2   80   30 18F318D43C0647F0F0924040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000016040400038404000018000015C00000000000000000000
++DATA2   80   30 00040000001041100000412000003E1000004120A5B1413EB51141D4E560
++DATA3   80   60 411B5A00BE24E7F93F14246E40404040F0F0F0F9
++DATA1   80    0 02E3E7E3400001984040003840400001BF6D68D9401CE094C060499F4020
++DATA2   80   30 DD76BE62A77FBE1C8AA93F19EDC1BF2BBD79BF115D253FC98CEFC01919EA
++DATA3   80   60 401A925FBFF8B3773F3FFFFC40404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001D04040001C4040000140906EB9C0483677C0F64C7FC024
++DATA2   80   30 F1AA414E86B6414312760110000040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02D9D3C44040404040400010404040400001000108000161000200010C00
++DATA2   80   30 016440404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSEXP  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E2C5E7D740000000004000
++DATA2   80   30 0192C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040E2C5E7D7F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040404040C5E7D74040404040010000004000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2C5E7D7F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00803C5E7D790E5D00C5821
++DATA2   80   30 00002B00780200007900F1244720F0BC7900F12847C0F0B26C00F1406E00
++DATA3   80   60 F1386000F1309823F13047C0E2C5E7D7F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001F0425720F10C5730F10C41E20FC0
++DATA2   80   30 89E000181B228D2000028830000418131C0118505C40F1185A00F1101850
++DATA3   80   60 5800F1141D051B1388100001E2C5E7D7F0F0F0F4
++DATA1   80    0 02E3E7E34000007040400038404000015A10F11C1A141843884000021D41
++DATA2   80   30 8A5000055A50F120885020005B50F10C5950F120885000014740F09E5850
++DATA3   80   60 F12C1B5E5050F1307800F130E2C5E7D7F0F0F0F5
++DATA1   80    0 02E3E7E3400000A8404000384040000198E5D00C92FFD00C07FE7800F12C
++DATA2   80   30 3C0047F0F0A87000F1304120F1304130F178185F181D98EFF10441DF00C4
++DATA3   80   60 50D10008501D0004440F0056E2C5E7D7F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000010501040E07004110514818FE05EF
++DATA2   80   30 18F558DD00049500F1634770F0107800F15847F0F0A80000000000000000
++DATA3   80   60 FFFFFFFF576AE119269F8E6BE2C5E7D7F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040001840400001B9059003B05CFCE30200000042AE
++DATA2   80   30 AC4FC2B437E0011000004040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2C5E7D7F0F0F0F8
++DATA1   80    0 02E3E7E34000013840400028404000014700000000000000415C551D94AE
++DATA2   80   30 0BF800000164000001600000015C800001307FFFFFFF000000FC40404040
++DATA3   80   60 404040404040404040404040E2C5E7D7F0F0F0F9
++DATA1   80    0 02E3E7E34000016440400014404000010000002AC9C8C3F2F5F2C940C5E7
++DATA2   80   30 D740C1D9C77E404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2C5E7D7F0F0F1F0
++DATA1   80    0 02E3E7E3400001864040000C404000016B40C7E340F1F7F44BF6F7F34040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2C5E7D7F0F0F1F1
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D0001480D00014C0D00
++DATA2   80   30 015008000155000200010C000108000300011C0001044040404040404040
++DATA3   80   60 404040404040404040404040E2C5E7D7F0F0F1F2
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2C5E7D7F0F0F1F3
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSGAMA EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E2C7C1D4C1000000004000
++DATA2   80   30 031DC7C1D4D4C14040400100001840000001C1D3C7C1D4C1404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400002C5E7D74040404040020000004040
++DATA2   80   30 4040C1D3D6C7404040400200000040404040C9C2C3D6D47B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F2
++DATA1   80    0 02C5E2C4404040404040001040400005C9C8C3C5D9D9D440020000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F3
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C1D3C7C1D4C10090E3
++DATA2   80   30 D00C9200F0EF45F0F02A47F0F00A05C7C1D4D4C190E3D00C92F0F0D7182F
++DATA3   80   60 18ED50D0219441D0219050DE40404040F0F0F0F4
++DATA1   80    0 02E3E7E340000038404000384040000100085831000058F021D878230000
++DATA2   80   30 792021E847202050918020D74710213A322247C0214205EF4700000A3300
++DATA3   80   60 47F020E8792021EC47C0206840404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000704040003840400001918020D74710213A792021F04720
++DATA2   80   30 21427920220447A020F6792021F847402092923C20D4784021F879202200
++DATA3   80   60 47C020A07B2021F83C4247F040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000A840400038404000012080923D20D438427B2021F447F0
++DATA2   80   30 20A47B2021FC38627A6022283C627A6022243C627A6022207800221C3C02
++DATA3   80   60 7A0022183C027A0022143C0240404040F0F0F0F7
++DATA1   80    0 02E3E7E3400000E040400038404000017A0022103D063C027A00220C3C04
++DATA2   80   30 47F020E8700021E44110224C05EF4700000C58D0219498E3D00C92FFD00C
++DATA3   80   60 07FE05EF4700000E7823000040404040F0F0F0F8
++DATA1   80    0 02E3E7E3400001184040003840400001784022303D427A40222C3D427A40
++DATA2   80   30 220834603B467B0021F83C022A04918020D7478020E8700021E44110224C
++DATA3   80   60 58F021DC05EF4700001047F040404040F0F0F0F9
++DATA1   80    0 02E3E7E340000150404000384040000120E84110224047F02146411022A4
++DATA2   80   30 702021E44131002B58F021E09012D00C412021E4440F00560501040E0700
++DATA3   80   60 41330013440F004E0501040840404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001884040001E404000019812D00C58F0223805EF4110224C
++DATA2   80   30 9500223F477020227800223447F020E84040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001F04040000C404000010000000000000000000000004040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02E3E7E3400002004040003840400001021000004239930D7E184D304080
++DATA2   80   30 00004110000041180000412000004180000040EB3FBE40E2DFC5C139FD1F
++DATA3   80   60 C23009F0C172FD6DC129CFAD40404040F0F0F1F3
++DATA1   80    0 02E3E7E3400002384040001C40400001C2701316C22FE5CA421452AA4015
++DATA2   80   30 56F6BE2340707FFFFFFF0000000040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F4
++DATA1   80    0 02E3E7E3400002584040002B404000010000026C00000254000002688000
++DATA2   80   30 01FC0000012200000049C9C8C3F2F9F0C940C7C1D4D4C14040C1D9C77E40
++DATA3   80   60 40404040404040404040404040404040F0F0F1F5
++DATA1   80    0 02E3E7E34000029140400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F6
++DATA1   80    0 02E3E7E34000029E40400038404000015D6B40D3C540F25C5C60F2F5F240
++DATA2   80   30 D6D940C7C540F5F74BF5F7F4F4000000000002D000000254000002CC8000
++DATA3   80   60 01FC0000012300000049C9C840404040F0F0F1F7
++DATA1   80    0 02E3E7E3400002D64040001140400001C3F2F9F1C940C1D3C7C1D4C140C1
++DATA2   80   30 D9C77E404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F8
++DATA1   80    0 02E3E7E3400002F540400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F9
++DATA1   80    0 02E3E7E3400003024040001B404000015D6BD3C540F04B40D6D940C7C540
++DATA2   80   30 F44BF2F9F3F75CF1F05C5CF7F34040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F0
++DATA1   80    0 02D9D3C4404040404040003440404040000100010D0002580D00025C0D00
++DATA2   80   30 0260090002650D0002BC0D0002C00D0002C4080002C9000200010C0001F4
++DATA3   80   60 000300010C0001F04040404040404040F0F0F2F1
++DATA1   80    0 02D9D3C4404040404040001040404040000400010C0001F8000500011C00
++DATA2   80   30 025040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F2
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F2F3
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSLOG  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E2D3D6C740000000004000
++DATA2   80   30 01B6C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040E2D3D6C7F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040002040404040C1D3D6C740404040010000184000
++DATA2   80   30 0001C1D3D6C7F1F040400100000040000001404040404040404040404040
++DATA3   80   60 404040404040404040404040E2D3D6C7F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06C1D3D6C7F1F04090E0
++DATA2   80   30 D00C927CF0AE45F0F02A47F0F00A04C1D3D6C74090E0D00C9291F09658E1
++DATA3   80   60 0000580E000012E047C0F0A4E2D3D6C7F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000018C000018890000024000F1228810
++DATA2   80   30 001D4311F14089E0100050E0F1489240F1481BEE7800F1487900F1284720
++DATA3   80   60 F05641E00004411100016820E2D3D6C7F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001F12034407B0EF1344770F0662B22
++DATA2   80   30 7A4EF1383D0438203C007840F1183B407C00F1143D043C022A207800F120
++DATA3   80   60 411101004010F1227B00F120E2D3D6C7F0F0F0F5
++DATA1   80    0 02E3E7E3400000A840400038404000017C00F12C2A027C00F13058ED000C
++DATA2   80   30 92FFD00C07FE5000F148501D001818EF58F0F110181D41DF00C450D10008
++DATA3   80   60 501D00049023D0144120E148E2D3D6C7F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000014130E188440F00560501040E0700
++DATA2   80   30 180E4110E15058F0E14C9823D01405EF18F058DD000441E0F1489500F163
++DATA3   80   60 4770F016947FF1485800F148E2D3D6C7F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040001C4040000112004770F0167800F16847F0F09A
++DATA2   80   30 000000000000408D8BC7416A298C40404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2D3D6C7F0F0F0F8
++DATA1   80    0 02E3E7E340000138404000284040000146000000F000000040B504F340B1
++DATA2   80   30 7219406F2DED411000004080000040400000030201010000000040404040
++DATA3   80   60 404040404040404040404040E2D3D6C7F0F0F0F9
++DATA1   80    0 02E3E7E34000016440400014404000010000000000000184000001780000
++DATA2   80   30 017C80000160404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2D3D6C7F0F0F1F0
++DATA1   80    0 02E3E7E34000017C4040002440400001000000FDFFFFFFFF0000002EC9C8
++DATA2   80   30 C3F2F5F3C940C1D3D6C760C1D3D6C7F1F040C1D9C77E4040404040404040
++DATA3   80   60 404040404040404040404040E2D3D6C7F0F0F1F1
++DATA1   80    0 02E3E7E3400001AE404000084040000140D3C540E9C5D9D6404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2D3D6C7F0F0F1F2
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D0001680D00016C0D00
++DATA2   80   30 017008000175000200010C000128000300011C0001644040404040404040
++DATA3   80   60 404040404040404040404040E2D3D6C7F0F0F1F3
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2D3D6C7F0F0F1F4
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSSCN  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E2E2C3D540000000004000
++DATA2   80   30 01D9C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040E2E2C3D5F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040002040404040C3D6E24040404040010000004000
++DATA2   80   30 0001E2C9D540404040400100001840000001404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E2C3D5F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00803C3D6E290EFD00C9202
++DATA2   80   30 F15B58E1000045F0F03847F0F00803E2C9D590EFD00C58E100009200F143
++DATA3   80   60 9180E0004780F0209204F143E2E2C3D5F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000016840F1386820F1402802780E0000
++DATA2   80   30 30007900F15447A0F0A06C00F14839044740F0482E0238202B027020F114
++DATA3   80   60 9101F1174780F0582B043000E2E2C3D5F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001411000049103F1174740F0681B11
++DATA2   80   30 38407900F1504720F0723B003C0038207C01F11C7A01F1243C027A01F12C
++DATA3   80   60 3C027A01F1343C049104F117E2E2C3D5F0F0F0F5
++DATA1   80    0 02E3E7E3400000A840400038404000014780F096310058ED000C92FFD00C
++DATA2   80   30 07FED203F174E0009001D01418EF181D58F0F11841DF00C4501D000450D1
++DATA3   80   60 00089023D0144120E1744130E2E2C3D5F0F0F0F6
++DATA1   80    0 02E3E7E3400000E04040003840400001E1974400F0560501040E07004130
++DATA2   80   30 E1AA4400F04E050104084110E16058F0E15C180E9823D01405EF18F041E0
++DATA3   80   60 F17458DD00047800F1589500E2E2C3D5F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040001240400001F1734780F0969102F1434780F010
++DATA2   80   30 47F0F0204040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E2C3D5F0F0F0F8
++DATA1   80    0 02E3E7E340000130404000384040000100000000BD25B368BE14F17D3EA3
++DATA2   80   30 2F623F40ED0FC014ABBCC04EF4EE40C90FDB411000000000000046000000
++DATA3   80   60 0000000041145F306DC9C883E2E2C3D5F0F0F0F9
++DATA1   80    0 02E3E7E34000016840400020404000013E10000045C90FDA40B504F30000
++DATA2   80   30 00000000019400000188000001908000018C404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E2C3D5F0F0F1F0
++DATA1   80    0 02E3E7E3400001904040001F40400001000000FE00000041C9C8C3F2F5F4
++DATA2   80   30 C940E2C9D560C3D6E24061C1D9C7617E6140404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E2C3D5F0F0F1F1
++DATA1   80    0 02E3E7E3400001BD40400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E2C3D5F0F0F1F2
++DATA1   80    0 02E3E7E3400001CA4040000F404000015D616B40C7C540D7C95CF25C5CF1
++DATA2   80   30 F84040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E2C3D5F0F0F1F3
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D0001780D00017C0D00
++DATA2   80   30 018008000185000200010C000130000300011C0001744040404040404040
++DATA3   80   60 404040404040404040404040E2E2C3D5F0F0F1F4
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E2C3D5F0F0F1F5
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSSCNH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E2E2C3D5C8000000004000
++DATA2   80   30 01D8C5E7D740404040400200000040404040C9C2C3D6D47B404002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040400004C9C8C3C5D9D9D440020000004040
++DATA2   80   30 4040E2C9D5C8404040400100001640000001C3D6E2C84040404001000000
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04C3D6E2C80090E2D00C
++DATA2   80   30 923AF0A045F0F02847F0F00A04E2C9D5C80090E2D00C923BF08A182F58E1
++DATA3   80   60 0000784E000030049101208A40404040F0F0F0F3
++DATA1   80    0 02E3E7E3400000384040003840400001478020527900215A47A020547900
++DATA2   80   30 2176474020983C0038207C0021767A0021723C027A00216E3C023C043A04
++DATA3   80   60 47F020A03044181D41D0210A40404040F0F0F0F4
++DATA1   80    0 02E3E7E340000070404000384040000150D100085010210E790021564720
++DATA2   80   30 20AA7A002166700021524110210658F020F605EF4700000458D0210E7820
++DATA3   80   60 21623D203A0268202162382040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A840400038404000017C00216A2A02324447A020A03100
++DATA2   80   30 98E2D00C92FFD00C07FED2032152E0009023D00C58F020F2413021A74120
++DATA3   80   60 2152440F00560501040E070040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000019823D00C58F0217E411020FA05EF
++DATA2   80   30 7800218658DD00049500217D478020A041E0215247F02018000000000000
++DATA3   80   60 00000000000001A00000019040404040F0F0F0F7
++DATA1   80    0 02E3E7E34000011840400008404000010000019880000168404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000016C404000084040000142AF5DC041100000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E3400001784040001840400001403FDF95C0B1B3003E40F043402A
++DATA2   80   30 AAB83F221E8C3DD5D8B34040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02E3E7E340000194404000294040000100000000000001007FFFFFFF0000
++DATA2   80   30 0034C9C8C3F2F5F6C940E2C9D5C860C3D6E2C84061C1D9C7617E61404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001CB4040000D40400001616B40C7C540F1F7F54BF3F6F640
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02D9D3C4404040404040002C40404040000100010D0001100D0001140D00
++DATA2   80   30 01180800011D000200010C00010C000300010C000108000400011C000194
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F4
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSSQRT EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E2E2D8D9E3000000004000
++DATA2   80   30 0145C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 404040404040404040404040E2E2D8D9F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040001040404040E2D8D9E340404040010000004000
++DATA2   80   30 000140404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E2D8D9F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04E2D8D9E30090EFD00C
++DATA2   80   30 58E10000780E000032204740F0744780F06A580E00008C00001989000018
++DATA3   80   60 8A10000347B0F0385A00F0D4E2E2D8D9F0F0F0F3
++DATA1   80    0 02E3E7E340000038404000384040000118E05A1EF0E8580EF0E01D015A1E
++DATA2   80   30 F0D81E1E5010F0F4D200F0F0F0F47D00F0F47E00F0F434003D207E00F0F0
++DATA3   80   60 3B0234003A0258ED000C92FFE2E2D8D9F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001D00C07FE7000F0F49001D014181D
++DATA2   80   30 18EF58F0F0D041DF00C450D10008501D00049023D0144120E0F44130E137
++DATA3   80   60 440F00560501040E07009823E2E2D8D9F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040003840400001D0144110E0FC180E58F0E0F805EF
++DATA2   80   30 18F058DD00049500F1134770F0C89780F0F441E0F0F447F0F01200000000
++DATA3   80   60 0100000421AE7D00206B9F3CE2E2D8D9F0F0F0F6
++DATA1   80    0 02E3E7E3400000E04040001440400001FFEB605EFFFAD8180D73F1851D73
++DATA2   80   30 F18500000001404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E2D8D9F0F0F0F7
++DATA1   80    0 02E3E7E3400000F840400018404000010000000000000114000001100000
++DATA2   80   30 010C800000F4000000FB4040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E2D8D9F0F0F0F8
++DATA1   80    0 02E3E7E34000011440400023404000010000002DC9C8C3F2F5F1C940E2D8
++DATA2   80   30 D9E340D5C5C7C1E3C9E5C540C1D9C7E4D4C5D5E37E404040404040404040
++DATA3   80   60 404040404040404040404040E2E2D8D9F0F0F0F9
++DATA1   80    0 02D9D3C4404040404040002440404040000100010D0000FC0D0001000D00
++DATA2   80   30 010408000109000200010C0000D0000300011C0000F84040404040404040
++DATA3   80   60 404040404040404040404040E2E2D8D9F0F0F1F0
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E2D8D9F0F0F1F1
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSTAE  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040001040400001C9C8C3E2E3C1C540000000004000
++DATA2   80   30 019640404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000105C05030C18650D0C18A47F6C00C
++DATA2   80   30 47F0C03A47F0C01C47F0C04247F0C020587070044130C1124550C0CA4110
++DATA3   80   60 C0EA0A2358D0D00498ECD00C40404040F0F0F0F2
++DATA1   80    0 02E3E7E34000003840400038404000011BFF07FE92C2C17747F0C04692C3
++DATA2   80   30 C17758D0D0045810D018587010044130C1624550C0CA98E1D00C4100C06C
++DATA3   80   60 982CD01C41F0000407FE185F40404040F0F0F0F3
++DATA1   80    0 02E3E7E34000007040400038404000011881070045105012000000B80000
++DATA2   80   30 000041000008411100000A3C58D0511E5830511A58703008508070005810
++DATA3   80   60 80641211478050380A11411040404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000A8404000384040000150C258F0300405EF58F0300047F0
++DATA2   80   30 F04458C0F0D84900F0CC4780F01047F0C01047F0C01805908870000C4070
++DATA3   80   60 90C6412090C6584090BA58F040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000E04040000C4040000140004400F04E0501020407F54040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000EC404000384040000100408000C9C8C3F2F4F0C940E2E3
++DATA2   80   30 C1C5406040E2E8E2E3C5D440C1C2C5D5C440C3D6C4C540C9E24040404040
++DATA3   80   60 4B40C6D6D9E3D9C1D540C3D640404040F0F0F0F7
++DATA1   80    0 02E3E7E3400001244040003840400001C4C540C9E240C14B020000200000
++DATA2   80   30 013C000001808000017C0000003BC9C8C3F2F4F0C940E2E3C1C5406040E2
++DATA3   80   60 E8E2E3C5D440C1C2C5D5C44040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000015C4040002440400001C3D6C4C540C9E240404040404BC6
++DATA2   80   30 D6D9E3D9C1D540C3D6C4C540C9E240404B00000000F04040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E3400001844040000240400001000C404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02E3E7E34000019040400006404000010000000200004040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F1
++DATA1   80    0 02D9D3C4404040404040001840404040000100010D0000780D0001300D00
++DATA2   80   30 0134090001390C0001904040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSTANH EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E2E3C1D5C8000000004000
++DATA2   80   30 00F0C5E7D740404040400200000040404040E3C1D5C84040404001000000
++DATA3   80   60 400000014040404040404040E2E3D5C8F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A04E3C1D5C80090EFD00C
++DATA2   80   30 58110000786100007840F0DC30067900F0E847C0F0767900F0E047A0F070
++DATA3   80   60 7000F0EC41E0F0A450ED0008E2E3D5C8F0F0F0F2
++DATA1   80    0 02E3E7E340000038404000384040000150D0F0A818DE4110F09C58F0F0A0
++DATA2   80   30 05EF4700000258D0E06098EFD00C3C003A0438243A223D2038043B023266
++DATA3   80   60 47A0F06A310092FFD00C07FEE2E3D5C8F0F0F0F3
++DATA1   80    0 02E3E7E3400000704040002A40400001380447F0F0627900F0E447C0F062
++DATA2   80   30 3C007840F0D83A407820F0D43D247A20F0D03C023C063A0647F0F06A4040
++DATA3   80   60 404040404040404040404040E2E3D5C8F0F0F0F4
++DATA1   80    0 02E3E7E34000009C4040000840400001800000EC00000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E3D5C8F0F0F0F5
++DATA1   80    0 02E3E7E3400000D04040001C40400001BEF7EA70C0D0875641278C494110
++DATA2   80   30 000041902D0E3E10000040B3333340404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E3D5C8F0F0F0F6
++DATA1   80    0 02D9D3C4404040404040001040404040000100010800009D000200010C00
++DATA2   80   30 00A040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E3D5C8F0F0F0F7
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E2E3D5C8F0F0F0F8
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCSTNCT EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E2E3D5C3E3000000004000
++DATA2   80   30 0266C9C2C3D6D47B40400200000040404040C9C8C3C5D9D9D44002000000
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040003040404040E3C1D54040404040010000164000
++DATA2   80   30 0001C3D6E3C1D54040400100000040000001D8E3C1D54040404001000188
++DATA3   80   60 40000001404040404040404040404040F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05C3D6E3C1D590E1D00C
++DATA2   80   30 9297F08245F0F02647F0F00803E3C1D590E1D00C9291F06C6840F13A6820
++DATA3   80   60 F142280458E10000780E000040404040F0F0F0F3
++DATA1   80    0 02E3E7E340000038404000384040000130007900F15247A0F0CC6C00F14A
++DATA2   80   30 7000F16ED200F172F16E390447A0F0589102F06C4780F05E7900F1564720
++DATA3   80   60 F05E4110F1EA47F0F0D02E0240404040F0F0F0F4
++DATA1   80    0 02E3E7E340000070404000384040000138202B027020F16E9101F1714780
++DATA2   80   30 F06C2B049701F17130207920F15A4740F0883C00340038407C40F15E7A40
++DATA3   80   60 F1623C407A40F1667A00F16A40404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000A840400038404000013C029103F1714740F0A23D0447F0
++DATA2   80   30 F0AE7920F17247C0F0503D4038049102F1714780F0B833009180E0004780
++DATA3   80   60 F0C2330058ED000C92FFD00C40404040F0F0F0F6
++DATA1   80    0 02E3E7E3400000E0404000384040000107FE4110F18ED203F17AE00018ED
++DATA2   80   30 180F58F0F17641DF00C450ED000450DE00089014D00C1840413100314120
++DATA3   80   60 417A440F00560501040E070040404040F0F0F0F7
++DATA1   80    0 02E3E7E340000118404000324040000141330013440F004E0501040858F0
++DATA2   80   30 418A18049814D00C05EF18F058DD0004780100104110F19A9500F1814780
++DATA3   80   60 F0C247F0F01040404040404040404040F0F0F0F8
++DATA1   80    0 02E3E7E34000015040400034404000014110000000000000460000000000
++DATA2   80   30 000041145F306DC9C88345C90FDA02145F313B100000C028C93F415B40FD
++DATA3   80   60 C1AC5D33C1875FDC4040404040404040F0F0F0F9
++DATA1   80    0 02E3E7E34000018840400008404000010000000800000000404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02E3E7E34000019840400038404000010000010200000103000000000000
++DATA2   80   30 01B80000019400000198800001904110000000000043C9C8C3F2F5F8C940
++DATA3   80   60 E3C1D560C3D6E3C1D54061C140404040F0F0F1F1
++DATA1   80    0 02E3E7E3400001D04040000540400001D9C7617E61404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F2
++DATA1   80    0 02E3E7E3400001E340400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F3
++DATA1   80    0 02E3E7E3400001F040400038404000015D616B40C7C540D7C95CF25C5CF1
++DATA2   80   30 F80000000214000001940000019C800001907FFFFFFF0000004EC9C8C3F2
++DATA3   80   60 F5F9C940E3C1D560C3D6E3C140404040F0F0F1F4
++DATA1   80    0 02E3E7E3400002284040000940400001D54061C1D9C7617E614040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F5
++DATA1   80    0 02E3E7E34000023F40400005404000014DC8C5E77E404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F6
++DATA1   80    0 02E3E7E34000024C4040001A404000015D616B40C1D7D7D9D6C1C3C8C5E2
++DATA2   80   30 40E2C9D5C7E4D3C1D9C9E3E8404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F7
++DATA1   80    0 02D9D3C4404040404040003440404040000100010D0001A40D0001A80D00
++DATA2   80   30 01AC090001B10D0002000D0002040D0002080800020D000200010C00018C
++DATA3   80   60 000300011C0001A04040404040404040F0F0F1F8
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F9
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCTRCH  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001C9C8C3E3D9C3C840000000004000
++DATA2   80   30 02E4C9C8C3C5D9D9D4400100000040000001C9C2C3D6D47B404002000000
++DATA3   80   60 404040404040404040404040E3D9C3C8F0F0F0F1
++DATA1   80    0 02C5E2C4404040404040002040400003C1C4C3D6D57B4040020000004040
++DATA2   80   30 4040C6C9D6C3E27B40400200000040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E3D9C3C8F0F0F0F2
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00A05E3D9C1C3C590ECD00C
++DATA2   80   30 5880F2089101F21B47E0F19458B0100858B0B00050B0F2484EB0F2B0F321
++DATA3   80   60 F24FF2B696F0F25158601000E3D9C3C8F0F0F0F3
++DATA1   80    0 02E3E7E34000003840400038404000014120F2145810F210050100FF4700
++DATA2   80   30 000092F020004030F2AED501F24AF25447B0F08295D7F24B4780F08295D8
++DATA3   80   60 F24B4780F08295DAF24B4780E3D9C3C8F0F0F0F4
++DATA1   80    0 02E3E7E3400000704040003840400001F08295E7F24B47B0F0B495DDF24B
++DATA2   80   30 4740F0B418465860600019634740F0921863066006604460F2D895DAF24B
++DATA3   80   60 4770F0BA185F181441000070E3D9C3C8F0F0F0F5
++DATA1   80    0 02E3E7E3400000A84040003840400001411100000A0A18F547F0F0BAD206
++DATA2   80   30 2001F24C95F0F24B4770F0CA4170F1BA47F0F1EE4570F1EED24E2001F258
++DATA3   80   60 4570F1EE589D000441A00004E3D9C3C8F0F0F0F6
++DATA1   80    0 02E3E7E3400000E040400038404000011BBB5859001019584780F1D41A5A
++DATA2   80   30 950050004780F10C436500009508500047D0F1064160000806604460F2DE
++DATA3   80   60 5859000CD5015000F2AC4770E3D9C3C8F0F0F0F7
++DATA1   80    0 02E3E7E3400001184040003840400001F12C486500024E60F2B0F332201F
++DATA2   80   30 F2B596F020224150202541C0000418354120900C4570F1E01A9A4150500B
++DATA3   80   60 46C0F1344B90F2564570F1EEE3D9C3C8F0F0F0F8
++DATA1   80    0 02E3E7E3400001504040003840400001D503901080C04780F17A4150002C
++DATA2   80   30 875AF1701BCC86CAF1C6599CF2144770F164D2132016F2B84570F1EED20B
++DATA3   80   60 2001F2CC4132000D412800C0E3D9C3C8F0F0F0F9
++DATA1   80    0 02E3E7E34000018840400038404000014570F1E04570F1EE9601F21B92FF
++DATA2   80   30 807C95DAF24B4770F1BA582081104120200012224780F1BA18E2980D8084
++DATA3   80   60 58E0E00007FE18F8980CD014E3D9C3C8F0F0F1F0
++DATA1   80    0 02E3E7E3400001C0404000384040000145E0F0440010509BF21858909004
++DATA2   80   30 18BC47F0F0E2416000054150F2A647F0F1065810F20C5811005C0501040A
++DATA3   80   60 07F74820F2AE5810F2100501E3D9C3C8F0F0F1F1
++DATA1   80    0 02E3E7E3400001F8404000384040000102004700000092F020004030F2AE
++DATA2   80   30 07F700000000000000000000000004000000000000010000000000000000
++DATA3   80   60 000000000000000000000000E3D9C3C8F0F0F1F2
++DATA1   80    0 02E3E7E34000023040400018404000010000000000000000000000000000
++DATA2   80   30 000000000000000000004040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E3D9C3C8F0F0F1F3
++DATA1   80    0 02E3E7E34000024C4040003840400001C9C8C3404040C90000F00010E3D9
++DATA2   80   30 C1C3C5C2C1C3D24040D9D6E4E3C9D5C54040C3C1D3D3C5C440C6D9D6D440
++DATA3   80   60 C9E2D5404040D9C5C74B4040E3D9C3C8F0F0F1F4
++DATA1   80    0 02E3E7E3400002844040002C40400001F1F4404040D9C5C74B4040F1F540
++DATA2   80   30 4040D9C5C74B404040F0404040D9C5C74B404040F1C9C2C3D6D447000000
++DATA3   80   60 404040404040404040404040E3D9C3C8F0F0F1F5
++DATA1   80    0 02E3E7E3400002B040400034404000010000000000000000E3D9C1C3C5C2
++DATA2   80   30 C1C3D240E3C5D9D4C9D5C1E3C5C4C5D5E3D9E840D7D6C9D5E37ED2002001
++DATA3   80   60 4004D200200C500140404040E3D9C3C8F0F0F1F6
++DATA1   80    0 02D9D3C4404040404040001840404040000200011C000208000300011C00
++DATA2   80   30 020C000400011C0002104040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E3D9C3C8F0F0F1F7
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 404040404040404040404040E3D9C3C8F0F0F1F8
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCUATBL EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040001040400001C9C8C3E4C1E3C2D3000000004000
++DATA2   80   30 01E840404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E3400000004040003840400001000001E006050607000000017000
++DATA2   80   30 0320C0018000000000010000000170000320C00180000000000100000001
++DATA3   80   60 70000320C00180000000000140404040F0F0F0F2
++DATA1   80    0 02E3E7E34000003840400038404000010000000170000320C00180000000
++DATA2   80   30 0001000000017000005080010050000000010000000170000085C4018000
++DATA3   80   60 00000001000000017000005040404040F0F0F0F3
++DATA1   80    0 02E3E7E34000007040400038404000018001005000000001000000017000
++DATA2   80   30 0320C0018000000000010000000170000320C00180000000000100000001
++DATA3   80   60 70000320C00180000000000140404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000A840400038404000010000000170000320C00180000000
++DATA2   80   30 00010000000170000320C0018000000000010000000170000320C0018000
++DATA3   80   60 00000001000000017000032040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000E04040003840400001C001800000000001000000017000
++DATA2   80   30 0320C0018000000000010000000170000320C00180000000000100000001
++DATA3   80   60 70000320C00180000000000140404040F0F0F0F6
++DATA1   80    0 02E3E7E34000011840400038404000010000000170000320C00180000000
++DATA2   80   30 00010000000170000320C0018000000000010000000170000320C0018000
++DATA3   80   60 00000001000000017000032040404040F0F0F0F7
++DATA1   80    0 02E3E7E3400001504040003840400001C001800000000001000000017000
++DATA2   80   30 0320C0018000000000010000000170000320C00180000000000100000001
++DATA3   80   60 70000320C00180000000000140404040F0F0F0F8
++DATA1   80    0 02E3E7E34000018840400038404000010000000170000320C00180000000
++DATA2   80   30 00010000000170000320C0018000000000010000000170000320C0018000
++DATA3   80   60 00000001000000017000032040404040F0F0F0F9
++DATA1   80    0 02E3E7E3400001C04040002840400001C001800000000001000000017000
++DATA2   80   30 0320C0018000000000010000000170000320C00180000000000140404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F0
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F1F5D6C3E3F7F040F1F04BF5F64040F561F3F061
++DATA3   80   60 F7F34040404040404040404040404040F0F0F1F1
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB IHCUOPT  EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040001040400001C9C8C3E4D6D7E340000000004000
++DATA2   80   30 030040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E34000000040400038404000010000005F40000000010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000101010042
++DATA3   80   60 00000001010100520000000140404040F0F0F0F2
++DATA1   80    0 02E3E7E34000003840400038404000010101004200000001010100420000
++DATA2   80   30 000101010052000000010101004200000001010100420000000101010052
++DATA3   80   60 00000001010100420000000140404040F0F0F0F3
++DATA1   80    0 02E3E7E34000007040400038404000010101004200000001010100520000
++DATA2   80   30 000101010052000000010101005200000001010100520000000101010052
++DATA3   80   60 00000001010100420000000140404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000A840400038404000010101004200000001010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000101010042
++DATA3   80   60 00000001010100420000000140404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000E040400038404000010101004200000001010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000101010042
++DATA3   80   60 00000001010100020000000140404040F0F0F0F6
++DATA1   80    0 02E3E7E34000011840400038404000010101004200000001010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000101010042
++DATA3   80   60 00000001010100420000000140404040F0F0F0F7
++DATA1   80    0 02E3E7E34000015040400038404000010101004200000001010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000101010042
++DATA3   80   60 00000001010100420000000140404040F0F0F0F8
++DATA1   80    0 02E3E7E34000018840400038404000010101004200000001010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000101010042
++DATA3   80   60 00000001010100420000000140404040F0F0F0F9
++DATA1   80    0 02E3E7E3400001C040400038404000010101004200000001010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000101010042
++DATA3   80   60 00000001010100420000000140404040F0F0F1F0
++DATA1   80    0 02E3E7E3400001F840400038404000010101004200000001010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000101010042
++DATA3   80   60 00000001010100420000000140404040F0F0F1F1
++DATA1   80    0 02E3E7E34000023040400038404000010101004200000001010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000101010042
++DATA3   80   60 00000001010100420000000140404040F0F0F1F2
++DATA1   80    0 02E3E7E34000026840400038404000010101004200000001010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000101010042
++DATA3   80   60 00000001010100420000000140404040F0F0F1F3
++DATA1   80    0 02E3E7E3400002A040400038404000010101004200000001010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000101010042
++DATA3   80   60 00000001010100420000000140404040F0F0F1F4
++DATA1   80    0 02E3E7E3400002D840400028404000010101004200000001010100420000
++DATA2   80   30 000101010042000000010101004200000001010100420000000140404040
++DATA3   80   60 40404040404040404040404040404040F0F0F1F5
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 404040404040404040C6F1F5D6C3E3F7F040F1F34BF0F44040F661F0F561
++DATA3   80   60 F7F34040404040404040404040404040F0F0F1F6
++FILE PASCALN.RUNTIME.MATHTEXT                     MEMB STIMER   EXT OBJ HEX H
++DATA1   80    0 02C5E2C4404040404040003040400001E2E3C9D4C5D94040000000004000
++DATA2   80   30 00C4E3E3C9D4C5D940400100003440000001C7E3C9D4C5D9404001000098
++DATA3   80   60 40000001404040404040404040404040F0F0F0F1
++DATA1   80    0 02E3E7E340000000404000384040000147F0F00C06E2E3C9D4C5D90090EC
++DATA2   80   30 D00C1B00500D0008185F4110508841000003890000180A2F98ECD00C92FF
++DATA3   80   60 D00C41F0000007FE90E5D00C40404040F0F0F0F2
++DATA1   80    0 02E3E7E34000003840400038404000011B00500D0008185F583100004110
++DATA2   80   30 00010A2E2B00582050541B2055205054478050404140D03054405084D207
++DATA3   80   60 4000505C502040046A00400040404040F0F0F0F3
++DATA1   80    0 02E3E7E34000007040400038404000017C0050587003000098E4D00C92FF
++DATA2   80   30 D00C41F0000007FE00003FFFFFFF3D1B4E0F4E0000000000000090E5D00C
++DATA3   80   60 1B00500D0008185F5831000040404040F0F0F0F4
++DATA1   80    0 02E3E7E3400000A84040000E404000011B110A2E58F050245850502807FF
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F5
++DATA1   80    0 02E3E7E3400000B84040000C4040000100FFFFF80000004A000000344040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F6
++DATA1   80    0 02D9D3C4404040404040000C40404040000100010D0000BC0C0000C04040
++DATA2   80   30 404040404040404040404040404040404040404040404040404040404040
++DATA3   80   60 40404040404040404040404040404040F0F0F0F7
++DATA1   80    0 02C5D5C44040404040404040404040404040404040404040404040404040
++DATA2   80   30 4040F1C1E2D4C7F2F1D4C1E840F0F2F0F7F7F3F2F5F440F1F57AF0F27AF4
++DATA3   80   60 F640F1F140E2C5D740F7F34040404040F0F0F0F8
