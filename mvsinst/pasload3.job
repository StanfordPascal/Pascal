//PASCALNL JOB (PASCAL),'PASCAL LOAD3',CLASS=A,MSGCLASS=X,
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1),
//             USER=PASCALN,PASSWORD=PAS
//*
//********************************************************************
//*
//* LOAD Pascal System from large flat files
//* Part 3 - Old compilers and old sample programs
//*
//********************************************************************
//*
//LOAD3    EXEC PGM=SPLITMVS
//STEPLIB  DD  DISP=SHR,DSN=PASCALN.TESTPGM.LOAD
//SYSPRINT DD  SYSOUT=A
//OUTPUT   DD  SYSOUT=A,DCB=(RECFM=VB,LRECL=133)
//PASTRACE DD  SYSOUT=A
//********************************************************************
//* assign output files here, choose high level qualifier as you like
//********************************************************************
//OUTF00C  DD  DISP=SHR,DSN=PASCALN.OLDCOMP.CNTL
//OUTF00D  DD  DISP=SHR,DSN=PASCALN.OLDCOMP.SAMPLE
//OUTF00E  DD  DISP=SHR,DSN=PASCALN.OLDCOMP.SOURCE
//SYSUDUMP DD  SYSOUT=A
//QRD      DD  DISP=SHR,DSN=PASCALN.DBGINFO
//********************************************************************
//* instream input file - the complete rest of the job
//* delimiter $* never occurs
//********************************************************************
//INPUT    DD  DATA,DLM='$*'
++FILE PASCALN.OLDCOMP.CNTL                         MEMB ASM1982  EXT JOB HEX -
//PASCALN2 JOB (ACCNT),'ASM ASM1982',CLASS=A,MSGCLASS=X,                00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)                       00000200
//********************************************************************  00000300
//*                                                                     00000400
//* assemble pascal monitor                                             00000500
//*                                                                     00000600
//********************************************************************  00000700
//ASM1982 EXEC ASMFC,PARM.ASM=(OBJ,DECK),                               00000800
//             MAC1='SYS2.MACLIB',                                      00000900
//             MAC2='SYS1.AMACLIB',                                     00001000
//             MAC3='SYS1.AMODGEN'                                      00001100
//ASM.SYSIN DD DISP=SHR,DSN=PASCALN.OLDCOMP.SOURCE(MON1982)             00001200
//ASM.SYSGO DD DISP=SHR,DSN=PASCALN.RUNTIME.TEXT(MON1982)               00001300
++FILE PASCALN.OLDCOMP.CNTL                         MEMB PAS1979  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG PASCAL 1979',CLASS=A,MSGCLASS=X,           00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)                       00000200
//*                                                                     00000300
//********************************************************************  00000400
//* Test Compile Pascal of 1979                                         00000501
//********************************************************************  00000600
//*                                                                     00000700
//COMPILE  EXEC PASNCL,MEM=PAS1979,                                     00000802
//         SRC='PASCALN.OLDCOMP.SOURCE',                                00000902
//         MOD='PASCALN.TESTPGM.LOAD'                                   00001000
//*                                                                     00001100
++FILE PASCALN.OLDCOMP.CNTL                         MEMB PAS1982  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG PASCAL 1982',CLASS=A,MSGCLASS=X,           00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)                       00000200
//*                                                                     00000300
//********************************************************************  00000400
//* Test Compile Pascal of 1982 / 2007 / 2012                           00000500
//********************************************************************  00000600
//*                                                                     00000700
//COMPILE  EXEC PASNCL,MEM=PAS1982,                                     00000800
//         SRC='PASCALN.OLDCOMP.SOURCE',                                00000900
//         MOD='PASCALN.COMPILER.LOAD'                                  00001000
//*                                                                     00001100
++FILE PASCALN.OLDCOMP.CNTL                         MEMB PAS2012  EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG PASCAL 2012',CLASS=A,MSGCLASS=X,           00000100
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)                       00000200
//*                                                                     00000300
//********************************************************************  00000400
//* Test Compile Pascal of 1982 / 2007 / 2012                           00000500
//********************************************************************  00000600
//*                                                                     00000700
//COMPILE  EXEC PASNCL,MEM=PAS2012,                                     00000800
//         SRC='PASCALN.OLDCOMP.SOURCE',                                00000900
//         MOD='PASCALN.COMPILER.LOAD'                                  00001001
//*                                                                     00001100
++FILE PASCALN.OLDCOMP.CNTL                         MEMB PCOD1982 EXT JOB HEX -
//PASCALNG JOB (PASCAL),'CLG PCODE 1982',CLASS=A,MSGCLASS=X,            00000101
//             TIME=1440,REGION=0M,MSGLEVEL=(1,1)                       00000200
//*                                                                     00000300
//********************************************************************  00000400
//* Test Compile Pascal of 1982 / 2007 / 2012                           00000500
//********************************************************************  00000600
//*                                                                     00000700
//COMPILE  EXEC PASNCL,MEM=PCOD1982,                                    00000801
//         SRC='PASCALN.OLDCOMP.SOURCE',                                00000900
//         MOD='PASCALN.COMPILER.LOAD'                                  00001000
//*                                                                     00001100
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB ACKERMAN EXT PAS HEX -
PROGRAM ACKERMANN(OUTPUT) ;
CONST NLIM = 6 ;   MLIM = 6 ;   (* LIMITS OF FUNCTION DOMAIN *)
TYPE  SHRTINT = 0..20 ;
VAR   N, M : SHRTINT ;

FUNCTION ACK(N, M : INTEGER ): INTEGER ;
   BEGIN
   IF M = 0 THEN ACK := N+1
   ELSE
      IF N = 0 THEN  ACK := ACK(1, M-1)
      ELSE   ACK := ACK( ACK(N-1,M) ,  M-1) ;
   END (*ACK*) ;

BEGIN
WRITE(OUTPUT, '      ') ;
FOR N := 0 TO NLIM DO WRITE(OUTPUT, '   ', N:4, '    ') ;
WRITELN(OUTPUT) ;   WRITELN(OUTPUT) ;
FOR M := 0 TO MLIM DO
   BEGIN    WRITELN(OUTPUT) ;   WRITE(M:5, ')') ;
   FOR N := 0 TO NLIM DO  WRITE( ACK(N,M):12 ) ;
   WRITELN( OUTPUT)
   END ;
END .
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB COMPARE  EXT PAS HEX -
   (*$D-                     *)

(*   COMPARE - COMPARE TWO TEXT FILES AND REPORT THEIR DIFFERENCES
     COPYRIGHT (C) 1977,1978
     JAMES F. MINER
     SOCIAL SCIENCE RESEARCH FACILITIES CENTER
     UNIVERSITY OF MINNESOTA

     GENERAL PERMISSION TO USE IN A NON PROFIT MANNER.

     COMPARE IS USED TO DISPLAY ON OUTPUT THE DIFFERENCES BETWEEN
     TWO SIMILAR TEXTS (FILEA AND FILEB). NOTABLE CHARACTERISTICS ARE

     - COMPARE IS LINE ORIENTED. THE SMALLEST UNIT OF COMPARISON
       IS THE TEXT LINE (IGNORING TRAILING BLANKS). THE PRESENT
       IMPLEMENTATION HAS A FIXED MAXIMUM LINE LENGTH.


     - BY MANIPULATING A PROGRAM PARAMETER, THE USER CAN AFFECT
       COMPARES SENSITIVITY TO THE "LOCALITY" OF DIFFERENCES.
       MORE SPECIFICALLY THIS PARAMETER MINLINESFORMATCH, SPECIFIES
       THE NUMBER OF CONSECUTIVE LINES ON EACH FILE WHICH MUST MATCH
       IN ORDER THAT THEY BE CONSIDERED AS TERMINATING THE CURRENT
       MISMATCH. A LARGE VALUE FOR MINLINESFORMATCH TENDS TO PRODUCE
       FEWER BUT LARGER MISMATCHES THAN DOES A SMALLER VALUE. THE VALUE
       SIX APPEARS TO GIVE GOOD RESULTS ON PASCAL SOURCE FILES BUT MAY
       BE INAPPROPIATE FOR OTHER APPLICATIONS.

       IF COMPARE IS TO BE USED AS A GENERAL UTILITY PROGRAM, THEN
       MINLINESFORMATCH SHOULD BE A PARAMETER. IT IS DECLARED AS
       A CONSTANT FOR THE SAKE OF PORTABILITY.

     - COMPARE EMPLOYS A SIMPLE BACKTRACKING SEARCH ALGORITHM TO
       ISOLATE MISMATCHES FROM THEIR SURROUNDING MATCHES. THIS
       REQUIRES (HEAP) STORAGE ROUGHLY PROPORTIONAL TO THE SIZE
       OF THE LARGEST MISMATCH, AND TIME ROUGHLY PROPORTIONAL
       TO THE SQUARE OF THE SIZE OF EACH MISMATCH FOR EACH MISMATCH.
       FOR THIS REASON IT MAY NOT BE FEASIBLE TO USE COMPARE ON FILES
       WITH VERY LONG MISMATCHES.

     - TO THE BEST OF THE AUTHORS KNOWLEDGE, COMPARE UTILIZES ONLY
       STANDARD COMPARE.

     - COMPARE WAS IMPLEMENTED AT UNL IN AUGUST 1978 BY CURT HILL.
       MODIFICATIONS REQUIRED TO FORCE COMPATIBILITY WITH STANFORD
       PASCAL WERE:
        ADDITION OF EMPTY PARENS FOR PARAMATERLESS WRITELN CALLS I.E.
        FROM < WRITELN; > TO < WRITELN(); >
        DELETION OF PACK CALLS (ALL CHARS ARE PACKED)
        ADDITION OF A PAGE PROCEDURE AND TEXT DECLARATION WHICH
        ARE ABSENT FROM THIS COMPILER.
        IMPLEMENTATION OF SQUARE BRACKETS AS (/ /)
        LIMITING MAXIMUM LINELENGTH TO 80
        DELETION OF NONSTANDARD FILES FROM PROGRAM HEAD.
        ADDITION OF FILLER TO ENSURE BOUNDARY ALLIGNMENT OF STREAM
         SUPPRESSION OF THE PRINTING OF THE SENTINEL

                                                             *)


PROGRAM COMPARE(OUTPUT);

  CONST
    VERSION = '1.2P (78/03/01)';
    LINELENGTH =134;  (* MAXIMUM SIGNIFICANT INPUT LINE LENGTH *)
    MINLINESFORMATCH = 6; (* LINES TO END MIS-MATCH *)

  TYPE
    LINEPOINTER = @LINE;
    LINE =                 (* SINGLE LINE BUFFER *)
       RECORD
         NEXTLINE : LINEPOINTER;
         LENGTH : 0..LINELENGTH;
         IMAGE : ARRAY (/0..LINELENGTH/) OF CHAR;
       END;
    STREAM =               (* BOOKKEEPING FOR EACH INPUT FILE *)
       RECORD
         CURSOR, HEAD, TAIL : LINEPOINTER;
         CURSORLINENO, HEADLINENO, TAILLINENO : INTEGER;
         ENDFILE : BOOLEAN;
         FILLER : ARRAY (/1..3/) OF CHAR; (* FORCES BOUNDARY ALIGNMENT*)
       END;
    TEXT = FILE OF CHAR;

  VAR
    FILEA, FILEB : TEXT;
    A, B : STREAM;
    MATCH :BOOLEAN;
    ENDFILE : BOOLEAN;    (* SET IF END OF STREAM FOR A OR B *)
    TEMPLINE :            (* USED BY READLINE *)
      RECORD
        LENGTH : INTEGER;
        IMAGE : ARRAY (/0..LINELENGTH/) OF CHAR;
        END;

    FREELINES : LINEPOINTER;   (* FREE LIST OF LINE BUFFERS *)

    SAME : BOOLEAN;            (* FALSE IF NO MIS-MATCHES OCCUR *)


  PROCEDURE PAGE (VAR FILEX : TEXT);
    BEGIN
    WRITELN(FILEX);
    WRITELN(FILEX,'1  ');
    END;


  PROCEDURE COMPAREFILES;

    FUNCTION ENDSTREAM(VAR X : STREAM) : BOOLEAN;
      BEGIN  (* ENDSTREAM *)
      ENDSTREAM := ((X.CURSOR = NIL)  AND X.ENDFILE)
      END; (* ENDSTREAM *)

    PROCEDURE MARK(VAR X : STREAM);
      (* CAUSES BEGINNING OF STREAM TO BE POSITIONED BEFORE
         CURRENT STREAM CURSOR. BUFFERS GET RECLAIMED, LINE
         COUNTERS RESET, ETC.                               *)
      VAR
        P : LINEPOINTER;
    BEGIN (* MARK *)
      WITH X DO
        IF HEAD <> NIL
           THEN BEGIN
                WHILE HEAD <> CURSOR DO (* RECLAIM BUFFERS *)
                  BEGIN
                    WITH HEAD@ DO
                      BEGIN
                      P := NEXTLINE;
                      NEXTLINE := FREELINES;
                      FREELINES := HEAD
                      END;
                   HEAD := P
                   END;
              HEADLINENO := CURSORLINENO;
              IF CURSOR = NIL
                 THEN BEGIN
                      TAIL := NIL;
                      TAILLINENO := CURSORLINENO
                      END
                 ELSE;
              END
           END; (* MARK *)


    PROCEDURE MOVECURSOR(VAR X : STREAM; VAR FILEX : TEXT);

      (* FILEX IS THE INPUT FILE ASSOCIATED WITH STREAM X. THE CURSOR
         FOR X IS MOVED FORWARD ONE LINE, READING FROM X IF NECESARY,
         AND INCREMENTING THE LINE COUNT. ENDFILE IS SET IF EOF IS
         ENCOUNTERED ON EITHER STREAM.                     *)


      PROCEDURE READLINE;
        VAR
          NEWLINE : LINEPOINTER;
          C, C2 : 0..LINELENGTH;

        BEGIN (* READLINE *)
          IF NOT X.ENDFILE
             THEN BEGIN
            ¯"+++ C := 0;
                  WHILE NOT EOLN(FILEX) AND (C < LINELENGTH) DO
                    BEGIN    (* READ A LINE INTO TEMPLINE.IMAGE *)
                    C := C + 1;
                    TEMPLINE.IMAGE(/C/) := FILEX@;
                    GET(FILEX)
                    END;
                  READLN(FILEX);
                  WHILE (TEMPLINE.IMAGE(/C/) = ' ') AND (C < LINELENGTH) DO
                     C := C + 1;
                  IF C < TEMPLINE.LENGTH
                     THEN
                       FOR C2 := C+1 TO TEMPLINE.LENGTH DO
                         TEMPLINE.IMAGE (/C2/) := ' '
                     ELSE;  +++"
#
#                 readln(filex, templine.image);
#                 c := linelength;
#                   repeat
#                   c := c-1
#                   until (templine.image[c] <> ' ') or (c = 1);
#
                  TEMPLINE.LENGTH := C;
                  NEWLINE := FREELINES;
                  IF NEWLINE = NIL
                     THEN NEW (NEWLINE)
                     ELSE FREELINES := FREELINES@.NEXTLINE;
                  NEWLINE@.IMAGE := TEMPLINE.IMAGE; (* THIS STMT IS
                                             IN LIEU OF A PACK*)
                  NEWLINE@.LENGTH := C;
                  NEWLINE@.NEXTLINE := NIL;
                  IF X.TAIL = NIL
                     THEN BEGIN
                          X.HEAD := NEWLINE;
                          X.TAILLINENO := 1;
                          X.HEADLINENO := 1
                          END
                     ELSE BEGIN
                          X.TAIL@.NEXTLINE := NEWLINE;
                          X.TAILLINENO := X.TAILLINENO + 1
                          END;
                  X.TAIL := NEWLINE;
                  X.ENDFILE := EOF(FILEX)
                  END
              END; (* READLINE *)


      BEGIN    (* MOVECURSOR *)
        IF X.CURSOR <> NIL
           THEN BEGIN
                IF X.CURSOR = X.TAIL
                   THEN READLINE
                   ELSE;
                X.CURSOR := X.CURSOR@.NEXTLINE;
                IF X.CURSOR = NIL
                   THEN ENDFILE := TRUE
                   ELSE;
                X.CURSORLINENO := X.CURSORLINENO + 1;
                END
           ELSE IF NOT X.ENDFILE
                   THEN BEGIN  (* BEGINNING OF STREAM *)
                        READLINE;
                        X.CURSOR := X.HEAD;
                        X.CURSORLINENO := X.HEADLINENO
                        END
                   ELSE ENDFILE := TRUE;  (* END OF STREAM *)
        END;  (* MOVECURSOR *)



   PROCEDURE BACKTRACK(VAR X :STREAM; VAR XLINES : INTEGER);
     (* CAUSES THE CURRENT POSITION OF STREAM X TO BECOME THAT OF THE
        LAST MARK OPERATION. I.E. THE CURRENT LINE WHEN THE STREAM
        WAS MARKED LAST BECOMES THE NEW CURSOR. XLINES IS SET TO THE
        NUMBER OF LINES FROM THE NEW CURSOR TO THE OLD CURSOR INCLUSIVE
                                         *)

     BEGIN   (* BACKTRACK *)
       XLINES := X.CURSORLINENO + 1 - X.HEADLINENO;
       X.CURSOR := X.HEAD;
       X.CURSORLINENO := X.HEADLINENO;
       ENDFILE := ENDSTREAM (A) OR ENDSTREAM (B);
       END;   (* BACKTRACK *)


    PROCEDURE COMPARELINES (VAR MATCH : BOOLEAN);

      (* COMPARE THE CURRENT LINES OF STREAMS A AND B, RETURNING MATCH
         TO SIGNAL THEIR (NON-) EQUIVALENCE. EOF ON BOTH STREAMS IS
         CONSIDERED A MATCH, BUT EOF ON ONLY ONE STREAM IS A MISMATCH *)



      BEGIN       (* COMPARELINES *)
        IF (A.CURSOR = NIL) OR (B.CURSOR = NIL)
           THEN MATCH := ENDSTREAM (A) AND ENDSTREAM (B)
           ELSE BEGIN
                MATCH := (A.CURSOR@.LENGTH = B.CURSOR@.LENGTH);
                IF MATCH
                   THEN MATCH := (A.CURSOR@.IMAGE = B.CURSOR@.IMAGE)
                   ELSE
                END
      END;        (* COMPARELINES *)




    PROCEDURE FINDMISMATCH;
      BEGIN (* FINDMISMATCH *)
        (* NOT  ENDFILE AND MATCH *)
        REPEAT   (* COMPARENEXTLINES *)
          MOVECURSOR(A, FILEA);
          MOVECURSOR(B, FILEB);
          MARK (A);
          MARK (B);
          COMPARELINES(MATCH);
        UNTIL ENDFILE OR NOT MATCH;
      END;           (* FINDMISMATCH *)




    PROCEDURE FINDMATCH;
      VAR
        ADVANCEB : BOOLEAN; (* TOGGLE ONE-LINE
                              LOOKAHEAD BETWEEN STREAMS *)
      PROCEDURE SEARCH(VAR X : STREAM;  (* STREAM TO SEARCH *)
                       VAR FILEX : TEXT;
                       VAR Y : STREAM;  (* STREAM TO LOOKAHEAD *)
                       VAR FILEY : TEXT);

       (* LOOK AHEAD ONE LINE ON STREAM Y, AND SEARCH FOR THAT LINE
          BACKTRACKING ON STREAM X. *)

         VAR
           COUNT : INTEGER; (* NUMBER OF LINES BACKTRACKED ON X *)

         PROCEDURE CHECKFULLMATCH;
         (* FROM  THE CURRENT POSITIONS OF X AND Y, WHICH MATCH
            MAKE SURE THAT THE NEXT MINLINESFORMATCH - 1 LINES ALSO
            MATCH, OR SET MATCH := FALSE   *)

         VAR
           N : INTEGER;
           SAVEXCUR ,SAVEYCUR : LINEPOINTER;
           SAVEXLINE, SAVEYLINE : INTEGER;

         BEGIN        (* CHECKFULLMATCH *)
           SAVEXCUR := X.CURSOR;
           SAVEYCUR := Y.CURSOR;
           SAVEXLINE := X.CURSORLINENO;
           SAVEYLINE := Y.CURSORLINENO;
           COMPARELINES(MATCH);
           N := MINLINESFORMATCH - 1;
           WHILE MATCH AND (N <> 0) DO
              BEGIN
              MOVECURSOR(X, FILEX);
              MOVECURSOR(Y, FILEY);
              COMPARELINES(MATCH);
              N := N - 1
           END;
           X.CURSOR := SAVEXCUR;
           X.CURSORLINENO := SAVEXLINE;
           Y.CURSOR := SAVEYCUR;
           Y.CURSORLINENO := SAVEYLINE;
           END;    (* CHECKFULLMATCH *)



         BEGIN         (* SEARCH *)
           MOVECURSOR(Y, FILEY);
           BACKTRACK(X, COUNT);
           CHECKFULLMATCH;
           COUNT := COUNT - 1;
           WHILE (COUNT <> 0) AND NOT MATCH DO
              BEGIN
              MOVECURSOR(X, FILEX);
              COUNT := COUNT - 1;
              CHECKFULLMATCH
              END
           END;          (* SEARCH *)



    PROCEDURE PRINTMISMATCH;

      VAR
        EMPTYA, EMPTYB : BOOLEAN;

      PROCEDURE WRITETEXT(P, Q :LINEPOINTER);
        VAR I : INTEGER;
        BEGIN       (* WRITETEXT *)
          WRITELN();
          WHILE (P <> NIL) AND (P <> Q) DO
            BEGIN
              WRITE(' > ');
              IF P@.LENGTH = 0
                 THEN
                  ELSE FOR I := 1 TO P@.LENGTH DO
                           WRITE (OUTPUT,P@.IMAGE(/I/));
               WRITELN();
              P := P@.NEXTLINE
              END;
            IF P = NIL
               THEN WRITELN(' ==== EOF ====')
               "ELSE" ;
            WRITELN();
            END;    (* WRITETEXT *)



       PROCEDURE WRITELINENO(VAR X : STREAM);
         VAR
           F, L : INTEGER;

         BEGIN     (* WRITELINENO *)
           F := X.HEADLINENO;
           L := X.CURSORLINENO - 1;
           WRITE('LINE');
           IF F = L
              THEN WRITE(' ',F:1)
              ELSE WRITE('S ',F:1,' TO ',L:1);
           IF X.CURSOR = NIL
              THEN WRITE(' (BEFORE EOF)')
              ELSE;
           END;          (* WRITELINENO *)



       PROCEDURE PRINTEXTRATEXT (VAR X : STREAM; XNAME : CHAR
                                 VAR Y : STREAM; YNAME : CHAR);

         BEGIN     (* PRINTEXTRATEXT *)
           WRITE (' EXTRA TEXT ON FILE', XNAME,' --> ');
           WRITELINENO(X);        WRITELN();
           IF Y.HEAD = NIL
              THEN WRITELN(' BEFORE EOF ON FILE', YNAME)
              ELSE WRITELN(' BETWEEN LINES ', Y.HEADLINENO-1:1,' AND ',
                         Y.HEADLINENO:1,' OF FILE',YNAME);
           WRITETEXT(X.HEAD, X.CURSOR)
           END;         (* PRINTEXTRATEXT *)



    BEGIN            (* PRINTMISMATCH *)
      WRITELN (' =========================================');
      EMPTYA := (A.HEAD = A.CURSOR);
      EMPTYB := (B.HEAD = B.CURSOR);
      IF EMPTYA OR EMPTYB
         THEN IF EMPTYA
                 THEN PRINTEXTRATEXT(B, 'B', A, 'A')
                 ELSE PRINTEXTRATEXT(A, 'A', B, 'B')
         ELSE BEGIN
              WRITELN (' MISMATCH:');  WRITELN();
              WRITE(' FILEA --> ');   WRITELINENO(A);
              WRITELN(':');
              WRITETEXT(A.HEAD, A.CURSOR);
              WRITE(' FILEB --> '); WRITELINENO(B); WRITELN (':');
              WRITETEXT(B.HEAD, B.CURSOR);
              END
         END;       (* PRINTMISMATCH *)



    BEGIN    (* FINDMATCH *)
        (* NOT MATCH *)
      ADVANCEB := TRUE;
      REPEAT
        IF NOT ENDFILE
           THEN ADVANCEB := NOT ADVANCEB
           ELSE ADVANCEB := ENDSTREAM (A);
        IF ADVANCEB
           THEN SEARCH (A, FILEA, B, FILEB)
           ELSE SEARCH (B, FILEB, A, FILEA)
      UNTIL MATCH;
      PRINTMISMATCH;
    END;      (* FINDMATCH *)



    BEGIN        (* COMPAREFILES *)
      MATCH := TRUE;   (* I.E. BEGINNINGS OF FILES MATCH *)
      REPEAT
        IF MATCH
           THEN FINDMISMATCH
           ELSE BEGIN
                SAME := FALSE;
                FINDMATCH
                END
      UNTIL ENDFILE AND MATCH;
      (* MARK (A); MARK (B); MARK END OF FILES, THEREBY DISPOSING OF
                              BUFFERS     *)
     END;      (* COMPAREFILES *)




    PROCEDURE INITIALIZE;

       PROCEDURE INITSTREAM(VAR X : STREAM; VAR FILEX : TEXT);
         BEGIN    (* INITSTREAM *)
           WITH X DO
              BEGIN
              CURSOR := NIL;
              HEAD := NIL;
              TAIL := NIL;
              CURSORLINENO := 0;
              HEADLINENO := 0;
              TAILLINENO := 0
              END;
          RESET (FILEX);
          X.ENDFILE := EOF(FILEX);
          END;  (* INITSTREAM *)


      BEGIN   (* INITIALIZE*)

        INITSTREAM (A, FILEA);    INITSTREAM (B, FILEB);
        ENDFILE := A.ENDFILE OR B.ENDFILE;
        FREELINES := NIL;
        TEMPLINE.LENGTH := LINELENGTH;
        TEMPLINE.IMAGE(/0/) := 'X';   (* SENTINEL *)
        END;       (* INITIALIZE *)





    BEGIN       (* COMPARE *)
      INITIALIZE;
      PAGE(OUTPUT);
      WRITELN ('     COMPARE.  VERSION ', VERSION);
      WRITELN();
      WRITELN (' MATCH CRITERION = ',MINLINESFORMATCH:1, ' LINES.');
      WRITELN();
      IF A.ENDFILE
         THEN WRITELN (' FILEA IS EMPTY.')
         ELSE;
      IF B.ENDFILE
         THEN WRITELN(' FILEB IS EMPTY.');
      IF  NOT ENDFILE
          THEN BEGIN
               SAME := TRUE;
               COMPAREFILES;
               IF SAME
                  THEN WRITELN(' NO DIFFERENCES.')
                  ELSE;
               END
          ELSE;
  END.      (* COMPARE *)
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB COMPRESS EXT PAS HEX -
  (*$P-,F-,D-,K-,Q+,I+,M-    *)
 PROGRAM COMPRESS (INPUT,OUTPUT,QRR);
  (* THIS PROGRAM READS IN SOURCE(OR OTHER) TEXT AND COMPRESSES THE
     TEXT BY ELIMINATING DUPLICATE CHARACTERS. THERE ARE TWO SPECIAL
     CHARACTERS WHICH ARE USED TO AID THIS. SPEC1ALCHAR1 AND 2.
     IF THERE IS AN OCCURRENCE OF 3..256 IDENTICAL CHARACTERS
     THEY ARE COMPRESSED INTO THE FOLLOWING S C N, WHERE :
       S = SPECIALCHAR1
       C = THE DUPLICATED CHARACTER
       N = A 1 BYTE COUNT OF THE NUMBER OF DUPLICATED CHARACTERS

       IF SPECIALCHAR1 OR 2 IS ENCOUNTERED, THE FOLLOWING STRING
       IS OUTPUT : S C 1 WHERE :
         S = SPECIALCHAR1
         C = SPECIALCHAR1 OR SPECIALCHAR2
         1 = BYTE COUNT OF 1

       AT END OF LINE A CHECKSUM IS WRITTEN OUT. THE CHECKSUM IS OF
       THE FORM
       S N WHERE :
         S = SPECIALCHAR2
         N = THE LOW ORDER BYTE OF THE CHECKSUM
       THE CHECKSUM WILL BE IN THE RANGE OF 0 .. 255. OVERFLOW SHOULD
       NOT OCCUR IF CHECK SUM INTERVAL IS A REASONABLE VALUE, TRUNCATION OF
       CHECKSUM TO LESS THAN 255 SHOULD BE NO PROBLEM.

       IN ORDER THAT THE EXPAND PROGRAM CAN CALIBRATE ITSELF THE FIRST
       CHARACTERS SENT ARE SPECIALCHAR1, SPECIALCHAR2, AND TYPECODE,
       IN THAT ORDER. TYPECODE WILL BE USED TO DENOTE SOURCE CODE TYPE
       FOR (FUTURE) KEYWORD COMPACTION.

       THE DATA IN COMPRESSED FORM IS TERMINATED BY A CHECKSUM AND
       AN INTERNAL END OF FILE MARK WHICH IS S S 0 WHERE :
         S = SPECIALCHAR1
         S = SPECIALCHAR1
         0 = INDICATES A BYTE COUNT OF ZERO WHICH CAN ONLY LEGALLY
             OCCUR AT END OF FILE.

       BECAUSE OF THE AWKWARD HANDLING OF SPECIALCHAR1 AND 2
       THEY SHOULD BE RARE TO NONEXISTANT IN THE INPUT DATA SET,
       BUT THEY WILL BE HANDLED CORRECTLY IF PRESENT.

       UPDATE RECORD:

       04/27/79 : COMMENT CORRECTIONS AND SET SPECIALCHARS TO MORE
                  APPROPIATE VALUES. CH


                                             CURT HILL
                                             225 NEBRASKA HALL
                                             UNIVERSITY OF NEBRASKA - LINCOLN
                                             LINCOLN, NEBRASKA
                                             68588
                                             (402) 472-3701


       THIS PROGRAM IS COPYRIGHT 1979, CURT HILL

       PERMISSION IS HEREBY GRANTED FOR ANY NONPROFIT USE OF ALL OR
       PARTS OF THIS PROGRAM, PROVIDED THIS NOTICE IS DISPLAYED.
       FURTHERMORE DISTRIBUTION AND IMPROVEMENT IS ENCOURAGED.
       I WOULD LIKE TO HEAR ABOUT AND/OR RECIEVE COPIES OF ANY
       IMPROVEMENTS THAT ARE WORTH MAKING TO THIS PROGRAM. CONTACT
       ME AT ABOVE ADDRESS OR SEE PASCAL NEWS FOR AN ADDRESS UPDATE.

                  FREELY YOU HAVE RECIEVED, FREELY GIVE.
                                   *)


   VAR
     BUFFER : ARRAY (/0..2/) OF CHAR;
     SPECIALCHAR1, SPECIALCHAR2 : CHAR;
     INCOUNT,            (* CHARS INPUT *)
     OUTCOUNT,           (* CHARS OUTPUT *)
     CHECKSUM,
     INLINE : INTEGER;   (* INPUT LINES (ALSO OUTPUT CHECKSUMS) *)
     TYPECODE : CHAR;    (* INDICATES TYPE OF SOURCE CODE *)



   PROCEDURE WRITECHAR(C : CHAR);

     (* THIS PROCEDURE WRITES OUT ONE CHARACTER AND SUMS CHECKSUM AND
        THE COUNT OF CHARACTERS OUTPUT       *)

     BEGIN (* WRITECHAR *)
       WRITE (QRR, C);
       OUTCOUNT := OUTCOUNT + 1;
       CHECKSUM := CHECKSUM + ORD(C);
       END;    (* WRITECHAR *)



   PROCEDURE WRITECHECKSUM;

     (* THIS PROCEDURE WRITES OUT THE CHECKSUM *)

     BEGIN(* WRITECHECKSUM *)
       WRITE (QRR, SPECIALCHAR2, CHR(CHECKSUM MOD 256));
       OUTCOUNT := OUTCOUNT + 2;
       CHECKSUM := 0;
       INLINE := INLINE + 1;
       END;    (* WRITECHECKSUM *)


   FUNCTION GETCHAR (VAR C:CHAR):BOOLEAN;
     (* GET ONE CHAR, HANDLE EOLN PROPERLY AND PASS BACK WHETHER EOLN
        OR NOT SOAS TO TRIGGER CHECKSUM ACTIVITIES.   *)

     BEGIN     (* GETCHAR *)
       IF NOT EOF(INPUT) THEN
          BEGIN
          IF EOLN(INPUT)
             THEN BEGIN
                  READLN(INPUT);
                  GETCHAR := FALSE;
                  END
             ELSE BEGIN
                  READ (INPUT,C);
                  INCOUNT := INCOUNT + 1;
                  GETCHAR := TRUE;
                  END;
            END;   (*IF NOT EOF BEGIN *)
       END;           (* GETCHAR *)


   PROCEDURE FILLBUFFER (INDEX:INTEGER);
     (* FILL UP THE BUFFER FROM INDEX ON, IF GETCHAR FALSE THEN
        WRITECHECKSUM AFTER EMPTYING THE BUFFER    *)

     VAR
       I , J : INTEGER;



     BEGIN   (* FILLBUFFER *)
       I := INDEX;
       WHILE (I <= 2) AND (NOT EOF(INPUT))  DO
         BEGIN
         IF NOT GETCHAR(BUFFER(Ý I Ý))
            THEN BEGIN        (* WRITE BUFFER AND GET NEW ONE *)
                 FOR J := 0 TO I-1  DO
                     WRITECHAR ( BUFFER (/J/) );
                 I := 0;
                 WRITECHECKSUM;
                 END
            ELSE I := I + 1;
         END;
         IF EOF(INPUT)         (* CLEAN THE BUFFER *)
            THEN FOR J := 0 TO I DO
                     WRITECHAR( BUFFER(/0/) )
            ELSE;

     END;             (* FILLBUFFER *)


   PROCEDURE SENDDUPGROUP;
     (* ACCUMULATE DUPLICATE CHARACTERS AND SEND ONE THREE CHARACTER
        DUPLICATION GROUP *)

     VAR
       NEWCHAR : CHAR;
       COUNT : INTEGER;
       DIFFERENT : BOOLEAN;
       ENDLINE : BOOLEAN;
       IND : INTEGER;

     BEGIN                    (* SENDDUPGROUP *)
       ENDLINE := FALSE;
       COUNT := 3;       (* ONLY CALLED WHEN 3 DUPLICATES ALREADY *)
       DIFFERENT := FALSE;
       WHILE ( (NOT EOF (INPUT))   AND
               (COUNT < 255)       AND
               (NOT DIFFERENT) )             DO
          BEGIN
          IF NOT GETCHAR( BUFFER(Ý0Ý) )
             THEN BEGIN
                  DIFFERENT := TRUE;
                  ENDLINE := TRUE
                  END
             ELSE BEGIN
                  DIFFERENT := NOT (BUFFER (/0/) = BUFFER (/1/));
                  END;
          COUNT := COUNT + 1;
          END;

       WRITECHAR(SPECIALCHAR1);
       WRITECHAR( BUFFER(/1/) );
       WRITECHAR( CHR(COUNT-1) );
       IF ENDLINE
          THEN BEGIN
               WRITECHECKSUM;
               IND := 0;
               END
          ELSE IND := 1;
       FILLBUFFER(IND)
       END;       (* PROCDUPE *)



   PROCEDURE PROCCHAR;

     (* THIS PROCEDURE WRITES OUT THE FIRST ELEMENT OF BUFFER, SHIFTS
        THE REST AND READS IN THE LAST ELEMENT OF BUFFER.
        IT ALSO DETECTS OCCURRENCES OF SPECIALCHAR1 AND 2 AND WRITES
        THEM OUT CORRECTLY.              *)





     BEGIN
       IF (BUFFER (/0/) = SPECIALCHAR1)   OR
          (BUFFER (/0/) = SPECIALCHAR2)
          THEN BEGIN    (* WRITE SPECIAL CHARACTERS *)
               WRITECHAR (SPECIALCHAR1);
               WRITECHAR ( BUFFER(/0/) );
               WRITECHAR ( CHR(1) );
               END
          ELSE WRITECHAR ( BUFFER(/0/) );

      BUFFER (/0/) := BUFFER (/1/);     (* SHIFT *)
      BUFFER (/1/) := BUFFER (/2/);
      FILLBUFFER(2)

      END;          (* PROCCHAR *)




   BEGIN     (* COMPRESS *)
                                   (* INITIALIZATION *)
     INCOUNT := 0;
     CHECKSUM := 0;
     OUTCOUNT := 0;
     INLINE := 0;
     TYPECODE := ' ';   (* SET TO BLANK UNTIL PROPERLY IMPLEMENTED *)
     SPECIALCHAR1 := CHR(251);  (* UNUSED IN ASCII AND EBCDIC *)
     SPECIALCHAR2 := CHR(252);   (* UNUSED IN ASCII AND EBCDIC *)
     REWRITE (QRR);
     FILLBUFFER (0);
     WRITECHAR (SPECIALCHAR1);    (* THIS ALLOWS THE EXPAND PROGRAM *)
     WRITECHAR (SPECIALCHAR2);    (* TO BE SELF CALIBRATING  *)
     WRITECHAR (TYPECODE);
     WHILE NOT EOF(INPUT)  DO
       IF (BUFFER (/0/) = BUFFER (/1/)) AND
          (BUFFER (/0/) = BUFFER (/2/))
          THEN SENDDUPGROUP
          ELSE PROCCHAR;

     IF OUTCOUNT = 0
        THEN (* BY CHANCE WE JUST SENT OUT A CHECKSUM *)
        ELSE WRITECHECKSUM;
     WRITECHAR (SPECIALCHAR1);
     WRITECHAR (SPECIALCHAR1);
     WRITECHAR ( CHR(0) );  WRITELN(QRR);
     WRITELN (OUTPUT, ' **** COMPRESS ****');
     WRITELN (OUTPUT, ' NUMBER OF CHARACTERS INPUT : ', INCOUNT:10);
     WRITELN (OUTPUT, ' NUMBER OF LINES INPUT :      ', INLINE:10);
     WRITELN (OUTPUT, ' NUMBER OF CHARACTERS OUTPUT : ', OUTCOUNT:9);
     END.

++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB ED       EXT PAS HEX -
 program ed(output);
 (* software tools editor translated into PASCAL *)

(* Notes:                                                         *)
(* 1) Program now runs under ORVYL/370 on SLAC's 370/168          *)
(* 2) We did not change (much) more than was necessary to get it  *)
(*    running.                                                    *)
(* 3) Open and terminal I/O are done through external subroutines.*)
(* 4) The character set is EBCDIC, which may explain some things  *)
(*    in the program.                                             *)
(*             -- M Powell, SLAC Computation Research Group, 1979 *)

 const
   (* global flags *)
   (* constant definitons *)
   ARB = 100;
   MAXCARD = 163;
   MAXLINE = 165;
   MAXPACK = 165;
   MAXNAME = 30;
   MAXTOK = 200;
   MAXDEF = 200;
   MAXSYMBOL = 10;
   ASSGSTRSIZE = 163;

   LETTER = 1;
   DIGIT = 2;

   ESCAPE = '@';
   BANG = '!';
   CFLEX = '';
   TILDE = '^';
   BOL = '%';
   ANY = '?';
   EOL = '$';
   CLOSURE = '*';
   AMPER = '&';
(* DITTO = chr(1); *)
   CCL = '[';
   CCLEND = ']';
   NCCL = 'n';
   CHARA = 'a';
   (* constants for pattern routines *)
   COUNT = 1;
   PREVCL = 2;
   START = 3;
   CLOSIZE = 4;

   MAXPAT = MAXLINE;  (* must be same due to parameter passing *)
   GLOBAL = 'g';
   PRINT = 'p';
   LIST = 'l';
   FORW = 0;
   BACK = -1;
   EXCLUDE = 'x';
   APPENDCOM = 'a';
   BLOCK = 'b';
   CHANGE = 'c';
   DELCOM = 'd';
   ENTER = 'e';
   PRINTFILE = 'f';
   READCOM = 'r';
   WRITECOM = 'w';
   INSERT = 'i';
   PRINTCUR = '=';
   MOVECOM = 'm';
   QUIT = 'q';
   SUBSTITUTE = 's';
   QUERY = '?';
   CURLINE = '.';
   LASTLINE = '$';
   SCAN = '/';
   BACKSCAN = '\';
   PERIOD = '.';
   NEWLINE = '
';
   PLUS = '+';
   MINUS = '-';
   DASH = '-';
   COMMA = ',';
   SEMICOL = ';';
   DIG0 = '0';
   DIG7 = '7';
   DIG9 = '9';
   BLANK = ' ';
   LETA = 'a';
   LETN = 'n';
   LETT = 't';
(* TAB = chr(9); *)
   DIRIN = 0;
   DIROUT = 1;

type
   (* global type declarations *)
   lineString = array [1..MAXLINE] of char;
   argString = lineString;
   lineLength = 0..MAXLINE;
   fileNameString = array [1..MAXNAME] of char;
   patternString = array [1..MAXPAT] of char;
   traceString = array [1..6] of char;
   assignString = array [1..ASSGSTRSIZE] of char;
   linePtr = @lineRec;
   lineRec = record
     next, prev : linePtr;
     mark : boolean;
     length : lineLength;
     line : lineString;
   end;
   statusRange = (NOSTATUS, OKSTATUS, ERRSTATUS, EOFSTATUS, INTSTATUS);

var
   (* constant variables *)
   EOS, TAB, DITTO : char;
   LINE0 : linePtr;
   ONE, ZERO : integer;
   (* global variable definitions *)
   terminopen : boolean;
   freeList : linePtr;
   n0 : integer;
   k0 : linePtr;
   line1, line2, nlines, curln, cursav, lastln : integer;
   increment : integer;
   pat : patternString;
   txt : lineString;
   pak : array [1..MAXPACK] of char;
   lpak : integer;
   savfil : array [1..MAXNAME] of char;
   status : statusRange;
   lin : lineString;
   i : integer;
   glob : boolean;
   termin, termout, filex : text;
(*******************************************************************)

(***************)
(* subroutines *)
(***************)

(* a debugging routine *)
   (* etrace - trace status of edit *)
   procedure etrace(traceName : traceString);
   begin
     (*writeln(debug,traceName,':   i=',i,',  s=',ord(status),
         ',  g=',glob);*)
   end;

(* miscellaneous i/o routines *)
   (* readline - reads a line *)
   procedure readline(var filex : text; var lin : lineString;
       var lineLen : integer);
   var
     i : integer;
   begin
     if not eof(filex) then begin
       i := 1;
       while not eoln(filex) and not eof(filex) do begin
         lin[i] := filex@;
         get(filex);
         i := i + 1;
       end;
       readln(filex);
       lineLen := i-1;
       lin[i] := EOS;
     end
     else begin
       lineLen := -1;
       lin[1] := EOS;
     end;
   end;

   (* intrpt - indicate a user attempt to interrupt *)
   function intrpt(var x : integer) : boolean; fortran;

   (* readcmd - read a line from the terminal *)
   function readcmd(var lin : lineString; promptCh : char) : boolean;
   const
     MAXPROMPT = 163;
   type
     promptString = array [1..MAXPROMPT] of char;
     promptRec = record
       len : integer;
       str : promptString;
     end;
   var
     i : integer;
     len, ret, readlen : integer;
     prompt : promptRec;
     function readterm(var lin : lineString; var len : integer;
         var prompt : promptRec; var readlen : integer) : integer; fortran;
   begin
     (* read from the terminal *)
     readcmd := TRUE;
     repeat
       prompt.len := 1;
       prompt.str[1] := promptCh;
       len := MAXLINE-2;
       ret := readterm(lin,len,prompt,readlen);
       if (ret = 4) and (readlen = 1) and (lin[1] = '@') then begin
         ret := 0;
         readcmd := FALSE;
       end;
     until ret = 0;
     lin[readlen+1] := NEWLINE;
     lin[readlen+2] := EOS;
   end;

   (* assign - external function to assign a file *)
   function assign(var str : assignString) : integer; fortran;

   (* open - opens a file using uram *)
   function open(fileName : fileNameString; dir : integer) : integer;
   var
   assgStr : assignString;
     tempStr6 : array [1..6] of char;
     tempStr9 : array [1..9] of char;
     tempStr21 : array [1..21] of char;
     i : integer;
   begin
   (* clean up file name *)
   i := 1;
   while fileName[i] <> EOS do begin
     if (fileName[i] >= 'a') and (fileName[i] <= 'z') then
       fileName[i] := chr(ord(fileName[i])+ord('A')-ord('a'));
     i := i + 1;
   end;
   for i := i to MAXNAME do fileName[i] := ' ';
     tempStr21 := 'ASSIGN FILEX TO FILE ';
     tempStr9 := ' RECFM=E ';
     if dir = DIRIN then tempStr6 := 'INPUT '
     else if dir = DIROUT then tempStr6 := 'OUTPUT'
     else tempStr6 := '??????';
     (* build up string *)
     for i := 1 to 21 do assgStr[i] := tempStr21[i];
     for i := 22 to 51 do assgStr[i] := fileName[i-21];
     for i := 52 to 60 do assgStr[i] := tempStr9[i-51];
     for i := 61 to 66 do assgStr[i] := tempStr6[i-60];
     assgStr[67] := ';';
     i := assign(assgStr);
     if i = 0 then begin
       if dir = DIRIN then reset(filex)
       else if dir = DIROUT then rewrite(filex);
     end
     else writeln(output,'assign error',i);
     open := i;
   end;

   (* ctoi - convert character to integer *)
   function ctoi(lin : lineString; var i : integer) : integer;
   var
     temp : integer;
   begin
     temp := 0;
     while (lin[i] >= DIG0) and (lin[i] <= DIG9) do begin
       temp := temp * 10 + ord(lin[i]) - ord(DIG0);
       i := i + 1;
     end;
     ctoi := temp;
   end;
(* string manipulation routines *)

   (* addset - put c in str[j] if it fits. increment j *)
   function addset(c : char; var str : lineString; var j : integer;
       maxsiz : integer) : boolean;
   begin
     if j > maxsiz then addset := FALSE
     else begin
       str[j] := c;
       j := j + 1;
       addset := TRUE;
     end;
   end;

   (* esc - map str[i] into escaped character if appropriate *)
   function esc(str : lineString; var i : integer) : char;
   label 1;
   var
     temp, j : integer;
   begin
     if str[i] <> ESCAPE then esc := str[i]
     else if str[i+1] = EOS then esc := ESCAPE (* not special at end *)
     else begin
       i := i + 1;
       if str[i] = LETN then esc := NEWLINE
       else if str[i] = LETT then esc := TAB
       else if (str[i] >= DIG0) and (str[i] <= DIG7) then begin
         temp := 0;
         for j := 1 to 3 do begin
           if (str[i] < DIG0) or (str[i] > DIG7) then goto 1;
           temp := temp * 8 + ord(str[i]) - ord(DIG0);
           i := i + 1;
         end;
       1:
         esc := chr(temp);
         i := i - 1;
       end
       else esc := str[i];
     end;
   end;

   (* filset - expand set at lin[i] into str[j] *)
   procedure filset(delim : char; lin : lineString; var i : integer;
       var str : lineString; var j : integer; maxstr : integer);
   var
     limit, k : char;
     junk : boolean;
   begin
     while (lin[i] <> delim) and (lin[i] <> EOS) do begin
       if lin[i] = ESCAPE then
         junk := addset(esc(lin,i),str,j,maxstr)
       else if lin[i] <> DASH then
         junk := addset(lin[i],str,j,maxstr)
       else if (j <= 1) or (lin[i] = EOS) then
         junk := addset(DASH,str,j,maxstr)  (* literal - *)
       else begin
         i := i + 1;
         j := j - 1;
         limit := esc(lin,i);
         for k := str[j] to limit do
           junk := addset(k,str,j,maxstr);
       end;
       i := i + 1;
     end;
   end;

(* pattern matching subroutines *)

   (* dumppat - print a pattern, starting at j *)
   procedure dumppat(pat : patternString; j : integer);
   var p, i : integer;
   begin
     p := j;
     write(output,'[');
     while pat[p] <> EOS do begin
       case pat[p] of
         BOL : write(output,'<bol>');
         EOL : write(output,'<eol>');
         ANY : write(output,'<any>');
         CHARA : begin write(output,'<char><',pat[p+1],'>'); p := p + 1; end;
         CLOSURE : begin
           write(output,'<clos><',ord(pat[p+1]):1,'><',ord(pat[p+2]):1,
             '><',ord(pat[p+3]):1,'>');
           p := p + 3;
         end;
         CCL, NCCL : begin
           if pat[p] = CCL then write(output,'<ccl>')
           else write(output,'<nccl>');
           write(output,'<',ord(pat[p+1]):1,'><');
           for i := 1 to ord(pat[p+1]) do write(output,pat[p+1+i]);
           write(output,'>');
           p := p + 1 + ord(pat[p+1]);
         end;
       end;
       p := p + 1;
     end;
     writeln(output,']');
   end;

   (* patsiz - returns size of the pattern entry at pat[n] *)
   function patsiz(pat : patternString; n : integer) : integer;
   begin
     if pat[n] = CHARA then patsiz := 2
     else if (pat[n] = BOL) or (pat[n] = EOL) or (pat[n] = ANY) then
       patsiz := 1
     else if (pat[n] = CCL) or (pat[n] = NCCL) then
       patsiz := ord(pat[n+COUNT]) + 2
     else if pat[n] = CLOSURE then patsiz := CLOSIZE
     else writeln(termout,'patsize: impossible');
   end;

   (* locate - look for c in char class at pat[offset] *)
   function locate(c : char; pat : patternString; offset : integer) : boolean;
   label 1;
   var
     i : integer;
   begin
     locate := FALSE;
     for i := offset + ord(pat[offset]) downto offset + 1 do begin
       if c = pat[i] then begin
         locate := TRUE;
         goto 1;
       end;
     end;
   1:
   end;

   (* omatch - try to match a single pattern at pat[j] *)
   function omatch(lin : lineString; var i : integer; pat : patternString;
       j : integer) : boolean;
   var
     bump : integer;
   begin
     omatch := FALSE;
     if lin[i] <> EOS then begin
       bump := -1;
       if pat[j] = CHARA then begin
         if lin[i] = pat[j+1] then bump := 1;
       end
       else if pat[j] = BOL then begin
         if i = 1 then bump := 0;
       end
       else if pat[j] = ANY then begin
         if lin[i] <> NEWLINE then bump := 1;
       end
       else if pat[j] = EOL then begin
         if lin[i] = NEWLINE then bump := 0;
       end
       else if pat[j] = CCL then begin
         if locate(lin[i],pat,j+1) then bump := 1;
       end
       else if pat[j] = NCCL then begin
         if lin[i] <> NEWLINE then
           if not locate(lin[i],pat,j+1) then bump := 1;
       end
       else begin
         writeln(termout,'omatch: impossible');
       end;
       if bump >= 0 then begin
         i := i + bump;
         omatch := TRUE;
       end;
     end;
   end;


   (* amatch (non-recursive) - look for match starting at lin[from] *)
   function amatch(lin : lineString; from : integer; var pat : patternString)
       : integer;
   label 1, 2, 3;
   var
     i, j, offset, stack : integer;
   begin
     stack := 0;
     offset := from;
     j := 1;
     while pat[j] <> EOS do begin
       if pat[j] = CLOSURE then begin
         stack := j;
         j := j + CLOSIZE;
         i := offset;
         while lin[i] <> EOS do
           if not omatch(lin,i,pat,j) then goto 1;
       1:
         pat[stack+COUNT] := chr(i-offset);
         pat[stack+START] := chr(offset);
         offset := i;
       end
       else if not omatch(lin,offset,pat,j) then begin (* non-closure *)
         while stack > 0 do begin
           if ord(pat[stack+COUNT]) > 0 then goto 2;
           stack := ord(pat[stack+PREVCL]);
         end;
       2:
         if stack <= 0 then begin
           offset := 0;
           goto 3;
         end;
         pat[stack+COUNT] := chr(ord(pat[stack+COUNT]) - 1);
         j := stack + CLOSIZE;
         offset := ord(pat[stack+START]) + ord(pat[stack+COUNT]);
       end;
       (* else omatch succeeded *)
       j := j + patsiz(pat,j);
     end;
   3:
     amatch := offset;
   end;

   (* match - find match anywhere on line *)
   function match(lin : lineString; var pat : patternString) : boolean;
   var
     i : integer;
     result : boolean;
   begin
     i := 1;
     result := FALSE;
     while (lin[i] <> EOS) and not result do begin
       result := amatch(lin,i,pat) > 0;
       i := i + 1;
     end;
     match := result;
   end;

   (* stclos - insert closure entry at pat[j] *)
   function stclos(var pat : patternString; var j, lastj, lastcl : integer)
       : integer;
   var
     jp, jt : integer;
     junk : boolean;
   begin
     for jp := j-1 downto lastj do begin
       jt := jp + CLOSIZE;
       junk := addset(pat[jp],pat,jt,MAXPAT);
     end;
     j := j + CLOSIZE;
     stclos := lastj;
     junk := addset(CLOSURE,pat,lastj,MAXPAT);  (* put closure in it *)
     junk := addset(chr(0),pat,lastj,MAXPAT); (* COUNT *)
     junk := addset(chr(lastcl),pat,lastj,MAXPAT); (* PREVCL *)
     junk := addset(chr(0),pat,lastj,MAXPAT); (* START *)
   end;

   (* getccl - expand character class at arg[i] into pat[j] *)
   function getccl(arg : argString; var i : integer; var pat : patternString;
       var j : integer) : boolean;
   var
     junk : boolean;
     jstart : integer;
   begin
     i := i + 1;
     if (arg[i] = BANG) or (arg[i] = CFLEX) or (arg[i] = TILDE) then begin
       junk := addset(NCCL,pat,j,MAXPAT);
       i := i + 1;
     end
     else junk := addset(CCL,pat,j,MAXPAT);
     jstart := j;
     junk := addset(chr(0),pat,j,MAXPAT); (* leave room for count *)
     filset(CCLEND,arg,i,pat,j,MAXPAT);
     pat[jstart] := chr(j-jstart-1);
     getccl := arg[i] = CCLEND;
   end;

   (* makpat - make pattern from arg[from], terminate at delim *)
   function makpat(arg : argString; from : integer; delim : char;
       var pat : patternString) : integer;
   label 1;
   var
     i, j, lastcl, lastj, lj : integer;
     junk : boolean;
   begin
     j := 1;  (* pat index *)
     lastj := 1;
     lastcl := 0;
     i := from;
     while (arg[i] <> delim) and (arg[i] <> EOS) do begin
       lj := j;
       if arg[i] = ANY then junk := addset(ANY,pat,j,MAXPAT)
       else if (arg[i] = BOL) and (i = from) then
         junk := addset(BOL,pat,j,MAXPAT)
       else if (arg[i] = EOL) and (arg[i+1] = delim) then
         junk := addset(EOL,pat,j,MAXPAT)
       else if arg[i] = CCL then begin
         if not getccl(arg,i,pat,j) then goto 1;
       end
       else if (arg[i] = CLOSURE) and (i > from) then begin
         lj := lastj;
         if (pat[lj] = BOL) or (pat[lj] = EOL) or (pat[lj] = CLOSURE) then
           goto 1;
         lastcl := stclos(pat,j,lastj,lastcl);
       end
       else begin
        junk := addset(CHARA,pat,j,MAXPAT);
        junk := addset(esc(arg,i),pat,j,MAXPAT);
       end;
       lastj := lj;
       i := i + 1;
     end;
   1:
     if arg[i] <> delim then makpat := -1 (* error making pattern *)
     else if not addset(EOS,pat,j,MAXPAT) then makpat := -1 (* no room *)
     else makpat := i;
   end;

(* string substitution routines *)

   (* catsub - add replacement text to end of str *)
   procedure catsub(lin : lineString; f, t : integer; sub : patternString;
       var str : lineString; var k : integer; maxnew : integer);
   var
     i, j : integer;
     junk : boolean;
   begin
     (*writeln(debug,'catsub',f,t);*)
     (*writeln(debug,lin:20);*)
     (*writeln(debug,sub:20);*)
     i := 1;
     while sub[i] <> EOS do begin
       if sub[i] = DITTO then begin
         for j := f to t-1 do junk := addset(lin[j],str,k,maxnew);
       end
       else junk := addset(sub[i],str,k,maxnew);
       i := i + 1;
     end;
   end;

   (* maksub - make substitution string in sub *)
   function maksub(arg : argString; f : integer; delim : char;
       var sub : patternString) : integer;
   var
     i, j : integer;
     junk : boolean;
   begin
     j := 1;
     i := f;
     while (arg[i] <> delim) and (arg[i] <> EOS) do begin
       if arg[i] = AMPER then junk := addset(DITTO,sub,j,MAXPAT)
       else junk := addset(esc(arg,i),sub,j,MAXPAT);
       i := i + 1;
     end;
     if arg[i] <> delim then
       maksub := -1  (* error - missing delimiter *)
     else if not addset(EOS,sub,j,MAXPAT) then
       maksub := -1  (* error - no room *)
     else maksub := i;
   end;

(* line manipulating routines *)


   (* nextln - get line after "line" *)
   function nextln(line : integer) : integer;
   var
     result : integer;
   begin
     result := line + 1;
     if result > lastln then result := 0;
     nextln := result;
   end;

   (* prevln - get line before "line" *)
   function prevln(line : integer) : integer;
   var
     result : integer;
   begin
     result := line - 1;
     if result < 0 then result := lastln;
     prevln := result;
   end;

   (* linkup - make line k2 follow line k1 *)
   procedure linkup(k1, k2 : linePtr);
   begin
     k1@.next := k2;
     k2@.prev := k1;
     (* reset line cache *)
     n0 := 0;
     k0 := LINE0;
   end;

   (* alloline - allocate a line record *)
   function alloline : linePtr;
   var
     result : linePtr;
   begin
     if freeList = NIL then new(result)
     else begin
       result := freeList;
       freeList := freeList@.next;
     end;
     result@.next := NIL;
     result@.prev := NIL;
     result@.mark := FALSE;
     alloline := result;
   end;

   (* freeline - release a line record *)
   procedure freeline(var linep : linePtr);
   begin
     linep@.next := freeList;
     freeList := linep;
   end;

   (* getind - locate line index in buffer *)
   function getind(line : integer) : linePtr;
   var
     d, d0, n1 : integer;
   begin
     (*writeln(debug,'getind',line);*)
     n1 := lastln + 1;
     d0 := line;
     (* d := min(d0,n1-d0,abs(d0-n0)); *)
     d := d0;
     if n1-d0 < d then d := n1-d0;
     if abs(d0-n0) < d then d := abs(d0-n0);
     (*writeln(debug,d0,n1-d0,abs(d0-n0));*)
     if d = d0 then begin (* go forward from LINE0 *)
       n0 := 0;
       k0 := LINE0;
     end
     else if d = n1-d0 then begin (* go backwards from LINE0 *)
       n0 := n1;
       k0 := LINE0;
     end;
     (*writeln(debug,'search',n0,' ',k0@.line:k0@.length);*)
     while n0 > d0 do begin  (* search backward *)
     (*writeln(debug,'back');*)
       k0 := k0@.prev;
       n0 := n0 - 1;
     (*writeln(debug,'search',n0,' ',k0@.line:k0@.length);*)
     end;
     while n0 < d0 do begin  (* search forward *)
     (*writeln(debug,'forw');*)
       k0 := k0@.next;
       n0 := n0 + 1;
     (*writeln(debug,'search',n0,' ',k0@.line:k0@.length);*)
     end;
     getind := k0;
     (*writeln(debug,'k0',ord(k0));*)
   end;

   (* getpak - get packed text for line *)
   function getpak(line : integer) : linePtr;
   var
     result : linePtr;
   begin
     (* this routine should do something more *)
     (*writeln(debug,'getpak',line);*)
     result := getind(line);
     (*writeln(debug,'result',ord(result));*)
     pak := result@.line;
     lpak := result@.length;
     (*writeln(debug,'pak=',pak:lpak,result@.line:result@.length);*)
     getpak := result;
   end;

   (* gettxt - locate text for a line *)
   function gettxt(line : integer) : linePtr;
   begin
     (* this routine should do something more *)
     (*writeln(debug,'gettxt');*)
     gettxt := getpak(line);
     txt := pak;
     (*writeln(debug,'txt=pak?');*)
     (*writeln(debug,pak:lpak);*)
     (*writeln(debug,txt:lpak);*)
     txt[lpak+1] := NEWLINE;
     txt[lpak+2] := EOS;
   end;

   (* injpak - insert packed line from pak after curln *)
   function injpak(var sts : statusRange) : statusRange;
   var
     k1, k2, k3 : linePtr;
   begin
     (*writeln(debug,'injpak',curln,lpak,pak:lpak);*)
     k1 := getind(curln);
     k2 := k1@.next;
     k3 := alloline;
     k3@.line := pak;
     k3@.length := lpak;
     linkup(k1,k3);
     linkup(k3,k2);
     k1 := k3;
     curln := curln + 1;
     lastln := lastln + 1;
     n0 := curln;
     k0 := k1;
     injpak := OKSTATUS;
     sts := OKSTATUS;
   end;

   (* inject - insert text from lin after curln *)
   function inject(lin : lineString) : statusRange;
   label 1, 2;
   var
     i, j : integer;
     result : statusRange;
   begin
     (*writeln(debug,'inject',lin:20);*)
     i := 1;
     while lin[i] <> EOS do begin
       j := i;
       while lin[i] <> EOS do begin
         i := i + 1;
         if lin[i-1] = NEWLINE then goto 1;
       end;
     1:
       if lin[i-1] = NEWLINE then begin
         lin[i-1] := EOS;
         (* move in line *)
         lpak := 0;
         repeat
           lpak := lpak + 1;
           pak[lpak] := lin[j+lpak-1];
         until pak[lpak] = EOS;
         lpak := lpak - 1;
         lin[i-1] := NEWLINE;
         if injpak(result) <> OKSTATUS then goto 2;
       end;
     end;
     result := OKSTATUS;
   2:
     inject := result;
   end;

   (* append lines after 'line' *)
   function append(line:integer) : statusRange;
   var
     result : statusRange;
     lin : lineString;
   begin
     etrace('append');
     if glob then begin
       result := ERRSTATUS;
     end
     else begin
       curln := line;
       result := NOSTATUS;
       while result = NOSTATUS do begin
         if not readcmd(lin,'*') then result := ERRSTATUS
         else if (lin[1] = PERIOD) and (lin[2] = NEWLINE) then
           result := OKSTATUS
         else if inject(lin) = ERRSTATUS then result := ERRSTATUS;
       end;
     end;
     append := result;
   end;

   (* delete - delete lines "from" through "to" *)
   function delete(fromLine, toLine : integer) : statusRange;
   label 1;
   var
     number : integer;
     k1, k2, k3 : linePtr;
   begin
     status := ERRSTATUS;
     if fromLine > 0 then begin
       status := INTSTATUS;
       curln := prevln(fromLine);
       k1 := getind(curln);
       k2 := k1@.next;
       for number := toLine-fromLine+1 downto 1 do begin
         if intrpt(ONE) then goto 1;
         k3 := k2@.next;
         linkup(k1,k3);
         freeline(k2);
         lastln := lastln - 1;
         k2 := k3;
       end;
       status := OKSTATUS;
     1:
       n0 := curln;
       k0 := k1;
     end;
     delete := status;
   end;

   (* clrbuf - initialize for new file *)
   procedure clrbuf;
   begin
     (* perhaps this routine should do something *)
   end;

   (* setbuf - initialize line buffer *)
   procedure setbuf(initial : boolean);
   var
     junk : statusRange;
   begin
     if initial then begin
       n0 := 0;
       k0 := alloline;
       k0@.next := k0;
       k0@.prev := k0;
       k0@.line[1] := 'L';
       k0@.line[2] := 'I';
       k0@.line[3] := 'N';
       k0@.line[4] := 'E';
       k0@.line[5] := '0';
       k0@.length := 5;
       lastln := 0;
       LINE0 := k0;
     end;
     junk := delete(1,lastln);
   end;

(* command interpretation routines *)


   (* ckp - check for 'p' after command *)
   function ckp(var pflag : char) : statusRange;
   begin
     etrace('   ckp');
     if lin[i] = PRINT then begin
       i := i + 1;
       pflag := PRINT;
     end
     else if lin[i] = LIST then begin
       i := i + 1;
       pflag := LIST;
     end
     else pflag := BLANK;
     if lin[i] = NEWLINE then status := OKSTATUS
     else status := ERRSTATUS;
     ckp := status;
   end;

   (* defalt - set defaulted line numbers *)
   function defalt(def1, def2 : integer) : statusRange;
   begin
     etrace('defalt');
     if nlines = 0 then begin;
       line1 := def1;
       line2 := def2;
     end;
     if (line1 > line2) or (line1 <= 0) then status := ERRSTATUS
     else status := OKSTATUS;
     defalt := status;
   end;

   (* skipbl - skip blanks and tabs at lin[i] *)
   procedure skipbl;
   begin
     while (lin[i] = BLANK) or (lin[i] = TAB) do i := i + 1;
   end;

   (* getfn - get file name from lin[i] *)
   function getfn(var fileName : fileNameString) : statusRange;
   var
     result : statusRange;
     k : integer;
   begin
     etrace(' getfn');
     result := ERRSTATUS;
     if lin[i] = BLANK then begin
       (* get new file name *)
       i := i + 1;
       skipbl;
       k := 1;
       while lin[i] <> NEWLINE do begin
         if k < MAXNAME then begin
           fileName[k] := lin[i];
           k := k + 1;
         end;
         i := i + 1;
       end;
       fileName[k] := EOS;
       if k > 1 then result := OKSTATUS;
     end
     else if (lin[i] = NEWLINE) and (savfil[1] <> EOS) then begin
       fileName := savfil;
       result := OKSTATUS;
     end;
     (* else error *)
     if (result = OKSTATUS) and (savfil[1] = EOS) then
       savfil := fileName; (* if no old name, save new one *)
     getfn := result;
   end;

   (* ptscan - scan for next occurrence of pattern *)
   function ptscan(way : integer; var num0 : integer) : statusRange;
   label 1;
   var
     num : integer;
     k : linePtr;
   begin
     etrace('ptscan');
     num := curln;
     ptscan := INTSTATUS;
     repeat
       if intrpt(ONE) then goto 1;
       if way = FORW then num := nextln(num)
       else num := prevln(num);
       k := gettxt(num);
       if match(txt,pat) then begin
         num0 := num;
         ptscan := OKSTATUS;
         goto 1;
       end;
     until num = curln;
     ptscan := ERRSTATUS;
   1:
   end;

   (* optpat - make pattern if specified at lin[i] *)
   procedure optpat;
   var
     j : integer;
     delim : char;
   begin
     etrace('optpat');
     status := ERRSTATUS;
     if lin[i] <> EOS then begin
       delim := lin[i];
       i := i + 1;
       if (lin[i] = delim) and (pat[1] <> EOS) then
         status := OKSTATUS   (* use old pattern *)
       else if lin[i] <> EOS then begin
         j := makpat(lin,i,delim,pat);
         if j > 0 then begin
           i := j;
           status := OKSTATUS;
         end
         else pat[1] := EOS;
       end;
     end;
   end;

   (* getnum - convert one term to line number *)
   function getnum(var pnum : integer) : statusRange;
   var
     result : statusRange;
   begin
     etrace('getnum');
     result := OKSTATUS;
     if (lin[i] >= DIG0) and (lin[i] <= DIG9) then
       pnum := ctoi(lin,i)
     else if lin[i] = CURLINE then begin
       pnum := curln;
       i := i + 1;
     end
     else if lin[i] = LASTLINE then begin
       pnum := lastln;
       i := i + 1;
     end
     else if (lin[i] = SCAN) or (lin[i] = BACKSCAN) then begin
       optpat;  (* build pattern *)
       if status = ERRSTATUS then result := ERRSTATUS
       else if lin[i] = SCAN then begin
         getnum := ptscan(FORW,pnum);
         i := i + 1;
       end
       else begin
         getnum := ptscan(BACK,pnum);
         i := i + 1;
       end;
     end
     else result := EOFSTATUS;
     status := result;
     getnum := result;
     etrace('gotnum');
   end;

   (* getone - evaluate one line number expression *)
   function getone(var num0 : integer) : statusRange;
   label 1;
   var
     istart, mul, num, pnum : integer;
     result : statusRange;
   begin
     etrace('getone');
     istart := i;
     num := 0;
     skipbl;
     if (lin[i] = PLUS) or (lin[i] = MINUS) then begin
       num := curln;
       status := OKSTATUS;
     end
     else status := getnum(num);
     while status = OKSTATUS do begin
       skipbl;
       if lin[i] = PLUS then mul := +1
       else if lin[i] = MINUS then mul := -1
       else begin
         status := EOFSTATUS;
         goto 1;
       end;
       i := i + 1;
       skipbl;
       if getnum(pnum) = OKSTATUS then num := num + mul * pnum
       else if status = EOFSTATUS then begin
         num := num + mul;
         status := OKSTATUS;
       end;
     end;
   1:
     if (status = ERRSTATUS) or (status = INTSTATUS) then result := status
     else if (num < 0) or (num > lastln) then result := ERRSTATUS
     else if i <= istart then result := EOFSTATUS
     else result := OKSTATUS;
     num0 := num;
     status := result;
     getone := result;
     etrace('gotone');
   end;

   (* getlst - collect line numbers (if any) at lin[i] *)
   procedure getlst;
   label 1;
   var
     num : integer;
   begin
     etrace('getlst');
     line2 := 0;
     nlines := 0;
     while getone(num) = OKSTATUS do begin
       line1 := line2;
       line2 := num;
       nlines := nlines + 1;
       if (lin[i] <> COMMA) and (lin[i] <> SEMICOL) then goto 1;
       if lin[i] = SEMICOL then curln := num;
       i := i + 1;
     end;
   1:
     if nlines > 2 then nlines := 2;
     if nlines = 0 then line2 := curln;
     if nlines <= 1 then line1 := line2;
     if status = EOFSTATUS then status := OKSTATUS;
     etrace('gotlst');
     (*writeln(debug,line1,line2,nlines);*)
   end;

   (* getrhs - get substitution string for "s" command *)
   function getrhs(var sub : patternString; var gflag : boolean) : statusRange;
   var
     delim : char;
     j : integer;
     result : statusRange;
   begin
     etrace('getrhs');
     result := ERRSTATUS;
     gflag := FALSE;
     if lin[i] <> EOS then begin
       delim := lin[i];
       i := i + 1;
       if lin[i] <> EOS then begin
         j := maksub(lin,i,delim,sub);
         if j > 0 then begin
           i := j + 1;
           if lin[i] = GLOBAL then begin
             i := i + 1;
             gflag := TRUE;
           end;
           result := OKSTATUS;
         end;
       end;
     end;
     status := result;
     getrhs := result;
   end;

(* command routines *)


   (* dolist - print lines fromLine through toLine with all chars visible *)
   function dolist(fromLine, toLine : integer) : statusRange;
   label 1;
   var
     line, k, m : integer;
     j : linePtr;
     ch : char;
     numb : array [1..2] of char;
     junk : integer;
   begin
     dolist := ERRSTATUS;
     if fromLine > 0 then begin
       dolist := INTSTATUS;
       for line := fromLine to toLine do begin
         if intrpt(ONE) then goto 1;
         j := gettxt(line);
         k := 1;
         while txt[k] <> NEWLINE do begin
           ch := txt[k];
           if (ch=' ')or((ch>='')and(ch<='&'))or((ch>='!')and(ch<='/'))
             or((ch>=',')and(ch<='?'))or((ch>='`')and(ch<='#'))
             or((ch>='''')and(ch<='"'))or((ch>='a')and(ch<='i'))
             or((ch>='j')and(ch<='r'))or((ch>='s')and(ch<='z'))
             or(ch='¯')or(ch='')or(ch='[')or(ch=']')or(ch='\')
             or((ch>='A')and(ch<='I'))or((ch>='J')and(ch<='R'))
             or((ch>='S')and(ch<='Z'))or((ch>='0')and(ch<='9')) then
             write(termout,ch)
           else begin
             if ch = ESCAPE then write(termout,ESCAPE,ESCAPE)
             else if ch = NEWLINE then write(termout,ESCAPE,LETN)
             else if ch = TAB then write(termout,ESCAPE,LETT)
             else begin
               m := ord(ch) mod 16;
               if m > 9 then numb[2] := chr(m-10+ord(LETA))
               else numb[2] := chr(m+ord(DIG0));
               m := ord(ch) div 16;
               if m > 9 then numb[1] := chr(m-10+ord(LETA))
               else numb[1] := chr(m+ord(DIG0));
               write(termout,ESCAPE,numb);
             end;
           end;
           k := k + 1;
         end;
         writeln(termout);
         curln := line;
       end;
       dolist := OKSTATUS;
     end;
   1:
   end;

   (* doprnt - print lines fromLine through toLine *)
   function doprnt(fromLine, toLine : integer) : statusRange;
   label 1;
   var
     line : integer;
     j : linePtr;
   begin
     (*writeln(debug,'doprnt');*)
     doprnt := ERRSTATUS;
     if fromLine > 0 then begin
       doprnt := INTSTATUS;
       for line := fromLine to toLine do begin
         if intrpt(ONE) then goto 1;
         j := gettxt(line);
         writeln(termout,txt:lpak);
         (*writeln(debug,'txt=',txt:lpak);*)
         curln := line;
       end;
       doprnt := OKSTATUS;
     end;
   1:
   end;

   (* doread - read 'file' after 'line' *)
   function doread(line : integer; fileName : fileNameString) : statusRange;
   label 1;
   var
     errNum, number : integer;
     result : statusRange;
   begin
     result := ERRSTATUS;
     errNum := open(fileName,DIRIN);
     if errNum = 0 then begin
       result := OKSTATUS;
       curln := line;
       for number := 0 to MAXINT do begin
         if intrpt(ONE) then begin
           result := INTSTATUS;
           goto 1;
         end;
         readline(filex,pak,lpak);
         if lpak < 0 then goto 1;
         if injpak(result) <> OKSTATUS then goto 1;
       end;
     1:
       reset(filex);
       writeln(termout,number:1);
     end;
     doread := result;
   end;

   (* dowrit - write fromLine through toLine into file *)
   function dowrit(fromLine, toLine : integer; fileName : fileNameString)
           : statusRange;
   label 1;
   var
     errNum, number : integer;
     line : integer;
     k : linePtr;
   begin
     dowrit := ERRSTATUS;
     errNum := open(fileName,DIROUT);
     if errNum = 0 then begin
       dowrit := OKSTATUS;
       number := 0;
       for line := fromLine to toLine do begin
         if intrpt(ONE) then begin
           dowrit := INTSTATUS;
           goto 1;
         end;
         k := getpak(line);
         writeln(filex,pak:lpak);
         number := number + 1;
       end;
     1:
       reset(filex);
       writeln(termout,number:1);
     end;
   end;

   (* move - move "line1" through "line2" after "line3" *)
   function move(line3 : integer) : statusRange;
   var
     k0, k1, k2, k3, k4, k5 : linePtr;
     line4 : integer;
   begin
     line4 := line3;
     if (line1 <= 0) or ((line1 <= line4) and (line4 <= line2)) then
       move := ERRSTATUS
     else begin
       k0 := getind(prevln(line1));
       k1 := getind(line1);
       k2 := getind(line2);
       k3 := getind(nextln(line2));
       k4 := getind(line4);
       k5 := getind(nextln(line4));
       linkup(k0,k3);
       if line4 > line1 then begin
         curln := line4;
       end
       else curln := line4 + (line2 - line1 + 1);
       linkup(k4,k1);
       linkup(k2,k5);
       move := OKSTATUS;
     end;
   end;

   (* subst - substitute "sub" for occurrences of pattern *)
   function subst(sub : patternString; gflag : boolean) : statusRange;
   label 1, 2;
   var
     newString : lineString;
     j, k, lastm, line, m : integer;
     junk1 : linePtr;
     junk2 : boolean;
     gotcha : statusRange;
     subbed : boolean;
   begin
     etrace(' subst');
     subst := ERRSTATUS;
     if line1 > 0 then begin
       subst := INTSTATUS;
       gotcha := ERRSTATUS;
       for line := line1 to line2 do begin
         if intrpt(ONE) then goto 1;
         j := 1;
         subbed := FALSE;
         junk1 := gettxt(line);
         lastm := 0;
         k := 1;
         while txt[k] <> EOS do begin
           if gflag or not subbed then
             m := amatch(txt,k,pat)
           else m := 0;
           if (m > 0) and (lastm <> m) then begin (* replace matched text *)
             subbed := TRUE;
             catsub(txt,k,m,sub,newString,j,MAXLINE);
             lastm := m;
           end;
           if (m = 0) or (m = k) then begin (* no match or null match *)
             junk2 := addset(txt[k],newString,j,MAXLINE);
             k := k + 1;
           end
           else k := m; (* skip matched text *)
         end;
         if subbed then begin
           if not addset(EOS,newString,j,MAXLINE) then goto 2;
           gotcha := delete(line,line);   (* remembers dot *)
           if gotcha <> OKSTATUS then goto 2;
           if inject(newString) = ERRSTATUS then begin
             subst := ERRSTATUS;
             goto 1;
           end;
         end;
       end;
     2:
       subst := gotcha;
     end;
   1:
   end;

(* global command execution routines *)

   (* docmd - handle all commands except globals *)
   procedure docmd;
   var
     fileName : fileNameString;
     sub : patternString;
     ch : char;
     line3 : integer;
     gflag : boolean;
     pflag : char;
     ix : integer;
   begin
     etrace(' docmd');
     pflag := BLANK;   (* may be set by d, m, s *)
     status := ERRSTATUS;
     ch := lin[i];
     if lin[i] <> EOS then i := i + 1;
     case ch of
       APPENDCOM: begin
         if lin[i] = NEWLINE then status := append(line2);
       end;
       BLOCK: begin
         if nlines <> 1 then status := ERRSTATUS
         else begin
           increment := line2;
           status := OKSTATUS;
         end;
       end;
       CHANGE: begin
         if lin[i] = NEWLINE then
           if defalt(curln,curln) = OKSTATUS then
             if delete(line1,line2) = OKSTATUS then
               status := append(prevln(line1));
       end;
       DELCOM: begin
         if ckp(pflag) = OKSTATUS then
           if defalt(curln,curln) = OKSTATUS then
             if delete(line1,line2) = OKSTATUS then
               if nextln(curln) <> 0 then curln := nextln(curln);
       end;
       INSERT: begin
         if lin[i] = NEWLINE then status := append(prevln(line2));
       end;
       PRINTCUR: begin
         if ckp(pflag) = OKSTATUS then begin
           writeln(termout,line2:1);
         end;
       end;
       MOVECOM: begin
         if getone(line3) = EOFSTATUS then status := ERRSTATUS;
         if status = OKSTATUS then
           if ckp(pflag) = OKSTATUS then
             if defalt(curln,curln) = OKSTATUS then status := move(line3);
       end;
       SUBSTITUTE: begin
         optpat;
         if status = OKSTATUS then
           if getrhs(sub,gflag) = OKSTATUS then
             if ckp(pflag) = OKSTATUS then
               if defalt(curln,curln) = OKSTATUS then
                 status := subst(sub,gflag);
       end;
       ENTER: begin
         if nlines = 0 then
           if getfn(fileName) = OKSTATUS then begin
             savfil := fileName;
             clrbuf;
             setbuf(FALSE);
             status := doread(0,fileName);
           end;
       end;
       PRINTFILE: begin
         if nlines = 0 then
           if getfn(fileName) = OKSTATUS then begin
             savfil := fileName;
             ix := 1;
             while savfil[ix] <> EOS do ix := ix + 1;
             writeln(termout,savfil:ix-1);
             status := OKSTATUS;
           end;
       end;
       READCOM: begin
         if getfn(fileName) = OKSTATUS then status := doread(line2,fileName);
       end;
       WRITECOM: begin
         if getfn(fileName) = OKSTATUS then
           if defalt(1,lastln) = OKSTATUS then
             status := dowrit(line1,line2,fileName);
       end;
       PRINT: begin
         if lin[i] = NEWLINE then
           if defalt(curln,curln) = OKSTATUS then
             status := doprnt(line1,line2);
       end;
       LIST: begin
         if lin[i] = NEWLINE then
           if defalt(curln,curln) = OKSTATUS then
             status := dolist(line1,line2);
       end;
       QUERY: begin
         if lin[i] = NEWLINE then
           if nlines = 0 then begin
             etrace('     ?');
             (* qrymem; *) writeln(termout,'not yet implemented');
             status := OKSTATUS;
           end;
       end;
       NEWLINE: begin
         if nlines = 0 then begin
           line1 := nextln(curln);
           line2 := line1 + increment - 1;
           if line2 > lastln then line2 := lastln;
         end;
         status := doprnt(line1,line2);
       end;
       QUIT: begin;
         if (lin[i] = NEWLINE) and (nlines = 0) and not glob then
           status := EOFSTATUS;
       end;
     (* else status is ERRSTATUS *)
     end;
     if (status = OKSTATUS) and (pflag = PRINT) then
       status := doprnt(curln,curln)
     else if (status = OKSTATUS) and (pflag = LIST) then
       status := dolist(curln,curln);
   end;

   (* ckglob - if global prefix, mark lines to be affected *)
   procedure ckglob;
   label 1, 2;
   var
     line : integer;
     gflag : boolean;
     k : linePtr;
   begin
     etrace('ckglob');
     if (lin[i] <> GLOBAL) and (lin[i] <> EXCLUDE) then begin
       glob := FALSE;
       status := EOFSTATUS;
     end
     else begin
       glob := TRUE;
       gflag := lin[i] = GLOBAL;
       i := i + 1;
       optpat;
       if status = OKSTATUS then status := defalt(1,lastln);
       if status = OKSTATUS then begin
         i := i + 1;
         for line := line1 to line2 do begin
           if intrpt(ONE) then begin
             status := INTSTATUS;
             goto 1;
           end;
           k := gettxt(line);
           k@.mark := match(txt,pat) = gflag;
         end;
       1:
         if status = OKSTATUS then begin
           line := nextln(line2);
           while line <> line1 do begin
             if intrpt(ONE) then begin
               status := INTSTATUS;
               goto 2;
             end;
             k := getind(line);
             k@.mark := FALSE;
             line := nextln(line);
           end;
         2:
         end;
       end;
     end;
   end;

   (* doglob - do command at lin[i] on all marked lines *)
   procedure doglob(var cursav : integer);
   var
     number, istart, line : integer;
     k : linePtr;
   begin
     etrace('doglob');
     status := OKSTATUS;
     number := 0;
     line := line1;
     istart := i;
     repeat
       k := getind(line);
       if intrpt(ONE) then status := INTSTATUS
       else if k@.mark then begin
         k@.mark := FALSE;
         curln := line;
         cursav := curln;
         i := istart;
         getlst;
         if status = OKSTATUS then docmd;
         if status = OKSTATUS then number := 0;
       end
       else begin
         line := nextln(line);
         number := number + 1;
       end;
     until (number > lastln) or (status <> OKSTATUS);
   end;

(* global initialization *)

   (* initialize - perform initialization *)
   procedure initialize;
   var
     tempstr34 : array [1..34] of char;
     assgstr : assignString;
     i : integer;
     dummy : boolean;
   begin
     tempstr34 := 'ASSIGN TERMIN  TO TERMINAL INPUT ;';
     for i := 1 to 34 do assgstr[i] := tempstr34[i];
     i := assign(assgstr);
     if i <> 0 then writeln(output,'error in assign of termin',i);
     tempstr34 := 'ASSIGN TERMOUT TO TERMINAL OUTPUT;';
     for i := 1 to 34 do assgstr[i] := tempstr34[i];
     i := assign(assgstr);
     if i <> 0 then writeln(output,'error in assign of termout',i);
     EOS := chr(0);
     TAB := chr(9);
     ONE := 1;
     ZERO := 0;
     DITTO := chr(1);
     terminopen := FALSE;
     freeList := NIL;
     rewrite(termout);
     dummy := intrpt(ZERO);
     increment := 1;
   end;

(*******************************************************************)
begin

   (****************)
   (* main program *)
   (****************)

   (* initialize *)
   initialize;

   setbuf(TRUE);

   pat[1] := EOS;
   savfil[1] := EOS;
   (*??? look for argument, if possible *)
   status := OKSTATUS;
   while status <> EOFSTATUS do if readcmd(lin,'.') then begin
     i := 1;
     etrace('  edit');
     cursav := curln;
     getlst;
     if status = OKSTATUS then begin
       ckglob;
       if status = OKSTATUS then doglob(cursav)
       else if status = EOFSTATUS then docmd;
     end;
     etrace('  exit');
     if status = ERRSTATUS then begin
       writeln(termout,'?');
       curln := cursav;
     end
     else if status = INTSTATUS then writeln(termout,'!');
   end;
   clrbuf;
end.
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB EIGHTQNS EXT PAS HEX -
PROGRAM EIGHTQUEENS(OUTPUT) ;
VAR I : INTEGER ;
    A : ARRAY[1..8] OF BOOLEAN ;
    B : ARRAY[2..16] OF BOOLEAN ;
    C : ARRAY[-7..7] OF BOOLEAN ;
    X : ARRAY[1..8] OF INTEGER ;
    SAFE : BOOLEAN ;
PROCEDURE TRYCOL(J : INTEGER ) ;
         VAR I, K : INTEGER ;
         PROCEDURE SETQUEEN ;
         BEGIN A[I]:=FALSE ; B[I+J]:=FALSE ; C[I-J]:=FALSE
         END ;
         PROCEDURE REMOVEQUEEN ;
         BEGIN A[I]:=TRUE ; B[I+J]:=TRUE ; C[I-J]:=TRUE
         END ;
              BEGIN
                    I:=0      ;
                   REPEAT I:=I+1 ; SAFE:=A[I] AND B[I+J] AND C[I-J] ;
                        IF SAFE THEN
                        BEGIN SETQUEEN ; X[J]:=I ;
                             IF J<8 THEN TRYCOL(J+1)
                               ELSE
                                 BEGIN
                                 FOR K := 1 TO 8 DO WRITE(X[K]) ;
                                 WRITELN()
                                 END ;
                             REMOVEQUEEN
                        END
                   UNTIL I=8
              END ;
              BEGIN FOR I:=1 TO 8 DO A[I]:=TRUE ;
                    FOR I:=2 TO 16 DO B[I]:=TRUE ;
                    FOR I:=-7  TO 7 DO C[I]:=TRUE ;
   TRYCOL (1);
   WRITELN('  * DONE *') ;
END.  (*EIGHT QUEENS*)
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB EXPAND   EXT PAS HEX -
  (*$P-,F-,D-,K-,Q+,I+,M-    *)
 PROGRAM EXPAND (INPUT,OUTPUT,QRR);
  (* THIS PROGRAM IS THE COMPLEMENT OF COMPRESS. COMPRESS
     COMPACTS A FILE BY ELIMINATING DUPLICATE CHARACTERS, AND
     EXPAND RESTORES IT TO ORIGINAL FORM. FOR SPECIFICATIONS OF
     THE COMPRESSED FILE SEE COMPRESS.
     EXPAND DOES HAVE TO LOOK OUT FOR CHECKSUM ERRORS AND MUST
     DISPLAY THEM ON OUTPUT.

     UPDATE RECORD:
                   04/27/79 COMMENT CORRECTIONS. CH


                                             CURT HILL
                                             225 NEBRASKA HALL
                                             UNIVERSITY OF NEBRASKA - LINCOLN
                                             LINCOLN, NEBRASKA
                                             68588
                                             (402) 472-3701


     THIS PROGRAM IS COPYRIGHT 1979, CURT HILL

     PERMISSION IS HEREBY GRANTED FOR ANY NONPROFIT USE OF ALL OR
     PARTS OF THIS PROGRAM, PROVIDED THIS NOTICE IS DISPLAYED.
     FURTHERMORE DISTRIBUTION AND IMPROVEMENT IS ENCOURAGED.
     I WOULD LIKE TO HEAR ABOUT AND/OR RECIEVE COPIES OF ANY
     IMPROVEMENTS THAT ARE WORTH MAKING TO THIS PROGRAM. CONTACT
     ME AT ABOVE ADDRESS OR SEE PASCAL NEWS FOR AN ADDRESS UPDATE.

               FREELY YOU HAVE RECIEVED, FREELY GIVE.
                                   *)


   VAR
     SPECIALCHAR1, SPECIALCHAR2 : CHAR;
     INCOUNT,              (* INPUT CHARACTERS *)
     OUTCOUNT,             (* OUTPUT LINES *)
     CHECKSUM : INTEGER;
     INCHAR : CHAR;
     TYPECODE : CHAR;
     ENDFILE  : BOOLEAN;

   PROCEDURE GETCHAR(VAR C : CHAR);
     (* GET A CHARACTER, HANDLE EOLN, INCREMENT INCOUNT *)

     BEGIN
       READ (INPUT,C);
       IF EOLN(INPUT) THEN READLN(INPUT);
       INCOUNT := INCOUNT + 1;
       END;     (* GETCHAR *)


   PROCEDURE PROCDUPE;
     (* WE HAVE RECIEVED SPECIAL CHARACTER 1 GENERATE A DUPLICATE *)
     VAR
       COUNT, LASTLINE : INTEGER;
       COUNTCHAR : CHAR;

     BEGIN     (* PROCDUPE *)
      GETCHAR (INCHAR);
      GETCHAR (COUNTCHAR);
      IF (ORD(COUNTCHAR) = 0) AND (INCHAR = SPECIALCHAR1)
         THEN ENDFILE := TRUE
         ELSE BEGIN
              FOR COUNT := 1 TO ORD(COUNTCHAR) DO
                  WRITE (QRR, INCHAR);
              CHECKSUM := CHECKSUM + ORD(INCHAR) + ORD(COUNTCHAR) +
                            ORD (SPECIALCHAR1);
              END;
      END;   (* PROCDUPE *)


   PROCEDURE PROCCHKSUM;
       (* PROCESS CHECK SUM CHARACTER *)
      VAR
        LASTLINE,
        COUNT : INTEGER;

      BEGIN
        OUTCOUNT := OUTCOUNT + 1;
        GETCHAR (INCHAR);
        COUNT :=  ORD(INCHAR);
        IF COUNT <> (CHECKSUM MOD 256)
           THEN WRITELN (OUTPUT,'  *** CHECK SUM ERROR ***',
                        '  IN LINE ',OUTCOUNT)
           ELSE;
        CHECKSUM := 0;
        END;       (* PROCCHKSUM *)



   BEGIN   (* EXPAND *)
     INCOUNT := 3;     (* INITIALIZE VARIABLES *)
     OUTCOUNT := 0;
     READ (INPUT, SPECIALCHAR1, SPECIALCHAR2, TYPECODE);
         (* OBTAIN SPECIAL CHARACTERS AND TYPE CODE *)
     CHECKSUM := ORD(SPECIALCHAR1) + ORD(SPECIALCHAR2) + ORD(TYPECODE);
     ENDFILE := FALSE;
     REWRITE (QRR);

     WHILE (NOT EOF(INPUT)) AND (NOT ENDFILE) DO
       BEGIN
       GETCHAR (INCHAR);
       IF INCHAR = SPECIALCHAR1
          THEN PROCDUPE
          ELSE IF INCHAR = SPECIALCHAR2
                  THEN PROCCHKSUM
                  ELSE BEGIN
                       CHECKSUM := CHECKSUM + ORD(INCHAR);
                       WRITE (QRR,INCHAR)
                       END;
       END;
       WRITELN (OUTPUT,' **** EXPAND ****');
       WRITELN (OUTPUT,' TOTAL INPUT CHARACTERS : ',INCOUNT:9);
       WRITELN (OUTPUT,' TOTAL OUTPUT LINES :     ',OUTCOUNT:9);
     END.  (* EXPAND *)
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB FFT      EXT PAS HEX -
(*$L+,C+,M-,D-*)
PROGRAM OSCAR(OUTPUT) ;

(* FAST FOURIER TRANSFER PROGRAM AFTER OSCAR BUENMAN, S. HAZEGHI. *)

CONST TWO_K = 1024 ;  TWO_K_2 = 513  ;  TWO_TO_15 = 32768 ;

TYPE COMPLEX = RECORD  RP: REAL ;  IP: REAL  END ;
     C_K_ARRAY = ARRAY [1..TWO_K] OF COMPLEX ;
     C_K_2_ARRAY = ARRAY [1..TWO_K_2] OF COMPLEX ;
     ALPHA = ARRAY [1..8] OF CHAR ;

VAR
     SEED, I: INTEGER ;
     Z, W : C_K_ARRAY ;
     E    : C_K_2_ARRAY ;

FUNCTION UNIFORM_10_10 : REAL ;
    VAR T : INTEGER ;
         BEGIN
         SEED := (14159269*SEED+231818041) MOD TWO_TO_15 ;
         UNIFORM_10_10 := 20.0*SEED/TWO_TO_15 - 10.0 ;
         END (* UNIFORM *) ;

PROCEDURE EXPTAB(N: INTEGER; VAR E: C_K_2_ARRAY) ;

    VAR  H: ARRAY [1..13] OF REAL ;
         HT: ARRAY ['A'..'9'] OF  0..15 ;
         I, J, K, L, M: INTEGER ;
         C : CHAR ;

    FUNCTION Z(HEX_STR: ALPHA): REAL ;
         VAR T: REAL ;  I: INTEGER ;
              BEGIN  T := 0.0;
              FOR I := 8 DOWNTO 2 DO T := HT[HEX_STR[I]]+T/16.0 ;
              Z := T
              END ;

         BEGIN (* EXPTAB *)
         FOR C := 'A' TO 'F' DO HT[C] := ORD(C)-ORD('A')+10 ;
         FOR C := '0' TO '9' DO HT[C] := ORD(C)-ORD('0') ;
         H[1] := Z('40B504F3'); H[2] := Z('408A8BD4') ;
         H[3] := Z('408281F7'); H[4] := Z('40809E8D') ;
         H[5] := Z('40802785'); H[6] := Z('408009DF') ;
         H[7] := Z('40800278'); H[8] := Z('4080009E');
         H[9] := Z('40800027'); H[10] := Z('4080000A');
         H[11] := Z('40800002'); H[12] := Z('40800001');
         H[13] := Z('40800000');
         M := N DIV 2 ;  L := M DIV 2 ;  J := 1 ;
         E[1].RP := 1.0 ;  E[1].IP := 0.0; E[L+1].RP := 0.0;
         E[L+1].IP := 1.0 ;  E[M+1].RP := -1.0 ; E[M+1].IP := 0.0 ;

              REPEAT I := L DIV 2 ;  K := I ;

                   REPEAT
                   E[K+1].RP := H[J]*(E[K+I+1].RP+E[K-I+1].RP) ;
                   E[K+1].IP := H[J]*(E[K+I+1].IP+E[K-I+1].IP) ;
                   K := K+L ;
                   UNTIL K > M ;

              IF J > 12 THEN J := 13  ELSE J := J+1 ;
              L := I ;
              UNTIL L <= 1 ;

         END (* EXPTAB *) ;

PROCEDURE FFT( N: INTEGER ;VAR Z, W: C_K_ARRAY ;
              VAR E: C_K_2_ARRAY ; SQRINV: REAL) ;

    VAR  I, J, K, L, M: INTEGER ;

         BEGIN  M := N DIV 2 ;  L := 1 ;

              REPEAT  K := 0 ;  J := L ;  I := 1 ;

                   REPEAT

                        REPEAT
                        W[I+K].RP := Z[I].RP+Z[M+I].RP ;
                        W[I+K].IP := Z[I].IP+Z[M+I].IP ;
                        W[I+J].RP := E[K+1].RP*(Z[I].RP-Z[I+M].RP)
                                     -E[K+1].IP*(Z[I].IP-Z[I+M].IP) ;
                        W[I+J].IP := E[K+1].RP*(Z[I].IP-Z[I+M].IP)
                                     +E[K+1].IP*(Z[I].RP-Z[I+M].RP) ;
                        I := I+1 ;
                        UNTIL I > J ;

                   K := J ;  J := K+L ;
                   UNTIL J > M ;

              Z := W ; (*FOR I := 1 TO N DO  Z[I] := W[I]  ;*)
              L := L+L ;
              UNTIL L > M ;

         FOR I := 1 TO N DO

              BEGIN
              Z[I].RP := SQRINV*Z[I].RP ;  Z[I].IP := -SQRINV*Z[I].IP
              END ;

         END ;

PROCEDURE PRINT_COMPLEX ;

    VAR I, J: INTEGER ;

         BEGIN  WRITELN() ;  I := 1 ;  J := 0 ;

              REPEAT  J := J+1 ;
              WRITE('    ',Z[I].RP:10,'  ',Z[I].IP:10) ;
              IF (J MOD 4) = 0 THEN WRITELN() ;
              I := I+17 ;
              UNTIL I > TWO_K ;

         WRITELN() ;
         END ;

    BEGIN (* OSCAR *)

    EXPTAB(TWO_K,E) ;
    SEED := 12345 ;
    FOR I := 1 TO TWO_K DO

         BEGIN
         Z[I].RP := UNIFORM_10_10 ;  Z[I].IP := UNIFORM_10_10 ;
         END ;

    PRINT_COMPLEX ;
    FFT(TWO_K,Z,W,E,SQRT(1.0/TWO_K)) ;  PRINT_COMPLEX ;
    FFT(TWO_K,Z,W,E,SQRT(1.0/TWO_K)) ;  PRINT_COMPLEX ;
    END (* OSCAR *) .
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB GCIRCLE  EXT PAS HEX -
PROGRAM  GREATC(INPUT, OUTPUT); (*$M-*)

  CONST  DEGSRADIANS = 57.29578;

  VAR  SIDEA,  SIDEB,  SIDEC,
       ANGLEA, ANGLEB, ANGLEC,
       AMINUSB, APLUSB,
       DELTA, PLUSMINUS,
       STRTLATMNTS, STRTLONMNTS,
       DESTLATMNTS,  DESTLONMNTS,
       STRTLAT, STRTLON,
       DESTLAT,  DESTLON:             REAL;

       DISTANCE, I, STEP,
       STRTLATDEGS, STRTLONDEGS,
       DESTLATDEGS,  DESTLONDEGS,
       LATDEGS, LATMNTS,
       LONDEGS, LONMNTS:       INTEGER;



FUNCTION  TAN(X: REAL):  REAL;

BEGIN  (* TAN *)
  TAN := SIN(X) / COS(X)
END;  (* TAN *)



FUNCTION  COT(X: REAL):  REAL;

BEGIN  (* COT *)
  COT := (1.0 / X) - (X / 3.0)
                   - (X * X * X / 45.0)
                   - (2.0 * X * X * X * X * X / 945.0)
                   - (X * X * X * X * X * X * X / 4725.0);
END;  (* COT *)



FUNCTION  ASIN(X: REAL):  REAL;

BEGIN  (* ASIN *)
  ASIN := X + (X * X * X / 6.0)
            + (3.0 * X * X * X * X * X / 40.0)
            + (15.0 * X * X * X * X * X * X * X / 336.0);
END;  (* ASIN *)




BEGIN  (* GREATCIRCLE *)
      READ(STRTLATDEGS, STRTLATMNTS, STRTLONDEGS, STRTLONMNTS);
      READ(DESTLATDEGS,  DESTLATMNTS,  DESTLONDEGS,  DESTLONMNTS) ;

      STRTLAT := STRTLATDEGS + (STRTLATMNTS / 60.0);
      STRTLON:= STRTLONDEGS + (STRTLONMNTS / 60.0);
      DESTLAT  := DESTLATDEGS  + (DESTLATMNTS  / 60.0);
      DESTLON := DESTLONDEGS  + (DESTLONMNTS  / 60.0);

      WRITELN('1STRTING LAT:      ', STRTLATDEGS:3,
                                           STRTLATMNTS:5);
      WRITELN(' STRTING LON:     ', STRTLONDEGS:3,
                                           STRTLONMNTS:5);
      WRITELN('0DESTINATION LAT:   ', DESTLATDEGS:3,
                                           DESTLATMNTS:5);
      WRITELN(' DESTINATION LON:  ', DESTLONDEGS:3,
                                           DESTLONMNTS:5);

      PLUSMINUS := 1.0;
      IF  STRTLON > DESTLON   THEN PLUSMINUS := -1.0;
      READ(STEP);

      SIDEA := (90.0 - DESTLAT) / DEGSRADIANS;
      SIDEB := (90.0 - STRTLAT)/ DEGSRADIANS;
      ANGLEC := ABS(STRTLON - DESTLON) / DEGSRADIANS;
      AMINUSB := 2.0 * (ARCTAN(SIN(0.5*(SIDEA-SIDEB))/
                          SIN(0.5*(SIDEA+SIDEB))*
                          COT(0.5*ANGLEC)));
      APLUSB  := 2.0 * (ARCTAN(COS(0.5*(SIDEA-SIDEB))/
                           COS(0.5*(SIDEA+SIDEB))*
                           COT(0.5*ANGLEC)));
      ANGLEA := (AMINUSB + APLUSB) / 2.0;
      SIDEC  := ASIN(SIN(ANGLEC) * SIN(SIDEA)/ SIN(ANGLEA));
      DISTANCE := TRUNC(0.5+SIDEC * 3963.2);
      WRITELN('0GREATCIRCLE DISTANCE = ', DISTANCE:6, ' STATUTE MILES');
      WRITELN('0');


      SIDEC  := SIDEB;
      ANGLEB := 0.0;
      DELTA  := ANGLEC / STEP;

      FOR I := 1 TO STEP+1  DO
        BEGIN
          AMINUSB := 2.0*(ARCTAN(SIN(0.5*(ANGLEA-ANGLEB))/
                                 SIN(0.5*(ANGLEA+ANGLEB))*
                                 TAN(0.5*SIDEC)));
          APLUSB  := 2.0*(ARCTAN(COS(0.5*(ANGLEA-ANGLEB))/
                                 COS(0.5*(ANGLEA+ANGLEB))*
                                 TAN(0.5*SIDEC)));
          SIDEA := (AMINUSB + APLUSB) / 2.0;
          LATDEGS  := TRUNC(90.0 - (SIDEA * DEGSRADIANS));
          LATMNTS  := TRUNC(0.5+((90.0 - (SIDEA * DEGSRADIANS))
                                           - LATDEGS) * 60.0);
          LONDEGS := TRUNC(STRTLONDEGS + ((ANGLEB * DEGSRADIANS)
                                                    * PLUSMINUS));
          LONMNTS := TRUNC(0.5+((STRTLON + ((ANGLEB *DEGSRADIANS)
                                     * PLUSMINUS)) - LONDEGS) * 60.0);
          IF  LONMNTS >= 60
              THEN
                BEGIN
                  LONDEGS := LONDEGS + 1;
                  LONMNTS := LONMNTS - 60;
                END;
         WRITELN(LATDEGS:3, LATMNTS:3,
                 LONDEGS:8, LONMNTS:3);
         ANGLEB := ANGLEB + DELTA;
        END  (* FOR LOOP *)
END  (* GREATCIRCLE *)  .
 27 46   45 26  39 12   16 22     (TYPICAL DATA FOR GREATCIRCLE)
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB INQUIRE  EXT PAS HEX -
(* after a program by A. Sale, published in Pascal News, CH July 79 *)

PROGRAM INVESTIGATEREPRESENTATION(OUTPUT);
        (* DETERMINE REAL NUMBER CHARACTERISTICS OF BASE MACHINE
           AND COMPILER.                  *)
VAR
    BASE,
    NUMBEROFDIGITS,
    I                      : INTEGER;
    ROUNDING               : BOOLEAN;
    EPSILON                : REAL;

 PROCEDURE ENQUIRY (VAR RADIX, DIGITS : INTEGER; VAR ROUNDS : BOOLEAN);

 VAR
    NUMBER,
    INCREMENT              : REAL;

 BEGIN  (* ENQUIRY *)
     (* FIND LARGE INTEGRAL VALUE JUST BEYOND INTEGER LIMITS *)
     NUMBER := 2;
     WHILE (((NUMBER+1)-NUMBER ) = 1 ) DO NUMBER := NUMBER * 2;
     (* MANUFACTURE THE NEXT LARGEST REAL VALUE *)
     INCREMENT := 2;
     WHILE ((NUMBER + INCREMENT) = NUMBER) DO
          INCREMENT := INCREMENT * 2;
     (* SUBTRACT THESE TO GIVE RADIX OF REPRESENTATION *)
     RADIX := TRUNC((NUMBER + INCREMENT) - NUMBER);
     (* SEE IF IT ROUNDS OR TRUNCATES BY ADDING (RADIX - 1)  *)
     ROUNDS := ((NUMBER + (RADIX + 1)) <> NUMBER);
     (* WORK OUT HOW MANY DIGITS IN MANTISSA *)
     DIGITS := 0;
     NUMBER := 1;
     WHILE (((NUMBER + 1) - NUMBER) = 1) DO
         BEGIN
          DIGITS := DIGITS + 1;
          NUMBER := NUMBER * RADIX;
         END;
     END;   (* ENQUIRY *)



BEGIN   (* MAIN PROGRAM *)
    (* FIND OUT BASIC PROPERTIES *)
    ENQUIRY(BASE,NUMBEROFDIGITS,ROUNDING);
    WRITELN(OUTPUT, ' BASE=',BASE:5);
    WRITELN(OUTPUT, ' NUMBER OF DIGITS=',NUMBEROFDIGITS:5);
    IF ROUNDING
       THEN WRITELN(OUTPUT, ' ROUNDED')
       ELSE WRITELN(OUTPUT, ' TRUNCATED');
    (* COMPUTE THE PRECISION BOUNDS *)
    EPSILON := 1;
    FOR I := 1 TO NUMBEROFDIGITS DO EPSILON := EPSILON/BASE;
    IF ROUNDING THEN EPSILON := EPSILON / 2;
    (* PRINT THE BEST AND WORST *)
    WRITELN(OUTPUT, ' BEST AND WORST PRECISIONS ARE ',
                     EPSILON,(EPSILON*BASE) );
END.
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB INVERT   EXT PAS HEX -
PROGRAM  INVERT(OUTPUT);  (*$M-*)

  CONST  ARRAYSIZE =  9;
         NUMBEROFINVERSIONS =  50;

  VAR  A:  ARRAY[1..ARRAYSIZE, 1..ARRAYSIZE] OF REAL;
       TEMP, SUM:   REAL;
       I, J, K, L:  INTEGER;

(* THIS PROGRAM DOES REPEATED INVERSIONS OF A HILBERT MATRIX *)

BEGIN  (* INVERT *)
  FOR I := 1 TO ARRAYSIZE  DO
      FOR J := 1 TO ARRAYSIZE  DO
          A[I,J] := 1.0 / (I + J - 1.0);         (* SET UP THE HILBERT MATRIX *)

  FOR L := 1 TO NUMBEROFINVERSIONS  DO
      BEGIN FOR I := 1 TO ARRAYSIZE  DO
                BEGIN TEMP := A[I,I];
                      A[I,I] := 1.0;
                      FOR J := 1 TO ARRAYSIZE  DO
                          A[I,J] := A[I,J] / TEMP;
                      FOR K := 1 TO ARRAYSIZE  DO
                          BEGIN IF K <> I  THEN
                                   BEGIN TEMP := A[K,I];
                                         A[K,I] := 0.0;
                                         FOR J := 1 TO ARRAYSIZE  DO
                                             A[K,J] := A[K,J] -
                                                       (TEMP * A[I,J])
                                   END
                          END
                END;
            IF ODD(L)  THEN
               BEGIN SUM := 0.0;
                     FOR I := 1 TO ARRAYSIZE  DO
                         FOR J := 1 TO ARRAYSIZE  DO
                             SUM := SUM + A[I,J];
                     WRITELN(' SUM = ', SUM:17)
               END
      END
END  (* INVERT *)  .
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB PASCREF  EXT PAS HEX -
PROGRAM PASCREF(INPUT,OUTPUT);      (*$D-,L+,M+   N.WIRTH  2.7.75  *)   00010000
(*CROSS REFERENCE GENERATOR FOR PASCAL PROGRAMS*)                       00020000
(*QUADRATIC QUOTIENT HASH METHOD*)                                      00030000
(*MODIFIED SLIGHTLY BY A. MICKEL 75/12/08 AND D. LALIBERTE              00040000
  78/03/15 TO PRODUCE PROCEDURE LIST AND SKIP COMPILER TITLE*)          00050000
(* PASCAL-6000 DEPENDENT CONSTRUCTS CHANGED. S.HAZEGHI,  02-15-79 *)    00060000
(* 6/86 - CORRECTIONS FOR COMPILER OUTPUT PROCESSING (LPP, LINE#)   *)  00070000
(*             INCREASED HASH TABLE SIZE; FIXED BRACED COMMENTS     *)  00080000
(*          G. POSTPISCHIL, EXPERT SYSTEM PROGRAMMING, INC. / 86180 *)  00090000
(*$D-  TESTS OFF*)                                                      00100000
LABEL 99;                                                               00110000
CONST P = 8999;     (*SIZE OF HASH TABLE*)                 (* 86180 *)  00120000
  NK = 33;          (*NO. OF KEYWORDS*)                                 00130000
  KLN = 10;         (*KEYLENGTH*)                                       00140000
  LPPG = 55;        (*NO. OF LINES PER PAGE*)                           00150000
  LLMAX = 132;      (*LINE LENGTH DEFAULT MAX*)                         00160000
  LLMIN = 72;       (*LINE LENGTH MINIMUM*)                             00170000
  MAXN = 10000;     (*MAX NO. OF LINES*)                                00180000
  DGPN =  6;        (*NO. OF DIGITS PER NUMBER*)                        00190000
  LITL = 3;         (*NUMBER OF LINES IN COMPILER TITLE*)               00200000
  ADDRWIDTH = 11;        (*NUMBER OF DIGITS IN CODE ADDRESS / 86180 *)  00210000
  EMPTY = '          ';                                                 00220000
  STARS = ' *****';                                                     00230000
TYPE INDEX = 0..P;                                                      00240000
  ALFA = PACKED ARRAY [1..KLN] OF CHAR;                                 00250000
  REF = @ITEM;                                                          00260000
  WORD = RECORD KEY: ALFA;                                              00270000
           FIRST: REF;                                                  00280000
         END ;                                                          00290000
  ITEM = PACKED RECORD                                                  00300000
           LNO: 0..MAXN;                                                00310000
           NEXT: REF                                                    00320000
         END ;                                                          00330000
  PROCREF = @PROC;  (*PROCEDURE OR FUNCTION REFERENCE*)                 00340000
  PROC = PACKED RECORD                                                  00350000
           NAME: ALFA;                                                  00360000
           LNO: 0..MAXN;                                                00370000
           NEXT: PROCREF                                                00380000
         END ;                                                          00390000
VAR I: INDEX;                                                           00400000
  K: INTEGER;                                                           00410000
  M: INTEGER;       (*NO. OF LINES ON PAGE*)                            00420000
  N: INTEGER;       (*NO. OF LINES INPUT*)                              00430000
  LN: INTEGER;      (*CURRENT LINE NUMBER*)                             00440000
  OLDLN: INTEGER;               (* LINE NUMBER OF LAST LINE / 86180 *)  00450000
  LLNGOUT: INTEGER; (*LINE LENGTH FOR OUTPUT*)                          00460000
  LLNGIN: INTEGER;  (*LINE LENGTH FOR INPUT*)                           00470000
  CCOUNT: INTEGER;  (*CHARACTER COUNT IN LINE*)                         00480000
  NOPL: INTEGER;    (*NO. OF LINE-NUMBERS PER LINE*)                    00490000
  ID: RECORD CASE BOOLEAN OF                                            00500000
             FALSE: (A: ALFA);                                          00510000
             TRUE:  (ORD: INTEGER)                                      00520000
      END ;                                                             00530000
  KEY: ARRAY [1..NK] OF ALFA;                                           00540000
  PROCORFUNC,                                                           00550000
  COMPILERLISTING,                                                      00560000
  LINENUMBERS: BOOLEAN;                                                 00570000
  C1, C2, C3 : INTEGER;    (* ID, OCCUR, PROC. COUNTERS *)              00580000
  FIRSTPROC,                                                            00590000
  PROCPTR: PROCREF; (*POINTERS TO CHAIN OF PROCEDURES*)                 00600000
  T: ARRAY [INDEX] OF WORD;    (*HASH TABLE*)                           00610000
                                                                        00620000
                                                                        00630000
   FUNCTION LETTER(C: CHAR): BOOLEAN;                                   00640000
                                                                        00650000
     BEGIN                                                              00660000
     LETTER := (('A' <= C) AND (C <= 'Z')) OR                           00670000
               (('a' <= C) AND (C <= 'i')) OR                           00680000
               (('j' <= C) AND (C <= 'r')) OR                           00690000
               (('s' <= C) AND (C <= 'z')) ;                            00700000
     END ;                                                              00710000
                                                                        00720000
   FUNCTION DIGIT(C: CHAR): BOOLEAN ;                                   00730000
                                                                        00740000
     BEGIN                                                              00750000
     DIGIT := ('0' <= C) AND (C <= '9') ;                               00760000
     END ;                                                              00770000
                                                                        00780000
   FUNCTION SPECIAL(C: CHAR): BOOLEAN;                                  00790000
     BEGIN  SPECIAL := (C = '$') OR (C = '_')  END ;                    00800000
                                                                        00810000
FUNCTION NOKEY: BOOLEAN;                                                00820000
   VAR I,J,K: INTEGER;                                                  00830000
BEGIN I := 1; J := NK;   (*BINARY SEARCH*)                              00840000
  REPEAT K := (I+J) DIV 2;                                              00850000
    IF KEY[K] <= ID.A THEN I := K+1 ELSE J := K-1                       00860000
  UNTIL I > J;                                                          00870000
  IF J = 0 THEN NOKEY := TRUE ELSE                                      00880000
    NOKEY := KEY[J] <> ID.A                                             00890000
END (*NOKEY*) ;                                                         00900000
                                                                        00910000
PROCEDURE COUNTLINE;                                                    00920000
BEGIN                                                                   00930000
  IF M >= LPPG THEN                                                     00940000
    BEGIN PAGE(OUTPUT); WRITELN(OUTPUT); """WRITELN(OUTPUT); """        00950000
      M := 0                                                            00960000
    END;                                                                00970000
  M := M + 1                                                            00980000
END (*COUNTLINE*) ;                                                     00990000
                                                                        01000000
PROCEDURE ADVANCE;                                                      01010000
BEGIN                                                                   01020000
  WRITE(OUTPUT,INPUT@); GET(INPUT);                                     01030000
  CCOUNT := CCOUNT + 1;                                                 01040000
  IF CCOUNT = LLNGIN THEN                                               01050000
    WHILE NOT EOLN(INPUT) DO                                            01060000
      BEGIN WRITE(OUTPUT,INPUT@); GET(INPUT);                           01070000
      END                                                               01080000
END (*ADVANCE*);                                                        01090000
                                                                        01100000
PROCEDURE SPACE(J: INTEGER);                                            01110000
BEGIN                                                                   01120000
  REPEAT J := J-1; WRITELN(OUTPUT); COUNTLINE                           01130000
  UNTIL J = 0                                                           01140000
END (*SPACE*) ;                                                         01150000
                                                                        01160000
PROCEDURE SKIPCOMPILERTITLE;                               (* 86180 *)  01170000
                                                           (* 86180 *)  01180000
  VAR I: INTEGER;                                          (* 86180 *)  01190000
BEGIN                                                      (* 86180 *)  01200000
  COMPILERLISTING := INPUT@ = '1';                         (* 86180 *)  01210000
  PAGE(OUTPUT);                                            (* 86180 *)  01220000
  IF COMPILERLISTING THEN                                  (* 86180 *)  01230000
  BEGIN I := 0; GET(INPUT);                                (* 86180 *)  01240000
    WHILE I < LITL DO                                      (* 86180 *)  01250000
      BEGIN I := I + 1;                                    (* 86180 *)  01260000
        WHILE NOT EOLN(INPUT) DO                           (* 86180 *)  01270000
          ADVANCE;                                         (* 86180 *)  01280000
        READLN; WRITELN(OUTPUT);                           (* 86180 *)  01290000
      END;                                                 (* 86180 *)  01300000
    """COUNTLINE;"""      (* GENERATES INCORRECT LINES/PAGE / 86180 *)  01310000
         M := 0;(* SET LINE COUNT CORRECTLY - WE JUST EJECTED/86180 *)  01320000
    LINENUMBERS := TRUE                                    (* 86180 *)  01330000
  END ELSE                                                 (* 86180 *)  01340000
  BEGIN WRITELN(OUTPUT); WRITELN(OUTPUT);                  (* 86180 *)  01350000
    LINENUMBERS := """INPUT@ IN ['0'..'9']""" DIGIT(INPUT@)(* 86180 *)  01360000
  END;                                                     (* 86180 *)  01370000
END (*SKIPCOMPILERTITLE*) ;                                (* 86180 *)  01380000
                                                                        01390000
PROCEDURE HEADSHOP;                                        (* 86180 *)  01400000
BEGIN                                                      (* 86180 *)  01410000
  IF COMPILERLISTING AND NOT EOLN AND (INPUT@ = '1')       (* 86180 *)  01420000
    THEN SKIPCOMPILERTITLE                                 (* 86180 *)  01430000
END; (* HEADSHOP *)                                        (* 86180 *)  01440000
                                                           (* 86180 *)  01450000
PROCEDURE FLUSHLINE;                                       (* 86180 *)  01460000
BEGIN                                                      (* 86180 *)  01470000
  WHILE NOT EOLN DO                                        (* 86180 *)  01480000
    ADVANCE;                                               (* 86180 *)  01490000
END; (* FLUSHLINE *)                                       (* 86180 *)  01500000
                                                                        01510000
PROCEDURE BLANKSKIP;                                       (* 86180 *)  01520000
BEGIN                                                      (* 86180 *)  01530000
  IF NOT EOLN AND (INPUT@ = ' ') THEN                      (* 86180 *)  01540000
    ADVANCE;                                               (* 86180 *)  01550000
END; (* BLANKSKIP *)                                       (* 86180 *)  01560000
                                                                        01570000
PROCEDURE NEWLINE;                                                      01580000
BEGIN CCOUNT := 0;                                                      01590000
  HEADSHOP;      (* CHECK FOR COMPILER TITLE *)            (* 86180 *)  01600000
  OLDLN := LN;                         (* SAVE PRIOR LINE # / 86180 *)  01610000
  LN := 0;                                                              01620000
  IF N < MAXN THEN                                                      01630000
  BEGIN COUNTLINE;  N := N + 1;                                         01640000
    IF COMPILERLISTING THEN                                             01650000
       BEGIN                                                            01660000
       WHILE NOT EOLN AND (INPUT@ <>  ')') DO              (* 86180 *)  01670000
         BEGIN                                             (* 86180 *)  01680000
         FOR I := 1 TO 9 DO                                (* 86180 *)  01690000
           BLANKSKIP;                                      (* 86180 *)  01700000
         IF NOT DIGIT(INPUT@) THEN FLUSHLINE;              (* 86180 *)  01710000
         WHILE DIGIT(INPUT@) DO                            (* 86180 *)  01720000
             BEGIN LN := 10*LN + ORD(INPUT@) - ORD('0');   (* 86180 *)  01730000
             ADVANCE;                                      (* 86180 *)  01740000
             END;                                          (* 86180 *)  01750000
         FOR I := 1 TO ADDRWIDTH DO                        (* 86180 *)  01760000
           IF NOT EOLN THEN ADVANCE;                       (* 86180 *)  01770000
       END;                                                (* 86180 *)  01780000
         IF NOT EOLN AND (INPUT@ <> ')') THEN FLUSHLINE    (* 86180 *)  01790000
                            ELSE ADVANCE;                  (* 86180 *)  01800000
       END                                                 (* 86180 *)  01810000
    ELSE WRITE(OUTPUT,' ');                                             01820000
    IF LINENUMBERS THEN                                                 01830000
      BEGIN                                                             01840000
      WHILE DIGIT(INPUT@) DO                                            01850000
"""   WHILE INPUT@ IN ['0'..'9'] DO   """                               01860000
        BEGIN LN := 10*LN + ORD(INPUT@) - ORD('0');                     01870000
          ADVANCE;                                                      01880000
        END;                                                            01890000
      END                                                               01900000
    ELSE BEGIN                                                          01910000
      LN := N;  WRITE(OUTPUT,LN:6, ') ')                                01920000
      END                                                               01930000
    END                                                                 01940000
  ELSE BEGIN                                                            01950000
    WRITELN(STARS, ' TEXT TOO LONG', STARS);                            01960000
    "GOTO 99"  EXIT(99);                                                01970000
    END;                                                                01980000
    IF LN = 0 THEN LN := OLDLN         (* REL. TO PRIOR LINE /86180 *)  01990000
END (*NEWLINE*) ;                                                       02000000
                                                                        02010000
PROCEDURE SEARCH;   (*MODULO P HASH SEARCH*)                            02020000
  VAR H,D: INDEX;                                                       02030000
      X: REF; F: BOOLEAN;                                               02040000
      K: INTEGER;                                                       02050000
BEGIN  I := ABS(ID.ORD);  H := I MOD P;                                 02060000
  F := FALSE; D := 1;                                                   02070000
  NEW(X); X@.LNO := LN;                                                 02080000
  REPEAT                                                                02090000
    IF T[H].KEY = ID.A THEN                                             02100000
    BEGIN (*FOUND*) F := TRUE;                                          02110000
      X@.NEXT := T[H].FIRST; T[H].FIRST := X;                           02120000
    END ELSE                                                            02130000
    IF T[H].KEY = EMPTY THEN                                            02140000
    BEGIN (*NEW ENTRY*) F := TRUE;                                      02150000
      T[H].KEY := ID.A;                                                 02160000
      T[H].FIRST := X; X@.NEXT := NIL                                   02170000
    END ELSE                                                            02180000
    BEGIN (*COLLISION*) H := H+D; D := D+2;                             02190000
      IF H >= P THEN H := H-P;                                          02200000
      IF D = P THEN                                                     02210000
        BEGIN WRITELN(OUTPUT); WRITELN(STARS,' TABLE FULL',STARS);      02220000
        """GOTO 99"""   EXIT(99);                                       02230000
        END                                                             02240000
    END                                                                 02250000
  UNTIL F                                                               02260000
END (*SEARCH*) ;                                                        02270000
                                                                        02280000
PROCEDURE SORT(MIN, MAX: INTEGER);                                      02290000
                                                                        02300000
(* QUICKSORT WITH BOUNDED RECURSION DEPTH *)                            02310000
(* REQUIRES MIN <= MAX *)                                               02320000
                                                                        02330000
   VAR                                                                  02340000
         LOW,                                                           02350000
        HIGH: INDEX;                                                    02360000
      MIDKEY: ALFA;                                                     02370000
        TEMP: WORD;                                                     02380000
                                                                        02390000
   BEGIN                                                                02400000
      REPEAT (*PICK SPLIT POINT*)                                       02410000
         MIDKEY := T[(MIN + MAX) DIV 2].KEY;                            02420000
         LOW := MIN;                                                    02430000
         HIGH := MAX;                                                   02440000
         REPEAT (*PARTITION*)                                           02450000
            WHILE T[LOW].KEY < MIDKEY DO                                02460000
               LOW := LOW + 1;                                          02470000
            WHILE T[HIGH].KEY > MIDKEY DO                               02480000
               HIGH := HIGH - 1;                                        02490000
            IF LOW <= HIGH THEN                                         02500000
               BEGIN                                                    02510000
                  TEMP := T[LOW];                                       02520000
                  T[LOW] := T[HIGH];                                    02530000
                  T[HIGH] := TEMP;                                      02540000
                  LOW := LOW + 1;                                       02550000
                  HIGH := HIGH - 1                                      02560000
               END;                                                     02570000
         UNTIL LOW > HIGH;                                              02580000
                                                                        02590000
         (*RECURSIVELY SORT SHORTER SUB-SEGMENT*)                       02600000
         IF HIGH - MIN < MAX - LOW                                      02610000
         THEN                                                           02620000
            BEGIN                                                       02630000
               IF MIN < HIGH THEN                                       02640000
                  SORT(MIN, HIGH);                                      02650000
               MIN := LOW                                               02660000
            END                                                         02670000
         ELSE                                                           02680000
            BEGIN                                                       02690000
               IF LOW < MAX THEN                                        02700000
                  SORT(LOW, MAX);                                       02710000
               MAX := HIGH                                              02720000
            END                                                         02730000
      UNTIL MAX <= MIN                                                  02740000
   END (*SORT*);                                                        02750000
                                                                        02760000
                                                                        02770000
PROCEDURE NOTEPROC;   (*NOTE INSTANCE OF PROCEDURE OR FUNCTION*)        02780000
  VAR P: PROCREF;                                                       02790000
BEGIN PROCORFUNC := FALSE;                                              02800000
  NEW(P); PROCPTR@.NEXT := P;                                           02810000
  P@.NAME := ID.A; P@.LNO := LN; P@.NEXT := NIL;                        02820000
  PROCPTR := P                                                          02830000
END (*NOTEPROC*) ;                                                      02840000
                                                                        02850000
PROCEDURE PRINTWORD(W: WORD);                                           02860000
  VAR L: INTEGER; X,Y,Z: REF;                                           02870000
BEGIN COUNTLINE; WRITE(OUTPUT,' ', W.KEY);                              02880000
  X := W.FIRST; Y := X@.NEXT; X@.NEXT := NIL;                           02890000
  WHILE Y <> NIL DO                                                     02900000
    BEGIN Z := Y@.NEXT; Y@.NEXT := X; X := Y; Y := Z                    02910000
    END ;                                                               02920000
  L := 0;                                                               02930000
  REPEAT                                                                02940000
    IF L = NOPL THEN                                                    02950000
      BEGIN L := 0; WRITELN(OUTPUT); COUNTLINE; WRITE(OUTPUT,' ', EMPTY)02960000
      END;                                                              02970000
    L := L+1; WRITE(OUTPUT,X@.LNO: DGPN); X := X@.NEXT; C2 := C2+1;     02980000
  UNTIL X = NIL;                                                        02990000
  WRITELN(OUTPUT);                                                      03000000
END (*PRINTWORD*) ;                                                     03010000
                                                                        03020000
PROCEDURE PRINTTABLE;                                                   03030000
  VAR I,N: INDEX;                                                       03040000
BEGIN N := 0;    (*COMPRESS TABLE*)                                     03050000
  FOR I := 0 TO P-1 DO                                                  03060000
    IF T[I].KEY <> EMPTY THEN                                           03070000
      BEGIN T[N] := T[I]; N := N+1                                      03080000
      END ;                                                             03090000
  IF N > 0 THEN SORT(0,N-1);                                            03100000
  NOPL := (LLNGOUT-KLN-1) DIV DGPN;                                     03110000
# M := LPPG; SPACE(1); WRITELN(' CROSS REFERENCE OF IDENTIFIERS,',      03120000
            ' LABEL DECLARATIONS AND GOTO STATEMENTS:');                03130000
# COUNTLINE; SPACE(1);  C1 := N;  C2 := 0;                              03140000
  FOR I := 0 TO N-1 DO PRINTWORD(T[I])                                  03150000
END (*PRINTTABLE*) ;                                                    03160000
                                                                        03170000
PROCEDURE PRINTPROCS;                                                   03180000
BEGIN SPACE(2); COUNTLINE;                                              03190000
  WRITELN(' LIST OF PROCEDURES AND FUNCTIONS:');                        03200000
# C3 := 0;  COUNTLINE;  SPACE(1);                                       03210000
  PROCPTR := FIRSTPROC@.NEXT;                                           03220000
  WHILE PROCPTR <> NIL DO                                               03230000
    BEGIN WITH PROCPTR@ DO WRITELN(NAME:24,LNO:10);                     03240000
#     C3 := C3+1;  COUNTLINE; PROCPTR := PROCPTR@.NEXT                  03250000
    END;                                                                03260000
# SPACE(2);                                                             03270000
# WRITELN(OUTPUT, ' # OF IDENTIFIERS: ', C1:1, ',  # OF OCCURENCES: ',  03280000
#                 C2:1, ',  # OF PROCEDURES: ', C3:1, '.');             03290000
END (*PRINTPROCS*) ;                                                    03300000
                                                                        03310000
PROCEDURE INITIALIZE;                                                   03320000
  TYPE SETTING = PACKED RECORD                                          03330000
                   CASE SWITCH: BOOLEAN OF                              03340000
                     TRUE: (ONOFF: CHAR);                               03350000
                     FALSE: (SIZE: 0..999999)                           03360000
                   END;                                                 03370000
  VAR S: SETTING;                                                       03380000
  FUNCTION OPTION(NAME: CHAR; VAR S: SETTING): BOOLEAN;                 03390000
    EXTERNAL;                                                           03400000
BEGIN N := 0; M := 0;                                                   03410000
  LLNGIN := LLMAX; LLNGOUT := LLMAX;                                    03420000
"""IF OPTION('U',S) THEN                                                03430000
    IF S.SWITCH AND (S.ONOFF = '+')                                     03440000
      THEN LLNGIN := LLMIN;                                             03450000
  IF OPTION('W',S) THEN                                                 03460000
    IF S.SWITCH AND (S.ONOFF = '+')                                     03470000
      THEN LLNGOUT := LLMIN;    """                                     03480000
  FOR I := 0 TO P-1 DO T[I].KEY := EMPTY;                               03490000
  NEW(PROCPTR); FIRSTPROC := PROCPTR; PROCPTR@.NEXT := NIL;             03500000
  PROCORFUNC := TRUE;   (*TO GET P R O G R A M NAME IN PROCEDURE INDEX*)03510000
  KEY[ 1] := 'AND       '; KEY[ 2] := 'ARRAY     ';                     03520000
  KEY[ 3] := 'BEGIN     '; KEY[ 4] := 'CASE      ';                     03530000
  KEY[ 5] := 'CONST     '; KEY[ 6] := 'DIV       ';                     03540000
  KEY[ 7] := 'DOWNTO    '; KEY[ 8] := 'DO        ';                     03550000
  KEY[ 9] := 'ELSE      '; KEY[10] := 'END       ';                     03560000
  KEY[11] := 'FILE      '; KEY[12] := 'FOR       ';                     03570000
  KEY[13] := 'FUNCTION  '; KEY[14] := 'IF        ';                     03580000
  KEY[15] := 'IN        '; KEY[16] := 'MOD       ';                     03590000
  KEY[17] := 'NIL       '; KEY[18] := 'NOT       ';                     03600000
  KEY[19] := 'OF        '; KEY[20] := 'OR        ';                     03610000
  KEY[21] := 'PACKED    '; KEY[22] := 'PROCEDURE ';                     03620000
  KEY[23] := 'PROGRAM   '; KEY[24] := 'RECORD    ';                     03630000
  KEY[25] := 'REPEAT    '; KEY[26] := 'SET       ';                     03640000
  KEY[27] := 'THEN      '; KEY[28] := 'TO        ';                     03650000
  KEY[29] := 'TYPE      '; KEY[30] := 'UNTIL     ';                     03660000
  KEY[31] := 'VAR       '; KEY[32] := 'WHILE     ';                     03670000
  KEY[33] := 'WITH      '                                               03680000
END (*INITIALIZE*) ;                                                    03690000
                                                                        03700000
PROCEDURE SCANANDLISTINPUT;                                             03710000
BEGIN                                                                   03720000
  WHILE NOT EOF(INPUT) DO                                               03730000
  BEGIN NEWLINE;                                                        03740000
    WHILE NOT EOLN(INPUT) DO                                            03750000
    CASE INPUT@ OF                                                      03760000
     'a','b','c','d','e','f','g','h','i','j','k','l','m',               03770000
     'n','o','p','q','r','s','t','u','v','w','x','y','z',               03780000
     'A','B','C','D','E','F','G','H','I','J','K','L','M',               03790000
     'N','O','P','Q','R','S','T','U','V','W','X','Y','Z':               03800000
      BEGIN K := 0; ID.A := EMPTY;                                      03810000
        REPEAT                                                          03820000
          IF K < KLN THEN                                               03830000
            BEGIN K := K+1; ID.A[K] := INPUT@                           03840000
            END;                                                        03850000
          ADVANCE                                                       03860000
"""     UNTIL NOT(INPUT@ IN ['A'..'Z', '0'..'9']);   """                03870000
        UNTIL NOT(LETTER(INPUT@) OR DIGIT(INPUT@) OR SPECIAL(INPUT@));  03880000
        IF NOKEY THEN                                                   03890000
        BEGIN SEARCH;                                                   03900000
          IF PROCORFUNC THEN NOTEPROC                                   03910000
        END ELSE                                                        03920000
        IF (ID.A = 'PROCEDURE ') OR (ID.A = 'FUNCTION  ') THEN          03930000
          PROCORFUNC := TRUE                                            03940000
      END;                                                              03950000
     '0','1','2','3','4','5','6','7','8','9':                           03960000
        REPEAT ADVANCE;                                                 03970000
"""     UNTIL NOT (INPUT@ IN ['B','E','0'..'9']);  """                  03980000
        UNTIL NOT DIGIT(INPUT@) ;                                       03990000
     '''':                                                              04000000
      BEGIN (*STRING*)                                                  04010000
        REPEAT ADVANCE;                                                 04020000
        UNTIL (INPUT@ = '''') OR EOLN(INPUT);                           04030000
        IF NOT EOLN(INPUT) THEN                                         04040000
          ADVANCE                                                       04050000
      END;                                                              04060000
#    '"':                                                               04070000
      BEGIN (*COMMENT*)                                                 04080000
        REPEAT ADVANCE;                                                 04090000
          WHILE EOLN(INPUT) DO                                          04100000
            BEGIN WRITELN(OUTPUT); GET(INPUT); NEWLINE                  04110000
            END                                                         04120000
        UNTIL INPUT@ = '"';                                             04130000
        ADVANCE                                                         04140000
      END;                                                              04150000
     '¯':                                                   (* 86180 *) 04160000
      BEGIN (*COMMENT*)                                     (* 86180 *) 04170000
        REPEAT ADVANCE;                                     (* 86180 *) 04180000
          WHILE EOLN(INPUT) DO                              (* 86180 *) 04190000
            BEGIN WRITELN(OUTPUT); GET(INPUT); NEWLINE      (* 86180 *) 04200000
            END                                             (* 86180 *) 04210000
        UNTIL INPUT@ = '';                                 (* 86180 *) 04220000
        ADVANCE                                             (* 86180 *) 04230000
      END;                                                  (* 86180 *) 04240000
     '(':                                                               04250000
      BEGIN ADVANCE;                                                    04260000
        IF INPUT@ = '*' THEN                                            04270000
        BEGIN (*COMMENT*) ADVANCE;                                      04280000
          REPEAT                                                        04290000
            WHILE INPUT@ <> '*' DO                                      04300000
            BEGIN                                                       04310000
              IF EOLN(INPUT) THEN                                       04320000
                BEGIN GET(INPUT); WRITELN(OUTPUT); NEWLINE              04330000
                END ELSE                                                04340000
                ADVANCE                                                 04350000
            END ;                                                       04360000
            ADVANCE                                                     04370000
          UNTIL INPUT@ = ')';                                           04380000
          ADVANCE                                                       04390000
        END                                                             04400000
      END;                                                              04410000
     '+','-','*','/',')','$','=',' ',',','.','[',']',                   04420000
     ':','!','Ý','&','@','?','<','>','','\','^',';','#','_','%','':   04430000
      ADVANCE                                                           04440000
    END (*CASE*) ;                                                      04450000
    WRITELN(OUTPUT); GET(INPUT)                                         04460000
  END ;                                                                 04470000
END (*SCANANDLISTINPUT*) ;                                              04480000
                                                                        04490000
BEGIN (*CROSSREF*)                                                      04500000
"""LINELIMIT(OUTPUT, MAXN);PAGE(OUTPUT)"""  ; INITIALIZE;               04510000
  IF NOT EOF(INPUT) THEN                                                04520000
  BEGIN SKIPCOMPILERTITLE;                                              04530000
    SCANANDLISTINPUT; """LINELIMIT(OUTPUT, MAXN); """                   04540000
    PRINTTABLE; PRINTPROCS                                              04550000
  END ELSE WRITELN(STARS,' NO PROGRAM FOUND TO CROSS REFERENCE',STARS); 04560000
99:END .                                                                04570000
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB PAT      EXT PAS HEX -
(*$M-*)
program pat;



    ¯***********************************************
    ¯*       PAL     (pat,lalr)                    *
    ¯*                                             *
    ¯*   PATTERN  ACTION  LANGUAGE                 *
    ¯*                                             *
    ¯*    AUTHOR  :   G. POONEN                    *
    ¯*                                             *
    ¯*    modification :  J. Bloch, H. Eskin       *
    ¯*    modification :  G. Minshall              *
    ¯*                                             *
    ¯*     VERSION :                               *
    ¯*                                             *
    ¯*      DATE    :        December, 1983        *
    ¯*                                             *
    ¯***********************************************

¯ Dependancies - The algorithm for making a character
        upper case DEPENDS on (ord(LowerCaseLetter)-ord(UpperCaseLetter))
        being constant as 'Letter' varies from 'a' to 'z'
        (Both ASCII and EBCDIC have this property).























    ¯  GLOBAL DECLARATIONS  
    ¯***********************



    ¯ GLOBAL constANTS
  const
    XCONTINUE = 9996 ;     ¯ CODE FOR CONTINUE IN TABLE 
    ELSECODE = 9997  ;
    NOSCANCODE   = 9998 ; ¯ CODE FOR SCAN
    ERRORCODE = 9999 ;    ¯ CODE FOR ERROR IN TABLE 
    UNKNOWN=-9999 ;       ¯ UNKNOWN QTY 
    MAXSEGMENT = 200 ;
    MAXTABSIZE =3000;
    MAXADDR    = 4*65536-1;
    MAXNAME    = 15   ;   ¯ MAX LENGTH OF NAMES  (was 15) 
    MAXERR     =  20  ;   ¯ MAX ERRORS PER LINE
    MAXERRNmr  =  200 ;   ¯ MAX ERROR NUMBER
    MAXLINECNT =   132;   ¯  LINE COUNT
    GTMAXERR   =  199 ;   ¯ EXCEEDED MAX ERRORS PER LINE
    MAXSYM     =    6 ;   ¯ SIZE OF SPECIAL SYMBOLS
    STATETABSIZE= 2000 ;  ¯ was 1000 
    MAXSTATE = 2000 ;     ¯ was 1000 
    MAXRHS = 32 ;
    MAXVISIT = 3200  ;    ¯ MAX NO OF STATES VISITED FOR 
                          ¯ RESOLVING LA STATES  ¯ was 1600

    MAXVOCSIZE = 2048 ;   ¯ MAX VOCABULARY CODE (was 512) 
    MAXTERMINALS = 1023 ; ¯ was 255 
    NAMETABSIZE = 4001 ;  ¯ KEEP IT PRIME  (was 1023) 
    MAXRULENO    = 4001 ; ¯ KEEP IT PRIME  (was 1023) 
    DIGMAX    =    5 ;    ¯ MAXIMUM NUMBER of DIGITS FOR INTEGER
    THRESHOLD =3 ;        ¯ USED FOR SORTING AND MATCHING LISTS
    FILENAMELEN = 133 ;   ¯ MAX charACTERS IN FILESPEC
    B14 = 12;             ¯ was 14B in DEC version 
    WHITESPACE = [ ' ' ]; ¯ What INsymbol skips. 


    ¯ GLOBAL typeS 
type
    word  =  packed array [1 .. MAXNAME] of char ;
    symbol =  (Ident ,Res, Intconst,  SemiSy, SlashSy, OrSy, EqSy, ColSy
    ,PeriodSy    ) ;
    setofsymbol = set of symbol ;
    namety = (Term,NonTerm,
              Lab
              ) ;
    codety = -1 .. MAXTERMINALS ;
    listptrty = @ list ;
    list   =  packed  record
                             CDR     : listptrty;
                             CAR     : 1 .. '5FFF'X
                      end ;
    setofnamety = set of namety ;


    ¯  NAME TABLE ENTRIES   
    ¯***********************

    identptrty = @ identry ;
    prodptrty  = @ prod ;
    identry   =   record
                         Nic     : identptrty;
                         FirstAlt: prodptrty;

                         Defin   : listptrty;
                         UsedIn  : listptrty;
                         InternalName,
                         ExternalName    : word   ;
                         Kind    : namety ;
                         SpId    : symbol ;
                         Code    : codety
                  end ;
    prod = record
                  Next   : prodptrty;
                  XDef   : identptrty;
                  Action : identptrty;
                  NxtAlt : prodptrty;
                  Production : 1 .. MAXRULENO
           end ;


    ¯  STATE ENTRIES 
    ¯****************
    statekind     = (Reads,Inadequate,Lookahead,Reduction,Subgoal,LAString) ;
    stateptrty    = @ statety ;
    tranlistptr   = @ tranlist ;
    statelistptr  = @ statelist ;
    tranptrty     = @ tranty ;
    statety = record
                 FirstTran : tranptrty  ;
                 Back      : tranptrty ;
                 Nic       : stateptrty ;
                 State     : 0 .. MAXSTATE ;
                 Kind      : statekind
              end ;

    statelist = record
                  CAR : stateptrty ;
                  CDR : statelistptr
                end ;
    tranlist = record
                  CAR : tranptrty ;
                  CDR : tranlistptr
               end ;
    tranty =  packed record
                        Next      : tranptrty ;
                        NextState : stateptrty ;
                        Rule      : prodptrty ;
                        Pos       : 0 .. MAXRHS ;
                        MarkE     : BOOLEAN
                     end ;

    ¯ type specifiers for OPEN procedure 
    openOptions = ( OpenInput, OpenOutput, OpenUppercase );
    openOption  = set of openOptions;
    filenameType = packed array [1 .. FILENAMELEN] of char  ;
    promptType = packed array[1..121] of char;




    ¯ GLOBAL varIABLES 
var
    Heap,HeapBot,HeapTop      : @integer ; ¯ MARKS Heap 
    Visit   : array [ 1.. MAXVISIT ] of tranptrty ;
    CurrentVisit : integer ;

    ¯ Table ENTRIES 


    Table : array [0 .. MAXTABSIZE] of packed record
                                              Tran : integer ;
                                              Action : integer
                                       end ;
    Index : -1 .. MAXTABSIZE ;
    Segment : array [0 .. MAXSEGMENT] of packed record
                                                Tran : integer ;
                                                Action : integer
                                         end ;
    SegIndex : -1 .. MAXSEGMENT ;
    NewState : array [0 .. MAXSTATE] of integer ;


    SymbolName : packed array [0 .. MAXVOCSIZE] of identptrty;
    NameTab  :  array [0 .. NAMETABSIZE ] of identptrty ;
    RuleTab   :  array [1 .. MAXRULENO ] of   prodptrty;
                 ¯  Contains no. of elements on rhs e.g  
                 ¯  X =  A   B   C    will be 3          
    PopTab  : array [ 1 .. MAXRULENO ] of integer ;

    NState : array [0 .. MAXSTATE ] of stateptrty ;
    StateTab  : array [0 .. STATETABSIZE ] of stateptrty ;
    Inadeq,Conflict : statelistptr ; ¯ list of Inadequate StateS 
    CurrentState : 0 .. MAXSTATE ;
    Sy     : symbol  ; ¯ LAST symbol
    SyLeng : integer ; ¯ LENGTH of symbol
    SyKey  : integer ; ¯ symbol KEY      

    SyVal : integer ;
    MaxK  : integer ; ¯ MAX VAL of Lookahead 
    InternalId,               ¯ symbol InternalName     
    ExternalId    :  word   ; ¯ symbol ExternalName     
    Ch    :  char   ; ¯ LAST charACTER  
    InSymbolState : ( InSymbolNormalState, InSymbolStringState );
                    ¯ that is: returning a string, or just normal
                        processing 

    ChCnt : integer ;
    Letters
    ,Digits  :  set of char   ;

   MaxPop     : integer ;
   MaxCode    : integer ;
   MaxProdNo  : 0 .. MAXRULENO ;
      ProdNo  : 0 .. MAXRULENO ;

    L      : integer ; ¯ CONTROL varIABLE 

                       ¯  OPTION FLAGS  
    ListFl                  ¯ L 
    , Look                  ¯ A 
    , Grammar               ¯ G 
    , Debug                 ¯ D 
    , Optimize              ¯ O 
    , Trace                 ¯ R - Print trace info during run 
    , Tables                ¯ T 
    , PN                    ¯ P 
    , Terminals             ¯ S 
    , Frequency             ¯ F 
    , Lr0                   ¯ C 
    , IFSM                  ¯ I 
    , Research              ¯ Z 
    , Symbolic              ¯ Y - The state tables should be symbolic 
    , NonTerminals          ¯ N - Put non terminals in .TER 
    , FSM      :   boolean; ¯ M 

    ¯  ERROR  list  

    FatalError,
    ErrorFlag  : boolean ;
    ErrInx   :   integer   ;   ¯ NO of ERRORS IN THIS LINE
    ErrList  :  array  [1 .. MAXERR]  of
                    record
                      Pos :  0 .. MAXLINECNT ;
                      Nmr :  0 .. MAXERRNmr
                    end ;
    ¯  FILES  
    Filename  :  filenameType;
      TTYOut                                 ¯  Console output 
    , CrefPas                                ¯  Cref       
    , TerPas                                 ¯  Terminals  
    , NewPrgPas                              ¯  Formatted Grammar 
    , TabPas                                 ¯  Tables 
    , PNPas    :  text;                      ¯  Production num 

    ¯  LALR  
    LrK
    :  boolean    ;

    ¯  SPECIAL symbolS  
    SpList   :  array [1 .. MAXSYM]  of char  ;
    SpSy    :  array [1 .. MAXSYM]  of symbol  ;

LowerCaseLetters : set of char;


¯ The following are for the Arguments part of the implementation
        specific part of the Pascal/VS version (IBM)

    OurArgs : packed array[1..255] of char;
    OurArgsIndex,
    OurArgsLength : integer;
    OurArgsUpperCase : boolean;









¯ The following proceduRes are, hopefully,
    the only PASCAL/VS specific proceduRes.  Thus, to move to a new
    environment, one should only need to change the way they deal
    with your new I/O system.  NOTE that 'filename' is something
    one might have to reformat.
        (greg minshall - 12/10/83)


¯ OPEN - this procedure opens a file, doing ResET or REWRITE as
    necessary


procedure open( var f          : text;
                const filename : filenametype;
                const options  : openOption );
%include CMS
var
    opts : string(50);
    fn   : string(40);
    rc   : integer;
begin
    assert (( OpenInput in options ) or ( OpenOutput in options )) and
           not (( OpenInput in options ) and ( OpenOutput in options ));

    if OpenUppercase in options then
        opts := 'UCASE '    ¯ translate input to UPPER case 
    else
        opts := '';

    fn := trim(ltrim(compRess(str(filename))));

    if fn = 'TTY:' then begin
        opts := opts ÝÝ 'DDNAME=STDIN';
        cms( 'FILEDEF STDIN CLEAR', rc );
        cms( 'FILEDEF STDIN TermINAL ( LRECL 255 BLOCK 255', rc );
        if OpenInput in options then
            Reset( f, opts )
        else
            rewrite( f, opts );
    end else begin
        opts := opts ÝÝ 'NAME=' ÝÝ fn;
        if OpenInput in options then
            Reset( f, opts )
        else
            rewrite( f, opts );
    end;
end;

¯ CanOpen - this boolean function returns TRUE if the filename
          LookS ok, FALSE otherwise

function CanOpen( const filename : filenametype ) : boolean;
%include CMS
var
    myfile : filenametype;
    index,
    rc     : integer;
begin
    for index := 1 to filenamelen do
        if filename[index] = '.' then
            myfile[index] := ' '
        else
            myfile[index] := filename[index];

    cms( 'SET CMStype HT', rc );

    cms( 'State ' ÝÝ str(myfile), rc );
    CanOpen := rc = 0;

    cms( 'SET CMStype RT', rc );
end;

PROCEDURE BREAK;
BEGIN
    ¯ DEC has a procedure called BREAK, which causes the output
        buffer to be flushed.  Here is my version - it is
        good for nothing!
    
end;


¯ The following proceduRes are designed to allow PAT to get arguments
    from the users.  In the Pascal/VS version, we get the options from
    the command line.  In other versions, one might (as in the DEC
    version this started from) write a prompt, and the read from the
    terminal.


procedure InitArgs;
var
    TempArgs : string(255);
    Index : integer;
begin
    TempArgs := parms;          ¯ parms is a function, returns parms
                                  from the command line 
    OurArgs := TempArgs;        ¯ Pascal/VS converts 
    OurArgsIndex := 1;
    OurArgsLength := length(TempArgs);
    while (OurArgs[OurArgsIndex] = ' ') and
          (OurArgsIndex <= OurArgsLength) do
            OurArgsIndex := OurArgsIndex+1;
    OurArgsUpperCase := FALSE;
end;


procedure PromptArgs( Prompt : promptType );
begin
    ¯ We don't use this at all 
end;


procedure OpenArgs( Options : openOption );
begin
    if OpenUppercase in Options then
        OurArgsUpperCase := TRUE
    else
        OurArgsUpperCase := FALSE;
end;


Procedure GetArgCh( var ch : char; var EndLine, EndArgs : boolean );
begin
    if OurArgsIndex > OurArgsLength then begin
        EndArgs := TRUE;
        Ch := ' ';
    end else begin
        EndArgs := FALSE;
        Ch := OurArgs[OurArgsIndex];
        if (Ch in LowerCaseLetters) and OurArgsUpperCase then
            Ch := chr( ord(Ch) + ord('A')-ord('a') );
        OurArgsIndex := OurArgsIndex+1;
        if  Ch = ' ' then begin
            EndLine := TRUE;
            while (OurArgs[OurArgsIndex] = ' ') and
                  (OurArgsIndex <= OurArgsLength) do
                        OurArgsIndex := OurArgsIndex+1;
        end else
            EndLine := FALSE;
    end;
end;


procedure SetReturnCode( I : integer );
¯ In CMS, error code is propagatable back to caller, so let
    them know...

begin
    retcode(i);     ¯ CMS Pascal/VS primitive 
end;




¯ Thus ends, hopefully, the implementation dependent part
    of PAT.
        greg minshall, 12/83





procedure InitSp;
begin
        SpList  [1] :=  '!'    ;  SpSy [1] := OrSy ;
        SpList  [2] :=  '/'    ;  SpSy [2] := SlashSy ;
        SpList  [3] :=  ';'    ;  SpSy [3] := SemiSy ;
        SpList  [4] :=  '='    ;  SpSy [4] := EqSy ;
        SpList  [5] :=  ':'    ;  SpSy [5] := ColSy ;
        SpList  [6]  := '.' ;    SpSy [6] := PeriodSy
end;


    ¯used to be an initprocedure
    procedure  InitOptions ;  ¯  DEFAULT OPTIONS
      begin
        Optimize   :=   FALSE   ;
        Tables     :=   TRUE   ;
        PN         :=   FALSE   ;
        Terminals  :=   TRUE   ;
        Frequency  :=   FALSE   ;
        FSM        :=   FALSE   ;
        Grammar    :=   TRUE   ;
        Look       :=  TRUE   ;
        ListFl     :=  TRUE   ;
        Lr0        :=  TRUE   ;
        IFSM       :=  TRUE   ;
        Research   :=   FALSE ;
        Debug      :=   FALSE ;
        Trace      :=   FALSE ;
        Symbolic   :=   FALSE ;
        NonTerminals := FALSE ;

        MaxK  :=  1     ; ¯  DEFAULT Lookahead
      end  ;




    procedure InitGlob ;    ¯ GLOBAL varIABLES  
    ¯used to be an initprocedure
      begin
        FatalError := FALSE;
        ErrorFlag := FALSE ;
        Conflict := NIL ;
        Inadeq := NIL   ;
        ErrInx := 0     ;
        InSymbolState := InSymbolNormalState;
        LowerCaseLetters := [ 'a', 'b', 'c', 'd', 'e', 'f',
            'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
            'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' ];
      end ;



    procedure   EndOfLine  ;
        ¯*******************************************************
        ¯*                                                     *
        ¯*   end of LINE                                       *
        ¯*                                                     *
        ¯*       THIS procedure WRITES OUT THE                 *
        ¯*     CURRENT LINE AND FOLLOWS IT WITH                *
        ¯*     ANY ERROR MESSAGES AND POINTERS.                *
        ¯*                                                     *
        ¯*                                                     *
        ¯*      GLOBAL IN: ErrInx  NO. of ERRORS IN THIS LINE  *
        ¯*                                                     *
        ¯*                 ErrList array CONTAINING            *
        ¯*                         ATTRIBUTES of ERROR         *
        ¯*                                                     *
        ¯*                 list    listING REQUIRED IF         *
        ¯*                         TRUE.                       *
        ¯*                                                     *
        ¯*         OUT :  ErrInx   set TO 0                    *
        ¯*                                                     *
        ¯*                                                     *
        ¯*******************************************************
    var
        LastPos
        , FreePos
        , CurrPos
        , CurrNmr
        ,  F                ¯  FORMAT  
        ,  K                ¯  LOOP CONTROL  
        :  integer  ;

      begin
        readln; writeln;
        if ErrInx > 0 then  ¯OUTPUT ERROR MESSAGES
          begin
            write('****');
            LastPos := 0; FreePos := 1;
            for K := 1 to ErrInx do
              begin
                with ErrList[K] do
                  begin
                    CurrPos := Pos; CurrNmr := Nmr
                  end;
                if CurrPos = LastPos then write(',')
                else
                  begin
                    while FreePos < CurrPos do
                      begin
                        write(' '); FreePos := FreePos + 1
                      end;
                    write('@');
                    LastPos := CurrPos
                  end;
                if CurrNmr= 0 then F:= 0
                else if CurrNmr < 10 then F :=1
                else if CurrNmr < 100 then F := 2
                else F := 3;
                if F <> 0 then write(CurrNmr:F);
                FreePos:=FreePos+F+1
              end;
            writeln; ErrInx :=0
          end;
        ChCnt := 0
      end  ¯EndOfLine ;



    procedure   Error  (FErrNr : integer) ;
        ¯******************************************************
        ¯*                                                    *
        ¯*        Error                                       *
        ¯*                                                    *
        ¯*     THIS procedure recordS THE Error               *
        ¯*  AND PosITION of OCCURRENCE                        *
        ¯*                                                    *
        ¯*    GLOBAL  IN :  ChCnt   INDICATE PosITION         *
        ¯*                          ON LINE                   *
        ¯*                                                    *
        ¯*                                                    *
        ¯*                                                    *
        ¯*         OUT :  ErrorFlag                           *
        ¯*                ErrList     array of ErrorS         *
        ¯*                ErrInx                              *
        ¯*                                                    *
        ¯*                            I                       *
        ¯*                                                    *
        ¯******************************************************
      begin
        ¯  Error 
        ErrorFlag :=  TRUE  ;
        if ErrInx >= MAXERR  then
          begin
            ErrList [ MAXERR ].Nmr :=  GTMAXERR  ;
          end
        else
          begin
            ErrInx  :=  ErrInx +1  ;
            ErrList [ErrInx] . Nmr := FErrNr  ;
            ErrList [ErrInx].Pos   :=  ChCnt   ;
          end  ;
      end  ;
    ¯  Error 




    procedure  NextCh   ;
        ¯*******************************************************
        ¯*                                                     *
        ¯*  NextCh.                                            *
        ¯*                                                     *
        ¯*     THIS procedure RETURNS THE Next charACTER       *
        ¯* IN Ch                                               *
        ¯*                                                     *
        ¯*                                                     *
        ¯*                                                     *
        ¯*   GLOBAL      IN:   ChCnt                           *
        ¯*                     ListFl        boolean OPTION    *
        ¯*                                                     *
        ¯*              OUT:   ChCnt                           *
        ¯*                                                     *
        ¯*                      Ch         Next charACTER      *
        ¯*                                                     *
        ¯*******************************************************
      begin
        ¯ NextCh 
        if not ( eoln(Input) or eof(Input) )  then
          begin
            read (Ch)  ;
            if ListFl then write (Ch)  ;
            ChCnt :=  ChCnt +1  ;
          end
        else   Ch := ' '  ;
      end   ;



    procedure  InSymbol  ;
        ¯*******************************************************
        ¯*                                                     *
        ¯*   InSymbol                                          *
        ¯*                                                     *
        ¯*       THIS procedure RETURNS THE Next               *
        ¯*  symbol FROM THE SOURCE Input                       *
        ¯*                                                     *
        ¯*  GLOBAL  IN:  Ch     Next charACTER                 *
        ¯*              SP list                                *
        ¯*              SP Sy                                  *
        ¯*                                                     *
        ¯*         OUT :  SyLeng    symbol LENGTH              *
        ¯*                Sy        symbol type                *
        ¯*                InternalId[I]     symbol charACTERS  *
        ¯*                SyKey     KEY for IdentifIERS        *
        ¯*                                                     *
        ¯*                                                     *
        ¯*                                                     *
        ¯*******************************************************

    label
        3;
    var
        I,K : integer ;
        Noteoln,
        Noteof : boolean;
begin ¯ InSymbol 
    if InSymbolState = InSymbolStringState then begin
        ExternalId[1] := '''';
        ExternalId[2] := Ch;
        SyKey := ord(Ch);
        ExternalId[3] := '''';
        if Ch = '''' then
            ExternalId[4] := ''''
        else
            ExternalId[4] := ' ';
        for i := 5 to MAXNAME do
            ExternalId[i] := ' ';
        Sy := Res;
        InternalId := ExternalId;
                ¯ End of lines and files terminate strings 
        if eoln(Input) or eof(Input) then
            InSymbolState := InSymbolNormalState;
        Nextch;
        if Ch = '''' then begin
            Nextch;
            if Ch <> '''' then
                InSymbolState := InSymbolNormalState;
        end;
    end else begin
        repeat begin
            repeat begin
                if  eoln(Input)  then EndOfLine ;
                if  not ( Ch in WHITESPACE ) then
                    leave;
                NextCh   ;          ¯ skip whitespace 
            end until eof(Input);
            if (Ch <> '¯') AND (Ch <> '%') then
                leave;
            if  Ch = '%' then
            begin
                NextCh   ;
                repeat begin
                    if  eoln(Input)  then EndOfLine ;
                    if  Ch = '' then
                        leave;
                    NextCh
                end until eof(Input);
            end;
            if  Ch = '¯' then
            begin
                NextCh   ;
                repeat begin
                    if  eoln(Input)  then EndOfLine ;
                    if  Ch = '' then
                        leave;
                    NextCh
                end until eof(Input)
            end;
            NextCh
        end until eof(Input);
        SyLeng  := 0 ;
        SyVal :=0 ;
        SyKey   := 0 ;
        if  Ch  in  Letters  then begin
            K  := 0   ;
            repeat
                if  K  <MAXNAME   then begin
                    K := K+1 ;
                    ExternalId[K] := Ch   ;
                    if Ch in LowerCaseLetters then
                        InternalId[K] := chr( ord(ch) + ord('A')-ord('a') )
                    else
                        InternalId[K] := Ch;
                    SyKey  := SyKey + ord(InternalId[K]);
                  end   ;

                NextCh
            until  not  (Ch in Letters + Digits) ;
            if K < MAXNAME  then
            for I := K+1 to MAXNAME do begin
                ExternalId[I] := ' ' ;
                InternalId[I] := ' ' ;
            end;
            Sy  := Ident   ;
          end
        else  if  Ch  in  Digits  then begin
            Sy := Intconst ;
            I  :=  0     ;   SyVal :=0;
            repeat
                I := I+1 ;
                if   I < DIGMAX then
                SyVal := SyVal*10  + ord (Ch) - ord ('0') ;
                ExternalId[I] := Ch      ;
                NextCh
            until  not  (Ch in Digits)   ;
            if I < MAXNAME then
            for I:= I+1 to MAXNAME  do  ExternalId[I] := ' ';
            InternalId := ExternalID;
        end
        else if Ch = '''' then begin
            InSymbolState := InSymbolStringState;
            Nextch;
            if Ch = '''' then begin
                Nextch;
                if Ch <> '''' then    ¯ If TRUE, null symbol - ignore 
                    InSymbolState := InSymbolNormalState;
            end;
            InSymbol;           ¯ recurse to start reading string 
        end else begin
            for I := 1 to MAXSYM do begin
                if SpList[I]= Ch  then begin
                    Sy := SpSy [I] ;
                    GOto 3 ;
                end ;
            end ;
            3 : ExternalId[1] := Ch;
            NextCh ;
            for I:= 2 to MAXNAME  do ExternalId[I]:= ' ';
            InternalID := ExternalID;
        end ;
        if Trace then begin
            writeln(TTYOut,InternalId,' ',SyVal:3);BREAK
        end;
    end;
end  ;
        ¯  InSymbol  



    procedure   InitP ;
        ¯***********************************************************
        ¯*                                                         *
        ¯*    InitP                                                *
        ¯*                                                         *
        ¯*        THIS procedure Reads in THE OPTIONS              *
        ¯*   AND ALSO inITIALIZES ANY Tables AS                    *
        ¯*   REQUIRED                                              *
        ¯*                                                         *
        ¯***********************************************************
    var

        ChNext : char;
        EndLine,
        EndArgs : boolean;
        I : integer ;
        Distance,Dot,J, RBrak,Colon
                : 0..FILENAMELEN;       ¯PLACE MarkERS in FILESPEC
        procedure     InitSets   ;
        var
            L : integer ;
          begin
            Digits := ['0','1','2','3','4','5','6','7','8','9'] ;
            Letters:= ['A','B','C','D','E','F','G','H','I','J','K',
            'L','M','N','O','P','Q','R','S','T','U','V',
            'W','X','Y','Z','_','a','b','c','d','e','f','g','h','i','j','k',
            'l','m','n','o','p','q','r','s','t','u','v',
            'w','x','y','z' ] ;

            for L := 0 to NAMETABSIZE do
            NameTab[L] :=  NIL ;
            for L:= 1 to MAXRULENO do
              begin
                RuleTab[L] :=  NIL;
                PopTab [L] := 0
              end   ;
            MaxProdNo := 0;
            ProdNo := 0 ;
            MaxPop := 0 ;
            for L := 0 to MAXSTATE do
              begin
                NewState [L] := 0 ;
                NState [ L ] := NIL ;
              end ;
            for L := 0 to MAXTABSIZE do
              begin
                Table [L].Tran := UNKNOWN ;
                Table [L].Action := UNKNOWN;
              end ;
            for L := 0 to STATETABSIZE do
            StateTab [L] := NIL ;
            CurrentVisit := 0 ;
            for L := 1 to MAXVISIT do
            Visit [L] := NIL ;
            MaxCode := 257 ;    ¯ leave room for ord constants 
            CurrentState := 0
          end  ;
        ¯ InitSets 



        procedure    Options   ;
            ¯************************************************************
            ¯*                                                          *
            ¯*  Options                                                 *
            ¯*                                                          *
            ¯*  THIS procedure Reads in THE Options                     *
            ¯*   AND SETS THE OPTION FLAGS APPROPRIATELY                *
            ¯*                                                          *
            ¯*      GLOBAL in:  Ch        LAST charACTER                *
            ¯*                                                          *
            ¯*                                                          *
            ¯************************************************************
var
    ChNext : char;
    EndLine,
    EndArgs : boolean;

          begin
            ¯ Options 
              PromptArgs('Options: ');
              OpenArgs([ OpenInput, OpenUppercase ]);
        /*    Reset(TTY,'TTY:','/I/U'); ¯ convert tty input to upper case  */
              GetArgCh( ChNext, EndLine, EndArgs );
              while not EndArgs do begin
                Ch := ChNext;       ¯ get Identifier 
                GetArgCh( ChNext, EndLine, EndArgs ); ¯ get +/- 
                if Ch = 'L' then
                  begin
                    ListFl  :=  ChNext <> '-';
                    writeln(TTYOut,'Listfile: ',listfl)
                  end
                else if Ch = 'O' then
                  begin
                    Optimize  :=  ChNext <> '-';
                    writeln(TTYOut,'Optimize: ',optimize)
                  end
                else if Ch = 'T'  then
                  begin
                    Tables := ChNext<>'-';
                    writeln(TTYOut,'Tables: ',tables)
                  end
                else if Ch ='S'  then
                  begin
                    Terminals := ChNext<>'-';
                    writeln(TTYOut,'Terminals: ',terminals)
                  end
                else if Ch = 'F'   then
                  begin
                    Frequency  :=  ChNext <>'-';
                    writeln(TTYOut,'Frequency: ',frequency)
                  end
                else if  Ch = 'M'   then
                  begin
                    FSM  :=  ChNext<>'-';
                    writeln(TTYOut,'FSM: ',fsm)
                  end
                else  if  Ch  = 'D'   then
                  begin
                    Debug  := ChNext <> '-';
                    writeln(TTYOut,'Debug: ',debug)
                  end
                else  if  Ch  = 'R'   then
                  begin
                    Trace  :=  ChNext <> '-';
                    writeln(TTYOut,'Trace: ',trace)
                  end
                else  if  Ch in Digits  then
                begin
                    MaxK:=  ord(Ch) - ord('0');
                    writeln(TTYOut,'Maximum lookahead: ',maxk)
                end
                else  if  Ch = 'A'   then
                  begin
                    Look := ChNext<>'-';
                    writeln(TTYOut,'Look: ',look)
                  end
                else if Ch='G'  then
                  begin
                    Grammar:=  ChNext <> '-';
                    writeln(TTYOut,'Grammar: ',grammar)
                  end
                else if Ch ='Z' then
                  begin
                    Research:= ChNext<>'-';
                    writeln(TTYOut,'Research: ',Research)
                  end
                else if Ch ='N' then
                  begin
                    NonTerminals:= ChNext<>'-';
                    writeln(TTYOut,'Non-terminals: ',nonterminals)
                  end
                else if Ch ='Y' then
                  begin
                    Symbolic:= ChNext<>'-';
                    writeln(TTYOut,'Symbolic: ',symbolic)
                  end
                else if Ch = 'I' then
                  begin
                    IFSM := ChNext<>'-' ;
                    writeln(TTYOut,'IFSM: ',ifsm)
                  end
                else if Ch = 'C' then
                  begin
                    Lr0 := ChNext <> '-' ;
                    writeln(TTYOut,'Lr0: ',lr0)
                  end
                else  if  Ch = 'P'   then
                  begin
                    PN :=  ChNext <> '-';
                    writeln(TTYOut,'PN: ',pn)
                  end;
              end;
              writeln(TTYOut)
          end ;
        ¯  Options  



      begin
        ¯  InitP    
        ¯  GET Filename 

        InitSets;
        writeln(TTYOut, 'PAT/lalr -- December, 1983');
        writeln(TTYOut);
        InitArgs;


        PromptArgs('File: ');
        for I:= 1 to FILENAMELEN do
            Filename[I] := ' ';
        I:= 0;
        Dot:=0;
        RBrak:=0;
        Colon:=0;
        GetArgCh( ch, EndLine, EndArgs );
        while not EndLine and not EndArgs and
              not FatalError and (I < FILENAMELEN) do begin
            if (Ch in (Letters + Digits)) or (Ch = '<') or
                (Ch = '-') or (Ch = '.') or (Ch = '>') or (Ch = ':')
              then
                begin
                I := I + 1;
                Filename [I] := Ch;
                if ( Ch = '.' ) AND ( Dot = 0 ) then
                    Dot := I
                else if Ch = ':' then Colon := I
                else if Ch = '>' then RBrak := I;
                end
            else begin
                writeln (TTYOut,'?Error in filespecs');
                FatalError := TRUE;
            end;
            GetArgCh( ch, EndLine, EndArgs );
        end;

    if not FatalError then begin
        if dot=0 then ¯set default extension to PAT begin
            dot := i+1;
            filename[i+1] := '.';
            filename[i+2] := 'P';
            filename[i+3] := 'A';
            filename[i+4] := 'T';
            i := i+4
        end;

        if CanOpen(filename) then
            open( input, filename, [ OpenInput, OpenUppercase ] )
     /*Reset(input,filename,'/U/O'); ¯trap errors & xlate input to UC*/
        else begin
            writeln(TTYOut,'?Cannot open input file');
            FatalError := TRUE
        end;
    end;

    if not FatalError then begin
        Ch := ' ';
        if RBrak > Colon        ¯ Get rid of device and directory names 
        then Distance := RBrak
        else Distance := Colon;
        if Distance > 0
        then
            for J:=1 to I+Distance do
                Filename[J] := Filename[J+Distance];
        Dot := Dot-Distance;            ¯ Move down the dot 
        Options;
        Filename [Dot+1]  :=  'L'   ;
        Filename [Dot+2]  :=  'S'   ;
        Filename [Dot+3]  :=  'T'   ;
        open(OUTPUT,Filename,[ OpenOutput ]);
        if Frequency or FSM or Look or tables
        then
          begin
            Filename [Dot+1]  :=  'C'   ;
            Filename [Dot+2]  :=  'R'   ;
            Filename [Dot+3]  :=  'L'   ;
            open (CrefPas, Filename, [ OpenOutput ])
          end   ;
        if Terminals then
          begin
            Filename [Dot+1] := 'T';
            Filename [Dot+2] := 'E' ;
            Filename [Dot+3] := 'R' ;
            open (TerPas,Filename,[OpenOutput])
          end ;
        if Tables then
          begin
            Filename[Dot+1] := 'T';
            Filename[Dot+2] := 'A' ;
            Filename[Dot+3] := 'B';
            open (TabPas,Filename,[OpenOutput])
          end ;
        if PN then
          begin
            Filename [Dot+1] := 'P' ;
            Filename [Dot+2] := 'N' ;
            Filename [Dot+3] := ' ' ;
            open (PNPas,Filename,[OpenOutput])
          end ;
        NextCh;
    end;
end; ¯ InitP 



    procedure  Skip (SyS : setofsymbol)  ;

        ¯********************************************
        ¯*                                          *
        ¯*  Skip                                    *
        ¯*                                          *
        ¯* Skip Input String until RELEVANT symbol  *
        ¯*  IS FOUND                                *
        ¯********************************************
      begin
        while not(Sy in SyS) and not eof(Input) do InSymbol  ;
        Error (0)
      end  ;



    function FindId (IdName :word; Key : integer ; IdKind
        : setofnamety ) : identptrty ;
        ¯*********************************************
        ¯*                                           *
        ¯*  FindId                                   *
        ¯*                                           *
        ¯*     THIS procedure RETURNS A              *
        ¯*   A POinTER to THE GIVEN NAME AND type    *
        ¯*  in then symbol Table                     *
        ¯*                                           *
        ¯*********************************************

    var
        I : integer ;
        Found : boolean  ;
        P,Q  : identptrty;
      begin
        I := Key mod NAMETABSIZE ;
        Q := NameTab[I] ;
        Found := FALSE;
        P := NIL ;
        while (Q <> NIL) AND (not Found ) do
          begin
            if Q@.InternalName = IdName
            then
              begin
                Found := Q@.Kind in IdKind ;
                P := Q;
              end ;
            Q := Q@.Nic
          end ;
        FindId := P
      end ;




    function EnterId (ExtIdName, IntIdName: word; Key: integer;
        IdKind: namety; IdCode: codety; IdSy : symbol)  :  identptrty  ;
        ¯***************************************************
        ¯*                                                 *
        ¯*  EnterId                                        *
        ¯*                                                 *
        ¯*THIS procedure ENTERS THE GIVEN NAME             *
        ¯*  into THE symbol Table.  if THE NAME IS A       *
        ¯*  TerminAL THE TerminAL Code IS ENTERED AS       *
        ¯*  AN ATTRIBUTE of THE NEWLY ENTERED symbol.      *
        ¯*                                                 *
        ¯***************************************************
    label
        2;
    var
        I : integer ;
        P,Q : identptrty;
      begin
        ¯ EnterId 
        I := Key mod NAMETABSIZE ;
        Q := NameTab [I]  ;

        if Trace then
          begin
            writeln(TTYOut,'I= ',I,'Key= ',Key);
            BREAK
          end ;
        while Q <> NIL do
          begin
            if Q@.InternalName = IntIdName then
              begin
                Error (8) ;
                EnterId := Q;
                GOto 2
              end ;
            Q := Q@.Nic
          end ;
        new (P) ;
        with P@ do
          begin
            Nic := NIL  ;
            FirstAlt := NIL  ;
            ExternalName   := ExtIdName  ;
            InternalName   := IntIdName  ;
            SpId := IdSy ;
            Kind  := IdKind  ;
            if IdCode= -1 then IdCode :=MaxCode+1;
            if IdCode > MAXVOCSIZE then
                writeln(TTYOut,'Code is too big for cross indexing')
            else SymbolName[IdCode] := P ;
            Code  := IdCode  ;
            if IdCode > MaxCode then MaxCode := IdCode ;
            UsedIn  := NIL  ;
            Defin  := NIL
          end  ;
        Q := NameTab [I]  ;
        NameTab [I] := P  ;
        P@. Nic  := Q     ;
        EnterId  := P  ;
        2 :
      end  ;
    ¯ EnterId 


    procedure Terminal  ;
        ¯************************************************************
        ¯*                                                          *
        ¯*   Terminal                                               *
        ¯*                                                          *
        ¯* THIS procedure Reads THE Terminal                        *
        ¯* DefinITIONS AND ENTERS THEM in THE                       *
        ¯* symbol Table                                             *
        ¯************************************************************
    var

        TP   : identptrty ;
        LKey : integer ;
        InternalName,
        ExternalName : word;
        NotEof : boolean;
begin
        ¯ Terminal 
        InSymbol ;
    if InternalId <> 'BEGIN' then begin ¯ Terminal part need not be there 
        if InternalId <> 'TERMINAL' then
          begin
            Error (5) ;
            Skip ([SemiSy])
          end ;
        NotEof := not eof(Input);
        InSymbol  ;
        while (InternalId <> 'END') and NotEof do
          begin
            if (Sy <> Ident) AND (Sy <> Res) then
              begin
                Error (6);
                Skip ([Ident,Res])
              end;
            InternalName := InternalId  ;
            ExternalName := ExternalId  ;
            LKey := SyKey ;
            InSymbol;
            if Sy <> EqSy  then
              begin
                Error (7)  ;
                Skip ([Intconst])
              end
            else InSymbol  ;
            TP :=EnterId(ExternalName, InternalName, LKey, Term, SyVal, Sy);
            NotEof := not eof(Input);
            InSymbol  ;
            if Sy = SemiSy  then begin
                NotEof := not eof(Input);
                InSymbol;
            end;
          end  ;
        InSymbol ;
        if Sy= SemiSy then
            InSymbol;
    end; ¯ Allow Terminal part to be absent... 
end ;
    ¯ Terminal 



    procedure ReadG   ;
        ¯********************************************
        ¯*                                          *
        ¯*  ReadG                                   *
        ¯*                                          *
        ¯* THIS procedure Reads in THE Grammar      *
        ¯* AND SETS UP THE symbol Table             *
        ¯*                                          *
        ¯********************************************
    label
        1,2;
    var
        T,U¯ CURRENT RHS TranSITION 
        ,Q:   prodptrty ;¯ LHS Production 
        V,P:   identptrty ;¯ LHS symbol 
        R,S:   listptrty ;¯ of Production NO 
        PopNo:   integer ;
        NotEof : boolean;
      begin
        ¯ ReadG 
        if Trace then
          begin
            writeln(TTYOut,'ReadG') ;
            Break
          end ;
        if InternalId <> 'BEGIN' then
          begin
            Error(14) ;
            Skip([Ident,Res])
          end
        else InSymbol ;
        NotEof := TRUE;
        while (InternalId <> 'END') and NotEof do
          begin
            if (Sy <> Ident) AND (Sy <> Res) then
              begin
                  repeat
                    Error (9)  ;
                    Skip ([SemiSy])  ;
                    NotEof := not eof(Input);
                    InSymbol
                  until (Sy=Ident) or (Sy=Res) or not NotEof;
                goto 1
              end ;
            P := FindId (InternalId, SyKey, [NonTerm,Term])  ;
            if P <> NIL then
            if P@.Kind=Term then P@.Kind := NonTerm ;
            if P = NIL then
                P := EnterId ( ExternalId, InternalId, SyKey,
                               NonTerm, MaxCode+1, Sy );
            ¯ ENTER RHS 
            InSymbol   ;
            if Sy <> EqSy then
              begin
                Error (10)  ;
                Skip ([SemiSy])  ;
                InSymbol  ;
                goto 1
              end  ;
            Q := P@.FirstAlt ;
            if Q<> NIL then while Q@.NxtAlt<> NIL do
            Q := Q@.NxtAlt ;
              repeat
                PopNo := 0  ;
                new (U)  ;
                if Q = NIL then P@.FirstAlt := U
                else Q@.NxtAlt   := U  ;
                Q := U  ;
                with Q@ do
                  begin
                    Next := NIL  ;
                    XDef :=  P   ;
                    Action := NIL  ;
                    NxtAlt := NIL
                  end ;
                if  ProdNo < MAXRULENO then ProdNo := ProdNo +1
                else   Error (12)  ;
                new (R)  ;
                S := P@.Defin;
                if S <> NIL  then
                  begin
                    while S@.CDR <> NIL  do  S:= S@.CDR  ;
                    S@.CDR  := R ;
                  end
                else  P@.Defin  := R  ;

                R@.CDR := NIL ;
                R@.CAR  := ProdNo     ;
                RuleTab [ProdNo]  := Q;
                Q@.Production := ProdNo ;
                InSymbol;
                if (Sy = SemiSy) or (Sy = OrSy ) then
                  begin
                    PopTab [ProdNo] := PopNo ;
                    if PopNo > MaxPop then MaxPop := PopNo;
                    if Sy= SemiSy
                    then
                      begin
                        InSymbol  ;
                        goto 1
                      end
                    else
                    goto 2
                  end
                else while (Sy=Ident) or (Sy=Res) do
                  begin
                    PopNo := PopNo+1 ;
                    V :=  FindId (InternalId,SyKey, [NonTerm , Term]) ;
                    if V = NIL then
                        V := EnterId (ExternalId, InternalId, SyKey,
                                      Term, MaxCode+1, Sy) ;
                    new (T)  ;
                    U@.Next  :=T ;
                    U   :=T ;
                    T@.Action  := V  ;
                    T@.XDef     := P  ;
                    T@.NxtAlt := NIL  ;
                    T@.Next    := NIL  ;
                    S := V@.UsedIn  ;
                    new (R)  ;  R@.CDR  := NIL ;
                    if  S <> NIL then
                      begin
                        while  S@.CDR <> NIL do  S := S@.CDR  ;
                        S@.CDR  := R  ;
                      end
                    else    V@.UsedIn  :=  R ;
                    R@.CAR := ProdNo ;
                    InSymbol
                  end  ;
                PopTab[ProdNo] := PopNo ;
                if PopNo > MaxPop then MaxPop := PopNo;
                if Sy = SlashSy  then
                  begin
                    InSymbol ;
                    if Sy <> Ident
                    then
                      begin
                        Error (9)  ;
                        Skip ([SemiSy]);
                        goto 1
                      end  ;
                    V := FindId (InternalId, SyKey, [Lab]) ;
                    if V=NIL then
                        V:= EnterId (ExternalId, InternalId, SyKey, Lab,0, Sy) ;
                    S := V@.UsedIn ;
                    new(R) ; R@.CDR := NIL;
                    if S <> NIL then
                      begin
                        while S@.CDR <> NIL do S :=S@.CDR;
                        S@.CDR := R
                      end
                    else V@.UsedIn := R;
                    R@.CAR := ProdNo ;
                    Q@.Action := V  ;
                    InSymbol
                  end ;

                2:
              until Sy <> OrSy ;
            if Sy <> SemiSy then
              begin
                Error (13)  ;
                Skip ([SemiSy])  ;
              end ;
            NotEof := not eof(Input);
            InSymbol ;
            1:
          end ;
        MaxProdNo := ProdNo ;
        if (PopTab [1] <> 2) or
            (RuleTab [1]@.Next@.Next@.Action@.InternalName <> 'GOALSY')
         or (RuleTab[1]@.NxtAlt <> NIL)
        then writeln(TTYOut,'First production must have GOAL symbol.');
      end ;
    ¯ ReadG  



    procedure  PrintG ;
        ¯*****************************************************
        ¯*                                                   *
        ¯*  PrintG                                           *
        ¯*                                                   *
        ¯*THIS procedure PRinTS OUT A forMATTED              *
        ¯*  Grammar ONto FILENAM. new                        *
        ¯*                                                   *
        ¯*                                                   *
        ¯*                                                   *
        ¯*****************************************************
    var
        I,Count  : integer ;



        procedure PrintProd ( LHS : prodptrty
            ;ProdNo  :  integer  ) ;
            ¯***********************************************
            ¯*                                             *
            ¯* Print Prod                                  *
            ¯*                                             *
            ¯*   THIS procedure PRINTS OUT A Production    *
            ¯*                                             *
            ¯*                                             *
            ¯***********************************************
        var
            RHS    : prodptrty ;



            procedure    PrintRHS  ( LinK  :  prodptrty )  ;
                ¯***********************************************
                ¯*                                             *
                ¯* PrintRHS                                    *
                ¯*                                             *
                ¯*    THIS procedure PRINTS OUT THE RIGHT      *
                ¯*    HAND SIDE of A Production                *
                ¯*                                             *
                ¯*                                             *
                ¯***********************************************

              begin
                ¯ PrintRHS
                Count  := 0  ;
                if LinK= NIL
                then write(CrefPas,'                   ')
                else
                  repeat
                    if Count = 3  then
                      begin
                        writeln ( CrefPas)  ;
                        Count := 0  ;
                        write ( CrefPas,'                         ');
                      end   ;
                    Count := Count + 1   ;
                    write ( CrefPas, LinK@.Action@.ExternalName,'   ');
                    LinK :=  LinK@.Next
                  until  LinK = NIL  ;
                if LHS@.Action <> NIL
                then
                  begin
                    while Count <2 do
                      begin
                        write(CrefPas,'               ');
                        Count := Count+1 ;
                      end;
                    write ( CrefPas, '/  ', LHS@.Action@.ExternalName);
                  end ;
                if LHS@.NxtAlt = NIL
                then write ( CrefPas, '  ;  ');
              end ;
            ¯  PrintRHS 



          begin
            ¯ PRINT prod 
            if ProdNo <  10
            then write (CrefPas, '  ', ProdNo:1)
            else if ProdNo < 100
            then write (CrefPas, ' ', ProdNo : 2)
            else if ProdNo < 1000
            then write (CrefPas, ProdNo : 3)  ;
            if LHS@.XDef@.FirstAlt = LHS then
            write ( CrefPas,'   ', LHS@.XDef@.ExternalName, '=   ')
            else write ( CrefPas, '               ', '   !   ' );
            RHS :=  LHS@.Next ;
            PrintRHS (RHS)  ;
            writeln(CrefPas,' # ',LHS@.Production) ;
          end ;



      begin
        ¯ PRINT G
        I := B14 ;
        Ch := ChR (I) ;
        writeln (CrefPas, Ch)  ;
        writeln (CrefPas, '                      Grammar ');
        writeln (CrefPas, '                      ======= ');
        writeln (CrefPas)  ;
        for I := 1 to MAXRULENO do
        if RuleTab [I] <> NIL
        then PrintProd (RuleTab [I], I) ;
        writeln (CrefPas, Ch)
      end  ;
    ¯ PRINT G








    procedure  PrintCref ;
        ¯******************************************************
        ¯*                                                    *
        ¯*PrintCref                                           *
        ¯*                                                    *
        ¯*   THIS procedure CONTROLS THE PRINTinG of THE      *
        ¯*    CROSS REFERENCE listinG                         *
        ¯*                                                    *
        ¯*                                                    *
        ¯******************************************************
    type
        symlistptrty = @ symlist ;
        symlist =  record
                          Sym : identptrty;
                          CDR : symlistptrty
                   end ;
    var
        Head  :  symlist  ;
        I  :  integer  ;
        Ch  :  char     ;

procedure PrintTerm (IdKind : setofnamety) ;

        ¯*****************************************
        ¯*                                       *
        ¯* PrintTerm                             *
        ¯*                                       *
        ¯*  THIS procedure PRINTS OUT THE        *
        ¯* Terminal symbol DefinITIONS           *
        ¯*                                       *
        ¯*****************************************

var

        P : symlistptrty;



begin    ¯ PrintTerm 


        P := Head.CDR ;

        while P <> NIL do begin
                if P@.Sym@.Kind in IdKind then begin
                    write(TerPas,P@.Sym@.ExternalName,' = ');
                    if P@.Sym@.SpId = Res then
                        writeln(TerPas, '-1 ;')
                    else
                        writeln(TerPas,P@.Sym@.Code,' ;');
                end;
                P := P@.CDR ;

        end ;

end  ¯ PrintTerm  ;



        procedure   PrintVoc  (IdKind : setofnamety) ;
            ¯**********************************************************
            ¯*                                                        *
            ¯*    PrintVoc                                            *
            ¯*                                                        *
            ¯*        THIS procedure PRINTS OUT CROSS REFERENCE       *
            ¯*   inforMATION for Terminals , NON-                     *
            ¯*   Terminals AND Action labelS                          *
            ¯*                                                        *
            ¯**********************************************************
        var
            P   :    symlistptrty ;
            Count :   integer    ;
            Q :    listptrty ;
          begin
            ¯  PRINT VOC  
            if Trace then
              begin
                writeln(TTYOut,'VOC') ;
                Break
              end ;
            P :=   Head.CDR ;
            while  P <> NIL  do
              begin
                if       P@.Sym@.Kind
                in  IdKind
                then
                  begin
                    writeln (CrefPas)  ;
                    writeln(CrefPas);writeln(CrefPas);
                    write(CrefPas, P@.Sym@.ExternalName);
                    if P@.Sym@.SpId <> Res then
                        write(CrefPas, '  ',P@.Sym@.Code)
                    else
                        write(CrefPas,'     Reserved');
                    writeln(CrefPas) ;
                    write(CrefPas, ' Defined ') ;
                    Count := 0   ;
                    Q := P@.Sym@.Defin;
                    while  Q <> NIL  do
                      begin
                        if Count = 4 then
                          begin
                            writeln (CrefPas) ;
                            Count:=0          ;
                            write  (CrefPas,'         ')
                          end ;
                        Count := Count +1   ;
                        write (CrefPas, Q@.CAR, '   ') ;
                        Q := Q@.CDR
                      end     ;
                    writeln (CrefPas);
                    Count  :=0;
                    Q := P@.Sym@.UsedIn ;
                    write (CrefPas, ' Used    ') ;
                    while Q <> NIL  do
                      begin
                        if   Count =4   then
                          begin
                            writeln (CrefPas) ;
                            Count :=0  ;
                            write (CrefPas,'         ')
                          end   ;
                        Count := Count +1 ;
                        write (CrefPas , Q@.CAR, '   ') ;
                        Q := Q@.CDR
                      end   ;
                  end ;
                P:= P@.CDR
              end   ;
          end ;
        ¯  PRINT VOC  



        procedure    Sort ;
            ¯************************************************
            ¯*                                              *
            ¯*    Sort                                      *
            ¯*                                              *
            ¯*       THIS procedure SortS THE symbol Table  *
            ¯*                                              *
            ¯************************************************
        label
            1,2;
        var
            I,K :  integer      ;
            X   :   identptrty ;
            P,Q,R   :   symlistptrty ;
          begin
            ¯  Sort  
            if Trace then
              begin
                writeln(TTYOut,'Sort');
                Break
              end ;
            Head.CDR := NIL ;
            for K :=  0 to  NAMETABSIZE         do
              begin
                X := NameTab [K] ;
                while X <> NIL  do
                  begin
                    new (R)   ;
                    R@.Sym  := X  ;
                    R@.CDR  := NIL;
                       ¯  Enter in chain  
                    Q       := Head.CDR   ;
                    if Q=NIL then Head.CDR:= R
                    else
                      begin
                        if R@.Sym@.InternalName<Q@.Sym@.InternalName
                        then
                          begin
                            Head.CDR := R;
                            R@.CDR := Q
                          end
                        else
                          begin
                            P       :=  Q@.CDR    ;
                            while (P <> NIL)
                            do
                              begin
                                if R@.Sym@.InternalName < P@.Sym@.InternalName
                                    then goto 1;
                                Q :=P   ;
                                P := P@.CDR
                              end   ;
                            1:  Q@.CDR := R  ;
                            R@.CDR := P
                          end ;
                      end ;
                    X:= X@.Nic
                  end
              end   ;
            ¯  for  
            2:
          end   ;
        ¯  Sort  
      begin
        ¯  PRINT CREF  
        mark(Heap);
        Sort ;
        if Grammar then begin
        I :=  B14   ;
        Ch :=  ChR(I)  ;
        writeln (CrefPas, Ch)   ;
        writeln (CrefPas, '                      Cross Reference ');
        writeln (CrefPas, '                      ================');
        writeln (CrefPas,'      Terminals') ;
        writeln (CrefPas);
        PrintVoc([Term])      ;
        writeln (CrefPas, Ch) ;
        writeln (CrefPas,'     Non Terminals')  ;
        PrintVoc([NonTerm])    ;
        writeln (CrefPas, Ch)  ;
        writeln (CrefPas, '     Label')  ;

        PrintVoc([Lab]) ;
        writeln (CrefPas, Ch)  ;
        end ;
        if Terminals and NonTerminals then
            PrintTerm([ Term, NonTerm ])
        else if Terminals then
            PrintTerm([Term])
        else if NonTerminals then
            PrintTerm([NonTerm]);
        release (Heap)
      end   ;
    ¯  PRINT CREF  






    procedure PrintCon (T : tranptrty) ;
        ¯********************************************************
        ¯*                                                      *
        ¯*    PrintCon                                          *
        ¯*                                                      *
        ¯*   THIS procedure PRINT A CONFIGURATION in Symbolic   *
        ¯* forM                                                 *
        ¯*                                                      *
        ¯*   in :   T  GIVEN CONFIGURATION                      *
        ¯********************************************************
    var
        X : integer ;
        J : integer ;
        Red,SameLine : boolean ;
        P : prodptrty ;



      begin
        ¯ PRINT CON  
        X := T@.Pos ;
        P := T@.Rule ;
        SameLine := TRUE ;
        Red := FALSE ;
        J := 0 ;
        write(CrefPas,'* ');
        write(CrefPas,P@.XDef@.ExternalName);
        write(CrefPas,' = ');
        while X <> 0 do
          begin
            P := P@.Next ;
            write (CrefPas,P@.Action@.ExternalName,' ') ;
            X := X-1 ;
            J := J+1;
            if J >= 3 then
              begin
                writeln(CrefPas,'   *');
                write(CrefPas,'*                   ');
                J := 0
              end ;
          end ;
        write(CrefPas,'# ');
        P := P@.Next ;
        if P= NIL then Red := TRUE else Red := FALSE ;
        while P <> NIL do
          begin
            write(CrefPas,P@.Action@.ExternalName,' ');
            J := J+1 ;
            if J >= 3 then
              begin
                writeln(CrefPas,' *');
                write(CrefPas,'*                     ');
                SameLine := FALSE ;
                J := 0 ;
              end ;
            P := P@.Next
          end ;
        if Red then
          begin
            while J < 2 do
              begin
                write(CrefPas,'                ');
                J := J+1 ;
              end ;
            P := T@.Rule ;
            if P@.Action <> NIL then
              begin
                write(CrefPas,'/ ');
                write(CrefPas,P@.Action@.ExternalName);
                writeln(CrefPas,'*');
                if T@.NextState <> NIL then
                writeln(CrefPas,'*                                  ',
                '                   ',T@.NextState@.State:10,'       *');
              end
            else if T@.NextState <> NIL
            then writeln(CrefPas,T@.NextState@.State:10,'       *')
            else writeln(CrefPas,'                 *');
          end
        else
          begin
            while J <2 do
              begin
                write(CrefPas,'                ');
                J := J+1
              end ;
            if T@.NextState <> NIL then
              begin
                write(CrefPas,T@.NextState@.State: 10);
                if SameLine then writeln(CrefPas,'       *')
                else writeln(CrefPas,'       *');
              end
            else if SameLine then writeln(CrefPas,'                 *')
            else writeln(CrefPas,'                 *');
          end
      end   ¯   PRINT CON    ;



    procedure PrintState(S :stateptrty)  ;
        ¯**************************************************
        ¯*                                                *
        ¯*  PrintState                                    *
        ¯*                                                *
        ¯*  THIS PROC PRINTS A State                      *
        ¯*   in   :   S State                             *
        ¯**************************************************
    var
        T : tranptrty ;
        ST : stateptrty ;


      begin
        ¯ PrintState 

        writeln(CrefPas) ;
        writeln(CrefPas) ;
        writeln(CrefPas,'*******************************************',
                        '*****************************');
        write(CrefPas,'*     State ');
        write(CrefPas,S@.State) ;
          case S@.Kind of
            Reads : write(CrefPas,' read State ');
            Inadequate:write (CrefPas,' Inadequate ');
            Lookahead :write (CrefPas, ' Lookahead  ') ;
            Reduction  : write (CrefPas, ' Reduction  ') ;
            LAString : write (CrefPas,' LAString   ') ;
            Subgoal : write (CrefPas, ' Subgoal    ')
          end ;
        writeln( CrefPas, '                                   *');
        writeln(CrefPas,'*******************************************',
                        '*****************************');
        writeln(CrefPas,'*                                          ',
                        '                            *');
        T := S@.FirstTran ;
        while T <> NIL do
          begin
            PrintCon(T) ;
            T := T@.Next
          end ;
        writeln(CrefPas,'*******************************************',
                        '*****************************');
        writeln(CrefPas) ;
        writeln(CrefPas)
      end  ¯ PrintState    ;



    procedure OutFSM ;
        ¯*********************************************
        ¯*                                           *
        ¯*         OutFSM                            *
        ¯*    THIS PROC OUTPUTS FSM Tables           *
        ¯*                                           *
        ¯*********************************************

    label
        1;
    var
        I : integer ;


      begin
        ¯ OutFSM 
        I := B14 ;
        Ch := ChR(I) ;
        writeln(CrefPas,Ch) ;
        writeln(CrefPas,'                      Characteristic States');
        writeln(CrefPas,'                      =====================');
        writeln(CrefPas);writeln(CrefPas);writeln(CrefPas);
        for I := 0 to MAXSTATE do
          begin
            if NState [ I ] = NIL then goto 1 ;
            PrintState (NState [I])
          end ;
        1:
      end     ¯ OutFSM   ;







    procedure PrintTab ;
        ¯************************************************
        ¯*                                              *
        ¯* PrintTab                                     *
        ¯*                                              *
        ¯*    THIS procedure PRINTS THE symbol Action   *
        ¯*  Tables .                                    *
        ¯*                                              *
        ¯************************************************

    var
        I : integer ;
        T,A : integer ;



      begin
        ¯ PRINT TAB
        I := B14 ;
        Ch := ChR(I);
        writeln(CrefPas,Ch);
      I := 3*Index +3 ; ¯ NUMBER of ENTRIES
        writeln(CrefPas);
        writeln(CrefPas,'                Parsing Tables');
        writeln(CrefPas,'                ==============');
        writeln(CrefPas);writeln(CrefPas);writeln(CrefPas);
        writeln(CrefPas,'.__________________________________________',
                        '___________________________.');
        writeln(CrefPas,'! Index  Symbol Name                 Action',
                        '  Pop    Semantics         !');
        writeln(CrefPas,'.__________________________________________',
'___________________________.');
        for I := 0 to Index do
          begin
            write(CrefPas,'!',I:5);
            T := Table[I].Tran ;
            A := Table[I].Action ;
            if T=elseCode then write(CrefPas,'    ELSE')
            else if T=XCONTinUE then  write(CrefPas,'    CONT')
            else write (CrefPas,'   ',T:5);
            if (T >=0 ) AND (T <= MAXVOCSIZE)
            then write(CrefPas,'  ',SymbolName[T]@.ExternalName)
            else write(CrefPas,'                 ');
            if A<= 0 then
              begin
                if A <= -NOSCANCODE then write(CrefPas,' ',-A-NOSCANCODE:4,'#')
                else
                write(CrefPas,' ',-A:4,'#');
                if A <= -NOSCANCODE then write(CrefPas,'NO SCAN')
                else write (CrefPas,'       ');
              end
            else if A= ERRORCODE  then write(CrefPas,'   Error            ')
            else write(CrefPas,'   ',A:5,'            ');


            if A < 0 then
              begin
                if A <= - NOSCANCODE then A := A+NOSCANCODE;
                write(CrefPas,PopTab[-A]:4,'     ');
                if RuleTab[-A]@.Action <> NIL then
                    write(CrefPas,RuleTab[-A]@.Action@.ExternalName)
                else write(CrefPas,'               ');
              end
            else write(CrefPas,'                 ');
            writeln(CrefPas,'  !');
            writeln(CrefPas,'.______________________________________',
                            '_______________________________.');
          end ¯ for ;
      end ¯ PRINT TAB ;



    function NextTran (S :stateptrty; T : tranptrty ):tranptrty ;

        ¯******************************************************
        ¯*                                                    *
        ¯* NextTran                                           *
        ¯*                                                    *
        ¯*    THIS function GETS THE Next UNMarkED            *
        ¯* TranSITION FROM State S. THE CURRENT TranSITION IS *
        ¯* T. IT RETURNS NIL if NO Next TranSITION EXISTS     *
        ¯*                                                    *
        ¯*  in    : S    CURRENT State                        *
        ¯*          T    CURRENT TranSITION                   *
        ¯*                                                    *
        ¯*  OUT   :                                           *
        ¯*                                                    *
        ¯*  GLOBAL                                            *
        ¯*                                                    *
        ¯* ResULT    PTR to Next TranSITION                   *
        ¯******************************************************


    label
        1;
    var
        CurTran   : tranptrty   ;

      begin
        ¯ NextTran 
        if Trace then
          begin
            writeln(TTYOut,'NextTran');Break
          end;
        CurTran := T ;
        if CurTran = NIL then
          begin
            CurTran := S@.FirstTran ;
            if CurTran = NIL then
                writeln(TTYOut,'**System error** in NextTran');
            CurTran@.MarkE := TRUE
          end
        else
          begin
            while  CurTran@.MarkE do
              begin
                CurTran := CurTran@.Next ;
                if CurTran = NIL then goto 1
              end ;
            1:    if CurTran = NIL then
              begin
                CurTran := S@.FirstTran ;
                  repeat
                    CurTran@.MarkE := FALSE ;
                    CurTran       := CurTran@.Next
                  until CurTran = NIL
              end
            else CurTran@.MarkE := TRUE
          end ;
        NextTran := CurTran
      end     ¯ NextTran    ;









    function ConMatch(C1,C2 : tranptrty) : boolean ;
        ¯***************************************************
        ¯*                                                 *
        ¯*   ConMatch                                      *
        ¯*                                                 *
        ¯*     THIS function COMPARes TWO CONFIGURATIONS   *
        ¯*  AND RETURNS THE ResULT                         *
        ¯*      TWO CONFIGURATIONS MATCh if EVERYTHinG     *
        ¯* BEYOND THE Dot MATChES inCL THE Action          *
        ¯*   for THE Research VERSION . OTHERWISE USUAL DRF *
        ¯*                                                 *
        ¯*    in      : C1,C2 CONFIGURATIONS               *
        ¯*                                                 *
        ¯*                                                 *
        ¯*   GLOBAL          in :   RuleTab                *
        ¯*                                                 *
        ¯*  ResULT     TRUE if MATChES                     *
        ¯***************************************************


    label
        1;
    var
        I1, I2,I   : integer  ;
        X1,X2  : prodptrty ;



      begin
        ¯ ConMatch    
        I1 :=C1@.Pos ;
        I2 := C2@.Pos ;
        X1 := C1@.Rule ;
        X2 := C2@.Rule ;
        if not Research then begin
            if (I1=I2) and (X1=X2) then
                ConMatch := TRUE
            else
                ConMatch := FALSE;
        end else begin
            if (X1@.Action <> X2@.Action) or (I1 <> I2) then
                ConMatch := FALSE
            else begin
                for I := 0 to I1 do
                X1:= X1@.Next ;
                for I := 0 to I2 do
                X2 := X2@.Next ;
                while (X1<>NIL) and (X2 <> NIL) do
                  begin
                    if X1@.Action <> X2@.Action
                    then
                      begin
                        ConMatch := FALSE;
                        goto 1
                      end ;
                    X1:= X1@.Next;
                    X2 := X2@.Next

                  end ;
                if (X1=NIL) and (X2 = NIL)
                then ConMatch := TRUE
                else ConMatch  := FALSE ;
              end ;
          end ;
        1:

      end  ¯ ConMatch     ;



    procedure AddT( S: stateptrty ; T : tranptrty) ;
        ¯*****************************************************
        ¯*                                                   *
        ¯*  AddT                                             *
        ¯*                                                   *
        ¯*     THIS procedure ADDS A CONFIGURATION to THE    *
        ¯* GIVEN State . IT ALSO MAKES SURE THE doES not EXIST*
        ¯*  BEforE ENTERinG IT                               *
        ¯*     in       :S   GIVEN State                     *
        ¯*               T  GIVEN CONFIGURATION              *
        ¯*****************************************************


    label
        1;
    var
        Tx,Ty   : tranptrty ;



      begin
        ¯  AddT  

        Tx  := S@.FirstTran  ;
        if Tx = NIL then S@.FirstTran := T
        else
          begin
            while Tx <> NIL do
              begin
                if ConMatch(Tx,T) then goto 1  ;
                Ty := Tx ;
                Tx := Tx@.Next
              end ;
            Ty@.Next   := T  ;
          end ;
        1:
      end   ¯ AddT    ;






    function Token(PR : prodptrty ;PS : integer) : identptrty ;
        ¯***************************************************
        ¯*                                                 *
        ¯*  Token                                          *
        ¯*                                                 *
        ¯* THIS function RETURNS A POinTER to THE NE T     *
        ¯* Token GIVEN A Rule NO. and  A Pos NUM           *
        ¯*                                                 *
        ¯*   in         : PS   PosITION                    *
        ¯*                 PR Production                   *
        ¯*   OUT                                           *
        ¯*                                                 *
        ¯   ResULT         PTR to Next Token               *
        ¯***************************************************

    label
        1;
    var
        X : identptrty    ;
        I :  integer    ;
        Y  : prodptrty  ;



      begin
        ¯ Token   
        Token := NIL;
        Y := PR ;
        for I := 0 to PS
        do
          begin
            Y := Y@.Next ;
            if Y = NIL then
            goto 1
          end ;
        Token :=Y@.Action ;
        1:

      end   ¯ Token  ;



    procedure AddL (S :stateptrty) ;
        ¯***************************************************
        ¯*                                                 *
        ¯*  AddL                                           *
        ¯*                                                 *
        ¯*    THIS procedure ADDS A State to THE list of   *
        ¯*  of Inadequate StateS                           *
        ¯*                                                 *
        ¯*    in : S State                                 *
        ¯*                                                 *
        ¯***************************************************

    var
        X,Y  : statelistptr ;



      begin
        ¯ AddL 
        new(X)  ;
        X@.CAR := S  ;
        X@.CDR := NIL ;
        if Inadeq = NIL then Inadeq := X
        else
          begin
            Y := Inadeq ;
            while Y@.CDR <> NIL do Y := Y@.CDR ;
            Y@.CDR := X
          end
      end   ¯ AddL   ;




    procedure   CFSM (var  Lr0 : boolean)   ;
        ¯*********************************************************
        ¯*                                                       *
        ¯*     CFSM                                              *
        ¯*       THIS procedure COMPUTES THE charACTERISTIC      *
        ¯*  FinITE State MAChinE. Lr0 IS set to FALSE            *
        ¯*  if ANY Inadequate State EXISTS. A list of Inadequate *
        ¯*  StateS IS MAinTAinED BY GENS                         *
        ¯*                                                       *
        ¯*                                                       *
        ¯*                                                       *
        ¯*********************************************************
    var
        S : stateptrty ;
        S1   : stateptrty ;
        Sl1 : statelistptr ;
        AllReduce : boolean ;



        procedure Closure (A :stateptrty;C:tranptrty;
            var Reduce : boolean) ;
            ¯**************************************************
            ¯*                                                *
            ¯*   Closure                                      *
            ¯*                                                *
            ¯*     THIS procedure PERforMS THE Closure        *
            ¯* function ON THE GIVEN CONFIGURATIONS           *
            ¯*                                                *
            ¯*    in     : A  THE GIVEN State                 *
            ¯*             C   CURRENT CONFIG                 *
            ¯*    OUT    : Reduce  set to TRUE if Reduction   *
            ¯*                         N State                *
            ¯*                                                *
            ¯*   GLOBAL                                       *
            ¯*                                                *
            ¯**************************************************


        label
            1;
        var
            CPos : integer   ;
            Con,CRule : prodptrty ;
            X,Tran   : tranptrty  ;
            Nt   : identptrty   ;
            function Config(Pr : prodptrty ; N: integer) : tranptrty ;






                ¯*****************************************************
                ¯*                                                   *
                ¯*  Config                                           *
                ¯*                                                   *
                ¯*     THIS function CREAES A ConfigURATION          *
                ¯*                                                   *
                ¯*    in          :  Pr  Production                  *
                ¯*                N    PosITION in prod              *
                ¯*                                                   *
                ¯*  ResULT         PTR to new Config                 *
                ¯*****************************************************


            var
                X   : tranptrty    ;

              begin
                ¯  Config   
                new(X) ;
                with X@
                do
                  begin
                    Rule := Pr ;
                    Pos := N  ;
                    MarkE  := FALSE ;
                    Next := NIL ;
                    NextState := NIL
                  end ;
                Config  := X


              end ¯ Config    ;



          begin
            ¯ Closure   
            if Trace then
              begin
                writeln(TTYOut,'Closure');Break
              end ;
            CRule  := C@.Rule ;
            CPos   := C@.Pos;
            Nt    :=  Token(CRule,CPos) ;
            if Nt <> NIL
            then
              begin
                AllReduce := FALSE ;
                if Nt@.Kind = NonTerm
                then
                  begin
                    Tran := A@.FirstTran ;
                      repeat
                        if (Nt =Tran@.Rule@.XDef) and
                        (Tran@.Pos = 0) then goto 1;
                        Tran := Tran@.Next
                      until Tran = NIL ;
                    Con := Nt@.FirstAlt;
                    while Con <> NIL do
                      begin
                        X := Config(Con,0);
                        AddT(A,X) ;
                        Con := Con@.NxtAlt
                      end
                  end
              end
            else Reduce := TRUE ;
            1:
          end ¯ Closure       ;


        function CIS : stateptrty ;
            ¯*****************************************************
            ¯*                                                   *
            ¯*  CIS                                              *
            ¯*                                                   *
            ¯* THIS procedure SETS UP THE inITIAL State and      *
            ¯* ALSO ChECKS to SEE if THE FIRST Production        *
            ¯* WAS APPrOPrIATELY SET. if not IT GIVES AN Error   *
            ¯*   IT RETURNS A POinTER to THE FIRST State         *
            ¯*                                                   *
            ¯*    GLOBAL    in:   RuleTab                        *
            ¯*                    PopTab                         *
            ¯*                                                   *
            ¯*            OUT :   StateTab                       *
            ¯*                    NState,CurrentState            *
            ¯*                                                   *
            ¯*                                                   *
            ¯*   ResULT    POinTER to FIRST State                *
            ¯*                                                   *
            ¯*****************************************************
        var
            X  : stateptrty ;
            Y  : tranptrty ;
            I   : integer ;
            B   : boolean ;
          begin
            ¯  CIS 
            if Trace then
              begin
                writeln(TTYOut,'CIS');
                Break
              end  ;
            I := 0 ;
            new(X) ;
            new(Y) ;
            CurrentState := 0 ;
            StateTab [0] := X ;
            with X@ do
              begin
                FirstTran := Y ;
                Back      := NIL ;
                Nic       := NIL ;
                State     := 0 ;
                Kind       := Reads
              end ;
            NState [ 0] := X;
            with Y@ do
              begin
                Next := NIL ;
                NextState := NIL ;
                Rule      := RuleTab [1] ;
                Pos       := 0 ;
                MarkE      := FALSE
              end ;
            I  := 1 ;
            CIS := X ;
            B := FALSE ;
            AllReduce := TRUE ;
            Y := NIL ;
              repeat begin
                Y := NextTran(X,Y) ;
                if Y = NIL then
                    leave;
                Closure( X,Y,B) ;
                I := I+1 ;
              end until 1 <> 1;
            if B then if I= 1 then X@.Kind := Reduction
            else
              begin
                AddL(X) ;
                X@.Kind := Inadequate ;
              end ;
          end    ¯ CIS    ;




        procedure GenS (S : stateptrty ; var Lr0: boolean) ;

            ¯*****************************************************
            ¯*                                                   *
            ¯*  GenS                                             *
            ¯*                                                   *
            ¯*  THIS procedure GENERATES THE State MAChinE       *
            ¯* RECURSIVELY. IT SETS Lr0 to FALSE if NECESSARY    *
            ¯*                                                   *
            ¯*   in    :  S  CURRENt State                       *
            ¯*                                                   *
            ¯*   OUT   :  Lr0  inDICATES if MAChinE IS Lr0       *
            ¯*                                                   *
            ¯*   GLOBAL                                          *
            ¯*****************************************************


        var
            Z : prodptrty   ;
            I : integer   ; ¯ ConTROL  varIABLE
            X : tranptrty    ;
            Y : stateptrty   ;
            B : boolean     ;




            function CHash( S: stateptrty) : integer ;
                ¯**************************************************
                ¯*                                                *
                ¯*  CHash                                         *
                ¯*                                                *
                ¯*     THIS procedure produces A Key.IT USES      *
                ¯* THash to produce THE Key                       *
                ¯*                                                *
                ¯*  in   : S State                                *
                ¯*                                                *
                ¯**************************************************
            var
                Key   : integer   ;
                T     : tranptrty ;



                function THash( X: tranptrty) : integer ;
                    ¯**************************************************
                    ¯*                                                *
                    ¯* THash                                          *
                    ¯*                                                *
                    ¯*  THIS function RETURNS AN integer REPresENtinG *
                    ¯* A ConfigURATION                                *
                    ¯*                                                *
                    ¯*   in :  X TranSITION                           *
                    ¯*                                                *
                    ¯*                                                *
                    ¯**************************************************

                var
                    Y   : prodptrty ;
                    I    : integer ;
                    TKey : integer ;



                    function Number(S: identptrty): integer ;
                      ¯*****************************************************
                      ¯*                                                   *
                      ¯*  Number                                           *
                      ¯*                                                   *
                      ¯*  THIS function RETURNS AN integer BASED ON THE    *
                      ¯* VALUE of THE IdentifIER                           *
                      ¯*                                                   *
                      ¯*   in : S IdentifIER                               *
                      ¯*****************************************************
                   var
                        Y : word ;
                        I    : integer ;
                        Tally : integer ;
                      begin
                        ¯ Number 
                        Tally := 0 ;
                        if S <> NIL then
                          begin
                            Y := S@.ExternalName ;
                            for  I := 1 to MAXNAME do
                            Tally := Tally +ord(Y[I])
                          end  ;
                        Number := Tally

                      end    ¯ Number      ;


                  begin
                    ¯ THash 
                    Y := X@.Rule ;
                    TKey :=  Number(Y@.Action) ;
                    for I := 0 to X@.Pos do Y := Y@.Next ;
                    if Y <> NIL then
                    TKey := TKey+Number(Y@.Action) ;
                    THash := TKey
                  end      ¯ THash     ;





              begin
                ¯ CHash 
                Key := 0 ;
                T := S@.FirstTran ;
                while T <> NIL do
                  begin
                    Key := Key +THash(T) ;
                    T := T@.Next
                  end ;
                CHash := Key
              end ;
            ¯ CHash






            function Complete ( S : stateptrty; T : tranptrty) :
                stateptrty ;

                ¯****************************************************
                ¯*                                                  *
                ¯* Complete                                         *
                ¯*                                                  *
                ¯* THIS function CREATES A new State and CompleteS IT *
                ¯* IT RETURNS A POinTER to THE CompleteD State       *
                ¯*                                                   *
                ¯*   in    :  S   CURRENt State                      *
                ¯*            T   TranSITION State                   *
                ¯*   OUT   :                                         *
                ¯*                                                   *
                ¯*   GLOBAL                                          *
                ¯*                                                   *
                ¯*  ResULT   PTR to CompleteD State                  *
                ¯*****************************************************

            var
                A : stateptrty ;
                C : tranptrty ;
                Reduce : boolean  ;
                I  : integer    ;



                function Collect (S :stateptrty;T : tranptrty):stateptrty ;
                    ¯************************************************
                    ¯*                                              *
                    ¯*  Collect                                     *
                    ¯*                                              *
                    ¯*  THIS function CREATES A new State  for THE  *
                    ¯* GIVEN TranSITION. IT ALSO CollectS ALL       *
                    ¯* TranSITIONS WHICh HAVE THE SAME TranSITION   *
                    ¯* Token and ADDS IT to THE State               *
                    ¯*                                              *
                    ¯*  in     : S CURRENt State                    *
                    ¯*              T CURRENt TranSITION            *
                    ¯*                                              *
                    ¯*   OUT                                        *
                    ¯*                                              *
                    ¯*   GLOBAL                                     *
                    ¯*                                              *
                    ¯*  ResULT  PTR to new State                    *
                    ¯************************************************

                var
                    X,Z : tranptrty ;
                    Y : stateptrty ;



                    function TranMatch(T1,T2 : tranptrty) : boolean ;
                       ¯***********************************************
                       ¯                                              *
                       ¯*  TranMatch                                  *
                       ¯*                                             *
                       ¯*  THIS function ChECKS to SEE if THE TranSITION *
                       ¯*  Token for THE GIVEN TWO ConfigURATIONS     *
                       ¯*  IS THE SAME                                *
                       ¯*                                             *
                       ¯*   in       : T1,T2  ConfigURATIONS          *
                       ¯*                                             *
                       ¯*    OUT     :                                *
                       ¯*                                             *
                       ¯*   GLOBAL                                    *
                       ¯*                                             *
                       ¯*    ResULT IS TRUE if THEY MATCh             *
                       ¯***********************************************


                    var
                        R : prodptrty ;
                        I  : integer  ;
                        S1,S2 : identptrty ;



                      begin
                        ¯ TranMatch  
                        R   := T1@.Rule  ;
                        for I := 0 to T1@.Pos do
                            R := R@.Next  ;
                        if R = NIL then S1 := NIL
                            else S1 := R@.Action ;

                        R := T2@.Rule  ;
                        for I := 0 to T2@.Pos
                            do R := R@.Next ;
                        if R = NIL then  S2 := NIL
                            else  S2 := R@.Action  ;

                        TranMatch := S1=S2  ;

                      end       ¯ TranMatch      ;



                    function CreateS (S:stateptrty; T: tranptrty):stateptrty ;
                      ¯******************************************************
                      ¯*                                                    *
                      ¯*   CreateS                                          *
                      ¯*                                                    *
                      ¯*    THIS function CreateS A new State with A SinGLE *
                      ¯*  ConfigURATION T . IT doES not ENtER THE State     *
                      ¯* into  THE  State Table  SinCE THE State CompleteD  *
                      ¯ MAY EXIST ALreadY                                   *
                      ¯*                                                    *
                      ¯*    IT RETURNS A POinTER to THE newLY CREATED State *
                      ¯*                                                    *
                      ¯*   in        : S PARENt State                       *
                      ¯*               T  CURRENt ConfigURATION             *
                      ¯*                                                    *
                      ¯*   OUT       :                                      *
                      ¯*                                                    *
                      ¯*   GLOBAL                                           *
                      ¯*                                                    *
                      ¯    ResULT    PTR to new State                       *
                      ¯******************************************************



                    var
                        X   : stateptrty ;



                      begin
                        ¯ CreateS   
                        new(X)    ;
                        with X@ do
                          begin
                            FirstTran := T;
                            Nic   := NIL ;
                            Back     := NIL ;
                            State := 0    ;
                            Kind      :=Reads
                          end ;


                        CreateS := X
                      end        ¯ CreateS    ;



                    function  MoveDot (T : tranptrty) : tranptrty ;
                        ¯***************************************************
                        ¯*                                                 *
                        ¯*   MoveDot                                       *
                        ¯*                                                 *
                        ¯*       THIS function CreateS A new  ConfigURATION*
                        ¯* with THE PosITION of THE Dot MOVED OVER         *
                        ¯*    IT RETURNS A POinTER to THIS TranSITION      *
                        ¯* IT doES not WATChOUT for ReductionS. THIS  ID   *
                        ¯* BY THE Closure function                         *
                        ¯*                                                 *
                        ¯*     in         : T CURRENt Config               *
                        ¯*                                                 *
                        ¯*     OUT         :                               *
                        ¯*                                                 *
                        ¯*      GLOBAL                                     *
                        ¯*                                                 *
                        ¯*    ResULT     PTR to new ConfigURATION          *
                        ¯***************************************************


                    var
                        X  : tranptrty ;

                      begin
                        ¯ MoveDot 
                        new(X)   ;
                        with X@ do
                          begin
                            MarkE := FALSE ;
                            Next := NIL ;
                            NextState := NIL  ;
                            Rule := T@.Rule ;
                            Pos := T@.Pos +1
                          end ;


                        MoveDot  := X
                      end    ¯ MOVE Dot      ;









                  begin
                    ¯ Collect  
                    X := MoveDot (T) ;
                    Y := CreateS (S,X)  ;
                    Z := T@.Next ;
                    while Z <> NIL do
                      begin
                        if TranMatch (Z,T)
                        then
                          begin
                            Z@.MarkE := TRUE;
                            X := MoveDot(Z) ;
                            AddT(Y,X)
                          end ;
                        Z := Z@.Next ;
                      end  ;
                    Collect := Y
                  end      ¯ Collect      ;






              begin
                ¯ Complete 
                if Trace then
                  begin
                    writeln(TTYOut,'Complete');
                    Break
                  end ;
                A := Collect(S,T) ;
                C := NextTran( A,NIL) ;
                AllReduce := TRUE ;
                Reduce := FALSE ;
                I := 0   ;
                while C <> NIL do
                  begin
                    Closure(A,C,Reduce) ;
                    I   := I+1 ;
                    C := NextTran(A,C)
                  end ;
                if Reduce then if I=1 then A@.Kind := Reduction
                else
                  begin
                    A@.Kind := Inadequate ;
                    Lr0  := FALSE
                  end ;
                Complete := A
              end   ¯ Complete   ;

            procedure FindS(var S: stateptrty;var Found:boolean) ;
                ¯****************************************************
                ¯*                                                  *
                ¯*  FindS                                           *
                ¯*                                                  *
                ¯*    THIS procedure ChECKS to SEE if THE GIVEN     *
                ¯* State ALreadY EXISTS. if SO IT UPDATES S to      *
                ¯* POinT to THE EXISTinG State. in THIS case Found  *
                ¯* IS set to TRUE                                   *
                ¯*                                                  *
                ¯*     in:                                          *
                ¯*                                                  *
                ¯*   OUT : S   POinTS to Found State                *
                ¯*        Found  TRUE if State IS Found             *
                ¯*                                                  *
                ¯****************************************************

            var
                Key   : integer ;
                X     : stateptrty  ;



                function StateMatch(S1,S2:stateptrty) : boolean ;
                    ¯***************************************************
                    ¯*                                                 *
                    ¯*  StateMatch                                     *
                    ¯*                                                 *
                    ¯*   THIS procedure ChECKS to SEE if THE GIVEN     *
                    ¯* StateS Match                                    *
                    ¯*                                                 *
                    ¯*    in:  S1,S2 THE StateS to BE MatchED          *
                    ¯*                                                 *
                    ¯***************************************************

                var
                    X,X2    : tranptrty ;
                    A,B  : integer   ;
                    Match  : boolean  ;

                  begin
                    ¯ StateMatch 
                    StateMatch := FALSE ;
                    A := 0  ;
                    X := S1@.FirstTran   ;
                    while X <> NIL do
                      begin
                        A := A+1 ;
                        X := X@.Next ;
                      end ;

                    B := 0 ;
                    X := S2@.FirstTran ;
                    while X <> NIL do
                      begin
                        B := B+1 ;
                        X := X@.Next ;
                      end ;
                    if A =B
                    then
                      begin
                        X := S1@.FirstTran ;
                        Match := TRUE ;
                        while (X <> NIL) and Match do
                          begin
                            Match := FALSE ;
                            X2 := S2@.FirstTran ;
                            while (X2 <> NIL) and not Match do
                              begin
                                if ConMatch(X,X2) then Match := TRUE ;
                                X2 := X2@.Next
                              end ;
                            X := X@.Next
                          end ;
                        StateMatch := Match
                      end
                  end   ¯ StateMatch    ;



              begin
                ¯ FindS 
                if Trace
                then
                  begin
                    writeln(TTYOut,'FindS');Break
                  end;
                Found := FALSE ;
                Key   := CHash(S) ;
                Key := Key mod STATETABSIZE ;
                X     := StateTab [Key ] ;
                while (X <> NIL) and (not Found) do
                  begin
                    if StateMatch(X,S)
                    then
                      begin
                        Found := TRUE ;
                        S     := X
                      end ;
                    X := X@.Nic
                  end
              end    ¯ FindS   ;





            procedure Links(From : stateptrty ;
                On   : tranptrty;
                Dest   : stateptrty  ) ;
                ¯**********************************************************
                ¯*                                                        *
                ¯*  Links                                                 *
                ¯*                                                        *
                ¯*    THIS procedure Links THE From and to StateS         *
                ¯* BOTHWAYS                                               *
                ¯*                                                        *
                ¯*    in :     From  State                                *
                ¯*               Dest  State                              *
                ¯*               On  TranSITIOn                           *
                ¯*                                                        *
                ¯**********************************************************

            var
                X,Y,Z   : tranptrty ;



              begin
                ¯ Links 
                On@.NextState := Dest ;
                new(X)    ;
                with X@ do
                  begin
                    Next := NIL ;
                    MarkE := FALSE;
                    Pos  := On@.Pos ;
                    NextState := From ;
                    Rule   := On@.Rule
                  end ;
                Y := Dest@.Back ;
                if Y= NIL then Dest@.Back := X
                else
                  begin
                    while Y <> NIL do
                      begin
                        Z := Y ;
                        Y := Y@.Next
                      end;
                    Z@.Next := X
                  end

              end   ¯ Links    ;


            procedure EnterS ( From:stateptrty; On:tranptrty;Dest:stateptrty);
                ¯***************************************************
                ¯*                                                 *
                ¯*  EnterS                                         *
                ¯*                                                 *
                ¯*   THIS procedure EnterS A new State and then    *
                ¯* Links THE From and Dest StateS                  *
                ¯*                                                 *
                ¯*  I   : From      State                          *
                ¯*          Dest      State                        *
                ¯*                                                 *
                ¯*          On      TranSITIOn                     *
                ¯*                                                 *
                ¯***************************************************

            var
                Key  :  integer ;
                X,Z  : stateptrty  ;



              begin
                ¯ EnterS 
                if Trace
                then
                  begin
                    writeln(TTYOut,'EnterS'); Break
                  end;
                Key := CHash(Dest)  ;
                Key := Key  mod STATETABSIZE ;
                if CurrentState >= MAXSTATE then
                  begin
                    writeln(TTYOut,'toO MANY StateS');
                    CurrentState := MAXSTATE ;
                  end
                else                 CurrentState := CurrentState+1 ;
                NState [ CurrentState ] := Dest ;
                Dest@.State := CurrentState ;
                if StateTab [Key] = NIL then StateTab[Key] := Dest
                else
                  begin
                    X := StateTab [Key ] ;
                    while X <> NIL do
                      begin
                        Z := X ;
                        X := X@.Nic
                      end ;
                    Z@.Nic := Dest
                  end ;
                Links( From,On,Dest)
              end     ¯EnterS    ;


          begin
            ¯ GenS  
            if Trace then
              begin
                writeln(TTYOut,'GenS');
                Break
              end ;
            if Debug then if FSM then PrintState(S) ;
            X := NextTran (S,NIL) ;
            while X <> NIL do
              begin
                Z := X@.Rule ;
                for I := 0 to X@.Pos
                do  Z := Z@.Next ;
                if Z <> NIL then
                  begin
                    mark(Heap) ;
                    Y := Complete (S,X) ;
                    FindS(Y,B) ;
                    if B then
                      begin
                        release(Heap) ; ¯ NO new State WAS NEEDED 
                        Links (S,X,Y)
                      end
                    else
                      begin
                        EnterS(S,X,Y) ;
                        if Y@.Kind =Inadequate then
                          begin
                            AddL(Y) ;
                            if AllReduce then Y@.Kind:= Reduction ;
                          end ;
                        if Y@.Kind <> Reduction then
                        GenS(Y,Lr0)
                      end ;
                  end ;
                X := NextTran(S,X)
              end
          end    ¯ GenS      ;





      begin
        if Trace then
          begin
            writeln(TTYOut, 'CFSM') ;
            Break
          end ;
        Lr0 := TRUE ;
        S   := CIS ; ¯ CREATE inITIAL State 
        GenS(S,Lr0) ;
        if Debug then if IFSM then
          begin
            Sl1 := Inadeq ;
            while Sl1 <> NIL do
              begin
                S1 := Sl1@.CAR ;
                PrintState(S1);
                Sl1 := Sl1@.CDR ;
              end ;
          end ;
      end   ¯ CFSM  ;




    procedure LaLr ( K: integer ; LrK : boolean ) ;
        ¯************************************************
        ¯*                                              *
        ¯*  LaLr                                        *
        ¯*                                              *
        ¯*   THIS procedure ATTEMPTS to ResOLVE         *
        ¯* ALL Inadequate StateS, USinG A               *
        ¯* MAXIMUM of K Lookahead. IT SETS              *
        ¯* LrK to FALSE if THIS IS not PosSIBLE         *
        ¯* for THE GIVEN K                              *
        ¯*                                              *
        ¯*                                              *
        ¯*    GLOBAL       in:                          *
        ¯*                                              *
        ¯*                                              *
        ¯*                                              *
        ¯*               OUT :                          *
        ¯************************************************
    var
        Y : stateptrty ;
        I : integer;
        X,Z : statelistptr ;




        function Disjoint( X,Y :stateptrty) : boolean ;
            ¯*******************************************************
            ¯*                                                     *
            ¯*  Disjoint                                           *
            ¯*                                                     *
            ¯*     THIS function ChECKS to SEE if THE Lookahead    *
            ¯* String of Y IS SUFFICIENt to ResOLVE State X        *
            ¯* if SO IT RETURNS TRUE                               *
            ¯*                                                     *
            ¯*     in     :   X     Inadequate State               *
            ¯*                Y     Lookahead String State         *
            ¯*                                                     *
            ¯*     ResULT      TRUE if Disjoint else FALSE         *
            ¯*******************************************************

        var
            Check : boolean ;
            Id,Id2 : identptrty ;
            S  : stateptrty ;
            Q,R,T : tranptrty;



          begin
            ¯ Disjoint 
            Disjoint := TRUE ;
            Check := TRUE ;
            T := Y@.FirstTran ;
            while ( T <> NIL) and Check do
              begin
                Id := Token(T@.Rule,T@.Pos);
                Q := X@.FirstTran ;
                while (Q <> NIL) and Check do
                  begin
                    Id2 := Token(Q@.Rule,Q@.Pos);
                    if Id2<> NIL then
                      begin
                        if Id2=Id then Check := FALSE;
                      end

                    else
                      begin
                        S := Q@.NextState ;
                        if (S<> NIL) and(S<>Y)
                        then
                          begin
                            R := S@.FirstTran ;
                            while (R<> NIL) and Check do
                              begin
                                if Token(R@.Rule,R@.Pos)=Id then
                                    Check := FALSE;
                                R := R@.Next ;
                              end ;
                          end ;
                      end ;
                    Q := Q@.Next ;
                  end ;
                T := T@.Next ;
              end ;
            Disjoint := Check ;
          end   ¯ Disjoint    ;


        procedure Follow(A : stateptrty;B :tranptrty;C :stateptrty) ;forward;

        procedure  Resolve( Y : stateptrty ;  var B : boolean) ;

            ¯****************************************************
            ¯*                                                   *
            ¯*  Resolve                                          *
            ¯*                                                   *
            ¯*   THIS procedure ResolveS ANY InadeqUACIES        *
            ¯* IT IS CALLED for EACh Inadequate State            *
            ¯* if UNABLE to Resolve A State IT SETS B to FALSE   *
            ¯*                                                   *
            ¯*    in    Y   GIVEN State                          *
            ¯*                                                   *
            ¯*    OUT   B   set to FALSE if UNABLE to Resolve    *
            ¯*                                                   *
            ¯*****************************************************

        var
            Id : identptrty ;
            X,Z : statelistptr ;
            I   : integer ;
            T,U : tranptrty  ;
            Q,S : stateptrty ;



          begin
            ¯ Resolve 
            if Trace then
              begin
                writeln(TTYOut,'Resolve');Break ;
              end ;
            T := Y@.FirstTran ;
            while T <> NIL do
              begin
                Id := Token( T@.Rule,T@.Pos) ;
                if Id = NIL then
                  begin
                    new(S) ;
                    with S@ do
                      begin
                        FirstTran := NIL ;
                        Back := NIL ;
                        Nic  := NIL ;
                        CurrentState := CurrentState+1 ;
                        if CurrentState > MAXSTATE then
                          begin
                            writeln(TTYOut,' Too many states.') ;
                            CurrentState := MAXSTATE ;
                          end  ;
                        State := CurrentState ;
                        Kind := LAString ;
                      end ;
                    NState [ CurrentState ] := S ;
                    CurrentVisit := 0;
                    Follow (Y,T,S) ;
                    T@.NextState := S ;
                    if CurrentVisit >0 then
                    for I := 1 to CurrentVisit do
                      begin
                        Visit[I]@.MarkE := FALSE ;
                        Visit [I] := NIL ;
                      end ;
                    CurrentVisit := 0;
                    if Debug and IFSM then
                      begin
                        writeln(TTYOut); writeln(TTYOut);
                        writeln(TTYOut,'Inadequate State ') ;
                        writeln(TTYOut);
                        PrintState(Y) ;
                        writeln(TTYOut);
                        writeln(TTYOut,'Lookahead String') ;
                        PrintState(Y) ;
                      end ;
                    if Disjoint (Y,S) then Y@.Kind := Lookahead
                    else
                      begin
                        Y@.Kind := Inadequate ; ¯ Just in case it was set 
                                                ¯ otherwise previously    
                        B := FALSE ;
                        Z := Conflict ;
                        new(X) ;
                        X@.CAR := S ;
                        X@.CDR := NIL ;
                        if Z=NIL then Conflict := X
                        else
                          begin
                            while Z@.CDR <> NIL do
                            Z := Z@.CDR ;
                            Z@.CDR := X ;
                          end ;
                      end ;
                  end ;
                T := T@.Next ;
              end ;
          end ¯ Resolve    ;




        procedure Reverse (A:stateptrty; B :tranptrty;N:integer ;
            S : stateptrty )   ;
            ¯************************************************
            ¯*                                               *
            ¯* Reverse                                       *
            ¯*                                               *
            ¯*    THIS procedure EXECUTES THE Reduction and  *
            ¯* MAKES THE APPrOPrIATE TranSITIOn              *
            ¯*                                               *
            ¯*   in    A   BASE State                        *
            ¯*         B   Reduction                         *
            ¯*         N   Number of BackUPS to GO           *
            ¯*         S   LookSHead String State            *
            ¯*                                               *
            ¯*************************************************

        var
            Id : identptrty ;
            A1 : stateptrty ;
            T : tranptrty ;


            function MakeTran( A:stateptrty; B :tranptrty ) : stateptrty ;
                ¯******************************************************
                ¯*                                                    *
                ¯* MakeTran                                           *
                ¯*                                                    *
                ¯*    THIS function MAKES THE APPrOPrIATE TranSITIOn  *
                ¯* for THE GIVEN Reduction B and RETURNS THE ResULTANt*
                ¯* State                                              *
                ¯*                                                    *
                ¯*   in     A State                                   *
                ¯*          B GIVEN Reduction                         *
                ¯*                                                    *
                ¯*  ResULT  IS THE DestinATIOn State                  *
                ¯*                                                    *
                ¯******************************************************

            label
                1;
            var
                X : tranptrty ;
                new : stateptrty ;
                Id : identptrty ;



              begin
                ¯ MakeTran 
                new := NIL ;
                Id := B@.Rule@.XDef ;
                X := A@.FirstTran ;
                while X <> NIL do
                  begin
                    if Token(X@.Rule,X@.Pos)= Id
                    then
                      begin
                        new := X@.NextState ;
                        if new <> NIL then goto 1 ;
                      end ;
                    X := X@.Next ;
                  end ;
                1:
                MakeTran := new ;
              end ¯ MakeTran    ;


          begin
            ¯ Reverse  
            if Trace then
              begin
                writeln(TTYOut,'Reverse');Break ;
              end ;
            if N=0 then
              begin
                A1 := MakeTran(A,B) ;
                if A1 = NIL then writeln(TTYOut,'**SySTEM Error** in Reverse')
                else
                  begin
                    T := A1@.FirstTran ;
                    while T <> NIL do
                      begin
¯suspect code:           Id := Token(T@.Rule,T@.Pos);           
¯                        if Id@.Kind <> NonTerm then             
                        Follow(A1,T,S) ;
                        T := T@.Next ;
                      end ;
                  end
              end
            else
              begin
                T := A@.Back ;
                while T <> NIL do
                  begin
                    A1 := T@.NextState ;
                    Reverse(A1,B,N-1,S) ;
                    T := T@.Next ;
                  end ;
              end ;
          end ¯ Reverse     ;


        procedure Follow ;
            ¯***************************************************
            ¯*                                                 *
            ¯* Follow                                          *
            ¯*                                                 *
            ¯* THIS IS A forward procedure                     *
            ¯*      THIS procedure inITIALIZES C with THE      *
            ¯* Terminals THAT Follow                           *
            ¯*                                                 *
            ¯*   in   : A   BASE State                         *
            ¯*          B    GIVEN TranSITIOn                  *
            ¯*          C   Lookahead String State             *
            ¯*                                                 *
            ¯***************************************************

        var
            Id  : identptrty ;
            X   : stateptrty ;
            P  : prodptrty ;
            Pop : integer   ;
            T   : tranptrty ;



            procedure AddLook ( S: stateptrty;Q : tranptrty);
                ¯*******************************************************
                ¯*                                                     *
                ¯*  AddLook                                            *
                ¯*                                                     *
                ¯*      THIS procedure ADDS THE GIVEN TranSITIOn       *
                ¯* to THE EXISTinG Lookahead String AS REPresENtED BY  *
                ¯*   S                                                 *
                ¯*                                                     *
                ¯*   in      S   Lookahead String State                *
                ¯*           Q   new TranSITIOn                        *
                ¯*                                                     *
                ¯*******************************************************

            var
                X : tranptrty ;

              begin
                ¯ AddLook 
                new(X)   ;
                with X@ do
                  begin
                    Rule := Q@.Rule ;
                    Pos  := Q@.Pos  ;
                    MarkE := FALSE  ;
                    Next  := NIL  ;
                    NextState := NIL ;
                  end ;
                AddT(S,X)  ;
              end ¯ AddLook     ;



          begin
            ¯ Follow 
            if Trace then
              begin
                writeln(TTYOut,'Follow');
                Break ;
              end ;
            Id := Token(B@.Rule,B@.Pos) ;
            if not B@.MarkE then
              begin
                B@.MarkE := TRUE ;
                CurrentVisit := CurrentVisit+1 ;
                if CurrentVisit > MAXVISIT then
                writeln(TTYOut,'OVERFLOW of Visit StateS')
                else Visit[CurrentVisit] := B ;
                if Id = NIL then
                  begin
                    Pop := 0 ;
                    P := B@.Rule ;
                    P := P@.Next ;
                    while P <> NIL
                    do
                      begin
                        Pop := Pop +1 ;
                        P := P@.Next ;
                      end ;
                    if B@.NextState = NIL then Reverse(A,B,Pop,C)
                    else
                      begin
                        X := B@.NextState ;
                        T := X@.FirstTran ;
                        while T <> NIL do
                          begin
                            AddLook(C,T) ;
                            T := T@.Next ;
                          end ;
                      end ;
                  end
                else
                if Id@.Kind = Term then AddLook(C,B) ;
              end ;
          end ¯ Follow    ;


      begin
        ¯  LaLr  
        if Trace then
          begin
            writeln(TTYOut, 'LaLr') ;
            Break ;
          end ;
        Z := Inadeq ;
        X := Inadeq ;
        LrK := TRUE ;
        while X <> NIL do
          begin
            Y := X@.CAR ;
            Resolve(Y,LrK) ;
            if Y@.Kind = Lookahead
            then if X= Inadeq then Inadeq := X@.CDR
            else Z@.CDR := X@.CDR
            else Z := X ;
            X := X@.CDR ;
          end ;
        if not LrK then
          begin
            writeln(TTYOut);
            writeln(TTYOut,'The grammar is not laLR(',K:1,')');
            if IFSM then
              begin
                I := B14 ;
                Ch := ChR(I) ;
                writeln(CrefPas,Ch) ;
                writeln(CrefPas,'                      Conflict States');
                writeln(CrefPas,'                      ===============');
                writeln(CrefPas);writeln(CrefPas);writeln(CrefPas);
                X := Inadeq ;
                while X <> NIL do
                  begin
                    PrintState(X@.CAR) ;
                    X := X@.CDR ;
                  end ;
                X := Conflict ;
                while X <> NIL do
                  begin
                    PrintState(X@.CAR) ;
                    X := X@.CDR ;
                  end ;
              end ¯ IFSM<   ;
          end ¯ LrK   ;

      end ;
    ¯  LaLr  



    procedure   Optim  ;
        ¯************************************************
        ¯*                                              *
        ¯*        Optim              ;                  *
        ¯*                                              *
        ¯*                                              *
        ¯*   THIS procedure OptimizeS THE State Tables  *
        ¯*  GENERATED ALSO. THE OptimIZATIOn IS         *
        ¯*  doNE USinG FinITE State TEChNIQUES in ordER *
        ¯*  to Reduce THE Number of StateS.             *
        ¯*    THE FollowinG OptimIZATIOnS ARE doNE      *
        ¯*    A. REMOVAL of NOn Terminal TranSITIOnS    *
        ¯*    B. REMOVAL of ChAin DEVIATIOnS            *
        ¯*                                              *
        ¯************************************************
      begin
        ¯  Optim  
        writeln(TTYOut, 'Optim')
      end   ;



    function FindRule(T: tranptrty) : integer ;

        ¯*****************************************************
        ¯*                                                   *
        ¯* FindRule                                          *
        ¯*                                                   *
        ¯*     THIS function RETURNS THE Rule Number of THE  *
        ¯* GIVEN Production                                  *
        ¯*                                                   *
        ¯*     in : T  GIVEN TranSITIOn                      *
        ¯*                                                   *
        ¯*    OUT :                                          *
        ¯*    ResULT   Rule NO. of Production                *
        ¯*****************************************************

    label
        1;
    var
        L :   listptrty ;

      begin
        ¯ FindRule 
        FindRule := UNKNOWN ;
        L := T@.Rule@.XDef@.Defin ;
        if L= NIL  then writeln(TTYOut,'**SySTEM Error 2**') ;
        while L<> NIL do
          begin
            if RuleTab[L@.CAR]=T@.Rule then
              begin
                FindRule := L@.CAR ;
                goto 1
              end ;
            L := L@.CDR ;
          end ;
        1:
      end ¯ FindRule    ;



    procedure   OutT     ;
        ¯************************************************
        ¯*                                              *
        ¯*     OutT                                     *
        ¯*                                              *
        ¯*   THIS procedure GENERATES THE PARSER Tables,*
        ¯* Production Number Tables and THE SEMANtICS   *
        ¯* Tables                                       *
        ¯************************************************



        procedure GenTab ;
            ¯***********************************************
            ¯*                                             *
            ¯* GenTab                                      *
            ¯*                                             *
            ¯*  THIS procedure GENERATES Tables in THE     *
            ¯* REQUIRed forM VIZ MERGinG symbolS and THE   *
            ¯* THE Action list WHEREVER PosSIBLE           *
            ¯*                                             *
            ¯***********************************************
        label
            1;
        var
            I,J  : integer ;
            S : stateptrty ;
            Entry : integer ;
            Done : boolean ;




            procedure EnterSeg(T,A : integer) ;

                ¯************************************************
                ¯*                                              *
                ¯* EnterSeg                                     *
                ¯*                                              *
                ¯*   THIS procedure EnterS A symbol Action PAIR *
                ¯* into THE Table                               *
                ¯************************************************



              begin
                ¯ EnterSeg 
                if Index >= MAXTABSIZE then writeln(TTYOut,'Overflow of Table')
                else Index := Index+1 ;
                Table [Index].Tran := T;
                Table [Index].Action := A ;
              end ¯ EnterSeg    ;



            procedure MakeSeg (S :stateptrty) ;
                ¯*************************************************
                ¯*                                               *
                ¯* MakeSeg                                       *
                ¯*                                               *
                ¯*  THIS procedure COPIES A Segment I.E. A State *
                ¯* and forMATS into A symbol Action PAIR         *
                ¯*                                               *
                ¯*************************************************
            label
                1;
            var
                Act : integer ;
                Id : identptrty ;
                First : boolean ;
                K,LastCount,CurrCount : integer ;
                P : integer ;
                Last,T : tranptrty ;






                function Count (S :stateptrty) : integer ;

                    ¯*********************************************
                    ¯*                                           *
                    ¯* Count                                     *
                    ¯*                                           *
                    ¯*   THIS function RETURNS THE Number of     *
                    ¯* UNIQUE TranSITIOnS of A GIVEN State       *
                    ¯*********************************************

                var
                    Temp : integer ;
                    Id : identptrty ;
                    Q,T : tranptrty ;
                  begin
                    ¯ Count 
                    Temp := 0;
                    T := NextTran(S,NIL);
                    while T <> NIL do
                      begin
                        Id := Token(T@.Rule,T@.Pos);
                        Q := T@.Next ;
                        while Q <> NIL do
                          begin
                            if Token(Q@.Rule,Q@.Pos)=Id then Q@.MarkE := TRUE;
                            Q := Q@.Next ;
                          end ;
                        Temp := Temp +1 ;
                        T := NextTran(S,T) ;
                      end ;
                    Count := Temp ;
                  end ¯ Count  ;



                procedure Expand ( P : tranptrty) ;
                    ¯************************************************
                    ¯*                                              *
                    ¯* Expand                                       *
                    ¯*                                              *
                    ¯*    THIS procedure EXOandS A Lookahead String *
                    ¯* A symbol Action list                         *
                    ¯************************************************

                var
                    S : stateptrty ;
                    PRule : integer ;
                    T,Q : tranptrty ;
                    Id : identptrty ;
                  begin
                    S := P@.NextState ;
                    T := NextTran (S,NIL) ;
                    PRule := P@.Rule@.Production ;
                    while T <> NIL do
                      begin
                        Id := Token (T@.Rule ,T@.Pos) ;
                        Q := T@.Next ;
                        while Q <> NIL do
                          begin
                            if Token(Q@.Rule,Q@.Pos)=Id then Q@.MarkE := TRUE;
                            Q := Q@.Next ;
                          end ;
                        EnterSeg(Id@.Code,-PRule-NOSCANCODE) ;
                        T := NextTran(S,T) ;
                      end ;
                  end ¯ Expand   ;



              begin
                ¯ MakeSeg 
                First := TRUE ;
                Segment[0].Tran := UNKNOWN ;
                Segment[0].Action := UNKNOWN ;
                P := UNKNOWN ;

                SegIndex := -1 ;
                T :=S@.FirstTran ;
                while T <> NIL do
                  begin
                    ¯while
                    if T@.NextState <> NIL then
                      begin
                        ¯COPY
                        Id := Token(T@.Rule,T@.Pos) ;
                        if Id <> NIL then K := Id@.Code else K:=UNKNOWN;
                        if T@.NextState@.Kind=LAString then
                          begin
                            ¯LAString
                            if First then
                              begin
                                ¯First
                                First := FALSE;
                                Last := T ;
                                LastCount := Count(Last@.NextState) ;
                                goto 1 ;
                              end ¯First
                            else
                              begin
                                ¯not First
                                CurrCount := Count(T@.NextState);
                                if CurrCount > LastCount+THRESHOLD then
                                  begin
                                    ¯SWAP
                                    Expand(Last) ;
                                    Last := T ;
                                    LastCount := CurrCount ;
                                  end ¯SWAP
                                else Expand(T) ;
                                goto 1 ;
                              end ¯not First
                          end ¯ LAString
                        else if T@.NextState@.Kind=Reduction then
                        P := -T@.Rule@.Production
                        else
                        P := T@.NextState@.State ;
                        if SegIndex >= MAXSEGMENT then
                            writeln(TTYOut,'Segment Overflow!')
                        else SegIndex := SegIndex+1;
                        Segment[SegIndex].Tran := K ;
                        Segment[SegIndex].Action := P ;
                      end ¯COPY  ;
                    1: T := T@.Next ;
                  end ¯while  ;
                if S@.Kind = Lookahead then
                if First then writeln(TTYOut,'System error in MAKESEG2')
                         else Act := - Last@.Rule@.Production-NOSCANCODE ;

                if S@.Kind= Reads then Act := ERRORCODE;
                if (S@.Kind=Reads) or (S@.Kind=Lookahead)
                then
                  begin
                    if SegIndex>= MAXSEGMENT then
                        writeln(TTYOut,'*Segment Overflow!')
                    else SegIndex := SegIndex+1 ;
                    Segment[SegIndex].Tran := elseCode;
                    Segment[SegIndex].Action := Act ;
                  end ;
              end ¯MakeSeg  ;






            function SegMatch(Ind:integer) : integer ;
                ¯*****************************************************
                ¯*                                                   *
                ¯*  SegMatch                                         *
                ¯*                                                   *
                ¯*     THIS function RETURNS TRUE if THE Segment     *
                ¯* MatchES AN Entry in THE Table .if THERE IS NO     *
                ¯* Match IT RETURNS UNKNOWN                          *
                ¯*****************************************************
            label
                1,2;
            var
                I,K : integer ;
                Mate : integer ;



              begin
                ¯ SegMatch
                SegMatch := UNKNOWN ;
                if Index > (SegIndex-Ind) then
                for Mate := 0 to Index-(SegIndex-Ind) do
                  begin
                    K := Mate ;
                    for I := Ind to SegIndex do
                      begin
                       if Table[K].Tran=XCONTINUE
                           then K := Table[K].Action;
                        if (Segment[I].Tran <> Table[K].Tran)
                        or (Segment[I].Action <> Table[K].Action) then goto 1;
                        K := K+1;
                      end ;
                    SegMatch := Mate ; goto 2;
                    1:
                  end ¯ for  ;
                2:
              end  ¯ SegMatch   ;








          begin
            ¯ GenTab 
            Index := -1 ;
            for I := 0 to CurrentState do
              begin
                S := NState [I ];
                if (S@.Kind <> Reduction) and (S@.Kind <> LAString) then
                  begin
                        NewState[I] := Index+1 ;
                    MakeSeg(S) ;
                    Entry := SegMatch(0);
                    if Entry <> UNKNOWN then NewState[I] := Entry
                    else
                      begin
                        EnterSeg(Segment[0].Tran,Segment[0].Action) ;
                        if SegIndex > 0 then

                        begin
                        for J := 1 to SegIndex-1 do
                          begin
                            Entry := SegMatch(J);
                            if Entry <> UNKNOWN then
                              begin
                                EnterSeg(XCONTINUE,Entry);
                                goto 1 ;
                              end
                            else EnterSeg(Segment[J].Tran,Segment[J].Action);
                          end ;
                        EnterSeg(Segment[SegIndex].Tran,
                                 Segment[SegIndex].Action);
                        end ;
                        1:
                      end ;
                  end ;
              end  ¯ for  ;
            ¯ RENumber new StateS 
            for I := 0 to CurrentState do
            if NState[I]@.Kind <> LAString then
            NState[I] @.State := NewState[I] ;
            for I := 0 to Index do
            if (Table[I].Action >=0) and (Table[I].Action <=CurrentState)
            and (Table[I].Tran <> XCONTINUE) then
            Table[I].Action := NewState[Table[I].Action ];
          end ¯ GenTab    ;



        procedure OutTab ;
        ¯***********************************************
        ¯*                                             *
        ¯* OutTab                                      *
        ¯*                                             *
        ¯*    THIS procedure GENERATES TabPas          *
        ¯* THE Tables                                  *
        ¯***********************************************

var
    I,K,T,A : integer ;
    DoSymbolic : boolean;
    X : identptrty;
    Id : word;



 begin  ¯ OutTab 
        I := B14;
        Ch := ChR(I);
        writeln(TabPas,Ch);
        writeln(TabPas,XCONTINUE,' ',elseCode,' ',ERRORCODE,' ',NOSCANCODE);
        writeln(TabPas);

        writeln(TabPas,ERRORCODE);
        writeln(TabPas,MaxCode);
        writeln(TabPas,MaxPop);
        writeln(TabPas,MaxProdNo);
        writeln(TabPas,Index);
        writeln(TabPas,elseCode);
        writeln(TabPas,-1); ¯PARTITION
        writeln(TabPas);
        writeln(TabPas);

                ¯ GENERATE labelS

        for K := 0 to NAMETABSIZE do
        begin
                X := NameTab[K];
                while X<> NIL do
                begin
                   if X@.Kind in  [Lab]
                        then writeln(TabPas,X@.ExternalName);
                   X := X@.Nic;
                end ;
        end ;
        writeln(TabPas,-1) ; ¯ PART
        writeln(TabPas);writeln(TabPas);writeln(TabPas);


                ¯ GENERATE Table arrayS

        for I := 0 to Index do
        begin
            T := Table[I].Tran ;
            A := Table[I].Action;
            write(TabPas, I, ' ');
            if (T >= 0) and (T < MaxVocSize) then begin
                DoSymbolic := Symbolic and Terminals and
                                (SymbolName[T]@.Kind = Term);
                DoSymbolic := DoSymbolic or (
                                Symbolic and NonTerminals and
                                (SymbolName[T]@.Kind = NonTerm));
                DoSymbolic := DoSymbolic or (SymbolName[T]@.Spid = Res);
            end else
                DoSymbolic := FALSE;
            if DoSymbolic then
                write(TabPas, SymbolName[T]@.ExternalName)
            else
                write(TabPas, T);
            writeln(TabPas, ' ', A);
        end ;
        writeln(TabPas,-1);
        writeln(TabPas);

                ¯ GENERATE Pop and SEMANtICS

        DoSymbolic := Symbolic and NonTerminals;

        for I := 1 to ProdNo do
        begin

            T := PopTab[I] -1;
            A := RuleTab[I]@.XDef@.Code;
            X := RuleTab[I]@.Action;
            if X = NIL then Id := 'NULL           '
                else Id :=X@.ExternalName;
            write(TabPas,I,' ', T, ' ');
            if DoSymbolic then
                write(TabPas, RuleTab[i]@.XDef@.ExternalName)
            else
                write(TabPas, A);
            writeln(TabPas,' ',Id);
        end ;

        writeln(TabPas,-1) ; ¯ PART

        writeln(TabPas);
   end ¯OutTab  ;







      begin
        ¯  OutT  
        writeln(TTYOut,' Generating Tables...') ;
        GenTab ;
        if FSM or tables then    ¯ always want tables 
        PrintTab ;   ¯ even when you don't want the to see the FSM -hde '83
        OutTab;
      end   ;



    procedure   OutFreq          ;
        ¯************************************************
        ¯*                                              *
        ¯*    OutFreq                                   *
        ¯*                                              *
        ¯*     THIS procedure OUTPUTS ALL STATISTICS    *
        ¯*  ConCERNinG THE PrOGRAM, to FILNAM.CRL       *
        ¯*     THE FollowinG WILL BE inCLUDED           *
        ¯*   1. Frequency of Terminals, NOn Terminals.  *
        ¯************************************************
      begin
        ¯  OutFreq  
        writeln(TTYOut,'OutFreq')
      end   ;



  begin
    ¯  main  
    InitSp;           ¯ initialize some data 
    InitOptions ;     ¯initialize options to defaults 
    InitGlob;         ¯initialize global variables 
    mark(HeapBot) ;
    open( TTYOut, 'TTY:', [ OpenOutput ] );
    InitP          ;  ¯  Initialize tables as read. 
    if not FatalError then
        Terminal       ;  ¯  Read terminals 
    if not FatalError then begin
        ReadG          ;  ¯  Read grammar 
        writeln(TTYOut,' There are ', maxprodno:2,' rules.');
    end;
    if Grammar or Terminals and not FatalError then
      begin
        if Grammar then  PrintG ;
        PrintCref ;
      end ;
    if ErrorFlag or FatalError then
        writeln(TTYOut,'Error in the productions - NO tables generated.')
    else
    if Lr0 then
      begin
        ¯ Lr0 
        CFSM(Lr0) ;
        if (not Lr0) and Look
        then
          begin
            LrK := TRUE ;
            LaLr(MaxK,LrK) ;
          end ;
        if LrK or Lr0 then
          begin
            if Optimize then Optim ;
            if Tables or PN then OutT ;
          end ;
        if FSM then OutFSM ;
      end   ¯ Lr0  ;
    if Frequency then  OutFreq ;
    mark(HeapTop) ;
¯   writeln(TTYOut,'Storage used: ',HeapBot-HeapTop : 5) ;         
¯ the above line is commented out because pointers aren't integers
    (in PASCALVS), and also, it is not TRUE since other marks and
    releases are done in the Rest of the code

    if FatalError then
        SetReturnCode(2)
    else if ErrorFlag then
        SetReturnCode(1);

  end.

++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB PATPAS   EXT PAS HEX -
(*$M-*)
program patpas;
¯
    This program is a backend to PAT, and constructs the pascal file
    implementing the grammar specified to PAT.

    We read two files, FILE.tab and FILE.patpas.  The .tab file is one
    of the PAT output files.  The patpas file contains bits and pieces
    of what the user wants in the final pascal file, including the
    semantic actions.

    We also attempt to read FILE.ter, and create CONSTs to define the
    output of the INSYMBOL procedure symbolically.


const
    SYMBOLSIZE = 32;
    BUFFERSIZE = 200;
    DEBUGMAX = 4001;    ¯ number of TERM/NONTERM symbols we can save 
    OURFLAG = '¯ This is a flag that this file was created by PATPAS ';
    MAXNUMBEROFSTATEMENTS = 100; ¯ This is the number of statements
              we allow in InitProcedure's before seperating them up 

type
    symbol = packed array [1..SYMBOLSIZE] of char;

    TheirStates = ( Initializing,
                    GlobalConst,
                                 DefSymbolSize, DefSymbol,
                                 GlobalType, GlobalVar, GlobalInit,
                    InSymbol,
                    LocalConst, LocalType, LocalVar, LocalInit,
                    Action, Main,
                    Finished );

var
    DoDebug,                        ¯ output Debugging code? 
    TerExists,                      ¯ does foo.TER exist? 
    HadError    : boolean;

    TTYout,
    Us,
    Ter,
    Them    : text;

    TheirBuffer : packed array [1..BUFFERSIZE] of char;

    TheirState : TheirStates;

    FileName : packed array [1..16] of char;

    DebugTable : packed array [1..DEBUGMAX] of symbol; ¯ symbolic names 
    DebugLowest,                ¯ lowest entry in table used, or 0 
    DebugHighest : integer;     ¯ highest entry in table used, or 1 

    LowerCaseLetters,
    WhiteSpace : set of char;


¯ The following are the procedures that are system specific.
    They will need to be changed to run on other systems.
 

procedure InitProcedure;
var
    i,
    retcode : integer;
%include CMS
begin
    TheirState := Initializing;

    LowerCaseLetters := [ 'a', 'b', 'c', 'd', 'e', 'f',
                    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
                    'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' ];
    WhiteSpace := [ ' ', chr(12), chr(9) ];

    DoDebug := TRUE;

    for i := 1 to DEBUGMAX do
        DebugTable[i] := ' ';

    ¯ open the terminal for error output 
    cms( 'FILEDEF STDERR TERMINAL', retcode );  ¯ bind STDERR to tty 
    rewrite( TTYout, 'DDNAME=STDERR' );
end;


procedure GetFileName;
var
    i : integer;
begin
    i := 1;
    token( i, parms, filename );
end;


procedure OpenFiles;
var
    BaseName,
    TabName,
    STabName,
    PatpasName,
    SPatpasName,
    TerName,
    STerName,
    PascalName,
    SPascalName  :  string(30);

    Temporary : packed array [1..200] of char;

function DoesExist( const Name : string ) : boolean;

%include CMS

var
    retcode : integer;
begin
    cms( 'SET CMSTYPE HT', retcode );   ¯ turn off error messages 

    cms( 'STATE ' ÝÝ Name, retcode );   ¯ does file exist? 

    if retcode = 0 then
        DoesExist := TRUE
    else
        DoesExist := FALSE;

    cms( 'SET CMSTYPE RT', retcode );   ¯ turn back on error messages 
end;


begin
    BaseName := trim(ltrim(compress(str(FileName))));
    TabName := BaseName ÝÝ '.TAB.*';
    STabName := BaseName ÝÝ ' TAB *';
    PatpasName := BaseName ÝÝ '.PATPAS.*';
    SPatpasName := BaseName ÝÝ ' PATPAS *';
    TerName := BaseName ÝÝ '.TER.*';
    STerName := BaseName ÝÝ ' TER *';
    PascalName := BaseName ÝÝ '.PASCAL.A';
    SPascalName := BaseName ÝÝ ' PASCAL A';

    if DoesExist(STabName) then begin

        reset( Us, 'NAME=' ÝÝ TabName );

        if DoesExist(SPatpasName) then
            reset( Them, 'NAME=' ÝÝ PatpasName )
        else
            TheirState := Finished;

        TerExists := DoesExist(STerName);
        if TerExists then
            reset( Ter, 'NAME=' ÝÝ TerName );

        if DoesExist(SPascalName) then begin
            reset( output, 'NAME=' ÝÝ PascalName );
            readln( output, temporary );
            if temporary <> OURFLAG then begin
                writeln( TTYout, SPascalName, ' already exists, and does' );
                writeln( TTYout, 'not appear to have been created by PATPAS.' );
                writeln( TTYout, 'No action taken.' );
                HadError := TRUE;
            end
        end;

        if not HadError then
            rewrite( output, 'NAME=' ÝÝ PascalName );

    end else begin
        writeln( TTYout, STabName, ' does not exist.  No action taken.' );
        HadError := TRUE;
    end;
end;


procedure SetReturnCode( I : integer );
¯ In CMS, error code is propagatable back to caller, so let
    them know...

begin
    retcode(i);     ¯ CMS Pascal/VS primitive 
end;


¯ IsEqual - does a case independant compare of the
            two symbols

function IsEqual( Field1, Field2 : symbol ) : boolean;
var
    i : integer;

function UpperCase( Ch : char ) : char;
begin
    if ch in LowerCaseLetters then
        UpperCase := chr( ord(ch) + ord('A')-ord('a') )
    else
        UpperCase := Ch;
end;


begin
    IsEqual := TRUE;
    if Field1 <> Field2 then begin
        for i := 1 to SYMBOLSIZE do begin
            if Field1[i] <> Field2[i] then
                if UpperCase(Field1[i]) <> UpperCase(Field2[i]) then
                    IsEqual := FALSE;
        end;
    end;
end;

function GetOurNumber : integer;
var
    Found : boolean;
    Result : integer;
begin
    Found := FALSE;

    while not ( Found or eof(Us) ) do
        if eoln(Us) then
            readln(Us)
        else if Us@ in WhiteSpace then
            get(Us)
        else begin
            read( Us, Result );
            Found := True
        end;

    if found then
        GetOurNumber := Result
    else
        GetOurNumber := -1;
end;


function GetSymbol( var AFile : text ) : symbol;
var
    Quoting,                    ¯ true if unbalanced single quote 
    Found : boolean;
    Temp : integer;
    Result : symbol;
begin
    Found := FALSE;

    while not ( Found or eof(AFile) ) do
        if eoln(AFile) then
            readln(AFile)
        else if AFile@ = ' ' then
            get(AFile)
        else begin
            Found := TRUE;
            Temp := 1;
            Quoting := FALSE;
            while ( Temp <= SYMBOLSIZE ) and
                  ((AFile@ <> ' ') or (Quoting)) and
                   not eof(AFile) and
                   not eoln(AFile) do begin
                Result[Temp] := AFile@;
                if AFile@ = '''' then
                    Quoting := not Quoting;
                get(AFile);
                Temp := Temp+1;
            end;
            for Temp := Temp to SYMBOLSIZE do
                Result[Temp] := ' ';
        end;

    if found then
        GetSymbol := Result
    else
        GetSymbol := '-1';
end;


procedure WriteSymbol( OurSymbol : symbol );
var
    k, j : integer;
begin
    k := 0;
    for j := SYMBOLSIZE downto 1 do
        if OurSymbol[j] <> ' ' then
            k := max( j, k );

    if (k <> 0) then
        write(OurSymbol:k);
end;


procedure TheirError;
begin
    writeln( TTYout, 'The following line was not understood:' );
    writeln( TTYout, TheirBuffer );

    HadError := TRUE;
end;



procedure GetTheirLine;
var
    CtlRecord : boolean;
    Index : integer;

procedure SetTheirState;
var
    Result1, Result2 : symbol;

function GetTheirSymbol : symbol;
var
    ResultIndex : integer;
    Result : symbol;
begin ¯ GetTheirSymbol 

    Result := '';

    while ( Index <= BufferSize ) and ( TheirBuffer[Index] = ' ' ) do
        Index := Index + 1;

    ResultIndex := 1;

    while ( ResultIndex <= SymbolSize ) and
          ( TheirBuffer[Index] <> ' ' ) do begin
        Result[Resultindex] := TheirBuffer[Index];
        ResultIndex := ResultIndex+1;
        Index := Index+1;
    end;

    GetTheirSymbol := Result;
end; ¯ GetTheirSymbol 



begin ¯ SetTheirState 
    Index := 3;

    Result1 := GetTheirSymbol;

    if IsEqual( Result1,'GLOBAL' ) or IsEqual( Result1,'LOCAL' ) then
        Result2 := GetTheirSymbol;

    if IsEqual( Result1, 'GLOBAL') then begin
        if IsEqual( Result2, 'CONST') then TheirState := GlobalConst
        else if IsEqual( Result2, 'TYPE') then TheirState := GlobalType
        else if IsEqual( Result2, 'VAR') then TheirState := GlobalVar
        else if IsEqual( Result2, 'INIT') then TheirState := GlobalInit
        else TheirError
    end else if IsEqual( Result1, 'SYMBOLSIZE') then TheirState := DefSymbolSize
    else if IsEqual( Result1, 'SYMBOL') then TheirState := DefSymbol
    else if IsEqual( Result1, 'INSYMBOL') then TheirState := InSymbol
    else if IsEqual( Result1, 'LOCAL') then begin
        if IsEqual( Result2, 'CONST') then TheirState := LocalConst
        else if IsEqual( Result2, 'TYPE') then TheirState := LocalType
        else if IsEqual( Result2, 'VAR') then TheirState := LocalVar
        else if IsEqual( Result2, 'INIT') then TheirState := LocalInit
        else TheirError
    end else if IsEqual( Result1, 'ACTIONS') then TheirState := Action
    else if IsEqual( Result1, 'MAIN') then TheirState := Main
    else TheirError;
end; ¯ SetTheirState 


begin ¯ GetTheirLine 

    if eof( Them ) then
        TheirState := Finished
    else
        repeat begin
            readln( Them, TheirBuffer );
            CtlRecord := (TheirBuffer[1] = '%') and (TheirBuffer[2] = '%');
            if CtlRecord then
                SetTheirState;
        end until (not CtlRecord) or eof(Them);

    if CtlRecord then
        TheirState := Finished;
end; ¯ GetTheirLine 


procedure InitTheirFIle;
begin
    while TheirState = Initializing do
        GetTheirLine
end;

procedure DoTheir( DesiredState : TheirStates );
begin
    while TheirState = DesiredState do begin
        writeln( TheirBuffer );
        GetTheirLine
    end;
end;


procedure DoOurFlag;
begin
    writeln( OURFLAG )      ¯ Try to prevent overwriting a pascal file 
end;


procedure DoOurGlobalConsts;
var
    Equal,
    Name : symbol;
    NameValue,
    Temp : integer;
begin
    write( 'program ' );    ¯ write program heading 

    for Temp := 1 to 16 do
        if Filename[Temp] <> ' ' then
            write( FileName[Temp] );

    writeln( ';' );
    writeln( '¯     Global constants used by the parse  ');
    writeln;
    writeln( 'const' );
    writeln;
    writeln( '    ContCode = ', GetOurNumber,
             '; ¯ Code for CONTINUE in SymList ' );
    writeln( '    ElseCode = ', GetOurNumber,
             '; ¯ Code for ELSE in SymList ' );
    writeln( '    ErrorCode = ', GetOurNumber,
             '; ¯ Code for ERROR in Action list ' );
    writeln( '    ScanCode = ', GetOurNumber,
             '; ¯ Code for SCAN in SymList ' );
    writeln;
    writeln( '    MaxAction = ', GetOurNumber,
             '; ¯ Max code used in Action ' );
    writeln( '    MaxNonTerm = ', GetOurNumber,
             '; ¯ Number of symbols ' );
    writeln( '    MaxPop = ', GetOurNumber,
             '; ¯ Maximum number of pops ' );
    writeln( '    MaxProd = ', GetOurNumber,
             '; ¯ Number of productions ' );
    writeln( '    MaxStack = ', '100',
             '; ¯ Depth of parse stack ' );
    writeln( '    MaxState = ', GetOurNumber,
             '; ¯ Highest index of parser tables ' );
    writeln( '    MaxVoc = ', GetOurNumber,
             '; ¯ Size of vocabulary ' );
    writeln;

    DebugHighest := 0;
    DebugLowest := DEBUGMAX+1;
    if TerExists then begin
        while not eof(Ter) do begin
            Name := GetSymbol(Ter);
            Equal := GetSymbol(Ter);
            readln( Ter, NameValue );
            if (NameValue <= DEBUGMAX) and (NameValue > 0) then begin
                DebugTable[NameValue] := Name;
                DebugHighest := max( NameValue, DebugHighest );
                DebugLowest := min( NameValue, DebugLowest );
            end;

            if NameValue <> -1 then begin
                write('    ');
                WriteSymbol(Name);
                writeln('  =  ', NameValue:1, ';');
            end;
        end;
    end;

    DebugLowest := min(DebugHighest, DebugLowest);
    if DoDebug then begin
        writeln;
        writeln;
        writeln('    DEBUGMAX = ', DebugHighest:1, ';');
        writeln('    DEBUGMIN = ', DebugLowest:1 , ';');
        writeln('    DEBUGSIZE = 32;' );
        writeln('    HIGHESTPRINTABLE = 256;' );
    end;


    if GetOurNumber <> -1 then begin
        writeln( TTYout, 'Badly formed .TAB file.' );
        HadError := TRUE;
    end;
end;



procedure DoOurSymbolSize;
begin
    writeln;
    writeln( '    SYMBOLSIZE = 32;           ¯ size of User Symbol ' );
end;


procedure DoOurGlobalTypes;
var
    Token : Symbol;
begin
    writeln;
    writeln;
    writeln( 'type' );
    writeln;
    writeln( '¯ Labels representing semantic actions ' );
    writeln( '    SemSet = (' );
    writeln( '               ', 'NULL' );
    Token := GetSymbol(Us);
    while Token <> '-1' do begin
        writeln( '                ,  ', Token );
        Token := GetSymbol(Us);
    end;
    writeln( '             );' );

end;



procedure DoOurSymbol;
begin
    writeln;
    writeln( '    symbol = packed array[1..SYMBOLSIZE] of char;' );
end;


procedure DoOurGlobalVars;
begin
writeln;
writeln;
writeln( 'var' );
writeln;
writeln( '    IntValue,             ¯ Value destined for IntStack ' );
writeln( '    Currentstate,         ¯ The state of the Parse machine ' );
writeln( '    SP,                   ¯ Stack Index ' );
writeln( '    Token : integer;      ¯ Code to scanner from parser '     );
¯ no IF around this variable - could be set by user program 
writeln( '    Debug,          ¯ Can be set TRUE to do debugging ' );
writeln( '    Match,          ¯ True if a matching transition found ' );
writeln( '    Parse,          ¯ True if parse needs to be continued ' );
writeln( '    Scan : boolean; ¯ True if next symbol needs be scanned ');
writeln( '    SymValue : symbol;    ¯ Value destined for SymStack ' );
writeln;
writeln( '¯ Arrays used by the Parser ' );
writeln;
writeln( '    Action : array [0 .. MaxState] of integer;' );
writeln( '    SymList : array [0 .. MaxState] of integer;' );
writeln( '    LHS : array [0 .. MaxProd] of integer;' );
writeln( '    Pop : array [0 .. MaxProd] of integer;' );
writeln( '    Semantics : array [0 .. Maxprod] of SemSet;' );
writeln( '    PStack : array [0 .. MaxStack] of integer',
         ';  ¯ Parse Stack ' );
if DoDebug then begin
writeln( '    PATBlanks : packed array [1..50] of char;' );
writeln( '    DebugTable : packed array [DEBUGMIN..DEBUGMAX]' );
writeln( '                 of packed array [1..DEBUGSIZE] of char;' );
writeln( '    Printables : set of char;' );
end; ¯DoDebug
writeln( '    SymStack : array [0 .. MaxStack] of symbol',
         ';  ¯ User symbol stack ' );
writeln( '    IntStack : array [0 .. MaxStack] of integer',
         ';  ¯ User integer stack ' );
end;


procedure DoOurGlobalInits;
var
    NumberOfStatements,
    NumberOfInitProcedures,
    Index : integer;
    OurSymbol : symbol;

procedure Statement( var NumberOfStatements, NumberOfInitProcedures
                            : integer );
begin
    NumberOfStatements := NumberOfStatements+1;
    if NumberOfStatements > MAXNUMBEROFSTATEMENTS then begin
        NumberOfStatements := 0;
        if NumberOfInitProcedures <> 0 then
            writeln('end;');
        NumberOfInitProcedures := NumberOfInitProcedures+1;
        writeln;
        writeln;
        writeln;
        writeln('procedure InitProcedure', NumberOfInitProcedures:1, ';' );
        writeln('begin');
    end;
end;



begin
    NumberOfInitProcedures := 0;
    NumberOfStatements := MAXNUMBEROFSTATEMENTS+1;
    Statement(NumberOfStatements, NumberOfInitProcedures);
    Index := GetOurNumber;
    while Index <> -1 do begin
        write( '    SymList[', Index:3, '] := ' );
        OurSymbol := GetSymbol(Us);
        if OurSymbol[1] = '''' then begin
            write('ord(');
            WriteSymbol(OurSymbol);
            write(')');
        end else
            WriteSymbol(OurSymbol);
        writeln( ';    Action[', Index:3, '] := ', GetOurNumber:6, ';' );
        Statement(NumberOfStatements, NumberOfInitProcedures);
        Index := GetOurNumber;
    end;
    writeln;
    Statement(NumberOfStatements, NumberOfInitProcedures);

    Index := GetOurNumber;
    while Index <> -1 do begin

        write  ( '    Pop[', Index:3, '] := ', GetOurNumber:2,
                 ';   LHS[', Index:3, '] := ' );
        WriteSymbol(GetSymbol(Us));
        write  ( ';   Semantics[', Index:3, '] := ' );
        WriteSymbol(GetSymbol(Us));
        writeln( ';' );

        Statement(NumberOfStatements, NumberOfInitProcedures);
        Index := GetOurNumber;
    end;

    if DoDebug then begin
        ¯ initialize the Debug Symbol table 
        writeln( '    PATBlanks := '' '';' );
        for Index := DebugLowest to DebugHighest do begin
            if DebugTable[Index] <> ' ' then begin
                write( '    DebugTable[', Index:1, '] :=  ''' );
                WriteSymbol(DebugTable[Index]);
                writeln( ''';' );
                Statement(NumberOfStatements, NumberOfInitProcedures);
            end;
        end;
        writeln(
'   Printables := [ '' '', ''!'', ''"'', ''#'', ''$'', ''%'', ''&'', '''''''','
);      writeln(
'                   ''('', '')'', ''*'', ''+'', '','', ''-'', ''.'', ''/'','
);      writeln(
'                   ''0'', ''1'', ''2'', ''3'', ''4'', ''5'', ''6'', ''7'','
);      writeln(
'                   ''8'', ''9'', '':'', '';'', ''<'', ''='', ''>'', ''?'','
);      writeln(
'                   ''@'', ''A'', ''B'', ''C'', ''D'', ''E'', ''F'', ''G'','
);      writeln(
'                   ''H'', ''I'', ''J'', ''K'', ''L'', ''M'', ''N'', ''O'','
);      writeln(
'                   ''P'', ''Q'', ''R'', ''S'', ''T'', ''U'', ''V'', ''W'','
);      writeln(
'                   ''X'', ''Y'', ''Z'', ''['', '''', '']'', ''^'', ''_'','
);      writeln(
'                   ''`'', ''a'', ''b'', ''c'', ''d'', ''e'', ''f'', ''g'','
);      writeln(
'                   ''h'', ''i'', ''j'', ''k'', ''l'', ''m'', ''n'', ''o'','
);      writeln(
'                   ''p'', ''q'', ''r'', ''s'', ''t'', ''u'', ''v'', ''w'','
);      writeln(
'                   ''x'', ''y'', ''z'', ''¯'', ''Ý'', '''', ''~''     ];'
);

    end; ¯DoDebug


    writeln( 'end;' );

    writeln;
    writeln;
    writeln;
    writeln('procedure InitProcedure;');
    writeln('begin');

    for Index := 1 to NumberOfInitProcedures do
        writeln('    InitProcedure', Index:1, ';' );

    writeln('    Debug := FALSE;' );
    writeln('end;');
end;



procedure DoOurRoutines;
begin
    writeln;
    writeln;
    writeln(   'function GetIndex( Index : integer ) : integer;' );
    writeln(   'begin' );
    writeln(   '    if Index+sp-1 < MAXSTACK then' );
    writeln(   '        GetIndex := Index+sp-1' );
    writeln(   '    else' );
    writeln(   '        GetIndex := MAXSTACK-1' );
    writeln(   'end;' );
    writeln;
    writeln;
    writeln(   'function GetInt( Index : integer ) : integer;' );
    writeln(   'begin' );
    writeln(   '    if Index+sp-1 < MAXSTACK then' );
    writeln(   '        GetInt := IntStack[Index+sp-1]' );
    writeln(   '    else' );
    writeln(   '        GetInt := IntStack[MAXSTACK-1]' );
    writeln(   'end;' );
    writeln;
    writeln;
    writeln(   'function GetSym( Index : integer ) : symbol;' );
    writeln(   'begin' );
    writeln(   '    if Index+sp-1 < MAXSTACK then' );
    writeln(   '        GetSym := SymStack[Index+sp-1]' );
    writeln(   '    else' );
    writeln(   '        GetSym := SymStack[MAXSTACK-1]' );
    writeln(   'end;' );
end;


procedure DoOurLocalConsts;
begin
writeln( 'procedure LRParse ;' );
writeln( '    ¯****************************************************' );
writeln( '    ¯*                                                  *' );
writeln( '    ¯*   laLR Parse                                     *' );
writeln( '    ¯*                                                  *' );
writeln( '    ¯*      This is the parser driver. It uses the      *' );
writeln( '    ¯* the tables generated by PAT. The driver itself   *' );
writeln( '    ¯* is language independent. The only portion        *' );
writeln( '    ¯* that needs to be entered is the semantics as     *' );
writeln( '    ¯* indicated.for more details on the parsing method *' );
writeln( '    ¯* see the reference manual for PAT.                *' );
writeln( '    ¯*                                                  *' );
writeln( '    ¯*                                                  *' );
writeln( '    ¯*   Global                                         *' );
writeln( '    ¯*     in/out :  SP  stack pointer for parser       *' );
writeln( '    ¯*               CurrentState                       *' );
writeln( '    ¯*               Scan indicates if next symbol      *' );
writeln( '    ¯*                    needs to be scanned           *' );
writeln( '    ¯*               Parse  true while parsing          *' );
writeln( '    ¯*               Token  for making transition       *' );
writeln( '    ¯*               Action     parser table            *' );
writeln( '    ¯*               SymList    parser table            *' );
writeln( '    ¯*               Pop        parser table            *' );
writeln( '    ¯*               LHS        parser table            *' );
writeln( '    ¯*               Semantics  parser table            *' );
writeln( '    ¯*                                                  *' );
writeln( '    ¯*  Functions used                                  *' );
writeln( '    ¯*                                                  *' );
writeln( '    ¯*     InSymbol  scans the next symbol and must     *' );
writeln( '    ¯*               token to the required code         *' );
writeln( '    ¯*                                                  *' );
writeln( '    ¯*     Error     This routine does error recovery   *' );
writeln( '    ¯*         ##### user needs to write this as reqd   *' );
writeln( '    ¯*                                                  *' );
writeln( '    ¯*     #### other user defined semantic routines    *' );
writeln( '    ¯****************************************************' );
writeln;
writeln;
end;


procedure DoOurLocalTypes;
begin
end;


procedure DoOurLocalVars;
begin
writeln( 'var' );
writeln;
writeln( '    j : integer ;       ¯ Local control VAR              ' );
writeln( '    Act : integer ;     ¯ Action from Action array       ' );
writeln( '    Tran : integer ;    ¯ Transition code from SymList ' );
writeln( '    Next : integer ;    ¯ saves the Next token ' );
writeln;
writeln;

end;


procedure DoOurLocalInits;
begin
if DoDebug then begin
writeln(
'procedure TokenWrite( Token : integer );' );
writeln(
'¯ Write out the Token as nicely as possible... ' );
writeln(
'var' );
writeln(
'   i,' );
writeln(
'   j : integer; ' );
writeln(
'begin' );
writeln(
'   if (Token >= DEBUGMIN) and (Token <= DEBUGMAX) then begin' );
writeln(
'       if DebugTable[Token] = '' '' then begin' );
writeln(
'           if Token <= HighestPrintables then begin' );
writeln(
'               if chr(Token) in Printables then' );
writeln(
'                   write('''''''', chr(Token), '''''''')' );
writeln(
'               else' );
writeln(
'                   write(Token:1)' );
writeln(
'           end else' );
writeln(
'               write(Token:1)' );
writeln(
'       end else begin' );
writeln(
'           j := 0;' );
writeln(
'           for i := DEBUGSIZE downto 1 do' );
writeln(
'               if DebugTable[Token] <> '' '' then' );
writeln(
'                   j := max( i, j );' );
writeln(
'           write(DebugTable[Token]:j);' );
writeln(
'       end;' );
writeln(
'   end else begin' );
writeln(
'       if Token = ContCode then' );
writeln(
'           write(''ContCode'')' );
writeln(
'       else if Token = ElseCode then' );
writeln(
'           write(''ElseCode'')' );
writeln(
'       else if Token = ErrorCode then' );
writeln(
'           write(''ErrorCode'')' );
writeln(
'       else if Token = ScanCode then' );
writeln(
'           write(''ScanCode'')' );
writeln(
'       else begin' );
writeln(
'           if (Token <= HighestPrintables) and (Token >= 0) then begin' );
writeln(
'               if chr(Token) in Printables then begin' );
writeln(
'                   write('''''''', chr(Token), '''''''')' );
writeln(
'               end else' );
writeln(
'                   write(Token:1)' );
writeln(
'           end else' );
writeln(
'               write(Token:1);' );
writeln(
'       end;' );
writeln(
'   end;' );
writeln(
'end;' );
writeln;
writeln;
writeln;
writeln(
'¯ DebugOut - do what is needed for debug ' );
writeln(
'procedure DebugOut;' );
writeln(
'begin' );
writeln(
'   write  (PATBlanks:min(sp, 50));' );
writeln(
'   TokenWrite(Token);' );
writeln(
'   writeln;' );
writeln(
'end;' );
end; ¯DoDebug
writeln( 'begin' );
writeln( '     ¯ LR Parse        ' );
writeln;
writeln;
writeln( '    sp := 0;' );
writeln( '    InSymbol ;' );
if DoDebug then begin
writeln( '    if Debug then' );
writeln( '        DebugOut;' );
end; ¯DoDebug
writeln( '    CurrentState := 0;' );
writeln( '    Scan := TRUE ;' );
writeln( '    Parse := TRUE ;' );
writeln( '    Match := FALSE ;' );
writeln;
writeln( '    ¯************************************************' );
writeln( '    ¯*  User Defined Initialization for Semantics   *' );
writeln( '    ¯************************************************' );
writeln;
end;



procedure DoOurBeforeActions;
begin
writeln( '    repeat' );
writeln( '       ¯ Parse loop' );
writeln( '        j := CurrentState;' );
writeln( '        repeat' );
writeln( '                          ¯ Search for Matching Token ' );
writeln( '            Match := FALSE;' );
writeln( '            Tran := symlist [j] ;' );
writeln( '            if (Tran=Token) OR (Tran=ElseCode) then begin' );
writeln( '                                            ¯ Match ' );
writeln( '                Match := TRUE;' );
writeln( '                Act := Action[j] ;' );
writeln( '                if Act <> ErrorCode then begin' );
writeln( '                                            ¯ Read or Reduce ' );
writeln( '  ');¯              if Act > -ScanCode then begin' );     
writeln( '                                            ¯ Process ' );
writeln( '                    PStack[sp] := CurrentState;' );
writeln;
writeln( '                    IntStack[sp] := IntValue;' );
writeln( '                    SymStack[sp] := SymValue;' );
writeln;
writeln;
writeln( '  ' );         ¯    end¯ Process ¯;' );
writeln( '                    if Act >=0 then begin' );
writeln( '                                            ¯ Read ' );
writeln( '                        CurrentState :=Act ;' );
writeln;
writeln( '                        if sp >= MaxStack then begin' );
writeln( '                                           ¯ Overflow ' );
writeln( '                            writeln(Output,',
         '''Parse Stack Overflow'');' );
writeln( '                            Parse := FALSE ;' );
writeln( '                        end ¯ Overflow else' );
writeln( '                            sp := sp+1;' );
writeln( '                        if Scan then begin' );
writeln( '                            InSymbol;' );
if DoDebug then begin
writeln( '                            if Debug then' );
writeln( '                                DebugOut; ' );
end; ¯DoDebug
writeln( '                        end else begin' );
writeln( '                                   ¯ NO Scan' );
writeln( '                            Scan := TRUE;' );
writeln( '                            Token := Next ;' );
writeln( '                        end ¯ NO Scan  ;' );
writeln( '                    end ¯ READ  else begin' );
writeln( '                                   ¯ Reduce ' );
writeln( '                        if Act <= -ScanCode then begin' );
writeln( '                                   ¯ Set NO Scan ' );
writeln( '                            Act := Act + ScanCode ;' );
writeln( '                            Scan := FALSE ;' );
writeln( '                            sp := sp-1 ',
         '; ¯One extra Pop for' );
writeln( '                                       ',
         '  NO Scan Reductions' );
writeln( '                            Next := Token ; ¯ Save it ' );
writeln( '                        end ;' );
writeln( '                                          ¯ Set NO Scan ' );
writeln( '                        Act := - Act ; ¯ Make it positive' );
writeln( '                        sp := sp - Pop[Act] ; ¯ Pop stack' );
writeln( '                        CurrentState := PStack[sp];' );
writeln( '                        Token := LHS[Act] ;' );
if DoDebug then begin
writeln( '                        if Debug then' );
writeln( '                            DebugOut;' );
end; ¯DoDebug
writeln;
writeln( '       ¯ Semantic Action for each reduction ' );
writeln( '       ¯------------------------------------' );
writeln;
writeln;
writeln;
writeln( '                        case Semantics[Act] of' );
writeln;
end;




procedure DoOurAfterActions;
begin
writeln;
writeln( '                        end ¯ case ;' );
writeln;
writeln( '                    end ¯ Reduce  ;' );
writeln( '                end ¯ Read or Reduce else begin' );
writeln( '                                             ¯ Error ' );
writeln( '                    writeln(Output,''Error'');' );
writeln( '                    Parse := FALSE;' );
writeln( '                end  ¯ Error  ;' );
writeln( '            end ¯ Match  else' );
writeln( '                if Tran = ContCode then' );
writeln( '                    j := Action[j]' );
writeln( '                else' );
writeln( '                    j := j+1;' );
writeln;
writeln( '        until   Match ;' );
writeln;
writeln( '    until not Parse ;' );
writeln;
writeln( 'end   ¯ LR Parse  ;' );
writeln;
writeln;
writeln;
writeln( '   ¯ M A I N ' );
end;


procedure DoSymbolSize;
begin
    if TheirState = DefSymbolSize then
        DoTheir(DefSymbolSize)
    else
        DoOurSymbolSize;
end;


procedure DoSymbol;
begin
    if TheirState = DefSymbol then
        DoTheir(DefSymbol)
    else
        DoOurSymbol;
end;



begin

    InitProcedure;

    GetFileName;
    OpenFiles;

    if not HadError then begin

        InitTheirFile;
        DoOurFlag;

        DoOurGlobalConsts;
        DoTheir(GlobalConst);

        DoSymbolSize;

        DoOurGlobalTypes;

        DoSymbol;

        DoTheir(GlobalType);
        DoOurGlobalVars;
        DoTheir(GlobalVar);
        DoOurGlobalInits;
        DoTheir(GlobalInit);

        DoOurRoutines;

        DoTheir(InSymbol);

        DoOurLocalConsts;
        DoTheir(LocalConst);
        DoOurLocalTypes;
        DoTheir(LocalType);
        DoOurLocalVars;
        DoTheir(LocalVar);
        DoOurLocalInits;
        DoTheir(LocalInit);

        DoOurBeforeActions;

        DoTheir(Action);

        DoOurAfterActions;

        DoTheir(Main);
    end;

    if HadError then
        SetReturnCode(1);

end.
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB PCROSS   EXT PAS HEX -
PROGRAM pcross(input, output) ;
(*$N+       ***********
PCROSS is a cross-referencing program for PASCAL source files,
useful also to reformat programs (indentation, upper-lower case)
and to find omitted or excessive BEGINS and ENDS.

comments, gripes and bugs to A.ARMANDO

subtopics:
        INPUT AND OUTPUT
        HOW TO USE IT
        SWITCHES
        READING THE OUTPUT
<INPUT AND OUTPUT>
INPUT:
-----
through the file OLDSOURCE, a PASCAL source program file.

OUTPUT:
------
through NEWSOURCE:
        a copy of your input file, unnumbered, prettyprinted
        (proper indentation according to the statement nesting,
         newline on standard places in the program, management of upper
         and lower case according to the list of reserved words, etc.)

and trough  CROSSLIST:
        (a) a prettyprinted version of the program, showing in the left
            margin the relations between BEGIN..END pairs,THEN..ELSE
            pairs, etc.
        (b) a cross reference of all the identifiers
        (c) a report of procedure and function declaration nesting.

By default, PCROSS will change all reserved words and strings to upper
case, comments and everything else to lower case. There are switches
available to change this condition.
<HOW TO USE IT>
You can:
        (a) use the /CREF switch when @EXECUTEing your program
             or calling @PASCAL, or
        (b) call it directly by typing @PCROSS.

In the first case, PCROSS will be called immediately after compilation;
    You will have to type the file names, though. We are working to fix
    that detail soon. Two sample calls are:

        @pcross                         AND     @exec myprog/cref
        OLDSOURCE= myprog.pas/nocross             (*COMPILER STUFF HERE*)
        NEWSOURCE= myprog.pas                   OLDSOURCE= myprog.pas
        CROSSLIST=                              NEWSOURCE=
                                                CROSSLIST=

The left one calls it directly. The effect is the prettyprinting of the
program file itself. The right one is a call through the compiler, which
will use the default options.

The program parameters all have dafault values, but they can be modified
if desired, by the use of switches. See the subtopic SWITCHES.
See the subtopic SWITCHES.
<SWITCHES>
                                        Brackets indicate optional.
                                        <n> stands for an integer number.
                                        <L> stands for a letter.

   Switch          Meaning                                      Default.

        FILES.
                 <n> is the sum of:
                       1   source program listing
                       2   listing of identifiers
                       4   listing of proc-func
                           declaration nesting.
                       8   listing of proc-func call nesting.

        PAGE AND LINE FORMAT
                margin every fifth line                        on

        STATEMENT FORMAT
                  begin..end block is indented n spaces further.
                if it is there, the block will not be indented,
                  but the begin and end statements will be
                  exdented n spaces.                           0
                 after begin, end, then, else, repeat, etc.)   off
                 comment from old standards to
                 '('-'*' and '*'-')'                           on

        UPPER AND LOWER CASE
                       note: the possible values for <l> are:
                               u means upper case
                               l means lower case.

<READING THE OUTPUT>

The cross-reference file CROSSLIST contains 4 parts:

1. THE PROGRAM LISTING:
        the letters and numbers in the left margin indicate the presence
        of reserved words which have to match. (BEGIN-END, etc.) The two
        words that match accorde with the scope rules will have the
        same number. The first one (e. g., BEGIN) will appear at left, and
        the second one (e.g., END) at right, inside the margin. The meaning
        of the letters is:
                B  Begin        E end
                I  If           T  Then         S Else
                L  Loop         X  Exit         E End
                C  Case         E  End
                R  Repeat       U  Until

2. THE CROSS REFERENCE LISTING OF IDENTIFIERS:
        It is ordered alphabetically. For each identifier it contains:
            a. A 'P' or 'F' if it is a procedure or function, respectively.
            b. The name of the identifier, up to 10 symbols.
            c. The line numbers in which it occur. Those lines in which
                  it is declared are marked with a D; those in which it
                  occurs more than once are marked with an M (Multiple).

3. THE NESTING OF PROCEDURE-FUNCTION DECLARATION:
        It describes the static links. The scope is shown by indentation.
        Each line describes a procedure or function and contains:
            a. The name.
            b. an (M), (P) or (F) if it is the main program, a procedure
                  or a function, respectively.
            c. If there are more than one procedure-function with the same
                  name (in different scopes, which is perfectly valid, but
                  a horrible thing to do), a D  (for DOUBLE) appears next,
                  and the rest of the information in this and the next part
                  of the listing contains data on both (or all of them, if
                  there are more than one.).
            d. If it is an external procedure, an E will appear next.
            e. The line number where the header appeared.
            f. The line number of the BEGIN statement.
            g. The line number of the END statement.

4. THE NESTING OF PROCEDURE-FUNCTION CALLS:
        It describes the dynamic links. Calling depth is indicated by
        indenting. The format of each line is the same as in the previous
        report, except for the following:
            a. Lines are numbered.
            b. A procedure can be called from more than one place. To avoid
                repeating the list of proc-funcs called by it,an asterisk
                is printed after the name to indicate that it has already
                been 'described'. Instead of the line numbers for its
                appearence in the program, that for its appearence in this
                part of the listing is given, so that you can refer to it.
*************)



(******************************************************************************)



(*$T-,R100   *)
(*PROGRAM WHICH CREATES A CROSS REFERENCE LISTING WITH SIMULTANEOUS
 FORMATTING OF A PASCAL PROGRAM.       WRITTEN BY MANUEL MALL.*)




(*          INDEX           *)



(**) (*DECLARATIONS*)
(**)     (*INITPROCEDURES*)
(**)     (*CHECKOPTIONS[*) (*SETSWITCH*)
(**)     (*PAGE AND LINE CONTROL*) (*HEADER*) (*NEWPAGE*) (*NEWLINE*)
(**)     (*BLOCK[*) (*OUTPUT PROCEDURES:*) (*ERROR*) (*WRITELINE[*) (*USETABS*)
(*]*) (*SETLASTSPACES*)
(**)        (*INPUT PROCEDURES:*) (*INSYMBOL[*) (*READBUFFER*)
(**)            (*RESWORD*) (*FINDNAME*) (*PARENTHESE*)
(**)            (*DOCOMMENT*) (*]INSYMBOL*)
(**)        (*"PARSING" PROCEDURES:*) (*RECDEF[*) (*CASEDEF*) (*PARENTHESE*) (*]
*)
(**)        (*STATEMENT[*) (*AND ITS PARTS*) (*]*)
(**)     (*]BLOCK*)
(**)     (*PRINT_XREF_LIST[*) (*CHECKPAGE*) (*WRITEPROCNAME*) (*WRITELINENR*) (*
DUMPCALL*)
(**)     (*]PRINT_XREF_LIST*)
(**) (*MAIN PROGRAM*)
(*DECLARATIONS*)

    (**********************************************************************
     *
     *
     *       PROGRAM WHICH CREATES A CROSS REFERENCE LISTING
     *       AND A NEW, REFORMATTED VERSION OF A PASCAL PROGRAM.
     *
     *       INPUT:  PASCAL SOURCE FILE.
     *       OUTPUT: NEW REFORMATTED SOURCE FILE AND
     *               CROSS-REFERENCE LISTING.
     *
     *       AUTHOR: MANUEL MALL (1974).
     *
     *       MODIFIED AT STANFORD UNIVERSITY BY LARRY PAULSON.
     *                       + NOT AS MANY FORCED NEWLINES.
     *                       + THE REPORT ON PROCEDURE CALLS WAS CANCELLED.
     *
     *       MODIFIED AT STANFORD UNIVERSITY BY ARMANDO R. RODRIGUEZ. 24-MAR-78.
     *                       + A NEW SET OF SWITCH OPTIONS.
     *                       + SOME NEW ERRORS ARE REPORTED.
     *
     *       SEE THE PROCEDURE CHECKOPTIONS FOR THE AVAILABLE SWITCHES.
     *
     *       MODIFIED AT STANFORD UNIVERSITY BY ARMANDO R. RODRIGUEZ. 6-JUL-88.
     *               + ACCEPT COMMENTS BETWEEN '%' AND BACKLASH  AND BETWEEN '/*
' AND '*/'.
     *               + MARK 'P' OR 'F' IN FRONT OF THE PROC-FUNC NAMES.
     *               + MARK 'D' FOR DECLARATIONS AND 'M' FOR MULTIPLE OCCURRENCE
S.
     *               + SWITCH CLEAN/NOCLEAN TO STANDARIZE COMMENTS.
     *               + LISTING OF PROC-FUNC CALL NESTING.
     *               + REPORT THE LINE NUMBERS OF BEGIN AND END OF BODY OF PROCE
DURES.
     *          THINGS TO BE FIXED, OR DOCUMENTED:
     *                  + IF THERE ARE TWO PROCS WITH ONE NAME, IT MIXES THEM.
     *                  + IF A PROC NAME IS USED AS A VAR LATER, IT WILL BE SEEN
     *                      AS A PROC FOR CALL-NESTING.
     *                  + MAKE IT SMART ENOUGH TO AVOID CREATING STRUCTURES
     *                      THAT WON'T BE USED, WHEN CROSS IS NOT 15.
     *                  + MAKE IT RUN FASTER IN GENERAL. (TRY SPECIFICALLY I/O).
     *
     *
     ***********************************************************************)




"**********************************************************************
 *                                                                    *
 *                                                                    *
 *   PCROSS is now  modified  to  run  under  the  Stanford  PASCAL   *
 *   system.   The  various  option switches for the program should   *
 *   now be specified in special comments of the following form:      *
 *                                                                    *
 *     (*%X+,F+,N-,R+,I-,C+,... other comments *)                     *
 *                                                                    *
 *     where:                                                         *
 *                                                                    *
 *     X+/- --> generate/do not generate a cross reference table,     *
 *     F+/- --> generate/do not generate a reformatted listing,       *
 *     N+/- --> allow/do not allow nesing of comments,                *
 *     R+/- --> use upper/lower case in printing the reserved words , *
 *     I+/- --> use upper/lower case in printing the identifieres,    *
 *     C+/- --> use upper/lower case in printing comments.            *
 *                                                                    *
 *                                                                    *
 *                                                                    *
 *   PCROSS in general, and its reformating function in particular,   *
 *   can be fairly time consuming and it  is  known  to  have  some   *
 *   problems.                                                        *
 *                                                                    *
 *                                                                    *
 *                                                                    *
 *                               Sassan Hazeghi                       *
 *                                                                    *
 *                               Stanford Linear Accelerator Center   *
 *                               P. O. Box 4349                       *
 *                               Stanfor, CA 94305.                   *
 *                                                                    *
 *                               Jan. 22 1979.                        *
 *                                                                    *
 *                                                                    *
 **********************************************************************"




##  LABEL  444;

CONST
    version ='PCROSS: VERSION OF 4-aug-78 AT STANFORD UNIVERSITY';
    maxline = 55;                         (*MAXIMUM NUMBER OF LINES PER PAGE, IG
NORING HEADER*)
    oldwidth =200;                        (*MAXIMUM LENGTH OF INPUT LINES*)
    max_line_count = 7777(*B*);           (*LIMIT OF LINES/EDIT-PAGE*)
    max_page_count = 77(*B*);             (*LIMIT OF EDIT-PAGES*)
    (*          MAX_LINE_COUNT AND MAX_PAGE_COUNT SHOULD NOT NEED MORE THAN 18 B
ITS TOTAL*)
    ht = 9 (*11B*);                      (*ASCII HORIZONTAL TAB*)
    ff = 12 (*14B*);                     (*ASCII FORM FEED*)
    cr = 13 (*15B*);                     (*ASCII CARRIAGE RETURN*)
    blanks = '          ';               (*FOR EDITING PURPOSES*)
    dots = '  .   .   .   .   .   .   .   .   .   .';
        (*'  .   .   .   .   .   .   .   .   .   .   .   .   .   .'; *)

TYPE
    pack6 = PACKED ARRAY[1..6] OF char;
    pack9 = PACKED ARRAY[1..9] OF char;

    errkinds = (begerrinblkstr,enderrinblkstr,missgenduntil,missgthen,missgof,
missgexit,
                missgrpar,missgquote,linetoolong,missgmain,missgpoint);
    lineptrty = @line;
    listptrty = @list;
    procstructy = @procstruc;
    calledty = @called;

    linenrty = 0..max_line_count;
    pagenrty = 0..max_page_count;

    symbol = (labelsy,constsy,typesy,varsy,programsy,             (*DECSYM*)
              functionsy,proceduresy,initprocsy,                  (*PROSYM*)
              endsy,untilsy,elsesy,thensy,exitsy,ofsy,dosy,eobsy, (*ENDSYMBOLS*)
              beginsy,casesy,loopsy,repeatsy,ifsy,                (*BEGSYM*)
              recordsy,forwardsy,gotosy,othersy,intconst,ident,strgconst,
externsy,langsy,forsy,whilesy,
              rbracket,rparent,semicolon,point,lparent,lbracket,colon,eqlsy,
otherssy(*DELIMITER*),
###           letterup, letterlo, digit,quotech, dquotech, spacech,
###           dollarch, undsch, skipch ) ;

    line = PACKED RECORD
                      (*DESCRIPTION OF THE LINE NUMBER*)
                      linenr : linenrty;            (*LINE NUMBER*)
                      pagenr : pagenrty;            (*PAGE NUMBER*)
                      contlink : lineptrty;         (*NEXT LINE NUMBER RECORD*)
                      declflag: char;               (*'D' IF DECLARATION, 'M' IF
 MULTIPLE OCCURRENCE, BLANK OTHERWISE*)
                  END;

    list = PACKED RECORD
                      (*DESCRIPTION OF IDENTIFIERS*)
                      name : alfa;                  (*NAME OF THE IDENTIFIER*)
                      llink ,                       (*LEFT SUCCESSOR IN TREE*)
                      rlink : listptrty;            (*RIGHT SUCCESSOR IN TREE*)
                      first ,                       (*POINTER TO FIRST LINE NUMB
ER RECORD*)
                      last  : lineptrty;            (*POINTER TO LAST LINE NUMBE
R RECORD*)
                      externflag: char;             (*'E' IF EXTERNAL, 'F' IF FO
RWARD,
                                                     'D' IF TWO PROCS WITH THE S
AME NAME, BLANK OTHERWISE*)
                      profunflag : char;            (*'P' IF PROCEDURE NAME, 'F'
 IF FUNCTION, BLANK OTHERWISE*)
                      procdata: procstructy;
                  END;


    procstruc = PACKED RECORD
                           (*DESCRIPTION OF THE PROCEDURE NESTING*)
                           procname : listptrty;    (*POINTER TO THE APPROPRIATE
 IDENTIFIER*)
                           nextproc : procstructy;  (*POINTER TO THE NEXT ELEMEN
T*)
                           linenr,                  (*LINE NUMBER OF THE PROCEDU
RE DEFINITION*)
                           begline,                 (*LINE NUMBER OF THE BEGIN S
TATEMENT*)
                           endline: linenrty;       (*LINENUMBER OF THE END STAT
EMENT*)
                           pagenr ,                 (*PAGE NUMBER OF THE PROCEDU
RE DEFINITION*)
                           begpage,                 (*PAGE NUMBER OF THE BEGIN S
TATEMENT*)
                           endpage,                 (*PAGE NUMBER OF THE END STA
TEMENT*)
                           proclevel: pagenrty;     (*NESTING DEPTH OF THE PROCE
DURE*)
                           firstcall: calledty;     (*LIST OF PROCEDURES CALLED
BY THIS ONE*)
                           printed: boolean;        (*TO AVOID LOOPS IN THE CALL
-NEST LIST*)
                       END;

    called = PACKED RECORD
                        nextcall : calledty;
                        whom : procstructy;
                    END;

VAR
    (*                    INPUT CONTROL*)
    i,                                    (*INDEX VARIABLE*)
    bufflen,                              (*LENGTH OF THE CURRENT LINE IN THE IN
PUT BUFFER*)
    buffmark,                             (*LENGTH OF THE ALREADY PRINTED PART O
F THE BUFFER*)
    bufferptr,                            (*POINTER TO THE NEXT CHARACTER IN THE
 BUFFER*)
    syleng,                               (*LENGTH OF THE LAST READ IDENTIFIER O
R LABEL*)

    (*                    NESTING AND MATCHING CONTROL*)
    bmarknr,                              (*NUMBER FOR MARKING OF 'BEGIN', 'LOOP
' ETC.*)
    emarknr,                              (*NUMBER FOR MARKING OF 'END', 'UNTIL'
 ETC.*)
    level,                                (*NESTING DEPTH OF THE CURRENT PROCEDU
RE*)
    variant_level,                        (*NESTING DEPTH OF VARIANTS*)
    blocknr,                              (*COUNTS THE STATEMENTS 'BEGIN', 'CASE
', 'LOOP', 'REPEAT', 'IF'*)
    errcount,                              (*COUNTS THE ERRORS ENCOUNTERED*)

    (*                    FORMATTING*)
    maxch,                                (*PAGE WIDTH IN COLS FOR CROSSLIST*)
    increment,                            (*LINE NUMBER INCREMENT*)
    indentbegin,                          (*INDENTATION AFTER A BEGIN*)
    begexd,                               (*EXDENTATION FOR BEGIN-END PAIRS*)
    feed,                                 (*INDENTATION BY PROCEDURES AND BLOCKS
*)
    spaces,                               (*INDENTATION FOR THE FORMATTING*)
    lastspaces,                           (*ONE-TIME OVERRIDING VALUE FOR SPACES
*)
    goodversion,                          (*keeps the value of the version optio
n*)
    pagecnt,                              (*COUNTS THE FILE PAGES*)
    pagecnt2,                             (*COUNTS THE PRINT PAGES PER FILE PAGE
*)
    maxinc,                               (*GREATEST ALLOWABLE LINE NUMBER*)
    reallincnt,                           (*COUNTS THE LINES  PER PRINT PAGE*)
    linecnt : integer;                    (*COUNTS THE LINES  PER FILE PAGE*)

    rtime: ARRAY[0..3] OF integer;        (*CPU TIME REPORT*)

    procstrucdata : RECORD
                        (*NEXT PROCEDURE TO BE PUT IN NESTING LIST*)
                        exists : boolean;
                        item : procstruc;
                    END;

    flagger : ARRAY [-1..202] OF boolean; (*INDICATOR FOR UPPER AND LOWER CASE P
RINTING*)
    buffer  : ARRAY [-1..202] OF char;    (*INPUT BUFFER*)
    (*          BUFFER HAS 2 EXTRA POSITIONS ON THE LEFT AND ONE ON THE RIGHT*)

##  tabs: ARRAY [1..17] OF (*ascii*) char;   (*A STRING OF TABS FOR FORMATTING*)

    linenb : PACKED ARRAY [1..5] OF char; (*SOS-LINE NUMBER*)
## "date_text,time_text: alfa;"           (*HEADING DATE AND TIME*)
    prog_name,                            (*NAME OF CURRENT PROGRAM*)
    sy      : alfa;                       (*LAST SYMBOL READ*)
    syty    : symbol;                     (*TYPE OF THE LAST SYMBOL READ*)

    (*                    SWITCHES*)
    renewing,                             (*SET IF THE NEWLSOURCE FILE IS BEING
WRITTEN*)
    crossing,                             (*SET IF THE CROSSLIST FILE IS BEING W
RITEN*)
    refing,                               (*SET IF THE REFERENCES WILL BE PRINTE
D*)
    decnesting,                           (*SET IF THE PRO-FUNC DECLARATION LIST
ING WILL BE PRINTED*)
    callnesting,                          (*SET IF THE PRO-FUNC CALL NESTING WIL
L BE PRINTED*)
    doting,                               (*SET IF DOTED LINES WILL BE PRINTED A
T LEFT MARGIN*)
    forcing,                              (*SET IF THEN, ELSE, DO, REPEAT WILL F
ORCE NEWLINE*)
nestcomments,                             (*ACCEPT NESTED COMMENTS*)
    cleaning,                             (*SET IF COMMENTS WILL BE STANDARIZD*)
    rescase,                              (*SET IF RESERVED WORDS WILL UPSHIFT*)
    nonrcase,                             (*SET IF NONRESERVED WORDS WILL UPSHIF
T*)
    comcase,                              (*SET IF COMMENTS WILL UPSHIFT*)
    strcase,                              (*SET IF STRINGS WILL UPSHIFT*)
    thendo,                               (*SET WHENEVER 'SPACES := SPACES+DOFEE
D' IS EXECUTED*)
    anyversion,                           (*set if goodversion > 9*)

    (*                    OTHER CONTROLS*)
    fwddecl,                              (*SET TRUE BY BLOCK AFTER 'FORWARD', '
EXTERN'*)
    oldspaces,                            (*SET WHEN LASTSPACES SHOULD BE USED*)
    eoline,                               (*SET AT END ON INPUT LINE*)
    gotoinline,                           (*SET IF A HORRENDOUS GOTO STATEMENT I
N THIS LINE*)
    declaring,                            (*SET WHILE PARSING DECLARATIONS*)
    programpresent,                       (*SET AFTER PROGRAM ENCOUNTERED*)
    nobody,                               (*SET IF NO MAIN BODY IS FOUND*)
    eob     : boolean;                    (*EOF-FLAG*)

                        (**)
    ch,                                   (*LAST READ CHARACTER*)
    bmarktext,                            (*CHARACTER FOR MARKING OF 'BEGIN' ETC
.*)
    emarktext: char;                      (*CHARACTER FOR MARKING 'END' ETC.*)

    (*                    SETS*)
    delsy : ARRAY [CHAR"' '..'_'"] OF symbol; (*TYPE ARRAY FOR DELIMITER CHARS*)
#   resnum: ARRAY[char] OF integer;       (*INDEX OF THE FIRST KEYWORD BEGINNING
 WITH THE INDEXED LETTER*)
    reslist : ARRAY [1..46] OF alfa;      (*LIST OF THE RESERVED WORDS*)
    ressy   : ARRAY [1..46] OF symbol;    (*TYPE ARRAY OF THE RESERVED WORDS*)
## "alphanum,                             (*CHARACTERS FROM 0..9 AND A..Z*)
    digits,                               (*CHARACTERS FROM 0..9*)
##  letters : SET OF char; "              (*CHARACTERS FROM A..Z*)
    relevantsym,                          (*START SYMBOLS FOR STATEMENTS AND PRO
CEDURES*)
    prosym,                               (*ALL SYMBOLS WHICH BEGIN A PROC.*)
    decsym,                               (*ALL SYMBOLS WHICH BEGIN DECLARATIONS
*)
    begsym,                               (*ALL SYMBOLS WHICH BEGIN COMPOUND STA
TEMENTS*)
    endsym  : SET OF symbol;              (*ALL SYMBOLS WHICH TERMINATE  STATEME
NTS OR PROCEDURES*)

    (*                    POINTERS AND FILES*)
    listptr, heapmark : listptrty;        (*POINTER INTO THE BINARY TREE OF THE
IDENTIFIER*)
    firstname : ARRAY [char    ] OF listptrty;    (*POINTER TO THE ROOTS OF THE
TREE*)
    procstrucf,                           (*POINTER TO THE FIRST ELEMENT OF THE
PROCEDURE CALLS LIST*)
    procstrucl : procstructy;             (*POINTER TO THE LAST ELEMENT OF THE P
ROCEDURE CALLS LIST*)
    workcall: calledty;
    link_name,
    new_name, cross_name: pack9;          (*USED TO GET THE PARAMETER FILES*)
    old_dev,link_device,
    new_dev,cross_dev:pack6;
    old_prot,old_ppn,
    new_prot,new_ppn,cross_prot,cross_ppn: integer;
    programname,oldfileid,newfileid,crossfileid: alfa;
##  TTY,
    OLDSOURCE,NEWSOURCE,CROSSLIST: text;  (*FILES PROCESSED BY THIS PROGRAM*)

    (*INITPROCEDURES*)

# PROCEDURE init0; "INITPROCEDURE;"
    BEGIN (*CONSTANTS*)
    eob := false;
    maxch:=114;
##  increment:= "100" 1;
    feed:=4;
    indentbegin:=0;
##  nestcomments := true ;
##  cleaning := true ;
    begexd:=0;
    rescase:=true;
    nonrcase:=false;
    comcase:=false;
    strcase:=true;
    renewing:=true;
    crossing:=true;
##  refing:= true (*false*);
##  decnesting:= true (*false*);
##  callnesting:=true  (*false*);
##  doting:=false (*true*);
    nobody := false;
    anyversion := false;
    goodversion := -1;
    new_name:='         ';
    cross_name:='         ';
    programname:='PCROSS    ';
    oldfileid:='OLDSOURCE ';
    newfileid:='NEWSOURCE ';
    crossfileid:='CROSSLIST ';
    END (*CONSTANTS*);


#  procedure init1; "INITPROCEDURE;"
    BEGIN (*RESERVED WORDS*)
    resnum['A'] :=  1;    resnum['B'] :=  3;    resnum['C'] :=  4;
    resnum['D'] :=  6;    resnum['E'] :=  9;    resnum['F'] := 13;
    resnum['G'] := 18;    resnum['H'] := 19;    resnum['I'] := 19;
##  resnum[succ('I')] := 22;
    resnum['J'] := 22;    resnum['K'] := 22;    resnum['L'] := 22;
    resnum['M'] := 24;    resnum['N'] := 25;    resnum['O'] := 27;
    resnum['P'] := 30;    resnum['Q'] := 33;    resnum['R'] := 33;
##  resnum[succ('R')] := 35 ;
    resnum['S'] := 35;    resnum['T'] := 36;    resnum['U'] := 39;
    resnum['V'] := 40;    resnum['W'] := 41;    resnum['X'] := 43;
    resnum['Y'] := 43;    resnum['Z'] := 43;    resnum[succ('Z')] := 43;

    reslist[ 1] :='AND       '; ressy [ 1] := othersy;
    reslist[ 2] :='ARRAY     '; ressy [ 2] := othersy;
    reslist[ 3] :='BEGIN     '; ressy [ 3] := beginsy;
    reslist[ 4] :='CASE      '; ressy [ 4] := casesy;
    reslist[ 5] :='CONST     '; ressy [ 5] := constsy;
    reslist[ 6] :='DO        '; ressy [ 6] := dosy;
    reslist[ 7] :='DIV       '; ressy [ 7] := othersy;
    reslist[ 8] :='DOWNTO    '; ressy [ 8] := othersy;
    reslist[ 9] :='END       '; ressy [ 9] := endsy;
    reslist[10] :='ELSE      '; ressy [10] := elsesy;

##  reslist[11] :='EXIT____  '; ressy [11] := exitsy;
    reslist[12] :='EXTERN    '; ressy [12] := externsy;
    reslist[13] :='FOR       '; ressy [13] := forsy;
    reslist[14] :='FILE      '; ressy [14] := othersy;
    reslist[15] :='FORWARD   '; ressy [15] := forwardsy;
    reslist[16] :='FUNCTION  '; ressy [16] := functionsy;
    reslist[17] :='FORTRAN   '; ressy [17] := langsy;
    reslist[18] :='GOTO      '; ressy [18] := gotosy;
    reslist[19] :='IF        '; ressy [19] := ifsy;
    reslist[20] :='IN        '; ressy [20] := othersy;

    reslist[21] :='INITPROCED'; ressy [21] := initprocsy;
    reslist[22] :='LOOP____  '; ressy [22] := loopsy;
    reslist[23] :='LABEL     '; ressy [23] := labelsy;
    reslist[24] :='MOD       '; ressy [24] := othersy;
    reslist[25] :='NOT       '; ressy [25] := othersy;
    reslist[26] :='NIL       '; ressy [26] := othersy;
    reslist[27] :='OR        '; ressy [27] := othersy;
    reslist[28] :='OF        '; ressy [28] := ofsy;
    reslist[29] :='OTHERS    '; ressy [29] := otherssy;
    reslist[30] :='PACKED    '; ressy [30] := othersy;

    reslist[31] :='PROCEDURE '; ressy [31] := proceduresy;
    reslist[32] :='PROGRAM   '; ressy [32] := programsy;
    reslist[33] :='RECORD    '; ressy [33] := recordsy;
    reslist[34] :='REPEAT    '; ressy [34] := repeatsy;
    reslist[35] :='SET       '; ressy [35] := othersy;
    reslist[36] :='THEN      '; ressy [36] := thensy;
    reslist[37] :='TO        '; ressy [37] := othersy;
    reslist[38] :='TYPE      '; ressy [38] := typesy;
    reslist[39] :='UNTIL     '; ressy [39] := untilsy;
    reslist[40] :='VAR       '; ressy [40] := varsy;

    reslist[41] :='WHILE     '; ressy [41] := whilesy;
    reslist[42] :='WITH      '; ressy [42] := othersy;
    END;


# procedure init2; "INITPROCEDURE;"
    BEGIN (*SETS*)
## "digits := ['0'..'9'];
    letters := ['A'..'Z'];
##  alphanum := ['0'..'9','A'..'Z'] (*LETTERS OR DIGITS*); "
    decsym := [labelsy,constsy,typesy,varsy,programsy];
    prosym := [functionsy..initprocsy];
    endsym := [functionsy..eobsy];      (*PROSYM OR ENDSYMBOLS*)
    begsym := [beginsy..ifsy];
    relevantsym := [labelsy..initprocsy (*DECSYM OR PROSYM*),beginsy,forwardsy,
externsy,eobsy];
    END (*SETS*);


PROCEDURE init;
    BEGIN
#   init0 ;
#   init1 ;
#   init2 ;
#   rtime[0]:=clock(1);
    new(heapmark);    (*THE HEAP IS DEALLOCATED AFTER EACH PROGRAM*)
    workcall := NIL;
    i := 0;
    bufflen := 0;
    buffmark := 0;
    bufferptr := 2;
    variant_level := 0;
    reallincnt:= 0;
    linecnt :=0;
    blocknr := 0;
    level := 0;
    pagecnt := 1;
    pagecnt2 := 0;
    errcount := 0;
    eoline := true;
    gotoinline := false;
    programpresent := false;
    procstrucdata.exists := false;
    oldspaces := false;
    declaring := false;
    bmarktext := ' ';
    emarktext := ' ';
    sy := blanks;   prog_name := blanks;
#  "date(date_text);  time(time_text);"
    FOR ch := chr(0) to chr(255) DO
        firstname [ch] := NIL;
    FOR ch := ' ' TO 'Z' DO
        delsy [ch] := othersy;
###   FOR ch := 'A' TO 'I' DO    delsy[ch] := letterup ;
###   FOR ch := 'J' TO 'R' DO    delsy[ch] := letterup ;
###   FOR ch := 'S' TO 'Z' DO    delsy[ch] := letterup ;
###   FOR ch := 'a' TO 'i' DO    delsy[ch] := letterlo ;
###   FOR ch := 'j' TO 'r' DO    delsy[ch] := letterlo ;
###   FOR ch := 's' TO 'z' DO    delsy[ch] := letterlo ;
###   FOR ch := '0' TO '9' DO    delsy[ch] := digit ;
###   delsy['"']  := dquotech;
###   delsy['#']  := skipch ;
###   delsy['$']  := dollarch ;
###   delsy[''''] := quotech ;
###   delsy['_']  := undsch ;
    delsy [' '] := spacech;
    delsy ['('] := lparent;
    delsy [')'] := rparent;
    delsy ['['] := lbracket;
    delsy [']'] := rbracket;
    delsy [';'] := semicolon;
    delsy ['.'] := point;
    delsy [':'] := colon;
    delsy ['='] := eqlsy;
    FOR i := -1 TO 201 DO
        buffer [i] := ' ';
    i := 0;
    new (firstname['M']);
    listptr := firstname ['M'];
    WITH firstname ['M']@ DO
        BEGIN
        name := 'MAIN.     ';
        llink := NIL;
        rlink := NIL;
        profunflag := 'M';
        new (first);
        last := first;
        WITH last@ DO
            BEGIN
            linenr := 1;
            pagenr:=1;
            contlink := NIL;
            END;
        END;
    new (procstrucf);
    WITH procstrucf@ DO
        BEGIN
        procname := firstname ['M'];
        nextproc := NIL;
        linenr   := 1;
        pagenr:=1;
        proclevel:= 0;
        firstcall := NIL;
        END;
    procstrucl := procstrucf;
    ch := ' ';
    FOR i := 1 TO 17 DO
##      tabs [i] := "chr (ht)" ' ';
#   linenb := '-----' ;
    END (*INIT*);
    (*CHECKOPTIONS[*) (*SETSWITCH*)

    (*---------------------------------------------------------------------
     !  CHECKS THE PRESENCE OF SWITCHES WITH THE FILE NAMES.
     !
     !  VALID SWITCHES ARE:                     BRACKETS INDICATE OPTIONAL.
     !                                          <N> STANDS FOR AN INTEGER NUMBER
.
     !                                          <L> STANDS FOR A LETTER.
     !
     !  SWITCH          MEANING                                         DEFAULT.
     !
     !           FILES.
     !   /[NO]NEW        WRITTING OF THE NEWSOURCE FILE                 ON
     !   /[NO]CROSS[:<N>]  WRITTING OF THE CROSSLIST FILE.              ON,15
     !                    <N> IS THE SUM OF:
     !                          1   SOURCE PROGRAM LISTING
     !                          2   LISTING OF IDENTIFIERS
     !                          4   LISTING OF PROC-FUNC
     !                              DECLARATION NESTING.
     !                          8   LISTING OF PROC-FUNC CALL NESTING.
     !   /version:<n>    behave as if conditionally compiling %<n>
     !                     comments.                                    -1
     !
     !           PAGE AND LINE FORMAT
     !   /WIDTH:<N>      PAGE WIDTH FOR CROSSLIST. (MINIMUM: 40)        132
     !   /INDENT:<N>     INDENTATION BETWEEN LEVELS.                    4
     !   /INCREMENT:<N>  LINE NUMBER INCREMENT                          100
     !   /[NO]DOTS       PUT AS A GUIDE A DOTTED LINE AT THE LEFT
     !                   MARGIN EVERY FIFTH LINE                        ON
     !
     !           STATEMENT FORMAT
     !   /BEGIN:[-]<N>   IF THE [-] IS NOT THERE, THE CONTENTS OF A
     !                     BEGIN..END BLOCK IS INDENTED N SPACES FURTHER.
     !                   IF IT IS THERE, THE BLOCK WILL NOT BE INDENTED,
     !                     BUT THE BEGIN AND END STATEMENTS WILL BE
     !                     EXDENTED N SPACES.                           0
     !   /[NO]FORCE      FORCES NEWLINE IN STANDARD PLACES. (BEFORE AND
     !                    AFTER BEGIN, END, THEN, ELSE, REPEAT, ETC.)   OFF
     !   /[NO]CLEAN      CONVERTS THE SYMBOLS FOR BEGIN AND END OF
     !                    COMMENT FROM OLD STANDARDS TO '('-'*' AND '*'-')'
ON
     !
     !           UPPER AND LOWER CASE
     !                          NOTE: THE POSSIBLE VALUES FOR <L> ARE:
     !                                  U MEANS UPPER CASE
     !                                  L MEANS LOWER CASE.
     !
     !   /RES:<L>        CASE USED FOR RESERVED WORDS.                  U
     !   /NONRES:<L>     SAME FOR NON-RESERVED WORDS.                   L
     !   /COMM:<L>       SAME FOR COMMENTS.                             L
     !   /STR:<L>        SAME FOR STRINGS.                              U
     !   /CASE:<L>       RESETS ALL THE DEFAULTS TO <L>.
OFF
     !
     +--------------------------------------------------------------------*)

PROCEDURE checkoptions;
    VAR
        try: integer;

    PROCEDURE setswitch(opt:alfa;VAR switch:boolean);
        VAR
            i: integer;
        BEGIN (*SETSWITCH*)
##(*    getoption(opt,i);   *)  i := ord('l') ;
        IF i=ord('L') THEN
            switch:=false
        ELSE
            IF i=ord('U') THEN
                switch:=true;
        END (*SETSWITCH*);

    PROCEDURE showthemall (i: integer);
        BEGIN
        writeln (tty,'(',i:3,')',oldfileid,',',programname);
        writeln (tty, new_name,',',new_prot,',',new_ppn,',',new_dev,',',
newfileid,',',programname);
        writeln (tty, cross_name,',',cross_prot,',',cross_ppn,',',cross_dev,',',
crossfileid,',',programname);
        writeln (tty);
##       (* break(tty); *)
        END;

    BEGIN (*CHECKOPTIONS*)
    ###########(*##############
    getparameter(oldsource,oldfileid,programname,true);
    IF NOT option('NONEW     ') THEN
      parnameget(new_name,new_prot,new_ppn,new_dev,newfileid,programname,false);
    IF NOT option('NOCROSS   ') THEN
        parnameget(cross_name,cross_prot,cross_ppn,cross_dev,crossfileid,program
name,false);

    IF NOT option('NONEW     ') THEN
        begin
        IF (new_name = '         ') AND (new_dev = 'dsk   ') THEN
            BEGIN
            getstatus(oldsource, new_name,old_prot,old_ppn,old_dev);
            new_name[7]:='N';
            new_name[8]:='E';
            new_name[9]:='W';
            END;
        startfile(newsource,new_name,new_prot,new_ppn,new_dev,false,newfileid);
        end;

    IF NOT option('NOCROSS   ') THEN
        begin
        IF (cross_name = '         ') AND (cross_dev = 'dsk   ') THEN
            BEGIN
            getstatus(oldsource, cross_name,old_prot,old_ppn,old_dev);
            cross_name[7]:='C';
            cross_name[8]:='R';
            cross_name[9]:='L';
            END;
        startfile(crosslist,cross_name,cross_prot,cross_ppn,cross_dev,false,cros
sfileid);
        end;
######################*)##############

##  renewing:= true "NOT option('NONEW     ')" ;

##  crossing:= true "NOT option('NOCROSS   ')" ;
    IF crossing THEN
        BEGIN
##(*    getoption('CROSS     ',try);     *) try  := 0 ;
        IF try = 0 THEN
            try:=15;
        callnesting:=try > 7;
        decnesting:=(try MOD 8) > 3;
        refing:= (try MOD 4) > 1;
        crossing:=(try MOD 2) = 1;
        END;

##(*if option('version   ') then    *)
        begin
##(*    getoption('version   ',goodversion);  *)  goodversion := 15 ;
        if goodversion > 9 then
            begin
            goodversion := -1;
            anyversion := true;
            end;
        end;

##(*IF option('WIDTH     ') THEN  *)
        BEGIN
##(*    getoption('WIDTH     ',maxch);  *)  maxch := 90 ;
        IF maxch < 40 THEN
            maxch:=40;
        maxch:=maxch-18;
        END;

#################(*##################
    IF option('INDENT    ') THEN
        BEGIN
##(*    getoption('INDENT    ',feed);                 *)
        IF feed < 0 THEN
            feed:=4;
        END;

    IF option('INCREMENT ') THEN
        BEGIN
##(*    getoption('INCREMENT ',increment);            *)
        IF increment < 0 THEN
##          increment:= "100" 1;
        END;

    doting:=NOT option('NODOTS    ');

    IF option('BEGIN     ') THEN
        BEGIN
##(*    getoption('BEGIN     ',indentbegin);          *)
        IF indentbegin < 0 THEN
            BEGIN
            begexd:=-indentbegin;
            indentbegin:=0;
            END;
        END;

    forcing:=option('FORCE     ');

    cleaning := NOT option('NOCLEAN   ');

    IF option('CASE      ') THEN
        BEGIN
        setswitch('CASE      ',rescase);
        nonrcase:=rescase;
        comcase:=rescase;
        strcase:=rescase;
        END;

    setswitch('RES       ',rescase);
    setswitch('NONRES    ',nonrcase);
    setswitch('COMM      ',comcase);
    setswitch('STR       ',strcase);
#################*)##################
    END (*CHECKOPTIONS*);
    (*PAGE AND LINE CONTROL*) (*HEADER*) (*NEWPAGE*) (*NEWLINE*)

PROCEDURE header (name: alfa);
    (*PRINT TOP OF FORM AND HEADER ON LIST OUTPUT*)
    VAR
        position: integer;

    BEGIN (*HEADER*)
    pagecnt2 := pagecnt2 + 1;
    reallincnt := 0;
    IF crossing THEN
        BEGIN
        page(crosslist); " writeln(crosslist) ;"
##      write (crosslist, 'Page':9, pagecnt:4, '-', pagecnt2:3 ", ' ':15");
        position := 84;
        IF maxch < 84 THEN
            BEGIN
            reallincnt:=1;
            writeln(crosslist);
            position := 42;
            END;
        write(crosslist,'   [', prog_name,']', time"_text":50, date"_text");
        IF (name <> blanks) AND (maxch < position + 25) THEN
            BEGIN
            reallincnt := reallincnt + 1;
            writeln (crosslist);
            position := 0;
            END;
        writeln (crosslist, ' ': maxch - position, name);
        writeln(crosslist);
        END;
    END (*HEADER*);


PROCEDURE newpage;
    BEGIN (*NEWPAGE*)
    pagecnt2 := 0;
    pagecnt := pagecnt + 1;
    IF renewing THEN
##    (*write(newsource, chr(cr), chr(ff));*)    writeln(newsource) ;
    header (blanks);
    IF eoln (oldsource) THEN
        readln(oldsource);
    linecnt := 0;
    reallincnt := 0;
    IF prog_name <> blanks  THEN
        write(tty, pagecnt:3,'..');
##   (* break(tty); *)
    END (*NEWPAGE*);


PROCEDURE newline;
    BEGIN
    IF reallincnt = maxline THEN
        header (blanks);
    linecnt := linecnt + 1;
    reallincnt := reallincnt + 1;
##  if crossing then write(crosslist, ' ':5);
##  if renewing then write(newsource, ' ':5) ;
    END;
    (*BLOCK[*) (*OUTPUT PROCEDURES:*) (*ERROR*) (*WRITELINE[*) (*USETABS*) (*]*)
 (*SETLASTSPACES*)


PROCEDURE block;
    VAR
        curproc : listptrty;        (*ZEIGER AUF DIE PROZEDUR IN DEREN ANWEISUNG
STEIL DAS PROGRAMM SICH BEFINDET*)
        itisaproc : boolean;        (*TRUE WHEN THE WORD PROCEDURE IS FOUND*)
        locprocstl: procstructy;


    PROCEDURE error (errnr : errkinds);
        BEGIN (*ERROR*)
        errcount := errcount+1;
        reallincnt := reallincnt + 1; (*COUNT THE LINE OF THE ERROR MESSAGE ON T
HE LPT: FILE*)
        IF crossing THEN
            BEGIN
            write (crosslist, ' ':17,' *??* ');
            CASE errnr OF
                begerrinblkstr   : write(crosslist, sy,' ? ? ? : ERROR IN BLOCK'
,'STRUCTURE. POSSIBLY A MISSING BEGIN.');
                enderrinblkstr   : write(crosslist, sy,' ? ? ? : ERROR IN BLOCK'
,'STRUCTURE. POSSIBLY A MISSING END.');
                missgenduntil : write(crosslist, 'MISSING ''END'' OR ''UNTIL'' '
,'NUMBER ',emarknr : 4);
                missgthen     : write(crosslist, 'MISSING ''THEN'' NUMBER ',
emarknr : 4);
                missgof       : write(crosslist, 'MISSING ''OF'' TO ''CASE'' '
,'NUMBER ',bmarknr : 4);
                missgexit     : write(crosslist, 'MISSING ''EXIT'' IN ''LOOP'' '
,emarknr : 4);
                missgrpar     : write(crosslist, 'MISSING RIGHT PARENTHESIS OR '
,'BRACKET');
                missgquote    : write(crosslist, 'MISSING CLOSING QUOTE ON THIS'
,' LINE');
                linetoolong:
                          IF renewing THEN
                              write(crosslist,'NEXT LINE IS TOO LONG. IT WILL '
,'BE BROKEN AT COLUMN',
                                    oldwidth:4,' IN NEWSOURCE.');
                missgmain     : write(crosslist, 'WARNING: THIS FILE HAS NO '
,'MAIN BODY');
                missgpoint    : write(crosslist,'MISSING CLOSING POINT AT END '
,'OF PROGRAM.');
                END;
            writeln(crosslist,' *??*');
            END;
        writeln(tty);
        write(tty, ' ERROR AT ', linecnt*increment: 5, '/', pagecnt:2,
                    ord(errnr):12);
        END (*ERROR*) ;


    PROCEDURE writeline (position (*LETZTES ZU DRUCKENDES ZEICHEN IM PUFFER*):
integer);
        VAR
            i, j, tabcnt, maxchar: integer;    (*MARKIERT ERSTES ZU DRUCKENDES Z
EICHEN*)


        PROCEDURE usetabs(lastspaces: integer;crossing,renewing:boolean);
            VAR
                lspaces: integer;
            BEGIN (*USETABS*)
            (*USE TABS AND SPACES TO MAKE INDENTATION*)
            tabcnt := lastspaces DIV 8;
            lspaces := lastspaces MOD 8;
            IF renewing THEN
                BEGIN
                write(newsource, tabs:tabcnt*8);
                write(newsource, ' ': lspaces);
                END;
            IF crossing THEN
                IF doting AND ((reallincnt MOD 5) = 4) THEN
                    BEGIN
##                  write(crosslist, ' ', dots: lastspaces - 1);
                    IF lastspaces > 0 THEN
                        write (crosslist, ' ');
                    END
                ELSE
                    BEGIN
                    write(crosslist, tabs: tabcnt*8);
                    write (crosslist, ' ': lspaces);
             (*+++  IF lastspaces > 7 THEN              (*COMPENSATE FOR THE FIR
ST TAB*)
                        write (crosslist, '  ');    +++*)
                    END;
            END (*USETABS*);

        BEGIN (*WRITELINE*)
        position := position - 2;
        IF position > 0 THEN
            BEGIN
            i := buffmark + 1;
            WHILE (buffer [i] = ' ') AND (i <= position) DO
                i := i + 1;
            buffmark := position;
            WHILE (buffer [position] = ' ') AND (i < position) DO
                position := position - 1;
            IF i <= position THEN
                BEGIN
                IF NOT programpresent THEN
                    BEGIN
                    programpresent := true;
                    header (blanks);
                    END;
                newline;
                IF crossing THEN
                    BEGIN
                    IF gotoinline THEN
                        BEGIN
                        write(crosslist, '****GOTO****');
                        gotoinline := false;
                        bmarktext:=' ';
                        emarktext:=' ';
                        END
                    ELSE
                        BEGIN
                        IF bmarktext <> ' ' THEN
                            BEGIN
                            write (crosslist, bmarktext, bmarknr : 4, ' ');
                            bmarktext := ' ';
                            END
                        ELSE
                            write(crosslist,'      ');
                        IF emarktext <> ' ' THEN
                            BEGIN
                            write (crosslist,emarktext,emarknr : 4,' ');
                            emarktext := ' ';
                            END
                        ELSE
                            write (crosslist,'      ');
                        END;
                    write (crosslist, linecnt * increment : 5,' ');
                    END;
                IF NOT oldspaces THEN
                    lastspaces := spaces;
                usetabs(lastspaces,crossing,renewing);
                maxchar:=maxch+i-lastspaces-1;
                FOR j := i TO position DO
                    BEGIN
                    IF crossing AND (j > maxchar) THEN
                        BEGIN
                        writeln(crosslist);
                        IF reallincnt = maxline THEN
                            header (blanks);
                        reallincnt:=reallincnt+1;
                        usetabs(lastspaces+18+feed,crossing,false);
                        maxchar:=maxch+j-lastspaces-1;
                        END;
##                  IF (NOT flagger[j]) AND (* ('A' <= buffer[j]) AND
###                  (buffer[j] <= 'Z') *) (delsy[buffer[j]] = letterup) THEN
                        BEGIN
                        IF crossing THEN
###                         write(crosslist,chr(ord(buffer[j])-64(*+40B*)));
                        IF renewing THEN
###                         write(newsource,chr(ord(buffer[j])-64(*+40B*)));
                        END
                    ELSE
##                  IF flagger[j] AND (delsy[buffer[j]] = letterlo)  then

                        BEGIN
                        IF crossing THEN
###                         write(crosslist,chr(ord(buffer[j])+64(*+40B*)));
                        IF renewing THEN
###                         write(newsource,chr(ord(buffer[j])+64(*+40B*)));
                        END
                    ELSE
                        BEGIN
                        IF crossing THEN
                            write (crosslist, buffer [j]);
                        IF renewing THEN
                            write(newsource, buffer[j]);
                        END;
                    END;
                IF crossing THEN
                    writeln(crosslist);
                IF renewing THEN
                    writeln(newsource);
                IF ((linenb = '     ') AND (position = bufflen)) OR (maxinc <=
linecnt) THEN
                    newpage;
                END;
            END;
        lastspaces := spaces;
        oldspaces := false;
        thendo := false;
        END (*WRITELINE*) ;


    PROCEDURE setlastspaces(i: integer);
        BEGIN
        oldspaces := true;
##      lastspaces := 0 ;  if i > 0 then  lastspaces := i ;   (*max(0,i);*)
        END;
        (*INPUT PROCEDURES:*) (*INSYMBOL[*) (*READBUFFER*)

    PROCEDURE insymbol ;
        LABEL 1;
        VAR
            oldspacesmark,            (*ALTER ZEICHENVORSCHUB BEI FORMATIERUNG V
ON KOMMENTAREN*)
            i: integer;



        PROCEDURE readbuffer;
            (*READS A CHARACTER FROM THE INPUT BUFFER*)


            PROCEDURE readline;
                (*HANDLES LEADING BLANKS AND BLANK LINES, READS NEXT NONBLANK LI
NE
                 (WITHOUT LEADING BLANKS) INTO BUFFER*)
                LABEL 111 ;
                VAR
                    ch : char;
                BEGIN (*READLINE*)
                (*ENTERED AT THE BEGINNING OF A LINE*)
                REPEAT
                    WHILE eoln (oldsource) AND NOT eof (oldsource) DO
                        BEGIN
                        (*IS THIS A PAGE MARK?*)
##                     "getlinenr (oldsource,linenb);"
                        readln(oldsource);
                        IF (linenb = '     ') AND programpresent THEN
                            newpage
                        ELSE
                            IF programpresent THEN
                                BEGIN
                                (*HANDLE BLANK LINE*)
                                newline;
                                IF crossing THEN
                                    writeln (crosslist,"chr(ht)"' ':12,linecnt *
 increment : 5);
                                IF renewing THEN
                                    writeln(newsource);
                                IF maxinc <= linecnt THEN
                                    newpage;
                                END;
                        END;
                    read(oldsource, ch);
                UNTIL (ch <> ' ') OR (eof (oldsource));
                bufflen := 0;
                (*READ IN THE LINE*)
##            (*LOOP *)  repeat
                    bufflen := bufflen + 1;
                    buffer [bufflen] := ch;
                    flagger[bufflen]:=nonrcase;
##            (*EXIT*) IF (eoln (oldsource) OR (bufflen = oldwidth))
                         THEN GOTO 111 ;
                    read(oldsource, ch);
                  (*END*) UNTIL FALSE ;
              111:
                buffer[bufflen+1] := ' '; (*SO WE CAN ALWAYS BE ONE CHAR AHEAD*)
                IF NOT eoln (oldsource) THEN
                    error(linetoolong)
                ELSE
                    IF NOT eof (oldsource) THEN
                        BEGIN
##                     "getlinenr (linenb);"
                        readln(oldsource);
                        END;
                bufferptr := 1;
                buffmark := 0;
                END (*READLINE*) ;

            BEGIN (*READBUFFER*)
            (*IF READING PAST THE EXTRA BLANK ON THE END, GET A NEW LINE*)
            IF eoline THEN
                BEGIN
                writeline (bufferptr);
                ch := ' ';
                IF eof (oldsource) THEN
                    eob := true
                ELSE
                    readline;
                END
            ELSE
                BEGIN
                ch := buffer [bufferptr];
                bufferptr := bufferptr + 1;
                END;
            eoline := bufferptr = bufflen + 2;
            END (*READBUFFER*) ;

            (*RESWORD*) (*FINDNAME*) (*PARENTHESE*)

        FUNCTION resword: boolean ;
            (*DETERMINES IF THE CURRENT IDENTIFIER IS A RESERVED WORD*)
##          LABEL 222 ;
            VAR
                i,j: integer;  lid : alfa ;
            BEGIN (*RESWORD*)
##          resword:= false; lid := sy ;
##          for i := 1 to 10 do
##            if delsy[lid[i]] = letterlo then lid[i] := chr( ord(lid[i]) +64) ;
##          FOR i:=resnum[lid[1]] TO resnum[succ(lid[1])] - 1
            DO
##              IF reslist[ i ] = lid THEN
                    BEGIN
                    resword := true;
                    syty := ressy [i];
##               (* i:=resnum[succ(sy[1])]; ** BUG 1 **   *)
                    FOR j:=bufferptr-syleng-1 TO bufferptr-2 DO
                        flagger[j]:=rescase;
##                   GOTO 222;
                    END;
##          222:
            END (*RESWORD*) ;


##      PROCEDURE findname "(curproc: listptrty)" (*does not seem to be used*);
            VAR
                lptr: listptrty;        (*ZEIGER AUF DEN VORGAENGER IM BAUM*)
                bptr,
                zptr : lineptrty;       (*ZEIGER AUF DIE VORLETZTE ZEILENNUMMER
IN EINER KETTE*)
                found,                  (*SET AFTER IDENTIFIER IS FOUND*)
                right: boolean;         (*MERKVARIABLE FUER DIE VERZWEIGUNG IM B
AUM*)
                indexch : char;         (*INDEXVARIABLE FUER DAS FELD DER STARTZ
EIGER (FIRSTNAME)*)

            BEGIN (*FINDNAME*)
            indexch := sy [1];
            listptr := firstname [indexch];
            (*SEARCH IN THE TREE FOR THE IDENTIFIER*)
            found := false;
            WHILE NOT found AND (listptr <> NIL) DO
                BEGIN
                lptr:= listptr;
                IF sy = listptr@.name THEN
                    BEGIN
                    found := true;
##                  IF"(listptr@.profunflag IN ['P', 'F'])"(NOT declaring) AND
##                    ((listptr@.profunflag = 'P')OR(listptr@.profunflag = 'F'))
                      THEN
                        BEGIN
                        new (workcall);
                        workcall@.whom := listptr@.procdata;
                        workcall@.nextcall := NIL;
                        END;
                    zptr := listptr@.last;
                    IF (zptr@.linenr <> linecnt+1) OR (zptr@.pagenr <> pagecnt)
THEN
                        BEGIN
                        new (listptr@.last);
                        WITH listptr@.last@ DO
                            BEGIN
                            linenr := linecnt + 1;
                            pagenr := pagecnt;
                            contlink := NIL;
                            IF declaring THEN
                                declflag := 'D'
                            ELSE
                                declflag := ' ';
                            END;
                        zptr@.contlink := listptr@.last;
                        END
                    ELSE
                        zptr@.declflag := 'M';
                    END
                ELSE
                    IF sy > listptr@.name THEN
                        BEGIN
                        listptr:= listptr@.rlink;
                        right:= true;
                        END
                    ELSE
                        BEGIN
                        listptr:= listptr@.llink;
                        right:= false;
                        END;
                END;
            IF NOT found THEN
                BEGIN (*UNKNOWN IDENTIFIER*)
                new (listptr);
                WITH listptr@ DO
                    BEGIN
                    name := sy;
                    llink := NIL;
                    rlink := NIL;
                    profunflag := ' ';
                    externflag := ' ';
                    procdata := NIL;
                    END;
                IF firstname [indexch] = NIL THEN
                    firstname [indexch] := listptr
                ELSE
                    IF right THEN
                        lptr@.rlink := listptr
                    ELSE
                        lptr@.llink := listptr;
                WITH listptr@ DO
                    BEGIN
                    new (first);
                    WITH first@ DO
                        BEGIN
                        linenr := linecnt + 1;
                        pagenr := pagecnt;
                        contlink := NIL;
                        IF declaring THEN
                            declflag := 'D'
                        ELSE
                            declflag := ' ';
                        END;
                    last := first ;
                    END;
                END;
            END (*FINDNAME*) ;

        PROCEDURE insertcall;
            VAR
                thiscall: calledty;
                repeated,               (*SET IF SY IS A PROC-NAME AND IS ALREAD
Y IN THE CALL SEQUENCE*)
                finished: boolean;      (*SET WHEN DONE CHECKING THE CALL SEQUEN
CE*)

            BEGIN (*INSERTCALL*)
            IF locprocstl@.firstcall = NIL THEN
                locprocstl@.firstcall := workcall
            ELSE
                BEGIN
                thiscall := locprocstl@.firstcall;
                repeated := false;
                finished := false;
                WHILE (NOT finished) AND (NOT repeated) DO
                    IF thiscall@.whom@.procname@.name = workcall@.whom@.procname
@.name THEN
                        repeated := true
                    ELSE
                        IF thiscall@.nextcall = NIL THEN
                            finished := true
                        ELSE
                            thiscall := thiscall@.nextcall;
                IF NOT repeated THEN
                    thiscall@.nextcall := workcall;
                END;
            workcall := NIL;
            END (*INSERTCALL*);


        PROCEDURE parenthese (which: symbol);
            (*HANDLES THE FORMATTING OF PARENTHESES, EXCEPT THOSE IN VARIANT PAR
TS OF RECORDS*)
            VAR
                oldspacesmark : integer;        (*ALTER ZEICHENVORSCHUB BEI FORM
ATIERUNG VON KLAMMERN*)
            BEGIN (*PARENTHESE*)
            IF variant_level = 0 THEN
                BEGIN
                oldspacesmark := spaces;
                IF NOT oldspaces THEN
                    setlastspaces (spaces);
                spaces := lastspaces + bufferptr - buffmark - 2;
                (*SKIP STUFF UNTIL WE SEEM TO BE OUT OF THE EXPRESSION*)
                IF declaring THEN
                    REPEAT
                        insymbol;
                        CASE syty OF
                            colon: declaring := false;
                            semicolon: declaring := true;
                            END;
                    UNTIL syty IN [externsy..rparent,labelsy..typesy,initprocsy
..exitsy,dosy..forwardsy]
                ELSE
                    REPEAT
                        insymbol
                    UNTIL syty IN [externsy..rparent,labelsy..typesy,initprocsy
..exitsy,dosy..forwardsy];
                spaces := oldspacesmark;
                oldspaces := true;
                IF syty = which THEN
                    insymbol
                ELSE
                    error(missgrpar);
                END;
            END (*PARENTHESE*) ;
            (*DOCOMMENT*) (*]INSYMBOL*)


        PROCEDURE docomment (dellength: integer; firstch, secondch: char;
cleaning: boolean);
##        var temposp : boolean ;

            PROCEDURE expand (here: integer; firstch, secondch: char);
                VAR
                    i: integer;

                BEGIN (*EXPAND*)
                bufferptr := here + 2;
                bufflen := bufflen + 1;
                FOR i := bufflen + 1 DOWNTO here + 2 DO
                    buffer [i] := buffer [i-1];
                buffer [here] := firstch;
                buffer [here + 1] := secondch;
                END (*EXPAND*);
            PROCEDURE dumpit;
                VAR i: integer;
                BEGIN
                write (tty, '<');
                FOR i := 1 TO bufflen DO
                    write (tty, buffer[i]);
                writeln (tty);
                writeln (tty,'<',' ':bufferptr -1, '@');
                END;

            BEGIN (* DOCOMMENT *)
            oldspacesmark := spaces;
            IF oldspaces THEN
                spaces := lastspaces
            ELSE
                lastspaces := spaces;
            spaces := spaces + bufferptr - 1;
            oldspaces := true;
            IF dellength = 2 THEN
                BEGIN
                IF cleaning THEN BEGIN
                    buffer [bufferptr - 1] := '(';
                    buffer [bufferptr] := '*';
                    END;
##              readbuffer ;  flagger[bufferptr] := comcase ; readbuffer ;
                (* skip over comment beginning bracket *)
##              if ch = '%' then
##              REPEAT  readbuffer;  flagger[bufferptr] := comcase;
##                IF ch <> '*' THEN
##                  BEGIN
##                  IF ch = 'X' THEN
##                    BEGIN readbuffer;  crossing := ch = '+'  END
##                  ELSE IF ch = 'F' THEN
##                    BEGIN readbuffer; renewing := ch = '+';  END
##                  ELSE IF ch = 'R' THEN
##                    BEGIN readbuffer; rescase := ch = '+' END
##                  ELSE IF ch = 'C' THEN
##                    BEGIN  readbuffer ;  comcase := ch = '+' ;  END
##                  ELSE IF ch = 'N' THEN
##                    BEGIN  readbuffer ;  nestcomments := ch ='+'  END
##                  ELSE IF ch='I' THEN
##                    BEGIN  readbuffer ;  nonrcase := ch = '+' END
##                  (*ELSE IF ch = 'S' THEN
##                      BEGIN  readbuffer ;  SAVEREGS := ch <> '-'  END
##                      ELSE IF ch = 'F' THEN
##                      BEGIN readbuffer ;  SAVEFPRS := ch <> '-' ;
##                      END  *) ;
##                  readbuffer
##                END
##              UNTIL ch <> ',' ;
##
##          (*  REPEAT   *)
##              WHILE NOT((ch = secondch) AND (buffer[bufferptr-2] = firstch)
##                        OR eob)  DO
##                  begin
##                  if nestcomments then
##                    if (ch = '(') and (buffer[bufferptr] = '*') then
##                      begin
##                      temposp := oldspaces ;
##                      docomment(2, '*', ')', false) ;
##                      oldspaces := temposp;
##                      readbuffer;
##                      end;
##
                    flagger[bufferptr]:=comcase;
                    readbuffer;
##
##                  end (* while .. *) ;
##          (*  UNTIL (ch = secondch) AND (buffer[bufferptr-2] = firstch) OR eob
;           *)
                IF cleaning THEN
                    BEGIN
                    buffer [bufferptr - 2] := '*';
                    buffer [bufferptr - 1] := ')';
                    END;
                END
            ELSE
                BEGIN
                IF cleaning THEN
                    expand (bufferptr - 1,'(','*');
                REPEAT
                    flagger[bufferptr]:=comcase;
                    readbuffer;
                UNTIL (ch = firstch) OR eob;
                IF cleaning THEN
                    expand (bufferptr - 1, '*', ')');
                END;
            spaces := oldspacesmark;
            oldspaces := true;
            END (*DOCOMMENT*);

        BEGIN (*INSYMBOL*)
        syleng := 0;
       "WHILE (ch IN ['_', '(', ' ', '$', '?', '!', '@', '%', '/', '\']) AND NOT
 eob  DO"
###     WHILE ((delsy[ch] in [spacech, dquotech, skipch, lparent])
###           AND (NOT eob)) DO
##   (* WHILE  ( (ch = '_') OR (ch = '(') OR (ch = ' ') OR (ch = '$') OR
##              (ch = '?') OR (ch = '!') OR (ch = '@') OR (ch = '%') OR
##              (ch = '/') OR (ch = '\') OR (ch = '#') OR (ch = '"') )
##              AND (NOT eob)  DO  *)
            BEGIN
            IF (ch = '(') AND (buffer[bufferptr] = '*') THEN
                docomment (2,'*',')', false)
            ELSE
##           (* IF (ch = '/') AND (buffer[bufferptr] = '*') THEN
                    docomment (2,'*','/',cleaning)
##              ELSE   *)
##                  IF ch = '"' then  docomment(1, '"', ' ', cleaning)
##                  ELSE  IF ch = '#' THEN buffer[bufferptr-1] := ' '
##                  (*ELSE
                    IF ch = '%' THEN
##                    IF   (buffer[bufferptr] >= '0') AND
##                         (buffer[bufferptr] <= '9') then
                            if anyversion OR (ord(buffer[bufferptr]) - ord ('0')
 = goodversion) then
                                bufferptr := bufferptr + 1
                            else
                                docomment (1,'\','\',cleaning)
                        else
##                      docomment (1,'\','\',cleaning)    *)
##                  ELSE  IF ch = '#' THEN buffer[bufferptr-1] := ' '
                    ELSE
##                      IF (ch = '(') (* OR (ch = '/') *) THEN
                            GOTO 1;
            readbuffer;
            END;
##    " CASE ch OF
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I',
            'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
            'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
##          'Z':"
##   (*  IF (ch >= 'A') AND (ch <= 'Z')  THEN  *)
###
###    CASE delsy[ch] OF
###
###    letterup, letterlo :
              BEGIN
              syleng := 0;
              sy := '          ';
              REPEAT
                  syleng := syleng + 1;
                  IF syleng <= 10 THEN
                      sy [syleng] := ch;
                  readbuffer;
##       (*   UNTIL NOT (((ch >= '0') AND (CH <= '9')) OR
##                      ((ch >= 'A') AND (ch <= 'Z')) OR (ch = '_'));*)
###           UNTIL NOT(delsy[ch] IN [letterup, letterlo, digit,
###                                   dollarch, undsch]) ;
              IF NOT resword THEN
                  BEGIN
                  syty := ident ;
##                findname"(curproc)";
                  END
##            END ;
##    (* ELSE IF  (ch >= '0') AND (ch <= '9') THEN *)
##        " '0', '1', '2', '3', '4', '5', '6', '7', '8',
            '9':"

##          digit :
              BEGIN
              REPEAT
                  syleng := syleng + 1;
                  readbuffer;
              UNTIL NOT (('0' <= ch) AND (ch <= '9'));
              syty := intconst;
              IF ch = 'B' THEN
                  BEGIN
                  flagger[bufferptr-1]:=true;
                  readbuffer;
                  END
              ELSE
                  BEGIN
                  IF ch = '.' THEN
                      BEGIN
                      REPEAT
                          readbuffer
                      UNTIL NOT (('0' <= ch) AND (ch <= '9'));
                      syty := othersy; syleng := 0; (*REALS CAN'T BE LABELS*)
                      END;
                  IF ch = 'E' THEN
                      BEGIN
                      readbuffer;
                      IF (ch = '+') OR (ch = '-') THEN
                          readbuffer;
                      WHILE ('0' <= ch) AND (ch <= '9') DO
                          readbuffer;
                      syty := othersy; syleng := 0; (*REALS CAN'T BE LABELS*)
                      END;
                  END;
##            END  ;
##     (* ELSE IF ch = ''''  THEN  *)
###       quotech :
               BEGIN
               syty := strgconst;
               REPEAT
###             (* flagger[bufferptr]:=strcase; *)
###                (*this ensures that Strings will not be up/low shifted*)
###                flagger[bufferptr]:= delsy[buffer[bufferptr]] = letterup ;
                   readbuffer;
               UNTIL (ch = '''') OR eob OR eoline;
               IF ch <> '''' THEN
                   error(missgquote);
               readbuffer;
##             END ;
##    (*  ELSE IF ch = '"' THEN
              BEGIN
              REPEAT
                  readbuffer
##            UNTIL NOT ((ch >= '0') AND (ch <= '9')) "(digits + ['A'..'F']))";
              syty := intconst;
##            END     *)
##     (* ELSE IF ch = ' ' THEN *)

###    spacech : syty := eobsy ;   (*END OF FILE*)
##     (* ELSE   *)  (*OTHERS*)

###    othersy, lparent, rparent, lbracket, rbracket,
###    semicolon, point, colon, eqlsy :
                 BEGIN
        1:
                 syty := delsy [ch];
                 readbuffer;
                 IF (syty = colon) AND (ch = '=') THEN
                     BEGIN
                     workcall := NIL;
                     syty := othersy;
                     readbuffer;
                     END
                 ELSE
                     IF syty IN [lparent, lbracket] THEN
                         IF syty = lparent THEN
                             parenthese (rparent)
                         ELSE
                             parenthese (rbracket);
                 END ;
##            END;  (* CASE delsy[ch] OF *)
        IF workcall <> NIL THEN
            insertcall;
        END (*INSYMBOL*) ;

        (*"PARSING" PROCEDURES:*) (*RECDEF[*) (*CASEDEF*) (*PARENTHESE*) (*]*)

    PROCEDURE recdef;
        VAR
            oldspacesmark  : integer;         (*ALTER ZEICHENVORSCHUB BEI FORMAT
IERUNG VON RECORDS*)


        PROCEDURE casedef;
            VAR
                oldspacesmark  : integer;       (*ALTER ZEICHENVORSCHUB BEI FORM
ATIERUNG VON VARIANT PARTS*)


            PROCEDURE parenthese;
                (*HANDLES THE FORMATTING OF PARENTHESES INSIDE VARIANT PARTS*)
                VAR
                    oldspacesmark : integer;      (*SAVED VALUE OF 'SPACES'*)
                BEGIN (*PARENTHESE*)
                oldspacesmark := spaces;
                IF NOT oldspaces THEN
                    setlastspaces (spaces);
                spaces := spaces + bufferptr - 2;
                declaring := true;
                insymbol;
                REPEAT
##              IF  NOT (syty IN [casesy, recordsy, semicolon, lparent,
##                           eqlsy, colon])  THEN  insymbol
##              ELSE
                    CASE syty OF
                        casesy  : casedef;
                        recordsy : recdef;
                        semicolon, lparent:
                                         BEGIN
                                         declaring := true;
                                         insymbol;
                                         END;
                        eqlsy, colon:
                                   BEGIN
                                   declaring := false;
                                   insymbol;
                                   END;
##                     "OTHERS:  insymbol"
                        END;
                    (*UNTIL WE APPARENTLY LEAVE THE DECLARATION*)
                UNTIL syty IN [strgconst..whilesy,rparent,labelsy..exitsy,dosy..
beginsy,
                               loopsy..forwardsy];
                spaces := oldspacesmark;
                oldspaces := true;
                IF syty = rparent THEN
                    insymbol
                ELSE
                    error(missgrpar);
                END (*PARENTHESE*) ;

            BEGIN (*CASEDEF*)
            variant_level := variant_level+1;
            oldspacesmark := spaces;
            IF NOT oldspaces THEN
                setlastspaces (spaces);
            spaces := bufferptr - buffmark + lastspaces - syleng + 3;
            declaring := true;
            insymbol;
            declaring := false;
            REPEAT
                IF syty = lparent THEN
                    parenthese
                ELSE
                    insymbol
            UNTIL syty IN [untilsy..exitsy,labelsy..endsy,rparent,dosy..beginsy]
;
            spaces := oldspacesmark;
            variant_level := variant_level-1;
            END (*CASEDEF*) ;

        BEGIN (*RECDEF*)
        oldspacesmark := spaces;
        setlastspaces(spaces);
        spaces := bufferptr - buffmark + spaces - syleng - 2 + feed;
        declaring := true;
        insymbol;
        REPEAT
##          IF  NOT(syty IN [casesy, recordsy, semicolon, lparent,
##                       eqlsy, colon])  THEN  insymbol
##          ELSE
            CASE syty OF
                casesy   : casedef;
                recordsy : recdef;
                semicolon, lparent:
                                 BEGIN
                                 declaring := true;
                                 insymbol;
                                 END;
                eqlsy, colon:
                           BEGIN
                           declaring := false;
                           insymbol;
                           END;
##            " OTHERS   : insymbol "
                END;
        UNTIL syty IN [untilsy..exitsy,labelsy..endsy,dosy..beginsy];
        oldspaces := true;
        lastspaces := spaces - feed;
        spaces := oldspacesmark;
        IF syty = endsy THEN
            begin
            declaring := true;
            insymbol;
            end
        ELSE
            error(missgenduntil);
        END (*RECDEF*) ;
        (*STATEMENT[*) (*AND ITS PARTS*) (*]*)


    PROCEDURE statement;
        VAR
            oldspacesmark,           (*SPACES AT ENTRY OF THIS PROCEDURE*)
            curblocknr : integer;     (*CURRENT BLOCKNUMBER*)


        PROCEDURE endedstatseq(endsym: symbol;  markch: char);
            BEGIN
            statement;
            WHILE syty = semicolon DO
                BEGIN
                insymbol;
                statement;
                END;
            WHILE NOT (syty IN [endsym,eobsy,proceduresy,functionsy]) DO
                BEGIN
                error(enderrinblkstr);
                IF NOT (syty IN begsym) THEN
                    insymbol;
                statement;
                WHILE syty = semicolon DO
                    BEGIN
                    insymbol;
                    statement;
                    END;
                END;
            IF forcing THEN
                writeline(bufferptr-syleng);
            emarktext := markch;
            emarknr := curblocknr;
            IF (endsym = endsy) THEN
                IF indentbegin = 0 THEN
                    setlastspaces(spaces-begexd)
                ELSE
                    setlastspaces(spaces-indentbegin)
            ELSE
                setlastspaces(spaces - feed);
            IF syty <> endsym THEN
                error(missgenduntil);
            END (*ENDEDSTATSEQ*);


        PROCEDURE compstat;
            BEGIN (*COMPSTAT*)
            IF indentbegin = 0 THEN
                IF NOT oldspaces THEN
                    setlastspaces (spaces-begexd)
                ELSE
                    IF NOT oldspaces THEN
                        setlastspaces (spaces - indentbegin);
            bmarktext := 'B';
            insymbol;
            IF forcing THEN
                writeline(bufferptr-syleng);
            endedstatseq(endsy, 'E');
            IF syty = endsy THEN
                BEGIN
                insymbol ;
                writeline(bufferptr-syleng);
                END;
            END (*COMPSTAT*) ;


        PROCEDURE casestat;
            LABEL 333 ;
            VAR
                oldspacesmark : integer;        (*SAVED VALUE OF 'SPACES'*)

            BEGIN (*CASESTAT*)
            bmarktext := 'C';
            IF NOT oldspaces THEN
                setlastspaces (spaces-feed);
            insymbol;
            statement;
            IF syty = ofsy THEN
                writeline (bufferptr)
            ELSE
                error (missgof);
##        " LOOP " REPEAT
                REPEAT
                    REPEAT
                        insymbol
                    UNTIL syty IN [colon,functionsy..eobsy];
                    IF syty = colon THEN
                        BEGIN
                        oldspacesmark := spaces;
                        lastspaces := spaces;
                        spaces := bufferptr - buffmark + spaces - 4;
                        oldspaces := true;
                        thendo := true;
                        insymbol;
                        statement;
                        spaces := oldspacesmark;
                        END;
                UNTIL syty IN endsym;
##        " EXIT"IF syty IN [endsy,eobsy,proceduresy,functionsy] THEN GOTO 333;
                error (enderrinblkstr);
##              UNTIL FALSE "END";
##        333:
            writeline(bufferptr-syleng);
            emarktext := 'E';
            emarknr := curblocknr;
            IF syty = endsy THEN
                BEGIN
                insymbol ;
                writeline(bufferptr-syleng);
                END
            ELSE
                error (missgenduntil);
            END (*CASESTAT*) ;


        PROCEDURE loopstat;
            BEGIN (*LOOPSTAT*)
            bmarktext := 'L';
            IF NOT oldspaces THEN
                setlastspaces (spaces - feed);
            insymbol;
            writeline(bufferptr-syleng);
            statement;
            WHILE syty = semicolon DO
                BEGIN
                insymbol;
                statement;
                END;
            IF syty = exitsy THEN
                BEGIN
                writeline(bufferptr-syleng);
                oldspaces := true;
                lastspaces := spaces-feed;
                emarktext := 'X';
                emarknr := curblocknr;
                insymbol; insymbol;
                END
            ELSE
                error(missgexit);
            endedstatseq(endsy, 'E');
            IF syty = endsy THEN
                BEGIN
                insymbol ;
                writeline(bufferptr-syleng);
                END;
            END (*LOOPSTAT*) ;


        PROCEDURE ifstat;
            VAR
                oldspacesmark: integer;

            BEGIN
            oldspacesmark := spaces;
            bmarktext := 'I';
            IF NOT oldspaces THEN
                setlastspaces (spaces - feed);
            (*DON'T INDENT THE 'IF'*)
            (*MAKE 'THEN' AND 'ELSE' LINE UP WITH 'IF' UNLESS ON SAME LINE*)
            spaces := lastspaces + bufferptr - buffmark + feed - 4;
            insymbol;
            statement; (*WILL EAT THE EXPRESSION AND STOP ON A KEYWORD*)
            IF syty = thensy THEN
                BEGIN
                IF NOT oldspaces THEN
                    setlastspaces (spaces-feed);
                emarktext := 'T';
                emarknr := curblocknr;
                IF forcing THEN
                    writeline(bufferptr)
                ELSE
                    thendo := true;
                (*SUPPRESS FURTHER INDENTATION FROM A 'DO'*)
                insymbol;
                statement;
                END
            ELSE
                error (missgthen);
            IF syty = elsesy THEN
                BEGIN
                writeline(bufferptr-syleng);
                emarktext := 'S';
                emarknr := curblocknr;
                IF NOT oldspaces THEN
                    setlastspaces (spaces-feed);
                IF forcing THEN
                    writeline(bufferptr)
                ELSE
                    thendo := true;
                insymbol;
                statement;
                END;
            oldspaces := true; (*PRESERVE INDENTATION OF STATEMENT*)
            writeline(bufferptr-syleng);
            spaces := oldspacesmark;
            END (*IFSTAT*) ;


        PROCEDURE labelstat;
            BEGIN (*LABELSTAT*)
            lastspaces := level * feed;
            oldspaces := true;
            insymbol;
            writeline(bufferptr-syleng);
            END (*LABELSTAT*) ;


        PROCEDURE repeatstat;
            BEGIN
            bmarktext := 'R';
            IF NOT oldspaces THEN
                setlastspaces (spaces - feed);
            insymbol;
            endedstatseq(untilsy, 'U');
            IF syty = untilsy THEN
                BEGIN
                insymbol;
                statement;
                writeline(bufferptr-syleng);
                END;
            END (*REPEATSTAT*) ;

        BEGIN (*STATEMENT*)
        oldspacesmark := spaces; (*SAVE THE INCOMING VALUE OF SPACES TO BE ABLE
TO RESTORE  IT*)
        IF syty = intconst THEN
            BEGIN
            insymbol;
            IF syty = colon THEN
                labelstat;
            END;
        IF syty IN begsym THEN
            BEGIN
            blocknr := blocknr + 1;
            curblocknr := blocknr;
            bmarknr := curblocknr;
            IF NOT thendo THEN
                BEGIN
                writeline(bufferptr-syleng);
                IF (syty <> beginsy) THEN
                    spaces := spaces + feed
                ELSE
                    spaces:=spaces + indentbegin;
                END;
            CASE syty OF
                beginsy : compstat;
                loopsy  : loopstat;
                casesy  : casestat;
                ifsy    : ifstat;
                repeatsy: repeatstat
                END;
            END
        ELSE
            BEGIN
            IF forcing THEN
                IF syty IN [forsy,whilesy] THEN
                    writeline(bufferptr-syleng);
            IF syty = gotosy THEN
                gotoinline:=true;
            WHILE NOT (syty IN [semicolon,functionsy..recordsy]) DO
                insymbol;
            IF syty = dosy THEN
                BEGIN
                IF NOT thendo THEN
                    BEGIN
                    setlastspaces(spaces);
                    spaces := spaces + feed;
                    IF NOT forcing THEN
                        thendo := true;
                    END;
                insymbol;
                statement;
                writeline(bufferptr-syleng);
                END;
            END;
        spaces := oldspacesmark;
        END (*STATEMENT*) ;

        (*]BLOCK*)

    BEGIN (*BLOCK*)
    REPEAT
        insymbol
    UNTIL syty IN relevantsym;
    level := level + 1;
    curproc := listptr;
    spaces := level * feed;
    (*HANDLE NESTING LIST*)
    locprocstl := procstrucf;
##IF procstrucdata.exists then      (*** BUG 2 ***)
    WITH procstrucdata, item, procname@ DO
##    (*IF exists THEN*)
            BEGIN
            IF procdata <> NIL THEN
                BEGIN
                IF externflag = 'F' THEN
                    procdata := NIL
                ELSE
                    IF externflag = ' ' THEN
                        externflag := 'D';
                locprocstl := procdata;
                END;
            IF procdata = NIL THEN
                BEGIN
                IF (syty IN [forwardsy,externsy]) THEN
                    IF syty = externsy THEN
                        externflag := 'E'
                    ELSE
                        externflag := 'F';
                new(procstrucl@.nextproc);
                procstrucl := procstrucl@.nextproc;
                procdata := procstrucl;
                procstrucl@ := item;
                locprocstl := procstrucl;
                END;
            procstrucdata.exists := false
            END;
    REPEAT
        fwddecl := false;
        WHILE syty IN decsym DO
            BEGIN
            writeline(bufferptr-syleng);
            setlastspaces(spaces-feed);
            IF syty = programsy THEN
                BEGIN
                insymbol;
                prog_name := sy;
                procstrucf@.procname := listptr;
                listptr@.procdata := procstrucf;
                listptr@.profunflag := 'M';
                writeln(tty);
                write(tty,'1', version:8,new_name:7,' [',prog_name,']  1..');
                IF pagecnt > 1 THEN
                    FOR i := 2 TO pagecnt DO
                        write (tty, i:3,'..');
##               (* break(tty); *)
                declaring := false;
                END
            ELSE
                BEGIN
                declaring := true;
                IF forcing THEN
                    writeline(bufferptr);
                END;
            REPEAT
                insymbol;
                CASE syty OF
                    semicolon, lparent : declaring := true;
                    eqlsy, colon : declaring := false;
                    recordsy: recdef;
                    END;
            UNTIL syty IN relevantsym;
            END;
        WHILE syty IN prosym DO
            BEGIN
            writeline(bufferptr-syleng);
            setlastspaces(spaces-feed);
            IF syty <> initprocsy THEN
                BEGIN
                itisaproc := syty = proceduresy;
                declaring := true;
                insymbol;
                IF itisaproc THEN
                    listptr@.profunflag := 'P'
                ELSE
                    listptr@.profunflag := 'F';
                WITH procstrucdata, item DO
                    BEGIN
                    exists := true;
                    procname := listptr;
                    nextproc := NIL;
                    linenr := linecnt+1;
                    pagenr := pagecnt;
                    proclevel := level;
                    printed := false;
                    firstcall := NIL;
                    END;
                END;
            block;
            IF syty = semicolon THEN
                insymbol;
            END;
        (*FORWARD AND EXTERNAL DECLARATIONS MAY COME BEFORE 'VAR', ETC.*)
    UNTIL NOT fwddecl;
    IF forcing THEN
        writeline(bufferptr-syleng);
    level := level - 1;
    spaces := level * feed;
    IF NOT (syty IN [beginsy,forwardsy,externsy,eobsy,langsy]) THEN
        BEGIN
        IF (level = 0) AND (syty = point) THEN
            nobody := true
        ELSE
            error (begerrinblkstr);
        WHILE NOT (syty IN [beginsy,forwardsy,externsy,eobsy,langsy,point]) DO
            insymbol
        END;
    IF syty = beginsy THEN
        BEGIN
        declaring := false;
        locprocstl@.begline := linecnt + 1;
        locprocstl@.begpage := pagecnt;
        statement;
        locprocstl@.endline := linecnt + 1;
        locprocstl@.endpage := pagecnt;
        END
    ELSE
        IF NOT nobody THEN
            BEGIN
            fwddecl := true;
            insymbol;
            IF syty = langsy THEN
                insymbol
            END;
    IF programpresent AND (level = 0) THEN
        BEGIN
        IF nobody THEN
            BEGIN
            error (missgmain);
            errcount := errcount - 1;
            END;
        IF syty <> point THEN
            BEGIN
            error(missgpoint);
            REPEAT (*SKIP TEXT UNTIL END OF FILE OR END OF PROGRAM HIT*)
                REPEAT
                insymbol UNTIL (syty = endsy) OR (syty = eobsy);
                IF syty = endsy THEN
                    insymbol;
            UNTIL (syty = point) OR (syty = eobsy);
            END;
        writeline(bufflen+2);
        writeln(tty);
        writeln(tty);
##      writeln (tty,errcount:4,' ERROR(S) DETECTED');    (* break(tty); *)
        END;
    END (*BLOCK*) ;

PROCEDURE print_xref_list;
    VAR
        pred : listptrty;
        indexch : char;         (*LAUFVARIABLE FUER DAS FELD 'FIRSTNAME' ZUM AUS
DRUCKEN*)
        listpgnr : boolean;     (*TRUE IF THE SOURCE CONTAINS A PAGE MARK*)
        itemlen: integer;        (*LENGTH OF A PRINTED LINENUMBER, 9 OR 12*)
        thiscall : calledty;
        oldcrossing: boolean;


    PROCEDURE checkpage(heading: boolean);
        BEGIN
        IF reallincnt = maxline THEN
            BEGIN
            IF heading THEN
                header (listptr@.name)
            ELSE
                header (blanks);
            END;
        reallincnt:=reallincnt+1;
        END(*CHECKPAGE*);

    PROCEDURE writeprocname (procstrucl: procstructy; depth: integer; mark: char
; numbering: boolean);
        BEGIN (*WRITEPROCNAME*)
        writeln(crosslist);
        checkpage(false);
        WITH procstrucl@, procname@ DO
            BEGIN
            IF numbering THEN
##              write (crosslist, linecnt * increment:6, '  ')
##          ELSE write(crosslist, linenr*increment:6, '  ') ;
##       (* IF depth > 2 THEN
                write (crosslist, '. ',dots:depth-2)
            ELSE
##              write (crosslist, '.':depth);  *)
##          write  (crosslist, ' ': depth*3, name: 10, ' ':25-depth*3,
                    ' (', profunflag, ')', mark:2, externflag:2
##                  ",chr(ht), linenr * increment : 8");
##          IF numbering then  write(crosslist, linenr*increment:10) ;
            IF listpgnr OR (pagenr > 1) THEN
                write(crosslist, ' / ',pagenr : 1);
            IF (mark = ' ') AND NOT ((externflag = 'E') OR
##                                   (externflag = 'F')) THEN
                BEGIN
                write (crosslist, begline * increment: 10);
                IF listpgnr THEN
                    write (crosslist, ' / ', begpage: 1);
##              write (crosslist, endline * increment: 7);
                IF listpgnr THEN
                    write (crosslist, ' / ', endpage:1);
                END;
            END;
        END (*WRITEPROCNAME*);

    PROCEDURE writelinenr (spaces : integer);

        VAR
            link : lineptrty; (*ZEIGER ZUM DURCHHANGELN DURCH DIE VERKETTUNG DER
 ZEILENNUMMERN*)
            maxcnt,             (*MAXIMUM ALLOWABLE VALUE OF COUNT*)
            count : integer;  (*ZAEHLT DIE GEDRUCKTEN ZEILENNUMMERN PRO ZEILE*)
        BEGIN (*WRITELINENR*)
        count := 0;
        maxcnt := (maxch+20 - spaces) DIV itemlen; (*ITEMS ARE ITEMLEN CHARS EAC
H*)
        link := listptr@.first;
        REPEAT
            IF count = maxcnt THEN
                BEGIN
                writeln(crosslist);
                checkpage(true);
                write (crosslist, ' ' : spaces);
                count := 0;
                END;
            count := count + 1;
            write (crosslist, link@.linenr * increment : 6);
            IF listpgnr THEN
                write(crosslist, '/',link@.pagenr : 2);
            write (crosslist,link@.declflag,'  ');
            link := link@.contlink;
        UNTIL link = NIL;
        END (*WRITELINENR*) ;

    PROCEDURE dumpcall (thisproc: procstructy; depth: integer);
        VAR
            thiscall: calledty;

        BEGIN (*DUMPCALL*)
        linecnt := linecnt + 1;
        WITH thisproc@ DO
            IF printed THEN
                writeprocname (thisproc, depth,'*', true)
            ELSE
                BEGIN
                writeprocname (thisproc, depth, ' ', true);
                printed := true;
                linenr := linecnt;
                pagenr := pagecnt;
                thiscall := firstcall;
                WHILE thiscall <> NIL DO
                    BEGIN
##                  dumpcall (thiscall@.whom, depth + "4"1);
                    thiscall := thiscall@.nextcall;
                    END;
                END;
        END (*DUMPCALL*);
        (*]PRINT_XREF_LIST*)

    BEGIN (*PRINT_XREF_LIST*)
    oldcrossing := crossing;
    crossing := true;
    listpgnr := pagecnt > 1;
    IF listpgnr THEN
        itemlen := 12
    ELSE
        itemlen := 9;
    WITH firstname ['M']@ DO  (*DELETE 'MAIN'*)
        IF rlink = NIL THEN
            firstname ['M'] := llink
        ELSE
            BEGIN
            listptr := rlink;
            WHILE listptr@.llink <> NIL DO
                listptr := listptr@.llink;
            listptr@.llink := llink;
            firstname ['M'] := rlink;
            END;
    indexch := 'a';
    WHILE (indexch < 'Z') AND (firstname [indexch] = NIL) DO
        indexch := succ (indexch);
    IF firstname [indexch] <> NIL THEN
        BEGIN
        IF refing THEN
            BEGIN
            pagecnt := pagecnt + 1;
            pagecnt2 := 0;
            header (blanks);
            writeln (crosslist,
                     ' CROSS REFERENCE LISTING OF IDENTIFIERS   ':46) ;
            writeln (crosslist,
                     ' **************************************   ':46) ;
            reallincnt:= reallincnt + 3;
            FOR indexch := indexch TO 'Z' DO
                WHILE firstname [indexch] <> NIL DO
                    BEGIN
                    listptr := firstname [indexch];
                    WHILE listptr@.llink <> NIL DO
                        BEGIN
                        pred := listptr;
                        listptr := listptr@.llink;
                        END;
                    IF listptr = firstname [indexch] THEN
                        firstname [indexch] := listptr@.rlink
                    ELSE
                        pred@.llink := listptr@.rlink;
                    writeln(crosslist);
                    checkpage(true);
                    write (crosslist, listptr@.profunflag, listptr@.name : 11);
                    writelinenr (12);
                    END;
##          writeln(crosslist) ;
            END;

        IF procstrucl <> procstrucf THEN
            BEGIN
            IF decnesting THEN
                BEGIN
                pagecnt := pagecnt + 1;
                pagecnt2 := 0;
                writeln (crosslist);
                header (blanks);
                writeln (crosslist,
                         ' NESTING OF PROCEDURE-FUNCTION DECLARATION':46) ;
                writeln (crosslist,
                         ' *****************************************':46) ;
                writeln (crosslist,
                         ' HEADERLINE, NAME, P/F, BEGINLINE, ENDLINE':46) ;
                reallincnt:= reallincnt + 4;
                procstrucl := procstrucf;
                REPEAT
##                  writeprocname (procstrucl, procstrucl@.proclevel"* 2",' ',
false);
                    procstrucl := procstrucl@.nextproc;
                UNTIL procstrucl = NIL;
                END;
            IF callnesting THEN
                BEGIN
                pagecnt := pagecnt + 1;
                pagecnt2 := 0;
                writeln (crosslist);
                header (blanks);
                writeln (crosslist,
                         ' NESTING OF PROCEDURE-FUNCTION CALLS      ':46);
                writeln (crosslist,
                         ' ***********************************      ':46);
                writeln (crosslist,
                         ' NAME, P/F, HEADLINE, BEGINLINE, ENDLINE  ':46) ;
                reallincnt := reallincnt + 4;
                linecnt := 0;
                procstrucl := procstrucf;
                WHILE procstrucl <> NIL DO
                    BEGIN
                    IF NOT procstrucl@.printed THEN
                        dumpcall (procstrucl, 0);
                    procstrucl := procstrucl@.nextproc;
                    END;
                END;
##          writeln(crosslist) ;
            END;
        END;
    crossing := oldcrossing;
    END (*PRINT_XREF_LIST*) ;

    (*MAIN PROGRAM*)

BEGIN
# RESET(OLDSOURCE) ;
# REWRITE(NEWSOURCE);
# REWRITE(CROSSLIST) ;
# REWRITE(TTY) ;
checkoptions;
##"getstatus(oldsource,new_name,new_prot,new_ppn,new_dev);"

(*FIND MAX POSSIBLE LINE NUMBER WITH THIS INCREMENT*)
##increment := 1 ;
maxinc := (99999 DIV increment);
IF maxinc > 4000 THEN
    maxinc := 4000;

##"LOOP" REPEAT
    init;
    block;
##"EXIT" IF NOT programpresent OR (syty = eobsy) THEN GOTO 444;
    IF refing OR decnesting OR callnesting THEN
        print_xref_list;
##  "dispose(heapmark);"    (*RELEASE THE ENTIRE HEAP*)
    rtime[0]:=clock(1)-rtime[0];
    rtime[1]:=rtime[0] DIV 60000;
    rtime[2]:=(rtime[0] MOD 60000) DIV 1000;
    rtime[3]:=rtime[0] MOD 1000;
    writeln(tty);
    writeln(tty,' RUNTIME:',rtime[1]:3,':',rtime[2]:2,'.',rtime[3]:3);
##   (* break(tty); *)
##  UNTIL FALSE "END";
##  444:
##   (* writeln(tty, bel);   break(tty); *)

##  "getnextcall (link_name, link_device);
##   IF link_name <> '         ' THEN
##     call (link_name, link_device); "
END (*PCROSS*).
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB PEDITOR  EXT PAS HEX -
(*$N+,D-****************************************************************
*                                                                      *
*                                                                      *
*   A LINE EDITOR FOR PASCAL                                           *
*                                                                      *
*       The EDITOR program is a simple text editor that can  insert,   *
*   delete and replace entire lines in a file. PRD is the file to be   *
*   edited,  INPUT  is  the  file  containing  editor  commands. The   *
*   resulting edited file is transmitted to the PRR  file.  Messages   *
*   and a summary of the changes are printed on the OUTPUT file.       *
*       The INPUT file consists of commands and cards to be inserted   *
*   into the PRD  file.  Commands  are  distinguished  by  having  a   *
*   percent  character  in  column  one. Cards that do not have this   *
*   character in column one are automatically inserted.                *
*       There are only four commands. Three of the commands have  an   *
*   operand  consisting  of an arbitrary string of characters. These   *
*   text string operands are "matched" against cards read  from  the   *
*   PRD  file.  The  definition  of  "match" will be given after the   *
*   commands are explained.                                            *
*                                                                      *
*   Find Line Command: %FL <text>                                      *
*       Cards are copied from the PRD file to the PRR  file,  up  to   *
*   and including the first card that "matches" <text>.                *
*                                                                      *
*   Replace Line Command: %RL <text>                                   *
*       Cards are copied fom the PRD file to the PRR file, up to but   *
*   not including the first card that "matches" <text>. That is, the   *
*   card that matches is effectively deleted.                          *
*                                                                      *
*   Delete Lines Command: %DL <text>                                   *
*       Cards are read from the PRD file, up to  and  including  the   *
*   first  card  that  "matches" <text>. These cards are effectively   *
*   deleted because they are not passed on to the PRR file.            *
*                                                                      *
*   End of Editing Command: %END                                       *
*       All remaining cards in the PRD file are copied  to  the  PRR   *
*   file.                                                              *
*                                                                      *
*   The <text> operand of a command "matches" a card read  from  PRD   *
*   if that card begins with the exact same character sequence given   *
*   in  <text>.  Blanks  are  totally  ignored,  in  both the <text>   *
*   operand  and  the  PRD  card,  when   making   the   comparison.   *
*   Furthermore,  some  character  equivalences  are  acceptable (in   *
*   case the INPUT file is entered  from  a  device  that  does  not   *
*   support the special characters). The equivalences are:             *
*       Upper-case letters in INPUT match corresponding                *
*                     lower-case letters in PRD                        *
*       "(/" in INPUT matches "[" (left square bracket) in PRD         *
*       "/)" in INPUT matches "]" (right square bracket) in PRD        *
*       "(*" in INPUT matches "¯" (left brace) in PRD                  *
*       "*)" in INPUT matches "" (right brace) in PRD                 *
*       "" (i.e. nothing) in INPUT matches "#" in PRD                  *
*   It should be noted that these equivalences are defined  to  work   *
*   in one direction only.  That is, a left square bracket in a text   *
*   operand will not match "(/" occurring  in  the  PRD  file.   The   *
*   meaning  of the last equivalence above is that the "#" character   *
*   in the PRD file is ignored if it does not match  a  "#"  in  the   *
*   <text> operand.                                                    *
*       It is an error if no card is found in  PRD  that  matches  a   *
*   <text>  operand. The EDITOR program will print a warning message   *
*   and return a non-zero return code to signal this  event.  It  is   *
*   mandatory  that  the  last  card  in  the  INPUT  file be a %END   *
*   command.                                                           *
*                                                                      *
*         An Example Editing Session                                   *
*                                                                      *
*   1. The Editing Commands in the INPUT file:                         *
*                                                                      *
*       %FL I := I                                                     *
*          J := J + 1;                                                 *
*          K := K + 1;                                                 *
*       %RL A(/K                                                       *
*          A(/K/) := CHR(K);                                           *
*       %FL WRI                                                        *
*       %FL WRI                                                        *
*       %DL CALL                                                       *
*          WRITELN ( 'A3 =', A(/K/) );                                 *
*          EXIT( 10 );                                                 *
*       %END                                                           *
*                                                                      *
*   2. The Contents of the PRD File:                                   *
*                                                                      *
*       PROGRAM NONSENSE( OUTPUT );                                    *
*       VAR I,J,K: INTEGER; A: ARRAY[1..3] OF CHAR;                    *
*       BEGIN                                                          *
*          I := 0; J := 1; K := 2;                                     *
*          I := I + 1;                                                 *
*          A[I] := CHR(I);                                             *
*          A[J] *= CHR(J);                                             *
*          A[K] *= ORD(K);                                             *
*          WRITELN( 'A1 =', A[1] );                                    *
*          WRITELN( 'A2 =', A[2] );                                    *
*          WRITELN( 'A3 =', A[3] );                                    *
*          CALL EXIT(10);                                              *
*       END.                                                           *
*                                                                      *
*   3. Resulting Output to PRR File:                                   *
*                                                                      *
*       PROGRAM NONSENSE( OUTPUT );                                    *
*       VAR I,J,K: INTEGER; A: ARRAY[1..3] OF CHAR;                    *
*       BEGIN                                                          *
*          I := 0; J := 1; K := 2;                                     *
*          I := I + 1;                                                 *
*          J := J + 1;                                                 *
*          K := K + 1;                                                 *
*          A[I] := CHR(I);                                             *
*          A[J] := CHR(J);                                             *
*          A(/K/) := CHR(K);                                           *
*          WRITELN( 'A1 =', A[1] );                                    *
*          WRITELN( 'A2 =', A[2] );                                    *
*          WRITELN( 'A3 =', A(/K/) );                                  *
*          EXIT( 10 );                                                 *
*       END.                                                           *
*                                                                      *
*   Comments:                                                          *
*       As can be seen in the example, %FL is used to search through   *
*   the PRD file. When there are many lines in PRD that  begin  with   *
*   similar text, two or more %FL commands can be used successively.   *
*   Generally,  %FL  is used to locate a position at which cards are   *
*   to be inserted or from which lines are to be deleted.              *
*       %RL is actually a redundant command  -  its  effect  can  be   *
*   obtained   with  %FL  and  %DL  commands.  However  it  is  most   *
*   convenient when a single line in PRD is to be deleted or  to  be   *
*   replaced  by  one  or  more  cards from INPUT. It should also be   *
*   apparent from the command descriptions that the commands must be   *
*   presented in  the  correct  order.  I.e.,  all  the  editing  is   *
*   performed in a single pass through PRD.                            *
*                                                                      *
*                                                                      *
*                                      R. Nigel Horspool               *
*                                                                      *
*                                      School of Computer Science      *
*                                      McGill University               *
*                                                                      *
*                                                                      *
***********************************************************************)


PROGRAM EDITOR(INPUT,OUTPUT,PRD,PRR);
CONST   CARDLEN = 80;
        CONTROL = '%';

TYPE    CARD = ARRAY(/ 1 .. CARDLEN /) OF CHAR;
        CHAR_TYPE = (NULL,LOWER_CASE,LSQ,RSQ,LBRACE,RBRACE,SHARP);

VAR     SOURCE, EDITS : CARD;
        CLASS :         ARRAY(/CHAR/) OF CHAR_TYPE;
        EOF_OK        : BOOLEAN;
        ERRS, INNUM, OUTNUM, PATLEN : INTEGER;

FUNCTION MATCH: BOOLEAN;
  LABEL 10;
  VAR   IX1, IX2: INTEGER;
        CH1, CH2: CHAR;
  BEGIN
    MATCH := FALSE;  IX1 := 1;  IX2 := 4;
    REPEAT
       CH1 := SOURCE(/IX1/);  CH2 := EDITS(/IX2/);
       IF CH2 = ' ' THEN IX2 := IX2 + 1
       ELSE IF CH1 = ' ' THEN IX1 := IX1 + 1
       ELSE BEGIN
          IF CH1 <> CH2 THEN
             CASE CLASS(/CH1/) OF
    LOWER_CASE:  IF (ORD(CH2)-ORD(CH1)) <> 64 THEN GOTO 10;
    LSQ:         IF CH2 <> '(' THEN GOTO 10 ELSE IX2 := IX2 + 1;
    RSQ:         IF CH2 <> '/' THEN GOTO 10 ELSE IX2 := IX2 + 1;
    LBRACE:      IF CH2 <> '(' THEN GOTO 10 ELSE IX2 := IX2 + 1;
    RBRACE:      IF CH2 <> '*' THEN GOTO 10 ELSE IX2 := IX2 + 1;
    SHARP:       IX2 := IX2 - 1;
    NULL:        GOTO 10
             END;
          IX1 := IX1 + 1;  IX2 := IX2 + 1;
       END;
    UNTIL (IX1 > CARDLEN) OR (IX2 > PATLEN);
    IF IX2 > PATLEN THEN MATCH := TRUE;
10:
  END (* MATCH *) ;

PROCEDURE INITIALIZE;
VAR C : CHAR;
BEGIN
   FOR C := CHR(0) TO CHR(255) DO CLASS(/C/) := NULL;
   FOR C := 'a' TO 'i' DO CLASS(/C/) := LOWER_CASE;
   FOR C := 'j' TO 'r' DO CLASS(/C/) := LOWER_CASE;
   FOR C := 's' to 'z' DO CLASS(/C/) := LOWER_CASE;
   CLASS(/ CHR(173) /) := LSQ;     CLASS(/ CHR(189) /) := RSQ;
   CLASS(/ CHR(139) /) := LBRACE;  CLASS(/ CHR(155) /) := RBRACE;
   CLASS(/ '#' /) := SHARP;
END;

BEGIN
  ERRS := 0;  INNUM := 0;  OUTNUM := 0;  EOF_OK := FALSE;
  INITIALIZE;
  REPEAT
    READLN(INPUT,EDITS);
    IF EDITS(/1/) = CONTROL THEN
       BEGIN
          WRITELN();  WRITELN(' %% CONTROL CARD : ', EDITS );
          PATLEN := CARDLEN;
          WHILE EDITS(/PATLEN/) = ' ' DO PATLEN := PATLEN - 1;
          IF EDITS(/2/) = 'D' THEN  (* DL COMMAND *)
             REPEAT
                READLN(PRD,SOURCE);  INNUM := INNUM + 1;
                WRITELN(' -- DELETED  (',INNUM:5,') ------- Ý',
                     SOURCE,'Ý --' );
             UNTIL MATCH OR EOF(PRD)
          ELSE IF EDITS(/2/) = 'F' THEN (* FL COMMAND *)
             REPEAT
                READLN(PRD,SOURCE);  INNUM := INNUM + 1;
                WRITE(PRR,SOURCE); OUTNUM := OUTNUM + 1;
             UNTIL MATCH OR EOF(PRD)
          ELSE IF EDITS(/2/) = 'R' THEN (* RL COMMAND *)
             BEGIN
                READLN(PRD,SOURCE);  INNUM := INNUM + 1;
                WHILE NOT MATCH AND NOT EOF(PRD) DO
                   BEGIN
                      WRITE(PRR,SOURCE);  OUTNUM := OUTNUM + 1;
                      READLN(PRD,SOURCE);   INNUM  := INNUM  + 1;
                   END;
                IF NOT EOF(PRD) THEN
                   WRITELN(' -- DELETED  (',INNUM:5,') ------- Ý',
                           SOURCE,'Ý --');
            END
          ELSE IF EDITS(/2/) = 'E' THEN (* END COMMAND *)
             BEGIN
                REPEAT
                   READLN(PRD,SOURCE);  INNUM := INNUM + 1;
                   WRITE(PRR,SOURCE); OUTNUM := OUTNUM + 1;
                UNTIL EOF(PRD);
                EOF_OK := TRUE;
             END
          ELSE BEGIN
             WRITELN(' ***** BAD CONTROL CARD - IGNORED.');
             WRITELN();  ERRS := ERRS + 1;
          END
       END
    ELSE BEGIN  (* INSERTED CODE *)
       WRITE(PRR,EDITS);  OUTNUM := OUTNUM + 1;
       WRITELN(' ++ INSERTED +++++++ (',OUTNUM:5,') Ý',EDITS,'Ý ++' );
    END;
  UNTIL EOF(PRD) OR EOF(INPUT);

  WRITELN();
  IF NOT EOF_OK THEN
     BEGIN
       IF EOF(PRD) THEN
          WRITELN(' ***** LINE PREFIX NOT FOUND IN SOURCE FILE');
       IF EOF(INPUT) THEN
          WRITELN(' ***** MISSING %END CARD IN EDIT FILE');
       ERRS := ERRS + 1;
     END;
  WRITELN;  WRITELN(' * EDITING FINISHED;', INNUM:7, ' CARDS INPUT;',
                     OUTNUM:7, ' CARDS OUTPUT.' );
  EXIT( ERRS );
END.
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB PFORMAT  EXT PAS HEX -
 (*************************************************************
  *                                                           *
  *      P A S C A L   P R O G R A M   F O R M A T T E R      *
  *      -----------------------------------------------      *
  *                                                           *
  *             COPYRIGHT MICHAEL N. CONDICT 1975             *
  *                                                           *
  *************************************************************)
 PROGRAM FORMAT( (*PROG,*) OUTPUT, INPUT );

 CONST
    LASTPSYMBOLNAME = 40;
    BUFFERSIZE = 160;
    BUFFERSZP1 = 161;
    BUFFSZDIV10 = 16;
    ALFLEN = 10;

 TYPE
    chset = 0..63;
    STATMNTTYPES =
       (FORWITHWHILESTATEMENT, REPEATSTATEMENT, IFSTATEMENT,
        CASESTATEMENT, COMPOUNDSTATEMENT, OTHERSTATEMENT);
    SYMBOLS =
       (PROGRAMSYMBOL, COMMENT, BEGINSYMBOL, ENDSYMBOL,
        SEMICOLON, CONSTSYMBOL, TYPESYMBOL, RECORDSYMBOL,
        COLONSYMBOL, EQUALSYMBOL, PERIODSYMBOL, RANGE,
        CASESYMBOL, OTHERSYMBOL, IFSYMBOL, THENSYMBOL,
        ELSESYMBOL, DOSYMBOL, OFSYMBOL, FORSYMBOL, WITHSYMBOL,
        WHILESYMBOL, REPEATSYMBOL, UNTILSYMBOL, IDENTIFIER,
        VARSYMBOL, VALUESYMBOL, PROCEDSYMBOL, FUNCTIONSYMBOL,
        LEFTBRACKET, RIGHTBRACKET, COMMASYMBOL, LABELSYMBOL,
        LEFTPAREN, RIGHTPARENTH, UPARROW, ALPHAOPERATOR);
    WIDTH = 0 .. BUFFERSIZE;
    CHARTYPES =
       (ALPHANUMERIC, ENDOFLINE, BLANK, RIGHTARROW, SLASH,
        LFTPAREN, COLON, PERIOD, STRING, LESSTHAN, GREATERTHAN,
"SZH"   STAR, DQUOTE, OTHER);
    MARGINS = - 100 .. BUFFERSIZE;
    SYMBOLSET = SET OF SYMBOLS;
    OPTIONSIZE = - 99 .. 99;
    COMMENTTEXT = ARRAY [1 .. BUFFSZDIV10] OF ALFA;
    SYMBOLSTRING = ARRAY [WIDTH] OF CHAR;

 VAR
    READINGFORMATOPTIONS, PROGISPASCAL2: BOOLEAN;
    PROG: TEXT;
    I: INTEGER;
 (*USED AS FOR LOOP INDEX*)
    CHARACTER: CHAR;
    READCOLUMN, READCOL2: 0 .. 1000;
    OUTPUTCOL, WRITECOLUMN, LEFTMARGIN, ACTUALLEFTMARGIN:
       MARGINS;
    READCOL1, WRITECOL1, WRITECOL2: MARGINS;
    DISPLAYISON, PROCEDNAMESWANTED, ENDCOMMENTSWANTED,
       PACKERISOFF, SAVEDCOMPRESS, COMPRESSWANTED, NOFORMATTING,
       DISPLAYWANTED, CROSSREFWANTED: BOOLEAN;
    LINENUMBER, INCREMENT: - 999 .. 999;
    INDENTINDEX, LONGLINEINDENT, SYMBOLGAP, DECLARALIGNMENT,
       STATMTSEPARATION, PROCEDSEPARATION: OPTIONSIZE;
    LASTSYMBOL, SYMBOLNAME: SYMBOLS;
    ALPHASYMBOLS, ENDLABEL, ENDCONST, ENDTYPE, ENDVAR, ENDVALUE:
       SYMBOLSET;
    SYMBOL: SYMBOLSTRING;
    LENGTH: WIDTH;
"SZH"  FIRSTDQUOTE,
    SYMBOLISNUMBER, LASTPROGPARTWASBODY: BOOLEAN;
    DIGITS: SET OF CHSET;
    OLDEST: WIDTH;
    CHARCOUNT: INTEGER (* USED AS A TOTAL CHARACTERS COUNT*);
    MAIN: COMMENTTEXT;
    MAINNMLENGTH: WIDTH;
    BLANKS, ZEROES: ALFA;
    UNWRITTEN: ARRAY [WIDTH] OF RECORD
                                   CH: CHAR;
                                   CHISENDLINE: BOOLEAN;
                                   INDENTAFTEREOL: MARGINS;
                                END;
    TYPEOF: ARRAY [CHAR] OF CHARTYPES;
    PASCALSYMBOL: ARRAY [1 .. LASTPSYMBOLNAME] OF ALFA;
    PSYMBOLNAME: ARRAY [1 .. LASTPSYMBOLNAME] OF SYMBOLS;
    NAMEOF: ARRAY [CHAR] OF SYMBOLS;
    STATEMENTTYPEOF: ARRAY [SYMBOLS] OF STATMNTTYPES;
"szh"  CHMAP   : ARRAY [CHAR] OF 0..63  ;  (*CHAR CODE CONVERSION           *)
"szh"  PQ      : INTEGER;


"szh"procedure init_chmap;
"szh"
"szh"   (* this routine initializes the ebcdic to 'CCDC' display code MAP *)
"szh"   (* chmap : array[char] of 0..63                                   *)
"szh"
"szh"   const ordmaxch= 255;
"szh"
"szh"   var ch: char;
"szh"
"szh"   BEGIN
"szh"
"szh"    FOR ch := chr(0) TO chr(ORDMAXCH) DO CHMAP[ch] := 0;
"szh"    FOR CH := 'A' TO 'I' DO  CHMAP[CH] := ORD(CH)-192 ;
"szh"    FOR CH := 'J' TO 'R' DO  CHMAP[CH] := ORD(CH)-199 ;
"szh"    FOR CH := 'S' TO 'Z' DO  CHMAP[CH] := ORD(CH)-207 ;
"szh"    FOR CH := 'a' TO 'i' DO  CHMAP[CH] := ORD(CH)-128 ;
"szh"    FOR CH := 'j' TO 'r' DO  CHMAP[CH] := ORD(CH)-135 ;
"szh"    FOR CH := 's' TO 'z' DO  CHMAP[CH] := ORD(CH)-143 ;
"szh"    FOR CH := '0' TO '9' DO  CHMAP[CH] := ORD(CH)-213 ;
"szh"    CHMAP['+']  :=  37 ;
"szh"    CHMAP['-']  :=  38 ;
"szh"    CHMAP['*']  :=  39 ;
"szh"    CHMAP['/']  :=  40 ;
"szh"    CHMAP['(']  :=  41 ;
"szh"    CHMAP[')']  :=  42 ;
"szh"    CHMAP['$']  :=  43 ;
"szh"    CHMAP['=']  :=  44 ;
"szh"    CHMAP[' ']  :=  45 ;
"szh"    CHMAP[',']  :=  46 ;
"szh"    CHMAP['.']  :=  47 ;
"szh"    CHMAP['#']  :=  48 ;
"szh"    CHMAP['[']  :=  49 ;
"szh"    CHMAP[']']  :=  50 ;
"szh"    CHMAP['%']  :=  51 ;
"szh"    CHMAP['"']  :=  52 ;
"szh"    CHMAP['_']  :=  53 ;
"szh"    CHMAP['¯']  :=  54 ;      (* SHOULD BE '!' *)
"szh"    CHMAP['&']  :=  55 ;
"szh"    CHMAP[''''] :=  56 ;
"szh"    CHMAP['']  :=  57 ;
"szh"    CHMAP['<']  :=  58 ;
"szh"    CHMAP['>']  :=  59 ;
"szh"    CHMAP['@']  :=  60 ;
"szh"    CHMAP[':']  :=  61 ;       (* SHOULD BE '0', 61 IS BACK SLASH *)
"szh"    CHMAP['']  :=  62 ;
"szh"    CHMAP[';']  :=  63 ;
"szh"
"szh"   END (*init_chmap*);
"szh"
 PROCEDURE CONSTANTSINITIALIZATION;

    BEGIN
"SZH"  FIRSTDQUOTE := FALSE;
       MAIN[1] := 'MAIN      ';   MAINNMLENGTH := 4;
       BLANKS := '          ';   ZEROES := '0000000000';
       FOR I := 0 TO BUFFERSIZE DO
          WITH UNWRITTEN[I] DO
             BEGIN
                CH := 'A';   CHISENDLINE := FALSE;
                INDENTAFTEREOL := 0;
             END;
       FOR CHARACTER := CHR(0) TO CHR(255) DO
          TYPEOF[CHARACTER] := OTHER;
       TYPEOF[CHR(0)] := BLANK;
       FOR CHARACTER := 'A' TO 'I' DO
          TYPEOF[CHARACTER] := ALPHANUMERIC;
       FOR CHARACTER := 'J' TO 'R' DO
          TYPEOF[CHARACTER] := ALPHANUMERIC;
       FOR CHARACTER := 'S' TO 'Z' DO
          TYPEOF[CHARACTER] := ALPHANUMERIC;
       FOR CHARACTER := '0' TO '9' DO
          TYPEOF[CHARACTER] := ALPHANUMERIC;
       TYPEOF['*'] := STAR;         TYPEOF['/'] := SLASH;
       TYPEOF['('] := LFTPAREN;     TYPEOF[' '] := BLANK;
       TYPEOF['.'] := PERIOD;       TYPEOF[''''] := STRING;
       TYPEOF[':'] := COLON;
"SZH"  TYPEOF['¯'] := RIGHTARROW;   TYPEOF['"'] := DQUOTE;
"SZH"  TYPEOF['$'] := ALPHANUMERIC; TYPEOF['_'] := ALPHANUMERIC;
"SZH"  TYPEOF['#'] := BLANK;
       TYPEOF['<'] := LESSTHAN;     TYPEOF['>'] := GREATERTHAN;
"SZH"  FOR CHARACTER := CHR(0) TO CHR(255) DO
          NAMEOF[CHARACTER] := OTHERSYMBOL;
       NAMEOF['('] := LEFTPAREN;
       NAMEOF[')'] := RIGHTPARENTH;
       NAMEOF['='] := EQUALSYMBOL;   NAMEOF[','] := COMMASYMBOL;
       NAMEOF['.'] := PERIODSYMBOL;
       NAMEOF['['] := LEFTBRACKET;
       NAMEOF[']'] := RIGHTBRACKET;
       NAMEOF[':'] := COLONSYMBOL;   NAMEOF['@'] := UPARROW;
"SZH"  NAMEOF[''] := COMMENT;   NAMEOF['<'] := EQUALSYMBOL;
"SZH"  NAMEOF['"'] := COMMENT;
       NAMEOF['>'] := EQUALSYMBOL;   NAMEOF[';'] := SEMICOLON;
       PASCALSYMBOL[1] := 'PROGRAM   ';
       PASCALSYMBOL[21] := 'FUNCTION  ';
       PASCALSYMBOL[2] := 'BEGIN     ';
       PASCALSYMBOL[22] := 'LABEL     ';
       PASCALSYMBOL[3] := 'END       ';
       PASCALSYMBOL[23] := 'IN        ';
       PASCALSYMBOL[4] := 'CONST     ';
       PASCALSYMBOL[24] := 'MOD       ';
       PASCALSYMBOL[5] := 'TYPE      ';
       PASCALSYMBOL[25] := 'DIV       ';
       PASCALSYMBOL[6] := 'VAR       ';
       PASCALSYMBOL[26] := 'AND       ';
       PASCALSYMBOL[7] := 'VALUE     ';
       PASCALSYMBOL[27] := 'OR        ';
       PASCALSYMBOL[8] := 'RECORD    ';
       PASCALSYMBOL[28] := 'NOT       ';
       PASCALSYMBOL[9] := 'CASE      ';
       PASCALSYMBOL[29] := 'LT        ';
       PASCALSYMBOL[10] := 'IF        ';
       PASCALSYMBOL[30] := 'LE        ';
       PASCALSYMBOL[11] := 'THEN      ';
       PASCALSYMBOL[31] := 'IS        ';
       PASCALSYMBOL[12] := 'ELSE      ';
       PASCALSYMBOL[32] := 'ISNT      ';
       PASCALSYMBOL[13] := 'DO        ';
       PASCALSYMBOL[33] := 'EQ        ';
       PASCALSYMBOL[14] := 'OF        ';
       PASCALSYMBOL[34] := 'NE        ';
       PASCALSYMBOL[15] := 'FOR       ';
       PASCALSYMBOL[35] := 'GE        ';
       PASCALSYMBOL[16] := 'WHILE     ';
       PASCALSYMBOL[36] := 'GT        ';
       PASCALSYMBOL[17] := 'WITH      ';
       PASCALSYMBOL[37] := 'JOIN      ';
       PASCALSYMBOL[18] := 'REPEAT    ';
       PASCALSYMBOL[38] := 'MEET      ';
       PASCALSYMBOL[19] := 'UNTIL     ';
       PASCALSYMBOL[39] := 'ARRAY     ';
       PASCALSYMBOL[20] := 'PROCEDURE ';
       PASCALSYMBOL[40] := 'NOSYMBOL  ';
       PSYMBOLNAME[1] := PROGRAMSYMBOL;
       PSYMBOLNAME[21] := FUNCTIONSYMBOL;
       PSYMBOLNAME[2] := BEGINSYMBOL;
       PSYMBOLNAME[22] := LABELSYMBOL;
       PSYMBOLNAME[3] := ENDSYMBOL;
       PSYMBOLNAME[4] := CONSTSYMBOL;
       PSYMBOLNAME[5] := TYPESYMBOL;
       PSYMBOLNAME[6] := VARSYMBOL;
       PSYMBOLNAME[7] := VALUESYMBOL;
       PSYMBOLNAME[8] := RECORDSYMBOL;
       PSYMBOLNAME[9] := CASESYMBOL;
       PSYMBOLNAME[10] := IFSYMBOL;
       PSYMBOLNAME[11] := THENSYMBOL;
       PSYMBOLNAME[12] := ELSESYMBOL;
       PSYMBOLNAME[13] := DOSYMBOL;   PSYMBOLNAME[14] := OFSYMBOL;
       PSYMBOLNAME[15] := FORSYMBOL;
       PSYMBOLNAME[16] := WHILESYMBOL;
       PSYMBOLNAME[17] := WITHSYMBOL;
       PSYMBOLNAME[18] := REPEATSYMBOL;
       PSYMBOLNAME[19] := UNTILSYMBOL;
       PSYMBOLNAME[20] := PROCEDSYMBOL;
       PSYMBOLNAME[40] := IDENTIFIER;
       FOR I := 23 TO 39 DO PSYMBOLNAME[I] := ALPHAOPERATOR;
       FOR SYMBOLNAME := PROGRAMSYMBOL TO ALPHAOPERATOR DO
          STATEMENTTYPEOF[SYMBOLNAME] := OTHERSTATEMENT;
       STATEMENTTYPEOF[BEGINSYMBOL] := COMPOUNDSTATEMENT;
       STATEMENTTYPEOF[CASESYMBOL] := CASESTATEMENT;
       STATEMENTTYPEOF[IFSYMBOL] := IFSTATEMENT;
       STATEMENTTYPEOF[FORSYMBOL] := FORWITHWHILESTATEMENT;
       STATEMENTTYPEOF[WHILESYMBOL] := FORWITHWHILESTATEMENT;
       STATEMENTTYPEOF[WITHSYMBOL] := FORWITHWHILESTATEMENT;
       STATEMENTTYPEOF[REPEATSYMBOL] := REPEATSTATEMENT;
    END (*CONSTANTSINITIALIZATION*);

 PROCEDURE WRITEA(CHARACTER: CHAR);

    VAR
       I: WIDTH;
       TESTNO: INTEGER;

    BEGIN
       CHARCOUNT := CHARCOUNT + 1;
       OLDEST := CHARCOUNT MOD BUFFERSIZE;
       WITH UNWRITTEN[OLDEST] DO
          BEGIN
             IF CHARCOUNT > BUFFERSZP1
             THEN
                BEGIN
                   IF CHISENDLINE
                   THEN
                      BEGIN
                         IF INDENTAFTEREOL < 0
                         THEN
                            BEGIN
                               WRITE(OUTPUT, BLANKS: - INDENTAFTEREOL);
                               OUTPUTCOL := OUTPUTCOL -
                                  INDENTAFTEREOL;
                            END
                         ELSE
                            BEGIN
                               IF INCREMENT < 0
                               THEN
                                  BEGIN
                                     I := WRITECOL2 - OUTPUTCOL
                                        + 1;
                                     IF I > 0
                                     THEN WRITE(OUTPUT, BLANKS: I);
                                     TESTNO := LINENUMBER;
                                     I := 0;
                                     REPEAT
                                        TESTNO := TESTNO DIV 10;
                                        I := I + 1;
                                     UNTIL TESTNO = 0;
                                     WRITE(OUTPUT, ZEROES: (6 - I),
                                        LINENUMBER: I);
                                     LINENUMBER := LINENUMBER -
                                        INCREMENT;
                                     IF LINENUMBER > 999999
                                     THEN
                                        LINENUMBER := LINENUMBER
                                           - 1000000;
                                     WRITELN(OUTPUT);  WRITE(OUTPUT, ' ');
                                  END
                               ELSE
                                  BEGIN
                                     WRITELN(OUTPUT, ' '); WRITE(OUTPUT, ' ');
                                     IF INCREMENT > 0 THEN
                                        BEGIN
                                           WRITE(OUTPUT, LINENUMBER: (
                                              WRITECOL1 - 2));
                                           INDENTAFTEREOL :=
                                              INDENTAFTEREOL -
                                              WRITECOL1 + 2;
                                           LINENUMBER :=
                                              LINENUMBER +
                                              INCREMENT;
                                        END
                                  END;
                               IF INDENTAFTEREOL > 0 THEN
                                  WRITE(OUTPUT, BLANKS: INDENTAFTEREOL);
                               OUTPUTCOL := INDENTAFTEREOL + 1;
                            END;
                         CHISENDLINE := FALSE;
                      END (*IF CHISENDLINE*)
                   ELSE
                      BEGIN
                         WRITE(OUTPUT, CH);
                         OUTPUTCOL := OUTPUTCOL + 1;
                      END (*ELSE*);
                END (*IF CHARCOUNT > *);
             CH := CHARACTER;   WRITECOLUMN := WRITECOLUMN + 1;
          END (*WITH*);
    END (*WRITEA*);

 PROCEDURE WRITEANEOLWITHNOINDENT;

    BEGIN
       WRITEA(' ');
       WITH UNWRITTEN[OLDEST] DO
          BEGIN
             CHISENDLINE := TRUE;
             INDENTAFTEREOL := WRITECOL1 - 1;
          END;
       WRITECOLUMN := WRITECOL1;
    END (*WRITEANEOLWITHNOINDENT*);

 PROCEDURE STARTNEWLINEANDINDENT;

    LABEL
       1, 2;

    VAR
       I: OPTIONSIZE;

    BEGIN
       IF PACKERISOFF AND DISPLAYISON
       THEN
          BEGIN
          2: WRITEA(' ');   1: LASTSYMBOL := PERIODSYMBOL;
             WITH UNWRITTEN[OLDEST] DO
                BEGIN
                   CHISENDLINE := TRUE;
                   INDENTAFTEREOL := WRITECOL1 + LEFTMARGIN - 1;
                END;
             WRITECOLUMN := WRITECOL1 + LEFTMARGIN;
          END (*IF PACKERISOFF*);
    END (*STARTNEWLINE*);

 PROCEDURE READACHARACTER;

    BEGIN
       IF READCOLUMN > READCOL2
       THEN
          BEGIN
             GET(PROG);
             IF READCOL2 < 999
             THEN BEGIN WHILE NOT EOLN(PROG) DO GET(PROG); END
             ELSE READCOLUMN := 2;
          END
       ELSE
          IF READCOLUMN <= 1
          THEN
             BEGIN
                IF READCOLUMN = 1   THEN GET(PROG)
                ELSE READCOLUMN := 1;
                WHILE READCOLUMN < READCOL1 DO
                   BEGIN
                      IF EOLN(PROG)   THEN READCOLUMN := 1
                      ELSE READCOLUMN := READCOLUMN + 1;
                      GET(PROG);
                   END;
             END
          ELSE GET(PROG);
       IF EOLN(PROG)
       THEN
          BEGIN
             CHARACTER := ' ';   READCOLUMN := 1;
             IF NOFORMATTING   THEN WRITEANEOLWITHNOINDENT;
          END
       ELSE
          BEGIN
             CHARACTER := PROG@;   READCOLUMN := READCOLUMN + 1;
             IF NOFORMATTING   THEN WRITEA(CHARACTER);
          END;

"SZH" IF CHARACTER = '"' THEN
"SZH"    IF FIRSTDQUOTE THEN
"SZH"       BEGIN  CHARACTER := '';
"SZH"       FIRSTDQUOTE := FALSE;
"SZH"       END ;

    END (*READACHARACTER*);

 PROCEDURE WRITESYMBOL;

    VAR
       I: WIDTH;
       NUMBERBLANKSTOWRITE: OPTIONSIZE;
       WRITEWIDTH, TOTALINDENT: WIDTH;

    BEGIN
       IF DISPLAYISON
       THEN
          BEGIN
             NUMBERBLANKSTOWRITE := SYMBOLGAP;
             IF (LASTSYMBOL IN [LEFTPAREN, LEFTBRACKET,
                PERIODSYMBOL]) OR (SYMBOLNAME IN [SEMICOLON,
                RIGHTPARENTH, RIGHTBRACKET, COMMASYMBOL,
                PERIODSYMBOL, COLONSYMBOL]) OR (SYMBOLNAME IN [
                LEFTBRACKET, LEFTPAREN, UPARROW]) AND (
                LASTSYMBOL = IDENTIFIER)
             THEN NUMBERBLANKSTOWRITE := 0
             ELSE
                IF (SYMBOLNAME IN ALPHASYMBOLS) AND (LASTSYMBOL
                   IN ALPHASYMBOLS)
                THEN
                   IF WRITECOLUMN <= WRITECOL2 THEN
                      BEGIN
                         WRITEA(' ');
                         IF SYMBOLGAP > 0 THEN
                            NUMBERBLANKSTOWRITE := SYMBOLGAP - 1
                         ;
                      END;
             IF WRITECOLUMN + LENGTH + NUMBERBLANKSTOWRITE - 1 >
                WRITECOL2
             THEN
                BEGIN
                   WRITEA(' ');
                   WITH UNWRITTEN[OLDEST] DO
                      BEGIN
                         CHISENDLINE := TRUE;
                         IF PACKERISOFF
                         THEN
                            BEGIN
                               WRITEWIDTH := WRITECOL2 -
                                  WRITECOL1 + 1;
                               TOTALINDENT := LEFTMARGIN +
                                  LONGLINEINDENT;
                               IF LENGTH <= WRITEWIDTH -
                                  TOTALINDENT
                               THEN
                                  INDENTAFTEREOL := WRITECOL1 -
                                     1 + TOTALINDENT
                               ELSE
                                  IF LENGTH <= WRITEWIDTH
                                  THEN
                                     INDENTAFTEREOL := WRITECOL2
                                        - LENGTH
                                  ELSE
                                     BEGIN
                                        LENGTH := WRITEWIDTH;
                                        INDENTAFTEREOL :=
                                           WRITECOL1 - 1;
                                        IF SYMBOL[1] = ''''
                                        THEN
                                           SYMBOL[LENGTH] :=
                                              ''''
                                     END;
                               WRITECOLUMN := INDENTAFTEREOL + 1
                               ;
                            END
                         ELSE
                            BEGIN
                               IF LENGTH > WRITECOL2 - WRITECOL1
                                  + 1
                               THEN
                                  LENGTH := WRITECOL2 -
                                     WRITECOL1 + 1;
                               INDENTAFTEREOL := WRITECOL1 - 1;
                               WRITECOLUMN := WRITECOL1;
                            END;
                      END (*WITH*);
                END
             ELSE
                FOR I := 1 TO NUMBERBLANKSTOWRITE DO
                   WRITEA(' ');
             FOR I := 1 TO LENGTH DO WRITEA(SYMBOL[I]);
          END (*IF DISPLAYISON*);
       LASTSYMBOL := SYMBOLNAME;
    END (*WRITESYMBOL*);

 PROCEDURE READSYMBOL;

    CONST
       READNEXTCH = TRUE;
       DONTREADNEXTCH = FALSE;

    VAR
       TESTSYMBOL: ALFA;
       CHARNUMBER: WIDTH;
       I: WIDTH;

    PROCEDURE DOCOMMENT(TERMINATOR: CHAR);

       VAR
          I: OPTIONSIZE;
          SECONDTERMINATOR: CHAR;
          SAVEDSYMBGP: OPTIONSIZE;

       PROCEDURE COPYACHARACTER;

          LABEL
             10;

          BEGIN
             IF READINGFORMATOPTIONS
             THEN BEGIN CHARACTER := INPUT@;   GET(INPUT); END
             ELSE
                BEGIN
                   IF DISPLAYISON
                   THEN
                      BEGIN
                         IF WRITECOLUMN > WRITECOL2
                         THEN
                            BEGIN
                               IF (CHARACTER = ' ') AND
                                  NOT EOLN(PROG)
                               THEN
                                  BEGIN
                                     REPEAT READACHARACTER;
                                     UNTIL (CHARACTER <> ' ') OR
                                        EOLN(PROG);
                                     IF CHARACTER = TERMINATOR
                                     THEN GOTO 10;
                                  END;
                               IF NOT EOLN(PROG)
                               THEN
                                  BEGIN
                                     WRITEA(' ');
                                     WITH UNWRITTEN[OLDEST] DO
                                        BEGIN
                                           CHISENDLINE := TRUE;
                                           INDENTAFTEREOL :=
                                              WRITECOL1 +
                                              LEFTMARGIN - 1;
                                        END;
                                     WRITECOLUMN := WRITECOL1 +
                                        LEFTMARGIN;
                                  END;
                            END;
                         IF EOLN(PROG)
                         THEN WRITEANEOLWITHNOINDENT
                         ELSE WRITEA(CHARACTER);
                      END;
                   READACHARACTER;
                END;
         10:
          END (*COPYACHARACTER*);

       PROCEDURE COMPILERDIRECTIVES;

          BEGIN
             REPEAT
                REPEAT COPYACHARACTER;
"SZH"          UNTIL CHMAP[CHARACTER] IN
"SZH"                [CHMAP['E'], CHMAP['U'], CHMAP[' '], CHMAP['['],
"SZH"                 CHMAP[TERMINATOR] ];
             UNTIL NOT ((CHARACTER = 'E') AND PROGISPASCAL2);
             IF (CHARACTER = 'E') OR (CHARACTER = 'U')
             THEN
                BEGIN
                   COPYACHARACTER;
                   IF (CHARACTER = '+') OR (CHARACTER = '-') THEN
                      BEGIN
                         IF CHARACTER = '+'
                         THEN READCOL2 := 72
                         ELSE READCOL2 := 999;
                         IF (WRITECOL2 > 72)
                         THEN CHARACTER := '-';
                      END;
                END;
"SZH"       WHILE NOT (CHMAP[CHARACTER] IN [ CHMAP['['], CHMAP[TERMINATOR]]) DO
                COPYACHARACTER;
          END (*COMPILERDIRECTIVES*);

       PROCEDURE FORMATTERDIRECTIVES;

          CONST
             INVALID = - 1;

          TYPE
             PARAMCOUNT = 1 .. 2;
             PARAMS = ARRAY [PARAMCOUNT] OF MARGINS;

          VAR
             SPECIFICATION: PARAMS;
             FORMATOPTION: CHAR;
             PREVDISPLAY: BOOLEAN;
             ENDDIRECTV: SET OF CHSET;

          PROCEDURE READIN(N: PARAMCOUNT; VAR SPECIFICATION:
             PARAMS);

             VAR
                I: PARAMCOUNT;

             BEGIN
                FOR I := 1 TO N DO
                   BEGIN
"SZH"                 WHILE NOT (CHMAP[CHARACTER] IN (DIGITS +
                         ENDDIRECTV)) DO
                         COPYACHARACTER;
                      SPECIFICATION[I] := 0;
"SZH"                 IF NOT (CHMAP[CHARACTER] IN ENDDIRECTV)
                      THEN
                         REPEAT
                            SPECIFICATION[I] := 10 *
                               SPECIFICATION[I] + ORD(CHARACTER)
                               - ORD('0');
                            COPYACHARACTER;
"SZH"                    UNTIL NOT (CHMAP[CHARACTER] IN DIGITS)
                      ELSE SPECIFICATION[I] := INVALID;
                   END (*FOR*);
             END (*READIN*);

          BEGIN (*FORMATTERDIRECTIVES*)
"SZH"        ENDDIRECTV := [CHMAP[TERMINATOR], CHMAP[']']];
             REPEAT
"SZH"          IF ( CHMAP[CHARACTER] IN
"SZH"             [ CHMAP['A'], CHMAP['B'], CHMAP['C'], CHMAP['D'],
"SZH"               CHMAP['E'], CHMAP['G'], CHMAP['I'], CHMAP['L'],
"SZH"               CHMAP['N'], CHMAP['P'], CHMAP['R'], CHMAP['S'],
"SZH"               CHMAP['W'], CHMAP['F'], CHMAP['X'] ])
                THEN
                   BEGIN
                      FORMATOPTION := CHARACTER;
                      CASE FORMATOPTION OF
                         'A', 'E', 'I', 'G', 'P', 'L', 'S':
                            BEGIN
                               READIN(1, SPECIFICATION);
                               IF (SPECIFICATION[1] < WRITECOL2
                                  - WRITECOL1 - 9) OR (
                                  FORMATOPTION = 'P')
                               THEN
                                  CASE FORMATOPTION OF
                                     'A':
                                        DECLARALIGNMENT :=
                                           SPECIFICATION[1];
                                     'E':
                                        IF SPECIFICATION[1] < 4
                                        THEN
                                           BEGIN
                                              PROCEDNAMESWANTED
                                                 :=
                                                 SPECIFICATION[1
                                                 ] > 1;
                                              ENDCOMMENTSWANTED
                                                 := ODD(
                                                 SPECIFICATION[1]
                                                 );
                                           END;
                                     'G':
                                        SYMBOLGAP :=
                                           SPECIFICATION[1];
                                     'I':
                                        INDENTINDEX :=
                                           SPECIFICATION[1];
                                     'L':
                                        LONGLINEINDENT :=
                                           SPECIFICATION[1];
                                     'P':
                                        PROCEDSEPARATION :=
                                           SPECIFICATION[1];
                                     'S':
                                        STATMTSEPARATION :=
                                           SPECIFICATION[1];
                                  END (*CASE*);
                            END (*SINGLE PARAMETERS*);
                         'W', 'R', 'N':
                            BEGIN
                               READIN(2, SPECIFICATION);
                               IF SPECIFICATION[2] <> INVALID
                               THEN
                                  CASE FORMATOPTION OF
                                     'W':
                                        IF (SPECIFICATION[1] > 0
                                           ) AND (SPECIFICATION[
                                           2] < BUFFERSIZE - 2)
                                           AND (SPECIFICATION[2]
                                           - SPECIFICATION[1] >
                                           8)
                                        THEN
                                           BEGIN
                                              WRITECOL1 :=
                                                 SPECIFICATION[1
                                                 ];
                                              WRITECOL2 :=
                                                 SPECIFICATION[2
                                                 ];
                                           END;
                                     'R':
                                        IF (SPECIFICATION[1] > 0
                                           ) AND (SPECIFICATION[
                                           2] - SPECIFICATION[1]
                                           > 8)
                                        THEN
                                           BEGIN
                                              READCOL1 :=
                                                 SPECIFICATION[1
                                                 ];
                                              READCOL2 :=
                                                 SPECIFICATION[2
                                                 ];
                                           END;
                                     'N':
                                        BEGIN
                                           LINENUMBER :=
                                              SPECIFICATION[1];
                                           INCREMENT :=
                                              SPECIFICATION[2];
"SZH"                                     WHILE NOT ( CHMAP[CHARACTER]
"SZH"                                           IN ([CHMAP['+'], CHMAP['-'] ]+
                                              ENDDIRECTV)) DO
                                              COPYACHARACTER;
                                           IF CHARACTER = '-'
                                           THEN
                                              INCREMENT := -
                                                 INCREMENT
                                           ELSE
                                              IF WRITECOL1 < 3
                                              THEN
                                                 WRITECOL1 := 3;
                                        END;
                                  END (*CASE*);
                            END (*DOUBLE PARAMETERS*);
                         'B', 'C', 'D', 'F', 'X':
                            BEGIN
                               REPEAT COPYACHARACTER;
"SZH"                         UNTIL CHMAP[CHARACTER] IN
"SZH"                               ([ CHMAP['+'], CHMAP['-'] ] +
                                     ENDDIRECTV);
                               IF (CHARACTER = '+') OR (CHARACTER = '-')
                               THEN
                                  CASE FORMATOPTION OF
                                     'B':
                                        PACKERISOFF := CHARACTER
                                           = '-';
                                     'C':
                                        IF DISPLAYISON THEN
                                           COMPRESSWANTED :=
                                              CHARACTER = '+';
                                     'D':
                                        BEGIN
                                           PREVDISPLAY :=
                                              DISPLAYWANTED;
                                           DISPLAYWANTED :=
                                              CHARACTER = '+';
                                           IF PREVDISPLAY AND
                                              NOT DISPLAYWANTED
                                           THEN
                                              BEGIN
                                                 WRITEA(
                                                    TERMINATOR);
                                                 IF TERMINATOR =
                                                    '*'
                                                 THEN
                                                   IF
                                                   PROGISPASCAL2
                                                   THEN
                                                   WRITEA('(')
                                                   ELSE
                                                   WRITEA('/');
                                                 SAVEDCOMPRESS
                                                    :=
                                                  COMPRESSWANTED
                                                 ;
                                                 COMPRESSWANTED
                                                    := FALSE;
                                              END
                                           ELSE
                                              IF NOT PREVDISPLAY
                                                 AND
                                                 DISPLAYWANTED
                                              THEN
                                                 BEGIN

                                           STARTNEWLINEANDINDENT
                                                    ;
                                                   IF TERMINATOR
                                                      = '*'
                                                   THEN
                                                   BEGIN
                                                   IF PROGISPASCAL2
                                                   THEN
                                                   WRITEA('(')
                                                   ELSE
                                                   WRITEA('/');
                                                   WRITEA('*');
                                                   END
                                                   ELSE
                                                   WRITEA('_');

                                                  COMPRESSWANTED
                                                      :=
                                                   SAVEDCOMPRESS
                                                    ;
                                                 END (*IF NOT PR
                                                 EV*);
                                        END (* 'D': *);
                                     'F':
                                        BEGIN
                                           PREVDISPLAY :=
                                              NOFORMATTING;
                                           NOFORMATTING :=
                                              CHARACTER = '-';
                                           IF PREVDISPLAY AND
                                              NOT NOFORMATTING
                                           THEN READACHARACTER;
                                           IF NOT PREVDISPLAY
                                              AND NOFORMATTING
                                           THEN WRITEA('-');
                                        END;
                                     'X':
                                        CROSSREFWANTED :=
                                           CHARACTER = '+';
                                  END (*CASE*);
                               DISPLAYISON := DISPLAYWANTED AND
                                  NOT NOFORMATTING;
                            END (*BOOLEAN PARAMETERS*);
                      END (*CASE*)
                   END (*THEN*)
                ELSE
"SZH"              IF NOT (CHMAP[CHARACTER] IN ENDDIRECTV)
                   THEN COPYACHARACTER;
"SZH"        UNTIL CHMAP[CHARACTER] IN ENDDIRECTV;
             IF CHARACTER = ']'   THEN COPYACHARACTER;
          END (*FORMATTERDIRECTIVES*);

       BEGIN (*DOCOMMENT*)
          IF READINGFORMATOPTIONS   THEN FORMATTERDIRECTIVES
          ELSE
             BEGIN
                IF PROGISPASCAL2   THEN SECONDTERMINATOR := ')'
                ELSE SECONDTERMINATOR := '/';
                IF LASTSYMBOL IN [COMMENT, SEMICOLON] THEN
                   BEGIN
                      LEFTMARGIN := 0;   STARTNEWLINEANDINDENT;
                      LEFTMARGIN := ACTUALLEFTMARGIN;
                   END;
                WRITESYMBOL;
                IF CHARACTER = '$'   THEN COMPILERDIRECTIVES;
                IF CHARACTER = '['   THEN FORMATTERDIRECTIVES;
                SAVEDSYMBGP := SYMBOLGAP;   SYMBOLGAP := 0;
                REPEAT

                   WHILE CHARACTER <> TERMINATOR DO
                      BEGIN  COPYACHARACTER;
                      END (*WHILE*);

                   READSYMBOL;   WRITESYMBOL;
                UNTIL SYMBOLNAME = COMMENT;
                SYMBOLGAP := SAVEDSYMBGP;   READSYMBOL;
             END;
       END (*DOCOMMENT*);

    PROCEDURE CHECKFOR(SECONDCHAR: CHAR; TWOCHARSYMBOL: SYMBOLS;
       READALLOWED: BOOLEAN);

       BEGIN
          IF READALLOWED THEN
             BEGIN
                LENGTH := 1;   SYMBOL[1] := CHARACTER;
                SYMBOLNAME := NAMEOF[CHARACTER];
                READACHARACTER;
             END;
          IF CHARACTER = SECONDCHAR THEN
             BEGIN
                SYMBOL[2] := CHARACTER;   LENGTH := 2;
                SYMBOLNAME := TWOCHARSYMBOL;   READACHARACTER;
             END;
       END (*CHECKFOR*);

    BEGIN (*READSYMBOL*)
"SZH"
"SZH"  IF CHARACTER = '#' THEN CHARACTER := ' '
"SZH"  ELSE
"SZH"     IF CHARACTER = '"' THEN
"SZH"         IF FIRSTDQUOTE THEN
"SZH"            BEGIN CHARACTER := '';  FIRSTDQUOTE := FALSE END
"SZH"         ELSE  BEGIN  CHARACTER := '¯';  FIRSTDQUOTE := TRUE  END;
"SZH"
       IF READINGFORMATOPTIONS   THEN DOCOMMENT('*')
       ELSE
          CASE TYPEOF[CHARACTER] OF
             STAR:
                IF PROGISPASCAL2
                THEN CHECKFOR(')', COMMENT, READNEXTCH)
                ELSE CHECKFOR('/', COMMENT, READNEXTCH);
             RIGHTARROW:
                BEGIN
                   SYMBOLNAME := COMMENT;   SYMBOL[1] := '¯';
                   LENGTH := 1;   READACHARACTER;
                   DOCOMMENT('');
                END;
"SZH"    (*  DQUOTE:
"SZH"           BEGIN
"SZH"              SYMBOLNAME := COMMENT;   SYMBOL[1] := '"';
"SZH"              LENGTH := 1;   READACHARACTER;
"SZH"              DOCOMMENT('"');
"SZH"           END;   *)
             SLASH:
                BEGIN
                   CHECKFOR('*', COMMENT, READNEXTCH);
                   IF (SYMBOLNAME = COMMENT) THEN
                      BEGIN
                         PROGISPASCAL2 := FALSE;
                         DOCOMMENT('*')
                      END;
                END;
             LFTPAREN:
                BEGIN
                   CHECKFOR('*', COMMENT, READNEXTCH);
                   IF (SYMBOLNAME = COMMENT) THEN
                      BEGIN
                         PROGISPASCAL2 := TRUE;
                         DOCOMMENT('*')
                      END;
                END;
             ALPHANUMERIC:
                BEGIN
"SZH"              SYMBOLISNUMBER := CHMAP[CHARACTER] IN DIGITS;
                   CHARNUMBER := 1;
                   REPEAT
                      SYMBOL[CHARNUMBER] := CHARACTER;
                      READACHARACTER;
                      CHARNUMBER := CHARNUMBER + 1
                   UNTIL NOT (TYPEOF[CHARACTER] = ALPHANUMERIC);
                   IF SYMBOLISNUMBER AND (SYMBOL[CHARNUMBER - 1]
                      = 'E')
                   THEN
                      REPEAT
                         SYMBOL[CHARNUMBER] := CHARACTER;
                         READACHARACTER;
                         CHARNUMBER := CHARNUMBER + 1;
"SZH"                 UNTIL NOT (CHMAP[CHARACTER] IN DIGITS);
                   LENGTH := CHARNUMBER - 1;
                   IF SYMBOLISNUMBR
                   THEN SYMBOLNAME := IDENTIFIER
                   ELSE
                      BEGIN
                         FOR CHARNUMBER := CHARNUMBER TO 10 DO
                            SYMBOL[CHARNUMBER] := ' ';
"""                      PACK(SYMBOL, 1, TESTSYMBOL);   """  I := 1;
"SZH"                    FOR PQ := 1 TO ALFLEN DO TESTSYMBOL[PQ] := SYMBOL[PQ];
                         PASCALSYMBOL[LASTPSYMBOLNAME] :=
                            TESTSYMBOL;
                         WHILE TESTSYMBOL <> PASCALSYMBOL[I] DO
                            I := I + 1;
                         SYMBOLNAME := PSYMBOLNAME[I];
                      END (*ELSE*);
                END (*ALPHANUMERIC*);
             BLANK, ENDOFLINE:
                BEGIN
                   REPEAT READACHARACTER
                   UNTIL NOT (TYPEOF[CHARACTER] IN [BLANK,
                      ENDOFLINE]);
                   READSYMBOL
                END;
             GREATERTHAN, COLON:
                CHECKFOR('=', OTHERSYMBOL, READNEXTCH);
             LESSTHAN:
                BEGIN
                   CHECKFOR('=', OTHERSYMBOL, READNEXTCH);
                   IF SYMBOLNAME <> OTHERSYMBOL THEN
                      CHECKFOR('>', OTHERSYMBOL, DONTREADNEXTCH)
                   ;
                END;
             PERIOD:
                IF LASTSYMBOL <> ENDSYMBOL
                THEN CHECKFOR('.', RANGE, READNEXTCH)
                ELSE SYMBOLNAME := PERIODSYMBOL;
             STRING:
                BEGIN
                   CHARNUMBER := 1;
                   REPEAT
                      REPEAT
                         SYMBOL[CHARNUMBER] := CHARACTER;
                         CHARNUMBER := CHARNUMBER + 1;
                         READACHARACTER;
                      UNTIL CHARACTER = '''';
                      SYMBOL[CHARNUMBER] := CHARACTER;
                      CHARNUMBER := CHARNUMBER + 1;
                      READACHARACTER;
                   UNTIL CHARACTER <> '''';
                   LENGTH := CHARNUMBER - 1;
                   SYMBOLNAME := OTHERSYMBOL;
                END (*STRING*);
             OTHER:
                BEGIN
                   SYMBOL[1] := CHARACTER;
                   SYMBOLNAME := NAMEOF[CHARACTER];
                   LENGTH := 1;   READACHARACTER;
                END;
          END (*CASE*);
    END (*READSYMBOL*);

 PROCEDURE CHANGEMARGINTO(NEWLEFTMARGIN: MARGINS);

    BEGIN
       ACTUALLEFTMARGIN := NEWLEFTMARGIN;
       LEFTMARGIN := NEWLEFTMARGIN;
       IF LEFTMARGIN < 0   THEN LEFTMARGIN := 0
       ELSE
          IF LEFTMARGIN > WRITECOL2 - WRITECOL1 - 9 -
             LONGLINEINDENT
          THEN
             LEFTMARGIN := WRITECOL2 - WRITECOL1 - 9 -
                LONGLINEINDENT;
    END (*CHANGEMARGINTO*);

 PROCEDURE DODECLARATIONUNTIL(ENDDECLARATION: SYMBOLSET);

    PROCEDURE DOPARENTHESES;

       VAR
          SAVEDLGLNID: OPTIONSIZE;

       BEGIN
          SAVEDLGLNID := LONGLINEINDENT;
          IF DECLARALIGNMENT > 0
          THEN
             BEGIN
                LONGLINEINDENT := WRITECOLUMN + SYMBOLGAP + 1 -
                   LEFTMARGIN - WRITECOL1;
                REPEAT WRITESYMBOL;   READSYMBOL;
                UNTIL SYMBOLNAME = RIGHTPARENTH;
                WRITESYMBOL;   READSYMBOL;
             END
          ELSE
             BEGIN
                LONGLINEINDENT := 1;
                CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
                STARTNEWLINEANDINDENT;
                REPEAT WRITESYMBOL;   READSYMBOL
                UNTIL SYMBOLNAME = RIGHTPARENTH;
                WRITESYMBOL;   READSYMBOL;
                CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
             END (*ELSE*);
          LONGLINEINDENT := SAVEDLGLNID;
       END (*DOPARENTHESES*);

    PROCEDURE DOFIELDLISTUNTIL(ENDFIELDLIST: SYMBOLSET);

       VAR
          LASTEOL: MARGINS;
          ALIGNCOLUMN: WIDTH;

       PROCEDURE DORECORD;

          VAR
             SAVEDLEFTMARGIN: WIDTH;

          BEGIN
             SAVEDLEFTMARGIN := ACTUALLEFTMARGIN;   WRITESYMBOL;
             READSYMBOL;
             CHANGEMARGINTO(WRITECOLUMN - 6 + INDENTINDEX -
                WRITECOL1);
             STARTNEWLINEANDINDENT;
             DOFIELDLISTUNTIL([ENDSYMBOL]);
             CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
             STARTNEWLINEANDINDENT;   WRITESYMBOL;   READSYMBOL;
             CHANGEMARGINTO(SAVEDLEFTMARGIN);
          END (*DORECORD*);

       PROCEDURE DOVARIANTRECORDPART;

          VAR
             SAVEDLEFTMARGIN, OTHERSAVEDMARGIN: MARGINS;

          BEGIN
             OTHERSAVEDMARGIN := ACTUALLEFTMARGIN;
             IF DECLARALIGNMENT > 0
             THEN
                BEGIN
                   REPEAT WRITESYMBOL;   READSYMBOL;
                   UNTIL SYMBOLNAME = COLONSYMBOL;
                   WRITESYMBOL;   READSYMBOL;
                   WITH UNWRITTEN[LASTEOL] DO
                      BEGIN
                         INDENTAFTEREOL := INDENTAFTEREOL +
                            ALIGNCOLUMN - WRITECOLUMN;
                         IF INDENTAFTEREOL < 0
                         THEN INDENTAFTEREOL := 0;
                      END;
                   WRITECOLUMN := ALIGNCOLUMN;
                   CHANGEMARGINTO(ACTUALLEFTMARGIN + ALIGNCOLUMN -
                      WRITECOLUMN);
                END;
             REPEAT WRITESYMBOL;   READSYMBOL;
             UNTIL SYMBOLNAME = OFSYMBOL;
             CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
             REPEAT
                WRITESYMBOL;   READSYMBOL;
                IF SYMBOLNAME <> ENDSYMBOL
                THEN
                   BEGIN
                      STARTNEWLINEANDINDENT;
                      REPEAT WRITESYMBOL;   READSYMBOL;
                      UNTIL SYMBOLNAME IN [LEFTPAREN, SEMICOLON
                         , ENDSYMBOL];
                      IF SYMBOLNAME = LEFTPAREN
                      THEN
                         BEGIN
                            WRITESYMBOL;   READSYMBOL;
                            SAVEDLEFTMARGIN := ACTUALLEFTMARGIN;
                            CHANGEMARGINTO(WRITECOLUMN -
                               WRITECOL1);
                            DOFIELDLISTUNTIL([RIGHTPARENTH]);
                            WRITESYMBOL;   READSYMBOL;
                            CHANGEMARGINTO(SAVEDLEFTMARGIN);
                         END;
                   END;
             UNTIL SYMBOLNAME <> SEMICOLON;
             CHANGEMARGINTO(OTHERSAVEDMARGIN);
          END (*DOVARIANTRECORDPART*);

       BEGIN (*DOFIELDLISTUNTIL*)
          LASTEOL := OLDEST;
          IF LASTSYMBOL = LEFTPAREN THEN
             FOR I := 1 TO DECLARALIGNMENT - LENGTH DO WRITEA(' ');
          ALIGNCOLUMN := LEFTMARGIN + WRITECOL1 + DECLARALIGNMENT +
             1;
          WHILE NOT (SYMBOLNAME IN ENDFIELDLIST) DO
             BEGIN
                IF LASTSYMBOL IN [SEMICOLON, COMMENT] THEN
                   IF SYMBOLNAME <> SEMICOLON THEN
                      BEGIN
                         STARTNEWLINEANDINDENT;
                         LASTEOL := OLDEST
                      END;
                IF SYMBOLNAME IN [RECORDSYMBOL, CASESYMBOL,
                   LEFTPAREN, COMMASYMBOL, COLONSYMBOL,
                   EQUALSYMBOL]
                THEN
                   CASE SYMBOLNAME OF
                      RECORDSYMBOL: DORECORD;
                      CASESYMBOL: DOVARIANTRECORDPART;
                      LEFTPAREN: DOPARENTHESES;
                      COMMASYMBOL, COLONSYMBOL, EQUALSYMBOL:
                         BEGIN
                            WRITESYMBOL;
                            IF DECLARALIGNMENT > 0
                            THEN
                               IF ENDFIELDLIST <> ENDLABEL
                               THEN
                                  BEGIN
                                     WITH UNWRITTEN[LASTEOL] DO
                                        BEGIN
                                           INDENTAFTEREOL :=
                                              INDENTAFTEREOL +
                                              ALIGNCOLUMN -
                                              WRITECOLUMN;
                                           IF INDENTAFTEREOL < 0
                                           THEN
                                              INDENTAFTEREOL :=
                                                 0;
                                           WRITECOLUMN :=
                                              ALIGNCOLUMN;
                                        END;
                                     IF SYMBOLNAME = COMMASYMBOL
                                     THEN
                                        BEGIN
                                           STARTNEWLINEANDINDENT
                                           ;
                                           LASTEOL := OLDEST;
                                        END;
                                  END (*IF DECLARALIGN*);
                            READSYMBOL;
                         END (*  ,   :   = *)
                   END (*CASE*)
                ELSE BEGIN WRITESYMBOL;   READSYMBOL END;
             END (*WHILE*);
       END (*DOFIELDLISTUNTIL*);

    BEGIN (*DODECLARATIONUNTIL*)
       STARTNEWLINEANDINDENT;   WRITESYMBOL;
       CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
       STARTNEWLINEANDINDENT;   READSYMBOL;
       DOFIELDLISTUNTIL(ENDDECLARATION);
       STARTNEWLINEANDINDENT;
       CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
    END (*DOTYPES*);

 PROCEDURE BLOCK(BLOCKNAME: COMMENTTEXT; BLOCKNMLENGTH: WIDTH);

    VAR
       I: WIDTH;
       IFTHENCOMPRESSNEEDED: BOOLEAN;
       ATPROCEDBEGINNING: BOOLEAN;

    PROCEDURE PROCEDURES;

       VAR
          I: 0 .. 20;
          PROCEDNAME: COMMENTTEXT;
          PROCEDNMLENGTH: WIDTH;

       BEGIN
          FOR I := 2 TO PROCEDSEPARATION DO
             STARTNEWLINEANDINDENT;
          STARTNEWLINEANDINDENT;   WRITESYMBOL;   READSYMBOL;
          FOR I := 0 TO(LENGTH - 1) DIV 10 DO
"""          PACK(SYMBOL, I * 10 + 1, PROCEDNAME[I + 1]); """
"SZH"        FOR PQ := 1 TO ALFLEN DO PROCEDNAME[I+1,PQ] := SYMBOL[I*10+PQ];
          PROCEDNMLENGTH := LENGTH;   WRITESYMBOL;   READSYMBOL;
          IF SYMBOLNAME = LEFTPAREN THEN
             BEGIN
                WRITESYMBOL;
                REPEAT READSYMBOL;   WRITESYMBOL
                UNTIL SYMBOLNAME = RIGHTPARENTH;
                READSYMBOL;
             END;
          IF SYMBOLNAME = COLONSYMBOL THEN
             REPEAT WRITESYMBOL;   READSYMBOL;
             UNTIL SYMBOLNAME = SEMICOLON;
          WRITESYMBOL;   READSYMBOL;
          CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
          STARTNEWLINEANDINDENT;   LASTPROGPARTWASBODY := FALSE;
          BLOCK(PROCEDNAME, PROCEDNMLENGTH);
          LASTPROGPARTWASBODY := TRUE;
          CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
          WRITESYMBOL;   READSYMBOL;
 (* WRITE ";"*)
          STARTNEWLINEANDINDENT;
       END (*PROCEDURES*);

    PROCEDURE DOSTATEMENT(VAR ADDEDBLANKS: WIDTH; STATMTSYMBOL:
       COMMENTTEXT; STMTSYMLENGTH: WIDTH);

       VAR
          I: WIDTH;
          STATMTBEGINNING: INTEGER;
          STATMTPART: ARRAY [1 .. 4] OF INTEGER;
          BLKSONCURRNTLINE, BLKSADDEDBYTHISSTMT: INTEGER;
          SUCCESSFUL: BOOLEAN;

       PROCEDURE COMPRESS(BEGINNING, BREAKPT, ENDING: INTEGER;
          STATMTSEPARATION: OPTIONSIZE);

          BEGIN
             IF COMPRESSWANTED OR IFTHENCOMPRESSNEEDED
             THEN
                BEGIN
                   IF STATMTSEPARATION < 1
                   THEN STATMTSEPARATION := 1;
                   BLKSONCURRNTLINE := BLKSONCURRNTLINE +
                      STATMTSEPARATION - 1;
                   SUCCESSFUL := ((ENDING - BEGINNING +
                      BLKSONCURRNTLINE + UNWRITTEN[BEGINNING MOD
                      BUFFERSIZE].INDENTAFTEREOL) < WRITECOL2)
                      AND (CHARCOUNT - BEGINNING < BUFFERSIZE);
                   IF SUCCESSFUL THEN
                      BEGIN
                         BLKSADDEDBYTHISST := BLKSADDEDBYTHISST +
                            STATMTSEPARATION - 1;
                         UNWRITTEN[BREAKPT MOD BUFFERSIZE].
                            INDENTAFTEREOL := - STATMTSEPARATION
                         ;
                      END;
                END;
          END (*COMPRESS*);

       PROCEDURE WRITECOMMENT;

          VAR
             I: 0 .. BUFFSZDIV10;
             SAVEDLENGTH: WIDTH;
             SAVEDSYMBOLNAME: SYMBOLS;
             SAVEDCHARS: SYMBOLSTRING;

          BEGIN
             SAVEDSYMBOLNAME := SYMBOLNAME;
             FOR I := 1 TO LENGTH DO SAVEDCHARS[I] := SYMBOL[I];
             SAVEDLENGTH := LENGTH;   SYMBOLNAME := OTHERSYMBOL;
             IF PROGISPASCAL2   THEN SYMBOL[1] := '('
             ELSE SYMBOL[1] := '/';
             SYMBOL[2] := '*';   LENGTH := 2;   WRITESYMBOL;
             FOR I := 0 TO(STMTSYMLENGTH - 1) DIV 10 DO
            """ UNPACK(STATMTSYMBOL[I + 1], SYMBOL, (I * 10 + 1)
                   );"""
                FOR PQ := 1 TO ALFLEN DO  SYMBOL[I*10+PQ]:=STATMTSYMBOL[I+1,PQ];
             LENGTH := STMTSYMLENGTH;
             SYMBOLNAME := PERIODSYMBOL;
             LASTSYMBOL := PERIODSYMBOL;   WRITESYMBOL;
             SYMBOL[1] := '*';
             IF PROGISPASCAL2   THEN SYMBOL[2] := ')'
             ELSE SYMBOL[2] := '/';
             LENGTH := 2;   WRITESYMBOL;
             SYMBOLNAME := SAVEDSYMBOLNAME;
             LENGTH := SAVEDLENGTH;
             FOR I := 1 TO LENGTH DO SYMBOL[I] := SAVEDCHARS[I];
          END (*WRITECOMMENT*);

       PROCEDURE DOSTATMTLIST(ENDLIST: SYMBOLS);

          VAR
             BLKSAFTERPRT2: WIDTH;
             ATPROCEDEND: BOOLEAN;

          BEGIN
             ATPROCEDEND := ATPROCEDBEGINNING;   WRITESYMBOL;
             READSYMBOL;   STATMTPART[1] := CHARCOUNT + 1;
             STATMTPART[2] := STATMTPART[1];
             IF SYMBOLNAME <> ENDLIST
             THEN
                BEGIN
                   IF PROCEDNAMESWANTED THEN
                      IF ATPROCEDBEGINNING THEN
                         IF LASTPROGPARTWASBODY THEN
                            IF LASTSYMBOL = BEGINSYMBOL
                            THEN WRITECOMMENT;
                   ATPROCEDBEGINNING := FALSE;
                   DOSTATEMENT(ADDEDBLANKS, STATMTSYMBOL,
                      STMTSYMLENGTH);
                   BLKSAFTERPRT2 := ADDEDBLANKS;
                   BLKSADDEDBYTHISSTMT := BLKSADDEDBYTHISSTMT +
                      ADDEDBLANKS;
                   WHILE SYMBOLNAME <> ENDLIST DO
                      BEGIN
                         WRITESYMBOL;   READSYMBOL;
                         IF SYMBOLNAME <> ENDLIST
                         THEN
                            BEGIN
                               STATMTPART[3] := CHARCOUNT + 1;
                               DOSTATEMENT(ADDEDBLANKS,
                                  STATMTSYMBOL, STMTSYMLENGTH);
                               BLKSONCURRNTLINE := ADDEDBLANKS +
                                  BLKSAFTERPRT2;
                               BLKSADDEDBYTHSTMT :=
                                  BLKSADDEDBYTHSTMT +
                                  ADDEDBLANKS;
                               COMPRESS(STATMTPART[2],
                                  STATMTPART[3], CHARCOUNT,
                                  STATMTSEPARATION);
                               IF NOT SUCCESSFUL
                               THEN
                                  BEGIN
                                     BLKSAFTERPRT2 :=
                                        ADDEDBLANKS;
                                     STATMTPART[2] := STATMTPART
                                        [3];
                                  END
                               ELSE
                                  BLKSAFTERPRT2 :=
                                     BLKSONCURRNTLINE;
                            END;
                      END (*WHILE SYMBOLNAME <> ENDLIST*);
                END (*IF SYMBOLNAME <> ENDLIST*);
             BLKSONCURRNTLINE := BLKSADDEDBYTHISSTMT;
             COMPRESS(STATMTBEGINNING, STATMTPART[1], CHARCOUNT,
                SYMBOLGAP);
             STARTNEWLINEANDINDENT;
             STATMTPART[1] := CHARCOUNT;
             REPEAT WRITESYMBOL;   READSYMBOL;
             UNTIL SYMBOLNAME IN [SEMICOLON, UNTILSYMBOL,
                ENDSYMBOL, ELSESYMBOL, PERIODSYMBOL];
             IF SUCCESSFUL
             THEN
                BEGIN
                   IF ENDLIST = UNTILSYMBOL
                   THEN STATMTPART[4] := STATMTSEPARATION
                   ELSE STATMTPART[4] := SYMBOLGAP;
                   COMPRESS(STATMTBEGINNING, STATMTPART[1],
                      CHARCOUNT, STATMTPART[4]);
                END (*IF SUCCESSFUL*);
             IF NOT (SUCCESSFUL AND COMPRESSWANTED)
             THEN
                IF ENDLIST = ENDSYMBOL THEN
                   IF LASTSYMBOL = ENDSYMBOL THEN
                      IF ATPROCEDEND AND PROCEDNAMESWANTED
                      THEN WRITECOMMENT
                      ELSE
                         IF ENDCOMMENTSWANTED
                         THEN WRITECOMMENT;
          END (*DOSTATMTLIST*);

       BEGIN (*DOSTATEMENT*)
          BLKSONCURRNTLINE := 0;
          BLKSADDEDBYTHISST := 0;
          CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
          STARTNEWLINEANDINDENT;   STATMTBEGINNING := CHARCOUNT;
          IF SYMBOLISNUMBER
          THEN
             BEGIN
                WITH UNWRITTEN[OLDEST] DO
                   BEGIN
                      INDENTAFTEREOL := INDENTAFTEREOL - 1 -
                         LENGTH - SYMBOLGAP;
                      IF INDENTAFTEREOL < 0
                      THEN INDENTAFTEREOL := 0;
                   END;
                WRITESYMBOL;   READSYMBOL (*WRITE LABEL*);
                WRITESYMBOL;   READSYMBOL (*WRITE COLON*);
             END;
          CASE STATEMENTTYPEOF[SYMBOLNAME] OF
             FORWITHWHILESTATEMENT:
                BEGIN
"""                PACK(SYMBOL, 1, STATMTSYMBOL[1]);    """
"SZH"              FOR PQ := 1 TO ALFLEN DO STATMTSYMBOL[1,PQ] := SYMBOL[PQ];
                   STMTSYMLENGTH := LENGTH;
                   REPEAT WRITESYMBOL;   READSYMBOL
                   UNTIL SYMBOLNAME = DOSYMBOL;
                   WRITESYMBOL;   READSYMBOL;
                   STATMTPART[1] := CHARCOUNT + 1;
                   DOSTATEMENT(ADDEDBLANKS, STATMTSYMBOL,
                      STMTSYMLENGTH);
                   BLKSONCURRNTLINE := BLKSONCURRNTLINE +
                      ADDEDBLANKS;
                   BLKSADDEDBYTHISSTMT := BLKSADDEDBYTHISSTMT +
                      ADDEDBLANKS;
                   COMPRESS(STATMTBEGINNING, STATMTPART[1],
                      CHARCOUNT, SYMBOLGAP);
                END;
             REPEATSTATEMENT: DOSTATMTLIST(UNTILSYMBOL);
             IFSTATEMENT:
                BEGIN
"""                PACK(SYMBOL, 1, STATMTSYMBOL[1]);   """
"SZH"              FOR PQ := 1 TO ALFLEN DO STATMTSYMBOL[1,PQ] := SYMBOL[PQ];
                   STMTSYMLENGTH := LENGTH;
                   REPEAT WRITESYMBOL;   READSYMBOL
                   UNTIL SYMBOLNAME = THENSYMBOL;
                   STARTNEWLINEANDINDENT;
                   STATMTPART[1] := CHARCOUNT;   WRITESYMBOL;
                   READSYMBOL;   STATMTPART[2] := CHARCOUNT + 1;
                   DOSTATEMENT(ADDEDBLANKS, STATMTSYMBOL,
                      STMTSYMLENGTH);
                   BLKSONCURRNTLINE := ADDEDBLANKS;
                   BLKSADDEDBYTHISSTMT := ADDEDBLANKS;
                   COMPRESS(STATMTPART[1], STATMTPART[2],
                      CHARCOUNT, SYMBOLGAP);
                   IF SUCCESSFUL
                   THEN
                      COMPRESS(STATMTBEGINNING, STATMTPART[1],
                         CHARCOUNT, STATMTSEPARATION)
                   ELSE IFTHENCOMPRESSNEEDED := TRUE;
                   IF SYMBOLNAME = ELSESYMBOL
                   THEN
                      BEGIN
"""                      PACK(SYMBOL, 1, STATMTSYMBOL[1]);          """
"SZH"                    FOR PQ := 1 TO ALFLEN DO
"SZH"                        STATMTSYMBOL[1,PQ] := SYMBOL[PQ];
                         STMTSYMLENGTH := LENGTH;
                         IFTHENCOMPRESSNEEDED := FALSE;
                         STARTNEWLINEANDINDENT;
                         STATMTPART[3] := CHARCOUNT;
                         WRITESYMBOL;   READSYMBOL;
                         STATMTPART[4] := CHARCOUNT + 1;
                         DOSTATEMENT(ADDEDBLANKS, STATMTSYMBOL,
                            STMTSYMLENGTH);
                         BLKSONCURRNTLINE := ADDEDBLANKS;
                         BLKSADDEDBYTHISSTMT :=
                            BLKSADDEDBYTHISSTMT + ADDEDBLANKS;
                         COMPRESS(STATMTPART[3], STATMTPART[4],
                            CHARCOUNT, SYMBOLGAP);
                         BLKSONCURRNTLINE := BLKSADDEDBYTHISSTMT
                         ;
                         IF SUCCESSFUL THEN
                            COMPRESS(STATMTBEGINNING, STATMTPART[3],
                               CHARCOUNT, STATMTSEPARATION);
                      END
                   ELSE
                      IF (CHARCOUNT - STATMTBEGINNING) <
                         BUFFERSIZE
                      THEN
                         BEGIN
                            COMPRESSWANTED := NOT COMPRESSWANTED
                            ;
                            BLKSONCURRNTLINE := 0;
                            COMPRESS(STATMTBEGINNING, STATMTPART
                               [1], STATMTPART[2], SYMBOLGAP);
                            COMPRESSWANTED := NOT COMPRESSWANTED
                            ;
                         END;
                   IFTHENCOMPRESSNEEDED := FALSE;
                END (*IFSTATEMENT*);
             CASESTATEMENT:
                BEGIN
                   REPEAT WRITESYMBOL;   READSYMBOL
                   UNTIL SYMBOLNAME = OFSYMBOL;
                   WRITESYMBOL;   READSYMBOL;
                   CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX
                      );
                   WHILE SYMBOLNAME <> ENDSYMBOL DO
                      BEGIN
                         STARTNEWLINEANDINDENT;
                         STATMTPART[1] := CHARCOUNT;
                         FOR I := 0 TO(LENGTH - 1) DIV 10 DO
"""                         PACK(SYMBOL, (I * 10 + 1), STATMTSYMBOL[I + 1]);"""
"SZH"                       FOR PQ := 1 TO ALFLEN DO
                              STATMTSYMBOL[I+1, PQ] := SYMBOL[I*10 +PQ];
                         STMTSYMLENGTH := LENGTH;
                         REPEAT WRITESYMBOL;   READSYMBOL
                         UNTIL SYMBOLNAME = COLONSYMBOL;
                         WRITESYMBOL;   READSYMBOL;
 (*WRITE COLON*)
                         IF NOT (SYMBOLNAME IN [SEMICOLON,
                            ENDSYMBOL])
                         THEN
                            BEGIN
                               STATMTPART[2] := CHARCOUNT + 1;
                               DOSTATEMENT(ADDEDBLANKS,
                                  STATMTSYMBOL, STMTSYMLENGTH);
                               BLKSONCURRNTLINE := ADDEDBLANKS;
                               BLKSADDEDBYTHISSTMT :=
                                  BLKSADDEDBYTHISSTMT +
                                  ADDEDBLANKS;
                               COMPRESS(STATMTPART[1],
                                  STATMTPART[2], CHARCOUNT,
                                  SYMBOLGAP);
                            END (*IF NOT(SYMBOLNAME...)*);
                         IF SYMBOLNAME = SEMICOLON THEN
                            BEGIN WRITESYMBOL;   READSYMBOL;
                            END;
                      END;
                   CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX
                      );
                   STARTNEWLINEANDINDENT;   WRITESYMBOL;
                   READSYMBOL;
                   IF ENDCOMMENTSWANTED AND (LASTSYMBOL =
                      ENDSYMBOL)
                   THEN
                      BEGIN
                         STATMTSYMBOL[1] := 'CASE      ';
                         STMTSYMLENGTH := 4;   WRITECOMMENT;
                      END;
                END (*CASESTATEMENT*);
             OTHERSTATEMENT:
                BEGIN
                   WHILE NOT (SYMBOLNAME IN [SEMICOLON,
                      UNTILSYMBOL, ENDSYMBOL, ELSESYMBOL]) DO
                      BEGIN WRITESYMBOL;   READSYMBOL END;
                END (*OTHER*);
             COMPOUNDSTATEMENT: DOSTATMTLIST(ENDSYMBOL);
          END (*CASE*);
          ADDEDBLANKS := BLKSADDEDBYTHISSTMT;
          CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
       END (*DOSTATEMENT*);

    BEGIN (*BLOCK*)
       LASTPROGPARTWASBODY := LASTPROGPARTWASBODY AND (
          SYMBOLNAME = BEGINSYMBOL);
       IF SYMBOLNAME = LABELSYMBOL
       THEN DODECLARATIONUNTIL(ENDLABEL);
       IF SYMBOLNAME = CONSTSYMBOL
       THEN DODECLARATIONUNTIL(ENDCONST);
       IF SYMBOLNAME = TYPESYMBOL
       THEN DODECLARATIONUNTIL(ENDTYPE);
       IF SYMBOLNAME = VARSYMBOL
       THEN DODECLARATIONUNTIL(ENDVAR);
       IF SYMBOLNAME = VALUESYMBOL
       THEN DODECLARATIONUNTIL(ENDVALUE);
       WHILE SYMBOLNAME IN [FUNCTIONSYMBOL, PROCEDSYMBOL] DO
          PROCEDURES;
       IF SYMBOLNAME = BEGINSYMBOL
       THEN
          BEGIN
             IF LASTPROGPARTWASBODY THEN
                FOR I := 2 TO PROCEDSEPARATION DO
                   STARTNEWLINEANDINDENT;
             IFTHENCOMPRESSNEEDED := FALSE;
             ATPROCEDBEGINNING := TRUE;
             CHANGEMARGINTO(ACTUALLEFTMARGIN - INDENTINDEX);
             DOSTATEMENT(I, BLOCKNAME, BLOCKNMLENGTH);
 (*I = DUMMY PARAMETER*)
             LASTPROGPARTWASBODY := TRUE;
             CHANGEMARGINTO(ACTUALLEFTMARGIN + INDENTINDEX);
          END
       ELSE
          BEGIN WRITESYMBOL;   READSYMBOL;
 (*WRITE "FORWARD"*)
          END;
    END (*BLOCK*);

 PROCEDURE INITIALIZE;

    VAR
       I: WIDTH;

    BEGIN
"SZH" DIGITS := [ CHMAP['0'], CHMAP['1'], CHMAP['2'], CHMAP['3'],
"SZH"             CHMAP['4'], CHMAP['5'], CHMAP['6'], CHMAP['7'],
"SZH"             CHMAP['8'], CHMAP['9'] ];
       ALPHASYMBOLS := [PROGRAMSYMBOL, BEGINSYMBOL, ENDSYMBOL,
          CONSTSYMBOL, TYPESYMBOL, RECORDSYMBOL, CASESYMBOL,
          IFSYMBOL, THENSYMBOL, ELSESYMBOL, DOSYMBOL, OFSYMBOL,
          FORSYMBOL, WITHSYMBOL, WHILESYMBOL, REPEATSYMBOL,
          UNTILSYMBOL, IDENTIFIER, VARSYMBOL, VALUESYMBOL,
          PROCEDSYMBOL, FUNCTIONSYMBOL, LABELSYMBOL,
          ALPHAOPERATOR];
       ENDLABEL := [CONSTSYMBOL, TYPESYMBOL, VARSYMBOL,
          VALUESYMBOL, PROCEDSYMBOL, FUNCTIONSYMBOL, BEGINSYMBOL
          ];
       ENDCONST := ENDLABEL - [CONSTSYMBOL];
       ENDTYPE := ENDCONST - [TYPESYMBOL];
       ENDVAR := ENDTYPE - [VARSYMBOL];
       ENDVALUE := ENDVAR - [VALUESYMBOL];   WRITECOLUMN := 1;
       LEFTMARGIN := 0;   ACTUALLEFTMARGIN := 0;
       OUTPUTCOL := 1;   READCOL1 := 1;   READCOL2 := 999;
       WRITECOL1 := 1;   WRITECOL2 := 72;   OLDEST := 1;
       CHARCOUNT := 1;   LINENUMBER := 0;   INCREMENT := 0;
       PACKERISOFF := TRUE;   COMPRESSWANTED := FALSE;
       DISPLAYISON := TRUE;   DISPLAYWANTED := TRUE;
       NOFORMATTING := FALSE;   CROSSREFWANTED := FALSE;
       PROCEDNAMESWNTD := TRUE;   ENDCOMMENTSWNTD := FALSE;
       INDENTINDEX := 3;   LONGLINEINDENT := 3;
       PROCEDSEPARATION := 3;   SYMBOLGAP := 1;
       STATMTSEPARATION := 3;   DECLARALIGNMENT := 0;
       READCOLUMN := 0;   LASTSYMBOL := PERIODSYMBOL;
       LASTPROGPARTWASBODY := FALSE;
       READINGFORMATOPTIONS := FALSE;   PROGISPASCAL2 := FALSE;
       RESET(PROG);
    END (*INITIALIZE*);

 PROCEDURE READFORMATOPTIONS;

    BEGIN
       IF NOT EOF (*EOS*) (INPUT) THEN
          BEGIN
             READINGFORMATOPTIONS := TRUE;   READSYMBOL;
             READINGFORMATOPTIONS := FALSE;
          END;
    END (*READFORMATOPTIONS*);

 BEGIN (*MAINPROGRAM*)
"szh" init_chmap;
    (*MESSAGE*)
    WRITELN(OUTPUT, ' >>>> PASCAL PROGRAM FORMATTER VERS. 1/5/76 <<<<');
    (*MESSAGE*)
    WRITELN(OUTPUT, ' -----------------------------------------------');
    WRITELN(OUTPUT);

""" LINELIMIT(OUTPUT, - 1);    """
 (* UNLIMITED OUTPUT IS ALLOWED*)
    CONSTANTSINITIALIZATION;   INITIALIZE;   READFORMATOPTIONS;
    READACHARACTER;   WRITEA(' ');   READSYMBOL;
    PROGISPASCAL2 := SYMBOLNAME = PROGRAMSYMBOL;
    IF PROGISPASCAL2
    THEN
       BEGIN
          STARTNEWLINEANDINDENT;   WRITESYMBOL;   READSYMBOL;
          FOR I := 0 TO(LENGTH - 1) DIV 10 DO
"""          PACK(SYMBOL, (I * 10 + 1), MAIN[I + 1]);      """
"SZH"        FOR PQ := 1 TO ALFLEN DO MAIN[I+1,PQ] := SYMBOL[I*10+PQ];
          MAINNMLENGTH := LENGTH;
          REPEAT WRITESYMBOL;   READSYMBOL;
          UNTIL SYMBOLNAME = SEMICOLON;
          WRITESYMBOL;   READSYMBOL;   STARTNEWLINEANDINDENT;
          PSYMBOLNAME[7] := IDENTIFIER;
          PSYMBOLNAME[31] := IDENTIFIER;
          PSYMBOLNAME[32] := IDENTIFIER;
       END (*IF PROGISPASCAL2*);
    BLOCK(MAIN, MAINNMLENGTH);   WRITEA('.');   WRITEA(' ');
    WITH UNWRITTEN[OLDEST] DO
       BEGIN CHISENDLINE := TRUE;   INDENTAFTEREOL := 0; END;
    WRITECOLUMN := 0;   FOR I := 0 TO 159 DO WRITEA(' ');
    WRITELN(OUTPUT);

    IF SYMBOLNAME <> PERIODSYMBOL
    THEN (*MESSAGE*)  WRITELN(OUTPUT, ' >>>> ERROR(S) IN FORMATTING.');
    (*MESSAGE*)  WRITELN(OUTPUT, ' >>>> END FORMATTING');
 END (*MAINPROGRAM*).
PROGRAM PASCREF(INPUT,OUTPUT);      (*$D- N.WIRTH  2.7.75*)
(*CROSS REFERENCE GENERATOR FOR PASCAL PROGRAMS*)
(*QUADRATIC QUOTIENT HASH METHOD*)
(*MODIFIED SLIGHTLY BY A. MICKEL 75/12/08 AND D. LALIBERTE
  78/03/15 TO PRODUCE PROCEDURE LIST AND SKIP COMPILER TITLE*)
(*$T-,P-,R-,B4 TESTS OFF, PMD OFF, DYNAMIC STORAGE, BIG BUFFERS.*)
LABEL 99;
CONST P = 1499;     (*SIZE OF HASH TABLE*)
  NK = 33;          (*NO. OF KEYWORDS*)
  KLN = 10;         (*KEYLENGTH*)
  LPPG = 55;        (*NO. OF LINES PER PAGE*)
  LLMAX = 132;      (*LINE LENGTH DEFAULT MAX*)
  LLMIN = 72;       (*LINE LENGTH MINIMUM*)
  MAXN = 10000;     (*MAX NO. OF LINES*)
  DGPN =  6;        (*NO. OF DIGITS PER NUMBER*)
  LITL = 3;         (*NUMBER OF LINES IN COMPILER TITLE*)
  ADDRWIDTH = 6;    (*NUMBER OF DIGITS IN CODE ADDRESS*)
  EMPTY = '          ';
  STARS = ' *****';
TYPE INDEX = 0..P;
  ALFA = PACKED ARRAY [1..KLN] OF CHAR;
  REF = @ITEM;
  WORD = RECORD KEY: ALFA;
           FIRST: REF;
         END ;
  ITEM = PACKED RECORD
           LNO: 0..MAXN;
           NEXT: REF
         END ;
  PROCREF = @PROC;  (*PROCEDURE OR FUNCTION REFERENCE*)
  PROC = PACKED RECORD
           NAME: ALFA;
           LNO: 0..MAXN;
           NEXT: PROCREF
         END ;
VAR I: INDEX;
  K: INTEGER;
  M: INTEGER;       (*NO. OF LINES ON PAGE*)
  N: INTEGER;       (*NO. OF LINES INPUT*)
  LN: INTEGER;      (*CURRENT LINE NUMBER*)
  LLNGOUT: INTEGER; (*LINE LENGTH FOR OUTPUT*)
  LLNGIN: INTEGER;  (*LINE LENGTH FOR INPUT*)
  CCOUNT: INTEGER;  (*CHARACTER COUNT IN LINE*)
  NOPL: INTEGER;    (*NO. OF LINE-NUMBERS PER LINE*)
  ID: RECORD CASE BOOLEAN OF
             FALSE: (A: ALFA);
             TRUE:  (ORD: INTEGER)
      END ;
  T: ARRAY [INDEX] OF WORD;    (*HASH TABLE*)
  KEY: ARRAY [1..NK] OF ALFA;
  PROCORFUNC,
  COMPILERLISTING,
  LINENUMBERS: BOOLEAN;
  FIRSTPROC,
  PROCPTR: PROCREF; (*POINTERS TO CHAIN OF PROCEDURES*)


   FUNCTION LETTER(C: CHAR): BOOLEAN;

     BEGIN
     LETTER := (('A' <= C) AND (C <= 'Z')) OR
               (('a' <= C) AND (C <= 'i')) OR
               (('j' <= C) AND (C <= 'r')) OR
               (('s' <= C) AND (C <= 'z')) ;
     END ;

   FUNCTION DIGIT(C: CHAR): BOOLEAN ;

     BEGIN
     DIGIT := ('0' <= C) AND (C <= '9') ;
     END ;

   FUNCTION SPECIAL(C: CHAR): BOOLEAN;
     BEGIN  SPECIAL := (C = '$') OR (C = '_')  END ;

FUNCTION NOKEY: BOOLEAN;
   VAR I,J,K: INTEGER;
BEGIN I := 1; J := NK;   (*BINARY SEARCH*)
  REPEAT K := (I+J) DIV 2;
    IF KEY[K] <= ID.A THEN I := K+1 ELSE J := K-1
  UNTIL I > J;
  IF J = 0 THEN NOKEY := TRUE ELSE
    NOKEY := KEY[J] <> ID.A
END (*NOKEY*) ;

PROCEDURE COUNTLINE;
BEGIN
  IF M = LPPG THEN
    BEGIN PAGE(OUTPUT); WRITELN(OUTPUT);    WRITELN(OUTPUT);
      M := 0
    END;
  M := M + 1
END (*COUNTLINE*) ;

PROCEDURE ADVANCE;
BEGIN
  WRITE(OUTPUT,INPUT@); GET(INPUT);
  CCOUNT := CCOUNT + 1;
  IF CCOUNT = LLNGIN THEN
    WHILE NOT EOLN(INPUT) DO
      BEGIN WRITE(OUTPUT,INPUT@); GET(INPUT);
      END
END (*ADVANCE*);

PROCEDURE SPACE(J: INTEGER);
BEGIN
  REPEAT J := J-1; WRITELN(OUTPUT); COUNTLINE
  UNTIL J = 0
END (*SPACE*) ;

PROCEDURE NEWLINE;
BEGIN CCOUNT := 0;
  IF N < MAXN THEN
  BEGIN COUNTLINE;  N := N + 1;
    IF COMPILERLISTING THEN
      BEGIN IF NOT EOLN THEN
        BEGIN ADVANCE;
        IF NOT (INPUT@ IN ['0'..'9']) THEN  (* ERRORS *)
        IF NOT DIGIT(INPUT@) THEN  (* ERRORS *)
          WHILE NOT EOLN DO
            ADVANCE
        ELSE BEGIN
          FOR I := 1 TO ADDRWIDTH + 1  DO
            ADVANCE;
          WHILE (INPUT@ = ' ') AND NOT EOLN DO
            ADVANCE
          END
        END
      END
    ELSE WRITE(OUTPUT,' ');
    IF LINENUMBERS THEN
      BEGIN LN := 0;
      WHILE DIGIT(INPUT@) DO
      WHILE INPUT@ IN ['0'..'9'] DO
        BEGIN LN := 10*LN + ORD(INPUT@) - ORD('0');
          ADVANCE
        END
      END
    ELSE BEGIN
      LN := N;  WRITE(OUTPUT,LN:6, ' ')
      END
    END
  ELSE BEGIN
    WRITELN(STARS, ' TEXT TOO LONG', STARS);
     GOTO 99;  EXIT(99);
    END
END (*NEWLINE*) ;

PROCEDURE SEARCH;   (*MODULO P HASH SEARCH*)
  VAR H,D: INDEX;
      X: REF; F: BOOLEAN;
      K: INTEGER;
BEGIN  I := ABS(ID.ORD);  H := I MOD P;
  F := FALSE; D := 1;
  NEW(X); X@.LNO := LN;
  REPEAT
    IF T[H].KEY = ID.A THEN
    BEGIN (*FOUND*) F := TRUE;
      X@.NEXT := T[H].FIRST; T[H].FIRST := X;
    END ELSE
    IF T[H].KEY = EMPTY THEN
    BEGIN (*NEW ENTRY*) F := TRUE;
      T[H].KEY := ID.A;
      T[H].FIRST := X; X@.NEXT := NIL
    END ELSE
    BEGIN (*COLLISION*) H := H+D; D := D+2;
      IF H >= P THEN H := H-P;
      IF D = P THEN
        BEGIN WRITELN(OUTPUT); WRITELN(STARS,' TABLE FULL',STARS);    GOTO 99
        EXIT(99);
        END
    END
  UNTIL F
END (*SEARCH*) ;

PROCEDURE SORT(MIN, MAX: INTEGER);

(* QUICKSORT WITH BOUNDED RECURSION DEPTH *)
(* REQUIRES MIN <= MAX *)

   VAR
         LOW,
        HIGH: INDEX;
      MIDKEY: ALFA;
        TEMP: WORD;

   BEGIN
      REPEAT (*PICK SPLIT POINT*)
         MIDKEY := T[(MIN + MAX) DIV 2].KEY;
         LOW := MIN;
         HIGH := MAX;
         REPEAT (*PARTITION*)
            WHILE T[LOW].KEY < MIDKEY DO
               LOW := LOW + 1;
            WHILE T[HIGH].KEY > MIDKEY DO
               HIGH := HIGH - 1;
            IF LOW <= HIGH THEN
               BEGIN
                  TEMP := T[LOW];
                  T[LOW] := T[HIGH];
                  T[HIGH] := TEMP;
                  LOW := LOW + 1;
                  HIGH := HIGH - 1
               END;
         UNTIL LOW > HIGH;

         (*RECURSIVELY SORT SHORTER SUB-SEGMENT*)    (*A NOTE *)
         IF HIGH - MIN < MAX - LOW
         THEN    ¯ ANOTHER NOTE  ¯ A FORTH ONE 
            BEGIN
               IF MIN < HIGH THEN
                  SORT(MIN, HIGH);
  ¯THIS ONE   MIN := LOW
            END
" "      ELSE
            BEGIN
               IF LOW < MAX THEN
                  SORT(LOW, MAX);
               MAX := HIGH
               END
        UNTIL MAX <= MIN
   END " SORT" """(*SORT*)";


PROCEDURE " HERE " NOTEPROC;   (*NOTE INSTANCE OF PROCEDURE OR FUNCTION*)
  VAR P: PROCREF;
BEGIN PROCORFUNC := FALSE;
  NEW(P); PROCPTR@.NEXT := P;
  P@.NAME := ID.A; P@.LNO := LN; P@.NEXT := NIL;
  PROCPTR := P
END (*NOTEPROC*) ;

PROCEDURE PRINTWORD(W: WORD);
  VAR L: INTEGER; X,Y,Z: REF;
BEGIN COUNTLINE; WRITE(OUTPUT,' ', W.KEY);
  X := W.FIRST; Y := X@.NEXT; X@.NEXT := NIL;
  WHILE Y <> NIL DO
    BEGIN Z := Y@.NEXT; Y@.NEXT := X; X := Y; Y := Z
    END ;
  L := 0;
  REPEAT
    IF L = NOPL THEN
      BEGIN L := 0; WRITELN(OUTPUT); COUNTLINE; WRITE(OUTPUT,' ', EMPTY)
      END;
    L := L+1; WRITE(OUTPUT,X@.LNO: DGPN); X := X@.NEXT
  UNTIL X = NIL;
  WRITELN(OUTPUT);
END (*PRINTWORD*) ;

PROCEDURE PRINTTABLE;
  VAR I,M: INDEX;
BEGIN M := 0;    (*COMPRESS TABLE*)
  FOR I := 0 TO P-1 DO
    IF T[I].KEY <> EMPTY THEN
      BEGIN T[M] := T[I]; M := M+1
      END ;
  IF M > 0 THEN SORT(0,M-1);
  NOPL := (LLNGOUT-KLN-1) DIV DGPN;
  SPACE(2); WRITELN(' CROSS REFERENCE OF IDENTIFIERS,',
            ' LABEL DECLARATIONS AND GOTO STATEMENTS:');
  COUNTLINE; SPACE(1);
  FOR I := 0 TO M-1 DO PRINTWORD(T[I])
END (*PRINTTABLE*) ;

PROCEDURE PRINTPROCS;
BEGIN SPACE(1); COUNTLINE;
  WRITELN(' LIST OF PROCEDURES AND FUNCTIONS:');
  COUNTLINE; SPACE(1);
  PROCPTR := FIRSTPROC@.NEXT;
  WHILE PROCPTR <> NIL DO
    BEGIN WITH PROCPTR@ DO WRITELN(NAME:24,LNO:10);
      COUNTLINE; PROCPTR := PROCPTR@.NEXT
    END
END (*PRINTPROCS*) ;

PROCEDURE INITIALIZE;
  TYPE SETTING = PACKED RECORD
                   CASE SWITCH: BOOLEAN OF
                     TRUE: (ONOFF: CHAR);
                     FALSE: (SIZE: 0..999999)
                   END;
  VAR S: SETTING;
  FUNCTION OPTION(NAME: CHAR; VAR S: SETTING): BOOLEAN;
    EXTERNAL;
BEGIN N := 0; M := 0;
  LLNGIN := LLMAX; LLNGOUT := LLMAX;
   IF OPTION('U',S) THEN
    IF S.SWITCH AND (S.ONOFF = '+')
      THEN LLNGIN := LLMIN;
  IF OPTION('W',S) THEN
    IF S.SWITCH AND (S.ONOFF = '+')
      THEN LLNGOUT := LLMIN;
  FOR I := 0 TO P-1 DO T[I].KEY := EMPTY;
  NEW(PROCPTR); FIRSTPROC := PROCPTR; PROCPTR@.NEXT := NIL;
  PROCORFUNC := TRUE;   (*TO GET P R O G R A M NAME IN PROCEDURE INDEX*)
  KEY[ 1] := 'AND       '; KEY[ 2] := 'ARRAY     ';
  KEY[ 3] := 'BEGIN     '; KEY[ 4] := 'CASE      ';
  KEY[ 5] := 'CONST     '; KEY[ 6] := 'DIV       ';
  KEY[ 7] := 'DOWNTO    '; KEY[ 8] := 'DO        ';
  KEY[ 9] := 'ELSE      '; KEY[10] := 'END       ';
  KEY[11] := 'FILE      '; KEY[12] := 'FOR       ';
  KEY[13] := 'FUNCTION  '; KEY[14] := 'IF        ';
  KEY[15] := 'IN        '; KEY[16] := 'MOD       ';
  KEY[17] := 'NIL       '; KEY[18] := 'NOT       ';
  KEY[19] := 'OF        '; KEY[20] := 'OR        ';
  KEY[21] := 'PACKED    '; KEY[22] := 'PROCEDURE ';
  KEY[23] := 'PROGRAM   '; KEY[24] := 'RECORD    ';
  KEY[25] := 'REPEAT    '; KEY[26] := 'SET       ';
  KEY[27] := 'THEN      '; KEY[28] := 'TO        ';
  KEY[29] := 'TYPE      '; KEY[30] := 'UNTIL     ';
  KEY[31] := 'VAR       '; KEY[32] := 'WHILE     ';
  KEY[33] := 'WITH      '
END (*INITIALIZE*) ;

PROCEDURE SCANANDLISTINPUT;
BEGIN
  WHILE NOT EOF(INPUT) DO
  BEGIN NEWLINE;
    WHILE NOT EOLN(INPUT) DO
    CASE INPUT@ OF
     'a','b','c','d','e','f','g','h','i','j','k','l','m',
     'n','o','p','q','r','s','t','u','v','w','x','y','z',
     'A','B','C','D','E','F','G','H','I','J','K','L','M',
     'N','O','P','Q','R','S','T','U','V','W','X','Y','Z':
      BEGIN K := 0; ID.A := EMPTY;
        REPEAT
          IF K < KLN THEN
            BEGIN K := K+1; ID.A[K] := INPUT@
            END;
          ADVANCE
        UNTIL NOT(INPUT@ IN ['A'..'Z', '0'..'9']);
        UNTIL NOT(LETTER(INPUT@) OR DIGIT(INPUT@) OR SPECIAL(INPUT@));
        IF NOKEY THEN
        BEGIN SEARCH;
          IF PROCORFUNC THEN NOTEPROC
        END ELSE
        IF (ID.A = 'PROCEDURE ') OR (ID.A = 'FUNCTION  ') THEN
          PROCORFUNC := TRUE
      END;
     '0','1','2','3','4','5','6','7','8','9':
        REPEAT ADVANCE;
        UNTIL NOT (INPUT@ IN ['B','E','0'..'9']);
        UNTIL NOT DIGIT(INPUT@) ;
     '''':
      BEGIN (*STRING*)
        REPEAT ADVANCE;
        UNTIL (INPUT@ = '''') OR EOLN(INPUT);
        IF NOT EOLN(INPUT) THEN
          ADVANCE
      END;
#    '"':
      BEGIN (*COMMENT*)
        REPEAT ADVANCE;
          WHILE EOLN(INPUT) DO
            BEGIN WRITELN(OUTPUT); GET(INPUT); NEWLINE
            END
        UNTIL INPUT@ = '"';
        ADVANCE
      END;
     '(':
      BEGIN ADVANCE;
        IF INPUT@ = '*' THEN
        BEGIN (*COMMENT*) ADVANCE;
          REPEAT
            WHILE INPUT@ <> '*' DO
            BEGIN
              IF EOLN(INPUT) THEN
                BEGIN GET(INPUT); WRITELN(OUTPUT); NEWLINE
                END ELSE
                ADVANCE
            END ;
            ADVANCE
          UNTIL INPUT@ = ')';
          ADVANCE
        END
      END;
     '+','-','*','/',')','$','=',' ',',','.','[',']',
     ':','!','Ý','&','@','?','<','>','','\','^',';','#','_','%','':
      ADVANCE
    END (*CASE*) ;
    WRITELN(OUTPUT); GET(INPUT)
  END ;
END (*SCANANDLISTINPUT*) ;

PROCEDURE SKIPCOMPILERTITLE;
  VAR I: INTEGER;
BEGIN
  COMPILERLISTING := INPUT@ = '1';
  IF COMPILERLISTING THEN
  BEGIN I := 0; GET(INPUT);
    WHILE I < LITL DO
      BEGIN I := I + 1;
        WHILE NOT EOLN(INPUT) DO
          ADVANCE;
        READLN; WRITELN(OUTPUT);
      END;
    COUNTLINE;
    LINENUMBERS := TRUE
  END ELSE
  BEGIN WRITELN(OUTPUT); WRITELN(OUTPUT);
    LINENUMBERS :=    INPUT@ IN ['0'..'9']    DIGIT(INPUT@)
  END
END (*SKIPCOMPILERTITLE*) ;

BEGIN (*CROSSREF*)
   LINELIMIT(OUTPUT, MAXN);     PAGE(OUTPUT); INITIALIZE;
  IF NOT EOF(INPUT) THEN
  BEGIN SKIPCOMPILERTITLE;
    SCANANDLISTINPUT;    LINELIMIT(OUTPUT, MAXN);
    PRINTTABLE; PRINTPROCS
  END ELSE WRITELN(STARS,' NO PROGRAM FOUND TO CROSS REFERENCE',STARS);
99:END .
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB PINTERP  EXT PAS HEX -
(*$L+,C+,M-,D-*)
PROGRAM PCODE_INTERPRETER(OUTPUT);

(* ASSEMBLER AND INTERPRETER OF PASCAL CODE.  K.JENSEN, N.WIRTH, E.T.H. 15.3.73


NOTE FOR THE IMPLEMENTATION.
===========================
THIS INTERPRETER IS WRITTEN FOR THE CASE WHERE ALL THE FUNDAMENTAL
TYPES TAKE ONE STORAGE UNIT.
IN AN IMPLEMENTATION ALL THE HANDLING OF THE SP POINTER HAS TO TAKE
INTO ACCOUNT THE FACT TAHT THE TYPES MAY HAVE A LENGTH DIFFERENT FROM
ONE. SO IN PUSH AND POP OPERATIONS THE IMPLEMENTOR HAS TO INCREASE
AND DECREASE THE SP NOT BY 1 BUT BY A NUMBER DEPENDING ON THE TYPE
CONCERNED.
WHERE A COMMENT SAYS THAT SOME VARIABLE IS EXPRESSED 'IN UNITS OF
STORAGE' THE VALUE OF THIS VARIABLE MUST NOT BE CORRECTED, BECAUSE
THE COMPILER HAS COMPUTED IT TAKING INTO ACCOUNT THE LENGTHS OF THE
TYPES INVOLVED.
THE SAME HOLDS FOR THE HANDLING OF THE NP POINTER (WHICH MUST NOT BE
CORRECTED)                                                       *)

(* MODIFIED 20.7.76, S. WOOD, STANFORD.
   ===================================
THIS INTERPRETER HAS BEEN MODIFIED TO ACCEPT 'TYPED' P-CODE, AS
GENERATED BY THE S.L.A.C. COMPILER.
IN ADDITION, A DYNAMIC TRACE FEATURE HAS BEEN ADDED.  THE TRACE IS
TURNED ON OR OFF BY THE P-INSTRUCTIONS 'TON' AND 'TOF', RESPECTIVELY.
THE PRESENCE OF A 'TON' INSTRUCTION ANYWHERE IN THE SOURCE P-CODE
ALSO CAUSES A DUMP OF THE OBJECT CODE AFTER LOADING.
*)
(*$E*)
  (**********************************************************************
   *                                                                    *
   *                                                                    *
   *   P_Code Interpreter                                               *
   *                                                                    *
   *   This interpreter  interprets  the  P_Code  generated  by  the    *
   *   Stanford  Pascal  Compiler  when used in "PM"+"CM" mode (i.e.    *
   *   allocating one storage unit per basic data item).   It  reads    *
   *   the  P_Code  program to be interpreted from file 'PFILE', and    *
   *   sends its messages to the file 'OUTPUT'.  The  file  'OUTPUT'    *
   *   and  other predefined Pascal files may be used by the program    *
   *   being interpreted.                                               *
   *                                                                    *
   *   The   interpreter   can   provide   (optional)    statistical    *
   *   information about the program it is interpreting.  The P_Code    *
   *   related  statistics  are  sent  to  'SFL'  and  stack related    *
   *   information is directed to 'TRFILE'.  The size of the largest    *
   *   program that can be interpreted is determined by 'MAXPC'  and    *
   *   the  size  of  the  run  time  stack  is set by 'MAXSTK'.  By    *
   *   setting  'MAXPC  =  18500'  and  'STKMAX  =  30000'  you  can    *
   *   interpret the Compiler compiling  a  reasonably  large  (i.e.    *
   *   5000  lines)  program  and  the  interpreter will need a 600k    *
   *   region for such a compilation.  Also note that running Pascal    *
   *   programs in this nterpretive form is very expensive in  terms    *
   *   of  the  CPU  time  and  is not suggested as a normal mode of    *
   *   operation.                                                       *
   *                                                                    *
   *   further updates and new features will be listed below.           *
   *                                                                    *
   *                                                                    *
   *   -THE  PROBLEM  ASSOCIATED   WITH   'FORWARD   REFERENCE'   TO    *
   *   PROCEDURES IS FIXED AND SIZE OF 'STORE' AND 'CODE' ARRAYS ARE    *
   *   INCREASED   SO  THAT  THE  INTERPRETER  MAY  'INTERPRET'  THE    *
   *   P_COMPILER WHILE COMPILING AVERAGE SIZE PROGRAMS.                *
   *                                                                    *
   *   -THE  INTERPRETER  CAN  NOW  PROVIDE   DYNAMIC   AND   STATIC    *
   *   INFORMATION  ABOUT  THE  OCCURANCE  FREQUENCIES OF INDIVIDUAL    *
   *   P_INSTRUCTIONS AS WELL AS INSTRUCTION PAIRS.                     *
   *                                                                    *
   *       GETSTAT  -->  ENABLES 'COUNTING' PROCEDURES                  *
   *       STAT1    -->  PRINT DETAILED BREAKDOWN FOR EACH              *
   *                     INSTRUCTION BY THE OPERAND TYPE                *
   *       STAT2    -->  PRINT FREQUENCY OF ADDRESS/OPERAND             *
   *                     FOR LOD, STR, INC, DEC, IXA... ETC.            *
   *       STAT3    -->  PRINT FREQUENCY AND BRANCH DISTANCE            *
   *                     FOR JUMP INSTRUCTIONS.                         *
   *       STAT4    -->  PRINT INSTRUCTION PAIR STATISTICS              *
   *       STAT5    -->  PRINT MATRIX OF INSTRUCTION PAIR FREQUENCY.    *
   *       STAT6    -->  GENERATE PUSH/POP, CALL/RETURN STACK TRACE.    *
   *       STAT9    -->  PRINT FULL DETAILS OF THE ABOVE TABLES.        *
   *                                                                    *
   *       STAT4, STAT2 AND STAT3, IF ENABLED WHILE INTERPRETING,       *
   *       COULD BE QUITE COSTLY WITH THE COST INCREASING IN THAT       *
   *       ORDER. THE ADDED COST FOR THE STATIC STATISTICS              *
   *       (COLLECTED DURING THE LOADING PHASE) IS LESS DRAMATIC        *
   *       THOUGH.                                                      *
   *                                                                    *
   *                                                                    *
   *   -THE INTERPRETER HAS BEEN MODIFIED AND FIXED  TO  CONFORM  TO    *
   *   THE NEW P_CODE AS GENERATED BY THE APR_79 VERSION OF THE SLAC    *
   *   PASCAL  COMPILER,  THE MODIFICATION INVOLVES THE 'DEF', 'XJP'    *
   *   'NEW', 'SAV' AND 'RST' INSTRUCTIONS.                             *
   *                                                                    *
   *                                                                    *
   *                                Sassan Hazeghi,                     *
   *                                Computation Research Group,         *
   *                                Stanford Linear Accelerator Center  *
   *                                                                    *
   *                                                                    *
   *                                updated:  july 76                   *
   *                                          sep. 76                   *
   *                                          oct. 76                   *
   *                                          may  77                   *
   *                                          feb. 79                   *
   *                                          may. 79                   *
   *                                                                    *
   *                                                                    *
   **********************************************************************)

(*----------------------------------------------------------------------------*)


CONST  MAXPC       = 20000; (* SIZE OF PROGRAM AREA *)
       MAXCODE     = MAXPC; (* PROGRAM COUNTER RANGE *)
       MAXSTK      = 40000; (* TOTAL SIZE OF STACK+HEAP+CONSTANT POOL*)
"""    MAXSTK      = 30000; (* SIZE OF RUNTIME STACK *)
       OVERI       = 32010; (* SIZE OF INTEGER CONSTANT TABLE = 10 *)
       OVERR       = 32220; (* SIZE OF REAL CONSTANT TABLE = 210 *)
       OVERS       = 32300; (* SIZE OF SET CONSTANT TABLE =  80 *)
       OVERB       = 32400; (* SIZE OF BOUNDARY CONSTANT TABLE = 200 *)
       OVERM       = 35900; (* SIZE OF MULTIPLE CONSTANT TABLE = 2500 *) """
       LARGEINT    = 524288;  (* = 2**19 *)
      "MAXINT      = 2147483641 ;"
       MAXADR      = MAXINT     ;
       LTSIZE      = 550  ;   (* SIZE OF THE LINEARIZED 'COUNT' TABLE *)
       STRNGLEN    = 64;      (* MAX STRING LENGHT *)
       INPUTADR    = 6  ;     (* ABSOLUTE ADDRESS *)
       OUTPUTADR   = 7  ;
       PRDADR      = 8  ;
       PRRADR      = 9  ;
       QRDADR      = 10 ;
       QRRADR      = 11 ;
       LSTBUF      = 15 ;
       NILVAL      = MAXSTK;
       BLNK3       = '   ' ;  BLNK8 = '        ' ;
       MAXLBLCNT   = 1200 ; (* COUNT OF LABELS *)
       MAXLABEL    = 650 ;  (* COMPLETE COMPILER PROCESSING *)
       MINLABEL    = 360 ;  (*NEGATIVE INDICIES FOR PROCEDURE LABELS*)
       MAXPROC     = MINLABEL ;
       MINPROC     = 0 ;
       PTRSIZE     = 1 ;     (* HAS TO BE UPDATED FOR DIFFERENT DATA SIZES*)
       OSPARMLOC   = 16;     (* LOCATION FOR OSPARM VARIABLE *)
       LCAFTMST    = 16;     (* LOCATION AFTER MARK STACK *)
       SAVEAREA    = 16;     (* SAVE AREA FOR THE 370 IMPLEMENTATION*)
       TIMEDATELOC = 20;     (* LOCATION OF TIME/DATE PREDEF. VARS *)
       FUNCRSLT    = 0 ;     (* LOCATION (OFF MP) OF THE FUNC RESULT *)

       (* P-CODE INSTRUCTION MNEMONICS *)

       PABI =  0 ;   PABR =  1 ;   PADI =  2 ;   PADR =  3 ;
       PAND =  4 ;   PCHK =  5 ;   PCHR =  6 ;   PCSP =  7 ;
       PCUP =  8 ;   PDEC =  9 ;   PDEF = 10 ;   PDIF = 11 ;
       PDVI = 12 ;   PDVR = 13 ;   PENT = 14 ;   PEOF = 15 ;
       PEQU = 16 ;   PFJP = 17 ;   PFLO = 18 ;   PFLT = 19 ;
       PGEQ = 20 ;   PGRT = 21 ;   PINC = 22 ;   PIND = 23 ;
       PINN = 24 ;   PINT = 25 ;   PIOR = 26 ;   PIXA = 27 ;
       PLAO = 28 ;   PLCA = 29 ;   PLDA = 30 ;   PLDC = 31 ;
       PLDO = 32 ;   PLEQ = 33 ;   PLES = 34 ;   PLOC = 35 ;
       PLOD = 36 ;   PMOD = 37 ;   PMOV = 38 ;   PMPI = 39 ;
       PMPR = 40 ;   PMST = 41 ;   PNEQ = 42 ;   PNEW = 43 ;
       PNGI = 44 ;   PNGR = 45 ;   PNOT = 46 ;   PODD = 47 ;
       PORD = 48 ;   PPRE = 49 ;   PRET = 50 ;   PRST = 51 ;
       PSAV = 52 ;   PSBI = 53 ;   PSBR = 54 ;   PSGS = 55 ;
       PSQI = 56 ;   PSQR = 57 ;   PSRO = 58 ;   PSTO = 59 ;
       PSTP = 60 ;   PSTR = 61 ;   PUJP = 62 ;   PXJP = 63 ;
       PTON = 64 ;   PTRC = 65 ;   PSUC = 66 ;   PUNI = 67 ;
       PTOF = 68 ;   PBGN = 69 ;   PLCI = 70 ;   PCMP = 71 ;
       PNOP = 72 ;

       SPCNT = 32 ;                (* COUNT OF STANDARD PROCS *)

       UNDEF = '0' ;  INT = '1' ;  REEL = '2' ;  BOOL = '3' ;
       SETT  = '4' ;  ADR = '5' ;  MARK = '6' ;  INDEX= '7' ;
"""    UNDEF = 0 ;  INT = 1 ;  REEL = 2 ;  BOOL = 3 ;
       SETT  = 4 ;  ADR = 5 ;  MARK = 6 ;  INDEX= 7 ;   """

      "ENTERED = 0 ;  DEFINED = 1 ;"
(*----------------------------------------------------------------------------*)

TYPE  BIT4         = 0..MAXLBLCNT ;
      BIT7         = 0..70;
      BIT20        = -524287..524287;
      OPRNG        = 0..PNOP;
      DATATYPE     = CHAR (* I.E. UNDEF..INDEX *) ;
      LBLRNG       = MINPROC..MAXLABEL ;
      LBLCNTRNG    = 0..MAXLBLCNT ;
      ADDRESS      = -1..MAXSTK;
      POSINT       = 0..MAXADR ;
      ALFA         = PACKED ARRAY [1..8] OF CHAR ;
      SHRTALFA     = PACKED ARRAY [1..3] OF CHAR ;
      BETA         = PACKED ARRAY[1..20] OF CHAR; (*ERROR MESSAGE*)
      COUNTER      = 0..MAXINT ;
      COUNTER1     = -1..MAXINT ;

      LABELST      = (ENTERED,DEFINED);  (* LABEL SITUATION *)
      LABELREC     = RECORD
         VAL: -1..MAXADR  ;
         ST: LABELST
         END ;

      TEXT         = FILE OF CHAR ;

      CNTBIN       = RECORD
                       VAL :  INTEGER ;
                       CNT :  COUNTER ;
                       NXT :  @ CNTBIN
                     END ;

(*----------------------------------------------------------------------------*)
VAR
     (* INSTRUCTION REGISTER, OPCODE, T, P AND Q FIELDS *)

     OP, OLDOP     : -1..PNOP;
     T             : DATATYPE;
     P             : ADDRESS;
     Q             : INTEGER;

     (* MP:      ACTIVATION RECORD POINTER,
        SP:      TOP ELEMENT OF EXPRESSION EVALUATION STACK,
        NP:      POINTER TO NEXT AVAILABLE HEAP AREA (GROWS DOWN !)
        EP:      PROGRAM ENTRY POINT,
        CPL:     END OF THE HEAP, BEGINING OF CONSTANT POOL,
        PC:      P_PROGRAM COUNTER,
        CURLVL:  STATIC LEVEL OF CURRENTLY ACTIVE PROCEDURE,         *)

     MP,
     SP,
     NP,
     EP,
     CPL           : ADDRESS;
     PC            : 0..MAXPC;
     CURLVL        : BIT4;

     (* VARIOUS SWITCHES AND COUNTERS *)

     LOADING,
     STRACE,
(*   CTRACE,                                                              (*+*)
     INTERPRETING,
     GETSTAT,
     STAT1,
     STAT4,
     STAT2,
     STAT3,
     STAT5,
     STAT6,
     STAT9,
     TRCE, DMP      : BOOLEAN;

     PUSHCNT,
     POPCNT,
     MAXCALL,
     CSTP,
     TBUFP,
     INSTRCNT      : INTEGER;

     STK_LMT,
     HEAP_LMT      : ADDRESS;

     (* VARIOUS TABLES, BUFFERS AND COUNTER ARRAYS *)

     INSTR         : ARRAY[PABI..PNOP] OF SHRTALFA;(*MNEMONIC INST. CODES *)
     DISPLAY       : ARRAY [1..10] OF ADDRESS ;

     PINX, QINX,                                       (* INDEX TO SCNT *)
     PCNT          : ARRAY [PABI..PNOP] OF INTEGER ;   (* P_INST. COUNTS *)
     ACNT          : ARRAY [PABI..PNOP] OF @ CNTBIN ;  (* CONST. VALUE COUNTS *)
     SCNT          : ARRAY [0..LTSIZE] OF INTEGER ;    (* SPECIAL INST. COUNT.*)
     TBUF:           ARRAY[0..79] OF CHAR;            (* PUSH/POP TRACE BUF *)

     (* P_MACHINE CODE AND DATA SPACES *)

     CODE          : ARRAY[0..MAXCODE] OF   (* THE PROGRAM *)
                     PACKED RECORD  OP1    :INTEGER; ":BIT7;"
                                   "P1     :BIT4;"
                                    Q1     :INTEGER";
                                    T1     :DATATYPE ;
                                    OP2    :BIT7;
                                    P2     :BIT4;
                                    Q2     :INTEGER ;
                                    T2     :DATATYPE  "
                            END;

     STYPE:          ARRAY [ADDRESS] OF DATATYPE;

     STORE         : ARRAY [ADDRESS] OF
                        RECORD   CASE "STYPE :"DATATYPE OF
                                INT        :(VI :INTEGER);
                                REEL       :(VR :REAL);
                                BOOL       :(VB :BOOLEAN);
                                SETT       :(VS :SET OF 0..63);
                                ADR        :(VA :ADDRESS); (*ADDRESS IN STORE*)
                                MARK       :(VM :INTEGER)
                        END;

     SPTABLE       : ARRAY[0..SPCNT] OF SHRTALFA;   (* STANDARD FNS AND PROCS *)
        PROCTAB       : ARRAY [MINPROC..MAXPROC] OF ALFA ;
     BDCNT         : ARRAY [LBLCNTRNG] OF
                           RECORD  CNT: COUNTER1 ;  VAL : INTEGER  END ;

     CORTBL        : ARRAY[PABI..PNOP,PABI..PNOP] OF INTEGER ;  (* INST. PAIR *)

     STRBUF:         ARRAY[0..STRNGLEN] OF CHAR;  (* BUFFER FOR STRING CONST. *)
     HEADLN:         ARRAY[1..36] OF CHAR;        (* HEADING OF THE P_PROGRAM *)
     IVECTOR       : ARRAY['A'..'Z'] OF INTEGER ; (* INDEX INTO P_CODE TABLE *)
     CALLSTK:        ARRAY[0..100] OF INTEGER;    (* NEST OF CALL STACK *)

     NEEDOPNDS     : SET OF 0..63 ;  (* OPCODES THAT HAVE OPERANDS *)

     NXTUJP,NXTFJP : LBLCNTRNG ;
     TIMER,
     RETCDE,
     GAC, IAC, LAC:  INTEGER;               (* GLOBAL/LOCAL/INT. ACCESS *)

     (* INTERPRETER I/O FILE DEFINITIONS *)

     PFILE         : TEXT ;                 (* P_CODE INPUT FILE *)

     SFL           : TEXT ;                 (* INTERP. STATISTICS OUTPUT FILE *)

     TRFILE        : TEXT ;                 (* STACK ACTIVITY TRACE FILE *)


(*$D-*)
(*----------------------------------------------------------------------------*)

PROCEDURE STK_TRACE ;

   (* TO GENERATE THE TRACE OF STACK ACTIVITY PUSH/POP AS WEEL AS CALL/RET. *)
   (* OUTPUTS AN 'A' TO 'TRFILE' FILE TO INDICATE A  PUSH         *)
   (*            'S' "    "      "        "          POP          *)
   (*            'P' "    "      "        "          POP PARM.    *)
   (*            'C' "    "      "        "          CALL         *)
   (*            'R' "    "      "        "          RETURN       *)
   (*                                                             *)

   VAR I, J: INTEGER;

   PROCEDURE DOPUSH(C: CHAR) ;

      BEGIN
      IF STRACE "AND (C IN ['C', 'R'])" THEN
         BEGIN  PUSHCNT := PUSHCNT+1;  TBUF[TBUFP] := C;  TBUFP := TBUFP+1;
         IF TBUFP = 80 THEN  BEGIN  WRITE(TRFILE,TBUF);  TBUFP := 2;  END;
         END;
      END (*DOPUSH*);


   PROCEDURE DOPOP(C: CHAR);

      BEGIN
      IF STRACE "AND (C IN ['C', 'R'])" THEN
         BEGIN  POPCNT := POPCNT+1;  TBUF[TBUFP] := C;  TBUFP := TBUFP+1;
         IF TBUFP = 80 THEN  BEGIN  WRITE(TRFILE, TBUF);  TBUFP := 2  END;
         END;
      END (*DOPOP*);



   BEGIN

      CASE OP OF

      PLCA, PLCI, PLDC, PLOD, PLDA :
         DOPUSH('A');

      PABI, PABR, PNGI, PNGR, PNOT:
         BEGIN  DOPOP('S');  DOPUSH('A');  END;

      PEQU, PNEQ, PGRT, PGEQ, PLES, PLEQ,
      PADI, PSBI, PMPI, PDVI, PMOD, PADR,
      PSBR, PMPR, PDVR, PAND, PIOR,
      PDIF, PINT, PUNI, PINN:
         BEGIN  DOPOP('S');  DOPOP('S');  DOPUSH('A')  END;

      PSTR, PIXA, PXJP, PFJP,
      PNEW, PSAV, PRST:
         DOPOP('S');

      PSTO, PMOV :
         BEGIN  DOPOP('S'); DOPOP('S') END ;

      PMST :
         BEGIN  CSTP := CSTP+1 ;  CALLSTK[CSTP] := PUSHCNT-POPCNT ; END ;

      PCUP :
         BEGIN  J := (PUSHCNT-POPCNT)-CALLSTK[CSTP] ;
         FOR I := 1 TO J DO DOPOP('P') ;  (*POPS PARAMETERS OFF THE STACK*)
         IF LOADING THEN
            BEGIN
            IF T <> UNDEF THEN DOPUSH('A');  (*FUNCTION CALL LEAVES A RESULT*)
            IF MAXCALL < CSTP THEN  MAXCALL := CSTP;
            CSTP := CSTP-1;
            END
         ELSE  (*I.E. INTERPRETING*)  DOPUSH('C');

         END ;

      PCSP :
         BEGIN
         IF Q = 28 (*PSIO*) THEN  STRACE := FALSE
         ELSE IF Q = 29 (*PEIO*) THEN  BEGIN  STRACE := TRUE;  DOPOP('S')  END
         ELSE IF Q IN [24, 7 (*PEOF, PELN*)] THEN
            BEGIN STRACE := TRUE; DOPUSH('A');  STRACE := FALSE END
         ELSE IF Q IN [14, 15, 16, 17, 18, 19
                      (*PSIN, PCOS, PATN, PEXP, PLOG, PSQT*)] THEN
                      BEGIN  DOPOP('S');  DOPUSH('A');  END
         ELSE IF Q IN [2, 4, 20 (*PRST, PNEW, PSAV*)] THEN  DOPOP('S')
         END ;

      PRET :
         IF INTERPRETING THEN
            BEGIN
            IF MAXCALL < CSTP THEN MAXCALL := CSTP;
            IF T <> UNDEF THEN DOPUSH('A');
            DOPOP('R');  (*FLAG PROC. RETURN*)
            CSTP := CSTP-1;
            END;


      END (*CASE OP OF*);


   END (*STK_TRACE*);

(*----------------------------------------------------------------------------*)


FUNCTION  WRF(VAR F:TEXT; X: REAL; M,N: INTEGER): CHAR;
   (* WRITE REAL NUMBER X IN FIXED-POINT FORMAT;
    M CHARACTERS, N AFTER THE '.' *)
   CONST T31 = 214731364(*7*);  (* (2**32-1) DIV 10 *)
         REALT31 = 214731364.0;
     (*  Z = 27; *)   (* ORD('0') *)
   TYPE POSINT = 0..99;
   VAR C,D,E,R,K2,K3,I: INTEGER;
       SIGN: CHAR;

BEGIN
   IF ABS(X) > T31*10  THEN
   BEGIN FOR I:=1 TO N-1 DO BEGIN F@:='#'; PUT(F) END;
      F@:='U'; PUT(F)
   END ELSE
   BEGIN
      IF X<0 THEN
         BEGIN SIGN := '-'; X := -X
         END ELSE SIGN := ' ';

     IF X < 1.0E-10 THEN X := 0;

      (* X = 0: A SPECIAL CASE *)
      IF X=0 THEN
      BEGIN  REPEAT  F@ := ' '; PUT(F); M := M-1 UNTIL M<=1;
             F@ := '0'; PUT(F)
      END ELSE
      BEGIN (* CHECK SIGN AND DETERMINE SCALE FACTOR *)
         (*E := EXPO(X);*)   E := 0;
         IF X >= 1.0 THEN
            REPEAT  X := X(*/10.0*) * 0.1; E := E + 1   UNTIL X < 1.0

         ELSE  IF X < 0.1 THEN
                  REPEAT  X := X * 10.0; E := E - 1   UNTIL X >= 0.1 ;

         (* 0.1 <= X < 1.0 *)
         R := N+E;

         IF (R >= 1) OR (R <= 9) THEN

            CASE R OF      (* ROUNDING *)
              1: X := X+0.5E-1;
              2: X := X+0.5E-2;
              3: X := X+0.5E-3;
              4: X := X+0.5E-4;
              5: X := X+0.5E-5;
              6: X := X+0.5E-6;
              7: X := X+0.5E-7;
              8: X := X+0.5E-8;
              9: X := X+0.5E-9;
             10: X := X+0.5E-10;
             11: X := X+0.5E-11;
             12: X := X+0.5E-12;
             13: X := X+0.5E-13
            END

         ELSE X := X+0.5E-9;

         IF X >= 1.0 THEN  BEGIN X := X * 0.1; E := E+1 END ;
         IF E>0 THEN BEGIN M := M-N-E-2;  K2 := E;  K3 := 0  END
         ELSE
         BEGIN M := M-N-3;  K2 := 0;
            IF N+E >= 0 THEN K3 := -E ELSE K3 := N;
            N := N-K3
         END;
         IF M <= 0 THEN M := (*1*) 0;
         (* M BLANKS, SIGN, K2 DIGITS, '.', K3 ZEROES, N DIGITS *)
         WHILE M > 0 DO BEGIN    F@ := ' '; PUT(F); M := M-1  END ;
         F@ := SIGN; PUT(F);
         C := TRUNC(X*REALT31+0.5); D := 0;
         IF K2=0 THEN BEGIN F@ := '0'; PUT(F) END ELSE
            REPEAT C := (C - D*T31) * 10;
                   D := C DIV T31;
                  F@ := CHR(D+ ORD('0') ); PUT(F);  K2 := K2-1
            UNTIL K2=0;
         F@ := '.'; PUT(F);
         WHILE K3<>0 DO
            BEGIN F@ := '0'; PUT(F); K3 := K3-1
            END;
         WHILE N<>0 DO
         BEGIN C := (C - D*T31) * 10;
               D := C DIV T31;
               F@ := CHR(D+ ORD('0') ); PUT(F); N := N-1
         END
      END
   END ;
   WRF := ' ';
END (* WRF *);

(*----------------------------------------------------------------------------*)

   PROCEDURE PRINT_HEADLN(VAR F: TEXT);

   BEGIN
   REWRITE(F);
   WRITELN(F, '    < Stanford P_Code Interpreter, Version of May 79. >');
   WRITELN(F);  WRITELN(F);

   IF LOADING THEN
      BEGIN
      WRITELN(F, '    < P_INSTRUCTIONS'' STATIC STATISTICS >') ;
      WRITELN(F);  WRITELN(F);
      WRITELN(F, '    >>>>  LOADING: ', HEADLN);
      WRITELN(F);  WRITELN(F);
      WRITELN(F, '>>>>  ':10,  PC:5, ' INSTRUCTIONS AND  ',
                 MAXSTK-CPL-1:1, ' CONSTANTS LOADED, ',
                 WRF(F, TIMER/1000, 6, 1):01, ' SECONDS IN LOADING.') ;
      END
   ELSE
      BEGIN
      WRITELN(F, '    < P_INSTRUCTIONS'' DYNAMIC STATISTICS >') ;
      WRITELN(F);  WRITELN(F);
      WRITELN(F, '    >>>>  INTERPRETING: ', HEADLN);
      WRITELN(F);  WRITELN(F);
      WRITELN(F,'    --->  I_CNT:  ',INSTRCNT:4,',  SP: ', SP:5,',  NP: ', NP:4,
                ',  MP: ',MP:4, ',  PC: ',  PC:5, '  OP =', INSTR[OP]:4,
                '  (', OP:3, '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:5, ')' );
      WRITELN(F);  WRITELN(F);
      WRITELN(F, '>>>>  ':10, INSTRCNT:5, ' INSTRUCTIONS INTERPRETED IN  ',
                 WRF(F, TIMER/1000, 8, 1):01, ' SECONDS.' ) ;
      WRITELN(F);  WRITELN(F);
      WRITELN(F, '>>>>  ':10, ' TOTAL STACK USAGE= ',STK_LMT:2,
                 ',  HEAP USAGE= ', CPL-HEAP_LMT:2, '  STORAGE UNITS.');
      END (*IF INTERPRETING*);

   END (*PRINT_HEADLN*);

(*------------------------------------------------------------------------*)


PROCEDURE CLEARCOUNTS ;      (*TO CLEAR STATIC/DYNAMIC COUNTERS*)
   VAR  I, J : INTEGER ;   PTR : @CNTBIN ;
   BEGIN   OLDOP := PNOP ;

   FOR I := PABI TO PNOP DO
      BEGIN  PCNT[I] := 0 ;  PINX[I] := 0 ;
      PTR := ACNT[I] ;
      REPEAT  PTR@.CNT := 0 ;  PTR := PTR@.NXT ;   UNTIL PTR = NIL ;
      FOR  J := PABI TO PNOP DO  CORTBL[I,J] := 0 ;
      END ;

   PINX[PRET] :=   0 ;  PINX[PLDA] :=  10 ;  PINX[PEQU] :=  20 ;
   PINX[PGEQ] :=  26 ;  PINX[PGRT] :=  32 ;  PINX[PLDC] :=  38 ;
   PINX[PLEQ] :=  44 ;  PINX[PLES] :=  50 ;  PINX[PNEQ] :=  56 ;
  "PINX[PRET] :=  62 ;" PINX[PIND] :=  68 ;  PINX[PLDO] :=  74 ;
   PINX[PSRO] :=  80 ;  PINX[PSTO] :=  86 ;  PINX[PCUP] :=  92 ;
   PINX[PLOD] := 152 ;  PINX[PSTR] := 212 ;  PINX[PCSP] := 272 ;
   PINX[PMST] := 304 ;  PINX[PENT] := 320 ;

   QINX[PLOD] := 380 ;  QINX[PSTR] := 450 ;  QINX[PLDA] := 520 ;
   QINX[PMST] := 530 ;

   FOR I := 0 TO LTSIZE DO SCNT[I] := 0 ;

   FOR I := 0 TO MAXLBLCNT DO BDCNT[I].CNT := 0 ;

   PUSHCNT := 0;  POPCNT := 0;  CSTP := 0;                 (*++++++++*)
   TBUFP := 2;  MAXCALL := 0;  STRACE := TRUE;             (*++++++++*)
(*    CTRACE := TRUE;                                                     (*+*)
   TBUF[0] := '$';  TBUF[1] := ' ';                        (*++++++++*)
   IF INTERPRETING THEN TBUF[0] := '#';                    (*++++++++*)
   END (*CLEARCOUNTS*) ;
(*----------------------------------------------------------------------------*)

PROCEDURE COUNT ;            (*TO ACCUMULATE STSTIC/DYNAMIC INSTR. COUNTS*)
   VAR  J, K, TT : INTEGER ;   PTR, PTR2: @ CNTBIN ;
   BEGIN
   IF STAT6 THEN  STK_TRACE;                                       (*+++++++++*)
   PCNT[OP] := PCNT[OP]+1 ;

     IF STAT1 THEN

       BEGIN   TT := ORD(T)-ORD(UNDEF);  J := PINX[OP];

       CASE OP OF

          PLDA,PMST:  (* SEGREGATE BY LEVEL *)
             BEGIN
             SCNT[ J  + P] := SCNT[ J  + P] + 1 ;
             K := CURLVL-P;
             SCNT[QINX[OP]+K+ TT] := SCNT[QINX[OP]+K+ TT]+1;

             IF LOADING THEN
                IF OP = PLDA THEN
                   IF P = 1 THEN GAC := GAC+1
                   ELSE IF P = CURLVL THEN LAC := LAC+1
                   ELSE               IAC := IAC+1;

             END;

          PRET,PEQU,PGEQ,PGRT,PLDC,PLEQ,PLES,PNEQ:
          (* SEGREGATE BY TYPE *)
             SCNT[ J  + P] := SCNT[ J  + P] + 1 ;

          PIND,PSTO",PLDO,PSRO":  (* SEGREGATE BY TYPE *)
             BEGIN
                SCNT[ J  + TT] := SCNT[ J  + TT] + 1  ;
             END  (* IND,STO",LDO,SRO" *) ;

          PLOD,PSTR:  (* SEGREGATE BY TYPE AND LEVEL *)
             BEGIN
                SCNT[ J  + P * 6 + TT] := SCNT[ J  + P * 6 + TT] + 1;;
                K := 6*(CURLVL-P);
                SCNT[QINX[OP]+K+ TT] := SCNT[QINX[OP]+K+ TT]+1;

             IF LOADING THEN
                IF P = 1 THEN GAC := GAC+1
                ELSE IF P = CURLVL THEN LAC := LAC+1
                ELSE               IAC := IAC+1;

             END  (* PLOD,PSTR *) ;

          PCUP,PENT:  (* SEGREGATE BY TYPE AND LEVEL *)
             BEGIN
                SCNT[ J  + P * 6 + TT] := SCNT[ J  + P * 6 + TT] + 1;;
             END  (* PCUP,PENT *) ;

          PCSP:  (* SEGREGATE BY PROCEDURE NUMBER *)
             SCNT[ J  + Q] := SCNT[ J  + Q] + 1 ;

          PABI,PABR,PADI,PADR,PAND,PCHK,PCHR,PDEC,PDIF,PDVI,PDVR,
          PEOF,PFJP,PFLO,PFLT,PINC,PINN,PINT,PIOR,PIXA,PLAO,PLCA,
          PLOC,PMOD,PMOV,PMPI,PMPR,PNGI,PNGR,PNOT,PODD,PORD,
          PPRE,PSBI,PSBR,PSGS,PSQI,PSQR,PSTP,PSUC,PTOF,PTON,PTRC,
          PUJP,PUNI,PXJP,PLCI:
             PINX[OP] := PINX[OP] + 1

       END  (* CASE OP *) ;


    """IF OP <= PSTR THEN
          BEGIN

          IF OP IN [PLOD, PSTR, PLDA, PMST] THEN
             BEGIN
             IF OP IN [PMST, PLDA] THEN  K := CURLVL-P  ELSE  K := 6*(CURLVL-P);
             SCNT[QINX[OP]+K+ TT] := SCNT[QINX[OP]+K+ TT]+1;
             END;

          IF LOADING THEN
             IF OP IN [PLOD, PSTR, PLDA] THEN
                IF P = 1 THEN GAC := GAC+1
                ELSE IF P = CURLVL THEN LAC := LAC+1
                ELSE               IAC := IAC+1;

          END (* OP <= PSTR *); """


      END (* IF STAT1 *);

   IF STAT2 THEN  (* COLLECT DATA OCCURANCE COUNTS *)
      IF OP <= 63 THEN
         IF OP IN [PNEW,PINC,PDEC,PIND,PLDA,PLOD,PSTR,PCSP,PMOV,PIXA,PLDC] THEN
            IF (OP <> PLDC) OR (P = 1) THEN
               BEGIN   PTR := ACNT[OP] ;      (* OCCURANCE COUNT OF CONSTANS *)

               WHILE (PTR@.VAL < Q)"AND (PTR@.NXT <> NIL)"DO  PTR := PTR@.NXT ;

               IF PTR @.VAL <>  Q THEN
                  BEGIN  NEW(PTR2) ;
                  PTR2@ := PTR@ ;
                  PTR@.NXT := PTR2 ;  PTR@.CNT := 0 ;  PTR@.VAL := Q ;
                  END ;
               PTR@.CNT := PTR@.CNT+1 ;
               END (* COUNTING OCCURANCES OF CONSTANT VALUES *) ;

   IF STAT4 THEN  BEGIN  CORTBL[OLDOP,OP] := CORTBL[OLDOP,OP]+1 ;
                  OLDOP := OP ;
                  END ;
   END (*COUNT*) ;
(*----------------------------------------------------------------------------*)


PROCEDURE PRINTCOUNTS ;     (*TO PRINT STATIC/DYNAMIC STATISTICS*)
   VAR   I, J, K, L, M, S,
         COLS:                INTEGER ;
         SL                 : REAL;       (* SCALED TOTAL CNT *)
         PTR                : @ CNTBIN ;
         COLNDX             : ARRAY [0..30] OF INTEGER ;
         OPMAP               : ARRAY [0..5] OF OPRNG;
                                    (*INDEX OF NON ZERO COLS*)
(*----------------------------------------------------------------------------*)

   PROCEDURE PRINT_STK_TRACE;
      BEGIN
      WRITELN(TRFILE, TBUF:TBUFP);  WRITELN(TRFILE);        (*++++++*)

      WRITELN(TRFILE,'    PUSHCNT, POPCNT, MAXCALL: ',
              PUSHCNT:10,POPCNT:10, MAXCALL:5);
      WRITELN(SFL);
      WRITELN(SFL, '    PUSHCNT, POPCNT, MAXCALL: ',
              PUSHCNT:10,POPCNT:10, MAXCALL:5);
      WRITELN(SFL);
      END (*PRINT_STK_TRACE*);

(*----------------------------------------------------------------------------*)

   PROCEDURE SORTJ(LB,UB: LBLCNTRNG) ;  (*TO SORT/PRINT JUMP DISTANCE TABLES*)
      VAR  I, N      : LBLCNTRNG ;
           J, K, L1  : INTEGER ;
           TCNT, NEGCNT, BINCNT,
           CUMCNT    : COUNTER ;
           INX       : ARRAY [LBLCNTRNG] OF LBLCNTRNG ;
      BEGIN     (* TO SORT AND PRINT BRANCH DISTANCES *)
      INX[0] := NXTFJP ;   BDCNT[NXTFJP].VAL := MAXADR ;
      TCNT := 0 ;  NEGCNT := 0 ;
      FOR I := LB TO UB DO
         BEGIN
         WITH BDCNT[I] DO
            BEGIN   K := VAL ;
            TCNT := TCNT+CNT ;   IF K < 0 THEN NEGCNT := NEGCNT+CNT ;
            END ;
         J := -1 ;
         REPEAT   J := J+1   UNTIL K < BDCNT[ INX[J] ].VAL ;
         FOR  N := I-LB DOWNTO J DO   INX[N+1] := INX[N]  ;
         INX[J] := I ;
         END ;

      IF TCNT > 0 THEN
         BEGIN
         WRITELN(SFL,'1--> ', INSTR[OP], '   (BRANCH  DISTANCE  COUNTS.)',
                     '   TOTAL COUNT: ', TCNT:4, WRF(SFL, TCNT*SL, 8, 2):0);
         WRITELN(SFL) ;       (* PRINT BACKWARD BRANCH DISTANCES *)
         L1 := -1024 ;   BINCNT := 0 ;  CUMCNT := 0  ;   I := 0 ;

         IF NEGCNT > 0 THEN
            REPEAT
            WITH BDCNT[ INX[I] ] DO
               IF VAL <= L1 THEN  BEGIN  BINCNT := BINCNT+CNT ;  I := I+1  END
               ELSE
                  BEGIN   CUMCNT := CUMCNT+BINCNT ;
                  WRITELN(SFL, L1:16, BINCNT:8, CUMCNT:8, NEGCNT-CUMCNT:10,
                               WRF(SFL, (NEGCNT-CUMCNT)/TCNT*100, 8, 2):0) ;
                  L1 := L1 DIV 2 ;  BINCNT := 0 ;
                  END ;
            UNTIL L1 = 0 ;

         WRITELN(SFL) ;   (* NOW PRINT FORWARD BRANCH DISTANCES *)

         CUMCNT := TCNT-CUMCNT ;  NEGCNT := CUMCNT ;   L1 := 1 ;

         IF NEGCNT > 0 THEN
            BEGIN
            REPEAT
            WITH BDCNT[ INX[I] ] DO
               IF VAL < L1 THEN  BEGIN  BINCNT := BINCNT+CNT ;  I := I+1   END
               ELSE
                  BEGIN
                  WRITELN(SFL,L1 DIV 2:16, BINCNT:8, CUMCNT:8, NEGCNT-CUMCNT:10,
                              WRF(SFL, (NEGCNT-CUMCNT)/TCNT*100, 8, 2):0) ;
                  CUMCNT := CUMCNT-BINCNT ;  L1 := L1*2 ;  BINCNT := 0 ;
                  END ;
            UNTIL CUMCNT = 0 ;

            WRITELN(SFL, L1 DIV 2:16, BINCNT:8, CUMCNT:8, NEGCNT-CUMCNT:10,
                         WRF(SFL, (NEGCNT-CUMCNT)/TCNT*100, 8, 2):0) ;
            END (* IF NEGCNT > 0 ... *);
         WRITELN(SFL);
         WRITELN(SFL, '     BKWRD JUMPS,  FRWRD JUMPS,  RATIOS: ',
                      TCNT-NEGCNT:6, ' ',NEGCNT:6,
                      WRF(SFL, (TCNT-NEGCNT)/TCNT*100, 10, 2):0,
                      WRF(SFL, (NEGCNT)/TCNT*100, 10, 2):0 );

         WRITELN(SFL) ;

         END (* IF TCNT > 0 ... *);

      IF (OP = PFJP) AND (PCNT[PFJP] > 0) THEN
         IF NOT(INTERPRETING OR LOADING) THEN
            (* SUCCESSFUL/UNSUCCESSFULL BRANCHES *)
            WRITELN(SFL, '     TOTAL ''FJP'' COUNT,  SUCC. BRANCHES,  RATIO : ',
                         PCNT[PFJP]:6, ' ', TCNT:6,
                         WRF(SFL, TCNT/PCNT[PFJP]*100, 10, 2):0);

      IF STAT9 AND (TCNT > 0) THEN
         BEGIN   WRITELN(SFL);  WRITELN(SFL);
         FOR I := 0 TO UB-LB DO
            WRITELN(SFL,BDCNT[ INX[I] ].VAL:16, BDCNT[ INX[I] ].CNT:8) ;
         END (* IF STAT9 *) ;

      WRITELN(SFL) ;

      END (*SORTJ*) ;
(*----------------------------------------------------------------------------*)

   PROCEDURE SORTP ;       (*TO SORT/PRINT INSTRUCTION PAIR FREQUENCIES*)
      CONST ML = 120 ;   ML1 = 121 ;
      VAR  I, J       : PABI..PNOP ;
           K          : INTEGER ;
           N          : 0..ML ;
           M          : 0..MAXADR ;
           R          : REAL ;
           INX        : ARRAY [0..ML1] OF  RECORD  X, Y: PABI..PNOP  END ;

      BEGIN   CORTBL[PNOP,PNOP] := 0 ;
      INX[0].X := PNOP ;  INX[0].Y := PNOP ;  INX[ML1] := INX[0] ;
      FOR I := PABI TO PNOP-1 DO
         FOR J := PABI TO PNOP-1 DO
            BEGIN   M := CORTBL[I,J] ;
            IF M >= 0 THEN
               BEGIN   K := -1 ;
               REPEAT  K := K+1  UNTIL M >= CORTBL[INX[K].X,INX[K].Y] ;
               IF K < ML THEN
                  BEGIN
                  FOR N := ML-1 DOWNTO K DO  INX[N+1] := INX[N] ;
                  INX[K].X := I ;  INX[K].Y := J ;
                  END  ;
               END (* M > 0 *) ;
            END (* FOR I,.. FOR J... *) ;

      WRITELN(SFL,'1 INSTRUCTION PAIR OCCURANCES (COUNT   %   CUMUL.) ',
                   '  TOTAL # OF PAIRS: ', INSTRCNT:8) ;
      WRITELN(SFL) ;     M := 0 ;

      FOR  N := 0 TO ML DO      (* ASSUMES ALL ENTRIES USEFULL *)
         BEGIN   I := INX[N].X ;   J := INX[N].Y ;  K := CORTBL[I,J] ;
         M := M+K ;    R := K*SL ;
         IF R >= 0.1 THEN
            WRITELN(SFL,N:4,')',INSTR[I]:12,INSTR[J]:6,K:10,
                        WRF(SFL, R, 8, 3):01, WRF(SFL, M*SL,10,2):1) ;
         END (* FOR N ... *) ;

      END (*SORTP*) ;

(*----------------------------------------------------------------------------*)
(*$D-*)
   PROCEDURE SORTO(SORTOPC, DETAILED: BOOLEAN);  (*TO SORT/PRINT OPCODE DIST.*)
      VAR  INX            : ARRAY [PABI..PNOP] OF PABI..PNOP ;
           WR, ENTROPY    : REAL ;
           OP, OP1        : PABI..PNOP ;
           M, TC          : INTEGER ;

      PROCEDURE PRINTO(*PRINT OPCODE DISTRIBUATION TABLE*);

         VAR  J:              INTEGER;

         BEGIN
         FOR OP1 := PABI TO PNOP DO

            BEGIN   IF SORTOPC THEN  OP := INX[OP1]  ELSE  OP := OP1 ;
            TC := PCNT[OP];
            IF TC > 0 THEN
               BEGIN WR := L/TC ;
               ENTROPY := ENTROPY + LN(WR)/WR ;

               IF DETAILED THEN

                  CASE OP OF
                     PABI,PABR,PADI,PADR,PAND,PCHK,PCHR,PDEC,PDIF,PDVI,PDVR,
                     PEOF,PFJP,PFLO,PFLT,PINC,PINN,PINT,PIOR,PIXA,PLAO,PLCA,
                     PLOC,PMOD,PMOV,PMPI,PMPR,PNGI,PNGR,PNOT,PODD,PORD,
                     PPRE,PSBI,PSBR,PSGS,PSQI,PSQR,PSTP,PSUC,PTOF,PTON,PTRC,
                     PUJP,PUNI,PXJP,PLCI,PNEW:
                        BEGIN  K := PINX[OP] ;
                        IF K <> 0 THEN
                           WRITELN(SFL, INSTR[OP]:10, K:20,
                                        WRF(SFL,K*SL,10,2):01) ;
                        END ;

                     PRET,PLDA,PMST:
                        BEGIN  S := 0 ;
                        FOR I := PINX[OP] TO PINX[OP] + 9 DO
                           BEGIN  K := SCNT[I] ;
                           IF K <> 0 THEN
                               BEGIN  S := S+K ;
                               WRITELN(SFL,INSTR[OP]:10,(I-PINX[OP]):5,
                                       K:15,WRF(SFL, K*SL,10,2):01,
                                       WRF(SFL, K*100.0/TC, 10, 2):0 );
                               END ;
                           END ;

                        IF S > 0 THEN
                           BEGIN
                           WRITELN(SFL,INSTR[OP]:10,'*':5,S:15,
                                       WRF(SFL, S*SL, 10, 2):01,
                                       WRF(SFL, S*100.0/S, 10, 2):01);
                           WRITELN(SFL) ;
                           END ;

                        IF OP <> PRET THEN
                           BEGIN  S := 0 ;
                           FOR I := QINX[OP] TO QINX[OP] + 9 DO
                              BEGIN  K := SCNT[I] ;
                              IF K <> 0 THEN
                                  BEGIN  S := S+K ;
                                  WRITELN(SFL, '#':7, INSTR[OP], (I-QINX[OP]):5,
                                                K:15,WRF(SFL, K*SL,10,2):01,
                                                WRF(SFL, K*100.0/TC, 10, 2) );
                                  END ;
                               END;

                           WRITELN(SFL, '#':7, INSTR[OP], '*':5,S:15,
                                        WRF(SFL, S*SL, 10, 2):01,
                                        WRF(SFL, S*100.0/S, 10, 2):01 ) ;
                           WRITELN(SFL) ;
                           END ;

                        END ;

                     PIND,PLDC,PLDO,PSRO,PSTO:
                        BEGIN  S := 0 ;
                        FOR I := PINX[OP] TO PINX[OP] + 5 DO
                           BEGIN  K := SCNT[I] ;
                           IF K <> 0 THEN
                              BEGIN  S := S+K ;

                                 WRITE(SFL,INSTR[OP]:10) ;
                                 CASE (I - PINX[OP]) OF
                                    0: IF OP = PLDC THEN WRITE(SFL,'N':5)
                                       ELSE WRITE(SFL,'P':5) ;
                                    1: WRITE(SFL,'I':5) ;
                                    2: WRITE(SFL,'R':5) ;
                                    3: WRITE(SFL,'B':5) ;
                                    4: IF OP = PRET THEN WRITE(SFL,'C':5)
                                          ELSE WRITE(SFL,'S':5) ;
                                    5: WRITE(SFL,'A':5)
                                 END  (* CASE K-PINX ... *) ;
                                 WRITELN(SFL,K:15, WRF(SFL, K*SL,10,2):01  ) ;
                              END ;
                           END (* FOR I...*) ;
                        WRITELN(SFL,INSTR[OP]:10,'*':5,S:15,
                                    WRF(SFL, S*SL, 10, 2):01 ) ;
                        WRITELN(SFL) ;
                        END  (* PIND, ... ,PSTO *) ;

                     PCMP (*PEQU,PGEQ,PGRT,PLEQ,PLES,PNEQ*) :
                        BEGIN
                        FOR J := 0 TO 5 DO
                           BEGIN   S := 0;   OP := OPMAP[J];
                           FOR I := PINX[OP] TO PINX[OP] + 5 DO
                              BEGIN  K := SCNT[I] ;
                              IF K <> 0 THEN
                                 BEGIN  S := S+K ;

                                    WRITE(SFL,INSTR[OP]:10) ;
                                    CASE (I - PINX[OP]) OF
                                       0: WRITE(SFL,'A':5);
                                       1: WRITE(SFL,'I':5) ;
                                       2: WRITE(SFL,'R':5) ;
                                       3: WRITE(SFL,'B':5) ;
                                       4: WRITE(SFL,'S':5) ;
                                       5: WRITE(SFL,'M':5)
                                    END  (* CASE K-PINX ... *) ;
                                    WRITELN(SFL,K:15, WRF(SFL, K*SL,10,2):01  );
                                 END ;
                              END (* FOR I...*) ;

                           IF S > 0 THEN
                              BEGIN
                              WRITELN(SFL, INSTR[OP]:10, '*':5, S:15,
                                           WRF(SFL, S*SL, 10, 2):01,
                                           WRF(SFL, S*100.0/TC, 10, 2):01 );
                              WRITELN(SFL) ;
                              END (* IF S > 0 *);
                           END (*FOR J :=0... *);

                        WRITELN(SFL, INSTR[PCMP]:10, '*':5, TC:15,
                                     WRF(SFL, TC*SL, 10, 2):01,
                                     WRF(SFL, TC*100.0/TC, 10, 2):2 );
                        WRITELN(SFL);
                        END  (* PCMP ::= PEQU, ... ,PGRT *) ;

                     PCUP,PLOD,PSTR,PENT:
                        BEGIN  S := 0 ;
                        FOR I := 0 TO 9 DO
                           BEGIN  M := 0;
                           FOR J := 0 TO 5 DO
                              BEGIN  K := SCNT[PINX[OP]+I*6+J] ;
                              IF K <> 0 THEN
                                 BEGIN
                                 S := S+K ;   M := M+K;
                                 WRITE(SFL,INSTR[OP]:10,'    ') ;
                                    CASE J OF
                                    0: WRITE(SFL,'P') ;
                                    1: WRITE(SFL,'I') ;
                                    2: WRITE(SFL,'R') ;
                                    3: WRITE(SFL,'B') ;
                                    4: WRITE(SFL,'S') ;
                                    5: WRITE(SFL,'A')
                                    END  (* CASE J *) ;
                                 WRITELN(SFL,',',I:1,K:13,
                                             WRF(SFL, K*SL,10,2):01 ) ;
                                 END ;
                              END (* FOR J := 0 TO 5 *);

                           IF M > 0 THEN
                              BEGIN
                              WRITELN(SFL, INSTR[OP]:10, '*,':6, I:1, M:13,
                                            WRF(SFL, M*SL, 10, 2):01,
                                            WRF(SFL, M*100.0/TC, 10, 2):01);
                              WRITELN(SFL);
                              END;

                           END ;

                           WRITELN(SFL,INSTR[OP]:10,'*,*':7,S:13,
                                       WRF(SFL, S*SL, 10, 2):01,
                                       WRF(SFL, S*100.0/S, 10, 2):01 );
                           WRITELN(SFL) ;

                        IF OP IN [PLOD, PSTR] THEN
                           BEGIN  S := 0 ;
                           FOR I := 0 TO 9 DO
                              BEGIN  M := 0;
                              FOR J := 0 TO 5 DO
                                 BEGIN  K := SCNT[QINX[OP]+I*6+J] ;
                                 IF K <> 0 THEN
                                    BEGIN
                                    S := S+K ;   M := M+K ;
                                    WRITE(SFL, '#':7, INSTR[OP],'    ') ;
                                       CASE J OF
                                       0: WRITE(SFL,'P') ;
                                       1: WRITE(SFL,'I') ;
                                       2: WRITE(SFL,'R') ;
                                       3: WRITE(SFL,'B') ;
                                       4: WRITE(SFL,'S') ;
                                       5: WRITE(SFL,'A')
                                       END  (* CASE J *) ;
                                    WRITELN(SFL,',',I:1,K:13,
                                                WRF(SFL, K*SL,10,2):01);
                                    END (* IF K > 0 *);

                                 END (* FOR J := 0 TO 5 *);

                              IF M > 0 THEN
                                 BEGIN
                                 WRITELN(SFL, '#':7, INSTR[OP], '*,':6, I:1,
                                              M:13,
                                              WRF(SFL, M*SL, 10 ,2):01,
                                              WRF(SFL, M*100.0/TC,10,2):01);
                                 WRITELN(SFL);
                                 END ;


                              END ;

                           WRITELN(SFL, '#':7, INSTR[OP],'*,*':7, S:13,
                                        WRF(SFL, S*SL, 10, 2):01,
                                        WRF(SFL, S*100.0/S, 10, 2):01 );
                           WRITELN(SFL) ;
                           END ;

                        END  (* PCUP,PLOD,PSTR *) ;

                       PCSP:
                        BEGIN  S := 0 ;
                          FOR J := 0 TO SPCNT-1 DO
                          BEGIN  K := SCNT[PINX[OP]+J] ;    S:= S+K ;
                            IF K <> 0 THEN
                              WRITELN(SFL, INSTR[OP]:10, SPTABLE[J]:7,
                                           K:13, WRF(SFL, K*SL, 10, 2):01 );
                          END ;
                          WRITELN(SFL,INSTR[OP]:10,'*':5,S:15,
                                      WRF(SFL, S*SL, 10, 2):01) ;
                          WRITELN(SFL) ;
                        END (*PCSP*)
                  END  (* CASE OP *)

               ELSE (* NOT STAT1 *)

                  BEGIN    S := S+TC;  M := M+1;
                  WRITELN(SFL, M:6, ')', INSTR[OP]:5, TC:10,
                               WRF(SFL, TC*SL, 7,2):01, WRF(SFL, S*SL,10,2):01);
                  END ;

               END (*IF TC > 0*);


            END (* FOR OP := PABI...*) ;
         END (*PRINTO*);


      BEGIN    PCNT[PNOP] := 0 ;   INX[0] := PNOP ;

      FOR OP := PABI TO PNOP-1 DO
         BEGIN   S := PCNT[OP] ;   K := -1 ;
         REPEAT    K := K+1   UNTIL  S >= PCNT[ INX[K] ] ;
         FOR I := OP-PABI DOWNTO K DO  INX[I+1] := INX[I] ;
         INX[K] := OP ;
         END (* FOR OP := PABI.. *) ;

      ENTROPY := 0.0 ;  S := 0 ;  M := 0 ;
      IF DETAILED THEN WRITE(SFL, '1   DETAILED')
      ELSE WRITE(SFL, '1   SUMMARY');

      WRITELN(SFL,' P_INSTRUCTION COUNTS, ABSOLUT AND RELATIVE FIGURES.');
      WRITELN(SFL, '    ( TOTAL OF: ', L:3, ' INSTRUCTIONS )' ) ;
      IF SORTOPC THEN WRITELN(SFL, '    ( SORTED BY COUNTS )')
      ELSE  WRITELN(SFL, '    ( SORTED BY OPCODES )' );
      WRITELN(SFL) ;  WRITELN(SFL) ;

      PRINTO;

      WRITELN(SFL) ;
      WRITELN(SFL, '    TOTAL COUNT = ', L:6 ,
                   ',   ENTROPY =', WRF(SFL, ENTROPY/LN(2.0),8, 3):01 );

      END (* SORTO *) ;      (*$D-*)

(*----------------------------------------------------------------------------*)

BEGIN  (*PRINTCOUNT*)
   WRITELN(SFL);  WRITELN(SFL);
   IF GETSTAT THEN WRITELN(SFL, '    GETSTAT  -->  ENABLE ''COUNTING'' ',
                                'PROCEDURES.');
   IF STAT1   THEN WRITELN(SFL, '    STAT1    -->  PRINT DETAILED BREAKDOWN ',
                                'FOR EACH INSTRUCTION BY THE OPERAND TYPE.');
   IF STAT2   THEN WRITELN(SFL, '    STAT2    -->  PRINT FREQUENCY OF ADDRESS/',
                                'OPERAND FOR LOD, STR, INC, DEC, IXA... ETC.');
   IF STAT3   THEN WRITELN(SFL, '    STAT3    -->  PRINT FREQUENCY AND BRANCH ',
                                'DISTANCE FOR JUMP INSTRUCTIONS.');
   IF STAT4   THEN WRITELN(SFL, '    STAT4    -->  PRINT INSTRUCTION ',
                                'PAIR STATISTICS.');
   IF STAT5   THEN WRITELN(SFL, '    STAT5    -->  PRINT MATRIX OF ',
                               'INSTRUCTION PAIR FREQUENCIES.');
   IF STAT6   THEN WRITELN(SFL, '    STAT6    -->  GENERATE PUSH/POP, ',
                                'CALL/RETURN STACK TRACE.');
   IF STAT9   THEN WRITELN(SFL, '    STAT9    -->  PRINT FULL DETAILS OF ',
                                'THE ABOVE TABLES.');
   WRITELN(SFL);  WRITELN(SFL);


   IF STAT6 THEN  PRINT_STK_TRACE;                                (*++++++++++*)

   (* PATCH UP COUNT TABLES *)
   OPMAP[0] := PEQU;   OPMAP[1] := PNEQ;
   OPMAP[2] := PLEQ;   OPMAP[3] := PLES;
   OPMAP[4] := PGEQ;   OPMAP[5] := PGRT;

   FOR I := 0 TO 5 DO  (*PEQU..PGRT*)
      BEGIN  OP := OPMAP[I];
      M := PCNT[PCMP]+PCNT[OP];   PCNT[OP] := 0;  PCNT[PCMP] := M;

      FOR J := 0 TO PNOP DO
         BEGIN
         M := CORTBL[PCMP,J]+CORTBL[OP,J];  CORTBL[OP,J] := 0;
         CORTBL[PCMP,J] := M;
         M := CORTBL[J,PCMP]+CORTBL[J,OP];  CORTBL[J,OP] := 0;
         CORTBL[J,PCMP] := M;
         END;

      END (*FOR I := 0... *);

   (* SORT AND/OR PRINT TABLES *)

   L := INSTRCNT;   SL := 100/L;  (*SCALE FACTOR*)

   SORTO(TRUE  (*OPCODE SORTED LIST*), FALSE (*SUMMARY TABLE*));

   IF STAT9 THEN  SORTO(FALSE (*ALPHABETIC LISTING*), FALSE ) ;

   IF STAT1 THEN SORTO(TRUE  (*OPCODE SORTED LIST*), TRUE  (*DETAILED TABLE*));

   IF STAT2 THEN
      BEGIN   WRITELN(SFL,'1') ;
      FOR OP := PABI TO PSTR DO       (* PSTR = 61 <= 63 *)
         IF PCNT[OP] > 0 THEN
            IF OP IN [PNEW,PINC,PDEC,PIND,PLDA,PLOD,PSTR,PCSP,PMOV,PIXA,PLDC]
               THEN
               BEGIN  M := PCNT[OP];  WRITELN(SFL) ; WRITELN(SFL) ;
               WRITELN(SFL, '-->':4, INSTR[OP]:4,
                           '   (VALUE      COUNT      CUMUL.C.)',
                            ',   TOTAL COUNT: ',M:7,
                            WRF(SFL, PCNT[OP]*SL, 7, 2):01) ;
               WRITELN(SFL) ;
               PTR := ACNT[OP] ;    S:= 0 ;   J := 0 ;   I := 0 ;   K := 1 ;
                  REPEAT
                  WITH PTR@ DO
                      BEGIN
                      IF OP IN [PLOD,PSTR,PLDA,PLDC] THEN
                         IF VAL < K THEN
                            BEGIN  I := I+CNT ;  S := S+CNT ;
                            IF CNT > 0 THEN  J := J+1 ;
                            PTR := NXT ;
                            END
                         ELSE
                            BEGIN
                            WRITELN(SFL, K DIV 2:16, I:8,
                                         WRF(SFL, I*100.0/M, 8, 2):0,
                                         WRF(SFL, S*100.0/M, 10, 2):0 ) ;
                            I := 0 ;  K := K*2 ;
                            END

                      ELSE (* NOT (OP IN [... *)

                         BEGIN
                         IF CNT > 0 THEN
                            BEGIN   J := J+1 ;    S := S+CNT ;
                            IF OP = PCSP THEN  WRITE(SFL, SPTABLE[VAL]:16)
                            ELSE  WRITE(SFL, VAL:16);
                            WRITELN(SFL, CNT:8, WRF(SFL, CNT*100.0/M, 8, 2):0,
                                         WRF(SFL, S*100.0/M, 10, 2):0 ) ;
                            END ;
                         PTR := NXT ;
                         END ;

                      END ;
                   UNTIL (PTR = NIL) OR (S = M) OR (K >= 1073741824)  ;

                IF OP IN [PLOD,PSTR,PLDA,PLDC] THEN
                   WRITELN(SFL, K DIV 2:16, I:8, WRF(SFL, I*100.0/M, 8, 2):0,
                                WRF(SFL, S*100.0/ PCNT[OP], 10, 2):01);
                WRITELN(SFL);
                WRITELN(SFL, '     COUNT OF DISTINCT VALUES: ', J:3) ;

               END (* FOR OP := PABI TO ...*) ;

      END (* STAT2 *) ;


   IF STAT3 THEN
      BEGIN  (* PRINT BRANCH DISTANCES *)
      IF NXTUJP > 0 THEN  BEGIN  OP := PUJP;  SORTJ(0, NXTUJP-1)  END;
      IF NXTFJP < MAXLBLCNT THEN
         BEGIN  OP := PFJP;  SORTJ(NXTFJP+1, MAXLBLCNT) END;
      END (* STAT3 *) ;


   IF STAT4 THEN SORTP ;   (* SORTED LIST OF THE MOST FREQUENT PAIRS *)

   IF STAT5 THEN

      BEGIN   (* INSTRUCTION PAIR TABLES *)

      FOR COLS := 0 TO 30 DO COLNDX[COLS] := 0 ;

      WRITE(SFL,'1INSTRUCTION_PAIR FREQUENCY TABLE') ;
      WRITELN(SFL,'   (ROW  PERCENTAGES)') ;  WRITELN(SFL) ;
        FOR I := PABI TO PNOP DO
           BEGIN  PINX[I] := 0 ;
           FOR J := PABI TO PNOP DO
              BEGIN  PINX[I] := PINX[I]+CORTBL[I,J] ;
              "CORTBL[I,J] := CORTBL[I,J]*100;"
              END ;
           END ;

        K := PABI ;
        WRITELN(SFL) ;
        WHILE K < PNOP DO (* LOOP FOR FRAMES *)
           BEGIN  COLS := 0 ;
           (* PRINT FRAME HEADER *)
           WRITE(SFL,' ':14) ;
           WHILE (COLS <= 15) AND (K < PNOP) DO
              BEGIN
              IF PINX[K] > 0 THEN
                 BEGIN
                 COLNDX[COLS] := K ;  WRITE(SFL,INSTR[K]:7) ;
                 COLS := COLS+1 ;
                 END ;
              K := K+1 ;
              END ;
           WRITELN(SFL (*TERMINATE HEADER LINE*) ) ;
           (* PRINT BODY OF THE FRAME *)
           IF COLS > 0 THEN
              BEGIN  WRITELN(SFL (*SPACE*) ) ;
              FOR I := PABI TO PNOP DO (* REPEAT FOR EACH LINE *)
                 IF PINX[I] > 0 THEN
                    BEGIN  J := 0 ;
                    WHILE (J < COLS) AND (CORTBL[I,COLNDX[J]] = 0) DO  J:= J+1 ;
                    IF J < COLS THEN
                       BEGIN  L := PINX[I] ;
                       WRITE(SFL, WRF(SFL, PINX[I]*SL, 8, 2):0,')',INSTR[I]:4) ;
                       FOR J := 0 TO COLS-1 DO
                          WRITE(SFL, WRF(SFL, CORTBL[I,COLNDX[J]]*SL, 7, 2):0);
                       WRITELN(SFL (* TERMINATE THIS LINE *) ) ;
                       END ;
                    END ;
              WRITELN(SFL,'1' (* SPACE *) ) ;
              END (* IF COLS...*) ;
           END (* WHILE K < PNOP *) ;

      IF STAT9 THEN
         BEGIN  (*MATRIX OF ABSOLUTE COUNTS *)
         WRITELN(SFL,'1INSTRUCTION_PAIR FREQUENCY TABLE   (ABSOLUTE COUNTS)') ;
         WRITELN(SFL) ;

         FOR I := PABI TO PNOP DO
            BEGIN  PINX[I] := 0 ;
            FOR J := PABI TO PNOP DO
               PINX[I] := PINX[I]+CORTBL[I,J] ;
            END ;
         K := PABI ;
         WRITELN(SFL) ;
         WHILE K < PNOP DO (* LOOP FOR FRAMES *)
            BEGIN  COLS := 0 ;
            (* PRINT FRAME HEADER *)
            WRITE(SFL,' ':16) ;
            WHILE (COLS <= 15) AND (K < PNOP) DO
               BEGIN
               IF PINX[K] > 0 THEN
                  BEGIN
                  COLNDX[COLS] := K ;  WRITE(SFL,INSTR[K]:7) ;
                  COLS := COLS+1 ;
                  END ;
               K := K+1 ;
               END ;
            WRITELN(SFL (*TERMINATE HEADER LINE*) ) ;
            (* PRINT BODY OF THE FRAME *)
            IF COLS > 0 THEN
               BEGIN  WRITELN(SFL (*SPACE*) ) ;
               FOR I := PABI TO PNOP DO (* REPEAT FOR EACH LINE *)
                  IF PINX[I] > 0 THEN
                     BEGIN  J := 0 ;
                     WHILE (J < COLS) AND (CORTBL[I,COLNDX[J]] = 0) DO  J:= J+1;
                     IF J < COLS THEN
                        BEGIN
                        WRITE(SFL,PINX[I]:9,')',INSTR[I]:5) ;
                        FOR J := 0 TO COLS-1 DO
                           WRITE(SFL,CORTBL[I,COLNDX[J]]:7) ;
                        WRITELN(SFL (* TERMINATE THIS LINE *) ) ;
                        END ;
                     END ;
               WRITELN(SFL,'1' (* SPACE *) ) ;
               END (* IF COLS...*) ;
            END (* WHILE K <= PLCI *) ;

         END (*STAT9*) ;

      END (* STAT5 *) ;

END  (* PRINTCOUNTS *) ;
(*----------------------------------------------------------------------------*)

PROCEDURE LOAD;
   VAR
      " ICP,RCP,SCP,BCP,MCP  : ADDRESS; "(*POINTERS TO NEXT FREE POSITION*)
        I  :  INTEGER ;     CH  :  CHAR ;
        NXTPROC, CURPROC  : MINPROC..MAXPROC ;
        LABELVALUE: ADDRESS;
        NAME: SHRTALFA ;  PROCNAME : ALFA ;
        LABELTAB      : ARRAY [LBLRNG] OF LABELREC ;
        PROCSZE :       ARRAY [MINPROC..MAXPROC] OF 0..MAXADR  ;

   PROCEDURE INIT;
      VAR I, J : INTEGER;
   BEGIN INSTR[PABI]:='ABI'; INSTR[PABR]:='ABR';
         INSTR[PADI]:='ADI'; INSTR[PADR]:='ADR';
         INSTR[PAND]:='AND'; INSTR[PCHK]:='CHK';
         INSTR[PCHR]:='CHR'; INSTR[PCSP]:='CSP';
         INSTR[PCUP]:='CUP'; INSTR[PDEC]:='DEC';
         INSTR[PDEF]:='DEF'; INSTR[PDIF]:='DIF';
         INSTR[PDVI]:='DVI'; INSTR[PDVR]:='DVR';
         INSTR[PENT]:='ENT'; INSTR[PEOF]:='EOF';
         INSTR[PEQU]:='EQU'; INSTR[PFJP]:='FJP';
         INSTR[PFLO]:='FLO'; INSTR[PFLT]:='FLT';
         INSTR[PGEQ]:='GEQ'; INSTR[PGRT]:='GRT';
         INSTR[PINC]:='INC'; INSTR[PIND]:='IND';
         INSTR[PINN]:='INN'; INSTR[PINT]:='INT';
         INSTR[PIOR]:='IOR'; INSTR[PIXA]:='IXA';
         INSTR[PLAO]:='LAO'; INSTR[PLCA]:='LCA';
         INSTR[PLDA]:='LDA'; INSTR[PLDC]:='LDC';
         INSTR[PLDO]:='LDO'; INSTR[PLEQ]:='LEQ';
         INSTR[PLES]:='LES'; INSTR[PLOC]:='LOC';
         INSTR[PLOD]:='LOD'; INSTR[PMOD]:='MOD';
         INSTR[PMOV]:='MOV'; INSTR[PMPI]:='MPI';
         INSTR[PMPR]:='MPR'; INSTR[PMST]:='MST';
         INSTR[PNEQ]:='NEQ'; INSTR[PNEW]:='NEW';
         INSTR[PNGI]:='NGI'; INSTR[PNGR]:='NGR';
         INSTR[PNOT]:='NOT'; INSTR[PODD]:='ODD';
         INSTR[PORD]:='ORD'; INSTR[PPRE]:='PRE';
         INSTR[PRET]:='RET'; INSTR[PRST]:='RST';
         INSTR[PSAV]:='SAV'; INSTR[PSBI]:='SBI';
         INSTR[PSBR]:='SBR'; INSTR[PSGS]:='SGS';
         INSTR[PSQI]:='SQI'; INSTR[PSQR]:='SQR';
         INSTR[PSRO]:='SRO'; INSTR[PSTO]:='STO';
         INSTR[PSTP]:='STP'; INSTR[PSTR]:='STR';
         INSTR[PSUC]:='SUC'; INSTR[PTOF]:='TOF';
         INSTR[PTON]:='TON'; INSTR[PTRC]:='TRC';
         INSTR[PUJP]:='UJP'; INSTR[PUNI]:='UNI';
         INSTR[PXJP]:='XJP'; INSTR[PLCI]:='LCI';
         INSTR[PBGN]:='BGN'; INSTR[PCMP]:='CMP';

         SPTABLE[ 0]:='GET'; SPTABLE[ 1]:='PUT';
         SPTABLE[ 2]:='RST'; SPTABLE[ 3]:='RLN';
         SPTABLE[ 4]:='NEW'; SPTABLE[ 5]:='WLN';
         SPTABLE[ 6]:='WRS'; SPTABLE[ 7]:='ELN';
         SPTABLE[ 8]:='WRI'; SPTABLE[ 9]:='WRR';
         SPTABLE[10]:='WRC'; SPTABLE[11]:='RDI';
         SPTABLE[12]:='RDR'; SPTABLE[13]:='RDC';
         SPTABLE[14]:='SIN'; SPTABLE[15]:='COS';
         SPTABLE[16]:='EXP'; SPTABLE[17]:='LOG';
         SPTABLE[18]:='SQT'; SPTABLE[19]:='ATN';
         SPTABLE[20]:='SAV'; SPTABLE[21]:='XIT';
         SPTABLE[22]:='RES'; SPTABLE[23]:='REW';
         SPTABLE[24]:='EOF'; SPTABLE[25]:='CLK';
         SPTABLE[26]:='WRB'; SPTABLE[27]:='RDS';
         SPTABLE[28]:='SIO'; SPTABLE[29]:='EIO';
         SPTABLE[30]:='FDF'; SPTABLE[31]:='RDB';

         FOR CH := 'A' TO 'Z' DO IVECTOR[CH] := 0 ;

         IVECTOR['A'] := PABI ;  IVECTOR['C'] := PCHK ;
         IVECTOR['D'] := PDEC ;  IVECTOR['E'] := PENT ;
         IVECTOR['F'] := PFJP ;  IVECTOR['G'] := PGEQ ;
         IVECTOR['I'] := PINC ;  IVECTOR['L'] := PLAO ;
         IVECTOR['M'] := PMOD ;  IVECTOR['N'] := PNEQ ;
         IVECTOR['O'] := PODD ;  IVECTOR['P'] := PPRE ;
         IVECTOR['R'] := PRET ;  IVECTOR['S'] := PSAV ;
         IVECTOR['T'] := PTON ;  IVECTOR['U'] := PUJP ;
         IVECTOR['X'] := PXJP ;

         NEEDOPNDS := [PCHK,PCSP,PCUP,PDEC,PENT,PEQU,PFJP,PGEQ,PGRT,PINC,PIND,
                       PIXA,PLAO,PLCA,PLDA,PLDC,PLDO,PLEQ,PLES,PLOC,PLOD]
                        + [PMOV,PMST,PNEQ,PNEW,PRET,PSRO,PSTO,PSTR,PUJP,PXJP] ;
         PC:= 0;   EP := 0;  CPL := MAXSTK-1;
"""      ICP:= MAXSTK+1; FOR I:= ICP TO OVERI DO STORE[I].STYPE:= INT;
         RCP:= OVERI+1; FOR I:= RCP TO OVERR DO STORE[I].STYPE:= REEL;
         SCP:= OVERR+1; FOR I:= SCP TO OVERS DO STORE[I].STYPE:= SETT;
         BCP:= OVERS+2; FOR I:= OVERS+1 TO OVERB DO STORE[I].STYPE:= INT;
         MCP:= OVERB+1; FOR I:= MCP TO OVERM DO STORE[I].STYPE:= INT; """

         STYPE[MAXSTK] := UNDEF;  STYPE[0] := UNDEF;
         NAME := BLNK3 ;

         FOR I := PABI TO PNOP DO
            BEGIN
            NEW(ACNT[I]) ;
            ACNT[I]@.VAL := MAXINT ;  ACNT[I]@.NXT := NIL ;  ACNT[I]@.CNT := 0 ;
            END ;

         FOR I:= MINPROC TO MAXPROC DO
             WITH LABELTAB[I] DO BEGIN VAL:=-1; ST:= ENTERED END;

         CURLVL := 0;
      """NUMERICS := ['0','1','2','3','4','5','6','7','8','9'] ; """
         NXTPROC := MINPROC ;   LOADING := TRUE ;  INTERPRETING := FALSE;
         NXTFJP := MAXLBLCNT ;  NXTUJP := 0 ;
         TRCE := FALSE  ;  DMP := FALSE  ;
         GETSTAT := FALSE;  STAT9 := FALSE;  STAT1 := FALSE;  STAT4 := FALSE;
         STAT2 := FALSE;   STAT3 := FALSE;  STAT5 := FALSE;  STAT6 := FALSE;

         FOR I := 0 TO 9 DO  (*INITIALIZE TIME/DATE*)
             BEGIN
             STORE[TIMEDATELOC+I].VI := ORD(DATE[I+1]) ;
             STYPE[TIMEDATELOC+I] := INT;
             STORE[TIMEDATELOC+10+I].VI := ORD(TIME[I+1]);
             STYPE[TIMEDATELOC+10+I] := INT;
             END;

         IF OSPARM = NIL THEN
            STORE[OSPARMLOC].VI := NILVAL
         ELSE
            WITH OSPARM@ DO
               BEGIN
               FOR I := LENGTH TO 1 DO
                  BEGIN  NP := NP-1;
                  STORE[NP].VI := ORD(STRING[I]);  STYPE[NP] := INT;
                  END;
               NP := NP-1;
               STORE[NP].VI := LENGTH;  STYPE[NP] := INT;
               STORE[OSPARMLOC].VI := NP;
               END (* WITH OSPARM... *);

         STYPE[OSPARMLOC] := ADR;


         IF STAT6 THEN  BEGIN  REWRITE(TRFILE); WRITELN(TRFILE)  END;  (*+++++*)

   END;(*INIT*)
(*----------------------------------------------------------------------------*)

   PROCEDURE ERRORL(STRING: BETA); (*ERROR IN LOADING*)
   BEGIN WRITELN() ;
         WRITELN(OUTPUT,'>>>>  ':10, STRING); EXIT(1001) (*EXIT INTERPRETER*)
   END; (*ERRORL*)
(*----------------------------------------------------------------------------*)

   PROCEDURE BRDIST(DIST: INTEGER) ;   (*TO RECORD BRANCH DISTANCES*)
      VAR I : INTEGER ;
      BEGIN   (* TO RECORD 'BRANCH DISTANCE' OF A BRANCH INSTRUCTION *)
      IF OP = PFJP THEN

         IF NXTFJP = NXTUJP THEN ERRORL(' BRANCH TABLE OVRFL.')
         ELSE
            BEGIN   BDCNT[NXTFJP].VAL := DIST ;   I := MAXLBLCNT+1 ;
            REPEAT  I := I-1  UNTIL BDCNT[I].VAL = DIST ;
            IF I = NXTFJP THEN  NXTFJP := NXTFJP-1 ;
            BDCNT[I].CNT := BDCNT[I].CNT+1  ;  P := I ;
            END

      ELSE IF OP = PUJP THEN

         IF NXTFJP = NXTUJP THEN ERRORL(' BRANCH TABLE OVRFL.')
         ELSE
            BEGIN   BDCNT[NXTUJP].VAL := DIST ;   I := -1 ;
            REPEAT  I := I+1  UNTIL BDCNT[I].VAL = DIST ;
            IF I = NXTUJP THEN  NXTUJP := NXTUJP+1 ;
            BDCNT[I].CNT := BDCNT[I].CNT+1  ;  P := I ;
            END ;

      END (*BRDIST*) ;
(*----------------------------------------------------------------------------*)

   PROCEDURE UPDATE(X: LBLRNG); (*WHEN A LABEL DEFINITION LX IS FOUND*)
      VAR CURR,SUCC: -1..MAXPC; (*RESP. CURRENT ELEMENT AND SUCCESSOR ELEMENT
                                      OF A LIST OF FUTURE REFERENCE*)
          ENDLIST: BOOLEAN;
   BEGIN
      IF LABELTAB[X].ST=DEFINED THEN
         BEGIN  WRITELN(OUTPUT,X) ; ERRORL(' DUPLICATED LABEL   ')  END
      ELSE BEGIN
             IF LABELTAB[X].VAL<>-1 THEN (*FORWARD REFERENCE(S)*)
             BEGIN CURR:= LABELTAB[X].VAL; ENDLIST:= FALSE;
                REPEAT
                      WITH CODE[CURR] DO
                        BEGIN
                        IF STAT3 THEN
                           BEGIN
                           OP := OP1 MOD 256 ;  BRDIST(LABELVALUE-CURR) ;
                           IF OP IN [PUJP,PFJP] THEN
                              OP1 := OP + 65536*P ;   (*'P' IS SET BY 'BRDIST'*)
                           END ;
                        SUCC := Q1 ;  Q1:= LABELVALUE ;
                        IF SUCC=-1 THEN ENDLIST:= TRUE
                                   ELSE CURR:= SUCC
                        END;
                UNTIL ENDLIST ;
             END;
             LABELTAB[X].ST:= DEFINED;
             LABELTAB[X].VAL:= LABELVALUE;
          END  ;
   END;(*UPDATE*)
(*----------------------------------------------------------------------------*)

   FUNCTION GET_PROCID: LBLRNG ;       (* TO GET PROCEDURE NAME *)
      VAR  ALFALAB : ALFA ;  INTLAB : LBLRNG ;
      BEGIN  ALFALAB[1] := CH ;
      FOR INTLAB := 2 TO 8 DO READ(PFILE,ALFALAB[INTLAB]) ;
      INTLAB := MINPROC ;  PROCTAB[NXTPROC] := ALFALAB;
      WHILE ALFALAB <> PROCTAB[INTLAB] DO INTLAB := INTLAB+1 ;
      IF INTLAB = NXTPROC THEN NXTPROC := NXTPROC+1 ;
      IF ALFALAB = '$MAINBLK' THEN EP := PC ; (*RECORD ENTRY POINT *)
      IF NXTPROC > MAXPROC THEN
          BEGIN WRITELN(OUTPUT, ALFALAB:10, INTLAB) ;
          ERRORL(' TOO MANY PROCEDURES')
          END ;
      GET_PROCID := INTLAB ;
      END (* GET_PROCID*) ;
(*----------------------------------------------------------------------------*)

   PROCEDURE SORTE ;      (* TO SORT/PRINT PROCEDURE SIZE DISTRIBUTION *)
      VAR  I, J, K : 0..MAXPROC ;  L, N: ADDRESS ;
           INX :     ARRAY [0..MAXPROC] OF 0..MAXPROC ;
           LGTH :    ARRAY [0..MAXPROC] OF ADDRESS ;
      BEGIN

      PROCSZE[NXTPROC] := MAXADR ;   INX[0] := NXTPROC ;

      FOR J := MINPROC TO NXTPROC-1 DO
         BEGIN   L := PROCSZE[J]  ;   N := -1  ;

         REPEAT   N := N+1   UNTIL L < PROCSZE[ INX[N] ] ;

         FOR L := J DOWNTO N DO   INX[L+1] := INX[L] ;

         INX[N] := J ;
         END ;

      WRITELN(SFL) ;  WRITELN(SFL) ;
      WRITELN(SFL,'    PROCEDURE SIZE DISTRIBUTION, TOTAL COUNT =',NXTPROC:5);
      WRITELN(SFL);  WRITELN(SFL, '    LENGTH,     NAME,     DATA SIZE ') ;
      WRITELN(SFL) ;   WRITELN(SFL) ;

      FOR J := MINPROC TO NXTPROC-1 DO
         WRITELN(SFL, PROCSZE[ INX[J] ]:10, PROCTAB[ INX[J] ]:12,
                       CODE[ LABELTAB[ INX[J] ].VAL ].Q1:10) ;

      END (*SORTE*) ;


(*----------------------------------------------------------------------------*)

   PROCEDURE ASSEMBLE; FORWARD;
(*----------------------------------------------------------------------------*)

   PROCEDURE GENERATE;(*GENERATE SEGMENT OF CODE*)
      VAR X: INTEGER; (* LABEL NUMBER *)
   BEGIN  RESET(PFILE) ;
      REPEAT    (* READ UNTIL LAST INSTRUCTION, 'STP' *)
         READ(PFILE,CH) ;  (* FIRST CHARACTER OF LINE *)
         IF CH = ' ' THEN
         BEGIN   (* NO LABEL FIELD *)
            ASSEMBLE
         END   (* CH = ' ' *)
         ELSE
         BEGIN   (* LABEL *)
            IF (CH = 'L') AND (PFILE@ >= '0') AND (PFILE@ <= '9') THEN
            BEGIN   (* STANDARD LABEL *)
               READ(PFILE,X,CH,CH) ;   (*READ NEXT NON BLANK CHAR*)
               IF CH = 'L' THEN   (* LAB *)
                  LABELVALUE := PC
               ELSE
               BEGIN   (* DEF *)
                  READ(PFILE,CH,CH,LABELVALUE)
               END   (* DEF *) ;
               UPDATE(X+MINLABEL) ;
               READLN(PFILE)
            END   (* STANDARD LABEL *)
            ELSE
            BEGIN   (* PROCEDURE OR FUNCTION *)
(*            PC := PC+1;     (* SAVE SPACE FOR PROC ID PTR *)            (*+*)
               LABELVALUE := PC ;   CURPROC := GET_PROCID ;
               UPDATE(CURPROC) ;
               READ(PFILE,CH) ; (*ADVANCE TO OPCODE FIELD*)
               ASSEMBLE
            END   (* PROCEDURE OR FUNCTION *)
         END   (* LABEL *)  ;
      UNTIL OP = PSTP ;
   END   (* GENERATE *) ;
(*----------------------------------------------------------------------------*)

   PROCEDURE ASSEMBLE; (*TRANSLATE SYMBOLIC CODE INTO MACHINE CODE AND STORE*)
      VAR B :BOOLEAN;  R :REAL;  S :SET OF 0..63;
          C1 :CHAR;  I,J,S1,LB,UB :INTEGER;
(*----------------------------------------------------------------------------*)

      PROCEDURE LOOKUP(X: LBLRNG); (* SEARCH IN LABEL TABLE*)
      BEGIN
          CASE LABELTAB[X].ST OF
          ENTERED: BEGIN Q:=LABELTAB[X].VAL;
                   LABELTAB[X].VAL:=PC
                   END;
          DEFINED: BEGIN  Q:= LABELTAB[X].VAL  ;
                   IF STAT3 THEN BRDIST(Q-PC) ;
                   END
          END(*CASE LABEL..*) ;
      END;(*LOOKUP*)
(*----------------------------------------------------------------------------*)


      PROCEDURE GET_OPCDE;
      BEGIN     READ(PFILE,NAME) ;
         OP := IVECTOR[NAME[1]]-1 ;
         INSTR[PNOP] := NAME ;
         REPEAT  OP := OP+1  UNTIL (INSTR[OP] = NAME) ;
         IF OP > PLCI THEN
         BEGIN
            WRITELN(OUTPUT,' ILLEGAL OPCODE     ',NAME) ;
            OP := PTOF  (* NOP *)
         END ;
         IF OP <= 63 THEN
            IF (OP IN NEEDOPNDS) THEN
               REPEAT
                  READ(PFILE,CH) ;
               UNTIL (CH <> ' ') ;
      END; (*GET_OPCDE*)
(*----------------------------------------------------------------------------*)

   BEGIN   (* ASSEMBLE *)
      P := 0;  Q := 0;  OP := 0; T := UNDEF ;
      GET_OPCDE;

      CASE OP OF  (* GET PARAMETERS T,P,Q *)

          PBGN:
             BEGIN  READ(PFILE, B, CH, B, CH, B, CH, HEADLN);  END;

          (*EQU,NEQ,GEQ,GRT,LEQ,LES*)
          PEQU,PGEQ,PGRT,PLEQ,PLES,PNEQ :
                        BEGIN CASE CH OF
                              'A': P := 0;
                         'C', 'I': P := 1;
                              'R': P := 2;
                              'B': P := 3;
                              'S': P := 4;
                              'M' :BEGIN P := 5;
                                     READ(PFILE, CH, Q)
                                   END
                              END
                          END;

          PLOD,PSTR:
             BEGIN
                CASE CH OF
                   'I','C': T := INT ;
                   'R': T := REEL ;
                   'B': T := BOOL ;
                   'S': T := SETT ;
                   'A': T := ADR
                END   (* CASE *) ;
                REPEAT
                   READ(PFILE,CH) ;
                UNTIL CH = ',' ;
                READ(PFILE,CH) ;
                P := 0 ;
                WHILE CH <> ',' DO
                BEGIN
                   P := P * 10 + ORD(CH) - ORD('0') ;
                   READ(PFILE,CH)
                END   (* WHILE *) ;
                READ(PFILE,Q)
             END   (* LOD,STR *) ;

          PSTO:
             CASE CH OF
                'I','C': T := INT ;
                'R': T := REEL ;
                'B': T := BOOL ;
                'S': T := SETT ;
                'A': T := ADR
             END   (* STO *) ;

          (* LDA *)
          PLDA:
             BEGIN
                P := ORD(CH) - ORD('0') ;
                READ(PFILE,CH) ;
                WHILE CH <> ',' DO
                BEGIN
                   P := P * 10 + ORD(CH) - ORD('0') ;
                   READ(PFILE,CH)
                END   (* WHILE *) ;
                READ(PFILE,Q)
             END   (* LDA *) ;

          PCUP:
             BEGIN
                CASE CH OF
                   'P': T := UNDEF ;
                   'I','C': T := INT ;
                   'R': T := REEL ;
                   'B': T := BOOL ;
                   'S': T := SETT ;
                   'A': T := ADR
                END   (* CASE *) ;
                READ(PFILE,CH,P,CH,CH) ;  (*THE FIRST CHAR OF PROCID*)
            """ IF ODD(P) THEN  ERRORL(' FP SAVE AREA REQ   '); """
                P := P DIV 2 ;
                LOOKUP(GET_PROCID) ;
             END   (* CUP *) ;

          PMST :
                  BEGIN
                  REPEAT
                     P := P * 10 + ORD(CH) - ORD('0') ;
                     READ(PFILE,CH) ;
                  UNTIL CH = ' ' ;
                  P := CURLVL-P;
                  END;

          PRET :
             BEGIN   PROCSZE[CURPROC] := PC+1- LABELTAB[CURPROC].VAL ;
                CASE CH OF
                   'P': T := UNDEF ;
                   'I','C': T := INT ;
                   'R': T := REEL ;
                   'B': T := BOOL ;
                   'S': T := SETT ;
                   'A': T := ADR
                END ;

             IF GETSTAT THEN
                IF IAC <> 0 THEN P := 1
                ELSE IF (GAC = 0) AND (LAC > 0) THEN P := 0
                ELSE IF (GAC > 0) AND (LAC = 0) THEN P := 2
                ELSE P := 3
             END ;

          PDEC,PINC,PIND,PLDO,PSRO :
             BEGIN
                CASE CH OF
                   'I','C': T := INT ;
                   'R': T := REEL ;
                   'A': T := ADR ;
                   'B': T := BOOL ;
                   'S': T := SETT
                END   (* CASE *) ;
                REPEAT
                   READ(PFILE,CH) ;
                UNTIL CH = ',' ;
                READ(PFILE,Q)
             END   (* LDO,SRO,IND,MOV,INC,DEC *) ;

          PIXA,PLAO,PLOC,PMOV :
             BEGIN
                Q := ORD(CH) - ORD('0') ;
                READ(PFILE,CH) ;
                WHILE CH <> ' ' DO
                BEGIN
                   Q := Q * 10 + ORD(CH) - ORD('0') ;
                   READ(PFILE,CH)
                END   (* WHILE *)
             END   (* LAO,IXA *) ;

          PFJP,PUJP:
             BEGIN  READ(PFILE,I) ;  LOOKUP(I+MINLABEL) ;  END ;

          PXJP:
            BEGIN  READ(PFILE,I);  LOOKUP(I+2+MINLABEL) ;
            CODE[PC].OP1 := OP ;   CODE[PC].Q1 := Q ;  PC := PC+1 ;
            LOOKUP(I+3+MINLABEL) ;
            CODE[PC].OP1 := 0 ;  CODE[PC].Q1 := Q ; PC := PC+1 ;
            LOOKUP(I+MINLABEL) ;
            CODE[PC].OP1 := 0 ;  CODE[PC].Q1 := Q ; PC := PC+1 ;
            LOOKUP(I+1+MINLABEL) ;
            END (*PXJP*) ;

          PENT:
             BEGIN
                GAC := 0;  IAC := 0;  LAC := 0;

                FOR I := MINLABEL TO MAXLABEL DO
                   BEGIN  LABELTAB[I].VAL := -1;  LABELTAB[I].ST := ENTERED END;
                CASE CH OF
                   'P': T := UNDEF ;
                   'I','C': T := INT ;
                   'R': T := REEL ;
                   'B': T := BOOL ;
                   'S': T := SETT ;
                   'A': T := ADR
                END ;

             (* WHILE CH <> ',' DO READ(PFILE,CH) ;*)  (* GET LEVEL *)
                READ(PFILE, CH(*,*), P, CH, CH(*,L*), I) ;
                CURLVL := P ;         (*LEVEL OF THIS PROC*)
                LOOKUP(I+MINLABEL) ;  (*LABEL FOR DATA AREA*)
(*             WRITELN(OUTPUT, ' PROCID,  PC: ', PROCTAB[CURPROC],  PC:6);(*+*)
(*             CODE[PC-1].Q1 := CURPROC;                                  (*+*)
             END  (* PENT *) ;

          PCSP :
             BEGIN
                NAME[1] := CH ;
                READ(PFILE,NAME[2],NAME[3]) ;
                WHILE (NAME<>SPTABLE[Q]) AND (Q < SPCNT) DO  Q := Q+1 ;
                IF NAME <> SPTABLE[Q] THEN
                   BEGIN WRITE(NAME:5) ;ERRORL(' UNDEFINED CSP NAME ') END;
             END   (* CSP *) ;

          PLDC :          BEGIN CASE CH OF  (*GET Q*)
                           'I' :BEGIN  P := 1;
                                   REPEAT
                                      READ(PFILE,CH) ;
                                   UNTIL CH = ',' ;
                                   READ(PFILE,I) ;
                                   Q := I
                                END;

                           'C' :BEGIN
                                   P := 1 ;
                                   READ(PFILE,CH) ;  READ(PFILE,CH) ;
                                   READ(PFILE,CH) ;
                                   Q := ORD(CH)
                                END   (* C *) ;

                           'R' :BEGIN  OP := PLCI ; P := 2;
                                   REPEAT
                                      READ(PFILE,CH) ;
                                   UNTIL CH = ',' ;
                                   READ(PFILE,R);
                                   STORE[CPL].VR := R;  Q := MAXSTK;
                                   STYPE[CPL]".STYPE" := REEL ;
                                   REPEAT  Q := Q-1
                                   UNTIL (STYPE[Q]".STYPE" = REEL) AND
                                         (STORE[Q].VR=R);
                                   IF Q=CPL THEN  CPL := CPL-1;
                               """ BEGIN  RCP := RCP+1;
                                      IF RCP=OVERR THEN
                                         ERRORL(' REAL TABLE OVERFLOW')
                                   END  """
                                END;

                           'N' :; (*P,Q = 0*)

                           'B' :BEGIN
                                   P := 3 ;
                                   REPEAT
                                      READ(PFILE,CH) ;
                                   UNTIL CH = ',' ;
                                   READ(PFILE,Q)
                                END   (* B *) ;

                           'S' :BEGIN  OP := PLCI ;   P := 4;
                                   S := [ ];
                                   REPEAT
                                      READ(PFILE,CH) ;
                                   UNTIL CH = '(' ;

                                   FOR I := 3 DOWNTO 0 DO
                                      BEGIN  J := I*16 ;
                                      READ(PFILE,S1,CH) ;
                                      WHILE S1 > 0 DO
                                         BEGIN
                                         IF ODD(S1) THEN S := S+[J] ;
                                         S1 := S1 DIV 2 ;  J := J+1 ;
                                         END ;
                                      END (* FOR I :=..*) ;

                                   STYPE[CPL]".STYPE" := SETT;
                                   STORE[CPL].VS := S;
                                   Q := MAXSTK;
                                   REPEAT  Q := Q-1
                                   UNTIL (STYPE[Q]".STYPE" = SETT) AND
                                         (STORE[Q].VS=S);
                                   IF Q=CPL THEN   CPL := CPL-1;
                              """  BEGIN  SCP := SCP+1;
                                      IF SCP=OVERS THEN
                                         ERRORL(' SET TABLE OVERFLOW ')
                                   END   """
                                END
                           END (*CASE*)
                        END;

          PCHK :        BEGIN  READ(PFILE,LB,UB);

                           CASE CH OF
                           'I','C': T := INT ;
                           'S':     T := SETT ;
                           'A':     T := ADR ;
                           'J':     T := INDEX
                           END ;

                        STORE[CPL-1].VI := LB;  STYPE[CPL-1] := INT;
                        STORE[CPL].VI := UB;  STYPE[CPL] := INT;
                        Q := MAXSTK;
                        REPEAT  Q := Q-2
                        UNTIL (STORE[Q].VI = LB) AND (STORE[Q+1].VI = UB);
                        IF Q <= CPL THEN CPL := CPL-2;
                        END;

          PLCA :        BEGIN  READ(PFILE,CH);  (*CH = FIRST CHAR IN STRING*)
                           I := 0;

                              REPEAT
                                 REPEAT
                                 STRBUF[I] := CH ;
                                 IF I = STRNGLEN THEN
                                    ERRORL(' STRING TABLE OVRFL.') ;
                                 I := I+1;  READ(PFILE,CH)
                                 UNTIL CH = '''' ;
                              READ(PFILE, CH);
                              UNTIL CH <> '''';

                           FOR I := I-1 DOWNTO 0 DO
                              BEGIN
                              STYPE[CPL]".STYPE" := INT;
                              STORE[CPL].VI := ORD(STRBUF[I]);
                              CPL := CPL-1;
                              END;

                           Q := CPL+1;
                        END;

          PNEW,PRST,PSAV :
             BEGIN  (* CHANGE TO CSP CALL *)    P := 0 ;
                IF OP = PNEW THEN
                   REPEAT  (* GET LENGTH *)
                      Q := Q * 10 + ORD(CH) - ORD('0') ;
                      READ(PFILE,CH) ;
                   UNTIL CH = ' ' ;
              " OP := PCSP ;
                WHILE (NAME <> SPTABLE[Q]) AND (Q < 24) DO Q := Q + 1 ;
                IF NAME <> SPTABLE[Q] THEN
                   BEGIN WRITELN(OUTPUT, NAME:8) ;
                   ERRORL(' UNDEFINED CSP NAME ')
                   END; "
             END   (* SAV,NEW,RST *) ;
          PTON: DMP := TRUE


      END; (*CASE*)

      READLN(PFILE);
      (* STORE INSTRUCTION *)

      IF (OP <> PLOC) THEN
            BEGIN
            WITH CODE[PC] DO
               BEGIN  OP1 := OP+ (65536)*P + 256*ORD(T);  Q1 := Q;
               IF DMP THEN
                 WRITELN(OUTPUT, ',  PC: ',PC:5,' OP =',INSTR[OP]:4,
                                 '  (', OP:3, '  T: ', T:1, '  P: ', P:4,
                                 '  Q: ',Q:6, ')' );
               END;

            IF GETSTAT THEN  COUNT ;
            PC := PC+1;  INSTRCNT := INSTRCNT+1 ;
            IF PC > CPL THEN  ERRORL(' CODE AREA OVERFLOW ');
            END ;

   END; (*ASSEMBLE*)
(*----------------------------------------------------------------------------*)

BEGIN (*LOAD*)
   INIT ;      (* INITIALIZE FOR LOADING THE P_PROGRAM *)
   INSTRCNT := 0 ;
   IF GETSTAT THEN  CLEARCOUNTS
   ELSE
      BEGIN
      STAT5 := FALSE ;  STAT3 := FALSE ;  STAT2 := FALSE ;  STAT4 := FALSE
      END ;

   GENERATE;   (* GENERATE THE P_PROGRAM SEGMENT *)

   FOR I := MINPROC TO NXTPROC-1 DO
      WITH LABELTAB[I] DO
      IF ST <> DEFINED THEN
         BEGIN  WRITELN(OUTPUT, ' ':4, PROCTAB[I]:14,I:5) ;
         ERRORL(' UNDEFINED PROC.    ');
         END;

   IF DMP THEN
      FOR I := 0 TO PC-1  DO
         WITH CODE [I] DO
         BEGIN
            OP :=OP1 MOD 256;
            P := OP1 DIV 65536;   T := CHR((OP1 DIV 256) MOD 256);   Q := Q1;
            WRITELN(OUTPUT, ',  PC: ',  I:5, ' OP =', INSTR[OP]:4, '  (', OP:3,
                            '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:6, ')' );
         END;

   TIMER := CLOCK(1);
   PRINT_HEADLN(OUTPUT);

   IF GETSTAT THEN
      BEGIN   REWRITE(SFL);  PRINT_HEADLN(SFL);  SORTE;  PRINTCOUNTS;  END;

   IF PC >= CPL  THEN  ERRORL(' PROGRAM TOO LARGE. ');
   IF EP = 0  THEN  ERRORL(' NO ENTRY POINT.    ');

END; (*LOAD*)

(*------------------------------------------------------------------------*)


PROCEDURE PMD;
   VAR S :INTEGER; I: INTEGER;

   PROCEDURE PT;
   BEGIN
   IF I >= 5 THEN
      BEGIN  WRITELN(OUTPUT);   WRITE(OUTPUT, ' ':5);  I := 0 END;
   WRITE(S:6);
   IF (STYPE[S] < UNDEF) OR (STYPE[S] > MARK) THEN
       BEGIN
       REPEAT S:=S-1
       UNTIL  (S <= 0) OR ((STYPE[S] >= UNDEF) AND (STYPE[S] <= MARK));
       S := S+1;
       WRITE(OUTPUT, '  <G>', S:5);
       END
   ELSE
      CASE STYPE[S]".STYPE" OF
          UNDEF: BEGIN
                    REPEAT S := S-1 UNTIL (S <= 0) OR (STYPE[S] <> UNDEF);
                    S := S+1;
                    WRITE(OUTPUT,'  <U>',S:5)
                 END;
          INT  : WRITE(STORE[S].VI:10);
          REEL : WRITE(STORE[S].VR:10);
          BOOL : IF STORE[S].VB THEN
                    WRITE(OUTPUT,' TRUE ':10)
                 ELSE  WRITE(OUTPUT,' FALSE ':10);
          SETT : WRITE(OUTPUT,' SET ':10) (* WRITE(STORE[S].VS:21 OCT) *) ;
          ADR  : WRITE(OUTPUT,' @  ',STORE[S].VA:6);
          MARK : WRITE(OUTPUT,' .M.',STORE[S].VM:6)
      END; (*CASE*)
      S := S - 1;
      I := I + 1;
   END; (*PT*)

   BEGIN
   WRITELN(OUTPUT);
   WRITELN(OUTPUT, '    ***>  PSW: ');  WRITELN(OUTPUT);
   WRITELN(OUTPUT);
   WRITE(OUTPUT, '    PC: ',PC-1:5,' OP =',INSTR[OP]:4,'  (', OP:3,
                 '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:6, '),  SP =',SP:5,
                 '  MP =',MP:5,'  NP =', NP:5,'  INSTRCNT = ',INSTRCNT:6);
   WRITELN(OUTPUT); WRITELN(OUTPUT);
   WRITELN(OUTPUT, '    ***>  STACK CONTENTS: ');  WRITELN(OUTPUT);

   S := SP;  I := 6;
   WHILE S > 0 DO PT;
   WRITELN(OUTPUT) ;
   S := CPL;   I := 6;
   IF S >= NP THEN
      BEGIN  WRITELN(OUTPUT);  WRITELN(OUTPUT, '    ***>  HEAP CONTENTS: ') ;
      WRITELN(OUTPUT) ;
      END ;
   WHILE S>=NP DO PT;
   WRITELN(OUTPUT);  WRITELN(OUTPUT, '    ***>  END OF DUMP  ***>');
   WRITELN(OUTPUT);
END; (*PMD*)
(*----------------------------------------------------------------------------*)

   PROCEDURE ERRORI0(AD: ADDRESS);

      BEGIN   WRITELN(OUTPUT);  WRITELN(OUTPUT);

      WRITELN(OUTPUT, '    ***>   ADDRESS, TYPE, VALUE: ',
                      AD:6, STYPE[AD]:4, STORE[AD].VI:10) ;
      WRITE(OUTPUT,'    ***>   LOC: ', AD:6, '  VALUE: ') ;
      IF (STYPE[AD] < UNDEF) OR (STYPE[AD] > MARK) THEN
         WRITE(OUTPUT,'.GARBAGE.':10)
      ELSE
        CASE STYPE[AD]".STYPE" OF
          UNDEF: WRITE(OUTPUT,'UNDEF':10);
          INT  : WRITE(STORE[AD].VI:10);
          REEL : WRITE(STORE[AD].VR:10);
          BOOL : IF STORE[AD].VB THEN
                    WRITE(OUTPUT,' TRUE ':10)
                 ELSE  WRITE(OUTPUT,' FALSE ':10);
          SETT : WRITE(OUTPUT,' SET ':10) (* WRITE(STORE[AD].VS:21 OCT) *) ;
          ADR  : WRITE(OUTPUT,' @  ',STORE[AD].VA:6);
          MARK : WRITE(OUTPUT,' .M.',STORE[AD].VM:6)
        END; (*CASE*)

      WRITELN(OUTPUT);  WRITELN(OUTPUT);
      END (*ERRORI0*);
(*----------------------------------------------------------------------------*)

PROCEDURE ERRORI(STRING: BETA);
BEGIN  WRITELN(OUTPUT);  WRITELN(OUTPUT,'    ***>  ', STRING);
      PMD; "EXIT(1002)"
      RETCDE := 1002;  INTERPRETING := FALSE;
END;(*ERRORI*)
(*----------------------------------------------------------------------------*)

FUNCTION BASE(LD :BIT4):INTEGER ;
   VAR AD :ADDRESS;
BEGIN  AD := MP;
   WHILE LD>0 DO
   BEGIN  AD := STORE[AD+1].VM;  LD := LD-1
   END;
   BASE := AD
END; (*BASE*)
(*----------------------------------------------------------------------------*)

PROCEDURE PUSH ;
BEGIN
   SP := SP + 1 ;
   IF SP >= NP THEN
      ERRORI(' STORE OVERFLOW     ')
END   (* PUSH *) ;
(*----------------------------------------------------------------------------*)


   PROCEDURE CALLSP;
      VAR LINE: BOOLEAN; ADPTR,ADELNT,AD: ADDRESS;
          I: INTEGER;
(*----------------------------------------------------------------------------*)

      PROCEDURE READI(VAR F: TEXT);
         VAR AD: ADDRESS;
      BEGIN AD:= STORE[SP].VA;
         READ(F,STORE[AD].VI) ;
         STORE[STORE[SP-1].VA].VI := ORD(F@)  ;    (* UPDATE FILE BUF *)
         STYPE[AD]".STYPE" := INT ;
         SP := SP - 1
      END;(*READI*)
(*----------------------------------------------------------------------------*)

      PROCEDURE READB(VAR F: TEXT);
         VAR AD: ADDRESS;
      BEGIN AD:= STORE[SP].VA;
         READ(F,STORE[AD].VB) ;
         STORE[STORE[SP-1].VA].VI := ORD(F@)  ;    (* UPDATE FILE BUF *)
         STYPE[AD]".STYPE" := BOOL;
         SP := SP - 1
      END;(*READB*)
(*----------------------------------------------------------------------------*)

      PROCEDURE READR(VAR F: TEXT);
         VAR AD: ADDRESS;
      BEGIN AD:= STORE[SP].VA;
         READ(F,STORE[AD].VR) ;
         STORE[STORE[SP-1].VA].VI := ORD(F@)  ;     (* UPDATE FILE BUFFER *)
         STYPE[AD]".STYPE" := REEL ;
         SP := SP - 1
      END;(*READR*)
(*----------------------------------------------------------------------------*)

      PROCEDURE READC(VAR F: TEXT);
         VAR C: CHAR; AD: ADDRESS;
      BEGIN
         READ(F,C) ;
         STORE[STORE[SP-1].VA].VI := ORD(F@)  ;    (* UPDATE FILE BUFFER *)
         AD := STORE[SP].VA ;
         STORE[AD].VI := ORD(C) ;
         STYPE[AD]".STYPE" := INT ;
         SP := SP - 1
      END;(*READC*)
(*----------------------------------------------------------------------------*)

      PROCEDURE READSTR(VAR F: TEXT) ;
         VAR  C : CHAR ;  I :INTEGER ;  AD : ADDRESS ;
         BEGIN   AD := STORE[SP-1].VA ;
         FOR I := 0 TO STORE[SP].VI-1 DO
            BEGIN  READ(F,C) ;
            STORE[AD+I].VI := ORD(C) ;
            STYPE[AD+I]".STYPE" := INT ;
            END ;
         SP := SP-2 ;
         STORE[ STORE[SP].VA ].VI := ORD(F@) ;   (* UPDATE FILE BUFFER *)
         END (* READSTR *) ;
(*----------------------------------------------------------------------------*)

      PROCEDURE WRITESTR(VAR F: TEXT);
         VAR I,J,K: INTEGER;
             AD: ADDRESS;
      BEGIN AD:= STORE[SP-2].VA;
            K:= STORE[SP].VI; J:= STORE[SP-1].VI;
           (* J AND K ARE NUMBERS OF CHARACTERS *)
      (*  K <-- STRING LEN,   J <-- FIELD WIDTH  *)
      IF J > K THEN FOR I := 1 TO J-K DO WRITE(F,' ')
      ELSE  K := J ;
      FOR I := 0 TO K-1 DO WRITE(F,CHR(STORE[AD+I].VI)) ;
      (* IN THE INDEX OF STORE I HAS TO BE MULTIPLIED BY CHARSIZE *)
      SP := SP - 3
      END;(*WRITESTR*)
(*----------------------------------------------------------------------------*)


      PROCEDURE GETFILE(VAR F: TEXT);
         VAR AD: ADDRESS;
      BEGIN AD:=STORE[SP].VA;
         GET(F) ;
         STORE[AD].VI := ORD(F@) ;
      "  SP := SP - 1  "
      END;(*GETFILE*)
(*----------------------------------------------------------------------------*)

      PROCEDURE PUTFILE(VAR F: TEXT);
         VAR AD: ADDRESS;
      BEGIN AD:= STORE[SP].VA;
         F@ := CHR(STORE[AD].VI) ;
         PUT(F)  ;
      "  SP := SP - 1  "
      END;(*PUTFILE*)
(*----------------------------------------------------------------------------*)

   BEGIN (*CALLSP*)
         CASE Q OF
              0 (*GET*) : CASE STORE[SP].VA OF
                               INPUTADR: GETFILE(INPUT);
                               OUTPUTADR: ERRORI(' GET ON OUTPUT FILE ');
                               PRDADR: GETFILE(PRD);
                               PRRADR: ERRORI(' GET ON PRR FILE    ')
                          END;
              1 (*PUT*) : CASE STORE[SP].VA OF
                               INPUTADR: ERRORI(' PUT ON INPUT FILE  ');
                               OUTPUTADR: PUTFILE(OUTPUT);
                               PRDADR: ERRORI(' PUT ON PRD FILE    ');
                               PRRADR: PUTFILE(PRR)
                          END;
              2 (*RST*) : BEGIN NP:= STORE[SP].VI; SP:=SP-1  END ;
              3 (*RLN*) : BEGIN
                             CASE STORE[SP].VA OF
                                INPUTADR: BEGIN READLN(INPUT);
                                          STORE[INPUTADR].VI := ORD(INPUT@) END;
                                 OUTPUTADR: ERRORI(' READLN ON OUTPUT   ');
                                 PRDADR: BEGIN READLN(PRD);
                                         STORE[PRDADR].VI := ORD(PRD@) END;
                                 PRRADR: ERRORI(' READLN ON PRR FILE ');
                                 QRDADR: BEGIN READLN(QRD);
                                         STORE[QRDADR].VI := ORD(QRD@) END;
                             END;
                          "  SP := SP-1  "
                          END;
               4 (*NEW*): BEGIN AD := NP - P ;
                          (*TOP OF STACK GIVES THE ADDRESS TO BE STORED INTO*)
                                IF AD<= SP THEN
                                   ERRORI(' STORE OVERFLOW     ') ;
                                FOR I:=NP-1 DOWNTO AD DO
                                   STYPE[I]".STYPE":= UNDEF;
                                NP:= AD; AD:= STORE[SP].VA;
                                STORE[AD].VA:= NP;
                                STYPE[AD]".STYPE":=ADR;
                                SP := SP - 1
                          END;

               5 (*WLN*): BEGIN
                              CASE STORE[SP].VA OF
                                 INPUTADR: ERRORI(' WRITELN ON INPUT   ');
                                 OUTPUTADR: WRITELN(OUTPUT);
                                 PRDADR: ERRORI(' WRITELN ON PRD FILE');
                                 PRRADR: WRITELN(PRR) ;
                                 QRRADR: WRITELN(QRR) ;
                              END;
                           "  SP:= SP-1  "
                           END;
               6 (*WRS*): CASE STORE[SP-3].VA OF
                               INPUTADR: ERRORI(' WRITE ON INPUT FILE');
                               OUTPUTADR: WRITESTR(OUTPUT);
                               PRDADR: ERRORI(' WRITE ON PRD FILE  ');
                               PRRADR: WRITESTR(PRR) ;
                               QRRADR: WRITESTR(QRR)
                          END;
               7 (*ELN*) : BEGIN
                               CASE STORE[SP].VA OF
                                  INPUTADR: LINE:= EOLN(INPUT);
                                  OUTPUTADR: ERRORI(' EOLN ON OUTPUT FILE');
                                  PRDADR: LINE:=EOLN(PRD);
                                  PRRADR: ERRORI(' EOLN ON PRR FILE   ')
                               END;
                               STORE[SP].VB:= LINE;
                               STYPE[SP]".STYPE":= BOOL ;
                               SP := SP+1 ;
                           END;
               8 (*WRI*) : BEGIN
                               CASE STORE[SP-2].VA OF
                                  INPUTADR: ERRORI(' WRITE ON INPUT FILE');
                                  OUTPUTADR: WRITE(OUTPUT,STORE[SP-1].VI:
                                             STORE[SP].VI);
                                  PRDADR: ERRORI(' WRITE ON PRD FILE  ');
                                  PRRADR: WRITE(PRR,STORE[SP-1].VI:
                                                STORE[SP].VI);
                                  QRDADR: ERRORI(' WRITE ON QRD FILE  ');
                                  QRRADR: WRITE(QRR,STORE[SP-1].VI:
                                                STORE[SP].VI);
                               END;
                              SP:=SP-2
                           END;
               9 (*WRR*) : BEGIN
                               CASE STORE[SP-3].VA OF
                                  INPUTADR: ERRORI(' WRITE ON INPUT FILE');
                                  OUTPUTADR: WRITE(OUTPUT,STORE[SP-2].VR:
                                                   STORE[SP-1].VI:STORE[SP].VI);
                                  PRDADR: ERRORI(' WRITE ON PRD FILE  ');
                                  PRRADR: WRITE(PRR,STORE[SP-2].VR:
                                                STORE[SP-1].VI:STORE[SP].VI);
                                  QRDADR: ERRORI(' WRITE ON QRD FILE  ');
                                  QRRADR: WRITE(QRR,STORE[SP-2].VR:
                                                STORE[SP-1].VI:STORE[SP].VI);
                               END;
                               SP:=SP-3
                          END;
               10 (*WRC*):BEGIN
                              CASE STORE[SP-2].VA OF
                                 INPUTADR: ERRORI(' WRITE ON INPUT FILE');
                                 OUTPUTADR: WRITE(OUTPUT,CHR(STORE[SP-1].VI):
                                                  STORE[SP].VI);
                                 PRDADR: ERRORI(' WRITE ON PRD FILE  ');
                                 PRRADR: WRITE(PRR,CHR(STORE[SP-1].VI):
                                               STORE[SP].VI) ;
                                 QRRADR: WRITE(QRR,CHR(STORE[SP-1].VI):
                                               STORE[SP].VI)
                              END;
                              SP:=SP-2
                          END;
               26(*WRB*) : BEGIN
                              "IF STORE[SP-1].VB THEN  STORE[SP-1].VI := 1
                               ELSE  STORE[SP-1].VI := 0 ;"

                               CASE STORE[SP-2].VA OF
                                  INPUTADR: ERRORI(' WRITE ON INPUT FILE');
                                  OUTPUTADR: WRITE(OUTPUT,STORE[SP-1].VB:
                                             STORE[SP].VI);
                                  PRDADR: ERRORI(' WRITE ON PRD FILE  ');
                                  PRRADR: WRITE(PRR,STORE[SP-1].VB:
                                                STORE[SP].VI) ;
                                  QRDADR: ERRORI(' WRITE ON QRD FILE  ');
                                  QRRADR: WRITE(QRR,STORE[SP-1].VB:
                                                STORE[SP].VI) ;
                               END;
                              SP:=SP-2
                           END;
               11(*RDI*) : CASE STORE[SP-1].VA OF
                               INPUTADR: READI(INPUT);
                               OUTPUTADR: ERRORI(' READ ON OUTPUT FILE');
                               PRDADR: READI(PRD);
                               QRDADR: READI(QRD);
                               PRRADR, QRRADR: ERRORI(' READ ON WRONG FILE ')
                           END;
               12(*RDR*) : CASE STORE[SP-1].VA OF
                               INPUTADR: READR(INPUT);
                               OUTPUTADR: ERRORI(' READ ON OUTPUT FILE');
                               PRDADR: READR(PRD);
                               QRDADR: READR(QRD);
                               PRRADR, QRRADR: ERRORI(' READ ON WRONG FILE ')
                           END;
               31(*RDB*) : CASE STORE[SP-1].VA OF
                               INPUTADR: READB(INPUT);
                               OUTPUTADR: ERRORI(' READ ON OUTPUT FILE');
                               PRDADR: READB(PRD);
                               QRDADR: READB(QRD);
                               PRRADR, QRRADR: ERRORI(' READ ON WRONG FILE ')
                           END;
               13(*RDC*):  CASE STORE[SP-1].VA OF
                               INPUTADR: READC(INPUT);
                               OUTPUTADR: ERRORI(' READ ON OUTPUT FILE');
                               PRDADR: READC(PRD);
                               QRRADR,
                               PRRADR: ERRORI(' READ ON PRR FILE   ') ;
                               QRDADR: READC(QRD);
                           END;
               27(*RDS*):  CASE STORE[SP-2].VA OF
                               INPUTADR: READSTR(INPUT);
                               OUTPUTADR: ERRORI(' READ ON OUTPUT FILE');
                               PRDADR: READSTR(PRD);
                               QRRADR,
                               PRRADR: ERRORI(' READ ON PRR FILE   ') ;
                               QRDADR: READSTR(QRD);
                           END;

               29(*EIO*): SP := SP-1;    (*POP THE FILE ADRE*)

               30(*FDF*): BEGIN ERRORI(' EXTERNAL FILE DEF. ')  END;

               14(*SIN*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ; *)
                             STORE[SP].VR := SIN(STORE[SP].VR)
                          END   (* SIN *) ;
               15(*COS*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ;  *)
                             STORE[SP].VR := COS(STORE[SP].VR)
                          END   (* COS *) ;
               16(*EXP*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ; *)
                             STORE[SP].VR := EXP(STORE[SP].VR)
                          END   (* EXP *) ;
               17(*LOG*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ; *)
                             STORE[SP].VR := LN(STORE[SP].VR)
                          END   (* LOG *) ;
               18(*SQT*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ; *)
                             STORE[SP].VR := SQRT(STORE[SP].VR)
                          END   (* SQT *) ;
               19(*ATN*): BEGIN
                          (* AD := STORE[SP].VA ;
                             STYPE[SP]".STYPE" := REEL ;*)
                             STORE[SP].VR := ARCTAN(STORE[SP].VR)
                          END   (* ATN *) ;
               20(*SAV*): BEGIN AD:=STORE[SP].VA;
                             STYPE[AD]".STYPE":=ADR;
                             STORE[AD].VA:= NP;
                             SP:= SP-1
                          END;
               21(*XIT*): BEGIN  INTERPRETING := FALSE;
                          RETCDE := STORE[SP].VI;
                          END ;
               22 (* RES *):
                  BEGIN
                     CASE STORE[SP].VA OF
                        INPUTADR: RESET(INPUT) ;
                        OUTPUTADR: ERRORI(' RESET ON OUTPUT    ') ;
                        PRDADR: RESET(PRD) ;
                        QRRADR,PRRADR: ERRORI(' RESET ON PRR FILE  ') ;
                        QRDADR: RESET(QRD) ;
                     END   (* CASE STORE[SP].VA *) ;
                  "  SP := SP - 1  "
                  END   (* RES *) ;
               23 (* REW *):
                  BEGIN
                     CASE STORE[SP].VA OF
                        INPUTADR: ERRORI(' REWRITE ON INPUT   ') ;
                        OUTPUTADR: REWRITE(OUTPUT) ;
                        QRDADR,PRDADR: ERRORI(' REWRITE ON PRD FILE') ;
                        PRRADR: REWRITE(PRR) ;
                        QRRADR: REWRITE(QRR)
                     END   (* CASE STORE[SP].VA *) ;
                  "  SP := SP - 1   "
                  END   (* REW *) ;
               24 (* EOF *):
                  BEGIN
                     CASE STORE[SP].VA OF
                        INPUTADR: STORE[SP].VB := EOF(INPUT) ;
                        OUTPUTADR: ERRORI(' EOF ON OUTPUT      ') ;
                        PRDADR: STORE[SP].VB := EOF(PRD) ;
                        QRRADR,PRRADR: ERRORI(' EOF ON PRR FILE    ') ;
                        QRDADR: STORE[SP].VB := EOF(QRD) ;
                     END   (* CASE STORE[SP].VA *) ;
                     STYPE[SP]".STYPE" := BOOL ;  SP := SP+1 ;
                  END   (* EOF *) ;

               25 (* CLK *) :  STORE[SP].VI := CLOCK(STORE[SP].VI) ;

         END;(*CASE Q*)
   END;(*CALLSP*)
(*----------------------------------------------------------------------------*)

PROCEDURE EX0;
   VAR AD,AD1 :ADDRESS;
       I,I1,I2,J  :INTEGER;  B :BOOLEAN;

   PROCEDURE COMPARE;
   BEGIN  I1 := STORE[SP].VA;  I2 := STORE[SP+1].VA;
      I := 0;  B := TRUE;
      WHILE B AND (I<>Q) DO
         IF STORE[I1+I].VI=STORE[I2+I].VI THEN I := I+1
         ELSE B := FALSE
   END; (*COMPARE*)

BEGIN   (* EXO *)
   (* IN THIS PROCEDURE Q MUST NOT BE CORRECTED *)
   CASE OP OF

                PABI:STORE[SP].VI := ABS(STORE[SP].VI);

                PABR:STORE[SP].VR := ABS(STORE[SP].VR);

                PADI:BEGIN  SP := SP-1;
                      STORE[SP].VI := STORE[SP].VI + STORE[SP+1].VI
                   END;

                PADR:BEGIN  SP := SP-1;
                      STORE[SP].VR := STORE[SP].VR + STORE[SP+1].VR
                   END;

                PAND:BEGIN  SP := SP-1;
                      STORE[SP].VB := STORE[SP].VB AND STORE[SP+1].VB
                   END;

                PCHK:IF(STORE[SP].VI < STORE[Q].VI)
                        OR (STORE[SP].VI > STORE[Q+1].VI) THEN
                           ERRORI(' VALUE OUT OF RANGE ');

                PCHR: (* NOTHING TO DO *) ;

                PCSP: CALLSP ;

                PCUP:BEGIN  (*P=NO. OF PARAMETERS, Q=ENTRY POINT*)
(*                   IF CTRACE  THEN                                      (*+*)
(*                      BEGIN                                             (*+*)
(*                      WRITELN(OUTPUT,'     I_CNT: ',INSTRCNT:6,         (*+*)
(*                                     ', SP: ',SP:5,',  NP: ', NP:5,     (*+*)
(*                                     ',  MP: ', MP:5 , ',  PC: ',  PC:5,(*+*)
(*                                     ' OP =', INSTR[OP]:4, '  (', OP:3, (*+*)
(*                                     '  T: ', T:1, '  P: ', P:4,        (*+*)
(*                                     '  Q: ',Q:6, ') --> ',             (*+*)
(*                                     PROCTAB[CODE[Q-1].Q1] );           (*+*)
(*                      END  (* IF CTRCE *) ;                             (*+*)
                      MP := SP-(P + (SAVEAREA-1));
                      STYPE[MP+3]".STYPE" := MARK;
                      STORE[MP+3].VM := PC;
                      PC := Q
                   END;

                PDEC:STORE[SP].VI := STORE[SP].VI - Q;

                PDIF:BEGIN  SP := SP-1;
                      STORE[SP].VS := STORE[SP].VS - STORE[SP+1].VS
                   END;

                PDVI:BEGIN  SP := SP-1;
                      STORE[SP].VI := STORE[SP].VI DIV STORE[SP+1].VI
                   END;

                PDVR:BEGIN  SP := SP-1;
                      STORE[SP].VR := STORE[SP].VR/STORE[SP+1].VR
                   END;

                PENT:BEGIN  J := MP+Q;  (*Q=LENGTH OF DATA SEG*)
                      IF J>NP THEN ERRORI(' STORE OVERFLOW     ');
                      STORE[MP+1].VM := DISPLAY[P] ;  DISPLAY[P] := MP ;
                  """ (*RESET TO UNDEFINED--MAY DECIDE TO REMOVE THIS TEST*)
                      IF SP<INPUTADR THEN SP := PRDADR;
                      FOR I := SP+1 TO J DO STORE[I].STYPE := UNDEF; """
                      STORE[MP+4].VM := CURLVL ;  SP := J;  CURLVL := P ;
                      IF STK_LMT < SP THEN STK_LMT := SP;
                   END;

                PEQU:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI=STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR=STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB=STORE[SP+1].VB;
                        4: STORE[SP].VB := STORE[SP].VS=STORE[SP+1].VS;
                        5: BEGIN  COMPARE;
                              STORE[SP].VB := B;
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PFJP:BEGIN
                   IF NOT STORE[SP].VB THEN
                      BEGIN   PC := Q;
                      IF STAT3 THEN BDCNT[P].CNT := BDCNT[P].CNT+1
                      END ;
                   SP := SP-1
                   END;

                PFLO:BEGIN  STORE[SP-1].VR := STORE[SP-1].VI;
                      STYPE[SP-1]".STYPE" := REEL
                   END;

                PFLT:BEGIN  STORE[SP].VR := STORE[SP].VI;
                      STYPE[SP]".STYPE" := REEL
                   END;

                PGEQ:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI>=STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR>=STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB>=STORE[SP+1].VB;
                        4: STORE[SP].VB := STORE[SP].VS>=STORE[SP+1].VS;
                        5: BEGIN COMPARE;
                              STORE[SP].VB := (STORE[I1+I].VI>=STORE[I2+I].VI)
                                 OR B
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PGRT:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI>STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR>STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB>STORE[SP+1].VB;
                        4: ERRORI(' SET INCLUSION      ');
                        5: BEGIN  COMPARE;
                              STORE[SP].VB := (STORE[I1+I].VI>STORE[I2+I].VI)AND
                                  NOT B
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PINC:BEGIN STORE[SP].VI := STORE[SP].VI + Q;
                     END ;

                PIND:BEGIN  AD := STORE[SP].VI + Q; (* Q IS # OF STORAGE LOCS *)
                      IF STYPE[AD]".STYPE"=UNDEF THEN
                         ERRORI(' VALUE UNDEFINED    ') ;
                      STORE[SP] := STORE[AD] ;    STYPE[SP] := STYPE[AD];
                   END;

                PINN:BEGIN  SP := SP-1;
                      STORE[SP].VB := STORE[SP].VI IN STORE[SP+1].VS;
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PINT:BEGIN  SP := SP-1;
                      STORE[SP].VS := STORE[SP].VS *  STORE[SP+1].VS
                   END;

                PIOR:BEGIN  SP := SP-1;
                      STORE[SP].VB := STORE[SP].VB OR STORE[SP+1].VB
                   END;

                PIXA:BEGIN
                     IF STYPE[SP]".STYPE" = BOOL THEN
                        BEGIN
                        IF STORE[SP].VB THEN STORE[SP].VI := 1
                        ELSE  STORE[SP].VI := 0 ;
                        STYPE[SP]".STYPE" := INT ;
                        END ;
                     IF STYPE[SP]".STYPE" <> INT THEN
                        ERRORI(' NON INTEGER IXA ARG') ;
                     SP := SP-1; (* Q IS A NUMBER OF STORAGE UNITS *)
                      STORE[SP].VA := Q*STORE[SP+1].VI + STORE[SP].VA
                   END;

                PLAO:BEGIN  PUSH;
                      STORE[SP].VA := Q;
                      STYPE[SP]".STYPE" := ADR
                   END;

                PLCA:BEGIN  PUSH;
                      STORE[SP].VA := Q;
                      STYPE[SP]".STYPE" := ADR
                   END;

                PLDA:BEGIN  PUSH;
                      STORE[SP].VA := DISPLAY[P] + Q;
                      STYPE[SP]".STYPE" := ADR
                   END;

                PLDC:BEGIN  PUSH;
                      IF P=1 THEN
                         BEGIN  STORE[SP].VI := Q;
                         STYPE[SP]".STYPE" := INT
                         END ELSE
                      IF P=3 THEN
                         BEGIN  STORE[SP].VB := Q=1;
                         STYPE[SP]".STYPE" := BOOL
                         END
                      ELSE (*LOAD NIL*)
                         BEGIN  STORE[SP].VA := NILVAL;
                         STYPE[SP]".STYPE" := ADR
                         END
                   END;

                PLDO:BEGIN
                      IF STYPE[Q]".STYPE"=UNDEF THEN
                        ERRORI(' VALUE UNDEFINED    ') ;
                      IF STYPE[Q]".STYPE" <> T THEN
                         BEGIN  ERRORI0(AD);
                         ERRORI(' INCOMPATIBLE TYPE  ') ;
                         END;
                      PUSH;
                      STORE[SP] := STORE[Q];  STYPE[SP] := STYPE[Q];
                   END;

                PLEQ:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI<=STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR<=STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB<=STORE[SP+1].VB;
                        4: STORE[SP].VB := STORE[SP].VS<=STORE[SP+1].VS;
                        5: BEGIN  COMPARE;
                              STORE[SP].VB := (STORE[I1+I].VI<=STORE[I2+I].VI)
                                 OR B
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PLES:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI<STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR<STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB<STORE[SP+1].VB;
                        5: BEGIN  COMPARE;
                              STORE[SP].VB := (STORE[I1+I].VI<STORE[I2+I].VI)AND
                                 NOT B
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;


               PLOD:BEGIN  AD := DISPLAY[P] + Q;
                      IF STYPE[AD]".STYPE"=UNDEF THEN
                         ERRORI(' VALUE UNDEFINED    ') ;
                      IF STYPE[AD]".STYPE" <> T THEN
                         BEGIN  ERRORI0(AD);
                         ERRORI(' INCOMPATIBLE TYPE  ') ;
                         END;
                      PUSH;
                      STORE[SP] := STORE[AD];  STYPE[SP] := STYPE[AD];
                   END

   END  (* CASE *)
END   (* EX0 *) ;
(*----------------------------------------------------------------------------*)

PROCEDURE EX1;
   VAR AD,AD1 :ADDRESS;
       I,I1,I2,J  :INTEGER;  B :BOOLEAN;

   PROCEDURE COMPARE;
   BEGIN  I1 := STORE[SP].VA;  I2 := STORE[SP+1].VA;
      I := 0;  B := TRUE;
      WHILE B AND (I<>Q) DO
         IF STORE[I1+I].VI=STORE[I2+I].VI THEN I := I+1
         ELSE B := FALSE
   END; (*COMPARE*)

BEGIN   (* EX1 *)
   (* IN THIS PROCEDURE Q MUST NOT BE CORRECTED *)
   CASE OP OF

                PMOD:BEGIN  SP := SP-1;
                      STORE[SP].VI := STORE[SP].VI MOD STORE[SP+1].VI
                   END;

                PMOV: BEGIN I1 := STORE[SP-1].VA; I2 := STORE[SP].VA;
                         SP := SP - 2 ;
                       FOR I := 0 TO Q-1 DO
                          BEGIN
                          STORE[I1+I] := STORE[I2+I]; STYPE[I1+I] := STYPE[I2+I]
                          END;
                      (* Q IS A NUMBER OF STORAGE UNITS *)
                    END;

                PMPI:BEGIN  SP := SP-1;
                      STORE[SP].VI := STORE[SP].VI * STORE[SP+1].VI
                   END;

                PMPR:BEGIN  SP := SP-1;
                      STORE[SP].VR := STORE[SP].VR * STORE[SP+1].VR
                   END;

                PMST:BEGIN (*P=LEVEL OF CALLED PROCEDURE , SET DL
                             SL WILL BE SET AT 'ENT', INCREMENT SP*)
                      STYPE[SP+1]".STYPE" := UNDEF;
                      (* THEN LENTH OF THIS ELEMENT IS
                        MAX(INTSIZE,REALSIZE,BOOLSIZE,CHARSIZE,PTRSIZE *)
                      STYPE[SP+2]".STYPE" := MARK;
                      (* THE LENGTH OF THIS ELEMENT IS PTRSIZE *)
                      STYPE[SP+3]".STYPE" := MARK;
                      STORE[SP+3].VM := MP;
                      (* IDEM *)
                      "STYPE[SP+4]¯.STYPE := UNDEF;"
                      (* IDEM *)
                      SP := SP+SAVEAREA ;
                   END;

                PNEQ:BEGIN  SP := SP-1;
                      CASE P OF
                      0,1: STORE[SP].VB := STORE[SP].VI<>STORE[SP+1].VI;
                        2: STORE[SP].VB := STORE[SP].VR<>STORE[SP+1].VR;
                        3: STORE[SP].VB := STORE[SP].VB<>STORE[SP+1].VB;
                        4: STORE[SP].VB := STORE[SP].VS<>STORE[SP+1].VS;
                        5: BEGIN  COMPARE;
                              STORE[SP].VB := NOT B;
                           END
                      END; (*CASE P*)
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PNGI:STORE[SP].VI := -STORE[SP].VI;

                PNGR:STORE[SP].VR := -STORE[SP].VR;

                PNOT:STORE[SP].VB := NOT STORE[SP].VB;

                PODD:BEGIN  STORE[SP].VB := ODD(STORE[SP].VI);
                      STYPE[SP]".STYPE" := BOOL
                   END;

                PORD:
                     BEGIN
                        IF STYPE[SP]".STYPE" = BOOL THEN
                           BEGIN
                              IF STORE[SP].VB THEN  STORE[SP].VI := 1
                              ELSE STORE[SP].VI := 0 ;
                              STYPE[SP]".STYPE" := INT ;
                           END ;
                           IF STYPE[SP]".STYPE" <> INT THEN
                              ERRORI(' NON INT ARG FOR ORD') ;
                     END ;

                PNEW:      BEGIN AD := NP - Q ;
                           (*TOP OF STACK GIVES THE ADDRESS TO BE STORED INTO*)
                                 IF AD<= SP THEN
                                    ERRORI(' STORE OVERFLOW     ') ;
                                 FOR I:=NP-1 DOWNTO AD DO
                                    STYPE[I]".STYPE":= UNDEF;
                                 NP:= AD; AD:= STORE[SP].VA;
                                 STORE[AD].VA:= NP;
                                 STYPE[AD]".STYPE":=ADR;
                                 SP := SP - 1;
                                 IF HEAP_LMT > NP THEN  HEAP_LMT := NP;
                           END(*PNEW*);

                PPRE: BEGIN  STORE[SP].VI := STORE[SP].VI-1; END;

                PRST:      BEGIN NP:= STORE[SP].VI; SP:=SP-1  END ;

                PSAV :     BEGIN AD:=STORE[SP].VA;
                              STYPE[AD]".STYPE":=ADR;
                              STORE[AD].VA:= NP;
                              SP:= SP-1
                           END(*PSAV*);

                PRET :
                     BEGIN
                        IF T = UNDEF THEN  SP := MP-1
                        ELSE
                          BEGIN SP := MP; "STORE[SP] := STORE[MP+FUNCRSLT]" END;
                        PC:= STORE[MP+3].VM;
                        DISPLAY[CURLVL] := STORE[MP+1].VM ;  (*RESTORE DISPLAY*)
                        CURLVL := STORE[MP+4].VM ;
                        MP:= STORE[MP+2].VM ;   (*=DISPLAY[CURLVL]*)
                     END  (*PRET*) ;

                PSBI:BEGIN SP := SP-1;
                      STORE[SP].VI := STORE[SP].VI - STORE[SP+1].VI
                   END;

                PSBR:BEGIN  SP := SP-1;
                      STORE[SP].VR := STORE[SP].VR - STORE[SP+1].VR
                   END ;

                PSGS:BEGIN  STORE[SP].VS := [STORE[SP].VI];
                      STYPE[SP]".STYPE" := SETT
                   END;

                PSQI:STORE[SP].VI := SQR(STORE[SP].VI);

                PSQR:STORE[SP].VR := SQR(STORE[SP].VR);

                PSRO: BEGIN
                      STORE[Q] := STORE[SP];  STYPE[Q] := STYPE[SP];
                      SP := SP-1
                      END;

                PSTO: BEGIN  AD := STORE[SP-1].VA;
                      STORE[AD] := STORE[SP];  STYPE[AD] := STYPE[SP];
                      SP := SP-2
                      END;

                PSTP: BEGIN  INTERPRETING := FALSE;  RETCDE := 0;  END;

                PSUC: BEGIN  STORE[SP].VI := STORE[SP].VI+1;   END;

                PSTR: BEGIN  AD := DISPLAY[P]+Q;
                      STORE[AD] := STORE[SP]; STYPE[AD] := STYPE[SP];
                      SP := SP-1
                      END;

                PTOF: TRCE := FALSE ;

                PTON: TRCE := TRUE ;

                PTRC: BEGIN STORE[SP].VI := TRUNC(STORE[SP].VR);
                      STYPE[SP]".STYPE" := INT ;
                      END;

                PUJP: BEGIN  PC := Q;
                      IF STAT3 THEN   BDCNT[P].CNT := BDCNT[P].CNT+1
                      END ;

                PUNI: BEGIN  SP := SP-1;
                      STORE[SP].VS := STORE[SP].VS +  STORE[SP+1].VS
                      END ;

                PXJP: BEGIN
                      IF STYPE[SP]".STYPE" <> INT THEN
                         ERRORI(' NON INT ARG FOR XJP') ;
                      I1 := CODE[PC].Q1 ; (*ASSUME OFF CASE TABLE RANGE*)
                      I := STORE[SP].VI ;
                      IF I <= CODE[PC+2].Q1  THEN   (*CHECK AGAINS UPPER BOUND*)
                         BEGIN  I := I-CODE[PC+1].Q1 ; (*SUBTRACT LOWER BOUND*)
                         IF I >= 0 THEN  I1 := I+Q ; (*ADJUST PC IF IN RANGE*)
                         END ;
                      PC := I1 ;   SP := SP-1 ;
                      END ;

                PLCI: BEGIN  PUSH; STORE[SP] := STORE[Q]; STYPE[SP] := STYPE[Q];
                      END

       END (*CASE OP*)
END   (* EX1 *) ;

(*------------------------------------------------------------------------*)

BEGIN   (*PCODE_INTERPRETER*)   (*  M A I N  *)
   TIMER := 0;
   LOAD;  (* ASSEMBLES AND STORES CODE *)
   WRITELN(OUTPUT); (*FOR TESTING*)
   SP := LSTBUF;  MP := 0;  NP := CPL+1;
   STORE[1].VM := 0 ;  STORE[2].VM := 0 ;   (* SL AND DL FOR THE MAIN BLK *)
   STORE[3].VM := PC-1 ;                    (* RETURN ADDRESS FOR MAINBLK *)
   FOR P := 2 TO 10 DO DISPLAY[P] := -1 ;
   DISPLAY[1] := 0 ;  CURLVL := 1 ;
   PC := EP;   RETCDE := 0;  INSTRCNT := 0;  STK_LMT := 0;  HEAP_LMT := CPL;
   STYPE[INPUTADR]".STYPE" := INT;
   STORE[INPUTADR].VI := ORD(INPUT@);
   STYPE[PRDADR]".STYPE":= INT;
   STORE[PRDADR].VI:= ORD(PRD@);
   STYPE[OUTPUTADR]".STYPE":= UNDEF;  STYPE[QRRADR]".STYPE" := UNDEF ;
   GETSTAT :=TRUE;
   IF GETSTAT THEN
     BEGIN
     STAT1:= TRUE ; STAT4:= TRUE ;  STAT2:= TRUE ; STAT3:= TRUE ; STAT5:= TRUE ;
     END;

   INTERPRETING := TRUE;  LOADING := FALSE ;
   IF GETSTAT THEN  CLEARCOUNTS ;


   (* BEGIN INTERPRETING THE PROGRAM *)

   REPEAT   (* INTERPRET ALL INSTRUCTIONS *)
      WITH CODE[PC ] DO
         BEGIN   Q := Q1 ; OP := OP1 MOD 256;
         P := OP1 DIV (65536);  T := CHR((OP1 DIV 256) MOD 256);
         END;
      IF TRCE (*OR ((INSTRCNT MOD 1000) = 0)*) THEN
      BEGIN
         WRITE(OUTPUT,'     I_CNT: ',INSTRCNT:6,', SP: ',SP:5,',  NP: ', NP:5,
                      ',  MP: ', MP:5);
         WRITELN(OUTPUT, ',  PC: ',  PC:5, ' OP =', INSTR[OP]:4, '  (', OP:3,
                         '  T: ', T:1, '  P: ', P:4,'  Q: ',Q:6, ')' );
      END  (* TRCE *) ;

      (* EXECUTION COUNTERS *)

      PC := PC+1;  INSTRCNT := INSTRCNT+1 ;
      IF GETSTAT THEN  COUNT ;

      (*EXECUTE*)

      IF OP <= PLOD THEN EX0 ELSE EX1 ;

   UNTIL NOT INTERPRETING ;


   TIMER := CLOCK(1)-TIMER;
   WRITELN(OUTPUT) ;    WRITELN(OUTPUT) ;
   WRITELN(OUTPUT,'    >>>>  EXITING USER PROGRAM,  RETURN CODE = ',RETCDE:2);

   PRINT_HEADLN(OUTPUT);

   IF GETSTAT THEN  BEGIN  PRINT_HEADLN(SFL);  PRINTCOUNTS;  END;

   EXIT(RETCDE);

END.
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB PRETTY   EXT PAS HEX -
(*====================================================================*)
(*                                                                    *)
(*  PROGRAM TITLE: PASCAL PRETTYPRINTING PROGRAM                      *)
(*                                                                    *)
(*  AUTHORS: JON F. HUERAS AND HENRY F. LEDGARD                       *)
(*           COMPUTER AND INFORMATION SCIENCE DEPARTMENT              *)
(*           UNIVERSITY OF MASSACHUSETTS, AMHERST                     *)
(*           (EARLIER VERSIONS AND CONTRIBUTIONS BY RANDY CHOW        *)
(*            AND JOHN GORMAN.)                                       *)
(*                                                                    *)
(*  PROGRAM SUMMARY:                                                  *)
(*                                                                    *)
(*     THIS PROGRAM TAKES AS INPUT A PASCAL PROGRAM AND               *)
(*     REFORMATS THE PROGRAM ACCORDING TO A STANDARD SET OF           *)
(*     PRETTYPRINTING RULES. THE PRETTYPRINTED PROGRAM IS GIVEN       *)
(*     AS OUTPUT.  THE PRETTYPRINTING RULES ARE GIVEN BELOW.          *)
(*                                                                    *)
(*     AN IMPORTANT FEATURE IS THE PROVISION FOR THE USE OF EXTRA     *)
(*     SPACES AND EXTRA BLANK LINES.  THEY MAY BE FREELY INSERTED BY  *)
(*     THE USER IN ADDITION TO THE SPACES AND BLANK LINES INSERTED    *)
(*     BY THE PRETTYPRINTER.                                          *)
(*                                                                    *)
(*     NO ATTEMPT IS MADE TO DETECT OR CORRECT SYNTACTIC ERRORS IN    *)
(*     THE USER'S PROGRAM.  HOWEVER, SYNTACTIC ERRORS MAY RESULT IN   *)
(*     ERRONEOUS PRETTYPRINTING.                                      *)
(*                                                                    *)
(*                                                                    *)
(*  INPUT FILE: INPUTFL      - A FILE OF CHARACTERS, PRESUMABLY A     *)
(*                             PASCAL PROGRAM OR PROGRAM FRAGMENT.    *)
(*                                                                    *)
(*  OUTPUT FILES: OUTPUTFL   - THE PRETTYPRINTED PROGRAM.             *)
(*                                                                    *)
(*                OUTPUT     - STANDARD PASCAL FILE FOR RUNTIME       *)
(*                             MESSAGES.                              *)
(*                                                                    *)
(*                                                                    *)
(*====================================================================*)


(*====================================================================*)
(*                                                                    *)
(*                   PASCAL PRETTYPRINTING RULES                      *)
(*                                                                    *)
(*                                                                    *)
(*  [ GENERAL PRETTYPRINTING RULES ]                                  *)
(*                                                                    *)
(*   1.   ANY SPACES OR BLANK LINES BEYOND THOSE GENERATED BY THE     *)
(*     PRETTYPRINTER ARE LEFT ALONE.  THE USER IS ENCOURAGED, FOR THE *)
(*     SAKE OF READABILITY, TO MAKE USE OF THIS FACILITY.             *)
(*        IN ADDITION, COMMENTS ARE LEFT WHERE THEY ARE FOUND, UNLESS *)
(*     THEY ARE SHIFTED RIGHT BY PRECEEDING TEXT ON A LINE.           *)
(*                                                                    *)
(*   2.   ALL STATEMENTS AND DECLARATIONS BEGIN ON SEPARATE LINES.    *)
(*                                                                    *)
(*   3.   NO LINE MAY BE GREATER THAN 72 CHARACTERS LONG.  ANY LINE   *)
(*     LONGER THAN THIS IS CONTINUED ON A SEPARATE LINE.              *)
(*                                                                    *)
(*   4.   THE KEYWORDS "BEGIN", "END", "REPEAT", AND "RECORD" ARE     *)
(*     FORCED TO STAND ON LINES BY THEMSELVES (OR POSSIBLY FOLLWED BY *)
(*     SUPPORTING COMMENTS).                                          *)
(*        IN  ADDITION, THE "UNTIL" CLAUSE OF A "REPEAT-UNTIL" STATE- *)
(*     MENT IS FORCED TO START ON A NEW LINE.                         *)
(*                                                                    *)
(*   5.   A BLANK LINE IS FORCED BEFORE THE KEYWORDS "PROGRAM",       *)
(*     "PROCEDURE", "FUNCTION", "LABEL", "CONST", "TYPE", AND "VAR".  *)
(*                                                                    *)
(*   6.   A SPACE IS FORCED BEFORE AND AFTER THE SYMBOLS ":=" AND     *)
(*     "=".  ADDITIONALLY, A SPACE IS FORCED AFTER THE SYMBOL ":".    *)
(*                                                                    *)
(*                                                                    *)
(*  [ INDENTATION RULES ]                                             *)
(*                                                                    *)
(*   1.   THE BODIES OF "LABEL", "CONST", "TYPE", AND "VAR" DECLARA-  *)
(*     TIONS ARE INDENTED FROM THEIR CORRESPONDING DECLARATION HEADER *)
(*     KEYWORDS.                                                      *)
(*                                                                    *)
(*   2.   THE BODIES OF "BEGIN-END", "REPEAT-UNTIL", "FOR", "WHILE",  *)
(*     "WITH", AND "CASE" STATEMENTS, AS WELL AS "RECORD-END" STRUC-  *)
(*     TURES AND "CASE" VARIANTS (TO ONE LEVEL) ARE INDENTED FROM     *)
(*     THEIR HEADER KEYWORDS.                                         *)
(*                                                                    *)
(*   3.   AN "IF-THEN-ELSE" STATEMENT IS INDENTED AS FOLLOWS:         *)
(*                                                                    *)
(*             IF <EXPRESSION>                                        *)
(*                THEN                                                *)
(*                   <STATEMENT>                                      *)
(*                ELSE                                                *)
(*                   <STATEMENT>                                      *)
(*                                                                    *)
(*                                                                    *)
(*====================================================================*)


(*====================================================================*)
(*                                                                    *)
(*                      GENERAL ALGORITHM                             *)
(*                                                                    *)
(*                                                                    *)
(*      THE STRATEGY OF THE PRETTYPRINTER IS TO SCAN SYMBOLS FROM     *)
(*   THE INPUT PROGRAM AND MAP EACH SYMBOL INTO A PRETTYPRINTING      *)
(*   ACTION, INDEPENDENTLY OF THE CONTEXT IN WHICH THE SYMBOL         *)
(*   APPEARS.  THIS IS ACCOMPLISHED BY A TABLE OF PRETTYPRINTING      *)
(*   OPTIONS.                                                         *)
(*                                                                    *)
(*      FOR EACH DISTINGUISHED SYMBOL IN THE TABLE, THERE IS AN       *)
(*   ASSOCIATED SET OF OPTIONS.  IF THE OPTION HAS BEEN SELECTED FOR  *)
(*   THE SYMBOL BEING SCANNED, THEN THE ACTION CORRESPONDING WITH     *)
(*   EACH OPTION IS PERFORMED.                                        *)
(*                                                                    *)
(*      THE BASIC ACTIONS INVOLVED IN PRETTYPRINTING ARE THE INDENT-  *)
(*   ATION AND DE-INDENTATION OF THE MARGIN.  EACH TIME THE MARGIN IS *)
(*   INDENTED, THE PREVIOUS VALUE OF THE MARGIN IS PUSHED ONTO A      *)
(*   STACK, ALONG WITH THE NAME OF THE SYMBOL THAT CAUSED IT TO BE    *)
(*   INDENTED.  EACH TIME THE MARGIN IS DE-INDENTED, THE STACK IS     *)
(*   POPPED OFF TO OBTAIN THE PREVIOUS VALUE OF THE MARGIN.           *)
(*                                                                    *)
(*      THE PRETTYPRINTING OPTIONS ARE PROCESSED IN THE FOLLOWING     *)
(*   ORDER, AND INVOKE THE FOLLOWING ACTIONS:                         *)
(*                                                                    *)
(*                                                                    *)
(*     CRSUPPRESS      - IF A CARRIAGE RETURN HAS BEEN INSERTED       *)
(*                       FOLLOWING THE PREVIOUS SYMBOL, THEN IT IS    *)
(*                       INHIBITED UNTIL THE NEXT SYMBOL IS PRINTED.  *)
(*                                                                    *)
(*     CRBEFORE        - A CARRIAGE RETURN IS INSERTED BEFORE THE     *)
(*                       CURRENT SYMBOL (UNLESS ONE IS ALREADY THERE) *)
(*                                                                    *)
(*     BLANKLINEBEFORE - A BLANK LINE IS INSERTED BEFORE THE CURRENT  *)
(*                       SYMBOL (UNLESS ALREADY THERE).               *)
(*                                                                    *)
(*     DINDENTONKEYS   - IF ANY OF THE SPECIFIED KEYS ARE ON TOP OF   *)
(*                       OF THE STACK, THE STACK IS POPPED, DE-INDEN- *)
(*                       TING THE MARGIN.  THE PROCESS IS REPEATED    *)
(*                       UNTIL THE TOP OF THE STACK IS NOT ONE OF THE *)
(*                       SPECIFIED KEYS.                              *)
(*                                                                    *)
(*     DINDENT         - THE STACK IS UNCONDITIONALLY POPPED AND THE  *)
(*                       MARGIN IS DE-INDENTED.                       *)
(*                                                                    *)
(*     SPACEBEFORE     - A SPACE IS INSERTED BEFORE THE SYMBOL BEING  *)
(*                       SCANNED (UNLESS ALREADY THERE).              *)
(*                                                                    *)
(*     [ THE SYMBOL IS PRINTED AT THIS POINT ]                        *)
(*                                                                    *)
(*     SPACEAFTER      - A SPACE IS INSERTED AFTER THE SYMBOL BEING   *)
(*                       SCANNED (UNLESS ALREADY THERE).              *)
(*                                                                    *)
(*     GOBBLESYMBOLS   - SYMBOLS ARE CONTINUOUSLY SCANNED AND PRINTED *)
(*                       WITHOUT ANY PROCESSING UNTIL ONE OF THE      *)
(*                       SPECIFIED SYMBOLS IS SEEN (BUT NOT GOBBLED). *)
(*                                                                    *)
(*     INDENTBYTAB     - THE MARGIN IS INDENTED BY A STANDARD AMOUNT  *)
(*                       FROM THE PREVIOUS MARGIN.                    *)
(*                                                                    *)
(*     INDENTTOCLP     - THE MARGIN IS INDENTED TO THE CURRENT LINE   *)
(*                       POSITION.                                    *)
(*                                                                    *)
(*     CRAFTER         - A CARRIAGE RETURN IS INSERTED FOLLOWING THE  *)
(*                       SYMBOL SCANNED.                              *)
(*                                                                    *)
(*                                                                    *)
(*                                                                    *)
(*====================================================================*)


PROGRAM PRETTYPRINT """ ( (* FROM *)  INPUTFL  ,
                     (* TO *)    OUTPUTFL  ,
                     (* USING *) OUTPUT ) """ ;


CONST

      MAXSYMBOLSIZE = 200; (* THE MAXIMUM SIZE (IN CHARACTERS) OF A   *)
                           (* SYMBOL SCANNED BY THE LEXICAL SCANNER.  *)

      MAXSTACKSIZE  = 100; (* THE MAXIMUM NUMBER OF SYMBOLS CAUSING   *)
                           (* INDENTATION THAT MAY BE STACKED.        *)

      MAXKEYLENGTH  =  10; (* THE MAXIMUM LENGTH (IN CHARACTERS) OF A *)
                           (* PASCAL RESERVED KEYWORD.                *)
      MAXLINESIZE   =  72; (* THE MAXIMUM SIZE (IN CHARACTERS) OF A   *)
                           (* LINE OUTPUT BY THE PRETTYPRINTER.       *)

      SLOWFAIL1     =  30; (* UP TO THIS COLUMN POSITION, EACH TIME   *)
                           (* "INDENTBYTAB" IS INVOKED, THE MARGIN    *)
                           (* WILL BE INDENTED BY "INDENT1".          *)

      SLOWFAIL2     =  48; (* UP TO THIS COLUMN POSITION, EACH TIME   *)
                           (* "INDENTBYTAB" IS INVOKED, THE MARGIN    *)
                           (* WILL BE INDENTED BY "INDENT2".  BEYOND  *)
                           (* THIS, NO INDENTATION OCCURS.            *)

      INDENT1       =   3;

      INDENT2       =   1;


      SPACE = ' ';


TYPE

     KEYSYMBOL = ( PROGSYM,    FUNCSYM,     PROCSYM,
                   LABELSYM,   CONSTSYM,    TYPESYM,   VARSYM,
                   BEGINSYM,   REPEATSYM,   RECORDSYM,
                   CASESYM,    CASEVARSYM,  OFSYM,
                   FORSYM,     WHILESYM,    WITHSYM,   DOSYM,
                   IFSYM,      THENSYM,     ELSESYM,
                   ENDSYM,     UNTILSYM,
                   BECOMES,    OPENCOMMENT, CLOSECOMMENT,
                   SEMICOLON,  COLON,       EQUALS,
                   OPENPAREN,  CLOSEPAREN,  PERIOD,
                   ENDOFFILE,
                   OTHERSYM );

     OPTION = ( CRSUPPRESS,
                CRBEFORE,
                BLANKLINEBEFORE,
                DINDENTONKEYS,
                DINDENT,
                SPACEBEFORE,
                SPACEAFTER,
                GOBBLESYMBOLS,
                INDENTBYTAB,
                INDENTTOCLP,
                CRAFTER );

     OPTIONSET = SET OF OPTION;

     KEYSYMSET = SET OF KEYSYMBOL;

     TABLEENTRY = RECORD
                     OPTIONSSELECTED  : OPTIONSET;
                     DINDENTSYMBOLS   : KEYSYMSET;
                     GOBBLETERMINATORS: KEYSYMSET
                  END;

     OPTIONTABLE = ARRAY [ KEYSYMBOL ] OF TABLEENTRY;


     KEY = PACKED ARRAY [ 1..MAXKEYLENGTH ] OF CHAR;


     KEYWORDTABLE = ARRAY [ PROGSYM..UNTILSYM ] OF KEY;


     SPECIALCHAR = PACKED ARRAY [ 1..2 ] OF CHAR;

     DBLCHRSET = SET OF BECOMES..OPENCOMMENT;

     DBLCHARTABLE = ARRAY [ BECOMES..OPENCOMMENT ] OF SPECIALCHAR;

     SGLCHARTABLE = ARRAY [ SEMICOLON..PERIOD ] OF CHAR;


     STRING = ARRAY [ 1..MAXSYMBOLSIZE ] OF CHAR;

     SYMBOL = RECORD
                 NAME        : KEYSYMBOL;
                 VALUE       : STRING;
                 LENGTH      : INTEGER;
                 SPACESBEFORE: INTEGER;
                 CRSBEFORE   : INTEGER
              END;

     SYMBOLINFO = @SYMBOL;


     CHARNAME = ( LETTER,    DIGIT,    BLANK,    QUOTE,
                  ENDOFLINE, FILEMARK, OTHERCHAR       );

     CHARINFO = RECORD
                   NAME : CHARNAME;
                   VALUE: CHAR
                END;


     STACKENTRY = RECORD
                     INDENTSYMBOL: KEYSYMBOL;
                     PREVMARGIN  : INTEGER
                  END;

     SYMBOLSTACK = ARRAY [ 1..MAXSTACKSIZE ] OF STACKENTRY;


VAR

    INPUTFL  ,
    OUTPUTFL  : TEXT;

    RECORDSEEN: BOOLEAN;

    CURRCHAR,
    NEXTCHAR: CHARINFO;

    CURRSYM,
    NEXTSYM: SYMBOLINFO;

    CRPENDING: BOOLEAN;

    PPOPTION: OPTIONTABLE;

    KEYWORD: KEYWORDTABLE;

    DBLCHARS: DBLCHRSET;

    DBLCHAR: DBLCHARTABLE;
    SGLCHAR: SGLCHARTABLE;

    STACK: SYMBOLSTACK;
    TOP  : INTEGER;

    CURRLINEPOS,
    CURRMARGIN :  INTEGER;


PROCEDURE GETCHAR( (* FROM *)      VAR INPUTFL   : TEXT;
                   (* UPDATING *)  VAR NEXTCHAR  : CHARINFO;
                   (* RETURNING *) VAR CURRCHAR  : CHARINFO );

   FUNCTION ATOZ(C: CHAR): BOOLEAN;

     BEGIN
     ATOZ := (('A' <= C) AND (C <= 'Z')) OR
             (('a' <= C) AND (C <= 'i')) OR
             (('j' <= C) AND (C <= 'r')) OR
             (('s' <= C) AND (C <= 'z')) ;
     END ;


BEGIN (* GETCHAR *)

   CURRCHAR := NEXTCHAR;

   WITH NEXTCHAR DO
      BEGIN

         IF EOF(INPUTFL)
            THEN
               NAME  := FILEMARK

    ELSE IF EOLN(INPUTFL)
            THEN
               NAME  := ENDOFLINE

    ELSE IF ATOZ(INPUTFL@) """INPUTFL@ IN ['A'..'Z']"""
            THEN
               NAME  := LETTER

    """ELSE  IF NPUTFL@ IN ['0'..'9']"""
    ELSE IF (INPUTFL@ >= '0')AND(INPUTFL@ <= '9')
            THEN
               NAME  := DIGIT

    ELSE IF INPUTFL  @ = ''''
            THEN
               NAME  := QUOTE

    ELSE IF INPUTFL  @ = SPACE
            THEN
               NAME  := BLANK

    ELSE NAME := OTHERCHAR;


         IF NAME IN [ FILEMARK, ENDOFLINE ]
            THEN
               VALUE := SPACE
            ELSE
               VALUE := INPUTFL  @;

         IF NAME <> FILEMARK
            THEN
               GET(INPUTFL  )

      END (* WITH *)

END; (* GETCHAR *)


PROCEDURE STORENEXTCHAR( (* FROM *)        VAR INPUTFL   : TEXT;
                         (* UPDATING *)    VAR LENGTH    : INTEGER;
                                           VAR CURRCHAR,
                                               NEXTCHAR  : CHARINFO;
                         (* PLACING IN *)  VAR VALUE     : STRING   );

BEGIN (* STORENEXTCHAR *)

   GETCHAR( (* FROM *)      INPUTFL  ,
            (* UPDATING *)  NEXTCHAR,
            (* RETURNING *) CURRCHAR  );

   IF LENGTH < MAXSYMBOLSIZE
      THEN
         BEGIN

            LENGTH := LENGTH + 1;

            VALUE [LENGTH] := CURRCHAR.VALUE

         END

END; (* STORENEXTCHAR *)


PROCEDURE SKIPSPACES( (* IN *)        VAR INPUTFL      : TEXT;
                      (* UPDATING *)  VAR CURRCHAR,
                                          NEXTCHAR     : CHARINFO;
                      (* RETURNING *) VAR SPACESBEFORE,
                                          CRSBEFORE    : INTEGER  );

BEGIN (* SKIPSPACES *)

   SPACESBEFORE := 0;
   CRSBEFORE    := 0;

   WHILE NEXTCHAR.NAME IN [ BLANK, ENDOFLINE ] DO
      BEGIN

         GETCHAR( (* FROM *)      INPUTFL  ,
                  (* UPDATING *)  NEXTCHAR,
                  (* RETURNING *) CURRCHAR  );

         CASE CURRCHAR.NAME OF

            BLANK     : SPACESBEFORE := SPACESBEFORE + 1;

            ENDOFLINE : BEGIN
                           CRSBEFORE    := CRSBEFORE + 1;
                           SPACESBEFORE := 0
                        END

         END (* CASE *)

      END (* WHILE *)

END; (* SKIPSPACES *)


PROCEDURE GETCOMMENT( (* FROM *)     VAR INPUTFL   : TEXT;
                      (* UPDATING *) VAR CURRCHAR,
                                         NEXTCHAR  : CHARINFO;
                                     VAR NAME      : KEYSYMBOL;
                                     VAR VALUE     : STRING;
                                     VAR LENGTH    : INTEGER   );

BEGIN (* GETCOMMENT *)

   NAME := OPENCOMMENT;

   WHILE NOT(    ((CURRCHAR.VALUE = '*') AND (NEXTCHAR.VALUE = ')'))
              OR (NEXTCHAR.NAME = ENDOFLINE)
              OR (NEXTCHAR.NAME = FILEMARK)) DO

      STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                     (* UPDATING *) LENGTH,
                                    CURRCHAR,
                                    NEXTCHAR,
                     (* IN *)       VALUE     );


   IF (CURRCHAR.VALUE = '*') AND (NEXTCHAR.VALUE = ')')
      THEN
         BEGIN

            STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                           (* UPDATING *) LENGTH,
                                          CURRCHAR,
                                          NEXTCHAR,
                           (* IN *)       VALUE     );

            NAME := CLOSECOMMENT

         END

END; (* GETCOMMENT *)


FUNCTION IDTYPE( (* OF *)        VALUE  : STRING;
                 (* USING *)     LENGTH : INTEGER )
                 (* RETURNING *)                   : KEYSYMBOL;

VAR
    I: INTEGER;

    KEYVALUE: KEY;

    HIT: BOOLEAN;

    THISKEY: KEYSYMBOL;


BEGIN (* IDTYPE *)

   IDTYPE := OTHERSYM;

   IF LENGTH <= MAXKEYLENGTH
      THEN
         BEGIN

            FOR I := 1 TO LENGTH DO
               KEYVALUE [I] := VALUE [I];

            FOR I := LENGTH+1 TO MAXKEYLENGTH DO
               KEYVALUE [I] := SPACE;

            THISKEY := PROGSYM;
            HIT     := FALSE;

            WHILE NOT(HIT OR (PRED(THISKEY) = UNTILSYM)) DO
               IF KEYVALUE = KEYWORD [THISKEY]
                  THEN
                     HIT := TRUE
                  ELSE
                     THISKEY := SUCC(THISKEY);

            IF HIT
               THEN
                  IDTYPE := THISKEY

         END;

END; (* IDTYPE *)


PROCEDURE GETIDENTIFIER( (* FROM *)      VAR INPUTFL   : TEXT;
                         (* UPDATING *)  VAR CURRCHAR,
                                             NEXTCHAR  : CHARINFO;
                         (* RETURNING *) VAR NAME      : KEYSYMBOL;
                                         VAR VALUE     : STRING;
                                         VAR LENGTH    : INTEGER   );

BEGIN (* GETIDENTIFIER *)

   WHILE NEXTCHAR.NAME IN [ LETTER, DIGIT ] DO

      STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                     (* UPDATING *) LENGTH,
                                    CURRCHAR,
                                    NEXTCHAR,
                     (* IN *)       VALUE     );


   NAME := IDTYPE( (* OF *)    VALUE,
                   (* USING *) LENGTH );

   IF NAME IN [ RECORDSYM, CASESYM, ENDSYM ]
      THEN
         CASE NAME OF

            RECORDSYM : RECORDSEEN := TRUE;

            CASESYM   : IF RECORDSEEN
                           THEN
                              NAME := CASEVARSYM;

            ENDSYM    : RECORDSEEN := FALSE

         END (* CASE *)

END; (* GETIDENTIFIER *)


PROCEDURE GETNUMBER( (* FROM *)      VAR INPUTFL   : TEXT;
                     (* UPDATING *)  VAR CURRCHAR,
                                         NEXTCHAR  : CHARINFO;
                     (* RETURNING *) VAR NAME      : KEYSYMBOL;
                                     VAR VALUE     : STRING;
                                     VAR LENGTH    : INTEGER   );

BEGIN (* GETNUMBER *)

   WHILE NEXTCHAR.NAME = DIGIT DO

      STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                     (* UPDATING *) LENGTH,
                                    CURRCHAR,
                                    NEXTCHAR,
                     (* IN *)       VALUE     );


   NAME := OTHERSYM

END; (* GETNUMBER *)


PROCEDURE GETCHARLITERAL( (* FROM *)      VAR INPUTFL   : TEXT;
                          (* UPDATING *)  VAR CURRCHAR,
                                              NEXTCHAR  : CHARINFO;
                          (* RETURNING *) VAR NAME      : KEYSYMBOL;
                                          VAR VALUE     : STRING;
                                          VAR LENGTH    : INTEGER   );

BEGIN (* GETCHARLITERAL *)

   WHILE NEXTCHAR.NAME = QUOTE DO
      BEGIN

         STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                        (* UPDATING *) LENGTH,
                                       CURRCHAR,
                                       NEXTCHAR,
                        (* IN *)       VALUE     );

         WHILE NOT(NEXTCHAR.NAME IN [ QUOTE, ENDOFLINE, FILEMARK ]) DO

            STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                           (* UPDATING *) LENGTH,
                                          CURRCHAR,
                                          NEXTCHAR,
                           (* IN *)       VALUE     );


         IF NEXTCHAR.NAME = QUOTE
            THEN
               STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                              (* UPDATING *) LENGTH,
                                             CURRCHAR,
                                             NEXTCHAR,
                              (* IN *)       VALUE     )

      END;


   NAME := OTHERSYM

END; (* GETCHARLITERAL *)


FUNCTION CHARTYPE( (* OF *)        CURRCHAR,
                                   NEXTCHAR : CHARINFO )
                   (* RETURNING *)                      : KEYSYMBOL;

VAR
    NEXTTWOCHARS: SPECIALCHAR;

    HIT: BOOLEAN;

    THISCHAR: KEYSYMBOL;


BEGIN (* CHARTYPE *)

   NEXTTWOCHARS[1] := CURRCHAR.VALUE;
   NEXTTWOCHARS[2] := NEXTCHAR.VALUE;

   THISCHAR := BECOMES;
   HIT      := FALSE;

   WHILE NOT(HIT OR (THISCHAR = CLOSECOMMENT)) DO
      IF NEXTTWOCHARS = DBLCHAR [THISCHAR]
         THEN
            HIT := TRUE
         ELSE
            THISCHAR := SUCC(THISCHAR);

   IF NOT HIT
      THEN
         BEGIN

            THISCHAR := SEMICOLON;

            WHILE NOT(HIT OR (PRED(THISCHAR) = PERIOD)) DO
               IF CURRCHAR.VALUE = SGLCHAR [THISCHAR]
                  THEN
                     HIT := TRUE
                  ELSE
                     THISCHAR := SUCC(THISCHAR)

         END;

   IF HIT
      THEN
         CHARTYPE := THISCHAR
      ELSE
         CHARTYPE := OTHERSYM

END; (* CHARTYPE *)


PROCEDURE GETSPECIALCHAR( (* FROM *)      VAR INPUTFL   : TEXT;
                          (* UPDATING *)  VAR CURRCHAR,
                                              NEXTCHAR  : CHARINFO;
                          (* RETURNING *) VAR NAME      : KEYSYMBOL;
                                          VAR VALUE     : STRING;
                                          VAR LENGTH    : INTEGER   );

BEGIN (* GETSPECIALCHAR *)

   STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                  (* UPDATING *) LENGTH,
                                 CURRCHAR,
                                 NEXTCHAR,
                  (* IN *)       VALUE     );

   NAME := CHARTYPE( (* OF *) CURRCHAR,
                              NEXTCHAR );

   IF NAME IN DBLCHARS
      THEN

         STORENEXTCHAR( (* FROM *)     INPUTFL  ,
                        (* UPDATING *) LENGTH,
                                       CURRCHAR,
                                       NEXTCHAR,
                        (* IN *)       VALUE     )

END; (* GETSPECIALCHAR *)


PROCEDURE GETNEXTSYMBOL( (* FROM *)      VAR INPUTFL   : TEXT;
                         (* UPDATING *)  VAR CURRCHAR,
                                             NEXTCHAR  : CHARINFO;
                         (* RETURNING *) VAR NAME      : KEYSYMBOL;
                                         VAR VALUE     : STRING;
                                         VAR LENGTH    : INTEGER   );

BEGIN (* GETNEXTSYMBOL *)

   CASE NEXTCHAR.NAME OF

      LETTER      : GETIDENTIFIER( (* FROM *)      INPUTFL  ,
                                   (* UPDATING *)  CURRCHAR,
                                                   NEXTCHAR,
                                   (* RETURNING *) NAME,
                                                   VALUE,
                                                   LENGTH    );

      DIGIT       : GETNUMBER( (* FROM *)      INPUTFL  ,
                               (* UPDATING *)  CURRCHAR,
                                               NEXTCHAR,
                               (* RETURNING *) NAME,
                                               VALUE,
                                               LENGTH    );

      QUOTE       : GETCHARLITERAL( (* FROM *)      INPUTFL  ,
                                    (* UPDATING *)  CURRCHAR,
                                                    NEXTCHAR,
                                    (* RETURNING *) NAME,
                                                    VALUE,
                                                    LENGTH    );

      OTHERCHAR   : BEGIN

                       GETSPECIALCHAR( (* FROM *)      INPUTFL  ,
                                       (* UPDATING *)  CURRCHAR,
                                                       NEXTCHAR,
                                       (* RETURNING *) NAME,
                                                       VALUE,
                                                       LENGTH    );

                       IF NAME = OPENCOMMENT
                          THEN
                             GETCOMMENT( (* FROM *)     INPUTFL  ,
                                         (* UPDATING *) CURRCHAR,
                                                        NEXTCHAR,
                                                        NAME,
                                                        VALUE,
                                                        LENGTH    )

                    END;

      FILEMARK    : NAME := ENDOFFILE

   END (* CASE *)

END; (* GETNEXTSYMBOL *)


PROCEDURE GETSYMBOL( (* FROM *)      VAR INPUTFL   : TEXT;
                     (* UPDATING *)  VAR NEXTSYM   : SYMBOLINFO;
                     (* RETURNING *) VAR CURRSYM   : SYMBOLINFO );

VAR
    DUMMY: SYMBOLINFO;


BEGIN (* GETSYMBOL *)

   DUMMY   := CURRSYM;
   CURRSYM := NEXTSYM;
   NEXTSYM := DUMMY  ;

   WITH NEXTSYM@ DO
      BEGIN

         SKIPSPACES( (* IN *)        INPUTFL  ,
                     (* UPDATING *)  CURRCHAR,
                                     NEXTCHAR,
                     (* RETURNING *) SPACESBEFORE,
                                     CRSBEFORE     );
         LENGTH := 0;

         IF CURRSYM@.NAME = OPENCOMMENT
            THEN
               GETCOMMENT( (* FROM *)      INPUTFL  ,
                           (* UPDATING *)  CURRCHAR,
                                           NEXTCHAR,
                           (* RETURNING *) NAME,
                                           VALUE,
                                           LENGTH    )
            ELSE
               GETNEXTSYMBOL( (* FROM *)      INPUTFL  ,
                              (* UPDATING *)  CURRCHAR,
                                              NEXTCHAR,
                              (* RETURNING *) NAME,
                                              VALUE,
                                              LENGTH    )

      END (* WITH *)

END; (* GETSYMBOL *)


PROCEDURE INITIALIZE( (* RETURNING *)

                          VAR INPUTFL  ,
                              OUTPUTFL    : TEXT;

                          VAR TOPOFSTACK  : INTEGER;

                          VAR CURRLINEPOS,
                              CURRMARGIN  : INTEGER;

                          VAR KEYWORD     : KEYWORDTABLE;

                          VAR DBLCHARS    : DBLCHRSET;

                          VAR DBLCHAR     : DBLCHARTABLE;

                          VAR SGLCHAR     : SGLCHARTABLE;

                          VAR RECORDSEEN  : BOOLEAN;

                          VAR CURRCHAR,
                              NEXTCHAR    : CHARINFO;

                          VAR CURRSYM,
                              NEXTSYM     : SYMBOLINFO;

                          VAR PPOPTION    : OPTIONTABLE   );


BEGIN (* INITIALIZE *)

   RESET(INPUTFL  );
   REWRITE(OUTPUTFL  );
   WRITELN(OUTPUTFL  , ' <<<< PRETTY_PRINT OUTPUT OF THE PROGRAM >>>>');
   WRITELN(OUTPUTFL  , ' --------------------------------------------');
   WRITELN(OUTPUTFL  );
   WRITE(OUTPUTFL  , ' ');

   TOPOFSTACK  := 0;
   CURRLINEPOS := 0;
   CURRMARGIN  := 0;


   KEYWORD [ PROGSYM    ] := 'PROGRAM   ' ;
   KEYWORD [ FUNCSYM    ] := 'FUNCTION  ' ;
   KEYWORD [ PROCSYM    ] := 'PROCEDURE ' ;
   KEYWORD [ LABELSYM   ] := 'LABEL     ' ;
   KEYWORD [ CONSTSYM   ] := 'CONST     ' ;
   KEYWORD [ TYPESYM    ] := 'TYPE      ' ;
   KEYWORD [ VARSYM     ] := 'VAR       ' ;
   KEYWORD [ BEGINSYM   ] := 'BEGIN     ' ;
   KEYWORD [ REPEATSYM  ] := 'REPEAT    ' ;
   KEYWORD [ RECORDSYM  ] := 'RECORD    ' ;
   KEYWORD [ CASESYM    ] := 'CASE      ' ;
   KEYWORD [ CASEVARSYM ] := 'CASE      ' ;
   KEYWORD [ OFSYM      ] := 'OF        ' ;
   KEYWORD [ FORSYM     ] := 'FOR       ' ;
   KEYWORD [ WHILESYM   ] := 'WHILE     ' ;
   KEYWORD [ WITHSYM    ] := 'WITH      ' ;
   KEYWORD [ DOSYM      ] := 'DO        ' ;
   KEYWORD [ IFSYM      ] := 'IF        ' ;
   KEYWORD [ THENSYM    ] := 'THEN      ' ;
   KEYWORD [ ELSESYM    ] := 'ELSE      ' ;
   KEYWORD [ ENDSYM     ] := 'END       ' ;
   KEYWORD [ UNTILSYM   ] := 'UNTIL     ' ;


   DBLCHARS := [ BECOMES, OPENCOMMENT ];

   DBLCHAR [ BECOMES     ]  := ':=' ;
   DBLCHAR [ OPENCOMMENT ]  := '(*' ;

   SGLCHAR [ SEMICOLON  ]   := ';' ;
   SGLCHAR [ COLON      ]   := ':' ;
   SGLCHAR [ EQUALS     ]   := '=' ;
   SGLCHAR [ OPENPAREN  ]   := '(' ;
   SGLCHAR [ CLOSEPAREN ]   := ')' ;
   SGLCHAR [ PERIOD     ]   := '.' ;

   RECORDSEEN := FALSE;


   GETCHAR( (* FROM *)      INPUTFL  ,
            (* UPDATING *)  NEXTCHAR,
            (* RETURNING *) CURRCHAR  );

   NEW(CURRSYM);
   NEW(NEXTSYM);

   GETSYMBOL( (* FROM *)      INPUTFL  ,
              (* UPDATING *)  NEXTSYM,
              (* RETURNING *) CURRSYM  );


   WITH PPOPTION [ PROGSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                SPACEAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ FUNCSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                DINDENTONKEYS,
                                SPACEAFTER ];
         DINDENTSYMBOLS    := [ LABELSYM,
                                CONSTSYM,
                                TYPESYM,
                                VARSYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ PROCSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                DINDENTONKEYS,
                                SPACEAFTER ];
         DINDENTSYMBOLS    := [ LABELSYM,
                                CONSTSYM,
                                TYPESYM,
                                VARSYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ LABELSYM ] DO
      BEGIN
          OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ CONSTSYM ] DO
      BEGIN
          OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                DINDENTONKEYS,
                                SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [ LABELSYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ TYPESYM ] DO
      BEGIN
          OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                DINDENTONKEYS,
                                SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [ LABELSYM,
                                CONSTSYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ VARSYM ] DO
      BEGIN
          OPTIONSSELECTED   := [ BLANKLINEBEFORE,
                                DINDENTONKEYS,
                                SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [ LABELSYM,
                                CONSTSYM,
                                TYPESYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ BEGINSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ DINDENTONKEYS,
                                INDENTBYTAB,
                                CRAFTER ];
         DINDENTSYMBOLS    := [ LABELSYM,
                                CONSTSYM,
                                TYPESYM,
                                VARSYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ REPEATSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ INDENTBYTAB,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ RECORDSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ INDENTBYTAB,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ CASESYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ OFSYM ]
      END;

   WITH PPOPTION [ CASEVARSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ OFSYM ]
      END;

   WITH PPOPTION [ OFSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS,
                                SPACEBEFORE ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ FORSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ DOSYM ]
      END;

   WITH PPOPTION [ WHILESYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ DOSYM ]
      END;

   WITH PPOPTION [ WITHSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ DOSYM ]
      END;

   WITH PPOPTION [ DOSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS,
                                SPACEBEFORE ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ IFSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTBYTAB,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ THENSYM ]
      END;

   WITH PPOPTION [ THENSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ INDENTBYTAB,
                                CRAFTER ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ ELSESYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRBEFORE,
                                DINDENTONKEYS,
                                DINDENT,
                                INDENTBYTAB,
                                CRAFTER ];
         DINDENTSYMBOLS    := [ IFSYM,
                                ELSESYM ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ ENDSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRBEFORE,
                                DINDENTONKEYS,
                                DINDENT,
                                CRAFTER ];
         DINDENTSYMBOLS    := [ IFSYM,
                                THENSYM,
                                ELSESYM,
                                FORSYM,
                                WHILESYM,
                                WITHSYM,
                                CASEVARSYM,
                                COLON,
                                EQUALS ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ UNTILSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRBEFORE,
                                DINDENTONKEYS,
                                DINDENT,
                                SPACEAFTER,
                                GOBBLESYMBOLS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [ IFSYM,
                                THENSYM,
                                ELSESYM,
                                FORSYM,
                                WHILESYM,
                                WITHSYM,
                                COLON,
                                EQUALS ];
         GOBBLETERMINATORS := [ ENDSYM,
                                UNTILSYM,
                                ELSESYM,
                                SEMICOLON ];
      END;

   WITH PPOPTION [ BECOMES ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEBEFORE,
                                SPACEAFTER,
                                GOBBLESYMBOLS ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ ENDSYM,
                                UNTILSYM,
                                ELSESYM,
                                SEMICOLON ]
      END;

   WITH PPOPTION [ OPENCOMMENT ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ CLOSECOMMENT ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ SEMICOLON ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS,
                                DINDENTONKEYS,
                                CRAFTER ];
         DINDENTSYMBOLS    := [ IFSYM,
                                THENSYM,
                                ELSESYM,
                                FORSYM,
                                WHILESYM,
                                WITHSYM,
                                COLON,
                                EQUALS ];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ COLON ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ EQUALS ] DO
      BEGIN
         OPTIONSSELECTED   := [ SPACEBEFORE,
                                SPACEAFTER,
                                INDENTTOCLP ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ OPENPAREN ] DO
      BEGIN
         OPTIONSSELECTED   := [ GOBBLESYMBOLS ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := [ CLOSEPAREN ]
      END;

   WITH PPOPTION [ CLOSEPAREN ] DO
      BEGIN
         OPTIONSSELECTED   := [];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ PERIOD ] DO
      BEGIN
         OPTIONSSELECTED   := [ CRSUPPRESS ];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ ENDOFFILE ] DO
      BEGIN
         OPTIONSSELECTED   := [];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END;

   WITH PPOPTION [ OTHERSYM ] DO
      BEGIN
         OPTIONSSELECTED   := [];
         DINDENTSYMBOLS    := [];
         GOBBLETERMINATORS := []
      END


END; (* INITIALIZE *)


FUNCTION STACKEMPTY (* RETURNING *) : BOOLEAN;

BEGIN (* STACKEMPTY *)

   IF TOP = 0
      THEN
         STACKEMPTY := TRUE
      ELSE
         STACKEMPTY := FALSE

END; (* STACKEMPTY *)


FUNCTION STACKFULL (* RETURNING *) : BOOLEAN;

BEGIN (* STACKFULL *)

   IF TOP = MAXSTACKSIZE
      THEN
         STACKFULL := TRUE
      ELSE
         STACKFULL := FALSE

END; (* STACKFULL *)


PROCEDURE POPSTACK( (* RETURNING *) VAR INDENTSYMBOL : KEYSYMBOL;
                                    VAR PREVMARGIN   : INTEGER   );

BEGIN (* POPSTACK *)

   IF NOT STACKEMPTY
      THEN
         BEGIN

            INDENTSYMBOL := STACK[TOP].INDENTSYMBOL;
            PREVMARGIN   := STACK[TOP].PREVMARGIN;

            TOP := TOP - 1

         END

      ELSE
         BEGIN
            INDENTSYMBOL := OTHERSYM;
            PREVMARGIN   := 0
         END

END; (* POPSTACK *)


PROCEDURE PUSHSTACK( (* USING *) INDENTSYMBOL : KEYSYMBOL;
                                 PREVMARGIN   : INTEGER   );

BEGIN (* PUSHSTACK *)

   TOP := TOP + 1;

   STACK[TOP].INDENTSYMBOL := INDENTSYMBOL;
   STACK[TOP].PREVMARGIN   := PREVMARGIN

END; (* PUSHSTACK *)


PROCEDURE WRITECRS( (* USING *)          NUMBEROFCRS : INTEGER;
                    (* UPDATING *)   VAR CURRLINEPOS : INTEGER;
                    (* WRITING TO *) VAR OUTPUTFL    : TEXT    );

VAR
    I: INTEGER;


BEGIN (* WRITECRS *)

   IF NUMBEROFCRS > 0
      THEN
         BEGIN

            FOR I := 1 TO NUMBEROFCRS DO
               WRITELN(OUTPUTFL  );

            WRITE(OUTPUTFL, ' ');
            CURRLINEPOS := 0

         END

END; (* WRITECRS *)


PROCEDURE INSERTCR( (* UPDATING *)   VAR CURRSYM    : SYMBOLINFO;
                    (* WRITING TO *) VAR OUTPUTFL   : TEXT       );

CONST
      ONCE = 1;


BEGIN (* INSERTCR *)

   IF CURRSYM@.CRSBEFORE = 0
      THEN
         BEGIN

            WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
                            (* WRITING TO *) OUTPUTFL    );

            CURRSYM@.SPACESBEFORE := 0

         END

END; (* INSERTCR *)


PROCEDURE INSERTBLANKLINE( (* UPDATING *)   VAR CURRSYM : SYMBOLINFO;
                           (* WRITING TO *) VAR OUTPUTFL   : TEXT  );

CONST
      ONCE  = 1;
      TWICE = 2;


BEGIN (* INSERTBLANKLINE *)

   IF CURRSYM@.CRSBEFORE = 0
      THEN
         BEGIN

            IF CURRLINEPOS = 0
               THEN
                  WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
                                  (* WRITING TO *) OUTPUTFL    )
               ELSE
                  WRITECRS( TWICE, (* UPDATING *)   CURRLINEPOS,
                                   (* WRITING TO *) OUTPUTFL    );

            CURRSYM@.SPACESBEFORE := 0

         END

      ELSE
         IF CURRSYM@.CRSBEFORE = 1
            THEN
               IF CURRLINEPOS > 0
                  THEN
                     WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
                                     (* WRITING TO *) OUTPUTFL    )

END; (* INSERTBLANKLINE *)


PROCEDURE LSHIFTON( (* USING *) DINDENTSYMBOLS : KEYSYMSET );

VAR
    INDENTSYMBOL: KEYSYMBOL;
    PREVMARGIN  : INTEGER;


BEGIN (* LSHIFTON *)

   IF NOT STACKEMPTY
      THEN
         BEGIN

            REPEAT

               POPSTACK( (* RETURNING *) INDENTSYMBOL,
                                         PREVMARGIN   );

               IF INDENTSYMBOL IN DINDENTSYMBOLS
                  THEN
                     CURRMARGIN := PREVMARGIN

            UNTIL NOT(INDENTSYMBOL IN DINDENTSYMBOLS)
                   OR (STACKEMPTY);

            IF NOT(INDENTSYMBOL IN DINDENTSYMBOLS)
               THEN
                  PUSHSTACK( (* USING *) INDENTSYMBOL,
                                         PREVMARGIN   )

         END

END; (* LSHIFTON *)


PROCEDURE LSHIFT;

VAR
    INDENTSYMBOL: KEYSYMBOL;
    PREVMARGIN  : INTEGER;


BEGIN (* LSHIFT *)

   IF NOT STACKEMPTY
      THEN
         BEGIN
            POPSTACK( (* RETURNING *) INDENTSYMBOL,
                                      PREVMARGIN   );
            CURRMARGIN := PREVMARGIN
         END

END; (* LSHIFT *)


PROCEDURE INSERTSPACE( (* USING *)      VAR SYMBOL     : SYMBOLINFO;
                       (* WRITING TO *) VAR OUTPUTFL   : TEXT       );

BEGIN (* INSERTSPACE *)

   IF CURRLINEPOS < MAXLINESIZE
      THEN
         BEGIN

            WRITE(OUTPUTFL  , SPACE);

            CURRLINEPOS := CURRLINEPOS + 1;

            WITH SYMBOL@ DO
               IF (CRSBEFORE = 0) AND (SPACESBEFORE > 0)
                  THEN
                     SPACESBEFORE := SPACESBEFORE - 1

         END

END; (* INSERTSPACE *)


PROCEDURE MOVELINEPOS( (* TO *)       NEWLINEPOS  : INTEGER;
                       (* FROM *) VAR CURRLINEPOS : INTEGER;
                       (* IN *)   VAR OUTPUTFL    : TEXT    );

VAR
   I: INTEGER;


BEGIN (* MOVELINEPOS *)

   FOR I := CURRLINEPOS+1 TO NEWLINEPOS DO
      WRITE(OUTPUTFL  , SPACE);

   CURRLINEPOS := NEWLINEPOS

END; (* MOVELINEPOS *)


PROCEDURE PRINTSYMBOL( (* IN *)             CURRSYM     : SYMBOLINFO;
                       (* UPDATING *)   VAR CURRLINEPOS : INTEGER;
                       (* WRITING TO *) VAR OUTPUTFL    : TEXT       );

VAR
   I: INTEGER;


BEGIN (* PRINTSYMBOL *)

   WITH CURRSYM@ DO
      BEGIN

         FOR I := 1 TO LENGTH DO
            WRITE(OUTPUTFL  , VALUE[I]);

         CURRLINEPOS := CURRLINEPOS + LENGTH

      END (* WITH *)

END; (* PRINTSYMBOL *)


PROCEDURE PPSYMBOL( (* IN *)             CURRSYM    : SYMBOLINFO;
                    (* WRITING TO *) VAR OUTPUTFL   : TEXT       );

CONST
      ONCE  = 1;

VAR
    NEWLINEPOS: INTEGER;


BEGIN (* PPSYMBOL *)

   WITH CURRSYM@ DO
      BEGIN

         WRITECRS( (* USING *)      CRSBEFORE,
                   (* UPDATING *)   CURRLINEPOS,
                   (* WRITING TO *) OUTPUTFL    );

         IF (CURRLINEPOS + SPACESBEFORE > CURRMARGIN)
            OR (NAME IN [ OPENCOMMENT, CLOSECOMMENT ])
            THEN
               NEWLINEPOS := CURRLINEPOS + SPACESBEFORE
            ELSE
               NEWLINEPOS := CURRMARGIN;

         IF NEWLINEPOS + LENGTH > MAXLINESIZE
            THEN
               BEGIN

                  WRITECRS( ONCE, (* UPDATING *)   CURRLINEPOS,
                                  (* WRITING TO *) OUTPUTFL    );

                  IF CURRMARGIN + LENGTH <= MAXLINESIZE
                     THEN
                        NEWLINEPOS := CURRMARGIN
                     ELSE
                        IF LENGTH < MAXLINESIZE
                           THEN
                              NEWLINEPOS := MAXLINESIZE - LENGTH
                           ELSE
                              NEWLINEPOS := 0

               END;

         MOVELINEPOS( (* TO *)    NEWLINEPOS,
                      (* FROM *)  CURRLINEPOS,
                      (* IN *)    OUTPUTFL    );

         PRINTSYMBOL( (* IN *)         CURRSYM,
                      (* UPDATING *)   CURRLINEPOS,
                      (* WRITING TO *) OUTPUTFL    )

      END (* WITH *)

END; (* PPSYMBOL *)


PROCEDURE RSHIFTTOCLP( (* USING *) CURRSYM : KEYSYMBOL );
   FORWARD;

PROCEDURE GOBBLE( (* SYMBOLS FROM *) VAR INPUTFL     : TEXT;
                  (* UP TO *)            TERMINATORS : KEYSYMSET;
                  (* UPDATING *)     VAR CURRSYM,
                                         NEXTSYM     : SYMBOLINFO;
                  (* WRITING TO *)   VAR OUTPUTFL    : TEXT       );

BEGIN (* GOBBLE *)

   RSHIFTTOCLP( (* USING *) CURRSYM@.NAME );

   WHILE NOT(NEXTSYM@.NAME IN (TERMINATORS + [ENDOFFILE])) DO
      BEGIN

         GETSYMBOL( (* FROM *)      INPUTFL  ,
                    (* UPDATING *)  NEXTSYM,
                    (* RETURNING *) CURRSYM   );

         PPSYMBOL( (* IN *)         CURRSYM,
                   (* WRITING TO *) OUTPUTFL   )

      END; (* WHILE *)

   LSHIFT

END; (* GOBBLE *)


PROCEDURE RSHIFT( (* USING *) CURRSYM : KEYSYMBOL );

BEGIN (* RSHIFT *)

   IF NOT STACKFULL
      THEN
         PUSHSTACK( (* USING *) CURRSYM,
                                CURRMARGIN);

   IF CURRMARGIN < SLOWFAIL1
      THEN
         CURRMARGIN := CURRMARGIN + INDENT1
      ELSE
         IF CURRMARGIN < SLOWFAIL2
            THEN
               CURRMARGIN := CURRMARGIN + INDENT2

END; (* RSHIFT *)


PROCEDURE RSHIFTTOCLP;

BEGIN (* RSHIFTTOCLP *)

   IF NOT STACKFULL
      THEN
         PUSHSTACK( (* USING *) CURRSYM,
                                CURRMARGIN);

   CURRMARGIN := CURRLINEPOS

END; (* RSHIFTTOCLP *)


BEGIN (* PRETTYPRINT *)

   INITIALIZE( INPUTFL  ,  OUTPUTFL  , TOP,         CURRLINEPOS,
               CURRMARGIN, KEYWORD,    DBLCHARS,    DBLCHAR,
               SGLCHAR,    RECORDSEEN, CURRCHAR,    NEXTCHAR,
               CURRSYM,    NEXTSYM,    PPOPTION );

   CRPENDING := FALSE;

   WHILE (NEXTSYM@.NAME <> ENDOFFILE) DO
      BEGIN

         GETSYMBOL( (* FROM *)      INPUTFL  ,
                    (* UPDATING *)  NEXTSYM,
                    (* RETURNING *) CURRSYM   );

         WITH PPOPTION [CURRSYM@.NAME] DO
            BEGIN

               IF (CRPENDING AND NOT(CRSUPPRESS IN OPTIONSSELECTED))
                 OR (CRBEFORE IN OPTIONSSELECTED)
                  THEN
                     BEGIN
                        INSERTCR( (* USING *)      CURRSYM,
                                  (* WRITING TO *) OUTPUTFL   );
                        CRPENDING := FALSE
                     END;

               IF BLANKLINEBEFORE IN OPTIONSSELECTED
                  THEN
                     BEGIN
                        INSERTBLANKLINE( (* USING *)      CURRSYM,
                                         (* WRITING TO *) OUTPUTFL   );
                        CRPENDING := FALSE
                     END;

               IF DINDENTONKEYS IN OPTIONSSELECTED
                  THEN
                     LSHIFTON(DINDENTSYMBOLS);

               IF DINDENT IN OPTIONSSELECTED
                  THEN
                     LSHIFT;

               IF SPACEBEFORE IN OPTIONSSELECTED
                  THEN
                     INSERTSPACE( (* USING *)      CURRSYM,
                                  (* WRITING TO *) OUTPUTFL   );

               PPSYMBOL( (* IN *)         CURRSYM,
                         (* WRITING TO *) OUTPUTFL   );

               IF SPACEAFTER IN OPTIONSSELECTED
                  THEN
                     INSERTSPACE( (* USING *)      NEXTSYM,
                                  (* WRITING TO *) OUTPUTFL   );

               IF INDENTBYTAB IN OPTIONSSELECTED
                  THEN
                     RSHIFT( (* USING *) CURRSYM@.NAME );

               IF INDENTTOCLP IN OPTIONSSELECTED
                  THEN
                     RSHIFTTOCLP( (* USING *) CURRSYM@.NAME );

               IF GOBBLESYMBOLS IN OPTIONSSELECTED
                  THEN
                     GOBBLE( (* SYMBOLS FROM *) INPUTFL  ,
                             (* UP TO *)        GOBBLETERMINATORS,
                             (* UPDATING *)     CURRSYM,
                                                NEXTSYM,
                             (* WRITING TO *)   OUTPUTFL          );

               IF CRAFTER IN OPTIONSSELECTED
                  THEN
                     CRPENDING := TRUE

            END (* WITH *)

      END; (* WHILE *)

   IF CRPENDING
      THEN
         BEGIN  WRITELN(OUTPUTFL  );  WRITE(OUTPUTFL, ' ');  END;

END. (*PRETTYPRINT*)
PROGRAM PASCREF(INPUT,OUTPUT);      (*$D- N.WIRTH  2.7.75*)
(*CROSS REFERENCE GENERATOR FOR PASCAL PROGRAMS*)
(*QUADRATIC QUOTIENT HASH METHOD*)
(*MODIFIED SLIGHTLY BY A. MICKEL 75/12/08 AND D. LALIBERTE
  78/03/15 TO PRODUCE PROCEDURE LIST AND SKIP COMPILER TITLE*)
(*$T-,P-,R-,B4 TESTS OFF, PMD OFF, DYNAMIC STORAGE, BIG BUFFERS.*)
LABEL 99;
CONST P = 1499;     (*SIZE OF HASH TABLE*)
  NK = 33;          (*NO. OF KEYWORDS*)
  KLN = 10;         (*KEYLENGTH*)
  LPPG = 62;        (*NO. OF LINES PER PAGE*)
  LLMAX = 132;      (*LINE LENGTH DEFAULT MAX*)
  LLMIN = 72;       (*LINE LENGTH MINIMUM*)
  MAXN = 10000;     (*MAX NO. OF LINES*)
  DGPN =  6;        (*NO. OF DIGITS PER NUMBER*)
  LITL = 3;         (*NUMBER OF LINES IN COMPILER TITLE*)
  ADDRWIDTH = 6;    (*NUMBER OF DIGITS IN CODE ADDRESS*)
  EMPTY = '          ';
  STARS = ' *****';
TYPE INDEX = 0..P;
  ALFA = PACKED ARRAY [1..KLN] OF CHAR;
  REF = @ITEM;
  WORD = RECORD KEY: ALFA;
           FIRST: REF;
         END ;
  ITEM = PACKED RECORD
           LNO: 0..MAXN;
           NEXT: REF
         END ;
  PROCREF = @PROC;  (*PROCEDURE OR FUNCTION REFERENCE*)
  PROC = PACKED RECORD
           NAME: ALFA;
           LNO: 0..MAXN;
           NEXT: PROCREF
         END ;
VAR I: INDEX;
  K: INTEGER;
  M: INTEGER;       (*NO. OF LINES ON PAGE*)
  N: INTEGER;       (*NO. OF LINES INPUT*)
  LN: INTEGER;      (*CURRENT LINE NUMBER*)
  LLNGOUT: INTEGER; (*LINE LENGTH FOR OUTPUT*)
  LLNGIN: INTEGER;  (*LINE LENGTH FOR INPUT*)
  CCOUNT: INTEGER;  (*CHARACTER COUNT IN LINE*)
  NOPL: INTEGER;    (*NO. OF LINE-NUMBERS PER LINE*)
  ID: RECORD CASE BOOLEAN OF
             FALSE: (A: ALFA);
             TRUE:  (ORD: INTEGER)
      END ;
  T: ARRAY [INDEX] OF WORD;    (*HASH TABLE*)
  KEY: ARRAY [1..NK] OF ALFA;
  PROCORFUNC,
  COMPILERLISTING,
  LINENUMBERS: BOOLEAN;
  FIRSTPROC,
  PROCPTR: PROCREF; (*POINTERS TO CHAIN OF PROCEDURES*)


   FUNCTION LETTER(C: CHAR): BOOLEAN;

     BEGIN
     LETTER := (('A' <= C) AND (C <= 'Z')) OR (('a' <= C) AND (C <= 'z')) ;
     END ;

   FUNCTION DIGIT(C: CHAR): BOOLEAN ;

     BEGIN
     DIGIT := ('0' <= C) AND (C <= '9') ;
     END ;

   FUNCTION SPECIAL(C: CHAR): BOOLEAN;
     BEGIN  SPECIAL := (C = '$') OR (C = '_')  END ;

FUNCTION NOKEY: BOOLEAN;
   VAR I,J,K: INTEGER;
BEGIN I := 1; J := NK;   (*BINARY SEARCH*)
  REPEAT K := (I+J) DIV 2;
    IF KEY[K] <= ID.A THEN I := K+1 ELSE J := K-1
  UNTIL I > J;
  IF J = 0 THEN NOKEY := TRUE ELSE
    NOKEY := KEY[J] <> ID.A
END (*NOKEY*) ;

PROCEDURE COUNTLINE;
BEGIN
  IF M = LPPG THEN
    BEGIN PAGE(OUTPUT); WRITELN(OUTPUT); WRITELN(OUTPUT);
      M := 0
    END;
  M := M + 1
END (*COUNTLINE*) ;

PROCEDURE ADVANCE;
BEGIN
  WRITE(OUTPUT,INPUT@); GET(INPUT);
  CCOUNT := CCOUNT + 1;
  IF CCOUNT = LLNGIN THEN
    WHILE NOT EOLN(INPUT) DO
      BEGIN WRITE(OUTPUT,INPUT@); GET(INPUT);
      END
END (*ADVANCE*);

PROCEDURE SPACE(J: INTEGER);
BEGIN
  REPEAT J := J-1; WRITELN(OUTPUT); COUNTLINE
  UNTIL J = 0
END (*SPACE*) ;

PROCEDURE NEWLINE;
BEGIN CCOUNT := 0;
  IF N < MAXN THEN
  BEGIN COUNTLINE;  N := N + 1;
    IF COMPILERLISTING THEN
      BEGIN IF NOT EOLN THEN
        BEGIN ADVANCE;
"""     IF NOT (INPUT@ IN ['0'..'9']) THEN  (* ERRORS *)  """
        IF NOT DIGIT(INPUT@) THEN  (* ERRORS *)
          WHILE NOT EOLN DO
            ADVANCE
        ELSE BEGIN
          FOR I := 1 TO ADDRWIDTH + 1  DO
            ADVANCE;
          WHILE (INPUT@ = ' ') AND NOT EOLN DO
            ADVANCE
          END
        END
      END
    ELSE WRITE(OUTPUT,' ');
    IF LINENUMBERS THEN
      BEGIN LN := 0;
      WHILE DIGIT(INPUT@) DO
"""   WHILE INPUT@ IN ['0'..'9'] DO   """
        BEGIN LN := 10*LN + ORD(INPUT@) - ORD('0');
          ADVANCE
        END
      END
    ELSE BEGIN
      LN := N;  WRITE(OUTPUT,LN:6, ' ')
      END
    END
  ELSE BEGIN
    WRITELN(STARS, ' TEXT TOO LONG', STARS);
    "GOTO 99"  EXIT(99);
    END
END (*NEWLINE*) ;

PROCEDURE SEARCH;   (*MODULO P HASH SEARCH*)
  VAR H,D: INDEX;
      X: REF; F: BOOLEAN;
      K: INTEGER;
BEGIN  I := ABS(ID.ORD);  H := I MOD P;
  F := FALSE; D := 1;
  NEW(X); X@.LNO := LN;
  REPEAT
    IF T[H].KEY = ID.A THEN
    BEGIN (*FOUND*) F := TRUE;
      X@.NEXT := T[H].FIRST; T[H].FIRST := X;
    END ELSE
    IF T[H].KEY = EMPTY THEN
    BEGIN (*NEW ENTRY*) F := TRUE;
      T[H].KEY := ID.A;
      T[H].FIRST := X; X@.NEXT := NIL
    END ELSE
    BEGIN (*COLLISION*) H := H+D; D := D+2;
      IF H >= P THEN H := H-P;
      IF D = P THEN
        BEGIN WRITELN(OUTPUT); WRITELN(STARS,' TABLE FULL',STARS);""" GOTO 99"""
        EXIT(99);
        END
    END
  UNTIL F
END (*SEARCH*) ;

PROCEDURE SORT(MIN, MAX: INTEGER);

(* QUICKSORT WITH BOUNDED RECURSION DEPTH *)
(* REQUIRES MIN <= MAX *)

   VAR
         LOW,
        HIGH: INDEX;
      MIDKEY: ALFA;
        TEMP: WORD;

   BEGIN
      REPEAT (*PICK SPLIT POINT*)
         MIDKEY := T[(MIN + MAX) DIV 2].KEY;
         LOW := MIN;
         HIGH := MAX;
         REPEAT (*PARTITION*)
            WHILE T[LOW].KEY < MIDKEY DO
               LOW := LOW + 1;
            WHILE T[HIGH].KEY > MIDKEY DO
               HIGH := HIGH - 1;
            IF LOW <= HIGH THEN
               BEGIN
                  TEMP := T[LOW];
                  T[LOW] := T[HIGH];
                  T[HIGH] := TEMP;
                  LOW := LOW + 1;
                  HIGH := HIGH - 1
               END;
         UNTIL LOW > HIGH;

         (*RECURSIVELY SORT SHORTER SUB-SEGMENT*)
         IF HIGH - MIN < MAX - LOW
         THEN
            BEGIN
               IF MIN < HIGH THEN
                  SORT(MIN, HIGH);
               MIN := LOW
            END
         ELSE
            BEGIN
               IF LOW < MAX THEN
                  SORT(LOW, MAX);
               MAX := HIGH
            END
      UNTIL MAX <= MIN
   END (*SORT*);


PROCEDURE NOTEPROC;   (*NOTE INSTANCE OF PROCEDURE OR FUNCTION*)
  VAR P: PROCREF;
BEGIN PROCORFUNC := FALSE;
  NEW(P); PROCPTR@.NEXT := P;
  P@.NAME := ID.A; P@.LNO := LN; P@.NEXT := NIL;
  PROCPTR := P
END (*NOTEPROC*) ;

PROCEDURE PRINTWORD(W: WORD);
  VAR L: INTEGER; X,Y,Z: REF;
BEGIN COUNTLINE; WRITE(OUTPUT,' ', W.KEY);
  X := W.FIRST; Y := X@.NEXT; X@.NEXT := NIL;
  WHILE Y <> NIL DO
    BEGIN Z := Y@.NEXT; Y@.NEXT := X; X := Y; Y := Z
    END ;
  L := 0;
  REPEAT
    IF L = NOPL THEN
      BEGIN L := 0; WRITELN(OUTPUT); COUNTLINE; WRITE(OUTPUT,' ', EMPTY)
      END;
    L := L+1; WRITE(OUTPUT,X@.LNO: DGPN); X := X@.NEXT
  UNTIL X = NIL;
  WRITELN(OUTPUT);
END (*PRINTWORD*) ;

PROCEDURE PRINTTABLE;
  VAR I,M: INDEX;
BEGIN M := 0;    (*COMPRESS TABLE*)
  FOR I := 0 TO P-1 DO
    IF T[I].KEY <> EMPTY THEN
      BEGIN T[M] := T[I]; M := M+1
      END ;
  IF M > 0 THEN SORT(0,M-1);
  NOPL := (LLNGOUT-KLN-1) DIV DGPN;
  SPACE(2); WRITELN(' CROSS REFERENCE OF IDENTIFIERS,',
            ' LABEL DECLARATIONS AND GOTO STATEMENTS:');
  COUNTLINE; SPACE(1);
  FOR I := 0 TO M-1 DO PRINTWORD(T[I])
END (*PRINTTABLE*) ;

PROCEDURE PRINTPROCS;
BEGIN SPACE(2); COUNTLINE;
  WRITELN(' LIST OF PROCEDURES AND FUNCTIONS:');
  COUNTLINE; SPACE(1);
  PROCPTR := FIRSTPROC@.NEXT;
  WHILE PROCPTR <> NIL DO
    BEGIN WITH PROCPTR@ DO WRITELN(NAME:24,LNO:10);
      COUNTLINE; PROCPTR := PROCPTR@.NEXT
    END
END (*PRINTPROCS*) ;

PROCEDURE INITIALIZE;
  TYPE SETTING = PACKED RECORD
                   CASE SWITCH: BOOLEAN OF
                     TRUE: (ONOFF: CHAR);
                     FALSE: (SIZE: 0..999999)
                   END;
  VAR S: SETTING;
  FUNCTION OPTION(NAME: CHAR; VAR S: SETTING): BOOLEAN;
    EXTERNAL;
BEGIN N := 0; M := 0;
  LLNGIN := LLMAX; LLNGOUT := LLMAX;
"""IF OPTION('U',S) THEN
    IF S.SWITCH AND (S.ONOFF = '+')
      THEN LLNGIN := LLMIN;
  IF OPTION('W',S) THEN
    IF S.SWITCH AND (S.ONOFF = '+')
      THEN LLNGOUT := LLMIN;    """
  FOR I := 0 TO P-1 DO T[I].KEY := EMPTY;
  NEW(PROCPTR); FIRSTPROC := PROCPTR; PROCPTR@.NEXT := NIL;
  PROCORFUNC := TRUE;   (*TO GET P R O G R A M NAME IN PROCEDURE INDEX*)
  KEY[ 1] := 'AND       '; KEY[ 2] := 'ARRAY     ';
  KEY[ 3] := 'BEGIN     '; KEY[ 4] := 'CASE      ';
  KEY[ 5] := 'CONST     '; KEY[ 6] := 'DIV       ';
  KEY[ 7] := 'DOWNTO    '; KEY[ 8] := 'DO        ';
  KEY[ 9] := 'ELSE      '; KEY[10] := 'END       ';
  KEY[11] := 'FILE      '; KEY[12] := 'FOR       ';
  KEY[13] := 'FUNCTION  '; KEY[14] := 'IF        ';
  KEY[15] := 'IN        '; KEY[16] := 'MOD       ';
  KEY[17] := 'NIL       '; KEY[18] := 'NOT       ';
  KEY[19] := 'OF        '; KEY[20] := 'OR        ';
  KEY[21] := 'PACKED    '; KEY[22] := 'PROCEDURE ';
  KEY[23] := 'PROGRAM   '; KEY[24] := 'RECORD    ';
  KEY[25] := 'REPEAT    '; KEY[26] := 'SET       ';
  KEY[27] := 'THEN      '; KEY[28] := 'TO        ';
  KEY[29] := 'TYPE      '; KEY[30] := 'UNTIL     ';
  KEY[31] := 'VAR       '; KEY[32] := 'WHILE     ';
  KEY[33] := 'WITH      '
END (*INITIALIZE*) ;

PROCEDURE SCANANDLISTINPUT;
BEGIN
  WHILE NOT EOF(INPUT) DO
  BEGIN NEWLINE;
    WHILE NOT EOLN(INPUT) DO
    CASE INPUT@ OF
     'a','b','c','d','e','f','g','h','i','j','k','l','m',
     'n','o','p','q','r','s','t','u','v','w','x','y','z',
     'A','B','C','D','E','F','G','H','I','J','K','L','M',
     'N','O','P','Q','R','S','T','U','V','W','X','Y','Z':
      BEGIN K := 0; ID.A := EMPTY;
        REPEAT
          IF K < KLN THEN
            BEGIN K := K+1; ID.A[K] := INPUT@
            END;
          ADVANCE
"""     UNTIL NOT(INPUT@ IN ['A'..'Z', '0'..'9']);   """
        UNTIL NOT(LETTER(INPUT@) OR DIGIT(INPUT@) OR SPECIAL(INPUT@));
        IF NOKEY THEN
        BEGIN SEARCH;
          IF PROCORFUNC THEN NOTEPROC
        END ELSE
        IF (ID.A = 'PROCEDURE ') OR (ID.A = 'FUNCTION  ') THEN
          PROCORFUNC := TRUE
      END;
     '0','1','2','3','4','5','6','7','8','9':
        REPEAT ADVANCE;
"""     UNTIL NOT (INPUT@ IN ['B','E','0'..'9']);  """
        UNTIL NOT DIGIT(INPUT@) ;
     '''':
      BEGIN (*STRING*)
        REPEAT ADVANCE;
        UNTIL (INPUT@ = '''') OR EOLN(INPUT);
        IF NOT EOLN(INPUT) THEN
          ADVANCE
      END;
#    '"':
      BEGIN (*COMMENT*)
        REPEAT ADVANCE;
          WHILE EOLN(INPUT) DO
            BEGIN WRITELN(OUTPUT); GET(INPUT); NEWLINE
            END
        UNTIL INPUT@ = '"';
        ADVANCE
      END;
     '(':
      BEGIN ADVANCE;
        IF INPUT@ = '*' THEN
        BEGIN (*COMMENT*) ADVANCE;
          REPEAT
            WHILE INPUT@ <> '*' DO
            BEGIN
              IF EOLN(INPUT) THEN
                BEGIN GET(INPUT); WRITELN(OUTPUT); NEWLINE
                END ELSE
                ADVANCE
            END ;
            ADVANCE
          UNTIL INPUT@ = ')';
          ADVANCE
        END
      END;
     '+','-','*','/',')','$','=',' ',',','.','[',']',
     ':','!','Ý','&','@','?','<','>','','\','^',';','#','_','%','':
      ADVANCE
    END (*CASE*) ;
    WRITELN(OUTPUT); GET(INPUT)
  END ;
END (*SCANANDLISTINPUT*) ;

PROCEDURE SKIPCOMPILERTITLE;
  VAR I: INTEGER;
BEGIN
  COMPILERLISTING := INPUT@ = '1';
  IF COMPILERLISTING THEN
  BEGIN I := 0; GET(INPUT);
    WHILE I < LITL DO
      BEGIN I := I + 1;
        WHILE NOT EOLN(INPUT) DO
          ADVANCE;
        READLN; WRITELN(OUTPUT);
      END;
    COUNTLINE;
    LINENUMBERS := TRUE
  END ELSE
  BEGIN WRITELN(OUTPUT); WRITELN(OUTPUT);
    LINENUMBERS := """INPUT@ IN ['0'..'9']""" DIGIT(INPUT@)
  END
END (*SKIPCOMPILERTITLE*) ;

BEGIN (*CROSSREF*)
"""LINELIMIT(OUTPUT, MAXN);"""  PAGE(OUTPUT); INITIALIZE;
  IF NOT EOF(INPUT) THEN
  BEGIN SKIPCOMPILERTITLE;
    SCANANDLISTINPUT; """LINELIMIT(OUTPUT, MAXN); """
    PRINTTABLE; PRINTPROCS
  END ELSE WRITELN(STARS,' NO PROGRAM FOUND TO CROSS REFERENCE',STARS);
99:END .
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB PRINTME  EXT PAS HEX -
(* after a program published in Pascal News, DEW Jan. 79 *)

PROGRAM PRINTME(OUTPUT);

   TYPE ALPHA=ARRAY(/1..50/) OF CHAR;

   VAR  A: ARRAY(/1..31/) OF ALPHA;
        B: ARRAY(/1..10/) OF CHAR;
        I: INTEGER;


BEGIN

B(/ 1/):='''';
B(/ 2/):='A';
B(/ 3/):='B';
B(/ 4/):=' ';
B(/ 5/):=';';
B(/ 6/):='/';
B(/ 7/):=')';
B(/ 8/):='(';
B(/ 9/):=':';
B(/10/):='=';
A(/ 1/):='PROGRAM PRINTME(OUTPUT);                          ';
A(/ 2/):='                                                  ';
A(/ 3/):='   TYPE ALPHA=ARRAY(/1..50/) OF CHAR;             ';
A(/ 4/):='                                                  ';
A(/ 5/):='   VAR  A: ARRAY(/1..31/) OF ALPHA;               ';
A(/ 6/):='        B: ARRAY(/1..10/) OF CHAR;                ';
A(/ 7/):='        I: INTEGER;                               ';
A(/ 8/):='                                                  ';
A(/ 9/):='                                                  ';
A(/10/):='BEGIN                                             ';
A(/11/):='                                                  ';
A(/12/):='FOR I:=1 TO 11 DO WRITELN(OUTPUT,B(/4/),A(/I/));  ';
A(/13/):='                                                  ';
A(/14/):='I:=1;                                             ';
A(/15/):='WRITELN(OUTPUT,B(/4/),B(/3/),B(/8/),B(/6/),I:2,   ';
A(/16/):='       B(/6/),B(/7/),B(/9/),B(/10/),B(/1/),B(/1/),';
A(/17/):='       B(/1/),B(/1/),B(/5/) );                    ';
A(/18/):='                                                  ';
A(/19/):='FOR I:=2 TO 10 DO WRITELN(OUTPUT,B(/4/),B(/3/),   ';
A(/20/):='                  B(/8/),B(/6/),I:2,B(/6/),B(/7/),';
A(/21/):='                  B(/9/),B(/10/),B(/1/),B(/I/),   ';
A(/22/):='                  B(/1/),B(/5/) );                ';
A(/23/):='                                                  ';
A(/24/):='FOR I:=1 TO 31 DO WRITELN(OUTPUT,B(/4/),B(/2/),   ';
A(/25/):='                  B(/8/),B(/6/),I:2,B(/6/),B(/7/),';
A(/26/):='                  B(/9/),B(/10/),B(/1/),A(/I/),   ';
A(/27/):='                  B(/1/),B(/5/) );                ';
A(/28/):='                                                  ';
A(/29/):='FOR I:=11 TO 31 DO WRITELN(OUTPUT,B(/4/),A(/I/)); ';
A(/30/):='                                                  ';
A(/31/):='END.                                              ';

FOR I:=1 TO 11 DO WRITELN(OUTPUT,B(/4/),A(/I/));

I:=1;
WRITELN(OUTPUT,B(/4/),B(/3/),B(/8/),B(/6/),I:2,
       B(/6/),B(/7/),B(/9/),B(/10/),B(/1/),B(/1/),
       B(/1/),B(/1/),B(/5/) );

FOR I:=2 TO 10 DO WRITELN(OUTPUT,B(/4/),B(/3/),
                  B(/8/),B(/6/),I:2,B(/6/),B(/7/),
                  B(/9/),B(/10/),B(/1/),B(/I/),
                  B(/1/),B(/5/) );

FOR I:=1 TO 31 DO WRITELN(OUTPUT,B(/4/),B(/2/),
                  B(/8/),B(/6/),I:2,B(/6/),B(/7/),
                  B(/9/),B(/10/),B(/1/),A(/I/),
                  B(/1/),B(/5/) );

FOR I:=11 TO 31 DO WRITELN(OUTPUT,B(/4/),A(/I/));

END.
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB PROFILER EXT PAS HEX -
PROGRAM PROFILE(OUTPUT,QRD);

(*$D-
        M U L T I P U R P O S E   P R O F I L E    G E N E R A T O R
        -----------------------   -------------    -----------------

     AUTHOR:  R. NIGEL HORSPOOL,  MCGILL UNIVERSITY,  MONTREAL.
     DATE:    AUGUST 22, 1979.

PURPOSE: TO PRODUCE AN EXECUTION PROFILE FOR PASCAL PROGRAMS COMPILED
         AND EXECUTED VIA THE STANFORD PASCAL COMPILER.
         THIS PROGRAM IS INTENDED TO BE WHOLLY COMPATIBLE WITH THE
         "PASPROF" PROGRAM SUPPLIED WITH THE STANFORD PASCAL SYSTEM.
         HOWEVER, THIS PROGRAM REQUIRES MUCH LESS MEMORY AND IS MORE
         VERSATILE.  IT CAN GENERATE THREE DIFFERENT FORMATS FOR THE
         PROFILE.  THE FORMAT IS SELECTED ACCORDING TO WHAT INPUT IS
         PROVIDED IN THE "PRD" FILE - SEE BELOW.  FORMAT 1 IS A
         VERY CONDENSED PROFILE, SUITABLE FOR LISTING ON AN INTERACTIVE
         TERMINAL.  FORMAT 2 GIVES A SOURCE LISTING WITH EXECUTION
         FREQUENCIES PRINTED ALONGSIDE EACH LINE.  FORMAT 3 IS SIMILAR
         TO FORMAT 2 BUT IS IDENTICAL (OR NEARLY SO) TO THE FORMAT
         GENERATED BY STANFORD'S PASPROF PROGRAM.

FILES:
         QRR   - THE COUNTERS WRITTEN BY AN EXECUTING PASCAL PROGRAM
                 (WITH THE K+ OPTION IN EFFECT WHEN COMPILED).  THIS
                 CORRESPONDS TO THE DDNAME "GO.QRR" IN A PASCAL JOB.
         QRD   - SYMBOL TABLE DATA WRITTEN DURING A PASCAL COMPILATION.
                 THIS CORRESPONDS TO THE DDNAME "COMPILE.QRR".
         PRD   - THREE POSSIBILITIES ARE ALLOWED  (AND CAUSE OUTPUT
                 FORMATS 1, 2 OR 3 RESPECTIVELY).
                 1.  "PRD" IS AN EMPTY FILE  (I.E., THE DD STATEMENT
                     IN THE O.S. JCL IS CODED AS "DD DUMMY").
                 2.  "PRD" IS A FILE CONTAINING THE IDENTICAL SOURCE
                     CODE AS THE PROGRAM TO BE PROFILED.
                 3.  "PRD" IS A FILE CONTAINING THE COMPILATION OUTPUT
                     CREATED WHEN THE PROGRAM TO BE PROFILED WAS COMPILED.
                     (THIS CORRESPONDS TO THE DDNAME "COMPILE.OUTPUT".)

ERROR CODES:
         101, 102, 103:  INDICATE AN INTERNAL INCONSISTENCY IN THE DATA
                 CONTAINED IN THE "QRD" FILE.  THE ERROR SHOULD BE
                 REPORTED TO THE AUTHOR.
         200:    INDICATES THAT THE "QRR" FILE IS EMPTY OR A PREMATURE
                 END OF FILE HAS OCCURRED.
                                                                              *)
(*$EJECT *)
CONST MAXLINES = 55;
      BUFLEN   = 150;         (*SIZE OF THE INPUT LINE BUFFER*)
TYPE  STMT_TYPE = ( PROC, LAB_STMT, GOTO_STMT, IF_STMT, WHILE_STMT,
                    REPEAT_STMT, FOR_STMT, CASE_STMT, THEN_CLAUSE,
                    ELSE_CLAUSE, CASE_CLAUSE );
      NODE = RECORD
                KIND: STMT_TYPE;
                CTR_NO, FIRSTLN, LASTLN: INTEGER;
                NEST, NEXT: @NODE;
             END;
      NODE_PTR = @NODE;
VAR   NODE_LIST, NEW_NODE, HEAP_MARK: NODE_PTR;
      LAST_CNT, LAST_CTR_NO, LEN, LINECNT,
           PAGENUM, LEVEL, MID_LINE, CURLINE: INTEGER;
      MODE: ( UNKNOWN, BRIEF, SOURCE, LISTING );
      FAKE: RECORD CASE BOOLEAN OF
               FALSE: ( KIND: STMT_TYPE );
               TRUE:  ( INT:  INTEGER   );  END;
      OK: BOOLEAN;
      LAB:  ARRAY(/1..4/) OF CHAR;
      PROC_NAME: ARRAY(/1..12/) OF CHAR;
      L: RECORD CASE BOOLEAN OF
            FALSE: (LINE:     ARRAY(/1..BUFLEN/) OF CHAR);
            TRUE:  (SEQUENCE: ARRAY(/1..9/)   OF CHAR;
                    REMDR:    ARRAY(/1..141/) OF CHAR);  END;

FUNCTION INNER_STMTS( START_LINE, START_CTR: INTEGER ): NODE_PTR;
   LABEL 10;
   VAR   TEMP1, TEMP2: NODE_PTR;
   BEGIN
      TEMP1 := NIL;
      IF NODE_LIST <> NIL THEN
         WHILE ( NODE_LIST@.FIRSTLN >= START_LINE ) AND
               ( NODE_LIST@.CTR_NO  >  START_CTR  ) DO
            BEGIN
               TEMP2 := NODE_LIST;  NODE_LIST := TEMP2@.NEXT;
               TEMP2@.NEXT := TEMP1;  TEMP1 := TEMP2;
               IF NODE_LIST = NIL THEN GOTO 10;
            END;
   10:INNER_STMTS := TEMP1;
   END (* INNER_STMTS *) ;

PROCEDURE BUILD_TREE( NEW_NODE: NODE_PTR );
   VAR TEMP1, TEMP2: NODE_PTR;
   BEGIN
      CASE NEW_NODE@.KIND OF

      WHILE_STMT, REPEAT_STMT, FOR_STMT, PROC:
         NEW_NODE@.NEST := INNER_STMTS( NEW_NODE@.FIRSTLN, NEW_NODE@.CTR_NO );

      IF_STMT:
         IF MID_LINE = 0 THEN  (* NO ELSE CLAUSE *)
            BEGIN
               NEW_NODE@.KIND := THEN_CLAUSE;
               NEW_NODE@.NEST := INNER_STMTS( NEW_NODE@.FIRSTLN,
                                              NEW_NODE@.CTR_NO );
            END
         ELSE BEGIN  (* NESTED THEN & ELSE CLAUSES *)
               NEW(TEMP2);
               WITH TEMP2@ DO BEGIN
                  KIND := ELSE_CLAUSE;  CTR_NO := MAXINT;
                  FIRSTLN := MID_LINE;  NEXT   := NIL;
                  LASTLN  := NEW_NODE@.LASTLN;
                  NEST := INNER_STMTS( MID_LINE, NEW_NODE@.CTR_NO );  END;
               NEW(TEMP1);
               WITH TEMP1@ DO BEGIN
                  KIND := THEN_CLAUSE;  CTR_NO := NEW_NODE@.CTR_NO;
                  FIRSTLN := NEW_NODE@.FIRSTLN;  LASTLN := MID_LINE - 1;
                  IF LASTLN < FIRSTLN THEN LASTLN := FIRSTLN;
                  NEST := INNER_STMTS( FIRSTLN, NEW_NODE@.CTR_NO );
                  NEXT := TEMP2;                                       END;
               NEW_NODE@.NEST := TEMP1;
         END;

      CASE_STMT:
         IF MID_LINE = 0 THEN BEGIN  (* CASE CLAUSE *)
            NEW_NODE@.KIND := CASE_CLAUSE;
            NEW_NODE@.NEST := INNER_STMTS( NEW_NODE@.FIRSTLN,
                                           NEW_NODE@.CTR_NO );  END
         ELSE BEGIN  (* END OF ENTIRE CASE STMT *)
            TEMP1 := NIL;
            WHILE MID_LINE > 0 DO
               IF NODE_LIST <> NIL THEN
                  BEGIN
                     IF NODE_LIST@.KIND <> CASE_CLAUSE THEN EXIT(101);
                     TEMP2 := NODE_LIST;  NODE_LIST := TEMP2@.NEXT;
                     TEMP2@.NEXT := TEMP1;  TEMP1 := TEMP2;
                     MID_LINE := MID_LINE - 1;
                  END
               ELSE EXIT(102);
            NEW_NODE@.NEST := TEMP1;
            NEW_NODE@.CTR_NO := MAXINT;
         END;

      GOTO_STMT:
         NEW_NODE@.CTR_NO := MAXINT;

      LAB_STMT:
         (* NOTHING *) ;
      END  (* CASE *) ;
      NEW_NODE@.NEXT := NODE_LIST;
      NODE_LIST := NEW_NODE;
   END (* BUILD_TREE *) ;

PROCEDURE FILL_LINE;
   BEGIN
   (**LEN := 0;  REPEAT  LEN := LEN + 1;  READ(PRD, L.LINE(/LEN/) );
                 UNTIL   EOLN(PRD);  READLN(PRD);**)
       READLN(PRD, L.LINE);
       LEN := BUFLEN;
       REPEAT  LEN := LEN-1;  UNTIL (LEN = 1) OR (L.LINE(/LEN/) <> ' ');
   END  (* FILL_LINE *) ;

PROCEDURE READLINE;
   LABEL 10;
   VAR I: INTEGER;  CH: CHAR;  SEEN: BOOLEAN;

   FUNCTION HEADLINE: BOOLEAN;
      VAR  TEST: BOOLEAN;  I: INTEGER;
      BEGIN  TEST := FALSE;
         IF L.LINE(/1/) = '1' THEN  (* PAGE CONTROL CHAR? *)
            TEST := TRUE
         ELSE BEGIN  (* LOOK FOR WORD "LINE" IN HEADING *)
            I := 1;  WHILE L.LINE(/I/) = ' ' DO I := I + 1;
            TEST := (L.LINE(/I/) = 'L');
         END;
         IF TEST THEN BEGIN  (* SOME NASTY SIDE-EFFECTS *)
            IF L.LINE(/1/) <> '1' THEN BEGIN  PAGE;  WRITELN;  END;
            PAGENUM := PAGENUM + 1;
            WRITELN( L.SEQUENCE, 'RUN CNT':9, L.REMDR:LEN-9 );
            FILL_LINE;  READLN(PRD);
            WRITELN( L.SEQUENCE, '--- ---':9, L.REMDR:LEN-9 );
            WRITELN;  MODE := LISTING;  END;
         HEADLINE := TEST;
      END;
      BEGIN  (* READLINE *)
         REPEAT
            FILL_LINE;
            L.LINE(/BUFLEN/) := '#';
            IF LEN = 1 THEN
               IF EOF(PRD) THEN BEGIN MODE := BRIEF;  GOTO 10;  END;
         UNTIL NOT HEADLINE;
         IF MODE = LISTING THEN BEGIN
            CURLINE := 0;  SEEN := FALSE;
            FOR I := 1 TO 9 DO BEGIN
               CH := L.LINE(/I/);
              IF CH >= '0' THEN BEGIN  SEEN := TRUE;
                 CURLINE := CURLINE*10 - ORD('0') + ORD(CH);  END;  END;
            IF NOT SEEN THEN  (* NO LINE # FOUND *)
                CURLINE := MAXINT;  END;
 10: END;

PROCEDURE ADVANCE( STOPLINE, FREQUENCY: INTEGER );
   BEGIN
      WHILE (CURLINE <= STOPLINE) AND (MODE <> BRIEF) DO
         IF MODE = SOURCE THEN BEGIN
            IF LINECNT >= MAXLINES THEN BEGIN
               PAGE;  WRITELN;  PAGENUM := PAGENUM + 1;
               WRITELN( 'LINE #  RUN CNT':18, 'SOURCE STATEMENT':26,
                          'PAGE':24, PAGENUM:4 );
               WRITELN( '---- -  --- ---':18, '------ ---------':26,
                          '---- ---':28 );
               WRITELN;  LINECNT := 0;  END;
            LINECNT := LINECNT + 1;
            WRITE( CURLINE:9 );
            IF FREQUENCY = 0
               THEN WRITE( ' ':8 ) ELSE WRITE( FREQUENCY:8 );
            WRITELN( ' ':4, L.LINE:LEN );
            FILL_LINE;
            IF LEN = 1 THEN
               IF EOF(PRD) THEN MODE := BRIEF;
            CURLINE := CURLINE + 1;  END
          ELSE BEGIN
            WRITE( L.SEQUENCE:9 );
            IF FREQUENCY = 0 THEN
               WRITE( ' ':9 ) ELSE WRITE( FREQUENCY:9 );
            WRITELN( L.REMDR:LEN-9 );  READLINE;
          END;
   END (* ADVANCE *) ;

PROCEDURE PRINT( NODE: NODE_PTR;  CNT: INTEGER );
   CONST TAB = 2;
   BEGIN
      IF MODE = BRIEF THEN BEGIN
         IF LINECNT >= MAXLINES THEN BEGIN
            PAGE;  WRITELN;  LINECNT := 0;  PAGENUM := PAGENUM + 1;
            WRITELN( 'LINE # RANGE  RUN CNT  CONSTRUCT':35,
                      'PAGE':10, PAGENUM:4 );
            WRITELN( '---- - -----  --- ---  ---------':35, '---- ---':14 );
            WRITELN;  END;
         LINECNT := LINECNT + 1;
         WITH NODE@ DO BEGIN
            WRITE( FIRSTLN:7, '-':3, LASTLN:5, CNT:9,
                       ' ':(LEVEL*TAB) );
            CASE KIND OF
               PROC:         WRITELN( 'PROCEDURE: ', PROC_NAME );
               LAB_STMT:     WRITELN( 'LABELLED STMT' );
               WHILE_STMT:   WRITELN( 'WHILE STMT' );
               REPEAT_STMT:  WRITELN( 'REPEAT STMT' );
               FOR_STMT:     WRITELN( 'FOR STMT' );
               THEN_CLAUSE:  WRITELN( 'THEN CLAUSE' );
               ELSE_CLAUSE:  WRITELN( 'ELSE CLAUSE' );
               CASE_CLAUSE:  WRITELN( 'CASE CLAUSE' );
               IF_STMT, CASE_STMT:  WRITELN;
            END;  END;  END;
   END  (* PRINT *) ;

PROCEDURE WALK( NODE: NODE_PTR; DFLT_CNT: INTEGER );
   VAR  CNT: INTEGER;  ELSE_PTR: NODE_PTR;
   BEGIN
      LEVEL := LEVEL + 1;
      WHILE NODE <> NIL DO
         WITH NODE@ DO BEGIN
            ADVANCE( FIRSTLN-1, DFLT_CNT );
            IF CTR_NO < MAXINT THEN  BEGIN
               IF CTR_NO < LAST_CTR_NO THEN EXIT(103);
               WHILE CTR_NO > LAST_CTR_NO DO
                  BEGIN LAST_CTR_NO := LAST_CTR_NO + 1;
                     WHILE (QRR@=' ') AND NOT EOF(QRR) DO GET(QRR);
                     IF EOF(QRR) THEN BEGIN
                        WRITELN;  WRITELN( '****':9,
                        'ERROR - COUNTERS FILE INCONSISTANT':36 );
                        EXIT(200);  END;
                        READ( QRR, LAST_CNT );  END;
               CNT := LAST_CNT;  END
            ELSE CNT := DFLT_CNT;
            IF KIND = IF_STMT THEN BEGIN
               ELSE_PTR := NEST@.NEXT;
               NEST@.NEXT := NIL;
               WALK( NEST, DFLT_CNT );  WALK( ELSE_PTR, DFLT_CNT - CNT );
               "NEST@.NEXT := ELSE_PTR;"  END
            ELSE BEGIN
               IF (KIND <> CASE_STMT) AND
                  (KIND <> GOTO_STMT) THEN PRINT( NODE, CNT );
               IF NEST <> NIL THEN WALK( NEST, CNT );
               ADVANCE( LASTLN, CNT );
               IF (KIND = GOTO_STMT) OR (KIND = CASE_CLAUSE) THEN
                  DFLT_CNT := 0
               ELSE IF KIND = LAB_STMT THEN
                  DFLT_CNT := CNT;  END;
            NODE := NEXT;
         END (* WITH *) ;
      LEVEL := LEVEL - 1;
   END  (* WALK *) ;

BEGIN  (* PROFILE *)
   RESET(PRD);  RESET(QRR);
   MODE := UNKNOWN;  LINECNT := MAXLINES;  LAST_CTR_NO := -1;
   MARK( HEAP_MARK );  NODE_LIST := NIL;   OK := FALSE;
   PROC_NAME := '            ';            PAGENUM := 0;
   READLINE;
   IF MODE = UNKNOWN THEN BEGIN
      MODE := SOURCE;  CURLINE := 1;  END;

   WHILE NOT EOF(QRD) DO BEGIN
      READ( QRD, LAB );
      IF LAB = '#CTR' THEN BEGIN
         NEW( NEW_NODE );  OK := TRUE;
         WITH NEW_NODE@ DO BEGIN
            READLN( QRD, FAKE.INT, CTR_NO, FIRSTLN, MID_LINE, LASTLN );
            KIND := FAKE.KIND;
            NEST := NIL;  NEXT := NIL;
            BUILD_TREE( NEW_NODE );
            IF KIND = PROC THEN
               IF LASTLN > 0 THEN BEGIN
                  LEVEL := 0;
                  WALK( NEW_NODE, 0 );  RELEASE( HEAP_MARK );
                  PROC_NAME := '            ';
                  NODE_LIST := NIL;  END  END  END
       ELSE IF LAB = '#BGN' THEN BEGIN
          WHILE QRD@ = ' ' DO GET(QRD);
          READLN( QRD, PROC_NAME );  END
       ELSE READLN( QRD );  END;
   IF OK THEN
      ADVANCE( MAXINT, 0 )
   ELSE BEGIN
      WRITELN;  WRITELN( '****':9, 'ERROR - K+ OPTION NOT ENABLED':36 ); END;
END.
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB PSUBSET  EXT PAS HEX -
(*$M-,D-*)
(* PASCALS.P                                                                  *)
PROGRAM PASCALS(INPUT,OUTPUT);     (*1.7.75*)
(*$M-, T-,P-  N.WIRTH,  E.T.H.
      CLAUSIUSSTR.55   CH-8006 ZURICH    *)
(* #INCLUDE "GLOBALS.I"                                                       *)
(* GLOBALS.I                                                                  *)
LABEL 99;
CONST NKW = 27;     (*NO. OF KEY WORDS*)
## TABCH = ' ' "TAB";
    ALNG =  10;     (*NO. OF SIGNIFICANT CHARS IN IDENTIFIERS*)
    LLNG = 120;     (*INPUT LINE LENGTH*)
    EMAX = 322;     (*MAX EXPONENT OF REAL NUMBERS*)
    EMIN =-292;     (*MIN EXPONENT*)
    KMAX =  15;     (*MAX NO. OF SIGNIFICANT DIGITS*)
    TMAX = 100;     (*SIZE OF TABLE*)
    BMAX =  20;     (*SIZE OF BLOCK-TABLE*)
    AMAX =  30;     (*SIZE OF ARRAY-TABLE*)
    C2MAX = 20;     (*SIZE OF REAL CONSTANT TABLE*)
    CSMAX = 30;     (*MAX NO. OF CASES*)
    CMAX = 500;     (*SIZE OF CODE*)
    LMAX =   7;     (*MAXIMUM LEVEL*)
    SMAX = 400;     (*SIZE OF STRING-TABLE*)
    ERMAX = 58;     (*MAX ERROR NO.*)
    OMAX =  66;     (*HIGHEST ORDER CODE*)
(* { SHIT, LOOK AT THIS NUMBERÝÝÝÝÝ                                           *)
(*  NMAX = 281474976710655;     2**48-1*)
(* }                                                                          *)
##  NMAX = "MAXINT" 32767;
    XMAX = NMAX;    (*131071 = 2**17 - 1*)
    LINELENG = 136; (*OUTPUT LINE LENGTH*)
    LINELIMIT = 200;
    STACKSIZE = 200;

TYPE SYMBOL = (INTCON,REALCON,CHARCON,STRING,
          NOTSY,PLUS,MINUS,TIMES,IDIV,RDIV,IMOD,ANDSY,ORSY,
          EQL,NEQ,GTR,GEQ,LSS,LEQ,
          LPARENT,RPARENT,LBRACK,RBRACK,COMMA,SEMICOLON,PERIOD,
          COLON,BECOMES,CONSTSY,TYPESY,VARSY,FUNCSY,
          PROCSY,ARRAYSY,RECORDSY,PROGRAMSY,IDENT,
          BEGINSY,IFSY,CASESY,REPEATSY,WHILESY,FORSY,
          ENDSY,ELSESY,UNTILSY,OFSY,DOSY,TOSY,DOWNTOSY,THENSY);

#   INDEX  = 0(*-XMAX*) .. +XMAX;
    ALFA = PACKED ARRAY [1..ALNG] OF CHAR;
    OBJECT = (KONSTANT,VARIABLE,TYPE1,PROZEDURE,FUNKTION);
    TYPES  = (NOTYP,INTS,REALS,BOOLS,CHARS,ARRAYS,RECORDS);
    SYMSET = SET OF SYMBOL;
    TYPSET = SET OF TYPES;
    ITEM   = RECORD
          TYP: TYPES; REF: INDEX;
        END ;
    ORDER  = PACKED RECORD
          F: -OMAX..+OMAX;
          X: -LMAX..+LMAX;
#         Y: 0(*-NMAX*)..+NMAX;
        END ;

VAR SY: SYMBOL;          (*LAST SYMBOL READ BY INSYMBOL*)
    ID: ALFA;            (*IDENTIFIER FROM INSYMBOL*)
    INUM: INTEGER;       (*INTEGER FROM INSYMBOL*)
    RNUM: REAL;          (*REAL NUMBER FROM INSYMBOL*)
    SLENG: INTEGER;      (*STRING LENGTH*)
    CH: CHAR;            (*LAST CHARACTER READ FROM SOURCE PROGRAM*)
    LINE: ARRAY [1..LLNG] OF CHAR;
    CC: INTEGER;         (*CHARACTER COUNTER*)
    LC: INTEGER;         (*PROGRAM LOCATION COUNTER*)
    LL: INTEGER;         (*LENGTH OF CURRENT LINE*)
    ERRS: SET OF 0..ERMAX;
    ERRPOS: INTEGER;
    PROGNAME: ALFA;
    IFLAG, OFLAG: BOOLEAN;
    CONSTBEGSYS,TYPEBEGSYS,BLOCKBEGSYS,FACBEGSYS,STATBEGSYS: SYMSET;
    KEY: ARRAY [1..NKW] OF ALFA;
    KSY: ARRAY [1..NKW] OF SYMBOL;
    SPS: ARRAY [CHAR] OF SYMBOL;  (*SPECIAL SYMBOLS*)

    T,A,B,SX,C1,C2: INTEGER;  (*INDICES TO TABLES*)
    STANTYPS: TYPSET;
    DISPLAY: ARRAY [0 .. LMAX] OF INTEGER;

    TAB:     ARRAY [0 .. TMAX] OF     (*IDENTIFIER TABLE*)
          PACKED RECORD
       NAME: ALFA;  LINK: INDEX;
       OBJ: OBJECT; TYP: TYPES;
       REF: INDEX;  NORMAL: BOOLEAN;
       LEV: 0 .. LMAX; ADR: INTEGER;
          END ;
    ATAB:    ARRAY [1 .. AMAX] OF     (*ARRAY-TABLE*)
          PACKED RECORD
       INXTYP, ELTYP: TYPES;
       ELREF, LOW, HIGH, ELSIZE, SIZE: INDEX;
          END ;
    BTAB:    ARRAY [1 .. BMAX] OF    (*BLOCK-TABLE*)
          PACKED RECORD
        LAST, LASTPAR, PSIZE, VSIZE: INDEX
          END ;
    STAB:    PACKED ARRAY [0..SMAX] OF CHAR;  (*STRING TABLE*)
    RCONST:  ARRAY [1 .. C2MAX] OF REAL;
    CODE:    ARRAY [0 .. CMAX] OF ORDER;
(* EOF                                                                        *)
(* #INCLUDE "ERROR.I"                                                         *)
(* ERROR.I                                                                    *)

PROCEDURE ERRORMSG;
   VAR K: INTEGER;
       MSG: ARRAY [0..ERMAX] OF ALFA;
BEGIN
  MSG[ 0] := 'UNDEF ID  '; MSG[ 1] := 'MULTI DEF ';
  MSG[ 2] := 'IDENTIFIER'; MSG[ 3] := 'PROGRAM   ';
  MSG[ 4] := ')         '; MSG[ 5] := ':         ';
  MSG[ 6] := 'SYNTAX    '; MSG[ 7] := 'IDENT, VAR';
  MSG[ 8] := 'OF        '; MSG[ 9] := '(         ';
  MSG[10] := 'ID, ARRAY '; MSG[11] := '[         ';
  MSG[12] := ']         '; MSG[13] := '..        ';
  MSG[14] := ';         '; MSG[15] := 'FUNC. TYPE';
  MSG[16] := '=         '; MSG[17] := 'BOOLEAN   ';
  MSG[18] := 'CONVAR TYP'; MSG[19] := 'TYPE      ';
  MSG[20] := 'PROG.PARAM'; MSG[21] := 'TOO BIG   ';
  MSG[22] := '.         '; MSG[23] := 'TYP (CASE)';
  MSG[24] := 'CHARACTER '; MSG[25] := 'CONST ID  ';
  MSG[26] := 'INDEX TYPE'; MSG[27] := 'INDEXBOUND';
  MSG[28] := 'NO ARRAY  '; MSG[29] := 'TYPE ID   ';
  MSG[30] := 'UNDEF TYPE'; MSG[31] := 'NO RECORD ';
  MSG[32] := 'BOOLE TYPE'; MSG[33] := 'ARITH TYPE';
  MSG[34] := 'INTEGER   '; MSG[35] := 'TYPES     ';
  MSG[36] := 'PARAM TYPE'; MSG[37] := 'VARIAB ID ';
  MSG[38] := 'STRING    '; MSG[39] := 'NO.OF PARS';
  MSG[40] := 'TYPE      '; MSG[41] := 'TYPE      ';
  MSG[42] := 'REAL TYPE '; MSG[43] := 'INTEGER   ';
  MSG[44] := 'VAR, CONST'; MSG[45] := 'VAR, PROC ';
  MSG[46] := 'TYPES (:=)'; MSG[47] := 'TYP (CASE)';
  MSG[48] := 'TYPE      '; MSG[49] := 'STORE OVFL';
  MSG[50] := 'CONSTANT  '; MSG[51] := ':=        ';
  MSG[52] := 'THEN      '; MSG[53] := 'UNTIL     ';
  MSG[54] := 'DO        '; MSG[55] := 'TO DOWNTO ';
  MSG[56] := 'BEGIN     '; MSG[57] := 'END       ';
  MSG[58] := 'FACTOR    ';
  K := 0; WRITELN; WRITELN(' KEY WORDS');
  WHILE ERRS <> [] DO
  BEGIN WHILE NOT (K IN ERRS) DO K := K+1;
        WRITELN(K,'  ',MSG[K]); ERRS := ERRS - [K]
  END
END (*ERRORMSG*) ;


PROCEDURE ERROR(N: INTEGER);
BEGIN IF ERRPOS = 0 THEN WRITE(' ****');
   IF CC > ERRPOS THEN
      BEGIN WRITE(' ': CC-ERRPOS, '@', N:2);
         ERRPOS := CC+3; ERRS := ERRS + [N]
      END
END (*ERROR*) ;

PROCEDURE FATAL(N: INTEGER);
   VAR MSG: ARRAY [1..7] OF ALFA;
BEGIN WRITELN; ERRORMSG;
   MSG[ 1] := 'IDENTIFIER'; MSG[ 2] := 'PROCEDURES';
   MSG[ 3] := 'REALS     '; MSG[ 4] := 'ARRAYS    ';
   MSG[ 5] := 'LEVELS    '; MSG[ 6] := 'CODE      ';
   MSG[ 7] := 'STRINGS   ';
   WRITELN(' COMPILER TABLE FOR ', MSG[N], ' IS TOO SMALL');
   (*GOTO 99*)  EXIT(99)    (* TERMINATE COMPILATION*)
END (*FATAL*) ;

(* EOF                                                                        *)
(* #INCLUDE "SCANNER.I"                                                       *)
(* SCANNER.I                                                                  *)
PROCEDURE NEXTCH;   (*READ NEXT CHARACTER; PROCESS LINE END*)
BEGIN IF CC = LL THEN
      BEGIN IF EOF(INPUT) THEN
            BEGIN WRITELN;
               WRITELN(' PROGRAM INCOMPLETE');
               ERRORMSG; (*GOTO 99*)  EXIT(99)
            END ;
         IF ERRPOS <> 0 THEN
            BEGIN WRITELN; ERRPOS := 0
            END ;
         WRITE(LC:6, '  ');
         LL := 0; CC := 0;
         WHILE NOT EOLN(INPUT) DO
            BEGIN LL := LL+1; READ(CH); WRITE(CH); LINE[LL] := CH
            END ;
         WRITELN; LL := LL+1; READ(LINE[LL])
      END ;
   CC := CC+1; CH := LINE[CC];
END (*NEXTCH*) ;

PROCEDURE INSYMBOL;           (*READS NEXT SYMBOL*)
   LABEL 1,2,3;
   VAR I,J,K,E: INTEGER;

   PROCEDURE READSCALE;
      VAR S, SIGN: INTEGER;
   BEGIN NEXTCH; SIGN := 1; S := 0;
      IF CH = '+' THEN NEXTCH ELSE
      IF CH = '-' THEN BEGIN NEXTCH; SIGN := -1 END ;
      WHILE CH IN ['0'..'9'] DO
         BEGIN S := 10*S + ORD(CH) - ORD('0'); NEXTCH
         END ;
      E := S*SIGN + E
   END (*READSCALE*) ;

   PROCEDURE ADJUSTSCALE;
      VAR S: INTEGER; D,T: REAL;
   BEGIN IF K+E > EMAX THEN ERROR(21) ELSE
         IF K+E < EMIN THEN RNUM := 0 ELSE
     BEGIN S := ABS(E); T := 1.0; D := 10.0;
       REPEAT
         WHILE NOT ODD(S) DO
#           BEGIN S := S DIV 2; D := D*D (*SQR(D)*)
            END ;
         S := S-1; T := D*T
       UNTIL S = 0;
       IF E >= 0 THEN RNUM := RNUM*T ELSE RNUM := RNUM/T
     END
   END (*ADJUSTSCALE*) ;

BEGIN (*INSYMBOL*)
1: WHILE (CH = ' ') OR (CH = TABCH) DO NEXTCH;
   IF CH IN ['A'..'Z'] THEN
   BEGIN (*IDENTIFIER OR WORDSYMBOL*)  K := 0; ID := '          ';
      REPEAT IF K < ALNG THEN
             BEGIN K := K+1; ID[K] := CH
             END ;
         NEXTCH
      UNTIL NOT (CH IN ['A'..'Z','0'..'9']);
      I := 1; J := NKW;   (*BINARY SEARCH*)
      REPEAT K := (I+J) DIV 2;
         IF ID <= KEY[K] THEN J := K-1;
         IF ID >= KEY[K] THEN I := K+1
      UNTIL I > J;
      IF I-1 > J THEN SY := KSY[K] ELSE SY := IDENT
   END ELSE
   IF CH IN ['0'..'9'] THEN
   BEGIN (*NUMBER*) K := 0; INUM := 0; SY := INTCON;
      REPEAT INUM := INUM*10 + ORD(CH) - ORD('0');
         K := K+1; NEXTCH
      UNTIL NOT (CH IN ['0'..'9']);
      IF (K > KMAX) OR (INUM > NMAX) THEN
        BEGIN ERROR(21); INUM := 0; K := 0
        END ;
      IF CH = '.' THEN
      BEGIN NEXTCH;
         IF CH = '.' THEN CH := ':' ELSE
            BEGIN SY := REALCON; RNUM := INUM; E := 0;
               WHILE CH IN ['0'..'9'] DO
               BEGIN E := E-1;
                  RNUM := 10.0*RNUM + (ORD(CH)-ORD('0')); NEXTCH
               END ;
               IF CH = 'E' THEN READSCALE;
               IF E <> 0 THEN ADJUSTSCALE
            END
      END ELSE
      IF CH = 'E' THEN
      BEGIN SY := REALCON; RNUM := INUM; E := 0;
         READSCALE; IF E <> 0 THEN ADJUSTSCALE
      END ;
   END ELSE
   CASE CH OF
':' : BEGIN NEXTCH;
          IF CH = '=' THEN
            BEGIN SY := BECOMES; NEXTCH
            END  ELSE SY := COLON
      END ;
'<' : BEGIN NEXTCH;
         IF CH = '=' THEN BEGIN SY := LEQ; NEXTCH END ELSE
         IF CH = '>' THEN BEGIN SY := NEQ; NEXTCH END ELSE SY := LSS
      END ;
'>' : BEGIN NEXTCH;
         IF CH = '=' THEN BEGIN SY := GEQ; NEXTCH END ELSE SY := GTR
      END ;
'.' : BEGIN NEXTCH;
         IF CH = '.' THEN
            BEGIN SY := COLON; NEXTCH
            END  ELSE SY := PERIOD
      END ;
'''': BEGIN K := 0;
    2:  NEXTCH;
        IF CH = '''' THEN
          BEGIN NEXTCH; IF CH <> '''' THEN GOTO 3
          END ;
        IF SX+K = SMAX THEN FATAL(7);
        STAB[SX+K] := CH; K := K+1;
        IF CC = 1 THEN
          BEGIN (*END OF LINE*) K := 0;
          END
        ELSE GOTO 2;
    3:  IF K = 1 THEN
           BEGIN SY := CHARCON; INUM := ORD(STAB[SX])
           END ELSE
        IF K = 0 THEN
           BEGIN ERROR(38); SY := CHARCON; INUM := 0
           END ELSE
           BEGIN SY := STRING; INUM := SX; SLENG := K; SX := SX+K
           END
      END ;
'(' : BEGIN NEXTCH;
         IF CH <> '*' THEN SY := LPARENT ELSE
         BEGIN (*COMMENT*) NEXTCH;
            REPEAT
               WHILE CH <> '*' DO NEXTCH;
               NEXTCH
            UNTIL CH = ')';
            NEXTCH; GOTO 1
         END
      END ;
'+', '-', '*', '/', ')', '=', ',', '[', ']', '#', '&', ';' :
      BEGIN SY := SPS[CH]; NEXTCH
      END ;
'$', (*'\',*) 'Ý', (*'?',*) '@', '_', '"', '^' :
      BEGIN ERROR(24); NEXTCH; GOTO 1
      END
   END;
END (*INSYMBOL*) ;

(* EOF                                                                        *)
(* #INCLUDE "TABLES.I"                                                        *)
(* TABLES.I                                                                   *)
PROCEDURE ENTER(X0: ALFA; X1: OBJECT;
                X2: TYPES; X3: INTEGER);
BEGIN T := T+1;   (*ENTER STANDARD IDENTIFIER*)
   WITH TAB[T] DO
   BEGIN NAME := X0; LINK := T-1; OBJ := X1;
      TYP := X2; REF := 0; NORMAL := TRUE;
      LEV := 0; ADR := X3
   END
END (*ENTER*) ;

PROCEDURE ENTERARRAY(TP: TYPES; L,H: INTEGER);
BEGIN IF L > H THEN ERROR(27);
   IF (ABS(L)>XMAX) OR (ABS(H)>XMAX) THEN
      BEGIN ERROR(27); L := 0; H := 0;
      END ;
   IF A = AMAX THEN FATAL(4) ELSE
      BEGIN A := A+1;
        WITH ATAB[A] DO
            BEGIN INXTYP := TP; LOW := L; HIGH := H
            END
      END
END (*ENTERARRAY*) ;

PROCEDURE ENTERBLOCK;
BEGIN IF B = BMAX THEN FATAL(2) ELSE
      BEGIN B := B+1; BTAB[B].LAST := 0; BTAB[B].LASTPAR := 0
      END
END (*ENTERBLOCK*) ;

PROCEDURE ENTERREAL(X: REAL);
BEGIN IF C2 = C2MAX-1 THEN FATAL(3) ELSE
      BEGIN RCONST[C2+1] := X; C1 := 1;
         WHILE RCONST[C1] <> X DO  C1 := C1+1;
         IF C1 > C2 THEN C2 := C1
      END
END (*ENTERREAL*) ;

PROCEDURE EMIT(FCT: INTEGER);
BEGIN IF LC = CMAX THEN FATAL(6);
   CODE[LC].F := FCT; LC := LC+1
END (*EMIT*) ;

PROCEDURE EMIT1(FCT,B: INTEGER);
BEGIN IF LC = CMAX THEN FATAL(6);
   WITH CODE[LC] DO
      BEGIN F := FCT; Y := B END ;
   LC := LC+1
END (*EMIT1*) ;

PROCEDURE EMIT2(FCT,A,B: INTEGER);
BEGIN IF LC = CMAX THEN FATAL(6);
   WITH CODE[LC] DO
     BEGIN F := FCT; X := A; Y := B END ;
   LC := LC+1
END (*EMIT2*) ;

PROCEDURE PRINTTABLES;
   VAR I: INTEGER; O: ORDER;
BEGIN
   WRITELN('0IDENTIFIERS          LINK', '  OBJ  TYP  REF  NRM  LEV  ADR');
   FOR I := BTAB[1].LAST +1 TO T DO
      WITH TAB[I] DO
      WRITELN(I,' ',NAME,LINK:5, ORD(OBJ):5, ORD(TYP):5, REF:5,
            ORD(NORMAL):5, LEV:5, ADR:5);
   WRITELN('0BLOCKS    LAST LPAR PSZE VSZE');
   FOR I := 1 TO B DO
      WITH BTAB[I] DO
      WRITELN(I, LAST:5, LASTPAR:5, PSIZE:5, VSIZE:5);
   WRITELN('0ARRAYS    XTYP ETYP EREF  LOW HIGH ELSZ SIZE');
   FOR I := 1 TO A DO
      WITH ATAB[I] DO
      WRITELN(I, ORD(INXTYP):5, ORD(ELTYP):5,
              ELREF:5, LOW:5, HIGH:5, ELSIZE:5, SIZE:5);
   WRITELN('0CODE:');
   FOR I := 0 TO LC-1 DO
   BEGIN IF I MOD 5 = 0 THEN
         BEGIN WRITELN; WRITE(I:5)
         END ;
      O := CODE[I]; WRITE(O.F:5);
      IF O.F < 31 THEN
        IF O.F < 4 THEN WRITE(O.X:2, O.Y:5)
                    ELSE WRITE(O.Y:7)
      ELSE WRITE('       ');
      WRITE(',')
   END ;
   WRITELN;
END (*PRINTTABLES*) ;

(* EOF                                                                        *)
(* #INCLUDE "BLOCK.I"                                                         *)
(* BLOCK.I                                                                    *)
PROCEDURE BLOCK(FSYS: SYMSET; ISFUN: BOOLEAN; LEVEL: INTEGER);

   TYPE CONREC =
      RECORD CASE TP: TYPES OF
         INTS,CHARS,BOOLS: (I: INTEGER);
         REALS: (R: REAL)
      END ;

   VAR DX: INTEGER;    (*DATA ALLOCATION INDEX*)
       PRT: INTEGER;   (*T-INDEX OF THIS PROCEDURE*)
       PRB: INTEGER;   (*B-INDEX OF THIS PROCEDURE*)
       X: INTEGER;
   PROCEDURE SKIP(FSYS: SYMSET; N: INTEGER);
   BEGIN ERROR(N);
      WHILE NOT (SY IN FSYS) DO INSYMBOL
   END (*SKIP*) ;

   PROCEDURE TEST(S1,S2: SYMSET; N: INTEGER);
   BEGIN IF NOT (SY IN S1) THEN
         SKIP(S1+S2,N)
   END (*TEST*) ;

   PROCEDURE TESTSEMICOLON;
   BEGIN
     IF SY = SEMICOLON THEN INSYMBOL ELSE
     BEGIN ERROR(14);
       IF SY IN [COMMA,COLON] THEN INSYMBOL
     END ;
     TEST([IDENT]+BLOCKBEGSYS, FSYS, 6)
   END (*TESTSEMICOLON*) ;

   PROCEDURE ENTER(ID: ALFA; K: OBJECT);
      VAR J,L: INTEGER;
   BEGIN IF T = TMAX THEN FATAL(1) ELSE
         BEGIN TAB[0].NAME := ID;
            J := BTAB[DISPLAY[LEVEL]].LAST;  L := J;
            WHILE TAB[J].NAME <> ID DO  J := TAB[J].LINK;
            IF J <> 0 THEN ERROR(1) ELSE
            BEGIN T := T+1;
              WITH TAB[T] DO
              BEGIN NAME := ID; LINK := L;
               OBJ := K; TYP := NOTYP; REF := 0; LEV := LEVEL; ADR := 0
              END ;
              BTAB[DISPLAY[LEVEL]].LAST := T
            END
         END
   END (*ENTER*) ;

   FUNCTION LOC(ID: ALFA): INTEGER;
      VAR I,J: INTEGER;     (*LOCATE ID IN TABLE*)
   BEGIN I := LEVEL; TAB[0].NAME := ID;   (*SENTINEL*)
      REPEAT J := BTAB[DISPLAY[I]].LAST;
         WHILE TAB[J].NAME <> ID DO  J := TAB[J].LINK;
         I := I-1;
      UNTIL (I<0) OR (J<>0);
      IF J = 0 THEN ERROR(0);  LOC := J
   END (*LOC*) ;

  PROCEDURE ENTERVARIABLE;
  BEGIN IF SY = IDENT THEN
          BEGIN ENTER(ID,VARIABLE); INSYMBOL
          END
        ELSE ERROR(2)
  END (*ENTERVARIABLE*) ;

   PROCEDURE CONSTANT(FSYS: SYMSET; VAR C: CONREC);
     VAR X, SIGN: INTEGER;
   BEGIN C.TP := NOTYP; C.I := 0;
     TEST(CONSTBEGSYS, FSYS, 50);
     IF SY IN CONSTBEGSYS THEN
     BEGIN
         IF SY = CHARCON THEN
           BEGIN C.TP := CHARS; C.I := INUM; INSYMBOL
           END
         ELSE
           BEGIN SIGN := 1;
             IF SY IN [PLUS,MINUS] THEN
               BEGIN IF SY = MINUS THEN SIGN := -1;
                 INSYMBOL
               END ;
             IF SY = IDENT THEN
               BEGIN X := LOC(ID);
                 IF X <> 0 THEN
                   IF TAB[X].OBJ <> KONSTANT THEN ERROR(25) ELSE
                   BEGIN C.TP := TAB[X].TYP;
                     IF C.TP = REALS THEN C.R := SIGN*RCONST[TAB[X].ADR]
                                     ELSE C.I := SIGN*TAB[X].ADR
                   END ;
                 INSYMBOL
               END
             ELSE
             IF SY = INTCON THEN
               BEGIN C.TP := INTS; C.I := SIGN*INUM; INSYMBOL
               END ELSE
             IF SY = REALCON THEN
               BEGIN C.TP := REALS; C.R := SIGN*RNUM; INSYMBOL
               END ELSE SKIP(FSYS,50)
           END;
         TEST(FSYS, [], 6)
       END
   END (*CONSTANT*) ;
   PROCEDURE TYP(FSYS: SYMSET; VAR TP: TYPES; VAR RF, SZ: INTEGER);
     VAR X: INTEGER;
         ELTP: TYPES; ELRF: INTEGER;
         ELSZ, OFFSET, T0,T1: INTEGER;

     PROCEDURE ARRAYTYP(VAR AREF,ARSZ: INTEGER);
        VAR ELTP: TYPES;
           LOW, HIGH: CONREC;
           ELRF, ELSZ: INTEGER;
     BEGIN CONSTANT([COLON,RBRACK,RPARENT,OFSY]+FSYS, LOW);
        IF LOW.TP = REALS THEN
           BEGIN ERROR(27); LOW.TP := INTS; LOW.I := 0
           END ;
        IF SY = COLON THEN INSYMBOL ELSE ERROR(13);
        CONSTANT([RBRACK,COMMA,RPARENT,OFSY]+FSYS, HIGH);
        IF HIGH.TP <> LOW.TP THEN
           BEGIN ERROR(27); HIGH.I := LOW.I
           END ;
        ENTERARRAY(LOW.TP, LOW.I, HIGH.I); AREF := A;
        IF SY = COMMA THEN
           BEGIN INSYMBOL; ELTP := ARRAYS; ARRAYTYP(ELRF,ELSZ)
           END ELSE
        BEGIN
           IF SY = RBRACK THEN INSYMBOL ELSE
              BEGIN ERROR(12);
                 IF SY = RPARENT THEN INSYMBOL
              END ;
           IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
           TYP(FSYS,ELTP,ELRF,ELSZ)
        END ;
        WITH ATAB[AREF] DO
        BEGIN ARSZ := (HIGH-LOW+1)*ELSZ; SIZE := ARSZ;
           ELTYP := ELTP; ELREF := ELRF; ELSIZE := ELSZ
        END ;
     END (*ARRAYTYP*) ;

   BEGIN (*TYP*) TP := NOTYP; RF := 0; SZ := 0;
     TEST(TYPEBEGSYS, FSYS, 10);
     IF SY IN TYPEBEGSYS THEN
       BEGIN
         IF SY = IDENT THEN
         BEGIN X := LOC(ID);
           IF X <> 0 THEN
           WITH TAB[X] DO
             IF OBJ <> TYPE1 THEN ERROR(29) ELSE
             BEGIN TP := TYP; RF := REF; SZ := ADR;
               IF TP = NOTYP THEN ERROR(30)
             END ;
           INSYMBOL
         END ELSE
         IF SY = ARRAYSY THEN
         BEGIN INSYMBOL;
             IF SY = LBRACK THEN INSYMBOL ELSE
                BEGIN ERROR(11);
                   IF SY = LPARENT THEN INSYMBOL
                END ;
             TP := ARRAYS; ARRAYTYP(RF,SZ)
         END ELSE
         BEGIN (*RECORDS*) INSYMBOL;
           ENTERBLOCK; TP := RECORDS; RF := B;
           IF LEVEL = LMAX THEN FATAL(5);
           LEVEL := LEVEL+1; DISPLAY[LEVEL] := B; OFFSET := 0;
           WHILE SY <> ENDSY DO
           BEGIN (*FIELD SECTION*)
             IF SY = IDENT THEN
             BEGIN T0 := T; ENTERVARIABLE;
               WHILE SY = COMMA DO
                 BEGIN INSYMBOL; ENTERVARIABLE
                 END ;
               IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
               T1 := T;
               TYP(FSYS+[SEMICOLON,ENDSY,COMMA,IDENT],ELTP,ELRF,ELSZ);
               WHILE T0 < T1 DO
               BEGIN T0 := T0+1;
                 WITH TAB[T0] DO
                 BEGIN TYP := ELTP; REF := ELRF; NORMAL := TRUE;
                   ADR := OFFSET; OFFSET := OFFSET + ELSZ
                 END
               END
             END ;
             IF SY <> ENDSY THEN
             BEGIN IF SY = SEMICOLON THEN INSYMBOL ELSE
                   BEGIN ERROR(14);
                     IF SY = COMMA THEN INSYMBOL
                   END ;
                TEST([IDENT,ENDSY,SEMICOLON], FSYS, 6)
             END
           END ;
           BTAB[RF].VSIZE := OFFSET; SZ := OFFSET; BTAB[RF].PSIZE := 0;
           INSYMBOL; LEVEL := LEVEL-1
         END ;
         TEST(FSYS, [], 6)
       END
   END (*TYP*) ;

   PROCEDURE PARAMETERLIST;     (*FORMAL PARAMETER LIST*)
      VAR TP: TYPES;
          RF, SZ, X, T0: INTEGER;
          VALPAR: BOOLEAN;
   BEGIN INSYMBOL; TP := NOTYP; RF := 0; SZ := 0;
     TEST([IDENT, VARSY], FSYS+[RPARENT], 7);
     WHILE SY IN [IDENT,VARSY] DO
       BEGIN IF SY <> VARSY THEN VALPAR := TRUE ELSE
               BEGIN INSYMBOL; VALPAR := FALSE
               END ;
         T0 := T; ENTERVARIABLE;
         WHILE SY = COMMA DO
            BEGIN INSYMBOL; ENTERVARIABLE;
            END ;
         IF SY = COLON THEN
           BEGIN INSYMBOL;
             IF SY <> IDENT THEN ERROR(2) ELSE
             BEGIN X := LOC(ID); INSYMBOL;
               IF X <> 0 THEN
               WITH TAB[X] DO
                 IF OBJ <> TYPE1 THEN ERROR(29) ELSE
                   BEGIN TP := TYP; RF := REF;
                     IF VALPAR THEN SZ := ADR ELSE SZ := 1
                   END ;
             END ;
             TEST([SEMICOLON,RPARENT], [COMMA,IDENT]+FSYS, 14)
           END
         ELSE ERROR(5);
         WHILE T0 < T DO
         BEGIN T0 := T0+1;
           WITH TAB[T0] DO
           BEGIN TYP := TP; REF := RF;
               NORMAL := VALPAR; ADR := DX; LEV := LEVEL;
               DX := DX + SZ
           END
         END ;
         IF SY <> RPARENT THEN
         BEGIN IF SY = SEMICOLON THEN INSYMBOL ELSE
               BEGIN ERROR(14);
                 IF SY = COMMA THEN INSYMBOL
               END ;
            TEST([IDENT,VARSY], [RPARENT]+FSYS, 6)
         END
       END (*WHILE*) ;
     IF SY = RPARENT THEN
       BEGIN INSYMBOL;
         TEST([SEMICOLON,COLON], FSYS, 6)
       END
     ELSE ERROR(4)
   END (*PARAMETERLIST*) ;

   PROCEDURE CONSDECLARATION;
     VAR C: CONREC;
   BEGIN INSYMBOL;
     TEST([IDENT], BLOCKBEGSYS, 2);
     WHILE SY = IDENT DO
       BEGIN ENTER(ID,KONSTANT); INSYMBOL;
         IF SY = EQL THEN INSYMBOL ELSE
            BEGIN ERROR(16);
               IF SY = BECOMES THEN INSYMBOL
            END ;
         CONSTANT([SEMICOLON,COMMA,IDENT]+FSYS,C);
         TAB[T].TYP := C.TP; TAB[T].REF := 0;
         IF C.TP = REALS THEN
           BEGIN ENTERREAL(C.R); TAB[T].ADR := C1 END
         ELSE TAB[T].ADR := C.I;
         TESTSEMICOLON
       END
   END (*CONSDECLARATION*) ;

   PROCEDURE TYPEDECLARATION;
     VAR TP: TYPES; RF, SZ, T1: INTEGER;
   BEGIN INSYMBOL;
     TEST([IDENT], BLOCKBEGSYS, 2);
     WHILE SY = IDENT DO
       BEGIN ENTER(ID,TYPE1); T1 := T; INSYMBOL;
         IF SY = EQL THEN INSYMBOL ELSE
            BEGIN ERROR(16);
               IF SY = BECOMES THEN INSYMBOL
            END ;
         TYP([SEMICOLON,COMMA,IDENT]+FSYS, TP, RF, SZ);
         WITH TAB[T1] DO
           BEGIN TYP := TP; REF := RF; ADR := SZ
           END ;
         TESTSEMICOLON
       END
   END (*TYPEDECLARATION*) ;

   PROCEDURE VARDECLARATION;
     VAR T0, T1, RF, SZ: INTEGER;
         TP: TYPES;
   BEGIN INSYMBOL;
     WHILE SY = IDENT DO
     BEGIN T0 := T; ENTERVARIABLE;
       WHILE SY = COMMA DO
         BEGIN INSYMBOL; ENTERVARIABLE;
         END ;
       IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
       T1 := T;
       TYP([SEMICOLON,COMMA,IDENT]+FSYS, TP, RF, SZ);
       WHILE T0 < T1 DO
       BEGIN T0 := T0+1;
         WITH TAB[T0] DO
         BEGIN TYP := TP; REF := RF;
           LEV := LEVEL; ADR := DX; NORMAL := TRUE;
           DX := DX + SZ
         END
       END ;
       TESTSEMICOLON
     END
   END (*VARDECLARATION*) ;

   PROCEDURE PROCDECLARATION;
      VAR ISFUN: BOOLEAN;
   BEGIN ISFUN := SY = FUNCSY; INSYMBOL;
     IF SY <> IDENT THEN
        BEGIN  ERROR(2); ID := '          '
        END ;
     IF ISFUN THEN ENTER(ID,FUNKTION) ELSE ENTER(ID,PROZEDURE);
     TAB[T].NORMAL := TRUE;
     INSYMBOL; BLOCK([SEMICOLON]+FSYS, ISFUN, LEVEL+1);
     IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
     EMIT(32+ORD(ISFUN))    (*EXIT*)
   END (*PROCEDUREDECLARATION*) ;

(*---------------------------------------------------------STATEMENT--*)

   PROCEDURE STATEMENT(FSYS: SYMSET);
      VAR I: INTEGER;
      PROCEDURE EXPRESSION(FSYS: SYMSET; VAR X: ITEM); FORWARD;

      PROCEDURE SELECTOR(FSYS: SYMSET; VAR V:ITEM);
         VAR X: ITEM; A,J: INTEGER;
      BEGIN (*SY IN [LPARENT, LBRACK, PERIOD]*)
        REPEAT
          IF SY = PERIOD THEN
          BEGIN INSYMBOL;  (*FIELD SELECTOR*)
            IF SY <> IDENT THEN ERROR(2) ELSE
            BEGIN
              IF V.TYP <> RECORDS THEN ERROR(31) ELSE
              BEGIN (*SEARCH FIELD IDENTIFIER*)
                J := BTAB[V.REF] .LAST; TAB[0].NAME := ID;
                WHILE TAB[J].NAME <> ID DO J := TAB[J].LINK;
                IF J = 0 THEN ERROR(0);
                V.TYP := TAB[J].TYP; V.REF := TAB[J].REF;
                A := TAB[J].ADR; IF A <> 0 THEN EMIT1(9,A)
              END ;
              INSYMBOL
            END
          END ELSE
          BEGIN (*ARRAY SELECTOR*)
            IF SY <> LBRACK THEN ERROR(11);
            REPEAT INSYMBOL;
              EXPRESSION(FSYS+[COMMA,RBRACK], X);
              IF V.TYP <> ARRAYS THEN ERROR(28) ELSE
                BEGIN A := V.REF;
                  IF ATAB[A].INXTYP <> X.TYP THEN ERROR(26) ELSE
                IF ATAB[A].ELSIZE = 1 THEN EMIT1(20,A) ELSE EMIT1(21,A);
                  V.TYP := ATAB[A].ELTYP; V.REF := ATAB[A].ELREF
                END
            UNTIL SY <> COMMA;
            IF SY = RBRACK THEN INSYMBOL ELSE
              BEGIN ERROR(12); IF SY = RPARENT THEN INSYMBOL
              END
          END
        UNTIL NOT (SY IN [LBRACK,LPARENT,PERIOD]);
        TEST(FSYS, [], 6)
      END (*SELECTOR*) ;

      PROCEDURE CALL(FSYS: SYMSET; I: INTEGER);
         VAR X: ITEM;
             LASTP, CP, K: INTEGER;
      BEGIN EMIT1(18,I);  (*MARK STACK*)
        LASTP := BTAB[TAB[I].REF].LASTPAR; CP := I;
        IF SY = LPARENT THEN
        BEGIN (*ACTUAL PARAMETER LIST*)
          REPEAT INSYMBOL;
            IF CP >= LASTP THEN ERROR(39) ELSE
            BEGIN CP := CP+1;
              IF TAB[CP].NORMAL THEN
              BEGIN (*VALUE PARAMETER*)
                EXPRESSION(FSYS+[COMMA,COLON,RPARENT], X);
                IF X.TYP=TAB[CP].TYP THEN
                  BEGIN
                    IF X.REF <> TAB[CP].REF THEN ERROR(36) ELSE
                  IF X.TYP = ARRAYS THEN EMIT1(22,ATAB[X.REF].SIZE) ELSE
                    IF X.TYP = RECORDS THEN EMIT1(22,BTAB[X.REF].VSIZE)
                  END ELSE
                IF (X.TYP=INTS) AND (TAB[CP].TYP=REALS) THEN
                   EMIT1(26,0) ELSE
                   IF X.TYP<>NOTYP THEN ERROR(36);
              END ELSE
              BEGIN (*VARIABLE PARAMETER*)
                IF SY <> IDENT THEN ERROR(2) ELSE
                BEGIN K := LOC(ID); INSYMBOL;
                  IF K <> 0 THEN
                  BEGIN IF TAB[K].OBJ <> VARIABLE THEN ERROR(37);
                    X.TYP := TAB[K].TYP; X.REF := TAB[K].REF;
                    IF TAB[K].NORMAL THEN EMIT2(0,TAB[K].LEV,TAB[K].ADR)
                       ELSE EMIT2(1,TAB[K].LEV,TAB[K].ADR);
                    IF SY IN [LBRACK,LPARENT,PERIOD] THEN
                       SELECTOR(FSYS+[COMMA,COLON,RPARENT], X);
                    IF (X.TYP<>TAB[CP].TYP) OR (X.REF<>TAB[CP].REF) THEN
                       ERROR(36)
                  END
                END
              END
            END ;
            TEST([COMMA,RPARENT], FSYS, 6)
          UNTIL SY <> COMMA;
          IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
        END ;
        IF CP < LASTP THEN ERROR(39); (*TOO FEW ACTUAL PARAMETERS*)
        EMIT1(19, BTAB[TAB[I].REF].PSIZE-1);
        IF TAB[I].LEV < LEVEL THEN EMIT2(3, TAB[I].LEV, LEVEL)
      END (*CALL*) ;

      FUNCTION RESULTTYPE(A,B: TYPES): TYPES;
      BEGIN
        IF (A>REALS) OR (B>REALS) THEN
          BEGIN ERROR(33); RESULTTYPE := NOTYP
          END ELSE
        IF (A=NOTYP) OR (B=NOTYP) THEN RESULTTYPE := NOTYP ELSE
        IF A=INTS THEN
          IF B=INTS THEN RESULTTYPE := INTS ELSE
            BEGIN RESULTTYPE := REALS; EMIT1(26,1)
            END
        ELSE
          BEGIN RESULTTYPE := REALS;
            IF B=INTS THEN EMIT1(26,0)
          END
      END (*RESULTTYPE*) ;

      PROCEDURE EXPRESSION;
        VAR Y:ITEM; OP:SYMBOL;

        PROCEDURE SIMPLEEXPRESSION(FSYS:SYMSET; VAR X:ITEM);
          VAR Y:ITEM; OP:SYMBOL;

          PROCEDURE TERM(FSYS:SYMSET; VAR X:ITEM);
            VAR Y:ITEM; OP:SYMBOL;

            PROCEDURE FACTOR(FSYS:SYMSET; VAR X:ITEM);
              VAR I,F: INTEGER;

              PROCEDURE STANDFCT(N: INTEGER);
                 VAR TS: TYPSET;
              BEGIN (*STANDARD FUNCTION NO. N*)
                IF SY = LPARENT THEN INSYMBOL ELSE ERROR(9);
                IF N < 17 THEN
                  BEGIN EXPRESSION(FSYS+[RPARENT],X);
                    CASE N OF
(*ABS,SQR*)      0,2:  BEGIN TS := [INTS,REALS]; TAB[I].TYP := X.TYP;
                         IF X.TYP = REALS THEN N := N+1
                       END ;
(*ODD,CHR*)      4,5:  TS := [INTS];
(*ORD*)          6: BEGIN
            IF X.TYP = INTS THEN N := 19;
            TS := [INTS,BOOLS,CHARS];
         END;
(*SUCC,PRED*)    7,8:  TS := [CHARS];
(*ROUND,TRUNC*)  9,10,11,12,13,14,15,16:
(*SIN,COS,...*)        BEGIN TS := [INTS,REALS];
                         IF X.TYP = INTS THEN EMIT1(26,0)
                       END ;
                    END ;
                    IF X.TYP IN TS THEN EMIT1(8,N) ELSE
                    IF X.TYP <> NOTYP THEN ERROR(48);
                  END ELSE
(*EOF,EOLN*)      BEGIN (*N IN [17,18]*)
                    IF SY <> IDENT THEN ERROR(2) ELSE
                    IF ID <> 'INPUT     ' THEN ERROR(0) ELSE INSYMBOL;
                    EMIT1(8,N);
                  END ;
                X.TYP := TAB[I].TYP;
                IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
              END (*STANDFCT*) ;

            BEGIN (*FACTOR*) X.TYP := NOTYP; X.REF := 0;
              TEST(FACBEGSYS, FSYS, 58);
              WHILE SY IN FACBEGSYS DO
                BEGIN
                  IF SY = IDENT THEN
                  BEGIN I := LOC(ID); INSYMBOL;
                    WITH TAB[I] DO
                    CASE OBJ OF
              KONSTANT: BEGIN X.TYP := TYP; X.REF := 0;
         CASE X.TYP OF
            INTS: EMIT1(24,ADR);
            REALS: EMIT1(25,ADR);
            BOOLS: EMIT1(64,ADR);
            CHARS: EMIT1(65,ADR);
         END;
                        END ;
              VARIABLE: BEGIN X.TYP := TYP; X.REF := REF;
                          IF SY IN [LBRACK,LPARENT,PERIOD] THEN
                            BEGIN IF NORMAL THEN F := 0 ELSE F := 1;
                              EMIT2(F, LEV, ADR);
                              SELECTOR(FSYS,X);
                              IF X.TYP IN STANTYPS THEN EMIT(34)
                            END ELSE
                            BEGIN
                              IF X.TYP IN STANTYPS THEN
                                IF NORMAL THEN F := 1 ELSE F := 2
                              ELSE
                                IF NORMAL THEN F := 0 ELSE F := 1;
                              EMIT2(F, LEV, ADR)
                            END
                        END ;
              TYPE1, PROZEDURE:    ERROR(44);
              FUNKTION :BEGIN X.TYP := TYP;
                          IF LEV <> 0 THEN CALL(FSYS, I)
                                ELSE STANDFCT(ADR)
                        END
                    END (*CASE,WITH*)
                  END ELSE
                  IF SY IN [CHARCON,INTCON,REALCON] THEN
                   BEGIN
                     IF SY = REALCON THEN
                     BEGIN X.TYP := REALS; ENTERREAL(RNUM);
                       EMIT1(25, C1)
                     END ELSE
         BEGIN
         IF SY = CHARCON THEN BEGIN
            X.TYP := CHARS;
            EMIT1(65, INUM);
         END ELSE BEGIN
            X.TYP := INTS;
            EMIT1(24, INUM);
         END;
                     END ;
                     X.REF := 0; INSYMBOL
                   END ELSE
                  IF SY = LPARENT THEN
                   BEGIN INSYMBOL; EXPRESSION(FSYS+[RPARENT], X);
                     IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
                   END ELSE
                  IF SY = NOTSY THEN
                   BEGIN INSYMBOL; FACTOR(FSYS,X);
                     IF X.TYP=BOOLS THEN EMIT(35) ELSE
                       IF X.TYP<>NOTYP THEN ERROR(32)
                   END ;
                  TEST(FSYS, FACBEGSYS, 6)
                END (*WHILE*)
            END (*FACTOR*) ;

          BEGIN (*TERM*)
            FACTOR(FSYS+[TIMES,RDIV,IDIV,IMOD,ANDSY], X);
            WHILE SY IN [TIMES,RDIV,IDIV,IMOD,ANDSY] DO
              BEGIN OP := SY; INSYMBOL;
                FACTOR(FSYS+[TIMES,RDIV,IDIV,IMOD,ANDSY], Y);
                IF OP = TIMES THEN
                BEGIN X.TYP := RESULTTYPE(X.TYP, Y.TYP);
                  CASE X.TYP OF
                    NOTYP: ;
                    INTS : EMIT(57);
                    REALS: EMIT(60);
                  END
                END ELSE
                IF OP = RDIV THEN
                BEGIN
                  IF X.TYP = INTS THEN
                    BEGIN EMIT1(26,1); X.TYP := REALS
                    END ;
                  IF Y.TYP = INTS THEN
                    BEGIN EMIT1(26,0); Y.TYP := REALS
                    END ;
                  IF (X.TYP=REALS) AND (Y.TYP=REALS) THEN EMIT(61) ELSE
                    BEGIN IF (X.TYP<>NOTYP) AND (Y.TYP<>NOTYP) THEN
                            ERROR(33);
                          X.TYP := NOTYP
                    END
                END ELSE
                IF OP = ANDSY THEN
                BEGIN IF (X.TYP=BOOLS) AND (Y.TYP=BOOLS) THEN
                         EMIT(56) ELSE
                      BEGIN IF (X.TYP<>NOTYP) AND (Y.TYP<>NOTYP) THEN
                               ERROR(32);
                         X.TYP := NOTYP
                      END
                END ELSE
                BEGIN (*OP IN [IDIV,IMOD]*)
                  IF (X.TYP=INTS) AND (Y.TYP=INTS) THEN
                    IF OP=IDIV THEN EMIT(58)
                               ELSE EMIT(59) ELSE
                    BEGIN IF (X.TYP<>NOTYP) AND (Y.TYP<>NOTYP) THEN
                             ERROR(34);
                          X.TYP := NOTYP
                    END
                END
              END
          END (*TERM*) ;

        BEGIN (*SIMPLEEXPRESSION*)
          IF SY IN [PLUS,MINUS] THEN
            BEGIN OP := SY; INSYMBOL;
              TERM(FSYS+[PLUS,MINUS], X);
              IF X.TYP > REALS THEN ERROR(33) ELSE
                IF OP = MINUS THEN
         IF X.TYP = REALS THEN
            EMIT(66)
         ELSE
            EMIT(36)
            END ELSE
          TERM(FSYS+[PLUS,MINUS,ORSY], X);
          WHILE SY IN [PLUS,MINUS,ORSY] DO
            BEGIN OP := SY; INSYMBOL;
               TERM(FSYS+[PLUS,MINUS,ORSY], Y);
               IF OP = ORSY THEN
               BEGIN
                 IF (X.TYP=BOOLS) AND (Y.TYP=BOOLS) THEN EMIT(51) ELSE
                   BEGIN IF (X.TYP<>NOTYP) AND (Y.TYP<>NOTYP) THEN
                            ERROR(32);
                         X.TYP := NOTYP
                   END
               END ELSE
               BEGIN X.TYP := RESULTTYPE(X.TYP, Y.TYP);
                 CASE X.TYP OF
                   NOTYP: ;
                   INTS : IF OP = PLUS THEN EMIT(52)
                                   ELSE EMIT(53);
                   REALS: IF OP = PLUS THEN EMIT(54)
                                   ELSE EMIT(55)
                 END
               END
            END
        END (*SIMPLEEXPRESSION*) ;

      BEGIN (*EXPRESSION*)
        SIMPLEEXPRESSION(FSYS+[EQL,NEQ,LSS,LEQ,GTR,GEQ], X);
        IF SY IN [EQL,NEQ,LSS,LEQ,GTR,GEQ] THEN
          BEGIN OP := SY; INSYMBOL;
             SIMPLEEXPRESSION(FSYS, Y);
             IF (X.TYP IN [ NOTYP,INTS,BOOLS,CHARS]) AND (X.TYP = Y.TYP) THEN
               CASE OP OF
                 EQL: EMIT(45);
                 NEQ: EMIT(46);
                 LSS: EMIT(47);
                 LEQ: EMIT(48);
                 GTR: EMIT(49);
                 GEQ: EMIT(50);
               END ELSE
             BEGIN IF X.TYP = INTS THEN
                     BEGIN X.TYP := REALS; EMIT1(26,1)
                     END ELSE
                   IF Y.TYP = INTS THEN
                     BEGIN Y.TYP := REALS; EMIT1(26,0)
                     END ;
               IF (X.TYP=REALS) AND (Y.TYP=REALS) THEN
                 CASE OP OF
                   EQL: EMIT(39);
                   NEQ: EMIT(40);
                   LSS: EMIT(41);
                   LEQ: EMIT(42);
                   GTR: EMIT(43);
                   GEQ: EMIT(44);
                 END
               ELSE ERROR(35)
             END ;
             X.TYP := BOOLS
          END
      END (*EXPRESSION*) ;

      PROCEDURE ASSIGNMENT(LV,AD: INTEGER);
         VAR X,Y: ITEM; F: INTEGER;
         (*TAB[I].OBJ IN [VARIABLE,PROZEDURE]*)
      BEGIN X.TYP := TAB[I].TYP; X.REF := TAB[I].REF;
        IF TAB[I].NORMAL THEN F := 0 ELSE F := 1;
        EMIT2(F, LV, AD);
        IF SY IN [LBRACK,LPARENT,PERIOD] THEN
           SELECTOR([BECOMES,EQL]+FSYS, X);
        IF SY = BECOMES THEN INSYMBOL ELSE
          BEGIN ERROR(51); IF SY = EQL THEN INSYMBOL
          END ;
        EXPRESSION(FSYS, Y);
        IF X.TYP = Y.TYP THEN
          IF X.TYP IN STANTYPS THEN EMIT(38) ELSE
          IF X.REF <> Y.REF THEN ERROR(46) ELSE
          IF X.TYP = ARRAYS THEN EMIT1(23, ATAB[X.REF].SIZE)
                            ELSE EMIT1(23, BTAB[X.REF].VSIZE)
        ELSE
        IF (X.TYP=REALS) AND (Y.TYP=INTS) THEN
          BEGIN EMIT1(26,0); EMIT(38)
          END ELSE
          IF (X.TYP<>NOTYP) AND (Y.TYP<>NOTYP) THEN ERROR(46)
      END (*ASSIGNMENT*) ;

      PROCEDURE COMPOUNDSTATEMENT;
      BEGIN INSYMBOL;
        STATEMENT([SEMICOLON,ENDSY]+FSYS);
        WHILE SY IN [SEMICOLON]+STATBEGSYS DO
        BEGIN IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
          STATEMENT([SEMICOLON,ENDSY]+FSYS)
        END ;
        IF SY = ENDSY THEN INSYMBOL ELSE ERROR(57)
      END (*COMPOUNDSTATEMENET*) ;

      PROCEDURE IFSTATEMENT;
         VAR X: ITEM; LC1,LC2: INTEGER;
      BEGIN INSYMBOL;
        EXPRESSION(FSYS+[THENSY,DOSY], X);
        IF NOT (X.TYP IN [BOOLS,NOTYP]) THEN ERROR(17);
        LC1 := LC; EMIT(11);  (*JMPC*)
        IF SY = THENSY THEN INSYMBOL ELSE
          BEGIN ERROR(52); IF SY = DOSY THEN INSYMBOL
          END ;
        STATEMENT(FSYS+[ELSESY]);
        IF SY = ELSESY THEN
          BEGIN INSYMBOL; LC2 := LC; EMIT(10);
            CODE[LC1].Y := LC; STATEMENT(FSYS); CODE[LC2].Y := LC
          END
        ELSE CODE[LC1].Y := LC
      END (*IFSTATEMENT*) ;

      PROCEDURE CASESTATEMENT;
        VAR X: ITEM;
            I,J,K,LC1: INTEGER;
            CASETAB: ARRAY [1..CSMAX] OF
                       PACKED RECORD VAL, LC: INDEX END ;
            EXITTAB: ARRAY [1..CSMAX] OF INTEGER;

        PROCEDURE CASELABEL;
          VAR LAB: CONREC; K: INTEGER;
        BEGIN CONSTANT(FSYS+[COMMA,COLON], LAB);
          IF LAB.TP <> X.TYP THEN ERROR(47) ELSE
          IF I = CSMAX THEN FATAL(6) ELSE
            BEGIN I := I+1; K := 0;
              CASETAB[I].VAL := LAB.I; CASETAB[I].LC := LC;
              REPEAT K := K+1 UNTIL CASETAB[K].VAL = LAB.I;
              IF K < I THEN ERROR(1);   (*MULTIPLE DEFINITION*)
            END
        END (*CASELABEL*) ;

        PROCEDURE ONECASE;
        BEGIN IF SY IN CONSTBEGSYS THEN
          BEGIN CASELABEL;
            WHILE SY = COMMA DO
              BEGIN INSYMBOL; CASELABEL
              END ;
            IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
            STATEMENT([SEMICOLON,ENDSY]+FSYS);
            J := J+1; EXITTAB[J] := LC; EMIT(10)
          END
        END (*ONECASE*) ;

      BEGIN INSYMBOL; I := 0; J := 0;
        EXPRESSION(FSYS+[OFSY,COMMA,COLON], X);
        IF NOT (X.TYP IN [INTS,BOOLS,CHARS,NOTYP]) THEN ERROR(23);
        LC1 := LC; EMIT(12);  (*JMPX*)
        IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
        ONECASE;
        WHILE SY = SEMICOLON DO
          BEGIN INSYMBOL; ONECASE
          END ;
        CODE[LC1].Y := LC;
        FOR K := 1 TO I DO
          BEGIN EMIT1(13,CASETAB[K].VAL); EMIT1(13,CASETAB[K].LC)
          END ;
        EMIT1(10,0);
        FOR K := 1 TO J DO CODE[EXITTAB[K]].Y := LC;
        IF SY = ENDSY THEN INSYMBOL ELSE ERROR(57)
      END (*CASESTATEMENT*) ;

      PROCEDURE REPEATSTATEMENT;
         VAR X: ITEM; LC1: INTEGER;
      BEGIN LC1 := LC;
        INSYMBOL; STATEMENT([SEMICOLON,UNTILSY]+FSYS);
        WHILE SY IN [SEMICOLON]+STATBEGSYS DO
        BEGIN IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
          STATEMENT([SEMICOLON,UNTILSY]+FSYS)
        END ;
        IF SY = UNTILSY THEN
          BEGIN INSYMBOL; EXPRESSION(FSYS, X);
            IF NOT (X.TYP IN [BOOLS,NOTYP]) THEN ERROR(17);
            EMIT1(11,LC1)
          END
        ELSE ERROR(53)
      END (*REPEATSTATEMENT*) ;

      PROCEDURE WHILESTATEMENT;
         VAR X: ITEM; LC1,LC2: INTEGER;
      BEGIN INSYMBOL; LC1 := LC;
        EXPRESSION(FSYS+[DOSY], X);
        IF NOT (X.TYP IN [BOOLS,NOTYP]) THEN ERROR(17);
        LC2 := LC; EMIT(11);
        IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
        STATEMENT(FSYS); EMIT1(10,LC1); CODE[LC2].Y := LC
      END (*WHILESTATEMENT*) ;

      PROCEDURE FORSTATEMENT;
         VAR CVT: TYPES; X: ITEM;
             I,F,LC1,LC2: INTEGER;
      BEGIN INSYMBOL;
        IF SY = IDENT THEN
          BEGIN I := LOC(ID); INSYMBOL;
            IF I = 0 THEN CVT := INTS ELSE
            IF TAB[I].OBJ = VARIABLE THEN
              BEGIN CVT := TAB[I].TYP;
                IF NOT TAB[I].NORMAL THEN ERROR(37) ELSE
                  EMIT2(0, TAB[I].LEV, TAB[I].ADR);
                IF NOT (CVT IN [NOTYP,INTS,BOOLS,CHARS]) THEN ERROR(18)
              END ELSE
              BEGIN ERROR(37); CVT := INTS
              END
          END ELSE SKIP([BECOMES,TOSY,DOWNTOSY,DOSY]+FSYS, 2);
        IF SY = BECOMES THEN
          BEGIN INSYMBOL; EXPRESSION([TOSY,DOWNTOSY,DOSY]+FSYS, X);
            IF X.TYP <> CVT THEN ERROR(19);
          END ELSE SKIP([TOSY,DOWNTOSY,DOSY]+FSYS, 51);
        F := 14;
        IF SY IN [TOSY, DOWNTOSY] THEN
          BEGIN IF SY = DOWNTOSY THEN F := 16;
            INSYMBOL; EXPRESSION([DOSY]+FSYS, X);
            IF X.TYP <> CVT THEN ERROR(19)
          END ELSE SKIP([DOSY]+FSYS, 55);
        LC1 := LC; EMIT(F);
        IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
        LC2 := LC; STATEMENT(FSYS);
        EMIT1(F+1,LC2); CODE[LC1].Y := LC
      END (*FORSTATEMENT*) ;

      PROCEDURE STANDPROC(N: INTEGER);
         VAR I,F: INTEGER;
             X,Y: ITEM;
      BEGIN
        CASE N OF
   1,2: BEGIN (*READ*)
          IF NOT IFLAG THEN
            BEGIN ERROR(20); IFLAG := TRUE
            END ;
          IF SY = LPARENT THEN
          BEGIN
            REPEAT INSYMBOL;
              IF SY <> IDENT THEN ERROR(2) ELSE
              BEGIN I := LOC(ID); INSYMBOL;
                IF I <> 0 THEN
                IF TAB[I].OBJ <> VARIABLE THEN ERROR(37) ELSE
                BEGIN X.TYP := TAB[I].TYP; X.REF := TAB[I].REF;
                  IF TAB[I].NORMAL THEN F := 0 ELSE F := 1;
                  EMIT2(F, TAB[I].LEV, TAB[I].ADR);
                  IF SY IN [LBRACK,LPARENT,PERIOD] THEN
                    SELECTOR(FSYS+[COMMA,RPARENT], X);
                  IF X.TYP IN [INTS,REALS,CHARS,NOTYP] THEN
                    EMIT1(27, ORD(X.TYP)) ELSE ERROR(40)
                END
              END ;
              TEST([COMMA,RPARENT], FSYS, 6);
            UNTIL SY <> COMMA;
            IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
          END ;
          IF N = 2 THEN EMIT(62)
        END ;
   3,4: BEGIN (*WRITE*)
          IF SY = LPARENT THEN
          BEGIN
            REPEAT INSYMBOL;
              IF SY = STRING THEN
                BEGIN EMIT1(24,SLENG); EMIT1(28,INUM); INSYMBOL
                END ELSE
              BEGIN EXPRESSION(FSYS+[COMMA,COLON,RPARENT], X);
                IF NOT (X.TYP IN STANTYPS) THEN ERROR(41);
                IF SY = COLON THEN
                BEGIN INSYMBOL;
                  EXPRESSION(FSYS+[COMMA,COLON,RPARENT], Y);
                  IF Y.TYP <> INTS THEN ERROR(43);
                  IF SY = COLON THEN
                  BEGIN IF X.TYP <> REALS THEN ERROR(42);
                    INSYMBOL; EXPRESSION(FSYS+[COMMA,RPARENT], Y);
                    IF Y.TYP <> INTS THEN ERROR(43);
                    EMIT(37)
                  END
                  ELSE EMIT1(30, ORD(X.TYP))
                END
                ELSE EMIT1(29, ORD(X.TYP))
              END
            UNTIL SY <> COMMA;
            IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
          END ;
          IF N = 4 THEN EMIT(63)
        END ;
        END (*CASE*)
      END (*STANDPROC*) ;

    BEGIN (*STATEMENT*)
      IF SY IN STATBEGSYS+[IDENT] THEN
          CASE SY OF
            IDENT:    BEGIN I := LOC(ID); INSYMBOL;
                        IF I <> 0 THEN
                        CASE TAB[I].OBJ OF
                          KONSTANT, TYPE1: ERROR(45);
                          VARIABLE: ASSIGNMENT(TAB[I].LEV, TAB[I].ADR);
                          PROZEDURE:
                            IF TAB[I].LEV <> 0 THEN CALL(FSYS, I)
                                    ELSE STANDPROC(TAB[I].ADR);
                          FUNKTION:
                            IF TAB[I].REF = DISPLAY[LEVEL] THEN
                              ASSIGNMENT(TAB[I].LEV+1, 0) ELSE ERROR(45)
                        END
                      END ;
            BEGINSY:  COMPOUNDSTATEMENT;
            IFSY:     IFSTATEMENT;
            CASESY:   CASESTATEMENT;
            WHILESY:  WHILESTATEMENT;
            REPEATSY: REPEATSTATEMENT;
            FORSY:    FORSTATEMENT;
          END;
        TEST(FSYS, [], 14)
    END (*STATEMENT*) ;

BEGIN (*BLOCK*) DX := 5; PRT := T;
  IF LEVEL > LMAX THEN FATAL(5);
  TEST([LPARENT,COLON,SEMICOLON], FSYS, 7);
  ENTERBLOCK; DISPLAY[LEVEL] := B; PRB := B;
  TAB[PRT].TYP := NOTYP; TAB[PRT].REF := PRB;
  IF SY = LPARENT THEN PARAMETERLIST;
  BTAB[PRB].LASTPAR := T; BTAB[PRB].PSIZE := DX;
  IF ISFUN THEN
    IF SY = COLON THEN
    BEGIN INSYMBOL;   (*FUNCTION TYPE*)
      IF SY = IDENT THEN
      BEGIN X := LOC(ID); INSYMBOL;
        IF X <> 0 THEN
          IF TAB[X].OBJ <> TYPE1 THEN ERROR(29) ELSE
            IF TAB[X].TYP IN STANTYPS THEN TAB[PRT].TYP := TAB[X].TYP
              ELSE ERROR(15)
      END ELSE SKIP([SEMICOLON]+FSYS, 2)
    END ELSE ERROR(5);
  IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
  REPEAT
    IF SY = CONSTSY THEN CONSDECLARATION;
    IF SY = TYPESY THEN TYPEDECLARATION;
    IF SY = VARSY THEN VARDECLARATION;
    BTAB[PRB].VSIZE := DX;
    WHILE SY IN [PROCSY,FUNCSY] DO PROCDECLARATION;
    TEST([BEGINSY], BLOCKBEGSYS+STATBEGSYS, 56)
  UNTIL SY IN STATBEGSYS;
  TAB[PRT].ADR := LC;
  INSYMBOL; STATEMENT([SEMICOLON,ENDSY]+FSYS);
  WHILE SY IN [SEMICOLON]+STATBEGSYS DO
    BEGIN IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
      STATEMENT([SEMICOLON,ENDSY]+FSYS)
    END ;
  IF SY = ENDSY THEN INSYMBOL ELSE ERROR(57);
  TEST(FSYS+[PERIOD], [], 6)
END (*BLOCK*) ;

(* EOF                                                                        *)
(* #INCLUDE "INTERPRET.I"                                                     *)
(* INTERPRET.I                                                                *)
PROCEDURE INTERPRET;
  (*GLOBAL CODE, TAB, BTAB*)
  VAR IR: ORDER;      (*INSTRUCTION BUFFER*)
      PC: INTEGER;    (*PROGRAM COUNTER*)
      PS: (RUN,FIN,CASCHK,DIVCHK,INXCHK,STKCHK,LINCHK,LNGCHK,REDCHK);
      T:  INTEGER;    (*TOP STACK INDEX*)
      B:  INTEGER;    (*BASE INDEX*)
      LNCNT, OCNT, BLKCNT, CHRCNT: INTEGER;     (*COUNTERS*)
      H1,H2,H3,H4: INTEGER;
      FLD: ARRAY [1..4] OF INTEGER;     (*DEFAULT FIELD WIDTHS*)

      DISPLAY: ARRAY [1..LMAX] OF INTEGER;
      S: ARRAY [1..STACKSIZE] OF          (*BLOCKMARK:              *)
         RECORD CASE TYPES OF             (*   S[B+0] = FCT RESULT  *)
           INTS:  (I: INTEGER);           (*   S[B+1] = RETURN ADR  *)
           REALS: (R: REAL);              (*   S[B+2] = STATIC LINK *)
           BOOLS: (B: BOOLEAN);           (*   S[B+3] = DYNAMIC LINK*)
           CHARS: (C: CHAR)               (*   S[B+4] = TABLE INDEX *)
         END ;

BEGIN (*INTERPRET*)
  S[1].I := 0; S[2].I := 0; S[3].I := -1; S[4].I := BTAB[1].LAST;
  B := 0; DISPLAY[1] := 0;
  T := BTAB[2].VSIZE - 1; PC := TAB[S[4].I].ADR;
  PS := RUN;
  LNCNT := 0; OCNT := 0; CHRCNT := 0;
  FLD[1] := 10; FLD[2] := 22; FLD[3] := 10; FLD[4] := 1;
  REPEAT IR := CODE[PC]; PC := PC+1; OCNT := OCNT + 1;
    CASE IR.F OF
  0: BEGIN (*LOAD ADDRESS*) T := T+1;
       IF T > STACKSIZE THEN PS := STKCHK
         ELSE S[T].I := DISPLAY[IR.X] + IR.Y
     END ;
  1: BEGIN (*LOAD VALUE*) T := T+1;
       IF T > STACKSIZE THEN PS := STKCHK
         ELSE S[T] := S[DISPLAY[IR.X] + IR.Y]
     END ;
  2: BEGIN (*LOAD INDIRECT*) T := T+1;
       IF T > STACKSIZE THEN PS := STKCHK
         ELSE S[T] := S[S[DISPLAY[IR.X] + IR.Y].I]
     END ;
  3: BEGIN (*UPDATE DISPLAY*)
       H1 := IR.Y; H2 := IR.X; H3 := B;
       REPEAT DISPLAY[H1] := H3; H1 := H1-1; H3 := S[H3+2].I
       UNTIL H1 = H2
     END ;
  8: CASE IR.Y OF
      0: S[T].I := ABS(S[T].I);
      1: S[T].R := ABS(S[T].R);
#     2: S[T].I := S[T].I*S[T].I (*SQR(S[T].I)*);
      3: S[T].R := S[T].R*S[T].R (*SQR(S[T].R)*);
      4: S[T].B := ODD(S[T].I);
      5: BEGIN
           IF (S[T].I < 0) OR (S[T].I > 127) THEN PS := INXCHK
   ELSE S[T].C := CHR(S[T].I)
         END ;
      6: S[T].I := ORD(S[T].C) ;
      7: S[T].C := SUCC(S[T].C);
      8: S[T].C := PRED(S[T].C);
##  (*9: S[T].I := ROUND(S[T].R);*)
     10: S[T].I := TRUNC(S[T].R);
     11: S[T].R := SIN(S[T].R);
     12: S[T].R := COS(S[T].R);
     13: S[T].R := EXP(S[T].R);
     14: S[T].R := LN(S[T].R);
     15: S[T].R := SQRT(S[T].R);
     16: S[T].R := ARCTAN(S[T].R);
     17: BEGIN T := T+1;
           IF T > STACKSIZE THEN PS := STKCHK ELSE S[T].B := EOF(INPUT)
         END ;
     18: BEGIN T := T+1;
           IF T > STACKSIZE THEN PS := STKCHK ELSE S[T].B := EOLN(INPUT)
         END ;
     19:
     END ;
  9: S[T].I := S[T].I + IR.Y;   (*OFFSET*)
 10: PC := IR.Y;  (*JUMP*)
 11: BEGIN (*CONDITIONAL JUMP*)
       IF NOT S[T].B THEN PC := IR.Y;  T := T-1
     END ;
 12: BEGIN (*SWITCH*) H1 := S[T].I; T := T-1;
       H2 := IR.Y; H3 := 0;
       REPEAT IF CODE[H2].F <> 13 THEN
                BEGIN H3 := 1; PS := CASCHK
                END ELSE
              IF CODE[H2].Y = H1 THEN
                BEGIN H3 := 1; PC := CODE[H2+1].Y
                END ELSE
              H2 := H2 + 2
       UNTIL H3 <> 0
     END ;
 14: BEGIN (*FOR1UP*) H1 := S[T-1].I;
       IF H1 <= S[T].I THEN S[S[T-2].I].I := H1 ELSE
          BEGIN T := T-3; PC := IR.Y
          END
     END ;
 15: BEGIN (*FOR2UP*) H2 := S[T-2].I; H1 := S[H2].I + 1;
       IF H1 <= S[T].I THEN
         BEGIN S[H2].I := H1; PC := IR.Y END
       ELSE T := T-3;
     END ;
 16: BEGIN (*FOR1DOWN*) H1 := S[T-1].I;
       IF H1 >= S[T].I THEN S[S[T-2].I].I := H1 ELSE
          BEGIN PC := IR.Y; T := T-3
          END
     END ;
 17: BEGIN (*FOR2DOWN*) H2 := S[T-2].I; H1 := S[H2].I - 1;
       IF H1 >= S[T].I THEN
         BEGIN S[H2].I := H1; PC := IR.Y END
       ELSE T := T-3;
     END ;
 18: BEGIN (*MARK STACK*)  H1 := BTAB[TAB[IR.Y].REF].VSIZE;
       IF T+H1 > STACKSIZE THEN PS := STKCHK ELSE
         BEGIN T := T+5; S[T-1].I := H1-1; S[T].I := IR.Y
         END
     END ;
 19: BEGIN (*CALL*) H1 := T - IR.Y;  (*H1 POINTS TO BASE*)
       H2 := S[H1+4].I;            (*H2 POINTS TO TAB*)
       H3 := TAB[H2].LEV; DISPLAY[H3+1] := H1;
       H4 := S[H1+3].I + H1;
       S[H1+1].I := PC; S[H1+2].I := DISPLAY[H3]; S[H1+3].I := B;
       FOR H3 := T+1 TO H4 DO S[H3].I := 0;
       B := H1; T := H4; PC := TAB[H2].ADR
     END ;
 20: BEGIN (*INDEX1*) H1 := IR.Y;      (*H1 POINTS TO ATAB*)
       H2 := ATAB[H1].LOW; H3 := S[T].I;
       IF H3 < H2 THEN PS := INXCHK ELSE
       IF H3 > ATAB[H1].HIGH THEN PS := INXCHK ELSE
         BEGIN T := T-1; S[T].I := S[T].I + (H3-H2)
         END
     END ;
 21: BEGIN (*INDEX*)  H1 := IR.Y;      (*H1 POINTS TO ATAB*)
       H2 := ATAB[H1].LOW; H3 := S[T].I;
       IF H3 < H2 THEN PS := INXCHK ELSE
       IF H3 > ATAB[H1].HIGH THEN PS := INXCHK ELSE
         BEGIN T := T-1; S[T].I := S[T].I + (H3-H2)*ATAB[H1].ELSIZE
         END
     END ;
 22: BEGIN (*LOAD BLOCK*) H1 := S[T].I; T := T-1;
       H2 := IR.Y + T; IF H2 > STACKSIZE THEN PS := STKCHK ELSE
       WHILE T < H2 DO
         BEGIN T := T+1; S[T] := S[H1]; H1 := H1+1
         END
     END ;
 23: BEGIN (*COPY BLOCK*) H1 := S[T-1].I;
       H2 := S[T].I; H3 := H1 + IR.Y;
       WHILE H1 < H3 DO
         BEGIN S[H1] := S[H2]; H1 := H1+1; H2 := H2+1
         END ;
       T := T-2
     END ;
 24: BEGIN (*LITERAL*) T := T+1;
       IF T > STACKSIZE THEN PS := STKCHK ELSE S[T].I := IR.Y
     END ;
 25: BEGIN (*LOAD REAL*) T := T+1;
       IF T > STACKSIZE THEN PS := STKCHK ELSE S[T].R := RCONST[IR.Y]
     END ;
  64,65: BEGIN T := T + 1; IF T > STACKSIZE THEN PS := STKCHK
   ELSE S[T].C := CHR(IR.Y) END;
 26: BEGIN (*FLOAT*) H1 := T - IR.Y; S[H1].R := S[H1].I
     END ;
 27: BEGIN (*READ*)
       IF EOF(INPUT) THEN PS := REDCHK ELSE
          CASE IR.Y OF
           1: READ(S[S[T].I].I);
           2: READ(S[S[T].I].R);
           4: READ(S[S[T].I].C);
          END ;
       T := T-1
     END ;
 28: BEGIN (*WRITE STRING*)
       H1 := S[T].I; H2 := IR.Y; T := T-1;
       CHRCNT := CHRCNT+H1; IF CHRCNT > LINELENG THEN PS := LNGCHK;
       REPEAT WRITE(STAB[H2]); H1 := H1-1; H2 := H2+1
       UNTIL H1 = 0
     END ;
 29: BEGIN (*WRIT1*)
       CHRCNT := CHRCNT + FLD[IR.Y];
       IF CHRCNT > LINELENG THEN PS := LNGCHK ELSE
       CASE IR.Y OF
        1: WRITE(S[T].I: FLD[1]);
        2: WRITE(S[T].R: FLD[2]);
        3: WRITE(S[T].B: FLD[3]);
   4: WRITE(S[T].C);
       END ;
       T := T-1
     END ;
 30: BEGIN (*WRITE2*)
       CHRCNT := CHRCNT + S[T].I;
       IF CHRCNT > LINELENG THEN PS := LNGCHK ELSE
       CASE IR.Y OF
        1: WRITE(S[T-1].I: S[T].I);
        2: WRITE(S[T-1].R: S[T].I);
        3: WRITE(S[T-1].B: S[T].I);
        4: WRITE(S[T-1].C: S[T].I);
       END ;
       T := T-2
     END ;
 31: PS := FIN;
 32: BEGIN (*EXIT PROCEDURE*)
       T := B-1; PC := S[B+1].I; B := S[B+3].I
     END ;
 33: BEGIN (*EXIT FUNCTION*)
       T := B; PC := S[B+1].I; B := S[B+3].I
     END ;
 34: S[T] := S[S[T].I];
 35: S[T].B := NOT S[T].B;
 36: S[T].I := - S[T].I;
 66: S[T].R := - S[T].R;
 37: BEGIN CHRCNT := CHRCNT + S[T-1].I;
       IF CHRCNT > LINELENG THEN PS := LNGCHK ELSE
##        WRITE(S[T-2].R: S[T-1].I ": S[T].I");
       T := T-3
     END ;
 38: BEGIN (*STORE*) S[S[T-1].I] := S[T]; T := T-2
     END ;
 39: BEGIN T := T-1; S[T].B := S[T].R = S[T+1].R
     END ;
 40: BEGIN T := T-1; S[T].B := S[T].R <> S[T+1].R
     END ;
 41: BEGIN T := T-1; S[T].B := S[T].R < S[T+1].R
     END ;
 42: BEGIN T := T-1; S[T].B := S[T].R <= S[T+1].R
     END ;
 43: BEGIN T := T-1; S[T].B := S[T].R > S[T+1].R
     END ;
 44: BEGIN T := T-1; S[T].B := S[T].R >= S[T+1].R
     END ;
 45: BEGIN T := T-1; S[T].B := S[T].I = S[T+1].I
     END ;
 46: BEGIN T := T-1; S[T].B := S[T].I <> S[T+1].I
     END ;
 47: BEGIN T := T-1; S[T].B := S[T].I < S[T+1].I
     END ;
 48: BEGIN T := T-1; S[T].B := S[T].I <= S[T+1].I
     END ;
 49: BEGIN T := T-1; S[T].B := S[T].I > S[T+1].I
     END ;
 50: BEGIN T := T-1; S[T].B := S[T].I >= S[T+1].I
     END ;
 51: BEGIN T := T-1; S[T].B := S[T].B OR S[T+1].B
     END ;
 52: BEGIN T := T-1; S[T].I := S[T].I + S[T+1].I
     END ;
 53: BEGIN T := T-1; S[T].I := S[T].I - S[T+1].I
     END ;
 54: BEGIN T := T-1; S[T].R := S[T].R + S[T+1].R;
     END ;
 55: BEGIN T := T-1; S[T].R := S[T].R - S[T+1].R;
     END ;
 56: BEGIN T := T-1; S[T].B := S[T].B AND S[T+1].B
     END ;
 57: BEGIN T := T-1; S[T].I := S[T].I * S[T+1].I
     END ;
 58: BEGIN T := T-1;
       IF S[T+1].I = 0 THEN PS := DIVCHK ELSE
         S[T].I := S[T].I DIV S[T+1].I
     END ;
 59: BEGIN T := T-1;
       IF S[T+1].I = 0 THEN PS := DIVCHK ELSE
         S[T].I := S[T].I MOD S[T+1].I
     END ;
 60: BEGIN T := T-1; S[T].R := S[T].R * S[T+1].R;
     END ;
 61: BEGIN T := T-1;
   IF S[T+1].R = 0.0 THEN PS := DIVCHK ELSE S[T].R := S[T].R / S[T+1].R;
     END ;
 62: IF EOF(INPUT) THEN PS := REDCHK ELSE READLN(INPUT);
 63: BEGIN WRITELN; LNCNT := LNCNT + 1; CHRCNT := 0;
        IF LNCNT > LINELIMIT THEN PS := LINCHK
     END
    END (*CASE*) ;
  UNTIL PS <> RUN;

  IF PS <> FIN THEN
  BEGIN WRITELN;
    WRITE('0HALT AT', PC:5, ' BECAUSE OF ');
    CASE PS OF
      CASCHK: WRITELN('UNDEFINED CASE');
      DIVCHK: WRITELN('DIVISION BY 0');
      INXCHK: WRITELN('INVALID INDEX');
      STKCHK: WRITELN('STORAGE OVERFLOW');
      LINCHK: WRITELN('TOO MUCH OUTPUT');
      LNGCHK: WRITELN('LINE TOO LONG');
      REDCHK: WRITELN('READING PAST END OF FILE');
    END ;
    H1 := B; BLKCNT := 10;   (*POST MORTEM DUMP*)
    REPEAT WRITELN; BLKCNT := BLKCNT - 1;
      IF BLKCNT = 0 THEN H1 := 0; H2 := S[H1+4].I;
      IF H1<>0 THEN
        WRITELN(' ', TAB[H2].NAME, ' CALLED AT', S[H1+1].I: 5);
      H2 := BTAB[TAB[H2].REF].LAST;
      WHILE H2 <> 0 DO
      WITH TAB[H2] DO
      BEGIN IF OBJ = VARIABLE THEN
            IF TYP IN STANTYPS THEN
            BEGIN WRITE('    ', NAME, ' = ');
              IF NORMAL THEN H3 := H1+ADR ELSE H3 := S[H1+ADR].I;
              CASE TYP OF
               INTS:  WRITELN(S[H3].I);
               REALS: WRITELN(S[H3].R);
               BOOLS: WRITELN(S[H3].B);
               CHARS: WRITELN(S[H3].C);
              END
            END ;
            H2 := LINK
      END ;
      H1 := S[H1+3].I
    UNTIL H1 < 0;
  END ;
  WRITELN; WRITELN(OCNT, ' STEPS')
END (*INTERPRET*) ;
(* EOF                                                                        *)

BEGIN WRITELN;
   KEY[ 1] := 'AND       '; KEY[ 2] := 'ARRAY     ';
   KEY[ 3] := 'BEGIN     '; KEY[ 4] := 'CASE      ';
   KEY[ 5] := 'CONST     '; KEY[ 6] := 'DIV       ';
   KEY[ 8] := 'DOWNTO    '; KEY[ 7] := 'DO        ';
   KEY[ 9] := 'ELSE      '; KEY[10] := 'END       ';
   KEY[11] := 'FOR       '; KEY[12] := 'FUNCTION  ';
   KEY[13] := 'IF        '; KEY[14] := 'MOD       ';
   KEY[15] := 'NOT       '; KEY[16] := 'OF        ';
   KEY[17] := 'OR        '; KEY[18] := 'PROCEDURE ';
   KEY[19] := 'PROGRAM   '; KEY[20] := 'RECORD    ';
   KEY[21] := 'REPEAT    '; KEY[22] := 'THEN      ';
   KEY[23] := 'TO        '; KEY[24] := 'TYPE      ';
   KEY[25] := 'UNTIL     '; KEY[26] := 'VAR       ';
   KEY[27] := 'WHILE     ';
   KSY[ 1] := ANDSY;        KSY[ 2] := ARRAYSY;
   KSY[ 3] := BEGINSY;      KSY[ 4] := CASESY;
   KSY[ 5] := CONSTSY;      KSY[ 6] := IDIV;
   KSY[ 8] := DOWNTOSY;     KSY[ 7] := DOSY;
   KSY[ 9] := ELSESY;       KSY[10] := ENDSY;
   KSY[11] := FORSY;        KSY[12] := FUNCSY;
   KSY[13] := IFSY;         KSY[14] := IMOD;
   KSY[15] := NOTSY;        KSY[16] := OFSY;
   KSY[17] := ORSY;         KSY[18] := PROCSY;
   KSY[19] := PROGRAMSY;    KSY[20] := RECORDSY;
   KSY[21] := REPEATSY;     KSY[22] := THENSY;
   KSY[23] := TOSY;         KSY[24] := TYPESY;
   KSY[25] := UNTILSY;      KSY[26] := VARSY;
   KSY[27] := WHILESY;
   SPS['+'] := PLUS;        SPS['-'] := MINUS;
   SPS['*'] := TIMES;       SPS['/'] := RDIV;
   SPS['('] := LPARENT;     SPS[')'] := RPARENT;
   SPS['='] := EQL;         SPS[','] := COMMA;
   SPS['['] := LBRACK;      SPS[']'] := RBRACK;
   SPS['#'] := NEQ;         SPS['&'] := ANDSY;
   SPS[';'] := SEMICOLON;
  CONSTBEGSYS := [PLUS,MINUS,INTCON,REALCON,CHARCON,IDENT];
  TYPEBEGSYS := [IDENT,ARRAYSY,RECORDSY];
  BLOCKBEGSYS := [CONSTSY,TYPESY,VARSY,PROCSY,FUNCSY,BEGINSY];
  FACBEGSYS := [INTCON,REALCON,CHARCON,IDENT,LPARENT,NOTSY];
  STATBEGSYS := [BEGINSY,IFSY,WHILESY,REPEATSY,FORSY,CASESY];
  STANTYPS := [NOTYP,INTS,REALS,BOOLS,CHARS];
  LC := 0; LL := 0; CC := 0; CH := ' ';
  ERRPOS := 0; ERRS := []; INSYMBOL;
  T := -1; A := 0; B := 1; SX := 0; C2 := 0;
  DISPLAY[0] := 1;
  IFLAG := FALSE; OFLAG := FALSE;
  IF SY <> PROGRAMSY THEN ERROR(3) ELSE
  BEGIN INSYMBOL;
    IF SY <> IDENT THEN ERROR(2) ELSE
    BEGIN PROGNAME := ID; INSYMBOL;
      IF SY <> LPARENT THEN ERROR(9) ELSE
      REPEAT INSYMBOL;
   IF SY <> IDENT THEN ERROR(2) ELSE
   BEGIN IF ID = 'INPUT     ' THEN IFLAG := TRUE ELSE
         IF ID = 'OUTPUT    ' THEN OFLAG := TRUE ELSE ERROR(0);
      INSYMBOL
   END
      UNTIL SY <> COMMA;
      IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4);
      IF NOT OFLAG THEN ERROR(20)
    END
  END ;
  ENTER('          ', VARIABLE, NOTYP, 0);  (*SENTINEL*)
  ENTER('FALSE     ', KONSTANT, BOOLS, 0);
  ENTER('TRUE      ', KONSTANT, BOOLS, 1);
  ENTER('REAL      ', TYPE1, REALS, 1);
  ENTER('CHAR      ', TYPE1, CHARS, 1);
  ENTER('BOOLEAN   ', TYPE1, BOOLS, 1);
  ENTER('INTEGER   ', TYPE1, INTS , 1);
  ENTER('ABS       ', FUNKTION, REALS,0);
  ENTER('SQR       ', FUNKTION, REALS,2);
  ENTER('ODD       ', FUNKTION, BOOLS,4);
  ENTER('CHR       ', FUNKTION, CHARS,5);
  ENTER('ORD       ', FUNKTION, INTS, 6);
  ENTER('SUCC      ', FUNKTION, CHARS,7);
  ENTER('PRED      ', FUNKTION, CHARS,8);
  ENTER('ROUND     ', FUNKTION, INTS, 9);
  ENTER('TRUNC     ', FUNKTION, INTS, 10);
  ENTER('SIN       ', FUNKTION, REALS, 11);
  ENTER('COS       ', FUNKTION, REALS, 12);
  ENTER('EXP       ', FUNKTION, REALS, 13);
  ENTER('LN        ', FUNKTION, REALS, 14);
  ENTER('SQRT      ', FUNKTION, REALS, 15);
  ENTER('ARCTAN    ', FUNKTION, REALS, 16);
  ENTER('EOF       ', FUNKTION, BOOLS, 17);
  ENTER('EOLN      ', FUNKTION, BOOLS, 18);
  ENTER('READ      ', PROZEDURE, NOTYP, 1);
  ENTER('READLN    ', PROZEDURE, NOTYP, 2);
  ENTER('WRITE     ', PROZEDURE, NOTYP, 3);
  ENTER('WRITELN   ', PROZEDURE, NOTYP, 4);
  ENTER('          ', PROZEDURE, NOTYP, 0);
  WITH BTAB[1] DO
    BEGIN LAST := T; LASTPAR := 1; PSIZE := 0; VSIZE := 0
    END ;

  BLOCK(BLOCKBEGSYS+STATBEGSYS, FALSE, 1);
  IF SY <> PERIOD THEN ERROR(22);
  EMIT(31);  (*HALT*)
  IF BTAB[2].VSIZE > STACKSIZE THEN ERROR(49);
  IF PROGNAME = 'TEST0     ' THEN PRINTTABLES;

  IF ERRS = [] THEN
  BEGIN
(* { MUST BLOCK ALL OF THIS OUT FOR NOW.                                      *)
    IF IFLAG THEN
##  BEGIN  (* GETSEG(INPUT); *)
      IF EOF(INPUT) THEN WRITELN(' INPUT DATA MISSING') ELSE
      BEGIN WRITELN(' (EOR)'); (*COPY INPUT DATA*)
##(* WHILE NOT EOF(INPUT) DO
## BEGIN WRITE(' ');
##   WHILE NOT EOLN(INPUT) DO
##     BEGIN READ(CH); WRITE(CH)
##     END ;
##   WRITELN; READ(CH)
## END ;
## GETSEG(INPUT,0)  *)
      END
    END ;
(*  ALL THIS BECAUSE OF SEGMENTED FILE REPOSITIONINGÝÝ }                      *)
    WRITELN(' (EOF)');
    INTERPRET
  END
  ELSE ERRORMSG;
99:
END .
(* EOF                                                                        *)
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB QSORT    EXT PAS HEX -
PROGRAM QUICKSORT( OUTPUT ) ;  (*$L+,D- *)

(* PARTITION-XCHANGE SORT, AFTER J. SEDGEWICK,  S. HAZEGHI.

   M ::= SIZE OF THE PARTITIONS TO BE BUBBLE-SORTED
   N ::= NUMBER OF ELEMENTS TO BE SORTED ;
   N1 ::= N+1 ;
   STACK_SIZE ::= MAX # OF UNSORTED PARTITIONS ( >= 2*(LOG(N)-3), LOG IS BASE 2)
*)

LABEL 101,111 ;

CONST   M = 9 ;  N = 40;  N1 = 41 ;STACK_SIZE = 25;

VAR L,R,P,I,J,V,T : INTEGER ;
    STACK : ARRAY [1..STACK_SIZE] OF INTEGER ;
    (* STACK_SIZE  2*(LG(N)-3) *)
    A : ARRAY [1..N1] OF INTEGER ;

PROCEDURE PRINTDATA ;

    (* TO PRINT THE RAW AND SORTED DATA, 10 NUMBERS PER LINE *)

    BEGIN
    FOR I := 1 TO N1 DO
        BEGIN
        IF (I MOD 10) = 1 THEN  WRITELN ;
        WRITE('  ',A[I]:11 ) ;
        END;
    END ;

    BEGIN  (* QUIKSORT *)

    (* I- GENERATE RANDOM DATA FOR SORTING *)

    A[1] := 0; L := 2; R := N1; P := 0;
    FOR I := 1 TO N DO
        BEGIN  A[I+1] := A[I]*314159269+453806245;
        IF A[I+1] < 0 THEN
            BEGIN  A[I+1] := A[I+1]+2147483647 ;
            A[I+1] := A[I+1]+1
            END
        END ;

    PRINTDATA ;

    (* II- PARTITION THE SORT DATA *)

    REPEAT  I := L-1; J := R; V := A[R];
        REPEAT
            REPEAT I := I+1 UNTIL (A[I] >= V) ;
            A[J] := A[I];
            REPEAT J := J-1 UNTIL (A[J] <= V) ;
            IF I >= J THEN GOTO 101 ;
            A[I] := A[J]
        UNTIL  FALSE ;
    101:IF I <> J THEN  J := J+1;
        A[J] := V;
        IF J-L > R-J THEN
            BEGIN
            IF M >= J-L THEN
                BEGIN  IF P = 0 THEN GOTO 111 ;
                R := STACK[P+1];  L := STACK[P];  P := P-2;
                END
            ELSE IF R-J > M THEN
                    BEGIN  P := P+2 ;  STACK[P] := L ;
                    STACK[P+1] := J-1 ;  L := J+1
                    END
                ELSE  R := J-1
            END
        ELSE IF M >= R-J THEN
                BEGIN  IF P = 0 THEN GOTO 111 ;
                R := STACK[P+1];  L := STACK[P];  P := P-2;
                END
            ELSE IF J-L > M  THEN
                    BEGIN  P := P+2 ;  STACK[P] := J+1 ;
                    STACK[P+1] := R ;  R := J-1
                    END
                ELSE  L := J+1
    UNTIL  FALSE ;

    (* III- EXCHANGE SORT EACH PARTITION *)

111:FOR I := 2 TO N1 DO
        IF A[I] < A[I-1] THEN
            BEGIN
            V := A[I] ;  J := I-1 ;
            REPEAT  A[J+1] := A[J];  J := J-1  UNTIL (A[J] <= V) ;
            A[J+1] := V
            END ;

    PRINTDATA ;

    END (* QUIKSORT *).
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB RNF      EXT PAS HEX -
 (*$D-              NO DEBUG *)
 (*$K-              NO EXECUTION PROFILE *)
 (*$F-              DO NOT SAVE FLOATING POINT REGS *)
 (*$Q+              ACCEPT ALL FORMS OF SQUARE BRACKET, (UNL ONLY) *)




(*                                   RNF
     RNF IS A TEXT FORMATTING PROGRAM SIMILAR BUT NOT IDENTICAL TO RUNOFF
 (RUNOFF IS A REGISTERED TRADEMARK OF THE DIGITAL ELECTRONICS CORPORATION).
     RNF WAS ORIGINALLY WRITTEN, IMPLEMENTED AND MAINTAINED BY ROBERT FOSTER
 AND LATER MAINTAINED BY RICHARD CHILAUSKY, BOTH OF THE COMPUTING SERVICES
 OFFICE OF THE UNIVERSITY OF ILLINOIS.
     IT WAS CONVERTED FROM PASCAL 6000 (FOR CDC MACHINES) TO STANFORD
 PASCAL (FOR IBM MACHINES) BY CURT HILL OF UNIVERSITY OF NEBRASKA AT
 LINCOLN. THIS VERSION SHOULD BE PORTABLE TO ANY PASCAL RUNNING ON MACHINES
 THAT USE THE ASCII OR EBCDIC CHARACTER SETS.
     OUR THANKS TO RICHARD CHILAUSKY, FOR HIS HELP IN THE ORIGINAL
 CONVERSION TO STANFORD PASCAL.
     WE APPRECIATE AND ACKNOWLEDGE GEORGE F. BADGER, JR, DIRECTER OF COMPUTING
 SERVICES OFFICE AT THE UNIVERSITY OF ILLINOIS AT URBANA-CHAMPAIGN, FOR
 GRACIOUSLY ALLOWING FREE DISTRIBUTION OF THIS PROGRAM.
      DISTRIBUTION OF THIS PROGRAM IS PRIMARILY TIED TO DISTRIBUTION
  OF THE STANFORD PASCAL COMPILER. REVISIONS (IF ANY SHOULD OCCUR), WILL
  BE DISTRIBUTED IN THE SAME WAY. IF YOU REQUIRE A CDC COMPATIBLE
  IMPLEMENTATION, CONTACT THE OFFICE OF COMPUTER SERVICES, UNIVERSITY OF
  ILLINOIS, URBANA, ILLINOIS. IF YOU DESIRE A COPY OF THIS PROGRAM FOR
  AN IMPLEMENTATION THAT USES THE ASCII OR EBCDIC CHARACTER SET
  THAT IS NOT BASED ON A CDC OR IBM MACHINE THEN CONTACT ME. BUG REPORTS
  AND GENERAL COMMENTS SHOULD BE ADDRESSED TO MYSELF OR SASSAN HAZEGHI,
  WHO WILL RELAY THEM TO ME.
      THERE ARE NO WARRANTIES, EXPRESSED OR IMPLIED, CONCERNING THIS PROGRAM
  BY ANYONE MENTIONED HEREIN.

                                              CURT HILL
                                              225 NEBRASKA HALL
                                              UNIVERSITY OF NEBRASKA - LINCOLN
                                              LINCOLN, NEBRASKA
                                              (402) 472-3701

      IF THE ADDRESS CHANGES, CHECK PASCAL NEWS FOR AN UPDATE.

               *)

 (* CHANGE HISTORY:
    MODIFY     4/21 MAKE LINES <= 72 CHARS SO MODIFY CAN WORK. BF
   NONMP       4/21 SYMPTOM: .NONMP CAUSES PAGES NOT TO BE COUNTED.
               FIX: REWRITE MACRO. BF
   PERIOD      5/12 COMMAND WITH NO PREFIX TURNS OFF PERIOD SPACING.
               FIX: USE TRUE INSTEAD OF YES.BF
   HL          5/12 HL NOT RESET BY .CH. FIX: ADD TO MACRO. BF
   PUSHSYL     4/23 SYMPTOM: USING .AP, A FORCED .PP OR THE ENTIRE
               LINE IT BEGAN SOMETIMES VANISHED.  CAUSE: FORCED
               COMMANDS WERE NOT SAVED PROPERLY OVER FORCED PAGE
               EJECTS.  FIX: SAVE THE PENDING SYMBOL WHEN FORCING;
               FOR THIS SPECIAL CASE, PUSH IT SO WILL COME BACK WHEN
               .FRCPAGE CONCLUDES.  (INTRODUCES ALLOC TO HANDLE
               MACRO FREE LIST, WHICH IS NEEDED FOR FUTURE
               ENHANCEMENTS.) BF
  GETCUR       5/17 RESTRUCTURE CODE TO ALLOW FOR FUTURE ENHANCEMENTS.
               MOVE INPUT LINE READING TO GETCUR; MOVE ASIS
               HANDLING TO COMMAND HANDLER.  CHANGE FIXES BUG WHERE
               BLANK LINE IN ASIS TEXT CAUSED AUTOPARAGRAPH AFTER ASIS
               CONCLUDED. BF
  UNDL         5/18 MAKE UNDERLINING PART OF ENVIRONMENT SO UNDONE
               BY POPS AND NOT DONE IN PAGE FOOTERS AND HEADERS. BF
  DOLLAR       5/18 DON'T THINK $BLANK OR $NUMBER IS A VARIABLE. BF
  BR           5/23 WHEN .SP >1, A .BR AFTER THE FIRST LINE ON A PAGE
               LEFT ONE OR MORE BLANK LINES.  PROBLEM IS HOKEY CODE
               AROUND PAGE THROWS.  FIX IT SO EVERY PUSHED LINE FORCES
               A .CR AND SAVES SYMBOL FOR NEXT TIME AROUND.  MUCH
               CLEANER NOW. BF
 USB           5/25 SIGNIFICANT BLANK (SB) BUGS: A) SB AT END OF
               JUSTIFIED LINE SCREWED UP JUSTIFICATION, B) SB "PUSHED"
               TO NEW LINE WERE LOST, C) CONTROVERSY OVER WHETHER TO
               UNDERLINE SB. SOLUTION: ADD .USB COMMAND (UNDERLINE
               SIGNIFICANT BLANKS) TO TURN ON OR OFF. WHILE UP, FIX
               BUG WHERE COLON NOT UNDERLINED. BF
 ARGS          5/27 SIGNIFICANT CHANGE TO MACRO HANDLING: MACRO
               "PARMS" (MACROS DEFINED BY MACRO INVOCATION) ARE
               INITIALLY DEFINED AS NULL AND REMAIN WELL-DEFINED
               UNTIL REDEFINED BY ANOTHER INVOCATION.  PERMITS
               MACROS SUCH AS ".MACRO CHAP * = .CH .CHAP1", AS
               .CHAP1 RETAINS ITS MEANING UNTIL .CHAP CALLED AGAIN.
               NOTE THAT IF THIS HAD BEEN AVAILABLE BEFORE, THE
               ..TTL CIRCUMLOCUTION WOULD NOT HAVE BEEN NEEDED. BF
 RIGHT         6/6 ALTERNATING FILL BROKEN BY FORCING .CR AFTER
               EACH LINE.  RESET ALTERNATING FILL ONLY ON .PP
               COMMAND. BF
 DOMID         6/17 NEEDED SOME MORE CLRLINES IN DOMID.  BF
 EMPTY         7/11 IF THE FIRST SYMBOL IN A LINE EXCEEDED THE
               RIGHT MARGIN, ADDWORD WOULD NEVER PUT IT ON A
               LINE, BUT PUSHSYL'D IT INFINITELY.  SYMPTOM:
               STACK OVERFLOW IN PROCEDURE ALLOC. FIX: DON'T
               PUSH FIRST SYMBOL ON AN EMPTY LINE. BF
 ADDSYL        7/13 CHANGE "RIGHT" WAS WRONG; BROKE .X AT
               LINE OVERFLOW.  NOW NEED SOMETHING TO HOLD
               SYMBOL IN BOTH IN AND OUT FORMATS; ADDED
               ADDSYL FOR THIS PURPOSE. BF
 VAR           7/13 ALLOW .VAR $X = EXPRESSION WHERE BOTH $X AND
               EXPRESSION CAN BE MACRO ARGUMENTS (OR ANYTHING). BF
OLNO           7/16 OLNO CHANGE TO PREDEFINED VARIABLE $$OLNO SO
               THAT OUTPUT LINE NUMBER AVAILABLE AT RUNTIME. RC
 PARAGR        7/22 IF PARAGRAPH'S TEST PAGE DID A .FRCPAGE, THE
               PARAGRAPH INDENT WAS LOST.  SHOWED UP IN MANUAL.
               REPORTED BY RICK CICHELLI. FIX IS TO CALL PUSHSYL. BF
 PS            9/14 .PS CHANGED RIGHT MARGIN AS WELL AS PAGE # RIGHT
               MARGIN IF ISSUED AFTER A .RM. CORRECTED TO WORK AS
               DOCUMENTED IE CHANGE PAGE # RIGHT MARGIN ONLY.
               IMPLEMENTED CHANGE BY ADDING RNF VARIABLE $$PRM. RC
 ASIS          9/19 ASIS MODE ALLOWS SPURIOUS UNDERLINING TO HAPPEN.
               FIX: REINITIALIZE ENTIRE LINE BEFORE PROCESSING ASIS
               TEXT. RC
 WHEN          9/20 TWO COMMANDS ADDED ALLOW DATE(.DATE) AND TIME
               (.TIME) TO BE ACCESSED. DATE AS DD/MM/YY AND TIME AS
               HH:MM. RC
 DELMAC        9/20 COMMAND ADDED (.DELMAC) TO ALLOW DELETION OF USER
               DEFINED MACROS FROM MACRO LIST. RC
 NONMP         9/23 .FRCPAGE FORCED 6 LINES FOR NON PAGE NUMBERED
               OUTPUT AND 7 LINES FOR PAGE NUMBERED OUTPUT. FORCE
               AN EXTRA LINE WHEN PAGE NOT NUMBERED VIA SYSTEM
               MACRO ..NMP RC
 ELIST         9/26 ELIST DOES NOT RESET THE LEFT MARGIN UNLESS
               EXPLICITLY FORCED TO. FIX ADD A CLRLINE AFTER
               POPPING THE ENVIRONMENT(TWICE) TO RESET THE
               LEFT MARGIN. RC
 ASIS1         9/27 ASIS MODE DOES NOT PROCESS THE END OF ASIS
               MODE FLAG(Ý) SO THAT THE REMAINDER OF THE LINE
               WILL BE PROCESSED. FIX: SET THE CHARACTER
               POINTER(CUP) TO THE CHARACTER FOLLOWING THE FLAG
               CHARACTER. RC
 MACDEF        10/3 MACRO DEFINITION NOT ALLOWED ON SAME LINE AS
               VARIABLE DEFINITION. FIX CHANGE PUSHSYL TO
               BACKUPSYL. RC
 NOFILL        10/3 NOFILL TEXT NO LONGER NEEDS AN EXPLICIT BREAK
               TO FORCE A PAGE WITH SINGLE LINE OF TEXT. ACCOMPLISHED
               BY CHECKING DEFRSYM IN THE MAIN PROCEDURE AND GETTING
               A NEW LINE WHEN THERE ARE NO DEFERRED COMMANDS. RC
 CENTER        10/5 .C DOES AN EXTRA CR. AFFECTS THE SPACING WHEN
               .SP IS GREATER THAN 1. FIX REMOVE THE EXTRA .CR. RC
 CENTER2       10/7 CORRECTION IN CENTER WOULD WORK ONLY IN TEXT
               WAS FILLED. CORRECTED TO WORK FOR BOTH FILLED AND
               NOFILL TEST.  RC
 SIGCOM        10/7 WHEN USING .SIG, ALL COMMANDS WHICH REQUIRED
               ARGUMENTS WERE PICKING UP BLANKS AS ARGUMENTS.
               ADDED CASE STATEMENT TO TURN .SIG OFF WHEN PROCESSING
               THESE COMMANDS. RC
  AUTOCAP       A NEW FACILITY HAS BEEN ADDED. LETTERS THAT BEGIN A SENTENCE,
                PARAGRAPH, CHAPTER, OR SUB-CHAPTER ARE AUTOMATICALLY
                CAPITALIZED. TO MAINTAIN COMPATIBILITY WITH PREVIOUS VERSIONS
                THIS FEATURE IS ONLY DONE FOLLOWING THE .AUTOCAP COMMAND,
                AND .NOAUTOCAP IS THE DEFAULT. FURTHER, NO AUTO CAPITALIZATION
                IS DONE WHEN IN .ASCII MODE.   CH
 QRR           THIS IS TO PRINT THE INPUT FILE THAT IS BEING PROCESSED.
               THIS FILE IS USUALLY IGNORED. CH
 DEBUG1        THIS IS THE OLD DEBUG PLUS DEBUG2. CH
 DEBUG2        PRINT ON THE RIGHT MARGIN (LINLEN) THE NUMBER OF THE
               INPUT LINE THAT GENERATED THIS OUTPUT LINE. THIS AIDS
               FINDING THE CORRECT INPUT LINE THAT NEEDS CHANGING. CH
 *)

PROGRAM RUNOFF (INPUT,OUTPUT,QRR);
CONST
 VPAGE = 1; VCH = 2; VHL =3; VLIST = 9; (* NEXT IS 20 *)
 VLM = 20; VRM = 21; VSP = 22; VNMP = 23; VOLNO = 24; (* NEXT IS 25 *)
 VPRM = 25; (* NEXT IS 26 *)
 VARMAX = 100;
 MACCHR = '.';
 VARCHR = '$';
 CMDCHR = '.';
 TABMAX = 16;
 LINLEN = 132;
 MAXENP = 20;
 HLMAX = 5;
 MAXLIST = 10;
 FIGMAX = 10;
 MACMAX = 10;
 VHLMAX = 5;
 CASEDIFF = 64; (* DIFFERENCE BETWEEN UPPER AND LOWER CASE, WITH UPPER>LOWER
                   ASCII = 32,     EBCDIC = 64;         *)
 CHARSIZE = 256;    (* NUMBER OF CHARS IN CHARACTER SET FOR EBCDIC *)

TYPE
 VARTYP = (VITEM,VARRAY);
 RELOPR = (EQ,GT,LT,NE,GE,LE);
 ENRANGE = 0..MAXENP;
 SIGN = (PLUS,MINUS,UNSIGNED,INVALID);
 SYMTYP = (WORD,COMMAND,VARS,NONE);
 LLEN = 0..LINLEN;
 LALEN = 1..LINLEN;
 JUSLIN = RECORD
  NDX: LLEN;
  POS: ARRAY (/LALEN/) OF INTEGER
 END;
 LINE = RECORD
  CENTER,BBAR: BOOLEAN;
  VLEN,LEN: LLEN;
  LIN: ARRAY (/LALEN/) OF CHAR;    (* HOLDS THE LINE TO BE PROCESSEED *)
  LINT : ARRAY(/LALEN/) OF RECORD
                           LINC : ARRAY (/1..4/) OF CHAR;
         (* EACH ELEMENT OF LINT CORRESPONDS TO A LETTER OF LIN.
            THE FIRST THREE CHARACTERS ARE POSSIBLE OVERSTRIKE CHARACTERS
            AND THE FOURTH CHARACTER IS A INDEX AS TO THE NUMBER OF OVERSTRIKES
           *)              END;
 END;
 CMDTYP = (CBLANK,CCR,CBREAK,CRESPAG,CRES,
           CESCCHR,CASCII,CCENTER,CJUST,(*CUL,*)CLMAR,CRMAR,
           CFILL,CSIG,CPAGE,CSUP,CLPT,CSTD,CPS,CSAV,CP,
           CPP,CAP,CI,CSP,CS,CTP,CCH,CHL,CNMP,CPNO,CTITLE,CST,
           CATITLE,CLIST,CLE,CELIST,CFIG,CBAR,CBB,CEB,CU,
           CT,CTAB,CTABS,CRT,CRIGHT,CLINES,CMACRO,CX,
           CVAR,CINC,CASIS,CDEC,CDATE,CTIME,CDELMAC,
           (* END OF CMDTYP SET *)
           CFLAG,CFLAGCAPS,CFLAGOVER,CFLAGSIG,CLOWER,CUPPER,CPERIOD,
           CSAVPAG,CTOP,CMID,CBOT,CARRAY,
           CFMT,CIF,CDOT,CREM,CUPP,CUSB,CADD,CDEBUG1,CDEBUG2,CAUTOCAP,
           NOTCMD);
 ENVIRON = RECORD
            J,F,PR,SG,UN:   BOOLEAN;
            PM,SP:  INTEGER;
            LM,RM,PS,PT,PRM: LLEN;
            TB:  ARRAY (/1..TABMAX/) OF LLEN
          END;
MACTYP = (HEADER,PARM);
MACLEN = 1..MACMAX;
MACSYM =  ARRAY(/MACLEN/) OF CHAR;
ALINE =  ARRAY(/LALEN/) OF CHAR;
MAC = RECORD
      ON: BOOLEAN;
      CA,MA: @MAC;
      CU,BE,EN: LLEN;
      MT: MACTYP;
      NP: 0..8;
      LI: @ALINE;
      NM: MACSYM
     END;
PMAC = @MAC;
 SETOFCHAR = ARRAY (/0..255/) OF BOOLEAN;
VAR
 SYMTYPE: SYMTYP;
 SYL,OTL,TMPL: LINE;    (* THE LINE ENTERS THROUGH SYL AND THEN IS TRANSFERRED
                           A WORD AT A TIME INTO TMPL, WHERE THE CASE IS
                           ADJUSTED AND OVERSTRIKES ADDED AND THEN IS MOVED
                           OTL WHERE IT IS JUSTIFIED, CENTERED AND WRITTEN *)
 FRCSYL,ADDSYL: LINE;
 FREEMACP: PMAC;
 CMDS: ARRAY (/CMDTYP/) OF  ARRAY (/1..10/) OF CHAR;
 CMDTYPE: CMDTYP;
 LN: LLEN;
 FLAG,LOWER,FLAGCAPS,FLAGOVER,FLAGSIG: BOOLEAN;
 PQEND,PERIOD,ESCCHR: BOOLEAN;
 YES,PAGE: BOOLEAN;
 JUSTIT,RIGHT: BOOLEAN;
 (*UL,*) LPT: BOOLEAN;
 FILL,SIGBL: BOOLEAN;
 SUP: BOOLEAN;
 PARA,AP,PREL,ATITLE:  BOOLEAN;
 ILNO: INTEGER;
 OPNO,OBTXT,OETXT,OVETXT,OEPAG,OVBTXT: INTEGER;
 TMAR: LLEN;
 PMAR: INTEGER;
 JUST,SAVJUST: JUSLIN;
 ENSTK: ARRAY (/ENRANGE/) OF ENVIRON; ENP: ENRANGE;
 PARSPACE,PARTEST,SPACING: INTEGER;
 PAGENV: ENVIRON;
 DEFRB: INTEGER;
 FORCE: BOOLEAN;
 FIRSTCH: BOOLEAN;
 FIGP: 0..FIGMAX; FIGN: ARRAY (/1..FIGMAX/) OF INTEGER;
  UNDL: BOOLEAN;
 BAR,BB,HOLDBB:  BOOLEAN;
 RIGHTSPACE: 0..136;
 TABS: ARRAY(/1..TABMAX/) OF LLEN;
 TAB,DOTN: LLEN;
 DEFRSYM: BOOLEAN;
 RT,T,DOT:   BOOLEAN;
 BREAKSET,OPTBRKSET,CRSET: SET OF CBLANK..CDEC;
 EMPTY: BOOLEAN;
 ACTP,MACLSTP,BOTMAC,TTLMACP,STLMACP,CHTMACP: PMAC;
 NOTMACRO: BOOLEAN;
 CUR: ARRAY(/LALEN/) OF CHAR;
 BEG,ENL,CUP,LASTCUP: LLEN;
 XTEND: BOOLEAN;
 LASTLEN,LASTVLEN,LASTSLEN,LASTSVLEN: LLEN;
 VID: ARRAY (/1..VARMAX/) OF ALFA;
 VAL: ARRAY (/1..VARMAX/) OF INTEGER;
 VTY: ARRAY (/1..VARMAX/) OF VARTYP;
 VUP: ARRAY (/1..VARMAX/) OF 1..VARMAX;
 VARNDX,TV: 1..VARMAX;
 PUSHED: BOOLEAN;
 PAGSAV,PAGSAVS,TMPLSAV: LINE;
 PAGOTL,PAGSYL: BOOLEAN;
 CH: CHAR;
 EP: LLEN;
 ARELOPR: ARRAY (/RELOPR/) OF ALFA;
 EXPRERR,SHOWEXPR: BOOLEAN;
  ITEMSET, TERMSET : SETOFCHAR;
  SUB, ERRORS : INTEGER;
  LITERAL1 : ARRAY (/1..60/) OF CHAR;
  LITERAL2 : ARRAY (/1..57/) OF CHAR;
  LITERAL3 : ARRAY (/1..16/) OF CHAR;
  LITERAL4 : ARRAY (/1..38/) OF CHAR;
  LITERAL5 : ARRAY (/1..27/) OF CHAR;
  BLANKLINC : ARRAY (/1..4/) OF CHAR;
 ROMLC,LASTFILD: BOOLEAN;
 EOFINPUT: BOOLEAN;
 XTRABL,USB: BOOLEAN;
 CMMD: BOOLEAN;
 LETTERS : ARRAY (/0..25/) OF CHAR; (* EASES RELIANCE ON UNDERLYING CHAR SET *)
 DEBUG1, DEBUG2 : BOOLEAN;
 CAPNEXT : BOOLEAN;
 AUTOCAP : BOOLEAN;
   (*$E        *)
   FUNCTION INLALPHA (CH:CHAR):BOOLEAN;
     (* THIS FUNCTION IS EXPRESSLY FOR THE PURPOSE OF THE
        FOLLOWING TEST :
                CH IN (Ý'a'..'z'Ý)
                               *)
    BEGIN
      INLALPHA := FALSE;
      IF (CH >= 'a') AND (CH <= 'i')
         THEN INLALPHA := TRUE
         ELSE IF (CH>='j') AND (CH<='r')
                 THEN INLALPHA := TRUE
                 ELSE IF (CH>='s') AND (CH<='z')
                         THEN INLALPHA := TRUE
                         ELSE;
       END;  (* SO MUCH FOR INLALPHA *)



   FUNCTION INALPHA (CH:CHAR):BOOLEAN;
     (* THIS FUNCTION IS EXPRESSLY FOR THE PURPOSE OF THE
        FOLLOWING TEST :
                CH IN (Ý'A'..'Z'Ý)
                               *)
    BEGIN
      INALPHA := FALSE;
      IF (CH >= 'A') AND (CH <= 'I')
         THEN INALPHA := TRUE
         ELSE IF (CH>='J') AND (CH<='R')
                 THEN INALPHA := TRUE
                 ELSE IF (CH>='S') AND (CH<='Z')
                         THEN INALPHA := TRUE
                         ELSE;
       END;  (* SO MUCH FOR INALPHA *)

   FUNCTION INDIGIT (CH : CHAR) : BOOLEAN;
     (* THIS MODULE PERFORMS THE TEST: CH IN (Ý0..9Ý) WHICH IS
        SOMEWHAT DEFICIENT USING EBCDIC.
                              *)
     BEGIN
       INDIGIT := ((CH >= '0') AND (CH <= '9'));
       END;  (* INDIGIT *)




   FUNCTION INSETOFCHAR (S : SETOFCHAR; CH : CHAR) : BOOLEAN;
     (* THIS MODULE PERFORMS THE TEST: CH IN S , WHERE
        S IS DEFINED AS SET OF CHAR.
                              *)
     BEGIN
       INSETOFCHAR := S(/ ORD (CH) /) = TRUE
       END;  (* INSETOFCHAR *)                            (*$E  *)
   PROCEDURE ERR;
     BEGIN
       WRITE(' ERROR:  ');
       ERRORS := ERRORS + 1;
     END;    (* END OF ERR *)

  PROCEDURE ERRE;
    VAR T: PMAC;
    BEGIN
     WRITELN(' ON INPUT LINE ',ILNO:4);
     T := ACTP;
     WHILE T@.CA<>NIL DO
        BEGIN
        WRITELN('       WITHIN MACRO ',T@.NM:10);
        T := T@.CA;
        END;
    END;     (* END OF ERRE *)



  PROCEDURE SYLERR;
    BEGIN
    WRITE(' ''');
    FOR LN:=1 TO SYL.LEN DO WRITE(SYL.LIN(/LN/));
    WRITE('''');
    ERRE
    END;     (* END OF SYLERR *)

  PROCEDURE UPCASESYL;
    VAR I: LLEN;
    BEGIN
    I := 0;
    WITH SYL DO
      FOR LN:=1 TO LEN DO
          IF INLALPHA (LIN(/LN/) )
             THEN LIN (/LN/) := CHR( ORD( LIN(/LN/) ) + CASEDIFF )
             ELSE
    END;     (* END OF UPCASESYL *)
   FUNCTION  LOWERTHECASE (C:CHAR):CHAR;
      (* LOWER THE CASE IF ADVISABLE  *)
     BEGIN
       IF INALPHA(C)
          THEN LOWERTHECASE := CHR( ORD(C) - CASEDIFF)
          ELSE LOWERTHECASE := C;
     END;



  PROCEDURE NEXTCH;
    BEGIN
    IF EP<SYL.LEN THEN BEGIN EP := EP + 1; CH := SYL.LIN(/EP/) END
           ELSE IF EP=SYL.LEN THEN BEGIN EP := EP + 1; CH := ' ' END
       ELSE BEGIN EXPRERR := TRUE; CH := ' ' END;
    END;     (* END OF NEXTCH *)

FUNCTION TERM:INTEGER; FORWARD;
FUNCTION VARIABLE: INTEGER;
VAR V: ALFA; I: INTEGER; VNDX1,VNDX2: 0..VARMAX; VAR1: INTEGER;
BEGIN
 NEXTCH;
 V := '          ';
 I := 0;
 WHILE (INALPHA(CH) OR INDIGIT(CH) OR (CH = '$')) DO
  BEGIN I := I + 1;
   IF I<=10 THEN V(/I/) := CH;
   NEXTCH;
  END;
 VAR1 := 0;
 IF I=0 THEN EXPRERR := TRUE
 ELSE
  BEGIN
   VID(/TV/) := V;
   VNDX1 := 1;
   VNDX2 := 0;
   WHILE VID(/VNDX1/)<>V DO VNDX1 := VNDX1 + 1;
   IF VNDX1<>TV THEN
    BEGIN
     IF (VTY(/VNDX1/)=VARRAY) AND (CH='[') THEN
      BEGIN
       NEXTCH;
       VNDX2 := TERM;
       IF CH<>']' THEN EXPRERR := TRUE ELSE NEXTCH;
       IF (VNDX2<0) OR (VNDX2>VUP(/VNDX1/)) THEN
        BEGIN ERR; WRITE('ARRAY INDEX OUT OF BOUNDS'); SYLERR;
              VNDX2 := 0 END;
      END;
     IF CH='=' THEN
      BEGIN
       NEXTCH;
       VAL(/VNDX1+VNDX2/) := TERM;
      END;
     VAR1 := VAL(/VNDX1+VNDX2/);
    END
   ELSE BEGIN ERR; WRITE('UNDEFINED VARIABLE: $',V); ERRE END;
  END;
VARIABLE := VAR1;
END;     (* END OF VARIABLE *)

FUNCTION ITEM: INTEGER;
VAR SIGN,ITEM1: INTEGER;
BEGIN
 SIGN := 1;
 IF CH='-' THEN BEGIN SIGN := 2; NEXTCH END
 ELSE IF CH='+' THEN NEXTCH
 ELSE IF CH='#' THEN BEGIN SIGN := 3; NEXTCH END;
 ITEM1 := 0;
 IF CH='$' THEN ITEM1 := VARIABLE
 ELSE IF INDIGIT(CH) THEN
  REPEAT
   ITEM1 := ITEM1*10 + (ORD(CH)-ORD('0'));
   NEXTCH
  UNTIL NOT (INDIGIT(CH))
 ELSE EXPRERR := TRUE;
 CASE SIGN OF
  2: ITEM1 := - ITEM1;
  3: IF ITEM1=0 THEN ITEM1 := 1 ELSE ITEM1 := 0;
  1:
 END;
 ITEM := ITEM1;
END;     (* END OF ITEM *)

FUNCTION TERM;
VAR TERM1,TERM2: INTEGER; TCH: CHAR;
BEGIN
 TERM1 := 0;
 IF CH='(' THEN
  BEGIN
   NEXTCH;
   TERM1 := TERM;
   IF CH<>')' THEN EXPRERR := TRUE ELSE NEXTCH;
  END
 ELSE IF INSETOFCHAR(ITEMSET,CH) THEN
  BEGIN
   TERM1 := ITEM;
   WHILE (CH = '+') OR (CH = '-') DO
    BEGIN
     TCH := CH;
     NEXTCH;
     TERM2 := 0;
     IF INSETOFCHAR(ITEMSET,CH) THEN TERM2 := ITEM
     ELSE IF CH='(' THEN TERM2 := TERM;
     IF TCH='+' THEN TERM1 := TERM1 + TERM2
     ELSE TERM1 := TERM1 - TERM2;
    END;
  END;
 TERM := TERM1;
END;     (* END OF TERM *)

FUNCTION RELOP: RELOPR;
VAR OP: ALFA; ROP: RELOPR;
BEGIN
 NEXTCH;
 OP := '          ';
 OP(/1/) := CH; NEXTCH;
 OP(/2/) := CH; NEXTCH;
 RELOP := EQ;
 IF CH='.' THEN NEXTCH;
 FOR ROP:=EQ TO LE DO IF ARELOPR(/ROP/)=OP THEN RELOP := ROP;
END;     (* END OF RELOP *)

FUNCTION EXPR: INTEGER;
VAR EXPR1,EXPR2,EXPR3: INTEGER; EXPROP: RELOPR;
BEGIN
 WITH SYL DO
  BEGIN
   UPCASESYL;
   IF (LIN(/EP/)='$') AND (LIN(/EP+1/)='(') THEN EP := EP + 1;
   CH := LIN(/EP/);
   EXPR1 := 0;
   EXPRERR := FALSE;
   IF INSETOFCHAR(TERMSET,CH) THEN
    BEGIN
     EXPR1 := TERM;
     IF CH='.' THEN
      BEGIN
       EXPROP := RELOP;
       EXPR2 := 0;
       IF INSETOFCHAR(TERMSET,CH) THEN EXPR2 := TERM;
       EXPR3 := 0;
       CASE EXPROP OF
        EQ: IF EXPR1=EXPR2 THEN EXPR3 := 1;
        GT: IF EXPR1>EXPR2 THEN EXPR3 := 1;
        LT: IF EXPR1<EXPR2 THEN EXPR3 := 1;
        NE: IF EXPR1<>EXPR2 THEN EXPR3 := 1;
        GE: IF EXPR1>=EXPR2 THEN EXPR3 := 1;
        LE: IF EXPR1<=EXPR2 THEN EXPR3 := 1
        END;
       EXPR1 := EXPR3;
      END
    END;
   EXPR := EXPR1;
   SHOWEXPR := TRUE;
   IF (EP<=LEN) AND (CH=';') THEN BEGIN NEXTCH; SHOWEXPR := FALSE; END;
   IF EP<=LEN THEN EXPRERR := TRUE;
   IF EXPRERR THEN
    BEGIN ERR; WRITE('ERROR IN EXPRESSION:'); SYLERR END;
  END;
END;     (* END OF EXPR *)

PROCEDURE GETNUM(VAR S: SIGN; VAR N: INTEGER);
BEGIN
 WITH SYL DO
  BEGIN
   N := 0;
   LN := 2;
   IF LIN(/1/)='+' THEN S := PLUS
   ELSE IF LIN(/1/)='-' THEN S := MINUS
   ELSE BEGIN S := UNSIGNED; LN := 1 END;
   EP := LN;
   N := EXPR;
   IF EXPRERR THEN S := INVALID;
  END;
END;     (* END OF GETNUM *)

PROCEDURE CLRTAB;
BEGIN
 FOR LN:=1 TO TABMAX DO TABS(/LN/) := 0;
END;     (* END OF CLRTAB *)

FUNCTION GETTAB(X: INTEGER): INTEGER;
BEGIN
 LN := 1;
 TABS(/TABMAX/) := X;
 WHILE TABS(/LN/)<X DO LN := LN + 1;
 JUST.NDX := 0;
 RT := FALSE;
 T := FALSE;
 GETTAB := TABS(/LN/);
END;     (* END OF GETTAB *)

PROCEDURE SAVENV(VAR E: ENVIRON);
BEGIN
 WITH E DO
  BEGIN
   LM := VAL(/VLM/); RM := VAL(/VRM/); PM := PMAR;
   PS := PARSPACE; PT := PARTEST; PR := PREL;
   J := JUSTIT; F := FILL;
   SP := VAL (/VSP/);
   TB := TABS;
   SG := SIGBL; UN := UNDL;
   PRM:=VAL(/VPRM/);
  END
END;     (* END OF SAVENV *)

PROCEDURE RESENV(VAR E: ENVIRON);
BEGIN
 WITH E DO BEGIN
  VAL(/VLM/) := LM; VAL(/VRM/) := RM; PMAR := PM;
  PARSPACE := PS; PARTEST := PT; PREL := PR;
  JUSTIT := J; FILL := F;
  VAL(/VSP/) := SP;
  TABS := TB;
  SIGBL := SG; UNDL := UN;
  VAL(/VPRM/):=PRM;
 END
END;     (* END OF RESENV *)

PROCEDURE PSHENV;
BEGIN
 SAVENV(ENSTK(/ENP/));
 IF ENP=MAXENP THEN
  BEGIN ERR; WRITE('TOO MANY P OR LIST LEVELS'); ERRE END
 ELSE ENP := ENP + 1;
END;     (* END OF PSHENV *)

PROCEDURE POPENV;
BEGIN
 IF ENP=0 THEN
  BEGIN ERR; WRITE('TOO MANY POPS'); ERRE END
 ELSE ENP := ENP - 1;
 RESENV(ENSTK(/ENP/));
END;     (* END OF POPENV *)


   PROCEDURE UPCASE(VAR L: LINE);
     VAR I,J: LLEN;
     BEGIN
      WITH L DO
          FOR I := 1 TO LEN DO
              IF INLALPHA (LIN(/I/) )
                 THEN LIN(/I/) := CHR (ORD(LIN(/I/) ) + CASEDIFF)
                 ELSE
      END;      (* UPCASE *)





PROCEDURE FLAGERR(C1,C2: CHAR);
BEGIN
 WRITELN;
 WRITELN('FLAG ERROR IN INPUT LINE ',ILNO:5,':');
 WRITELN('  ''',C1,C2,''' SEQUENCE NOT ALLOWED -- ''',
  C1,''' DELETED')
END;     (* END OF FLAGERR *)

PROCEDURE DOJUST(VAR L: LINE; VAR F: JUSLIN; RIGHT: BOOLEAN);
VAR
 I,J,K,N,M: LLEN;
BEGIN        (* DOJUST *)
 WITH L,F DO
  BEGIN
   IF LEN>2 THEN
    IF XTRABL THEN BEGIN LEN := LEN - 1 END;
   IF (NOT CENTER) AND (NDX>1) AND (LEN<=VAL(/VRM/)+1) THEN
    BEGIN
     I := NDX; J := VAL(/VRM/);
     N := (VAL(/VRM/)-LEN+1) DIV (NDX-1);
     M := (VAL(/VRM/)-LEN+1) MOD (NDX-1);
     LEN := J + 1;
     FOR K:=NDX DOWNTO 2 DO
      BEGIN
       FOR LN:=POS(/K/) DOWNTO POS(/K-1/)+1 DO
        BEGIN LINT(/J/) := LINT(/LN/); LIN(/J/) := LIN(/LN/); J := J - 1 END;
       FOR LN:=1 TO N DO
        BEGIN LINT(/J/).LINC := BLANKLINC; LIN(/J/) := ' ';
                 J := J - 1 END;
       IF RIGHT THEN
        BEGIN IF (NDX-K)<=M THEN
         BEGIN LINT(/J/).LINC := BLANKLINC; LIN(/J/) := ' ';
                   J := J - 1 END
        END
       ELSE IF (K-2)<=M THEN
        BEGIN LINT(/J/).LINC := BLANKLINC;  LIN(/J/) := ' ';
                         J := J - 1  END
      END
    END
  END;
END;     (* END OF DOJUST *)

PROCEDURE SAVOTL;
BEGIN
 TMPLSAV := TMPL;
 PAGSAV := OTL;
 PAGOTL := TRUE;
END;     (* END OF SAVOTL *)

PROCEDURE SAVSYL;
BEGIN
 PAGSAVS := OTL;
 PAGSYL := TRUE;
 SAVJUST := JUST;
END;     (* END OF SAVSYL *)

PROCEDURE CLRLINE;
BEGIN
 WITH OTL DO
  BEGIN
   FOR LN:=1 TO VAL(/VLM/) DO BEGIN LIN(/LN/) := ' ';
                                    LINT(/LN/).LINC := BLANKLINC END;
   VLEN := VAL(/VLM/);
   LEN  := VAL(/VLM/);
   JUST.NDX := 0;
   SUP := FALSE;
   DEFRB := 0;
   TAB := 0;
   EMPTY := TRUE;
   CENTER := FALSE;
   FORCE := FALSE;
   OTL.BBAR := BB;
  END;
END;     (* END OF CLRLINE *)

PROCEDURE WRITEOTL; FORWARD;
PROCEDURE PUTBLANK; FORWARD;
PROCEDURE MIDRESTORE;
VAR LN: INTEGER;
BEGIN
 CLRLINE;
 IF PAGOTL THEN
  BEGIN
   TMPL := TMPLSAV;
   OTL := PAGSAV;
   WRITEOTL;
   VAL(/VOLNO/) := VAL(/VOLNO/) + 1;
   CLRLINE;
  END;
 PAGOTL := FALSE;
 IF PAGSYL THEN
  BEGIN
   OTL := PAGSAVS;
   JUST := SAVJUST;
   EMPTY := FALSE;
   CLRLINE;
  END;
 PAGSYL := FALSE;
 BB := HOLDBB; HOLDBB := FALSE;
END;     (* END OF MIDRESTORE *)

PROCEDURE STARTLINE(C: CHAR);
BEGIN
 IF DEBUG1                      (* DEBUG1STUFF    *)
    THEN
         WRITE(VAL(/VOLNO/):3,' ');
 IF LPT THEN WRITE(C);
 IF RIGHTSPACE>0 THEN
  FOR LN:=1 TO RIGHTSPACE DO WRITE(' ');
 IF BAR THEN
  BEGIN
   IF OTL.BBAR THEN WRITE('Ý')
   ELSE WRITE(' ');
   WRITE('  ');
  END;
END;     (* END OF STARTLINE *)

PROCEDURE DOTOP;
BEGIN
 IF NOT LPT THEN
   FOR SUB := VAL (/VOLNO/) TO OEPAG DO WRITELN;
 VAL(/VOLNO/) := 1;
 STARTLINE('1');
 OVETXT := OETXT - 1;
 OVBTXT := 0;
 IF NOT HOLDBB THEN BEGIN HOLDBB := BB; BB := FALSE; END;
END;     (* END OF DOTOP *)

PROCEDURE FORCECMD(A:ALFA; B:LLEN);
BEGIN
 FRCSYL := SYL;
 FOR SUB := 1 TO 10 DO BEGIN SYL.LIN (/SUB/) := A(/SUB/);
                             SYL.LINT(/SUB/).LINC := BLANKLINC; END;
 SYL.LIN(/11/) := ' ';
 SYL.LEN := B;
 SYL.VLEN := B;
 DEFRSYM := TRUE;
END;     (* END OF FORCECMD *)

PROCEDURE DOMID;
VAR DOFIG: BOOLEAN;
BEGIN
 OVBTXT := VAL(/VOLNO/);
 DOFIG := TRUE;
 IF FIGP>0 THEN
  WHILE DOFIG DO
   IF FIGN(/FIGP/)<=OVETXT-OVBTXT+1 THEN
    BEGIN
     FOR LN:=1 TO FIGN(/FIGP/) DO
      BEGIN WRITELN; VAL(/VOLNO/) := VAL(/VOLNO/) + 1 END;
     FIGP := FIGP - 1;
     IF FIGP=0 THEN DOFIG := FALSE;
    END
   ELSE DOFIG := FALSE;
 MIDRESTORE;
END;     (* END OF DOMID *)

PROCEDURE DOBOT;
BEGIN
 FOR LN:=VAL(/VOLNO/) TO OETXT DO WRITELN;
 VAL(/VOLNO/) := OETXT + 1;
 OVETXT := 100000;
 HOLDBB := BB;
END;     (* END OF DOBOT *)

PROCEDURE PUTBLANK;
BEGIN
 IF VAL(/VOLNO/)>OVBTXT THEN
  IF VAL(/VOLNO/)<=OVETXT+1 THEN
   BEGIN
    VAL(/VOLNO/) := VAL(/VOLNO/) + 1;
    STARTLINE(' ');
    WRITELN;
   END;
END;     (* END OF PUTBLANK *)
  (*$E                  *)
PROCEDURE WRITEOTL;
VAR I,J,K,CENTS: INTEGER;

PROCEDURE DOCENTER;
VAR I: INTEGER;
BEGIN
 CENTS := ((VAL(/VRM/)-VAL(/VLM/)) DIV 2) - ((OTL.LEN-VAL(/VLM/)) DIV 2) ;
 IF OTL.CENTER THEN FOR I := 1 TO CENTS DO WRITE(' ')
 ELSE CENTS := 0;
END;     (* END OF DOCENTER *)

BEGIN
 WITH OTL DO
  BEGIN
   IF LEN>0 THEN LEN := LEN - 1;
(* IF NOT UL THEN (* CONVERT TO UC *)
    BEGIN
(*   FOR LN:=1 TO LEN DO
      IF LINT(/LN/)<0 THEN
       BEGIN
(*      IF (LINC(/LN,0/)='@') AND (LINC(/LN,9/)<='D') THEN      *)
         CASE LINC(/LN,9/) OF
          'A': LINC(/LN,9/) := '@';
          'B': LINC(/LN,9/) := '^';
          'D': LINC(/LN,9/) := ':';
          ':','C':
         END;
        LINC(/LN,0/) := ':';
       END      *)
    END;           *)
   I := 0;
   STARTLINE(' ');
   DOCENTER;
   K := 0;
   FOR LN:=1 TO LEN DO (* WRITE THE LINE *)
    BEGIN
(*   IF LINT(/LN/)<0 THEN BEGIN K := K + 1; WRITE(LINC(/LN,0/)) END;    *)
     K := K + 1; WRITE(LIN(/LN/));
     IF ORD(LINT(/LN/).LINC(/4/))>I THEN I := ORD(LINT(/LN/).LINC(/4/));
    END;
   IF I>0 THEN (* COMPUTE LINE LEN *)
    BEGIN
     K := RIGHTSPACE + CENTS + K;
     IF LPT THEN K := K + 1;
     IF BAR THEN K := K + 3;
    END;
   FOR J:=1 TO I DO
    BEGIN
     IF LPT THEN BEGIN WRITELN; STARTLINE('+') END
     ELSE
      BEGIN
(*     IF ODD(K) THEN WRITE(' ');
       WRITELN(':K');
       WRITE('@ @5@5@5@5@5');
                               *)
      WRITELN; WRITELN; WRITELN;
       STARTLINE(' ');
      END;
     DOCENTER;
     FOR LN:=1 TO LEN DO
      IF ORD(LINT(/LN/).LINC(/4/))>=J THEN WRITE(LINT(/LN/).LINC(/J/))
      ELSE WRITE(' ');
     K := LEN
    END;
    IF DEBUG2
       THEN WRITELN(OUTPUT,' ':(LINLEN-LEN-CENTS-10),ILNO:5)
       ELSE WRITELN(OUTPUT)
  END;
END;     (* END OF WRITEOTL *)
   (*$E                 *)
PROCEDURE PUTLINE;
BEGIN
 IF (NOT SUP) AND (NOT EMPTY) THEN
  BEGIN
   IF (VAL(/VOLNO/)>OVETXT+1) OR (PUSHED AND (VAL(/VOLNO/)>OVETXT)) THEN
    BEGIN
     IF VAL(/VOLNO/)>OVETXT+1 THEN LASTFILD := TRUE;
     SAVOTL;
     FORCECMD('.FRCPAGE  ',8);
    END
   ELSE
    BEGIN
     PUSHED := FALSE; (* NO PAGE THROW *)
     VAL(/VOLNO/) := VAL(/VOLNO/) + 1;
     WITH OTL DO
      BEGIN
       RIGHT := NOT RIGHT;
       WRITEOTL;
      END
    END
  END;
 FOR LN:=1 TO DEFRB DO PUTBLANK;
 CLRLINE;
END;     (* END OF PUTLINE *)

PROCEDURE TESTPAGE(N: INTEGER);
BEGIN
 IF (N*VAL(/VSP/))-1>(OVETXT-VAL(/VOLNO/)+1) THEN
 BEGIN SAVSYL; FORCECMD('.FRCPAGE  ',8) END
END;     (* END OF TESTPAGE *)

PROCEDURE PUSHSYL(S: LINE); FORWARD;
PROCEDURE PARAGRAPH;
BEGIN
 RIGHT := TRUE; (* RESET ALTERNATING FILL *)
 FOR LN:=1 TO PARSPACE*VAL(/VSP/) DO PUTBLANK;
 WITH OTL DO BEGIN
  IF PREL THEN
   IF VAL(/VLM/)+PMAR>0 THEN LN := VAL(/VLM/) + PMAR
   ELSE LN := 1
  ELSE LN := PMAR;
  VLEN := LN; LEN := LN;
  FOR LN:=1 TO LEN DO BEGIN LIN(/LN/) := ' ';
                      LINT(/LN/).LINC := BLANKLINC; END;
 END;
 RIGHT := TRUE;
 TESTPAGE(PARTEST);
 IF DEFRSYM THEN PUSHSYL(FRCSYL);
 CAPNEXT := AUTOCAP AND LOWER;
END;     (* PARAGRAPH *)
PROCEDURE MARKJUST(N: LLEN);
BEGIN
 WITH JUST DO
  BEGIN NDX := NDX + 1; POS(/NDX/) := N END
END;     (* END OF MARKJUST *)
   (*$E             *)
PROCEDURE ADDWORD;
VAR I,J,LN: INTEGER;
BEGIN
 WITH OTL DO
  BEGIN
   IF (XTEND) AND (JUST.NDX>0) THEN
    BEGIN
     JUST.NDX := JUST.NDX -1;
     FOR LN:=TMPL.LEN DOWNTO 1 DO BEGIN TMPL.LIN(/LN+LASTSLEN/):=TMPL.LIN(/LN/);
      TMPL.LINT(/LN+LASTSLEN/) := TMPL.LINT(/LN/);   END;
     FOR LN:=1 TO LASTSLEN DO BEGIN TMPL.LINT(/LN/) := LINT(/LN+LASTLEN-1/);
                                 TMPL.LIN(/LN/) := LIN(/LN+LASTLEN-1/) END;
     TMPL.LEN := TMPL.LEN + LASTSLEN;
     LEN := LASTLEN;
(*   FOR LN:=1 TO SYL.LEN DO
      ADDSYL.LIN(/LN+ADDSYL.LEN/) := SYL.LIN(/LN/);
     ADDSYL.LEN := ADDSYL.LEN + SYL.LEN *)
    END;
(* ELSE ADDSYL := SYL; *)
   XTEND := FALSE;
   TAB := 0; DOTN := 0;
   IF RT THEN TAB := GETTAB(LEN+TMPL.LEN-1) - TMPL.LEN + 1
   ELSE IF T THEN TAB := GETTAB(LEN);
   WHILE LEN<TAB DO
    BEGIN
     IF DOT AND (NOT (LEN=TAB-1)) THEN LIN(/LEN/) := '.'
     ELSE LIN(/LEN/) := ' ';
     LINT(/LEN/).LINC := BLANKLINC;
     LEN := LEN + 1; DOTN := DOTN + 1;
    END;
   IF (LEN+TMPL.LEN-1>VAL(/VRM/)) AND (NOT EMPTY) THEN
     BEGIN
      IF JUSTIT THEN DOJUST(OTL,JUST,RIGHT);
      PUSHED := TRUE;
      FORCECMD('.CR       ',3);  (* FORCE THE END OF LINE *)
      PUSHSYL(ADDSYL);         (* AND SAVE THE CURRENT SYMBOL *)
      PUTLINE;
(*    IF NOT XTEND THEN PUSHSYL(ADDSYL) (* SAVE CURRENT SYMBOL *)
      ELSE
       BEGIN
        XTEND := FALSE;
        ADDWORD
      END; *)
      IF PUSHED THEN           (* RETURN FLAG MEANS PAGE THROWN *)
       PUSHSYL(FRCSYL);        (* SAVE THE .CR *)
      PUSHED := FALSE;         (* TURN IT OFF NOW *)
     END
   ELSE
    BEGIN
     EMPTY := FALSE;
     (*DEBUG*)
     IF LEN=0 THEN
      BEGIN ERR; WRITE('LEN=0;');FOR LN:=1 TO 10 DO WRITE(LIN(/LN/));
         WRITE(' -- ');
         FOR LN:=1 TO 10 DO WRITE(TMPL.LIN(/LN/));
        ERRE END;
     FOR LN:=1 TO TMPL.LEN DO BEGIN LINT(/LEN+LN-1/) := TMPL.LINT(/LN/);
                                    LIN(/LEN+LN-1/) := TMPL.LIN(/LN/) END;
     LASTLEN := LEN; LASTSLEN := TMPL.LEN;
     LEN := LEN + TMPL.LEN;
     MARKJUST(LEN-1);
     IF NOT SIGBL THEN
      BEGIN
       LIN(/LEN/) := ' ';
       LINT(/LEN/).LINC := BLANKLINC; LEN := LEN + 1;
       IF PQEND THEN
        BEGIN LIN(/LEN/):=' ';LINT(/LEN/).LINC:=BLANKLINC; LEN := LEN+1  END;
       XTRABL := PQEND
      END;
    END;
  END;
 PUSHED := FALSE;
END;     (* END OF ADDWORD *)

PROCEDURE ADDN(N: INTEGER; VAR OTL: LINE);
BEGIN
 IF N>=10 THEN ADDN(N DIV 10,OTL);
 WITH OTL DO BEGIN
  LIN(/LEN/) := CHR((N MOD 10) + ORD('0'));
  LINT(/LEN/).LINC := BLANKLINC;
  LEN := LEN + 1;
  VLEN := VLEN + 1;
 END
END;     (* END OF ADDN *)


PROCEDURE ADDNUM(N: INTEGER; VAR OTL: LINE);
BEGIN
 IF N<0 THEN
  BEGIN
   WITH OTL DO BEGIN LIN(/LEN/) := '-'; LEN := LEN + 1;
                     VLEN := VLEN + 1;LINT(/LEN/).LINC := BLANKLINC END;
   ADDN(-N,OTL)
  END
 ELSE ADDN(N,OTL);
END;     (* END OF ADDNUM *)

PROCEDURE ADDCHR(C: CHAR);
BEGIN
 WITH OTL DO BEGIN
  LIN(/LEN/) := C;
  LINT(/LEN/).LINC := BLANKLINC;
  LEN := LEN + 1; VLEN := VLEN + 1;
 END;
END;     (* END OF ADDCHR *)
    (*$E           *)
PROCEDURE UNFLAG(VAR L: LINE; LOWER: BOOLEAN);
  (* LOWERS THE CASE ADDS OVERSTRIKES AND TRANSFERS STUFF FROM L TO TMPL *)
VAR
 FUP : 0..3;
 VCHN,RCHN: LLEN;
 SKIP,OVER: BOOLEAN;
 OUTF: CHAR;

 PROCEDURE OUT(C: CHAR);
 BEGIN
  RCHN := RCHN + 1;
  TMPL.LINT(/RCHN/).LINC := BLANKLINC;
  IF INLALPHA(C) OR INALPHA(C)
     THEN BEGIN    (*  ONLY INVERT LETTERS *)
          IF (OUTF <> ':') AND (NOT CAPNEXT) (* INVERT? *)
             THEN TMPL.LIN(/RCHN/) := LOWERTHECASE(C)
             ELSE TMPL.LIN(/RCHN/) := C;
          CAPNEXT := FALSE; (* RESET WHETHER USED OR NOT *)
          END
     ELSE TMPL.LIN(/RCHN/) := C;
  OUTF := ':';
 END;     (* END OF OUT *)

PROCEDURE OVERS(C: CHAR);
VAR Z: INTEGER;
BEGIN
 WITH TMPL DO
  BEGIN
   Z := ORD(LINT(/RCHN/).LINC(/4/));
   IF (Z<3) AND (RCHN>0) AND (Z>-1) THEN
    BEGIN
     Z := Z + 1;
     LINT(/RCHN/).LINC(/4/) := CHR(Z);
     LINT(/RCHN/).LINC(/Z/) := C;
    END
  END;
END;     (* END OF OVERS *)

BEGIN     (* UNFLAG *)
 WITH L DO
  BEGIN
     FUP := 0; (* NO CASE FORCING *)
     VCHN := 0;
     RCHN := 0;
     LN := 1;
     OUTF := ':';
     PQEND := FALSE;
     WHILE LN<=LEN DO
      BEGIN
       OVER := FALSE;
      IF NOT ( (LIN(/LN/) = '''' )  OR
               (LIN(/LN/) = '"'  )  OR
               (LIN(/LN/) = ')'  )       ) THEN PQEND := FALSE;
      SKIP := FALSE;
       CASE LIN(/LN/) OF
        '^':
          BEGIN
           LN := LN + 1;
           CASE FUP OF
            2: OUTF := '^';
            0:
             IF FLAG THEN
              BEGIN
               IF NOT(LOWER AND INALPHA( LIN(/LN/) ) ) THEN
                OUTF := '^';
              END
             ELSE  OUT('^');
            1:
           END;
          END;
        'A','B','C','D','E','F','G',
        'H','I','J','K','L','M','N',
        'O','P','Q','R','S','T','U',
        'V','W','X','Y','Z':
          CASE FUP OF
           0: IF LOWER AND FLAG THEN OUTF := '^';
           2: OUTF := '^';
           1:
          END;
        '@':
          BEGIN
           LN := LN + 1;
           IF FLAG  THEN BEGIN
                         CASE LIN(/LN/) OF
                               'A':LIN(/LN/):='@';
                               'B':LIN(/LN/):='^'
                              END;
                         OUTF:=':';
                         OUT(LIN(/LN/))
                         END;
          END;
        '<':
          IF FLAGCAPS THEN
           BEGIN FUP := FUP + 1; IF FUP=3 THEN FUP := 1; SKIP := TRUE;
           END;
        '.','?','!':
         BEGIN
         CAPNEXT := AUTOCAP AND LOWER;
         IF PERIOD THEN PQEND := TRUE;
         END;
        '_':
          IF ESCCHR THEN LN := LN + 1;
        '#':
         IF FLAGSIG THEN
          BEGIN
           OUT(' ');
           SKIP := TRUE;
           IF UNDL AND USB THEN OVERS('_');
          END;
        '\':
          IF FLAGOVER THEN
           BEGIN LN := LN + 1; OVER := TRUE; SKIP := TRUE END;
         '0'..'9' : CAPNEXT := FALSE;
        '+','-','*','/',
        '(',')','$','=',' ',',',
        '[',']',   '%','"',
        '&','''','>',';',':' :
       END;
       IF NOT SKIP THEN
        BEGIN
         OUT(LIN(/LN/)); VCHN := VCHN + 1;
         IF UNDL THEN OVERS('_');
        END
       ELSE IF OVER THEN OVERS(LIN(/LN/));
       LN := LN + 1
      END;
   WITH TMPL DO BEGIN LEN := RCHN; VLEN := RCHN END;
  END;
END;     (*$END OF UNFLAG *)
PROCEDURE ADRC(C: CHAR);
BEGIN
 WITH SYL DO
  BEGIN
   LEN := LEN + 1;
   IF ROMLC
      THEN LIN(/LEN/) := LOWERTHECASE(C)
      ELSE LIN(/LEN/) := C;
   LINT(/LEN/).LINC := BLANKLINC;
  END;
END;     (* END OF ADRC *)

PROCEDURE ROMAN(N: INTEGER);
BEGIN
    WHILE N > 1000 DO
       BEGIN     ADRC('M');    N := N - 1000;       END;
    IF N > 500 THEN
       BEGIN     ADRC('D');    N := N - 500;        END;
    WHILE N > 100 DO
       BEGIN     ADRC('C');    N := N - 100;        END;
    IF N > 50 THEN
       BEGIN     ADRC('L');    N := N - 50;         END;
    WHILE N > 10 DO
       BEGIN     ADRC('X');    N := N - 10;         END;
    IF N > 5 THEN
       BEGIN     ADRC('V');    N := N - 5;          END;
    WHILE N > 0 DO
       BEGIN     ADRC('I');    N := N - 1;          END;
END;     (* END OF ROMAN *)

PROCEDURE DOFMT(F,N: INTEGER);
BEGIN
SYL.LEN := 0;
IF (F>=0) AND (F<=5) THEN
 CASE F OF
  0: BEGIN SYL.LEN := 1; ADDNUM(N,SYL); SYL.LEN := SYL.LEN - 1; END;
  1: BEGIN
      SYL.LIN(/1/) := LETTERS(/ (N-1) MOD 26 /);
      SYL.LINT(/1/).LINC := BLANKLINC;
      SYL.LEN := 1;
     END;
  2: BEGIN
      SYL.LIN(/1/) := LOWERTHECASE(LETTERS(/ (N-1) MOD 26 /) );
      SYL.LINT(/1/).LINC := BLANKLINC;
      SYL.LEN := 1;
     END;
  3: BEGIN ROMLC := FALSE; ROMAN(N); END;
  4: BEGIN ROMLC := TRUE; ROMAN(N); END;
  5: BEGIN
      SYL.LIN(/1/) := CHR( N MOD CHARSIZE);
      SYL.LINT(/1/).LINC := BLANKLINC;
      SYL.LEN := 1;
     END
 END;
IF SYL.LEN>0 THEN BEGIN UNFLAG(SYL,FALSE); ADDWORD; END;
END;     (* END OF DOFMT *)

PROCEDURE BREAK;
BEGIN
 PUTLINE;
END;     (* END OF BREAK *)

PROCEDURE CR;
BEGIN
 FOR LN:=2 TO VAL(/VSP/) DO PUTBLANK;
END;     (* END OF CR *)

PROCEDURE ENDPARA;
BEGIN
 BREAK; CR;
END;     (* END OF ENDPARA *)

PROCEDURE BLANKLINE;
BEGIN
 IF (NOT AP) THEN
  BEGIN
   ENDPARA;
   PUTBLANK
  END
 ELSE BEGIN FORCECMD('.PP       ',3); SYMTYPE := COMMAND END;
END;     (* END OF BLANKLINE *)

PROCEDURE ENDLINE;
BEGIN
 IF SUP THEN CLRLINE;
 IF FORCE OR (NOT FILL) OR OTL.CENTER THEN BREAK;
 IF FORCE OR (NOT FILL) THEN CR;
END;      (* END OF ENDLINE *)

PROCEDURE FIN;
BEGIN
 PUTLINE;
 DOTOP;
  WRITELN;
  IF ERRORS > 0 THEN WRITELN(ERRORS:9,' ERRORS ENCOUNTERED.');
END;     (* END OF FIN *)
(*
PROCEDURE DBUGWORD;
BEGIN
 WITH SYL DO
  BEGIN
   WRITE(LEN,' ');
   FOR LN:=1 TO LEN DO WRITE(LIN(/LN/));
   WRITELN(' (',LEN:3,',',VLEN:3,')');
  END
END;     (* END OF DBUGWORD *)             *)

PROCEDURE PUTWORD;
BEGIN
 UNFLAG(SYL,LOWER);
 ADDWORD;
END;     (* END OF PUTWORD *)

PROCEDURE PUTVAR;
VAR N: INTEGER; S: SIGN;
BEGIN
 GETNUM(S,N);
 IF S<>INVALID THEN
  BEGIN
   IF SHOWEXPR THEN
    BEGIN
     SYL.LEN := 1;
     SYL.VLEN := 1;
     ADDNUM(N,SYL);
     SYL.LEN := SYL.LEN - 1;
     SYL.VLEN := SYL.VLEN - 1;
     PUTWORD;
    END
  END
 ELSE PUTWORD;
END;     (* END OF PUTVAR *)
 (*$E           *)
PROCEDURE INISTDMACS;
VAR P: PMAC;
BEGIN
 (* .FRCPAGE *)
 MACLSTP := NIL;
 NEW(P);
 WITH P@ DO
  BEGIN
   ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
   EN := 60; MT := HEADER; NP := 0;
   NEW(LI);
   FOR SUB := 1 TO 60 DO LI@(/SUB/) := LITERAL1(/SUB/);

   NM := 'FRCPAGE   ';
  END;
 MACLSTP := P; NEW(P);
 (* ..NMP *)
 WITH P@ DO
  BEGIN
   ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
   EN := 57; MT := HEADER; NP := 0;
   NEW(LI);
   FOR SUB := 1 TO 57 DO LI@(/SUB/) := LITERAL2 (/SUB/);

   NM := '.NMP      ';
  END;
 MACLSTP := P; NEW(P);
 (* ..NONMP *)
 WITH P@ DO
  BEGIN
   ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
   EN := 16; MT := HEADER; NP := 0;
   NEW(LI);
   FOR SUB := 1 TO 16 DO LI@ (/SUB/) := LITERAL3 (/SUB/);
   NM := '.NONMP    ';
  END;
 MACLSTP := P; NEW(P);
 (* ..TTL *)
 WITH P@ DO
  BEGIN
   ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
   EN := 1; MT := HEADER; NP := 0;
   NEW(LI); NM := '.TTL      ';
  END;
 MACLSTP := P; TTLMACP := P; NEW(P);
 (* ..STL *)
 WITH P@ DO
  BEGIN
   ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
   EN := 1; MT := HEADER; NP := 0;
   NEW(LI); NM := '.STL      ';
  END;
 MACLSTP := P; STLMACP := P; NEW(P);
 (* ..CH *)
 WITH P@ DO
  BEGIN
   ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
   EN := 65; MT := HEADER; NP := 0;
   NEW(LI);
   FOR SUB := 1 TO 38 DO LI@ (/SUB/) := LITERAL4(/SUB/);
   FOR SUB := 1 TO 27 DO LI@ (/SUB+38/) := LITERAL5(/SUB/);
   NM := '.CH       ';
  END;
 MACLSTP := P; NEW(P);
 (* ..CHT *)
 WITH P@ DO
  BEGIN
   ON := FALSE; MA := MACLSTP; CA := NIL; CU := 1; BE := 1;
   EN := 1; MT := HEADER; NP := 0;
   NEW(LI); NM := '.CHT      ';
  END;
 MACLSTP := P; CHTMACP := P;
END;     (* END OF INISTDMACS *)
 (*$E *)
PROCEDURE INIRELS;
BEGIN
 ARELOPR(/EQ/)       := 'EQ        ';
 ARELOPR(/GT/)       := 'GT        ';
 ARELOPR(/LT/)       := 'LT        ';
 ARELOPR(/NE/)       := 'NE        ';
 ARELOPR(/GE/)       := 'GE        ';
 ARELOPR(/LE/)       := 'LE        ';
END;     (* END OF INIRELS *)

PROCEDURE INIVARS;
BEGIN
 VID(/VPAGE/)        := '$PAGE     ';  VTY(/VPAGE/) := VITEM;
 VID(/VCH/)          := '$CH       ';  VTY(/VCH/) := VITEM;
 VID(/VHL/)          := '$HL       ';  VTY(/VHL/) := VARRAY;
         VUP(/VHL/) :=5;
 VID(/VLIST/)        := '$LIST     ';  VTY(/VLIST/) := VARRAY;
         VUP(/VLIST/) := 5;
 VID(/VLM/)          := '$LM       ';  VTY(/VLM/) := VITEM;
 VID(/VRM/)          := '$RM       ';  VTY(/VRM/) := VITEM;
 VID(/VSP/)          := '$SP       ';  VTY(/VSP/) := VITEM;
 VID(/VNMP/)         := '$NMP      ';  VTY(/VNMP/) := VITEM;
 VID(/VOLNO/)        := '$OLNO     ';  VTY(/VOLNO/) := VITEM;
 VID(/VPRM/)         := '$PRM      ';  VTY(/VPRM/) := VITEM;
 TV := 26;
 FOR LN := 1 TO VARMAX DO VAL(/LN/) := 0;
END;     (* END OF INIVARS *)

PROCEDURE INICMDS;
BEGIN
 CMDS(/CBLANK/)      := 'B         ';
 CMDS(/CFLAG/)       := 'FLAG      ';
 CMDS(/CFLAGCAPS/)   := 'FLAGCAPS  ';
 CMDS(/CFLAGOVER/)   := 'FLAGOVER  ';
 CMDS(/CFLAGSIG/)    := 'FLAGSIG   ';
 CMDS(/CLOWER/)      := 'LOWER     ';
 CMDS(/CUPPER/)      := 'UPPER     ';
 CMDS(/CPERIOD/)     := 'PERIOD    ';
 CMDS(/CBREAK/)      := 'BR        ';
 CMDS(/CCR/)         := 'CR        ';
 CMDS(/CESCCHR/)     := 'ESC       ';
 CMDS(/CASCII   /)   := 'ASCII     ';
 CMDS(/CCENTER/)     := 'C         ';
 CMDS(/CJUST/)       := 'J         ';
(*MDS(/CUL/)         := 'UL        ';
       *)
 CMDS(/CLMAR/)       := 'LM        ';
 CMDS(/CRMAR/)       := 'RM        ';
 CMDS(/CSUP/)        := 'SUP       ';
 CMDS(/CSTD/)        := 'STD       ';
 CMDS(/CPS/)         := 'PS        ';
 CMDS(/CLPT/)        := 'LPT       ';
 CMDS(/CSAV/)        := 'SAV       ';
 CMDS(/CP/)          := 'P         ';
 CMDS(/CRES/)        := 'RES       ';
 CMDS(/CPP/)         := 'PP        ';
 CMDS(/CSP/)         := 'SP        ';
 CMDS(/CS/)          := 'S         ';
 CMDS(/CTP/)         := 'TP        ';
 CMDS(/CNMP/)        := 'NMP       ';
 CMDS(/CPNO/)        := 'PNO       ';
 CMDS(/CTITLE/)      := 'TITLE     ';
 CMDS(/CST/)         := 'ST        ';
 CMDS(/CATITLE/)     := 'ATITLE    ';
 CMDS(/CLIST/)       := 'LIST      ';
 CMDS(/CLE/)         := 'LE        ';
 CMDS(/CELIST/)      := 'ELIST     ';
 CMDS(/CFIG/)        := 'FIG       ';
 CMDS(/CBAR/)        := 'BAR       ';
 CMDS(/CBB/)         := 'BB        ';
 CMDS(/CEB/)         := 'EB        ';
 CMDS(/CU/)          := 'U         ';
 CMDS(/CT/)          := 'T         ';
 CMDS(/CTAB/)        := 'TAB       ';
 CMDS(/CTABS/)       := 'TABS      ';
 CMDS(/CRT/)         := 'RT        ';
 CMDS(/CCH/)         := 'CH        ';
 CMDS(/CAP/)         := 'AP        ';
 CMDS(/CI/)          := 'I         ';
 CMDS(/CFILL/)       := 'F         ';
 CMDS(/CSIG/)        := 'SIG       ';
 CMDS(/CPAGE/)       := 'PAGE      ';
 CMDS(/CTOP/)        := 'TOP       ';
 CMDS(/CMID/)        := 'MID       ';
 CMDS(/CBOT/)        := 'BOT       ';
 CMDS(/CARRAY/)      := 'ARRAY     ';
 CMDS(/CFMT/)        := 'FMT       ';
 CMDS(/CIF/)         := 'IF        ';
 CMDS(/CASIS/)       := 'ASIS      ';
 CMDS(/CDOT/)        := 'DOT       ';
 CMDS(/CREM/)        := 'REM       ';
 CMDS(/CUPP/)        := 'UP        ';
 CMDS(/CUSB/)        := 'USB       ';
 CMDS(/CADD/)        := 'ADD       ';
 CMDS(/CHL/)         := 'HL        ';
 CMDS(/CRIGHT/)      := 'RIGHT     ';
 CMDS(/CLINES/)      := 'LINES     ';
 CMDS(/CMACRO/)      := 'MACRO     ';
 CMDS(/CX/)          := 'X         ';
 CMDS(/CVAR/)        := 'VAR       ';
 CMDS(/CINC/)        := 'INC       ';
 CMDS(/CDEC/)        := 'DEC       ';
 CMDS(/CSAVPAG/)     := 'SAVPAG    ';
 CMDS(/CRESPAG/)     := 'RESPAG    ';
 CMDS(/CDATE/)       := 'DATE      ';
 CMDS(/CTIME/)       := 'TIME      ';
 CMDS(/CDELMAC/)     := 'DELMAC    ';
 CMDS(/CAUTOCAP/)    := 'AUTOCAP   ';
 CMDS(/CDEBUG1/)     := 'DEBUG1    ';
 CMDS(/CDEBUG2/)     := 'DEBUG2    ';
 BREAKSET := (/CCENTER,CTITLE,CST,CI,CCH,CLE,CLIST,CELIST,CHL,CCR,
              CPP,CPAGE,CFIG,CS,CTP,CBLANK,CASIS,CBREAK,CRES,CRESPAG/);
 CRSET := BREAKSET - (/CBREAK,CBLANK,CRES,CRESPAG/);
END;     (*$END OF INICMDS *)
PROCEDURE BACKUPSYL;
BEGIN CUP := LASTCUP END;
     (* END OF BACKUPSYL *)

PROCEDURE POPMACROS; (* CLEAR ALL ACTIVE MACROS *)
BEGIN
 WHILE ACTP@.CA<>NIL DO
  BEGIN ACTP@.ON := FALSE; ACTP := ACTP@.CA; END
END;     (* END OF POPMACROS *)

PROCEDURE GETCUR;
   VAR I : INTEGER;
BEGIN
 IF NOT EOF(INPUT) THEN
  BEGIN
   ILNO := ILNO + 1;
   BEG := 1; CUP := 1; ENL := 1;
   WHILE NOT EOLN DO
    BEGIN CUR(/ENL/) := INPUT@; GET(INPUT); ENL := ENL + 1 END;
   CUR(/ENL/) := ' ';
   WITH ACTP@ DO
    BEGIN LI@ := CUR; BE := BEG; EN := ENL END;
   READLN(INPUT);
   WRITE (QRR,' ',ILNO:6,'  ');
   FOR I := 1 TO ENL DO WRITE (QRR,CUR(/I/) );
   WRITELN(QRR);
  END
 ELSE EOFINPUT := TRUE
END;     (* END OF GETCUR *)

PROCEDURE GETTOKEN;
BEGIN        (* GETTOKEN *)
 IF DEFRSYM THEN DEFRSYM := FALSE
 ELSE
  WITH SYL DO
   BEGIN
    FOR LN:=1 TO MACMAX+1 DO BEGIN LIN(/LN/) := ' ';
                                   LINT(/LN/).LINC := BLANKLINC    END;
    LEN := 0;
    VLEN := 0;
    LASTCUP := CUP;
    IF (CUR(/CUP/)=' ') AND SIGBL AND NOT CMMD THEN
     WHILE (CUP<ENL) AND (CUR(/CUP/)=' ') DO
      BEGIN LEN := LEN + 1; LIN(/LEN/) := CUR(/CUP/); CUP := CUP + 1;
                  LINT(/LEN/).LINC := BLANKLINC   END
    ELSE
     BEGIN
      WHILE (CUP<ENL) AND (CUR(/CUP/)=' ') DO CUP := CUP + 1;
      CUR(/ENL/) := ' ';
      WHILE (CUR(/CUP/) <> ' ') AND (CUP <= ENL) DO
       BEGIN LEN := LEN + 1; LIN(/LEN/) := CUR(/CUP/); CUP := CUP + 1;
                    LINT(/LEN/).LINC := BLANKLINC; END
     END
   END;
END;     (* END OF GETTOKEN *)

PROCEDURE GETMACSYM;
VAR EXIT: BOOLEAN;
BEGIN      (*GETMACSYM *)
 REPEAT
  GETTOKEN;
  EXIT := TRUE;
  IF SYL.LEN=0 THEN
   BEGIN
    ACTP@.ON := FALSE;
    IF ACTP@.CA<>NIL THEN
     BEGIN
      EXIT := FALSE;
      ACTP := ACTP@.CA;
      WITH ACTP@ DO
       BEGIN
        CUR := LI@;
        CUP := CU; BEG := BE; ENL := EN;
       END
     END
   END
 UNTIL EXIT
END;     (* END OF GETMACSYM *)

PROCEDURE EXPMACRO(T: PMAC);
VAR N: 0..8;
BEGIN  (* EXPMACRO *)
 T@.CA := ACTP;                                  (* CHAIN NEW MACRO  *)
 ACTP := T;                                      (* NEW CURRENT MACRO*)
 IF T@.NP<8 THEN                                 (* SCAN PARMS       *)
  FOR N:=T@.NP DOWNTO 1 DO
   BEGIN
    T := T@.MA;                                  (* PARM MACRO       *)
    WITH T@ DO
     BEGIN
      BE := CUP;
      GETTOKEN;
      EN := CUP;
      LI@ := ACTP@.CA@.LI@;
     END
   END
 ELSE
  BEGIN                                    (* REST OF LINE IS PARM *)
   T := T@.MA;
   WITH T@ DO
    BEGIN BE := CUP; EN := ENL; LI@ := ACTP@.CA@.LI@ END;
   CUP := ENL
  END;
 ACTP@.CA@.CU := CUP;
 WITH ACTP@ DO                                   (* NOW FILL CUR   *)
  BEGIN
   ON := TRUE;
   CUP := BE; BEG := BE; ENL := EN;
   CUR := LI@;


  END;
END;      (* END OF EXPMACRO *)

PROCEDURE LOOKUPVAR;
VAR T: ALFA;
BEGIN  (* LOOKUPVAR *)
 UPCASESYL;
 FOR SUB := 1 TO 10 DO T(/SUB/) := SYL.LIN(/SUB+1/);
 VID(/TV/) := T;
 VARNDX := 1;
 WHILE VID(/VARNDX/)<>T DO VARNDX := VARNDX + 1;
END;     (* END OF LOOKUPVAR *)

PROCEDURE LOOKUPMAC;
VAR L: MACSYM;
 T: PMAC;
 EXIT: BOOLEAN;
BEGIN
 UPCASESYL;
 FOR SUB := 1 TO 10 DO L(/SUB/) := SYL.LIN (/SUB + 1/);
 T := MACLSTP;
 EXIT := FALSE;
 REPEAT
  IF T=NIL THEN BEGIN EXIT := TRUE; NOTMACRO := TRUE END
  ELSE
   IF L=T@.NM THEN
    BEGIN EXIT := TRUE;
     IF T@.ON THEN
      BEGIN
       ERR; WRITE('RECURSIVE MACRO CALL TO'); SYLERR;
       NOTMACRO := FALSE;
      END
     ELSE
      BEGIN
       EXPMACRO(T);
       NOTMACRO := FALSE;
      END
    END
  ELSE T := T@.MA
 UNTIL EXIT;
END;     (* END OF LOOKUPMAC *)


PROCEDURE GETSYM;
VAR
 START: 2..4;
 I,J: INTEGER;
 PIN:  ARRAY (/1..10/) OF CHAR;
BEGIN   (* GETSYM *)
  WITH SYL DO
   BEGIN
    REPEAT
     GETMACSYM;
     NOTMACRO := TRUE;
     IF LIN(/1/)=MACCHR THEN LOOKUPMAC
    UNTIL NOTMACRO;
    IF LEN=0 THEN SYMTYPE := NONE
    ELSE IF (NOT (INDIGIT ( LIN(/2/) ))) AND (LIN(/1/)=CMDCHR) THEN
     BEGIN
      SYMTYPE := COMMAND;
      START := 2;
      YES := TRUE;
      IF (LEN>3) AND (LIN(/2/)='N') AND (LIN(/3/)='O') THEN
       BEGIN YES := FALSE; START := 4 END;
      FOR LN:=LEN+1 TO START+9 DO BEGIN LIN(/LN/) := ' ';
                                  LINT(/LN/).LINC := BLANKLINC END;
      FOR SUB := 1 TO 10 DO PIN(/SUB/) := LIN(/SUB + START -1/);
      CMDS(/NOTCMD/) := PIN;
      CMDTYPE := CBLANK;
      WHILE PIN<>CMDS(/CMDTYPE/) DO CMDTYPE := SUCC(CMDTYPE);
      IF CMDTYPE=NOTCMD THEN
       BEGIN ERR; WRITE('UNKNOWN COMMAND'); SYLERR END;
     END
    ELSE IF (SYL.LIN(/1/)=VARCHR)
            AND  NOT (INDIGIT(SYL.LIN(/2/)) OR (SYL.LIN(/2/)=' ') )  THEN
              SYMTYPE := VARS
    ELSE SYMTYPE := WORD
   END;
END;     (* END OF GETSYM *)

PROCEDURE ALLOC(VAR T: PMAC);
LABEL 1;
VAR P: PMAC;
BEGIN           (* ALLOC *)
 P := FREEMACP;
 1:
  IF P<>NIL THEN
   IF P@.ON THEN BEGIN P := P@.MA; GOTO 1 END;
 IF P=NIL THEN
  BEGIN
   NEW(T);
   NEW(T@.LI);
   T@.MA := FREEMACP;
   FREEMACP := T;
  END
 ELSE T := P;
END;     (* END OF ALLOC *)

PROCEDURE PUSHSYL (* (S:LINE) ; FROM THE FORWARD DECL *)  ;
VAR M: PMAC;
BEGIN
 ALLOC(M);
 WITH M@ DO
  BEGIN
   ON := FALSE;
   CU := 1; BE := 1; EN := S.LEN + 1;
   MT := HEADER; NP := 0;
   LI@ := S.LIN;
   NM := '* DEFER * ';
  END;
 EXPMACRO(M);
END;     (* END OF PUSHSYL *)

FUNCTION GETEXP: INTEGER;
BEGIN
 GETSYM;
 EP := 0;
 NEXTCH;
 GETEXP := EXPR;
END;     (* END OF GETEXP *)


PROCEDURE SETSTD;
BEGIN
 FLAG := YES; FLAGCAPS := YES; LOWER := YES;
 ESCCHR := YES; PERIOD := YES; JUSTIT := YES;
 LOWER := YES; FILL := YES; SIGBL := NOT YES;
 IF YES THEN OPTBRKSET := BREAKSET
 ELSE OPTBRKSET := (//);
END;     (* END OF SETSTD *)
 (*$E *)
PROCEDURE DOCOMMAND;
VAR
 S: SIGN;
 I,N,LN: INTEGER;
 N8: 0..8;
 L: LLEN;
 TMACP,MACP: PMAC;
 EXIT: BOOLEAN;
 TL: LINE;
 VTEMP: 1..VARMAX;
 V: ALFA;

PROCEDURE STUFFMAC(P: PMAC);
BEGIN     (* STUFFMAC *)
 WITH P@ DO
  IF YES THEN
   BEGIN
    LI@ := CUR;
    BE := CUP; CU := CUP; EN := ENL;
    CUP := ENL;
   END
  ELSE CU := EN;
END;    (* END OF STUFFMAC *)

PROCEDURE SYLTOMAC;
BEGIN
 WITH TMACP@ DO
  BEGIN
   FOR SUB := 1 TO MACMAX DO NM(/SUB/) := SYL.LIN(/SUB/);
   CU := 0; BE := 0; EN := 0; NP := 0;
   CA := NIL; LI := ACTP@.LI; ON := FALSE;
  END;
END;     (* END OF SYLTOMAC *)

PROCEDURE MAKPARM;
BEGIN
 SYL := TL;
 ADDNUM(N-N8+1,SYL);
 NEW(TMACP); SYLTOMAC;
 WITH TMACP@ DO
  BEGIN
   MA := MACP@.MA; MACP@.MA := TMACP;
   NP := 0; MT := PARM;
   NEW(LI);
   MACP := TMACP;
  END;
END;     (* END OF MAKPARM *)

PROCEDURE CLRLISTS;
BEGIN
 ENP := 0;
 VAL(/VLIST/) := 0;
END;     (* END OF CLRLISTS *)

PROCEDURE GETOPTN;
BEGIN
 GETSYM;
 IF ((INDIGIT( SYL.LIN(/1/))) OR
     (SYL.LIN (/1/) = '$')    OR
     (SYL.LIN (/1/) = '(')        )      THEN
  BEGIN
   GETNUM(S,N);
   IF (S=INVALID) OR (N<=0) THEN
    BEGIN
     ERR; WRITE('EXPECTING POSITIVE NUMBER; GOT'); SYLERR;
     S := INVALID;
    END;
  END
 ELSE BEGIN BACKUPSYL; S := INVALID; END;
END;     (* END OF GETOPTN *)

PROCEDURE GETSN;
BEGIN GETSYM; GETNUM(S,N) END;
     (* END OF GETSN *)                                   (*$E *)
    PROCEDURE CPPROC;  (* MOVED HERE FOR ADDRESABILITY REASONS *)
       BEGIN          (* CPPROC *)
        GETSN;
        IF (S<>INVALID) THEN
         BEGIN
          CASE S OF
           UNSIGNED: BEGIN PREL := FALSE; PMAR := N END;
           MINUS:    BEGIN PREL := TRUE;  PMAR := -N END;
           PLUS:     BEGIN PREL := TRUE;  PMAR := N END
          END;
          GETSN;
          IF (S=UNSIGNED) AND (N>=0) AND (N<=5) THEN
           BEGIN
            PARSPACE := N;
            GETSN;
            IF (S=UNSIGNED) THEN
             PARTEST := N
            ELSE BEGIN ERR; WRITE('PARAGRAPH TP'); SYLERR END
           END
          ELSE BEGIN ERR; WRITE('PARAGRAPH SPACE'); SYLERR END
         END
        ELSE BEGIN ERR; WRITE('PARAGRAPH INDENT'); SYLERR END
       END;       (* CPPROC *)




     PROCEDURE CHLPROC;   (* MOVED HERE FOR ADDRESSABILITY REASONS *)
     BEGIN     (* CHLPROC *)
       IF (OVETXT-VAL(/VOLNO/)+1)>8 THEN
        BEGIN
         CLRLISTS;
         GETSN;
         IF (S=UNSIGNED) AND (N>0) AND (N<=VHLMAX) AND
         (N<=VAL(/VHL/)+1) THEN
          BEGIN
           IF FIRSTCH THEN BEGIN SAVENV(PAGENV); FIRSTCH := FALSE END;
           RESENV(PAGENV); ENP := 0; CLRLINE;
           FOR LN:=1 TO 3 DO PUTBLANK;
           IF N>VAL(/VHL/) THEN VAL(/VHL+N/) := 0;
           VAL(/VHL/) := N;
           N := VHL + N;
           VAL(/N/) := VAL(/N/) + 1;
           IF VAL(/VCH/)>0 THEN BEGIN LN := VHL+1; ADDNUM(VAL(/VCH/),OTL) END
              ELSE BEGIN LN := VHL+2; ADDNUM(VAL(/VHL+1/),OTL) END;
           FOR LN:=LN TO N DO BEGIN ADDCHR('.'); ADDNUM(VAL(/LN/),OTL) END;
           ADDCHR(' '); ADDCHR(' ');
           DEFRB := 1; FORCE := TRUE;
          END
         ELSE BEGIN ERR; WRITE('BAD HEADER LEVEL'); SYLERR END;
        END
       ELSE BEGIN BACKUPSYL; FORCECMD('.FRCPAGE  ',8) END;
       CAPNEXT := AUTOCAP AND LOWER;
    END;        (* CHLPROC *)                                    (*$E *)



    PROCEDURE CMACROPROC;    (* MOVED HERE FOR ADDRESSABILITY REASONS *)
     BEGIN    (* CMACROPROC *)
       IF ACTP@.CA=NIL THEN
        BEGIN
         GETTOKEN;
         IF SYL.LEN<>0 THEN
          BEGIN
           NEW(TMACP);
           UPCASESYL;
           SYLTOMAC;
           NEW(TMACP@.LI);
           TMACP@.MA := MACLSTP;
           TMACP@.MT := HEADER;
           TL := SYL;                              (* SAVE MACRO NAME  *)
           TL.LEN := TL.LEN + 1;                   (* FOR ADDNUM       *)
           IF TL.LEN>10 THEN TL.LEN := 10;
           GETTOKEN;
           IF NOT ((SYL.LIN(/1/) = '*' ) OR
                   (SYL.LIN(/1/) = '=' ) ) THEN GETNUM (S,N)
               ELSE S := INVALID;
           IF S=UNSIGNED THEN GETTOKEN
              ELSE IF (SYL.LIN(/1/)='*') AND (SYL.LEN=1) THEN
                      BEGIN N := 8; GETTOKEN END
                      ELSE N := 0;
           IF (SYL.LIN(/1/)='=') AND (SYL.LEN=1) THEN
              BEGIN
              MACLSTP := TMACP;
              WITH TMACP@ DO
                BEGIN
                FOR SUB:=1 TO (LINLEN-CUP+1) DO LI@ (/SUB/):=CUR(/SUB-1+CUP/);
                BE := 1;
                EN := ENL-CUP+1;
                CU := 1
                END;
              IF N<8 THEN
               BEGIN
                TMACP@.NP := N;
                MACP := MACLSTP;
                FOR N8:=N DOWNTO 1 DO MAKPARM
                END
             ELSE
              BEGIN
               TMACP@.NP := 8; N8 := N;
               MACP := MACLSTP;
               MAKPARM
              END;
             CUP := ENL;
            END
           ELSE BEGIN ERR; WRITE('MISSING = IN MACRO DEF'); ERRE END
          END
         ELSE BEGIN ERR; WRITE('NO MACRO NAME'); ERRE END;
        END
       ELSE BEGIN ERR; WRITE('NESTED MACRO DEFS'); ERRE END;
      END;    (* CMACROPROC *)




     PROCEDURE CVARPROC;   (* MOVED HERE FOR ADDRESSABILITY REASONS *)
       BEGIN
        GETSYM;
        IF SYMTYPE=VARS THEN
         BEGIN
          LOOKUPVAR;
          IF VARNDX<VARMAX THEN
           BEGIN
            IF VARNDX=TV THEN
             BEGIN TV := TV + 1; VTY(/VARNDX/) := VITEM END;
            GETMACSYM;
            IF (SYL.LEN=1) AND (SYL.LIN(/1/)='=') THEN
             BEGIN
              GETSN;
              IF S<>INVALID THEN
               BEGIN
                IF S=MINUS THEN N := -N;
                VAL(/VARNDX/) := N
               END
             END
            ELSE BACKUPSYL
           END
          ELSE BEGIN ERR; WRITE('TOO MANY VARIABLES'); ERRE END
         END
        ELSE BEGIN ERR; WRITE('NEED VAR NAME; GOT'); SYLERR END
     END;        (* CVARPROC *)



     PROCEDURE CARRAYPROC;  (* MOVED HERE FOR ADDRESABILITY REASONS *)
       BEGIN
        GETSYM;
        IF SYMTYPE=VARS THEN
         BEGIN
          LOOKUPVAR;
          IF VARNDX=TV THEN
            BEGIN
            N := GETEXP;
            IF (N>0) AND (NOT EXPRERR) THEN
             IF N+TV<VARMAX THEN
              BEGIN
               TV := TV + N + 1;
               VUP(/VARNDX/) := N;
               VTY(/VARNDX/) := VARRAY;
              END
             ELSE BEGIN ERR; WRITE('NO ROOM FOR ARRAY ',VID(/VARNDX/)); ERRE
                  END
            ELSE BEGIN ERR; WRITE('BAD ARRAY SIZE'); SYLERR END
           END
          ELSE BEGIN ERR; WRITE('ALREADY DECLARED'); SYLERR END
         END
        ELSE BEGIN ERR; WRITE('NOT A VARIABLE SYMBOL'); SYLERR END
       END;        (* CARRAYPROC *)



     PROCEDURE CASISPROC;    (* MOVED HERE FOR ADDRESABILITY REASONS *)
       BEGIN
        POPMACROS;
        FOR I:=1 TO LINLEN DO BEGIN OTL.LIN(/I/) := ' ';
                                    OTL.LINT(/I/).LINC := BLANKLINC  END;
        IF NOT EOF(INPUT) THEN
         REPEAT
          GETCUR;
          IF CUR(/1/)<>'!' THEN
           BEGIN
            LN := VAL(/VLM/); CUP := 1;
            WHILE CUP < ENL DO (* EACH ITERATION ADDS 1 CHAR TO OTL *)
             BEGIN
              OTL.LIN(/LN/) := CUR(/CUP/);
              OTL.LINT(/LN/).LINC := BLANKLINC;
              CUP := CUP + 1; LN := LN + 1;
             END;
            OTL.LEN := LN; CUP := ENL;
            EMPTY := FALSE;
            PUTLINE;
           END;
         UNTIL (CUR(/1/)='!') OR DEFRSYM OR EOFINPUT;
        CUP := CUP+1;
        IF DEFRSYM THEN PUSHSYL(FRCSYL);
       END;     (* CASISPROC *)
  (*$E    *)
BEGIN       (* DOCOMMAND *)
 IF CMDTYPE<=CDEC THEN BEGIN          (* PROTECT AGAINST SET OUT OF RANGE *)
                       IF CMDTYPE IN OPTBRKSET THEN BREAK;
                       IF CMDTYPE IN CRSET THEN CR;           END;
 (* ABOVE BREAK MAY FORCE PAGE EJECT;
    USE DEFRSYM FLAG TO TEST FOR THIS
    AND RE-DO COMMAND AFTER EJECT *)
 IF DEFRSYM THEN PUSHSYL(FRCSYL)
 ELSE
 WITH SYL DO
  BEGIN
   CASE CMDTYPE OF

    CBLANK,CLMAR,CRMAR,CPS,CP,CI,CSP,
    CS,CTP,CHL,CPNO,CLIST,CFIG,CTAB,
    CTABS,CRIGHT,CLINES,CMACRO,CVAR,
    CINC,CDEC,CARRAY,CIF,CUPP:

     CMMD := TRUE;

    CCR,CBREAK,CRESPAG,CRES,CESCCHR,
    CASCII,CCENTER,CJUST,(*CUL,*)CFILL,
    CSIG,CPAGE,CSUP,CLPT,CSTD,CSAV,
    CPP,CAP,CCH,CNMP,CTITLE,CST,
    CATITLE,CLE,CELIST,CBAR,CBB,CEB,
    CU,CT,CRT,CX,CASIS,CDATE,CTIME,
    CFLAG,CFLAGCAPS,
    CFLAGOVER,CFLAGSIG,CLOWER,CUPPER,
    CPERIOD,CSAVPAG,CTOP,
    CMID,CBOT,CFMT,CDOT,CREM,CUSB,CADD,CAUTOCAP,CDEBUG1,CDEBUG2,NOTCMD:

   END;
   CASE CMDTYPE OF
    CBLANK:
     (* BREAK FOLLOWED BY N EXTRA BLANK LINES *)
     BEGIN
      GETOPTN;
      IF S<>INVALID THEN FOR LN:=1 TO N DO PUTBLANK
      ELSE PUTBLANK;
     END;
    CFLAG:
     FLAG := YES;
    CFLAGCAPS:
     FLAGCAPS := YES;
    CLOWER:
     LOWER := YES;
    CUPPER:
     LOWER := NOT YES;
    CESCCHR:
     ESCCHR := YES;
    CPERIOD:
     PERIOD := YES;
    CBREAK:
     (* DOESN'T DO ANYTHING *)
     BEGIN END;
    CCR:
     (* DOESN'T DO ANYTHING *)
     BEGIN END;
    CASCII:
     LOWER := NOT YES;
    CCENTER:
     OTL.CENTER := TRUE;
    CJUST:
     JUSTIT := YES;
(*  CUL:
     UL := YES;              *)
    CLMAR:
     BEGIN GETSN;
      IF OTL.LEN=VAL(/VLM/) THEN OTL.LEN := 0;
      CASE S OF
       MINUS:    IF (VAL(/VLM/)-N)<0 THEN
                  BEGIN ERR; WRITE('LM<0'); ERRE END
                 ELSE VAL(/VLM/) := VAL(/VLM/) - N;
       PLUS:     IF (VAL(/VLM/)+N)>136 THEN
                  BEGIN ERR; WRITE('LM>136'); ERRE END
                 ELSE VAL(/VLM/) := VAL(/VLM/) + N;
       UNSIGNED: IF (N<1) OR (N>136) THEN
                  BEGIN ERR; WRITE('LM OUT OF RANGE'); ERRE END
                 ELSE VAL(/VLM/) := N;
       INVALID:  BEGIN ERR; WRITE('LM FOLLOWED BY'); SYLERR END
      END;
      IF OTL.LEN=0 THEN
       BEGIN OTL.LEN := VAL(/VLM/); OTL.VLEN := VAL(/VLM/);
        FOR LN:=1 TO VAL(/VLM/) DO BEGIN OTL.LIN(/LN/) := ' ';
                                        OTL.LINT(/LN/).LINC := BLANKLINC  END;
       END
     END;
    CRMAR:
     BEGIN GETSN;
      CASE S OF
       PLUS:     IF (VAL(/VRM/)+N)>136 THEN
                  BEGIN ERR; WRITE('RM>136'); ERRE END
                 ELSE VAL(/VRM/) := VAL(/VRM/) + N;
       MINUS:    IF (VAL(/VRM/)-N)<1 THEN
                  BEGIN ERR; WRITE('RM<1'); ERRE END
                 ELSE VAL(/VRM/) := VAL(/VRM/) - N;
       UNSIGNED: IF (N<1) OR (N>136) THEN
                  BEGIN ERR; WRITE('RM OUT OF RANGE'); ERRE END
                 ELSE VAL(/VRM/) := N;
       INVALID:  BEGIN ERR; WRITE('RM FOLLOWED BY'); SYLERR END
      END;
     END;
    CFILL:
     FILL := YES;
    CSIG:
     SIGBL := YES;
    CPAGE:  BEGIN
            FORCECMD('.FRCPAGE  ',8);
            CAPNEXT := AUTOCAP AND LOWER;
            END;
    CTOP:
     DOTOP;
    CMID:
     DOMID;
    CBOT:
     DOBOT;
    CSUP:
     SUP := YES;
    CLPT:
     LPT := YES;
    CSTD:
     SETSTD;
    CPS:
     BEGIN
      GETSN;
      IF (S=UNSIGNED) AND (N>10) THEN
       BEGIN
        OETXT := N;
        OVETXT := N - 1;
        GETSN;
        IF (S=UNSIGNED) AND (N>0) THEN
         BEGIN
          VAL(/VPRM/) := N;
          PAGENV.PRM := N;
         END
        ELSE BEGIN ERR; WRITE('INVALID PS COLUMN'); SYLERR END
       END
      ELSE BEGIN ERR; WRITE('INVALID PS LINES'); SYLERR END
     END;
    CSAV:
     PSHENV;
    CP: CPPROC;
    CRES:
     BEGIN POPENV; CLRLINE END;
    CPP:
     PARAGRAPH;
    CAP:
     AP := YES;
    CI:
     BEGIN
      GETSN;
      IF S<>INVALID THEN
       BEGIN
        CASE S OF
         PLUS:     N := N + VAL(/VLM/);
         MINUS:    N := VAL(/VLM/) - N;
         UNSIGNED:
        END;
        IF N>0 THEN
         BEGIN
          WITH OTL DO BEGIN
           LEN := N; VLEN := N;
           FOR LN:=1 TO N DO BEGIN LIN(/LN/) := ' ';
                                  LINT(/LN/).LINC := BLANKLINC    END;
          END
         END
        ELSE BEGIN ERR; WRITE('INDENT LESS THAN 0'); ERRE END
       END
      ELSE BEGIN ERR; WRITE('I FOLLOWED BY'); SYLERR END
     END;
    CSP:
     BEGIN
      GETSN;
      IF (S<>INVALID) AND (N>=1) AND (N<=5) THEN VAL(/VSP/) := N
      ELSE BEGIN ERR; WRITE('S FOLLOWED BY'); SYLERR END
     END;
    CS:
     (* RETURN PLUS N EXTRA CARRIAGE RETURNS *)
     BEGIN
      GETOPTN;
      IF S<>INVALID THEN FOR LN:=1 TO N*VAL(/VSP/) DO PUTBLANK
      ELSE FOR LN:=1 TO VAL(/VSP/) DO PUTBLANK;
     END;
    CTP:
     BEGIN
      GETSN;
      IF S=UNSIGNED THEN TESTPAGE(N)
      ELSE BEGIN ERR; WRITE('TP FOLLOWED BY'); SYLERR END
     END;
    CCH:
     BEGIN
      YES := TRUE;
      LN := CUP; (*SAVE THIS*)
      STUFFMAC(CHTMACP);
      IF ATITLE THEN
       BEGIN
        CUP := LN; (*SAME AS ABOVE*)
        STUFFMAC(TTLMACP);
        STUFFMAC(STLMACP);
       END;
      FORCECMD('..CH      ',4);    CAPNEXT := AUTOCAP AND LOWER;
     END;
    CHL: CHLPROC;
    CNMP:
     IF YES THEN VAL(/VNMP/) := 1 ELSE VAL(/VNMP/) := 0;
    CPNO:
     BEGIN
      GETSN;
      IF (S=UNSIGNED) AND (N<1000) THEN VAL(/VPAGE/) := N - 1
      ELSE BEGIN ERR; WRITE('PAGE NUMBER WAS'); SYLERR END
     END;
    CTITLE:
     BEGIN STUFFMAC(TTLMACP); CAPNEXT := AUTOCAP AND LOWER; END;
    CST:
     BEGIN STUFFMAC(STLMACP); CAPNEXT := AUTOCAP AND LOWER; END;
    CATITLE:
     ATITLE := YES;
    CLIST:
     BEGIN
      GETSN;
      IF (S=UNSIGNED) AND (N>0) AND (N<6) THEN
       BEGIN
        PSHENV;
        IF VAL(/VLIST/)=0 THEN VAL(/VLM/) := VAL(/VLM/) + 9
        ELSE VAL(/VLM/) := VAL(/VLM/) + 4;
        VAL(/VLIST/) := VAL(/VLIST/) + 1;
        VAL(/VLIST+VAL(/VLIST/)/) := 0;
        VAL(/VSP/) := N;
        PARSPACE := N + 1;
        PMAR := 0;
        PREL := TRUE;
        PSHENV;
       END
      ELSE BEGIN ERR; WRITE('LIST SPACING'); SYLERR END;
     END;
    CLE:
     IF VAL(/VLIST/)>0 THEN
      BEGIN
       FOR LN:=1 TO VAL(/VSP/) DO PUTBLANK;
       RESENV(ENSTK(/ENP-1/));
       CLRLINE;
       VAL(/VLIST+VAL(/VLIST/)/) := VAL(/VLIST+VAL(/VLIST/)/) + 1;
       OTL.LEN := VAL(/VLM/) - 4;
       ADDNUM(VAL(/VLIST+VAL(/VLIST/)/),OTL);
       ADDCHR('.');
       OTL.LEN := VAL(/VLM/);
       OTL.VLEN := VAL(/VLM/);
      END
     ELSE BEGIN ERR; WRITE('NO ACTIVE LIST'); ERRE END;
    CELIST:
     IF VAL(/VLIST/)>0 THEN
      BEGIN
       VAL(/VLIST/) := VAL(/VLIST/) - 1;
       POPENV; POPENV; CLRLINE;
      END
     ELSE BEGIN ERR; WRITE('NO ACTIVE LIST'); ERRE END;
    CFIG:
     BEGIN
      GETSN;
      IF (S=UNSIGNED) THEN
       BEGIN
        IF N<=OVETXT-VAL(/VOLNO/)+1 THEN
         BEGIN
          OVBTXT := 0; (* SO PUTBLANK WORKS *)
          FOR LN:=1 TO N DO PUTBLANK
         END
        ELSE
         BEGIN
          IF FIGP<FIGMAX THEN
           BEGIN
            FIGP := FIGP + 1;
            FIGN(/FIGP/) := N;
           END
          ELSE BEGIN ERR; WRITE('TOO MANY PENDING FIGS'); ERRE END
         END
       END
      ELSE BEGIN ERR; WRITE('FIG FOLLOWED BY'); SYLERR END
     END;
    CBAR:
     BAR := YES;
    CBB:
     BEGIN BB := TRUE; OTL.BBAR := TRUE END;
    CEB:
       BEGIN
      IF EMPTY THEN OTL.BBAR := FALSE;
      BB := FALSE;
     END;
    CU:
     UNDL := YES;
    CT:
     T := TRUE;
    CTAB,CTABS:
     BEGIN
      L := 1;
      CLRTAB;
      REPEAT
       GETOPTN;
       IF S<>INVALID THEN
        IF L<=TABMAX THEN BEGIN TABS(/L/) := N; L := L + 1 END
      UNTIL S=INVALID;
      BACKUPSYL;
     END;
    CRT:
     RT := TRUE;
    CDOT:
     DOT := YES;
    CRIGHT:
     BEGIN
      GETSN;
      IF (S=UNSIGNED) AND (N<=136) THEN RIGHTSPACE := N
      ELSE BEGIN ERR; WRITE('RIGHT SPACE '); SYLERR END
     END;
    CLINES:
     BEGIN
      GETSN;
      IF (S=UNSIGNED) THEN
       OEPAG := N
      ELSE BEGIN ERR; WRITE('LINES FOL BY'); SYLERR END
     END;
    CMACRO: CMACROPROC;
    CX:
     BEGIN XTEND := YES; CAPNEXT := FALSE END;
    CVAR: CVARPROC;
    CINC:
     BEGIN
      GETSYM;
      IF SYMTYPE=VARS THEN
       IF VARNDX<TV THEN VAL(/VARNDX/) := VAL(/VARNDX/) + 1
       ELSE BEGIN ERR; WRITE('UNDEDECLARED VAR'); SYLERR END
      ELSE BEGIN ERR; WRITE('INC FOLLOWED BY'); SYLERR END
     END;
    CDEC:
     BEGIN
      GETSYM;
      IF SYMTYPE=VARS THEN
       IF VARNDX<TV THEN VAL(/VARNDX/) := VAL(/VARNDX/) - 1
       ELSE BEGIN ERR; WRITE('UNDECLARED VAR'); SYLERR END
      ELSE BEGIN ERR; WRITE('DEC FOLLOWED BY'); SYLERR END
     END;
    CSAVPAG:
     BEGIN SAVENV(PAGENV); FIRSTCH := FALSE END;
    CRESPAG:
     RESENV(PAGENV);
    CARRAY: CARRAYPROC;
    CFMT:
     BEGIN N := GETEXP; DOFMT(N,GETEXP) END;
    CIF:
     IF GETEXP=0 THEN CUP := ENL;
    CASIS: CASISPROC;
    CFLAGOVER:
     FLAGOVER := YES;
    CFLAGSIG:
     FLAGSIG := YES;
    CREM:
     CUP := ENL; (* MAKES REST OF LINE A COMMENT *)
    CUPP:
     (* FORCE NEXT SYMBOL UPPER *)
     BEGIN GETSYM; UPCASESYL; ADDWORD; END;
    CUSB:
     USB := YES;
    CADD:
     ADDWORD;
    CDATE:
     BEGIN
   (* DATE(V); *)    V:='          ';
      WITH SYL DO
       BEGIN
        FOR I:=3 TO 6 DO BEGIN LIN(/I/) := V(/I+1/);
                         LINT(/I/).LINC := BLANKLINC END;
        LIN(/1/) := V(/8/); LIN(/2/) := V(/9/);
        LIN(/7/) := V(/2/); LIN(/8/) := V(/3/);
        LEN := 8;
       END;
      PUTWORD;
     END;
    CTIME:
     BEGIN
    (*TIME(V); *)     V:='          ';
      WITH SYL DO
       BEGIN
        FOR I:=1 TO 5 DO BEGIN LIN(/I/) := V(/I+1/);
                         LINT(/I/).LINC := BLANKLINC    END;
        LIN(/3/) := ':';
       END;
      PUTWORD;
     END;
   CDELMAC:
    BEGIN
     TMACP := MACLSTP;
     GETTOKEN;
     IF SYL.LEN<>0 THEN
      BEGIN
       UPCASESYL;
       FOR SUB := 1 TO 10 DO V(/SUB/) := SYL.LIN(/SUB/);
       WHILE (TMACP@.NM<>V) AND (TMACP<>CHTMACP) DO
        BEGIN MACP := TMACP; TMACP := TMACP@.MA; END;
       IF TMACP=CHTMACP THEN
        BEGIN ERR; WRITE('NO MACRO ',V,' DEFINED'); ERRE END
       ELSE IF TMACP=MACLSTP THEN MACLSTP := TMACP@.MA
        ELSE MACP@.MA := TMACP@.MA;
      END
     ELSE BEGIN ERR; WRITE('NO MACRO NAME'); ERRE END;
    END;
    CDEBUG1 : BEGIN  DEBUG1 := YES; DEBUG2 := YES; END;
    CDEBUG2 : DEBUG2 := YES;
    CAUTOCAP : BEGIN AUTOCAP := YES; CAPNEXT := AUTOCAP AND LOWER; END;
    NOTCMD: BEGIN END
   END
  END;
 CMMD := FALSE;
END;     (*$END OF DOCOMMAND *)

PROCEDURE INI;
BEGIN
 LITERAL1 := '.TOP .SAV .RESPAG .B 3 ..TTL ..NMP .BR ..STL .B 2 .RES .MID ';
 LITERAL2 := '$$PAGE=$$PAGE+1; ..NONMP .IF $$NMP .TAB $$PRM .RT $$PAGE ';
 LITERAL3 := '.IF #$$NMP .B 1 ';
 LITERAL4 := '.PAGE .FIG 12 .C <CHAPTER $$CH=$$CH+1 ';
 LITERAL5 := '$$HL=0; .B 2 .C ..CHT .B 3 ';
  BLANKLINC := '    ';
  BLANKLINC(/4/) := CHR(0);
 VAL(/VLM/) := 1;
 CMMD := FALSE;
 USB := TRUE;
 UNDL := FALSE;
 ILNO := 0; EOFINPUT := FALSE;
 FREEMACP := NIL;
 INISTDMACS;
 FLAGOVER := TRUE; FLAGSIG := TRUE;
 T := FALSE; RT := FALSE; DOT := FALSE;
  FOR ERRORS := 0 TO (CHARSIZE - 1) DO BEGIN
      ITEMSET(/ERRORS/) := FALSE;
      TERMSET(/ERRORS/) := FALSE;
      END;
  ERRORS := 0;
  ITEMSET (/ ORD('$') /) := TRUE; ITEMSET (/ ORD('+') /) := TRUE;
  ITEMSET (/ ORD('-') /) := TRUE; ITEMSET (/ ORD('#') /) := TRUE;
  FOR CH := '0' TO '9' DO  ITEMSET (/ORD(CH)/) := TRUE;
  TERMSET := ITEMSET;
  TERMSET (/ ORD('(') /) := TRUE;
 INIRELS;
 PUSHED := FALSE;
 PMAR := 0;
 AP := FALSE;
 PARA := FALSE;
 OTL.CENTER := FALSE;
 RIGHT := TRUE;
 OPNO := 5;
 OBTXT := 7;
 OVETXT := 58; OETXT := 58;
 OEPAG := 66;
 LPT := TRUE;                      (* THIS IS CHANGED FROM ORIGINAL SPECS *)
 ENP := 0;
 SUP := FALSE;
 PAGE := FALSE;
 YES := TRUE;
 ENP := 0;
 PARSPACE := 1;
 PARTEST := 3;
 DEFRB := 0;
 PREL := TRUE;
 FIRSTCH := TRUE;
 FORCE := FALSE;
 ATITLE := FALSE;
 FIGP := 0;
 BAR := FALSE; BB := FALSE;
(* LINELIMIT(OUTPUT,50000); *)
 CLRTAB;
 TAB := 0;
 DEFRSYM := FALSE;
 RT := FALSE;
 CLRLINE;
 NEW(ACTP);
 WITH ACTP@ DO
  BEGIN NP := 0; CA := NIL; ON := FALSE; NEW(LI) END;
 BOTMAC := ACTP;
 XTEND := FALSE;
 INICMDS;
 SETSTD;
 INIVARS;
 VAL(/VNMP/) := 1;
 VAL(/VLM/) := 1;
 VAL(/VRM/) := 72;
 VAL(/VPRM/) := 72;
 OTL.LEN := VAL(/VLM/); OTL.VLEN := VAL(/VLM/);
 VAL(/VSP/) := 1;
 VAL(/VOLNO/) := 1000000;
 SAVENV(PAGENV);
 WITH ADDSYL DO
  BEGIN LIN(/1/) := '.'; LIN (/2/) := 'A'; LIN(/3/) := 'D'; LIN(/4/):='D';
        LEN := 4; END;
 LETTERS := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
 DEBUG1 := FALSE;
 DEBUG2 := FALSE;
 RIGHTSPACE := 0;
  AUTOCAP := FALSE;
  CAPNEXT := FALSE;
END;     (*$END OF INI *)
          (* MAIN *)

BEGIN             REWRITE(QRR);
 INI;
 GETCUR;
 WHILE NOT EOFINPUT DO
  BEGIN
   IF (CUR(/1/)=' ') AND AP THEN FORCECMD('.PP       ',3);
   GETSYM;
   IF SYMTYPE=NONE THEN BLANKLINE
   ELSE
    BEGIN
     WHILE SYMTYPE<>NONE DO
      BEGIN
       CASE SYMTYPE OF
        WORD: PUTWORD;
        VARS: PUTVAR;
        COMMAND: DOCOMMAND
       END;
       GETSYM
      END;
    END;
   ENDLINE;
   IF NOT DEFRSYM THEN GETCUR;
  END;
 FIN
END.
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB RNFDOC   EXT PAS HEX -
1

























                                          RNF
+                                         ___

                                    Text Processor
+                                   ____ _________


                                    Reference Guide
1


        Introduction               RNF                                  1







                                       CHAPTER 1

                                     INTRODUCTION




        RNF is a text formatting program for the Cyber similiar  to  the  RUNOFF
        program available on the DECsystem-10.

        RNF accepts (mostly) free-format text which has been put in a  file  and
        edited  by  BOSS,  and  produces output suitable for a line printer or a
        typewriter-like terminal device.



        1.1  Features


        RNF does any or all of the following for the user:

         Pagination      RNF automatically breaks text up  into  pages,  and  by
                         default numbers them sequentially.

         Fill            Using the margins set by the  user,  RNF  automatically
                         "fills"  each  line of the output with as many words as
                         it  can  hold  without  exceeding  the  right   margin.
                         Filling stops at the end of a paragraph, etc.

         Justification   RNF will optionally justify filled lines on the  right,
                         so that the right margin "lines up" evenly.

         Chaptering      RNF will format chapter  titles,  and  number  chapters
                         sequentially.

         Sectioning      RNF will format section headers and number sections and
                         subsections sequentially.

         Lists           RNF will format and number lists and sublists.

        In addition to the features which are built in, RNF provides an easy  to
        use  macro  facility which permits the user to define commands which are
        customized to a particular application.
1


        2                          RNF                       Introduction


        1.2  Input Text


        The input to RNF may be prepared either on an  upper  case  only  device
        like  a  Teletype  or punched cards, or on an upper/lower case terminal.
        These are called NORMAL and ASCII devices, respectively.

        Regardless of the input medium, output from RNF is in upper/lower  case.
        This is accomplished by the following conventions:



        1.2.1  NORMAL Input


        By convention, RNF inverts the case  of  alphabetic  characters  in  the
        input.   Upper  case  characters  are  indicated  by a preceding ^.  For
        example, the following NORMAL input

         ^THIS IS AN ^U^P^P^E^R/LOWER CASE LINE.

        is output by RNF as

         This is an UPPER/lower case line.

        As a convenience, the < character will invert the case of all alphabetic
        characters which follow it in the same word.  For example,

         ^SOME <UPPER <CASE AND SOME LOWER CASE.

         SOME<OF<BOTH

        are output as

         Some UPPER CASE and some lower case.

         someOFboth

        In exchange for this  convenience,  the  characters  ^  and  @  must  be
        represented in NORMAL input as @B and @A, respectively.



        1.2.2  ASCII Input


        Upper/lower case text can be entered in a file by using  ASCII  mode  in
        BOSS.   When  submitted  to RNF, this text must be preceded by an .ASCII
        command.  The < character works the same.
1


        Introduction               RNF                                  3


        1.3  WORDS


        RNF input is a series  of  words,  where  a  word  is  any  sequence  of
        non-blank characters.

        Blanks in the input text are not (usually) significant  to  RNF,  except
        that  they  delimit words.  RNF inserts one blank between each word, and
        two blanks after words which end sentences.

        If a sequence of blanks must appear in the output, the significant blank
        character # is used.  For example, be####tween is output as be    tween.



        1.4  LINES


        In default mode, words are picked from the input one by one  and  placed
        into  an  output  line.  When an output line is full, it is written into
        the output file.

        The user sets the left and right margins of the output page by  the  .LM
        and  .RM  commands,  respectively.   Text  on the output line is written
        beginning at the left margin and not past the right margin.

        Filling means that (unless the user specifically directs  otherwise)  as
        many words as possible are used to fill each output line.

        Justification means that blank characters are  added  between  words  so
        that the last character on each line is exactly on the right margin.

        The .F and .J commands control filling and justification.

        The default left margin is 1 and the default right margin  is  72.   For
        Elite  type  (12  characters per inch) this produces a 6-inch wide line,
        which allows 1 and 1/4 inch margins on standard 8 and  1/2  inch  paper.
        For Pica type (10 characters per inch) .LM 1 and .RM 60 provide the same
        size line.

        For most purposes, it is recommended that the left margin  be  initially
        set  to  1, as this is easy to work with and remember.  If the text must
        be shifted to the right for output on  a  typewriter  page,  the  .RIGHT
        command may be used.
1


        4                          RNF                       Introduction


        1.5  SPACING


        The input to RNF is single spaced.  The output  may  be  single  spaced,
        double spaced, or triple spaced as the user chooses.

        Spacing is set by the .SP command,.  Once set,  RNF  will  automatically
        control  spacing without requiring any further action on the part of the
        user.  If extra spaces or non-standard spacing is desired, however,  RNF
        provides commands for these, too.

        The .CR command provides the equivalent of a carriage return key  on  an
        electric typewriter.  The .CR ends the current line and spaces as set by
        .SP.  That is, if single spacing is selected (.SP 1), the  .CR  "returns
        the  carriage"  to the next line; if double spacing is selected (.SP 2),
        the .CR leaves a single blank line after the current line,  and  so  on.
        Throughout  this  manual,  the  action  of  the  .CR is referred to as a
        "return".  Many commands cause a return as a prelude to further action.

        The .S command causes a return, followed by any number of extra returns.
        .S  and  .S 1  mean the same, i.e., a return and one extra return.  .S 2
        provides two extra returns, and so on.

        .CR and .S always honor the spacing set by .SP.   The  user  can  escape
        spacing by means of the .BR and .B commands.

        .BR provides a "break"; it returns the carriage and proceeds on the next
        line,  regardless of spacing.  .B causes any number of blank lines after
        the current line.  .B and .B 1 mean the same: break and leave one  blank
        line after the current line.  .B 2 leaves two blank lines, and so on.

        Thus, the user can create spacing independent text by using only .CR and
        .S  commands  for  spacing.   .BR  and .B are used when spacing is to be
        fixed regardless of the .SP setting.



        1.6  PARAGRAPHS


        RNF provides both explicit and automatic paragraphing  facilities.   The
        .P  command  controls  the  indentation,  spacing,  and location of each
        paragraph.  The .PP command begins a new paragraph.

        Autoparagraphing, controlled by the .AP command, causes an implicit  .PP
        command  each time either a blank line or a line beginning with blank is
        encountered in the input text.  This is a  convenient  format  for  text
        entry, and allows easy modification.  By use of the .SP (SPacing) and .P
        commands, the same input text can be used for producing both double  (or
        triple) spaced drafts and single spaced final copy.

1


        Introduction               RNF                                  5


        Paragraphing is sufficiently flexible to be used for "hanging  indents".
        In  addition,  the  fact  that  paragraph  indentation  can be specified
        relative to the left  margin  (even  if  it  is  later  changed)  allows
        paragraphing to be conveniently used in indented text.



        1.7  PAGES


        Lines are automatically separated  into  pages  by  RNF.   Two  commands
        control the size of RNF pages: .PS (Page Size) and .LINES.

        The first argument of .PS  specifies  the  number  of  lines  which  are
        allowed  on  a page before an automatic page throw is done.  This number
        includes the lines in the header at the top of each page, and the normal
        text  on the page, but does not include the lines in the footer (if any)
        at the bottom of the page.  The .LINES command specifies the  number  of
        lines  on  the  entire  page.   This number is used when simulating page
        ejects on terminals with continuous forms.

        The default .PS first argument and .LINES are 58 and  66,  respectively.
        This allows at least a 1 and 1/3 inch bottom margin with 6 line per inch
        printing, and a 1 inch margin with line per inch  printing  on  standard
        CSO reduced forms.

        Some terminals use reduced forms but print 6 lines per inch.  This means
        there are 51 lines on each page; a .PS first argument of 44 will allow a
        1 inch bottom margin.



        1.7.1  Explicit paging control


        The  .PAGE  command  allows  the  user  to  advance  to  the  next  page
        explicitly.   The .NMP and .PNO commands control page numbering, and the
        .TITLE, .ST, and .ATITLE commands provide for printing titles at the top
        of each page.



        1.7.2  Page Format


        A page is divided into three areas:

           . The top, which contains the upper margin and  optional  titles  and
             page number.

1


        6                          RNF                       Introduction


           . The middle, which contains the text of the document.

           . The bottom, which may contain a footer.  (By default, no footer  is
             printed.)


        The default header consists of an optional title on  the  left  and  the
        page  number  as an Arabic number on the right of the fourth line on the
        page.  The subtitle, if any, is below the title on the  following  line.
        Two blank lines are left below the header.

        If this default format is not satisfactory for a specific document,  the
        user  may  substitute any arbitrary header and footer text by means of a
        .FRCPAGE macro  definition  (see  Chapter  3)  and  use  of  the  paging
        intrinsics .TOP, .MID, and .BOT.

        The page number used  by  RNF  may  be  accessed  directly  through  the
        predefined variable $$PAGE (see Chapter 4).
1


        Commands                   RNF                                  7







                                       CHAPTER 2

                                       COMMANDS




        Any sequence of non-blank characters beginning with a  period  (.)   are
        taken  by  RNF  to  be  a command.  If the command is not recognized, an
        error message is produced.

        Many commands require arguments, i.e., words which  follow  the  command
        and  modify  its  action  in some way.  The only commands which permit a
        variable number of arguments are .TAB (or .TABS), .B, and  .S.   if  any
        other command requires an argument, it must be specified.

        Commands may be freely interspersed with text.  Some  commands  cause  a
        "return"  (that  is, act as if they were preceded by a .CR command) as a
        part of their action.  If a command causes a return, this  is  indicated
        in parenthesis after the command format.  Other commands cause a "break"
        (that is, act as if they were preceded by a .BR command) as  a  part  of
        their action.  These are indicated by (Break) in parenthesis.

        Note that a blank must follow a command if there is  more  text  on  the
        same  line.   For example, the sequence ".B.I 5" is in error; it must be
        written as ".B .I 5".


     .AP

         Any  blank  line  or any line beginning with a blank character begins a
         new  paragraph.   See  the  .P  and  the  .PP  commands.   .NOAP  turns
         autoparagraphing off and is the default.


     .ARRAY variablename n

         This command declares an array variable with the name specified and n+1
         elements.  An element of the array is later accessed or  changed  by  a
         reference of the form:

         variablename[expression]

         where  expression may be in the range 0 through n.  The zeroeth element
         of the array may be  referred  to  without  a  [0]  subscript,  and  is
         commonly used as an index into the remainder of the array.

1


        8                          RNF                           Commands


         All array elements have the initial value zero.  Array  names  must  be
         formed as defined for the .VAR command.


     .ASCII

         The  input  was prepared in ASCII mode on an upper/lower case terminal.
         When in ASCII mode cahracters  are  not  automatically  case  inverted.
         Also  the effect of the ^ character is reversed, in ASCII mode ^ lowers
         a capital letter and does nothing to a lower case letter.  The  default
         is .NOASCII.


     .ASIS                                                       (Return)

         Terminates  the current input line and enters as is mode beginning with
         the next input line.

         In  as  is  mode, input lines are copied directly to the output (except
         that the left  margin,  change  bars,  and  .RIGHT  spacing  are  still
         honored).

         As is mode is terminated by a line with an  exclamation  mark  (!)   in
         column  1.   All characters after the exclamation mark are ignored, and
         normal processing begins with the following line.

         Note that as is text which is intended to be output as upper/lower case
         (ASCII) must be input in ASCII.  No processing is done on as is text.
+                                         __


     .ATITLE

         Enables autotitling, which makes each new chapter heading the title for
         all but the first page of the chapter.  The default is .NOATITLE.


     .AUTOCAP

         Enables  the auto capitalization, which makes the character following a
         ., !, ?, remain in upper case.  This is disabled  in  ASCII  mode.   It
         takes  effect  after  the  first punctuation mark, so it may not affect
         titles or the first line.  NOAUTOCAP is the default.


     .B                                                           (Break)
     .B n                                                         (Break)

         Ends the  current  line  and  writes  it  without  further  filling  or
         justification (causes a break), then writes n blank lines.  .B and .B 1
         are equivalent.


1


        Commands                   RNF                                  9


     .BAR

         Enables  change  bars.   All text following the .BAR command is shifted
         right three spaces.  See the .BB and  .EB  commands.   The  default  is
         .NOBAR.


     .BB

         Begin  placing change bars (vertical bars) in the margin created by the
         .BAR command beginning with the line which contains the first  word  in
         the text following the .BB command.  See the .EB command.


     .BOT

         Sets  the  beginning  of  user text (on the page) to the current output
         line number and restores any output lines which might have  been  saved
         on a forced page eject (see .FRCPAGE).  If any deferred text is pending
         (see the .FIG command), as much of it as possible is  output  by  .BOT.
         If  as  is  mode  was in effect at the time of the last .FRCPAGE, it is
         restored.

         The  .BOT command is to be used only when overriding the default header
         format via macros.

         The  .B and .S commands have no effect at the beginning of user text on
         a page.  This prevents spurious blank lines at the top of a text page.


     .BR                                                          (Break)

         Ends  the current outtput line and writes it without further filling or
         justification.  No extra blank lines are left  by  .BR,  regardless  of
         spacing.


     .C text                                                     (Return)

         Centers  the  text  which  follows  the  .C  command  on the same line.
         Centering is between the current left and right margins.


     .CH title                                                   (Return)

         Begins  a new chapter with the title which follows on the same line.  A
         new page is begin, titles and subtitles are cleared, a .FIG 12 is done,
         followed  by  the  word  CHAPTER  centered, a .B, followed by the title
         centered.  Page numbering is not  affected.   If  .ATITLE  is  on,  the
         chapter title is set as the .TITLE for succeeding pages.


1


        10                         RNF                           Commands


     .CR                                                         (Return)

         Causes  a carriage return, which is a .BR followed by spacing minus one
         blank lines.

         Note  that  .CR  is  implied  before  any command for which (Return) is
         indicated.


     .DEBUG1

         Causes all following lines to be prefixed with the relative line number
         of the page.  This precedes the carriage control, if any.  .DEBUG1 also
         includes  .DEBUG2.   .NODEBUG1  is  the  default.   This  is useful for
         finding problems when creating a document with many page ejects.


     .DEBUG2

         Causes  all  following  lines to be trailed by the input line number on
         the extreme right margin (not necesarily the margin set by .RM).   This
         is  very useful for document preparation, to correlate a problem to the
         input line causing it.  .NODEBUG2 is the default.


     .DEC variablename

         Decrement the variablename.


     .DELMAC macroname

         Deletes the macro name, so that it may be reused.


     .DOT

         Causes  all  following  .T  or .RT commands to fill with dots (periods)
         instead of spaces.  A blank is always left before and after the  string
         of dots.  .NODOTS returns to filling tabs with spaces.


     .EB

         End  change  bars.  The last line flagged is the one which contains the
         word just preceding the .EB command.


     .ELIST

         End  list.   Terminates  the  innermost  active  list.   See  the .LIST
         command.
1


        Commands                   RNF                                 11


     .ESC

         Enables the escape character _ (backarrow or underline).  When enabled,
         the escape character causes the character which follows it to be copied
         to  the  output text without special action.  For example, 23_.  causes
         23. to be typed without an extra trailing blank.  The default is .ESC.


     .F

         Fills  each  output  line with as many words from the input as possible
         without exceeding the right margin.  Blanks are removed from the input.
         Each  word of the output is followed by at least one blank, while words
         which end in ., !, or ? are followed by  at  least  two  blanks.   .NOF
         suppresses fill.


     .FIG n

         Reserves  n  lines  for a figure.  If the lines will fit on the current
         page, .FIG causes a return and leaves n blank lines.  If not,  n  blank
         lines are left at the beginning of the next page.


     .FLAG

         Causes  ^  and  @  to  be  recognized as flag characters.  .FLAG is the
         default; .NOFLAG suppresses recognition.


     .FLAGCAPS

         Causes  the  <  character  to  invert the case of any letters in a word
         which  follow  it.   For  example,  <UP<AND<THEN<DOWN  is   output   as
         UPandTHENdown.   .NOFLAG suppresses special action for the < character.
         .FLAG is the default.


     .FLAGOVER

         The  .FLAGOVER  command  enables  recognition  of  \ (backslash) as the
         strikeover character.  The strikeover character is written between  the
         character to be overstruck and the character which is to overstrike it.
         For example, STRIKEO\/VER is output as STRIKEOVER.
+                                                     /

         Underlining  counts as one overstrike.  Any character may be overstruck
         up to three times.  Overstriking may be used only within  a  word;  the
         overstrike character has no meaning by itself or beginning a word.

         .FLAGOVER is the default.  .NOFLAGOVER turns it off.


1


        12                         RNF                           Commands


     .FLAGSIG

         The   .FLAGSIG   command  enables  recognition  of  #  (sharp)  as  the
         significant blank character.   .FLAGSIG  is  the  default.   .NOFLAGSIG
         turns it off.


     .FRCPAGE

         This command is used internally by RNF to force a page eject.  That is,
         if a line is about to be written which would exceed the page size,  the
         line is saved, and a .FRCPAGE command is executed as though it had been
         encountered in the input text.



         The .FRCPAGE command itself invokes the equivalent of .TOP, prints  the
         next page header, and invokes the equivalent of .MID.

         The user may add a footer or reformat the page  header  by  defining  a
         macro  with the name .FRCPAGE.  This replaces the .FRCPAGE command, and
         must invoke the  .TOP  and  .MID  commands  (and  optionally  the  .BOT
         command)  explicitly.   For  correct  operation,  the first word in the
+                                                              _____
         .FRCPAGE macro must be either .BOT or .TOP, and the last word should be
         .MID.

         Note that .FRCPAGE does not return, nor can  it,  since  a  return  can
         cause  a  page  eject,  which  will  cause  a  .FRCPAGE  to  be invoked
         recursively.  The .PAGE command does return, and in fact is defined  as
         .BR .FRCPAGE.


     .FMT n1 n2

         Formats  the  value of n2 according to the format code specified by n1.
         N1 and n2 may be expressions (see Chapter 4).  N1 must be in the  range
         0 through 5, and has a meaning as follows:

         Value      Formats n2 as...
+        _____      ________________

             0      Arabic numbers.  That is, .FMT 0 is a no-op except  that  it
                    forces output of n2.

             1      Upper case alphabetic characters, where  n2=1  produces  the
                    character  A, n2=2 produces B, etc.  (Note that in fact n2=n
                    produces the nth character in the alphabet, where n is taken
                    modulo 26.)

1


        Commands                   RNF                                 13


             2      Lower case alphabetic characters, where  n2=1  produces  the
                    character a, etc.  (The action is the same as that of format
                    except that the character is lower case.)

             3      Upper case Roman numerals.  (The numerals produced only make
                    use of the characters M, D, C, L, X, V, and I.)

             4      Lower case Roman numerals.  (The numerals produced only make
                    use of the characters m, d, c, l, x, v, and i.)

             5      The N2th character of the character set.  This is useful for
                    printing characters not available on the entry device.


     .HL n heading                                               (Return)

         Begins  a  new  section  with  the  heading specified and automatically
         numbers it.  The n in the .HL command must be in the range 1 through 5.
         Section  numbers  have  the form i.j.k.l.m.  If a .CH command preceeded
         the .HL command, i is the chapter number; otherwise it is the number of
         .HL  1  commands.   Within Chapter 2, the sequence .HL 1, .HL 2, .HL 3,
         .HL 3, .HL 2, .HL 1 produces sections  numbered  2.1,  2.1.1,  2.1.1.1,
         2.1.1.2, 2.1.2, and 2.2.

         Three blank lines are left before each section,  and  two  blank  lines
         follow the section header.


     .I  n                                                       (Return)
     .I +n                                                       (Return)
     .I -n                                                       (Return)

         Indent  the following line.  If n is specIfied, it indicates the column
         number at which the line is to begin.  If +n or -n are  specified,  the
         indent is plus or minus n characters from the left margin.


     .IF expression text

         The  .IF command tests the value of the expression.  If it is zero, the
         text on the remainder of the line is skipped;  otherwise  the  text  is
         scanned normally.  .IF provides a single line conditional capability.

         For a definition of expressions  acceptable  to  .IF,  see  Chapter  4,
         VARIABLES.


     .INC variablename

         increment the following variable.


1


        14                         RNF                           Commands


     .J

         Justify  text at the right margin.  This is the default.  Justification
         is accomplished by inserting extra blanks between words when necessary.
         (Note  that  a significant blank, the # character, is never expanded.)
         .NOJ turns justification off.


     .LE                                                         (Return)

         Begins  a  list  element.   The  element  is automatically numbered and
         indented.  See the .LIST and .ELIST commands.


     .LINES n

         Sets  the  number  of  lines  in the output page, including the top and
         bottom margins.  DEFAULT n is 66.  The correct setting for 6  line  per
         inch devices using 8 line per inch paper (like CSO'S DECwriters) is 51.


     .LIST n                                                     (Return)

         Begins   a   list  with  n  spacing.   Each  element  of  the  list  is
         automatically numbered beginning at 1.   Lists  may  be  nested  within
         lists,  for  up to 5 levels.  A list is terminated by a .ELIST command.
         Each list is indented on the right; the outermost list  is  indented  9
         characters, and each inner list is indented 4 more.


     .LOWER

         Formats the output in upper/lower case.  Lower is the default.


     .LPT

         Prepare  output  for a line printer, with carriage control in the first
         character position of each line.  The default is .LPT.  .NOLPT prepares
         output for an interactive terminal.


     .LM n

         Set  the  left  margin  to n.  N must be in the range 1 through 136 (in
         particular, .LM 0 is flagged as an error).  See .RM also.


     .MACRO name   = text
     .MACRO name n = text
     .MACRO name * = text

1


        Commands                   RNF                                 15


         Defines  a  macro  with  the  name  specified  equal to the text on the
         remainder of the same line.  When .name is encountered later, the  text
         is substituted for it.

         If n, an integer from 1 to 7, is specified, it indicates the macro  has
         n arguments.  This implicitly defines macros name1,name2...namen, which
         have a text value equal to the n words which follow the macro  when  it
         is invoked.

         If * is specified, it indicates that the macro has one  argument.   The
         argument  is  the  implicitly defined macro name1, and has a text value
         equal to the entire rest of the line on which the macro is invoked.

         For an extended discussion and examples, see Chapter 3, MACROS.


     .MID                                                        (Return)

         The  .MID command ends a user-defined .FRCPAGE macro.  .MID outputs any
         deferred text, followed by any lines saved prior to .FRCPAGE, then sets
         the beginning of user text to the current line.  This latter suppresses
         blank lines at the "top of the page" caused by either .S or .B.


     .NMP

         Number pages.  This is the default; .NONMP turns it off.


     .P  n s t
     .P +n s t
     .P -n s t

         Sets  paragraphing  conventions.   N,  s and t are numbers.  N sets the
         paragraph indent and works like the .I command.   S  sets  the  spacing
         between paragraphs, where 1 is single spaced, is double spaced, etc.  T
         sets an automatic .TP t before each paragraph.  See also  the  .PP  and
         .AP commands.


     .PAGE                                                       (Return)

         Begins a new page.


     .PERIOD

         Leave an extra blank after ., !, or ?.  This is the default.  It may be
         suppressed by .NOPERIOD.


1


        16                         RNF                           Commands


     .PNO n

         Number the next page n.


     .PP                                                         (Return)

         Begin a new paragraph.


     .PS l r

         Sets  the  page  size to l lines of text, not counting the lines at the
         top margin, and the page number right margin to r.  See also the .LINES
         command.


     .REM text

         The  .REM  command and all text which follows it on the same input line
         is treated as a remark (comment).   The  text  is  not  copied  to  the
         output.


     .RES                                                         (Break)

         Restores  the  margins,  fill  and  justify  modes, paragraph settings,
         spacing, and tab stops to their state as of the last .SAV command.


     .RESPAG                                                     (Return)

         Like  .RES;  replaces  the  margins,  fill and justify modes, paragraph
         settings, spacing, and tab stops to their state as of the last  .SAVPAG
         command.   Restores the page environment, which is used to align titles
         and page numbers.


     .RIGHT n                                                    (Return)

         Shift  output  text  right  n  spaces.  the .RIGHT spaces precede those
         caused by the .BAR command.


     .RM n

         Sets the right margin to column n.


1


        Commands                   RNF                                 17


     .RT

         Right  tab.   Causes  the following word to be right justified (end in)
         the next tab stop.  See the .TABS and .T commands.  This is useful  for
         tables of numeric data.


     .S                                                          (Return)
     .S n                                                        (Return)

         Leave n+1 times spacing blank lines, where spacing is set  by  the  .SP
         command.   .S does nothing at the beginning of a page.  .S and .S 1 are
         equivalent.


     .SAV

         Save  the  current margins, fill and justify modes, paragraph settings,
         spacing,  and  tab  stops  --  which  are   collectively   called   the
         "environment".   The environment is restored by the .RES command.  .SAV
         and .RES can be nested.

         For most text, there are two active environments: the current value and
         the "page environment".  The latter controls the printing of titles and
         page numbers at the head of each page.

         Note that .HL, .CH, or  .RESPAG  reset  the  environment  to  the  page
         environment  and discard any active .SAVs.  See the .SAVPAG and .RESPAG
         commands.


     .SAVPAG

         Like  .SAV,  except  .SAVPAG  replaces  the  page  environment.   If no
         explicit .SAVPAG is done, the environment  at  the  first  .HL  or  .CH
         command becomes the page environment.


     .SIG

         Treat  successive  blank  characters  as  words, and stop all automatic
         blank placement.  Used in conjunction with .NOJ and .NOF, it permits  a
         sort  of  "as  is"  mode  in  which,  however,  commands  and flags are
         recognized.  .NOSIG is the default.


     .SP n

         Set  the  spacing  between  lines  forced out by filling to n, where is
         single spacing, 2 is double spacing, etc.


1


        18                         RNF                           Commands


     .ST text                                                    (Return)

         The  text  which  follows the .ST command on the same line is used as a
         subtitle on the next and succeeding pages.


     .STD

         Sets  .F,  .FLAG,  .FLAGCAPS, .NOASCII, .ESC, .PERIOD, .J, .UL, .NOSIG,
         and automatic returns before the .C,  .TITLE,  .ST,  and  .I  commands.
         .SIG is the default; .NOSIG does the opposite.


     .SUP

         Suppresses  (throws  away) any text already in the current output line,
         and any text on the same input line as the .SUP command.


     .T

         Begin  the  next word at the next tab stop.  See also the .TABS and .RT
         commands.


     .TABS t1 t2 ...  t15

         Set  up  to 15 tab stops in columns t1, t2, etc.  The tab stops must be
         in ascending order.  Tabbing is done by the .T and .RT commands.


     .TITLE text                                                 (Return)

         Sets the text which follows .TITLE on the same line as the title on the
         next and succeeding pages.


     .TOP

         Spaces  to the top of the next page or emits "1" carriage control.  and
         resets the line counter.

         .TOP is only to be used when overriding the default page handling.  The
         .PAGE command is used for ejecting a page normally.


     .TP n                                                       (Return)

         Tests whether n lines remain on the current page.  If not, .TP ejects a
         page.  Note that .TP is affected by spacing in that the  actual  number
         of lines tested for is n times spacing minus one.

1


        Commands                   RNF                                 19


     .U

         Underline the next and succeeding words in the output text.  Terminated
         by the .NOU command.


     .UPP

         Force the next word to be upper case.


     .UPPER

         Forces the output into upper case only.  Lower is the default.


     .USB

         Underline  significant blanks (that is #) when .U is effective.  .NOUSB
         causes significant blanks to be not underlined.  .USB is the default.


     .VAR variablename

         Declares a variable with the name specified.  Variable names must begin
         with a $, and otherwise consist of letters, numbers, or  $  characters.
         The  second  character  of  a  variable  name  may not be a digit.  The
         variable has the initial value zero.


     .X

         Extend  the  preceding word on the output line with the following word.
         Words joined by .X are output on the same line with no  blanks  between
         them.   .X is primarily useful for joining text generated by a macro to
         punctuation on either side of it.
1


        20                         RNF                             Macros







                                       CHAPTER 3

                                        MACROS



        User-defined RNF macros provide a means of:

           . Extending the set of RNF commands by adding macros  tailored  to  a
             specific application.

           . Abbreviating commonly used series of RNF commands.

           . Abbreviating commonly used phrases or long words.

        For  example,  the  following macro definitions were used to produce the
        dotted list above:

                 .MACRO BDOT = .SAV .P -2 1 5 .LM +5
                 .MACRO DOT = .PP _.# .X
                 .MACRO EDOT = .RES .S 1

        while the following two macros  were  used  to  format  the  above  (and
        following) examples:

                 .MACRO EX = .SAV .LM +9 .NOF .NOJ .S 1
                 .MACRO EEX = .RES .S 1

        and so on!

        The following discussion is intended to give the user some insight  into
        potential  uses  of  macros  while  demonstrating how easy macros are to
        define and use.



        3.1  WHAT MACROS ARE


        Macros have two parts: a name, and some text.  The name is a single word
        long, while the text may be zero or more words long.

        The effect of a macro is similiarly easy to describe: wherever the  name
        of the macro appears RNF removes it and substitutes the text.

1


        Macros                     RNF                                 21


        For example, if the following macro is defined:

                 .MACRO CDC = Control Data Corporation

        whenever .CDC appears in the  input,  RNF  removes  it  and  substitutes
        Control Data Corporation.


                                     Note the Dots

                       The   macro  name  is  defined  without  a
                       preceding  period  (dot).   But  when  the
                       macro  is  used, the name must be preceded
                       by a dot.





        3.2  HOW TO DEFINE A MACRO


        The simplest form of macro definition is:

                 .MACRO name = text

        where name is the name of the macro, and text represents all the text on
        the rest of the same line.

        After the macro definition, wherever .name appears RNF  removes  it  and
        substitutes the text.



        3.3  SUB-MACROS


        All macro expansions are considered to take place on the same input line
        as  the  "outermost" macro call.  Thus, macros can be parameterized in a
        simple way by ending a macro expansion with a  command  and  typing  the
        command argument(s) after the macro call.  For example,

                 .MACRO RIGHTMARG = .RM

        which could be used by

                 .RIGHTMARG 65

        But,  as  the  example shows, this approach is mostly limited to trivial
        command replacements.  Sub-macros provide the  ability  to  parameterize
        macros in a more useful fashion.
1


        22                         RNF                             Macros


        3.3.1  Defining Parameterized Macros


        Macros with sub-macros are defined by the formats:

                 .MACRO name n = text
                 -or-
                 .MACRO name * = text

        The n in the format stands for a number in the range 1  through  7.   It
        means  that  the  1 through 7 words following the macro call on the same
        line are dynamically made the values of the sub-macros name1, name2, ...
        ,name7.

        Sub-macros have a defined value only when the macro is being expanded.

        If an asterisk is used instead of a number n,  it  means  that  all  the
        words  which follow the macro call on the same line are dynamically made
        the value of the sub-macro name1.

        For example,

                 .MACRO Z 2 = I hope you are .Z1 .X ing .Z2 .X !

        When .Z is called, the sub-macros .Z1 and .Z2 are given values equal  to
        the two words which follow .Z on the same line.  Thus, the call

                 .Z follow me

        produces the text

                 I hope you are following me!




        3.3.2  Sub-macro Semantics

        Since the parameters of a macro are defined as macros  themselves,  they
        may  be  used  in any macro called while the sub-macros are defined, and
        need not be "passed down" from macro to macro.

        If no words or not  enough  words  follow  the  call  of  a  macro  with
        sub-macros, the sub-macros are given null values.  That is, unless there
        is actually a word corresponding to a sub-macro, it expands  to  nothing
        at all.
1


        Variables                  RNF                                 23







                                       CHAPTER 4

                                       VARIABLES




        RNF allows the user to define and  use  numeric  variables.   These  are
        handy  (and  are  used  internally)  for  keeping track of page numbers,
        chapter numbers, header levels, etc.



        4.1  VARIABLE SYNTAX


        Variables are words which begin with a dollar sign ($), followed by from
        1 to 9 letters, numbers, or $ characters.  The case of variable names is
        not significant, e.g., $HILO and $hilo are the same variable.

        The first character after the leading $ cannot be a number.  This is  so
        character  combinations  of  the  forms  $<blank> and $<numbers> are not
        recognized as variables, making a nuisance for the user.

        Users should not declare variables with two  leading  dollar  signs,  as
        this is the format used by pre-declared RNF system variables.

        For example, the following are valid variable names:

                 $A

                 $VARIABLE

                 $n$

                 $L23

        while the following are invalid:


                 $100

                 $

1


        24                         RNF                          Variables


        4.2  HOW TO DECLARE VARIABLES


        Variables are declared by the .VAR command, which has the format:

                 .VAR $name

        Note that the variable name is both declared and used with a leading $.

        The effect of .VAR is to allocate space for a numeric variable, give  it
        the name specified, and initialize the variable to zero.

        RNF provides  75  spaces  for  user-defined  variables  in  addition  to
        predefined variables.



        4.3  PREDEFINED VARIABLES


        As a convenience to the  user,  Rnf  makes  use  of  several  predefined
        variables  while  performing various commands.  The predefined variables
        are:

             $$PAGE Current page number.
             $$CH Current chapter number.
             $$HL Current  header  level.   Also  defined  are  $$HL[1]  through
                         $$HL[5],  which  contain  the  current  counts  at each
                         level.
             $$LIST Current list level.   Also  defined  are  $$LIST[1]  through
                         $$LIST[10],  which  contain  the current counts at each
                         level.
             $$LM Current left margin, set by .LM.
             $$RM Current right margin, set by .RM.
             $$SP Current spacing, set by .SP.
             $$NMP Page numbering flag, set by .NMP.

        The values of the predefined variables may be examined or changed by the
        user  at  any  time.   (Of course, changing these values will affect the
        operation of the built in RNF features which use them.)



        4.4  VARIABLE ARRAYS


        Arrays may be declared by the .ARRAY command, which has the format:

                 .ARRAY $name n

        The effect of this declaration is that $name is declared to  be  an  n+1
        element array, which may be referenced as $name[0] through $name[n].
1


        Variables                  RNF                                 25


        The subscript may be omitted if the zeroeth  element  of  the  array  is
        being  referenced.   That  is,  $name[0] and $name are equivalent.  This
        convention is adopted so that a single declaration can allocate both  an
        n-element  array  and an index variable associated with the array.  (The
        predeclared arrays $$HL and $$LIST are used in this fashion.)

        Note that the array declaration requires n+1 spaces of the  allowed  for
        user variables.



        4.5  EXPRESSIONS


        An extremely useful feature of RNF is the ability to combine  variables,
        numbers,  and  operators into expressions which compute a numeric value.
        The values computed by the expressions can  in  turn  index  arrays,  be
        assigned to variables, or become a part of the output text.



        4.5.1  Expression Syntax


        An expression is defined as follows:

                 expr      ::= term < relop term >

                 relop     ::= .EQ. Ý .NE. Ý .LT. Ý .LE. Ý .GT. Ý .GE.

                 term      ::= item < < + Ý - > item >...

                 item      ::= < + Ý - Ý # > element

                 element   ::= ( term) Ý var Ý integer

                 var       ::= $id < [ term ] > < = term >


        The angle brackets < and > in the syntax  expressions  enclose  optional
        parts.  The construction

                 < stuff >...


        indicates that stuff is allowed to appear zero or more times.  Note that
        angle  brackets  are used to describe expressions; they do not appear in
        expressions.

        The # character in an expression represents  a  logical  NOT  operation.
        The  expression  #x  has  the value 1 if x equals , otherwise it has the
        value 0.
1


        26                         RNF                          Variables


        The blanks in the syntax expressions are not  significant  and  in  fact
        blanks  are  not permitted in expressions.  That is, and expression must
        be a single word.

        Some examples of valid expressions are:

                 $A.GR.5

                 $HL[$HL+1]=0

                 2+$$PAGE

                 $X[$X=$X+1]=$X[$X]+1

                 $A=$B=$C




        4.5.2  Expression Evaluation


        Expressions are evaluated from left to right,  except  that  assignments
        (indicated by the = sign) at the same level are done from right to left.

        In the examples above, $X[$X=$X+1]=$X[$X]+1 is equivalent to the  series
        of  expressions  $X=$X+1  $X[$X]=$X[$X]+1.   (Recall  that  the  zeroeth
        element of an array can be referenced without subscripts.)  On the other
        hand, the expression $A=$B=$C is equivalent to $B=$C $A=$B.



        4.5.3  Where Expressions Are Used


        An expression can always be used as  an  argument  to  a  command  which
        requires a numeric value.

        An expression can also appear in text.  RNF decides whether to  evaluate
        an  expression  in text or not based on whether the first character is a
        $.  If it is, RNF evaluates the expression; otherwise the expression  is
        treated like any other text word.

        For example, the expression $A+2 will be evaluated, while 2+$A will not.
        If  $A  has  the  value  3, the former will appear in the output as "5",
        while the latter will appear as "2+$A".

        For the few cases when it is not convenient to begin an expression to be
        evaluated with a variable name, the syntax:

                 $(expr)

1


        Variables                  RNF                                 27


        will cause expr to be evaluated.



        4.5.4  Suppressed Expressions


        Frequently, one wishes to compute a value and assign it to a variable --
        that  is,  evaluate  an expression -- without placing anything at all in
        the output text.  This is done by  terminating  the  expression  with  a
        semicolon.

        For example, the words:


                          .VAR $A See $A=$A+1; only $A of these.

                 are output as

                          See only 1 of these.

1


        28                         RNF                          Variables






















                              This page intentionally left blank.
+                             ____ ____ _____________ ____ ______
1


        Examples                   RNF                                 29







                                       CHAPTER 5

                                       EXAMPLES




        This chapter contains a number of short examples  demonstrating  various
        frequently used RNF features.

        The examples are intended  to  be  self-explanatory  and  are  presented
        without  accompanying text.  All but one of the examples was prepared in
        NORMAL mode (RNF default input).
1


        30                         RNF                           Examples


        5.1  INPUT TEXT EXAMPLE

        .C <RNO
        .C ^INPUT ^TEXT

        ^INPUT TEXT TO <RNO CONSISTS OF A SEQUENCE OF WORDS AND COMMANDS
        SEPARATED BY BLANKS.  ^A COMMAND IS ANY WORD WHICH BEGINS WITH
        A PERIOD FOLLOWED BY A NON-DIGIT, WHILE A WORD IS ANY
        SEQUENCE OF CHARACTERS WHICH
        DOES NOT CONTAIN A BLANK.  ^THE FOLLOWING ARE CONSIDERED WORDS:

        .I 5 ^THIS
        .BR .I 5 .^B
        .BR .I 5 ^W^O^RD#^W^I^T^H#^S^I^G^N^I^F^I^C^A^N^T#^B^L^
        .BR .I 5 .234
        .B ^OF THE ABOVE WORDS, ONLY .^B IS A COMMAND.
        .B <RNO GATHERS WORDS INTO LINES.  ^BY DEFAULT, THE FIRST WORD IN
        A LINE BEGINS AT THE LEFT MARGIN, AND THE LAST WORD ENDS AT
        OR BEFORE THE RIGHT MARGIN.  ^THAT IS, LINES ARE LEFT JUSTIFIED.

        ^IN THE OUTPUT,
        AT LEAST ONE BLANK APPEARS BETWEEN WORDS; TWO BLANKS FOLLOW A
        PERIOD OR QUESTION MARK WHICH END A WORD.
1


        Examples                   RNF                                 31


                                          RNO
                                      Input Text

        Input text to RNO consists of a sequence of words and commands separated
        by blanks.  A command is any word which begins with a period followed by
        a non-digit, while a word is any sequence of characters which  does  not
        contain a blank.  The following are considered words:

     This
     .B
     WORD#WITH#SIGNIFICANT#BLANKS
     .234

        Of the above words, only .B is a command.

        RNO  gathers  words  into  lines.   By default, the first word in a line
        begins at the left margin, and the last word ends at or before the right
        margin.  That is, lines are left justified.

        In the output, at least one blank  appears  between  words;  two  blanks
        follow a period or question mark which end a word.
1


        32                         RNF                           Examples


        5.2  PARAGRAPHING

        .C ^PARAGRAPHING
        .P +5 1 5
        .PP ^THE PARAGRAPHING FACILITY IN <RNO ENABLES FAST, CONVENIENT
        TEXT ENTRY IN A NATURAL FORMAT.
        .PP ^PARAGRAPHING IS SET UP BY THE .<P COMMAND, WHICH HAS THE
        FORMAT:
        .B .I 9 .<P INDENT SPACING TEST
        .PP ^INDENT IS THE COLUMN AT WHICH THE FIRST LINE OF EACH
        PARAGRAPH IS TO BEGIN, SPECIFIED EITHER AS AN UNSIGNED COLUMN
        NUMBER OR AS A POSITIVE OR NEGATIVE OFFSET FROM THE CURRENT
        LEFT MARGIN.  ^SPACING SPECIFIES THE NUMBER OF SPACES BETWEEN
        PARAGRAPHS, WHERE 1 IS THE EQUIVALENT OF A <.S 1 COMMAND,
        IS THE EQUIVALENT OF A <.S2 COMMAND, ETC.  ^TEST
        SPECIFIES THE NUMBER OF LINES WHICH
        MUST REMAIN ON THE CURRENT PAGE, OR THE PARAGRAPH IS BEGUN
        ON THE NEXT PAGE.
        .PP ^THE DEFAULT IS:
        .B .I 9 .<P +0 1 3
        .PP ^THE .<PP COMMAND DENOTES THE BEGINNING OF A NEW PARAGRAPH.
        .AP
         ^AS AN ALTERNATIVE (OR IN ADDITION) TO THE <.PP COMMAND, THE USER
        CAN SELECT AUTOPARAGRAPH MODE BY MEANS OF THE <.AP COMMAND.
        ^IF <.AP IS IN EFFECT, A BLANK AT THE BEGINNING OF ANY LINE
        (OR A BLANK LINE)
        IS TAKEN TO BE A <.PP COMMAND.

        (^NOTE THAT A BLANK LINE IN <.NOAP MODE IS TAKEN TO BE A <.B
        COMMAND.)

        ^THE AUTOPARAGRAPH CONVENTIONS ALLOW A TYPIST TO ENTER AND WORK
        WITH ALL TEXT IN A READABLE FORMAT WHICH IS CONVENIENT FOR
        COMPUTER EDITING (FOR EXAMPLE, SINGLE SPACED WITH SINGLE CHARACTER
        INDENTS), YET PRODUCE THE DRAFT AND FINAL COPIES OF WORK
        IN WHATEVER STYLE IS REQUIRED.
1


        Examples                   RNF                                 33


                                     Paragraphing

             The paragraphing facility in  RNO  enables  fast,  convenient  text
        entry in a natural format.

             Paragraphing is set up by the .P command, which has the format:

         .P indent spacing test

             Indent is the column at which the first line of each  paragraph  is
        to begin, specified either as an unsigned column number or as a positive
        or negative offset from the current left margin.  Spacing specifies  the
        number of spaces between paragraphs, where 1 is the equivalent of a .S 1
        command, is the equivalent of a .S2 command, etc.   Test  specifies  the
        number  of lines which must remain on the current page, or the paragraph
        is begun on the next page.

             The default is:

         .P +0 1 3

             The .PP command denotes the beginning of a new paragraph.

             As an alternative (or in addition) to the .PP command, the user can
        select  autoparagraph  mode  by  means of the .AP command.  If .AP is in
        effect, a blank at the beginning of any line (or a blank line) is  taken
        to be a .PP command.

             (Note that a blank line in .NOAP mode is taken to be a .B command.)

             The autoparagraph conventions allow a typist to enter and work with
        all  text  in a readable format which is convenient for computer editing
        (for example, single spaced with single character indents), yet  produce
        the draft and final copies of work in whatever style is required.
1


        34                         RNF                           Examples


        5.3  HEADER LEVEL EXAMPLES

        .AP
        .HL 2 <HOW <TO <USE <HEADER <LEVELS
         ^THE .<HL COMMAND ENABLES THE TYPIST TO ORGANIZE TEXT INTO
        SECTIONS, AND SECTIONS WITHIN SECTIONS, WITH SEQUENTIAL NUMBERS
        WHICH ARE CHANGED BY THE COMPUTER IF SECTIONS ARE ADDED OR
        DELETED.
        .HL 3 ^FORMAT
         ^THE FORMAT OF THE .<HL COMMAND IS:
        .S 1 .I 9 .<HL NUMBER TEXT
         ^THE NUMBER IS THE LEVEL NUMBER, WHERE 1 IS THE OUTERMOST
        LEVEL, 2 IS THE NEXT INNER LEVEL, ETC.  ^THE TEXT IS THE
        TITLE OF THE SECTION.
        .HL 3 ^EFFECT OF THE ^COMMAND
         ^THE .<HL COMMAND STARTS A SECTION AT THE LEVEL SPECIFIED AND
        USES TEXT AS THE HEADER.  ^THE NUMBER CAN BE IN THE RANGE
        FROM 1 TO 5. ^THE SECTION NUMBER OUTPUT IS IN THE FORM
        I.J.K.L.M.  ^IF THE DOCUMENT IS CHAPTER ORIENTED, I IS THE
        CHAPTER NUMBER; OTHERWISE IT IS THE NUMBER OF .<HL 1 COMMANDS
        SINCE THE BEGINNING OF THE INPUT TEXT.
         ^THE COMMAND DOES A RETURN, A TEST PAGE 9, AND PRECEDES THE
        SECTION IDENTIFIER WITH 3 BLANK LINES.
        ^THE MARGINS AND OTHER ENVIRONMENT ARE RESET TO THE VALUES
        THEY HAD BEFORE THE FIRST .<HL COMMAND (IN THE CHAPTER).
        ^THE SECTION NUMBER BEGINS AT THE LEFT MARGIN, FOLLOWED
        BY TWO SPACES, FOLLOWED BY THE TEXT, IF ANY.
         ^A SINGLE BLANK LINE IS INSERTED AFTER THE HEADER.
        .HL 2 <INCREMENTING
         ^SECTION NUMBERS ARE INCREMENTED BY 1 AT THE LEVEL OF THE
        CURRENT .<HL COMMAND.
         ^EACH TIME LEVELS ARE NESTED (FOR EXAMPLE, .<HL 1 FOLLOWED
        BY .<HL 2), THE NUMBERING IS RESTARTED AT 1 FOR THE HIGHER
        NUMBERED LEVEL.
1


        Examples                   RNF                                 35


        5.3.1  HOW TO USE HEADER LEVELS


        The .HL command enables the typist to organize text into  sections,  and
        sections  within  sections, with sequential numbers which are changed by
        the computer if sections are added or deleted.



        5.3.1.1  Format


        The format of the .HL command is:

         .HL number text

        The number is the level number, where 1 is the outermost level, 2 is the
        next inner level, etc.  The text is the title of the section.



        5.3.1.2  Effect of the Command


        The .HL command starts a section at the level specified and uses text as
        the  header.   The  number can be in the range from 1 to 5.  The section
        number output is in the form i.j.k.l.m.   If  the  document  is  chapter
        oriented,  i  is the chapter number; otherwise it is the number of .HL 1
        commands since the beginning of the input text.

        The command does a return, a test  page  9,  and  precedes  the  section
        identifier  with  3  blank lines.  The margins and other environment are
        reset to the values they had  before  the  first  .HL  command  (in  the
        chapter).  The section number begins at the left margin, followed by two
        spaces, followed by the text, if any.

        A single blank line is inserted after the header.



        5.3.2  INCREMENTING


        Section numbers are incremented by 1 at the level  of  the  current  .HL
        command.

        Each time levels are nested (for example, .HL 1 followed by .HL 2),  the
        numbering is restarted at 1 for the higher numbered level.
1


        36                         RNF                           Examples


        5.4  EXAMPLES of LISTS

        .C ^USING ^LISTS
        .AP
         ^AUTOMATICALLY NUMBERED LISTS CAN BE GENERATED BY THE <.LIST,
        <.LE, AND <.ELIST COMMANDS.  ^THE <.LIST COMMAND HAS THE FORMAT:
         .I 9 <.LIST SPACING
         WHERE SPACING IS A NUMBER IN THE RANGE 1 THROUGH 5 WHICH
        SPECIFIES THE SPACING TO BE USED WITHIN THE LIST.
         ^THE LIST IS GENERATED AS FOLLOWS:
        .LIST 1
        .LE ^EACH LIST ELEMENT IS PRECEDED BY THE <.LE COMMAND.
        .LE ^LIST ELEMENTS ARE SEPARATED BY "SPACING" BLANK LINES.
        .LE ^EACH ELEMENT IS AUTOMATICALLY NUMBERED BEGINNING AT
        BY 1.
        .LE ^THE LIST IS TERMINATED BY THE <.ELIST COMMAND (WHICH
        ALSO RESETS THE MARGINS AND SPACING).
        .LE ^LISTS CAN BE NESTED WITHIN LISTS.  ^THIS IS HANDLED
        AS FOLLOWS:
        .LIST 1
        .LE ^THE LEFT MARGIN IS SET 9 COLUMNS TO THE RIGHT FOR
        THE OUTERMOST LIST, AND 4 COLUMNS TO THE RIGHT FOR EACH
        INNER LIST.
        .LE ^EACH <.LIST MUST BE TERMINATED BY A MATCHING <.ELIST.
        ^THE <.ELIST RESETS THE MARGINS AND SPACING AS THEY WERE
        BEFORE THE <.LIST COMMAND.
        .LE ^FOR USERS OF AUTOPARAGRAPHING, THE PARAGRAPH MARGIN
        IS SET TO COINCIDE WITH THE LEFT MARGIN, AND PARAGRAPH
        SPACING IS SET TO THE LIST SPACING PLUS 1.
         ^THIS MEANS THAT AUTOPARAGRAPHING CAN BE CONVENIENTLY
        USED AT ANY LIST LEVEL.
         ^THE PARAGRAPH VALUES ARE RESET BY THE <.ELIST COMMAND.
        .ELIST
        .LE ^LISTS CAN BE NESTED UP TO 5 LEVELS.
        .ELIST
         ^THE LIST FACILITY CAN BE A SIGNIFICANT CONVENIENCE FOR
        THE TYPIST.
1


        Examples                   RNF                                 37


                                      Using Lists

        Automatically numbered lists can be generated by  the  .LIST,  .LE,  and
        .ELIST commands.  The .LIST command has the format:

         .LIST spacing

        where spacing is a number in the range 1 through 5 which  specifies  the
        spacing to be used within the list.

        The list is generated as follows:

             1.  Each list element is preceded by the .LE command.

             2.  List elements are separated by "spacing" blank lines.

             3.  Each element is automatically numbered beginning at by 1.

             4.  The list is terminated by the .ELIST command (which also resets
                 the margins and spacing).

             5.  Lists can be nested within lists.  This is handled as follows:

                 1.  The  left  margin  is  set  9  columns to the right for the
                     outermost list, and 4 columns to the right for  each  inner
                     list.

                 2.  Each .LIST must be terminated by a  matching  .ELIST.   The
                     .ELIST  resets  the margins and spacing as they were before
                     the .LIST command.

                 3.  For  users of autoparagraphing, the paragraph margin is set
                     to coincide with the left margin, and paragraph spacing  is
                     set to the list spacing plus 1.


                     This means that autoparagraphing can be  conveniently  used
                     at any list level.


                     The paragraph values are reset by the .ELIST command.

             6.  Lists can be nested up to 5 levels.

        The list facility can be a significant convenience for the typist.
1


        38                         RNF                           Examples


        5.5  CHANGE BAR EXAMPLES

        .BAR .AP
        .C ^USING ^CHANGE ^BARS
        .B
         ^CHANGE BARS ARE USED TO FLAG TEXT WHICH HAS BEEN
        ALTERED SINCE THE LAST VERSION OF A DOCUMENT, AND ARE
        COMMONLY FOUND ONLY IN TECHNICAL WRITING,
        .BB WHERE THE READER MUST BE ALTERTED TO NEW FEATURES. .EB
         ^THE <.BAR COMMAND ENABLES CHANGE BARS, AND HAS THE IMMEDIATE
        EFFECT OF SHIFTING ALL OUTPUT TEXT RIGHT
        .BB THREE .EB
        SPACES.
        ^THE <.NOBAR COMMAND DISABLES CHANGE BARS.  ^USUALLY, THE .BAR COMMAND
        APPEARS BEFORE ANY TEXT IN A DOCUMENT, SO THE LEFT MARGIN IN THE OUTPUT
        IS UNIFORM.
         ^THE <.BB (^BEGIN ^BAR) COMMAND TURNS ON CHANGE BARS.  ^THAT IS,
        <.BB CAUSES A ! TO APPEAR AT THE LEFT MARGIN FOR ANY LINES WHICH
        ARE OUTPUT AFTER THE <.BB
        .BB (INCLUDING BLANK LINES WHICH ARE A PART OF THE TEXT). .EB
         ^THE <.EB (^END ^BAR) COMMAND SIGNIFIES THE END OF THE CHANGE
        BEGUN BY <.BB, AND TURNS OFF CHANGE BARS.
         .BB ^SPACES CAUSED BY THE <.RIGHT COMMAND APPEAR TO THE LEFT OF
        THE THREE EXTRA COLUMNS USED BY THE <.BAR FEATURE.
         ^BLANK LINES WHICH APPEAR AS A PART OF CHANGED TEXT ARE
        ALSO FLAGGED BY A BAR.
1


        Examples                   RNF                                 39


 Ý                                    Using Change Bars
 Ý
 Ý
 Ý         Change bars are used to flag text which has been altered since the  l
 Ý         version of a document, and are commonly found only in technical writi
 Ý         where the reader must be alterted to new features.

           The .BAR command enables change bars, and has the  immediate  effect
 Ý         shifting  all  output  text  right  three  spaces.   The  .NOBAR comm
           disables change bars.  Usually, the command appears before any text i
           document, so the left margin in the output is uniform.

           The .BB (Begin Bar) command turns on change bars.  That is, .BB cause
           !  to appear at the left margin for any lines which are output after
 Ý         .BB (including blank lines which are a part of the text).

           The .EB (End Bar) command signifies the end of the change begun by  .
           and turns off change bars.

 Ý         Spaces caused by the .RIGHT command appear to  the  left  of  the  th
 Ý         extra columns used by the .BAR feature.
 Ý
 Ý         Blank lines which appear as a part of changed text are also flagged b
 Ý         bar.
1


        40                         RNF                           Examples


        5.6  TAB EXAMPLES

        .ASCII
        .c Using <rno Tabs
        .ap
         <rno tab stops are set by the <.tabs command.  The format is:
         .i 9 <.tabs c1 c2 <... c15
         where c1 through c15 are character positions, in ascending order,
        where the tab stops are to be set.
        (Character positions are numbered beginning at 1). To work
        correctly, tab stops must not be set beyond the right margin.
         Tabs are used by the <.t command, which means "begin the next
        word at the next tab stop".
         For example, the following
         .i 9 <.tabs 10 20 30 40
        .br .i 9 Line <.t this <.t up <.t in <.t columns
         produces
        .tabs 19 29 39 49
         .i 9 Line .t this .t up .t in .t columns
         The following features should be noted:
        .tab 30 .p -21 2 5 .lm 30
         Justification .t Having tabs in a line does not suppress
        justification.  Only the text after the last tab in a line is blank
        padded.  This permits convenient use of "hanging" titles and
        indentation.
         Left/Right .t Tabs produced by <.t cause the following
        word to begin at the next tab stop.  The <.rt
        command causes the following word to end at the
        next tab stop.  This permits creating tables of numeric
        data.
1


        Examples                   RNF                                 41


                                    Using RNO Tabs

        RNO tab stops are set by the .TABS command.  The format is:

         .TABS c1 c2 ...  c15

        where c1 through c15 are character positions, in ascending order,  where
        the  tab  stops  are  to  be  set.   (Character  positions  are numbered
        beginning at 1).  To work correctly, tab stops must not  be  set  beyond
        the right margin.

        Tabs are used by the .T command, which means "begin the next word at the
        next tab stop".

        For example, the following

         .TABS 10 20 30 40
         Line .T this .T up .T in .T columns

        produces

         Line      this      up        in        columns

        The following features should be noted:

         Justification        Having  tabs  in  a   line   does   not   suppress
                              justification.   Only  the text after the last tab
                              in  a  line  is  blank   padded.    This   permits
                              convenient    use    of   "hanging"   titles   and
                              indentation.

         Left/Right           Tabs produced by .T cause the  following  word  to
                              begin  at  the  next  tab  stop.   The .RT command
                              causes the following word to end at the  next  tab
                              stop.   This  permits  creating  tables of numeric
                              data.
1


        42                         RNF                           Examples


        5.7  MACRO EXAMPLES

        .MACRO BBCB 1 = .B .B .C .BBCB1 .B
        .MACRO NOTE * = .SAV .TP 8 .SP 1 .LM +15 .RM -15 .P +0 1 5 .BBCB .NOTE1
        .MACRO ENOTE = .B .B .RES
        .AP
        .C ^THE <NOTE ^COMMAND
         ^THIS EXAMPLE SHOWS THE DEFINITION OF A USEFUL COMMAND VIA THE <.MACRO
        FACILITY.
        .NOTE ^WARNING
        ^THIS COMMAND CAN BE HABIT-FORMING.  ^USE IT SPARINGLY.
        .ENOTE
        ^TRY IT, YOU'LL LIKE IT!
1


        Examples                   RNF                                 43


                                   The NOTE Command

        This example shows the definition of a useful  command  via  the  .MACRO
        facility.


                                        Warning

                       This command can be habit-forming.  Use it
                       sparingly.


        Try it, you'll like it!
1


        44                         RNF                     How To Run RNF







                                       CHAPTER 6

                                    HOW TO RUN RNF



        This is implementation dependent information!

        The following jcl may be used to run RNF:

        //RNF EXEC PGM=RUNOFF,REGION=90K,PARM='/IOBUF=16K',TIME=(2,00)
        //OUTPUT DD SYSOUT=(G,,0721),DCB=(LRECL=133,BLKSIZE=133,RECFM=FBA)
        //QRR DD SYSOUT=A,DCB=(LRECL=90,BLKSIZE=90,RECFM=FB)
        //INPUT DD *
           runoff text
        /*


        NOTES:

        If  you  do not wish to see the input printed, specify DUMMY, instead of
        SYSOUT=A on the QRR DD card.

        Adjust  REGION=90K  if BLKSIZE parameters are too large, but this should
        be sufficient for the normal case.

        Be sure to specify the proper OUTPUT DD sysout class and form.

        Be sure to specify the correct library in the //STEPLIB or  //JOBLIB  DD
        card.
1









                                   TABLE OF CONTENTS
+                                  _____ __ ________


             Section     Title and Page
+            _______     _____ ___ ____

                         CHAPTER 1 -- INTRODUCTION   1
             .1           FEATURES  1
             .2           INPUT TEXT  2
             .2.1         NORMAL Input  2
             .2.2         ASCII Input  2
             .3           WORDS  3
             .4           LINES  3
             .5           SPACING  4
             .6           PARAGRAPHS  4
             .7           PAGES  5
             .7.1         Explicit Paging Control  5
             .7.2         Page Format  5

             2           CHAPTER 2 -- COMMANDS   7
                          .AP  7
                          .ARRAY  7
                          .ASCII  8
                          .ASIS  8
                          .ATITLE  8
                          .AUTOCAP  8
                          .B  8
                          .BAR  9
                          .BB  9
                          .BOT  9
                          .BR  9
                          .C  9
                          .CH  9
                          .CR  10
                          .DEBUG1  10
                          .DEBUG2  10
                          .DEC  10
                          .DELMAC  10
                          .DOT  10
                          .EB  10
                          .ELIST  10
                          .ESC  11
                          .F  11
                          .FIG  11
                          .FLAG  11
                          .FLAGCAPS  11





                                           i
1









                             TABLE OF CONTENTS (Continued)
+                            _____ __ ________ ___________


             Section     Title and Page
+            _______     _____ ___ ____

                          .FLAGOVER  11
                          .FLAGSIG  12
                          .FRCPAGE  12
                          .FMT  12
                          .HL  13
                          .I  13
                          .IF  13
                          .INC  13
                          .J  14
                          .LE  14
                          .LINES  14
                          .LIST  14
                          .LPT  14
                          .LM  14
                          .LOWER  14
                          .MACRO  14
                          .MID  15
                          .NMP  15
                          .P  15
                          .PAGE  15
                          .PERIOD  15
                          .PNO  16
                          .PP  16
                          .PS  16
                          .REM  16
                          .RES  16
                          .RESPAG  16
                          .RIGHT  16
                          .RM  16
                          .RT  17
                          .S  17
                          .SAV  17
                          .SAVPAG  17
                          .SIG  17
                          .SP  17
                          .ST  18
                          .STD  18
                          .SUP  18
                          .T  18
                          .TABS  18





                                          ii
1









                             TABLE OF CONTENTS (Continued)
+                            _____ __ ________ ___________


             Section     Title and Page
+            _______     _____ ___ ____

                          .TITLE  18
                          .TOP  18
                          .TP  18
                          .U  19
                          .UPP  19
                          .UPPER  19
                          .USB  19
                          .VAR  19
                          .X  19

             3           CHAPTER 3 -- MACROS   21
             .1           WHAT MACROS ARE  21
             .2           HOW TO DEFINE A MACRO  22
             .3           SUB-MACROS  22
             .3.1         Defining Parameterized Macros  23
             .3.2         Sub-macro Semantics  23

             4           CHAPTER 4 -- VARIABLES   24
             .1           VARIABLE SYNTAX  24
             .2           HOW TO DECLARE VARIABLES  25
             .3           PREDEFINED VARIABLES  25
             .4           VARIABLE ARRAYS  25
             .5           EXPRESSIONS  26
             .5.1         Expression Syntax  26
             .5.2         Expression Evaluation  27
             .5.3         Where Expressions Are Used  27
             .5.4         Suppressed Expressions  28

             5           CHAPTER 5 -- EXAMPLES   30
             .1           INPUT TEXT EXAMPLE  31
             .2           PARAGRAPHING  33
             .3           HEADER LEVEL EXAMPLES  35
             .4           EXAMPLES OF LISTS  37
             .5           CHANGE BAR EXAMPLES  39
             .6           TAB EXAMPLES  41
             .7           MACRO EXAMPLES  43

             6           CHAPTER 6 -- HOW TO RUN RNF   45







                                          iii
1
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB RNFDOCIN EXT PAS HEX -
.LM +7 .RM +7
.REM .RIGHT 10
.MACRO INPAG   = .SAV .RESPAG .S 3
.MACRO OUTPAG  = .S 2 .RES
.MACRO LPAG    = .IF $LP $$PAGE=$$PAGE+1 .T <RNF .RT .CHTTL
.MACRO RPAG    = .IF #$LP .CHTTL .T <RNF .RT $$PAGE=$$PAGE+1
.MACRO CH *    = .PAGE .RESPAG .BR # .BR .S 4 .CHA .B .CHB .S 3 $$HL=0;
.MACRO CHA     = .C <CHAPTER $$CH=$$CH+1 .BR
.MACRO CHB     = .C .CH1 .BR
.MACRO BDOT = .SAV .P -2 1 5 .LM +5
.MACRO DOT = .PP _.# .X
.MACRO EDOT = .RES .S 1
.VAR $LP
.TAB 35 72 .SP 1 .SAVPAG
.PS 58 72 .LINES 66
.AP .P +0 1 4
.NONMP
.FIG 20
.C .U <RNF
.B
.C ^TEXT ^PROCESSOR .NOU
.B .B
.C ^REFERENCE ^GUIDE
$$PAGE=0;
.MACRO FRCPAGE = .TOP .INPAG .LPAG .RPAG .OUTPAG .MID $LP=#$LP;
.MACRO CHTTL   = ^INTRODUCTION
.CH <INTRODUCTION
 <RNF IS A TEXT FORMATTING PROGRAM FOR THE ^CYBER SIMILIAR TO THE
<RUNOFF PROGRAM AVAILABLE ON THE <DEC<SYSTEM-10.
 <RNF ACCEPTS (MOSTLY) FREE-FORMAT TEXT WHICH HAS BEEN PUT IN
A FILE AND EDITED BY <BOSS, AND PRODUCES OUTPUT SUITABLE FOR
A LINE PRINTER OR A TYPEWRITER-LIKE TERMINAL DEVICE.
.HL 1 ^FEATURES
 <RNF DOES ANY OR ALL OF THE FOLLOWING FOR THE USER:
.SAV .P -16 1 3 .LM 25 .TABS 25
 ^PAGINATION .T <RNF AUTOMATICALLY BREAKS TEXT UP INTO
PAGES, AND BY DEFAULT NUMBERS THEM SEQUENTIALLY.
 ^FILL .T ^USING THE MARGINS SET BY THE USER, <RNF
AUTOMATICALLY "FILLS" EACH LINE OF THE OUTPUT WITH AS MANY WORDS
AS IT CAN HOLD WITHOUT EXCEEDING THE RIGHT MARGIN.  ^FILLING
STOPS AT THE END OF A PARAGRAPH, ETC.
 ^JUSTIFICATION .T <RNF WILL OPTIONALLY JUSTIFY FILLED LINES
ON THE RIGHT, SO THAT THE RIGHT MARGIN "LINES UP" EVENLY.
 ^CHAPTERING .T <RNF WILL FORMAT CHAPTER TITLES, AND
NUMBER CHAPTERS SEQUENTIALLY.
 ^SECTIONING .T <RNF WILL FORMAT SECTION HEADERS AND NUMBER
SECTIONS AND SUBSECTIONS SEQUENTIALLY.
 ^LISTS .T <RNF WILL FORMAT AND NUMBER LISTS AND
SUBLISTS.
.RES
 ^IN ADDITION TO THE FEATURES WHICH ARE BUILT IN,
<RNF PROVIDES AN EASY TO USE MACRO FACILITY WHICH PERMITS
THE USER TO DEFINE COMMANDS WHICH ARE CUSTOMIZED TO A PARTICULAR
APPLICATION.
.HL 1 ^INPUT ^TEXT
 ^THE INPUT TO <RNF MAY BE PREPARED EITHER ON AN UPPER CASE ONLY
DEVICE LIKE A ^TELETYPE OR PUNCHED CARDS, OR ON AN UPPER/LOWER
CASE TERMINAL.  ^THESE ARE CALLED <NORMAL AND <ASCII DEVICES,
RESPECTIVELY.
 ^REGARDLESS OF THE INPUT MEDIUM, OUTPUT FROM <RNF IS IN UPPER/LOWER
CASE.  ^THIS IS ACCOMPLISHED BY THE FOLLOWING CONVENTIONS:
.HL 2 <NORMAL ^INPUT
 ^BY CONVENTION, <RNF INVERTS THE CASE OF ALPHABETIC CHARACTERS IN
THE INPUT.
^UPPER CASE CHARACTERS ARE INDICATED BY A PRECEDING _^.  ^FOR
EXAMPLE, THE FOLLOWING <NORMAL INPUT
.ASCII
 .I 9 _^THIS IS AN _^U_^P_^P_^E_^R/LOWER CASE LINE.
.NOASCII
 IS OUTPUT BY <RNF AS
 .I 9 ^THIS IS AN <UPPER/<LOWER CASE LINE.
 ^AS A CONVENIENCE, THE _< CHARACTER WILL INVERT THE CASE OF ALL
ALPHABETIC CHARACTERS WHICH FOLLOW IT IN THE SAME WORD.
^FOR EXAMPLE,
.ASCII
 .I 9 _^SOME _<UPPER _<CASE AND SOME LOWER CASE.
 .I 9 SOME_<OF_<BOTH
.NOASCII
 ARE OUTPUT AS
 .I 9 ^SOME <UPPER <CASE AND SOME LOWER CASE.
 .I 9 SOME<OF<BOTH
 ^IN EXCHANGE FOR THIS CONVENIENCE, THE CHARACTERS _^ AND _@ MUST
BE REPRESENTED IN <NORMAL INPUT AS _@^B AND _@^A, RESPECTIVELY.
.HL 2 <ASCII ^INPUT
 ^UPPER/LOWER CASE TEXT CAN BE ENTERED IN A FILE BY USING <ASCII
MODE IN <BOSS.  ^WHEN SUBMITTED TO <RNF, THIS TEXT MUST BE PRECEDED
BY AN <.ASCII COMMAND.
^THE _< CHARACTER WORKS THE SAME.
.HL 1 <WORDS
 <RNF INPUT IS A SERIES OF WORDS, WHERE A WORD IS ANY SEQUENCE
OF NON-BLANK CHARACTERS.
 ^BLANKS IN THE INPUT TEXT ARE NOT (USUALLY) SIGNIFICANT TO
<RNF, EXCEPT THAT THEY DELIMIT WORDS.  <RNF INSERTS ONE
BLANK BETWEEN EACH WORD, AND TWO BLANKS AFTER WORDS WHICH
END SENTENCES.
 ^IF A SEQUENCE OF BLANKS MUST APPEAR IN THE OUTPUT, THE
SIGNIFICANT BLANK CHARACTER _# IS USED.  ^FOR EXAMPLE,
BE_#_#_#_#TWEEN IS OUTPUT AS BE####TWEEN.
.HL 1 <LINES
 ^IN DEFAULT MODE, WORDS ARE
PICKED FROM THE INPUT ONE BY ONE AND PLACED INTO AN OUTPUT
LINE.  ^WHEN AN OUTPUT LINE IS FULL, IT IS WRITTEN INTO THE
OUTPUT FILE.
 ^THE USER SETS THE LEFT AND RIGHT MARGINS OF THE OUTPUT PAGE
BY THE <.LM AND <.RM COMMANDS, RESPECTIVELY.
^TEXT ON THE OUTPUT LINE IS WRITTEN BEGINNING AT THE LEFT MARGIN
AND NOT PAST THE RIGHT MARGIN.
 ^FILLING MEANS THAT (UNLESS THE USER SPECIFICALLY DIRECTS OTHERWISE)
AS MANY WORDS AS POSSIBLE ARE USED TO FILL EACH OUTPUT LINE.
 ^JUSTIFICATION MEANS THAT BLANK CHARACTERS ARE ADDED BETWEEN
WORDS SO THAT THE LAST CHARACTER ON EACH LINE IS EXACTLY ON THE
RIGHT MARGIN.
 ^THE <.F AND <.J COMMANDS CONTROL FILLING AND JUSTIFICATION.
 ^THE DEFAULT LEFT MARGIN IS 1 AND THE DEFAULT RIGHT MARGIN IS
72.  ^FOR ^ELITE TYPE (12 CHARACTERS PER INCH) THIS PRODUCES
A 6-INCH WIDE LINE, WHICH ALLOWS 1 AND 1/4 INCH MARGINS ON
STANDARD 8 AND 1/2 INCH PAPER.  ^FOR ^PICA TYPE (10 CHARACTERS
PER INCH) <.LM 1 AND <.RM 60 PROVIDE THE SAME SIZE LINE.
 ^FOR MOST PURPOSES, IT IS RECOMMENDED THAT THE LEFT MARGIN BE
INITIALLY SET TO 1, AS THIS IS EASY TO WORK WITH AND REMEMBER.
^IF THE TEXT MUST BE SHIFTED TO THE RIGHT FOR OUTPUT ON A
TYPEWRITER PAGE, THE <.RIGHT COMMAND MAY BE USED.
.HL 1 <SPACING
 ^THE INPUT TO <RNF IS SINGLE SPACED.  ^THE OUTPUT MAY BE SINGLE
SPACED, DOUBLE SPACED, OR TRIPLE SPACED AS THE USER CHOOSES.
 ^SPACING IS SET BY THE <.SP COMMAND,.
^ONCE SET, <RNF WILL AUTOMATICALLY
CONTROL SPACING WITHOUT REQUIRING ANY FURTHER ACTION
ON THE PART OF THE USER.  ^IF EXTRA SPACES OR NON-STANDARD SPACING
IS DESIRED, HOWEVER, <RNF PROVIDES COMMANDS FOR THESE, TOO.
 ^THE <.CR COMMAND PROVIDES THE EQUIVALENT OF A CARRIAGE RETURN
KEY ON AN ELECTRIC TYPEWRITER.  ^THE <.CR ENDS THE CURRENT LINE
AND SPACES AS SET BY <.SP.  ^THAT IS, IF SINGLE SPACING IS
SELECTED (<.SP 1), THE <.CR "RETURNS THE CARRIAGE" TO THE NEXT
LINE; IF DOUBLE SPACING IS SELECTED (<.SP 2), THE <.CR LEAVES
A SINGLE BLANK LINE AFTER THE CURRENT LINE, AND SO ON.  ^THROUGHOUT
THIS MANUAL, THE ACTION OF THE <.CR IS REFERRED TO AS A "RETURN".
^MANY COMMANDS CAUSE A RETURN AS A PRELUDE TO FURTHER ACTION.
 ^THE <.S COMMAND CAUSES A RETURN, FOLLOWED BY ANY NUMBER OF EXTRA
RETURNS.
<.S AND <.S#1 MEAN THE SAME, I.E., A RETURN AND ONE EXTRA RETURN.
<.S#2 PROVIDES TWO EXTRA RETURNS, AND SO ON.
 <.CR AND <.S ALWAYS HONOR THE SPACING SET BY <.SP.  ^THE USER
CAN ESCAPE SPACING BY MEANS OF THE <.BR AND <.B COMMANDS.
 <.BR PROVIDES A "BREAK"; IT RETURNS THE CARRIAGE AND PROCEEDS
ON THE NEXT LINE, REGARDLESS OF SPACING.  <.B CAUSES ANY NUMBER
OF BLANK LINES AFTER THE CURRENT LINE.  <.B AND <.B#1 MEAN THE
SAME: BREAK AND LEAVE ONE BLANK LINE AFTER THE CURRENT LINE.
<.B#2 LEAVES TWO BLANK LINES, AND SO ON.
 ^THUS, THE USER CAN CREATE SPACING INDEPENDENT TEXT BY USING
ONLY <.CR AND <.S COMMANDS FOR SPACING.  <.BR AND <.B ARE USED
WHEN SPACING IS TO BE FIXED REGARDLESS OF THE <.SP SETTING.
.HL 1 <PARAGRAPHS
 <RNF PROVIDES BOTH EXPLICIT AND AUTOMATIC PARAGRAPHING FACILITIES.
^THE <.P COMMAND CONTROLS THE INDENTATION, SPACING, AND LOCATION
OF EACH PARAGRAPH.  ^THE <.PP COMMAND BEGINS A NEW PARAGRAPH.
 ^AUTOPARAGRAPHING, CONTROLLED BY THE <.AP COMMAND, CAUSES AN
IMPLICIT <.PP COMMAND EACH TIME EITHER A BLANK LINE OR A LINE
BEGINNING WITH BLANK IS ENCOUNTERED IN THE INPUT TEXT.
^THIS IS A CONVENIENT FORMAT FOR TEXT ENTRY, AND ALLOWS
EASY MODIFICATION.
^BY USE OF THE <.SP (^S^PACING) AND <.P COMMANDS, THE SAME INPUT
TEXT CAN BE USED FOR PRODUCING BOTH DOUBLE (OR TRIPLE) SPACED DRAFTS
AND SINGLE SPACED FINAL COPY.
 ^PARAGRAPHING IS SUFFICIENTLY FLEXIBLE TO BE USED FOR
"HANGING INDENTS".
^IN ADDITION, THE FACT THAT PARAGRAPH INDENTATION CAN BE
SPECIFIED RELATIVE TO THE LEFT MARGIN (EVEN IF IT IS LATER
CHANGED) ALLOWS PARAGRAPHING TO BE CONVENIENTLY USED IN
INDENTED TEXT.
.HL 1 <PAGES
 ^LINES ARE AUTOMATICALLY SEPARATED INTO PAGES BY <RNF.
^TWO COMMANDS CONTROL THE SIZE OF <RNF PAGES: <.PS (^PAGE ^SIZE)
AND <.LINES.
 ^THE FIRST ARGUMENT OF <.PS SPECIFIES THE NUMBER OF LINES WHICH
ARE ALLOWED ON A PAGE BEFORE AN AUTOMATIC PAGE THROW IS DONE.
^THIS NUMBER INCLUDES THE LINES IN THE HEADER AT THE TOP OF EACH
PAGE, AND THE NORMAL TEXT ON THE PAGE, BUT DOES NOT INCLUDE THE
LINES IN THE FOOTER (IF ANY) AT THE BOTTOM OF THE PAGE.
^THE <.LINES COMMAND SPECIFIES THE NUMBER OF LINES ON THE
ENTIRE PAGE.  ^THIS NUMBER IS USED WHEN SIMULATING PAGE EJECTS
ON TERMINALS WITH CONTINUOUS FORMS.
 ^THE DEFAULT <.PS FIRST ARGUMENT AND <.LINES ARE 58 AND 66,
RESPECTIVELY.  ^THIS ALLOWS AT LEAST A 1 AND 1/3 INCH BOTTOM
MARGIN WITH 6 LINE PER INCH PRINTING, AND A 1 INCH MARGIN WITH
LINE PER INCH PRINTING ON STANDARD <CSO REDUCED FORMS.
 ^SOME TERMINALS USE REDUCED FORMS BUT PRINT 6 LINES PER INCH.
^THIS MEANS THERE ARE 51 LINES ON EACH PAGE; A <.PS FIRST ARGUMENT
OF 44 WILL ALLOW A 1 INCH BOTTOM MARGIN.
.HL 2 ^EXPLICIT PAGING CONTROL
 ^THE <.PAGE COMMAND ALLOWS THE USER TO ADVANCE TO THE NEXT PAGE
EXPLICITLY.  ^THE <.NMP AND <.PNO COMMANDS CONTROL PAGE NUMBERING,
AND THE <.TITLE, <.ST, AND <.ATITLE COMMANDS PROVIDE FOR PRINTING
TITLES AT THE TOP OF EACH PAGE.
.HL 2 ^PAGE ^FORMAT
 ^A PAGE IS DIVIDED INTO THREE AREAS:
.BDOT .DOT ^THE TOP, WHICH CONTAINS THE UPPER MARGIN AND OPTIONAL
TITLES AND PAGE NUMBER.
.DOT ^THE MIDDLE, WHICH CONTAINS THE TEXT OF THE DOCUMENT.
.DOT ^THE BOTTOM, WHICH MAY CONTAIN A FOOTER.  (^BY DEFAULT, NO
FOOTER IS PRINTED.)
.EDOT
 ^THE DEFAULT HEADER CONSISTS OF AN OPTIONAL TITLE ON THE LEFT AND
THE PAGE NUMBER AS AN ^ARABIC NUMBER ON THE RIGHT OF THE FOURTH
LINE ON THE PAGE.
^THE SUBTITLE, IF ANY, IS BELOW THE TITLE ON THE FOLLOWING LINE.
^TWO BLANK LINES ARE LEFT BELOW THE HEADER.
 ^IF THIS DEFAULT FORMAT IS NOT SATISFACTORY FOR A SPECIFIC
DOCUMENT, THE USER MAY SUBSTITUTE ANY ARBITRARY HEADER AND
FOOTER TEXT BY MEANS OF A <.FRCPAGE MACRO DEFINITION (SEE ^CHAPTER 3)
AND USE OF THE PAGING INTRINSICS <.TOP, <.MID, AND <.BOT.
 ^THE PAGE NUMBER USED BY <RNF MAY BE ACCESSED DIRECTLY THROUGH
THE PREDEFINED VARIABLE <$$PAGE (SEE ^CHAPTER 4).
.MACRO CHTTL = ^COMMANDS
.CH <COMMANDS
 ^ANY SEQUENCE OF NON-BLANK CHARACTERS BEGINNING WITH A PERIOD
(.) ARE TAKEN BY <RNF TO BE A COMMAND.  ^IF THE COMMAND IS NOT
RECOGNIZED, AN ERROR MESSAGE IS PRODUCED.
 ^MANY COMMANDS REQUIRE ARGUMENTS, I.E., WORDS WHICH FOLLOW
THE COMMAND AND MODIFY ITS ACTION IN SOME WAY.
^THE ONLY COMMANDS WHICH PERMIT A VARIABLE NUMBER OF ARGUMENTS
ARE <.TAB (OR <.TABS), <.B, AND <.S.
IF ANY OTHER COMMAND REQUIRES AN ARGUMENT, IT MUST BE SPECIFIED.
 ^COMMANDS MAY BE FREELY INTERSPERSED WITH TEXT.  ^SOME COMMANDS
CAUSE A "RETURN" (THAT IS, ACT AS IF THEY WERE PRECEDED BY A
<.CR COMMAND) AS A PART OF THEIR ACTION.  ^IF A COMMAND CAUSES
A RETURN, THIS IS INDICATED IN PARENTHESIS AFTER THE COMMAND
FORMAT.
^OTHER COMMANDS CAUSE A "BREAK" (THAT IS, ACT AS IF THEY WERE
PRECEDED BY A <.BR COMMAND) AS A PART OF THEIR ACTION.
^THESE ARE INDICATED BY (^BREAK) IN PARENTHESIS.
 ^NOTE THAT A BLANK MUST FOLLOW A COMMAND IF THERE IS MORE TEXT ON
THE SAME LINE.  ^FOR EXAMPLE, THE SEQUENCE "<.B.I#5" IS IN ERROR;
IT MUST BE WRITTEN AS "<.B#.I#5".
.LM 9
.TAB 72
.P -4 2 4
 <.AP
.B ^ANY BLANK LINE OR ANY LINE BEGINNING WITH A BLANK CHARACTER
BEGINS A NEW PARAGRAPH.  ^SEE THE <.P AND THE <.PP COMMANDS.
<.NOAP TURNS AUTOPARAGRAPHING OFF AND IS THE DEFAULT.
 <.ARRAY VARIABLENAME N
.B ^THIS COMMAND DECLARES AN ARRAY VARIABLE WITH THE NAME SPECIFIED
AND N+1 ELEMENTS.  ^AN ELEMENT OF THE ARRAY IS LATER ACCESSED OR
CHANGED BY A REFERENCE OF THE FORM:
.B .I 9 VARIABLENAME[EXPRESSION]
.B WHERE EXPRESSION MAY BE IN THE RANGE 0 THROUGH N.
^THE ZEROETH ELEMENT OF THE ARRAY MAY BE REFERRED TO WITHOUT
A [0] SUBSCRIPT, AND IS COMMONLY USED AS AN INDEX INTO THE
REMAINDER OF THE ARRAY.
.B ^ALL ARRAY ELEMENTS HAVE THE INITIAL VALUE ZERO. ^ARRAY NAMES
MUST BE FORMED AS DEFINED FOR THE <.VAR COMMAND.
 <.ASCII
.B ^THE INPUT WAS PREPARED IN <ASCII MODE ON AN UPPER/LOWER CASE
TERMINAL.
^WHEN IN <ASCII MODE CAHRACTERS ARE NOT AUTOMATICALLY CASE INVERTED. ^ALSO THE
EFFECT OF THE _^ CHARACTER IS REVERSED, IN <ASCII MODE _^ LOWERS A CAPITAL
LETTER AND DOES NOTHING TO A LOWER CASE LETTER.
^THE DEFAULT IS <.NOASCII.
 <.ASIS .RT (^RETURN)
.B ^TERMINATES THE CURRENT INPUT LINE AND ENTERS AS IS MODE BEGINNING
WITH THE NEXT INPUT LINE.
.B ^IN AS IS MODE, INPUT LINES ARE COPIED DIRECTLY TO THE OUTPUT
(EXCEPT THAT THE LEFT MARGIN, CHANGE BARS, AND <.RIGHT SPACING
ARE STILL HONORED).
.B ^AS IS MODE IS TERMINATED BY A LINE WITH AN EXCLAMATION MARK
(!) IN COLUMN 1.  ^ALL CHARACTERS AFTER THE EXCLAMATION MARK ARE
IGNORED, AND NORMAL PROCESSING BEGINS WITH THE FOLLOWING LINE.
.B ^NOTE THAT AS IS TEXT WHICH IS INTENDED TO BE OUTPUT
AS UPPER/LOWER CASE (<ASCII) MUST BE INPUT IN <ASCII.
.U ^NO .NOU PROCESSING IS DONE ON AS IS TEXT.
 <.ATITLE
.B ^ENABLES AUTOTITLING, WHICH MAKES EACH NEW CHAPTER HEADING
THE TITLE FOR ALL BUT THE FIRST PAGE OF THE CHAPTER.  ^THE
DEFAULT IS <.NOATITLE.
   <.AUTOCAP
.B ^ENABLES THE AUTO CAPITALIZATION, WHICH MAKES THE CHARACTER FOLLOWING
A _., _!, _?, REMAIN IN UPPER CASE. ^THIS IS DISABLED IN <ASCII MODE.
^IT TAKES EFFECT AFTER THE FIRST PUNCTUATION MARK, SO IT MAY NOT AFFECT
TITLES OR THE FIRST LINE. <NOAUTOCAP IS THE DEFAULT.
 <.B .RT (^BREAK)
.BR .I -4 <.B N .RT (^BREAK)
.B ^ENDS THE CURRENT LINE AND WRITES IT WITHOUT FURTHER FILLING
OR JUSTIFICATION (CAUSES A BREAK), THEN WRITES N BLANK LINES.
<.B AND <.B#1 ARE EQUIVALENT.
 <.BAR
.B ^ENABLES CHANGE BARS.  ^ALL TEXT FOLLOWING THE <.BAR COMMAND
IS SHIFTED RIGHT THREE SPACES.  ^SEE THE <.BB AND <.EB COMMANDS.
^THE DEFAULT IS <.NOBAR.
 <.BB
.B ^BEGIN PLACING CHANGE BARS (VERTICAL BARS) IN THE MARGIN
CREATED BY THE <.BAR COMMAND BEGINNING WITH THE LINE WHICH
CONTAINS THE FIRST WORD IN THE TEXT FOLLOWING THE <.BB COMMAND.
^SEE THE <.EB COMMAND.
 <.BOT
.B ^SETS THE BEGINNING OF USER TEXT (ON THE PAGE) TO THE CURRENT OUTPUT LINE
NUMBER
AND RESTORES ANY OUTPUT LINES WHICH MIGHT HAVE
BEEN SAVED ON A FORCED PAGE EJECT (SEE <.FRCPAGE).
^IF ANY DEFERRED TEXT IS PENDING (SEE THE <.FIG COMMAND), AS MUCH OF IT
AS POSSIBLE IS OUTPUT BY <.BOT.  ^IF AS IS MODE WAS IN EFFECT AT THE TIME OF
THE LAST <.FRCPAGE, IT IS RESTORED.
.B ^THE <.BOT
COMMAND IS TO BE USED ONLY WHEN OVERRIDING THE DEFAULT
HEADER FORMAT VIA MACROS.
.B ^THE <.B AND <.S COMMANDS HAVE NO EFFECT AT THE BEGINNING
OF USER TEXT ON A PAGE.  ^THIS PREVENTS SPURIOUS BLANK LINES AT THE TOP
OF A TEXT PAGE.
 <.BR .RT (^BREAK)
.B ^ENDS THE CURRENT OUTTPUT LINE AND WRITES IT WITHOUT FURTHER
FILLING OR JUSTIFICATION.  ^NO EXTRA BLANK LINES ARE LEFT BY
<.BR, REGARDLESS OF SPACING.
 <.C TEXT .RT (^RETURN)
.B ^CENTERS THE TEXT WHICH FOLLOWS THE <.C COMMAND ON THE
SAME LINE.  ^CENTERING IS BETWEEN THE CURRENT LEFT AND RIGHT
MARGINS.
 <.CH TITLE .RT (^RETURN)
.B ^BEGINS A NEW CHAPTER WITH THE TITLE WHICH FOLLOWS ON THE
SAME LINE.  ^A NEW PAGE IS BEGIN, TITLES AND SUBTITLES ARE
CLEARED, A <.FIG 12 IS DONE, FOLLOWED BY THE WORD <CHAPTER
CENTERED, A <.B, FOLLOWED BY THE TITLE CENTERED.  ^PAGE NUMBERING
IS NOT AFFECTED.  ^IF <.ATITLE IS ON, THE CHAPTER TITLE IS
SET AS THE <.TITLE FOR SUCCEEDING PAGES.
 <.CR .RT (^RETURN)
.B ^CAUSES A CARRIAGE RETURN, WHICH IS A <.BR FOLLOWED BY
SPACING MINUS ONE BLANK LINES.
.B ^NOTE THAT <.CR IS IMPLIED BEFORE ANY COMMAND FOR WHICH
(^RETURN) IS INDICATED.
 <.DEBUG1
.B ^CAUSES ALL FOLLOWING LINES TO BE PREFIXED WITH THE RELATIVE
LINE NUMBER OF THE PAGE. ^THIS PRECEDES THE CARRIAGE CONTROL, IF ANY.
<.DEBUG1 ALSO INCLUDES <.DEBUG2. <.NODEBUG1 IS THE DEFAULT. ^THIS
IS USEFUL FOR FINDING PROBLEMS WHEN CREATING A DOCUMENT WITH MANY PAGE EJECTS.
 <.DEBUG2
.B ^CAUSES ALL FOLLOWING LINES TO BE TRAILED BY THE INPUT LINE NUMBER ON THE
EXTREME RIGHT MARGIN (NOT NECESARILY THE MARGIN SET BY <.RM). ^THIS IS
VERY USEFUL FOR DOCUMENT PREPARATION, TO CORRELATE A PROBLEM TO THE INPUT LINE
CAUSING IT. <.NODEBUG2 IS THE DEFAULT.
 <.DEC VARIABLENAME
.B ^DECREMENT THE VARIABLENAME.
 <.DELMAC MACRONAME
.B ^DELETES THE MACRO NAME, SO THAT IT MAY BE REUSED.
 <.DOT
.B ^CAUSES ALL FOLLOWING <.T OR <.RT COMMANDS TO FILL WITH DOTS (PERIODS)
INSTEAD OF SPACES.  ^A BLANK IS ALWAYS LEFT BEFORE AND AFTER
THE STRING OF DOTS.
<.NODOTS RETURNS TO FILLING TABS WITH SPACES.
 <.EB
.B ^END CHANGE BARS.  ^THE LAST LINE FLAGGED IS THE ONE WHICH
CONTAINS THE WORD JUST PRECEDING THE <.EB COMMAND.
 <.ELIST
.B ^END LIST.  ^TERMINATES THE INNERMOST ACTIVE LIST.  ^SEE
THE <.LIST COMMAND.
 <.ESC
.B ^ENABLES THE ESCAPE CHARACTER __ (BACKARROW OR UNDERLINE).
^WHEN ENABLED, THE ESCAPE CHARACTER CAUSES THE CHARACTER WHICH
FOLLOWS IT TO BE COPIED TO THE OUTPUT TEXT WITHOUT SPECIAL
ACTION. ^FOR EXAMPLE, 23__. CAUSES 23_. TO BE TYPED WITHOUT
AN EXTRA TRAILING BLANK.  ^THE DEFAULT IS <.ESC.
 <.F
.B ^FILLS EACH OUTPUT LINE WITH AS MANY WORDS FROM THE INPUT
AS POSSIBLE WITHOUT EXCEEDING THE RIGHT MARGIN.
^BLANKS ARE REMOVED FROM THE INPUT.  ^EACH WORD OF THE OUTPUT
IS FOLLOWED BY AT LEAST ONE BLANK, WHILE WORDS WHICH END IN
_., _!, OR _? ARE FOLLOWED BY AT LEAST TWO BLANKS.
<.NOF SUPPRESSES FILL.
 <.FIG N
.B ^RESERVES N LINES FOR A FIGURE.  ^IF THE LINES WILL FIT ON THE
CURRENT PAGE, <.FIG CAUSES A RETURN AND LEAVES N BLANK LINES.
^IF NOT, N BLANK LINES ARE LEFT AT THE BEGINNING OF THE NEXT
PAGE.
 <.FLAG
.B ^CAUSES _^ AND _@ TO BE RECOGNIZED AS FLAG CHARACTERS.
<.FLAG IS THE DEFAULT; <.NOFLAG SUPPRESSES RECOGNITION.
 <.FLAGCAPS
.B ^CAUSES THE _< CHARACTER TO INVERT THE CASE OF ANY LETTERS
IN A WORD WHICH FOLLOW IT.  ^FOR EXAMPLE, <_<UP_<AND_<THEN_<DOWN
IS OUTPUT AS <UP<AND<THEN<DOWN.
<.NOFLAG SUPPRESSES SPECIAL ACTION FOR THE _< CHARACTER.
<.FLAG IS THE DEFAULT.
 <.FLAGOVER
.B ^THE <.FLAGOVER COMMAND ENABLES RECOGNITION OF _\ (BACKSLASH)
AS THE STRIKEOVER CHARACTER.  ^THE STRIKEOVER CHARACTER
IS WRITTEN BETWEEN THE CHARACTER TO BE OVERSTRUCK AND THE CHARACTER
WHICH IS TO OVERSTRIKE IT.  ^FOR EXAMPLE, <STRIKEO_\/VER IS
OUTPUT AS <STRIKEO\/VER.
.B ^UNDERLINING COUNTS AS ONE OVERSTRIKE.  ^ANY CHARACTER MAY BE
OVERSTRUCK UP TO THREE TIMES.  ^OVERSTRIKING MAY BE USED ONLY
WITHIN A WORD; THE OVERSTRIKE CHARACTER HAS NO MEANING BY ITSELF
OR BEGINNING A WORD.
.B <.FLAGOVER IS THE DEFAULT.  <.NOFLAGOVER TURNS IT OFF.
 <.FLAGSIG
.B ^THE <.FLAGSIG COMMAND ENABLES RECOGNITION OF _# (SHARP)
AS THE SIGNIFICANT BLANK CHARACTER.  <.FLAGSIG IS THE DEFAULT.
<.NOFLAGSIG TURNS IT OFF.
 <.FRCPAGE
.B ^THIS COMMAND IS USED INTERNALLY BY <RNF TO FORCE A PAGE
EJECT.  ^THAT IS, IF A LINE IS ABOUT TO BE WRITTEN WHICH WOULD
EXCEED THE PAGE SIZE, THE LINE IS SAVED, AND A <.FRCPAGE COMMAND
IS EXECUTED AS THOUGH IT HAD BEEN ENCOUNTERED IN THE INPUT
TEXT.
 .B ^THE <.FRCPAGE COMMAND ITSELF INVOKES THE EQUIVALENT OF
<.TOP, PRINTS THE NEXT PAGE HEADER, AND INVOKES THE EQUIVALENT
OF <.MID.
.B ^THE USER MAY ADD A FOOTER OR REFORMAT THE PAGE HEADER BY
DEFINING A MACRO WITH THE NAME <.FRCPAGE.  ^THIS REPLACES THE
<.FRCPAGE COMMAND, AND MUST INVOKE THE <.TOP AND <.MID COMMANDS
(AND OPTIONALLY THE <.BOT COMMAND) EXPLICITLY.  ^FOR CORRECT
OPERATION, THE .U FIRST .NOU WORD IN THE <.FRCPAGE MACRO MUST
BE EITHER <.BOT OR <.TOP, AND THE LAST WORD SHOULD BE <.MID.
.B ^NOTE THAT <.FRCPAGE DOES NOT RETURN, NOR CAN IT, SINCE A
RETURN CAN CAUSE A PAGE EJECT, WHICH WILL CAUSE A <.FRCPAGE
TO BE INVOKED RECURSIVELY.
^THE <.PAGE COMMAND DOES RETURN, AND IN FACT IS DEFINED AS
<.BR <.FRCPAGE.
 <.FMT N1 N2
.B ^FORMATS THE VALUE OF N2 ACCORDING TO THE FORMAT CODE SPECIFIED
BY N1.  ^N1 AND N2 MAY BE EXPRESSIONS (SEE ^CHAPTER 4).  ^N1 MUST
BE IN THE RANGE 0 THROUGH 5, AND HAS A MEANING AS FOLLOWS:
.SAV .LM +11 .TAB 20 .P -7 1 5
.B
.I -11 .U ^VALUE .T ^FORMATS#N2#AS... .NOU
 0 .T ^ARABIC NUMBERS.  ^THAT IS, <.FMT 0 IS A NO-OP EXCEPT
THAT IT FORCES OUTPUT OF N2.
 1 .T ^UPPER CASE ALPHABETIC CHARACTERS, WHERE N2=1 PRODUCES
THE CHARACTER <A, N2=2 PRODUCES <B, ETC.  (^NOTE THAT IN FACT
N2=N PRODUCES THE NTH CHARACTER IN THE ALPHABET, WHERE
N IS TAKEN MODULO 26.)
 2 .T ^LOWER CASE ALPHABETIC CHARACTERS, WHERE N2=1 PRODUCES
THE CHARACTER A, ETC.  (^THE ACTION IS THE SAME AS THAT OF FORMAT
EXCEPT THAT THE CHARACTER IS LOWER CASE.)
 3 .T ^UPPER CASE ^ROMAN NUMERALS.  (^THE NUMERALS PRODUCED
ONLY MAKE USE OF THE CHARACTERS <M, <D, <C, <L, <X, <V, AND <I.)
 4 .T ^LOWER CASE ^ROMAN NUMERALS.  (^THE NUMERALS PRODUCED
ONLY MAKE USE OF THE CHARACTERS M, D, C, L, X, V, AND I.)
 5 .T ^THE ^N2TH CHARACTER OF THE CHARACTER SET. ^THIS IS USEFUL FOR PRINTING
CHARACTERS NOT AVAILABLE ON THE ENTRY DEVICE.
.RES
 <.HL N HEADING .RT (^RETURN)
.B ^BEGINS A NEW SECTION WITH THE HEADING SPECIFIED AND AUTOMATICALLY
NUMBERS IT.  ^THE N IN THE <.HL COMMAND MUST BE IN THE RANGE 1 THROUGH
5. ^SECTION NUMBERS HAVE THE FORM I.J.K.L.M.
^IF A <.CH COMMAND PRECEEDED THE <.HL COMMAND, I IS THE CHAPTER NUMBER;
OTHERWISE IT IS THE NUMBER OF <.HL 1 COMMANDS.
^WITHIN ^CHAPTER 2, THE SEQUENCE <.HL#1, <.HL#2, <.HL#3, <.HL#3, <.HL#2,
<.HL#1 PRODUCES SECTIONS NUMBERED 2.1, 2.1.1, 2.1.1.1, 2.1.1.2, 2.1.2,
AND 2.2.
.B ^THREE BLANK LINES ARE LEFT BEFORE EACH SECTION, AND TWO BLANK
LINES FOLLOW THE SECTION HEADER.
 <.I #N .RT (^RETURN)
.BR .I -4 <.I +N .RT (^RETURN)
.BR .I -4 <.I -N .RT (^RETURN)
.B ^INDENT THE FOLLOWING LINE.  ^IF N IS SPEC^IFIED, IT INDICATES THE
COLUMN NUMBER AT WHICH THE LINE IS TO BEGIN.  ^IF +N OR -N ARE SPECIFIED,
THE INDENT IS PLUS OR MINUS N CHARACTERS FROM THE LEFT MARGIN.
 <.IF EXPRESSION TEXT
.B ^THE <.IF COMMAND TESTS THE VALUE OF THE EXPRESSION. ^IF IT
IS ZERO, THE TEXT ON THE REMAINDER OF THE LINE IS SKIPPED; OTHERWISE
THE TEXT IS SCANNED NORMALLY.  <.IF PROVIDES A SINGLE LINE CONDITIONAL
CAPABILITY.
.B ^FOR A DEFINITION OF EXPRESSIONS ACCEPTABLE TO <.IF, SEE
^CHAPTER 4, <VARIABLES.
 <.INC VARIABLENAME
.B INCREMENT THE FOLLOWING VARIABLE.
 <.J
.B ^JUSTIFY TEXT AT THE RIGHT MARGIN.  ^THIS IS THE DEFAULT.
^JUSTIFICATION IS ACCOMPLISHED BY INSERTING EXTRA BLANKS BETWEEN
WORDS WHEN NECESSARY.  (^NOTE THAT A SIGNIFICANT BLANK, THE
_# CHARACTER, IS NEVER EXPANDED.)# <.NOJ TURNS JUSTIFICATION OFF.
 <.LE .RT (^RETURN)
.B ^BEGINS A LIST ELEMENT.  ^THE ELEMENT IS AUTOMATICALLY NUMBERED
AND INDENTED.  ^SEE THE <.LIST AND <.ELIST COMMANDS.
 <.LINES N
.B ^SETS THE NUMBER OF LINES IN THE OUTPUT PAGE,
INCLUDING THE TOP AND BOTTOM MARGINS.  <DEFAULT N IS 66.  ^THE
CORRECT SETTING FOR 6 LINE PER INCH DEVICES USING 8 LINE PER INCH
PAPER (LIKE <CSO'S <DEC<WRITERS) IS 51.
 <.LIST N .RT (^RETURN)
.B ^BEGINS A LIST WITH N SPACING.  ^EACH ELEMENT OF THE LIST
IS AUTOMATICALLY NUMBERED BEGINNING AT 1.  ^LISTS MAY BE NESTED
WITHIN LISTS, FOR UP TO 5 LEVELS.  ^A LIST IS TERMINATED BY
A <.ELIST COMMAND.  ^EACH LIST IS INDENTED ON THE RIGHT; THE
OUTERMOST LIST IS INDENTED 9 CHARACTERS, AND EACH INNER LIST
IS INDENTED 4 MORE.
 <.LOWER .B ^FORMATS THE OUTPUT IN UPPER/LOWER CASE. ^LOWER IS THE DEFAULT.
 <.LPT
.B ^PREPARE OUTPUT FOR A LINE PRINTER, WITH CARRIAGE CONTROL IN
THE FIRST CHARACTER POSITION OF EACH LINE.  ^THE DEFAULT IS <.LPT.
<.NOLPT PREPARES OUTPUT FOR AN INTERACTIVE TERMINAL.
 <.LM N
.B ^SET THE LEFT MARGIN TO N.
^N MUST BE IN THE RANGE 1 THROUGH 136 (IN PARTICULAR, <.LM 0
IS FLAGGED AS AN ERROR).
^SEE <.RM ALSO.
 <.MACRO NAME ##= TEXT
.BR .I -4 <.MACRO NAME N = TEXT
.BR .I -4 <.MACRO NAME * = TEXT
.B ^DEFINES A MACRO WITH THE NAME SPECIFIED EQUAL TO THE TEXT ON THE
REMAINDER OF THE SAME LINE.  ^WHEN _.NAME IS ENCOUNTERED LATER, THE TEXT
IS SUBSTITUTED FOR IT.
.B ^IF N, AN INTEGER FROM 1 TO 7, IS SPECIFIED, IT INDICATES THE MACRO
HAS N ARGUMENTS.  ^THIS IMPLICITLY DEFINES MACROS NAME1,NAME2...NAMEN,
WHICH HAVE A TEXT VALUE EQUAL TO THE N WORDS WHICH FOLLOW THE MACRO WHEN
IT IS INVOKED.
.B ^IF * IS SPECIFIED, IT INDICATES THAT THE MACRO HAS ONE ARGUMENT.
^THE ARGUMENT IS THE IMPLICITLY DEFINED MACRO NAME1, AND HAS A TEXT
VALUE EQUAL TO THE ENTIRE REST OF THE LINE ON WHICH THE MACRO IS
INVOKED.
.B ^FOR AN EXTENDED DISCUSSION AND EXAMPLES, SEE ^CHAPTER 3, <MACROS.
 <.MID .RT (^RETURN)
.B ^THE <.MID COMMAND ENDS A USER-DEFINED <.FRCPAGE MACRO.
<.MID OUTPUTS ANY DEFERRED TEXT, FOLLOWED BY ANY LINES SAVED
PRIOR TO <.FRCPAGE, THEN SETS THE BEGINNING OF USER TEXT
TO THE CURRENT LINE.  ^THIS LATTER SUPPRESSES BLANK LINES
AT THE "TOP OF THE PAGE" CAUSED BY EITHER <.S OR <.B.
 <.NMP
.B ^NUMBER PAGES.  ^THIS IS THE DEFAULT; <.NONMP TURNS IT OFF.
 <.P #N S T
.BR .I -4 <.P +N S T
.BR .I -4 <.P -N S T
.B ^SETS PARAGRAPHING CONVENTIONS.  ^N, S AND T ARE NUMBERS.
^N SETS THE PARAGRAPH INDENT AND WORKS LIKE THE <.I COMMAND.
^S SETS THE SPACING BETWEEN PARAGRAPHS, WHERE 1 IS SINGLE SPACED,
IS DOUBLE SPACED, ETC.  ^T SETS AN AUTOMATIC <.TP T BEFORE
EACH PARAGRAPH.  ^SEE ALSO THE <.PP AND <.AP COMMANDS.
 <.PAGE .RT (^RETURN)
.B ^BEGINS A NEW PAGE.
 <.PERIOD
.B ^LEAVE AN EXTRA BLANK AFTER _., _!, OR _?.  ^THIS IS THE DEFAULT.
^IT MAY BE SUPPRESSED BY <.NOPERIOD.
 <.PNO N
.B ^NUMBER THE NEXT PAGE N.
 <.PP .RT  (^RETURN)
.B ^BEGIN A NEW PARAGRAPH.
 <.PS L R
.B ^SETS THE PAGE SIZE TO L LINES OF TEXT, NOT COUNTING THE LINES
AT THE TOP MARGIN, AND THE PAGE NUMBER RIGHT MARGIN TO R.
^SEE ALSO THE <.LINES COMMAND.
 <.REM TEXT
.B ^THE <.REM COMMAND AND ALL TEXT WHICH FOLLOWS IT ON THE SAME
INPUT LINE IS TREATED AS A REMARK (COMMENT).  ^THE TEXT IS
NOT COPIED TO THE OUTPUT.
 <.RES .RT (^BREAK)
.B ^RESTORES THE MARGINS, FILL AND JUSTIFY MODES, PARAGRAPH
SETTINGS, SPACING, AND TAB STOPS TO THEIR STATE AS OF THE
LAST <.SAV COMMAND.
 <.RESPAG .RT (^RETURN)
.B ^LIKE <.RES; REPLACES THE MARGINS, FILL AND JUSTIFY MODES,
PARAGRAPH SETTINGS, SPACING, AND TAB STOPS TO THEIR STATE
AS OF THE LAST <.SAVPAG COMMAND.  ^RESTORES THE PAGE ENVIRONMENT,
WHICH IS USED TO ALIGN TITLES AND PAGE NUMBERS.
 <.RIGHT N .RT (^RETURN)
.B ^SHIFT OUTPUT TEXT RIGHT N SPACES.  THE <.RIGHT SPACES PRECEDE
THOSE CAUSED BY THE <.BAR COMMAND.
 <.RM N
.B ^SETS THE RIGHT MARGIN TO COLUMN N.
 <.RT
.B ^RIGHT TAB.  ^CAUSES THE FOLLOWING WORD TO BE RIGHT JUSTIFIED
(END IN) THE NEXT TAB STOP.  ^SEE THE <.TABS AND <.T COMMANDS.
^THIS IS USEFUL FOR TABLES OF NUMERIC DATA.
 <.S .RT (^RETURN)
.BR .I -4 <.S N .RT (^RETURN)
.B ^LEAVE N+1 TIMES SPACING BLANK LINES, WHERE SPACING IS SET BY THE
<.SP COMMAND.  <.S DOES NOTHING AT THE BEGINNING OF A PAGE.
<.S AND <.S#1 ARE EQUIVALENT.
 <.SAV
.B ^SAVE THE CURRENT MARGINS, FILL AND JUSTIFY MODES, PARAGRAPH
SETTINGS, SPACING, AND TAB STOPS -- WHICH ARE COLLECTIVELY
CALLED THE "ENVIRONMENT".  ^THE ENVIRONMENT IS RESTORED BY
THE <.RES COMMAND.  <.SAV AND <.RES CAN BE NESTED.
.B ^FOR MOST TEXT, THERE ARE TWO ACTIVE ENVIRONMENTS: THE
CURRENT VALUE AND THE "PAGE ENVIRONMENT".  ^THE LATTER CONTROLS
THE PRINTING OF TITLES AND PAGE NUMBERS AT THE HEAD OF EACH
PAGE.
.B
^NOTE THAT <.HL, <.CH, OR <.RESPAG RESET THE ENVIRONMENT TO
THE PAGE ENVIRONMENT AND DISCARD ANY ACTIVE <.SAV<S.  ^SEE THE
<.SAVPAG AND <.RESPAG COMMANDS.
 <.SAVPAG
.B ^LIKE <.SAV, EXCEPT <.SAVPAG REPLACES THE PAGE ENVIRONMENT.
^IF NO EXPLICIT <.SAVPAG IS DONE, THE ENVIRONMENT AT THE
FIRST <.HL OR <.CH COMMAND BECOMES THE PAGE ENVIRONMENT.
 <.SIG
.B ^TREAT SUCCESSIVE BLANK CHARACTERS AS WORDS, AND STOP ALL AUTOMATIC
BLANK PLACEMENT.  ^USED IN CONJUNCTION WITH <.NOJ AND <.NOF, IT
PERMITS A SORT OF "AS IS" MODE IN WHICH, HOWEVER, COMMANDS AND FLAGS
ARE RECOGNIZED.
<.NOSIG IS THE DEFAULT.
 <.SP N
.B ^SET THE SPACING BETWEEN LINES FORCED OUT BY FILLING TO N, WHERE
IS SINGLE SPACING, 2 IS DOUBLE SPACING, ETC.
 <.ST TEXT .RT (^RETURN)
.B ^THE TEXT WHICH FOLLOWS THE <.ST COMMAND ON THE SAME LINE IS USED
AS A SUBTITLE ON THE NEXT AND SUCCEEDING PAGES.
 <.STD
.B ^SETS <.F, <.FLAG, <.FLAGCAPS, <.NOASCII, <.ESC, <.PERIOD, <.J,
<.UL, <.NOSIG, AND AUTOMATIC RETURNS BEFORE THE <.C, <.TITLE, <.ST,
AND <.I COMMANDS.  <.SIG IS THE DEFAULT; <.NOSIG DOES THE OPPOSITE.
 <.SUP
.B ^SUPPRESSES (THROWS AWAY) ANY TEXT ALREADY IN THE CURRENT OUTPUT
LINE, AND ANY TEXT ON THE SAME INPUT LINE AS THE <.SUP COMMAND.
 <.T
.B ^BEGIN THE NEXT WORD AT THE NEXT TAB STOP.  ^SEE ALSO THE <.TABS
AND <.RT COMMANDS.
 <.TABS T1 T2 _... T15
.B ^SET UP TO 15 TAB STOPS IN COLUMNS T1, T2, ETC.  ^THE TAB STOPS
MUST BE IN ASCENDING ORDER.  ^TABBING IS DONE BY THE <.T AND <.RT
COMMANDS.
 <.TITLE TEXT .RT (^RETURN)
.B ^SETS THE TEXT WHICH FOLLOWS <.TITLE ON THE SAME LINE AS THE
TITLE ON THE NEXT AND SUCCEEDING PAGES.
 <.TOP
.B ^SPACES TO THE TOP OF THE NEXT PAGE OR EMITS "1" CARRIAGE CONTROL.
AND RESETS THE LINE COUNTER.
.B <.TOP IS ONLY TO BE USED WHEN OVERRIDING THE DEFAULT PAGE
HANDLING.  ^THE <.PAGE COMMAND IS USED FOR EJECTING A PAGE NORMALLY.
 <.TP N .RT (^RETURN)
.B ^TESTS WHETHER N LINES REMAIN ON THE CURRENT PAGE.  ^IF NOT,
<.TP EJECTS A PAGE.  ^NOTE THAT <.TP IS AFFECTED BY SPACING
IN THAT THE ACTUAL NUMBER OF LINES TESTED FOR IS N TIMES
SPACING MINUS ONE.
 <.U
.B ^UNDERLINE THE NEXT AND SUCCEEDING WORDS IN THE OUTPUT TEXT.
^TERMINATED BY THE <.NOU COMMAND.
 <.UPP
.B ^FORCE THE NEXT WORD TO BE UPPER CASE.
 <.UPPER .B ^FORCES THE OUTPUT INTO UPPER CASE ONLY. ^LOWER IS THE DEFAULT.
 <.USB
.B ^UNDERLINE SIGNIFICANT BLANKS (THAT IS _#) WHEN <.U IS EFFECTIVE.
<.NOUSB CAUSES SIGNIFICANT BLANKS TO BE NOT UNDERLINED. <.USB IS THE DEFAULT.
 <.VAR VARIABLENAME
.B ^DECLARES A VARIABLE WITH THE NAME SPECIFIED.
^VARIABLE NAMES MUST BEGIN WITH A _$, AND OTHERWISE CONSIST OF
LETTERS, NUMBERS, OR _$ CHARACTERS.  ^THE SECOND CHARACTER
OF A VARIABLE NAME MAY NOT BE A DIGIT.  ^THE VARIABLE HAS THE
INITIAL VALUE ZERO.
 <.X
.B ^EXTEND THE PRECEDING WORD ON THE OUTPUT LINE WITH THE FOLLOWING
WORD.  ^WORDS JOINED BY <.X ARE OUTPUT ON THE SAME LINE WITH NO
BLANKS BETWEEN THEM.  <.X IS PRIMARILY USEFUL FOR JOINING TEXT
GENERATED BY A MACRO TO PUNCTUATION ON EITHER SIDE OF IT.
.MACRO CHTTL = ^MACROS
.CH <MACROS
^USER-DEFINED <RNF MACROS PROVIDE A MEANS OF:
.BDOT
.DOT ^EXTENDING THE SET OF <RNF COMMANDS BY ADDING MACROS TAILORED
TO A SPECIFIC APPLICATION.
.DOT ^ABBREVIATING COMMONLY USED SERIES OF <RNF COMMANDS.
.DOT ^ABBREVIATING COMMONLY USED PHRASES OR LONG WORDS.
.EDOT
^FOR EXAMPLE, THE FOLLOWING MACRO DEFINITIONS WERE USED TO PRODUCE
THE DOTTED LIST ABOVE:
.MACRO EX = .SAV .LM +9 .NOF .NOJ .S 1
.MACRO EEX = .RES .S 1
.EX <.MACRO <BDOT = <.SAV <.P -2 1 5 <.LM +5
<.MACRO <DOT = <.PP __._# <.X
<.MACRO <EDOT = <.RES <.S 1
.EEX
WHILE THE FOLLOWING TWO MACROS WERE USED TO FORMAT THE ABOVE
(AND FOLLOWING) EXAMPLES:
.EX <.MACRO <EX = <.SAV <.LM +9 <.NOF <.NOJ <.S 1
<.MACRO <EEX = <.RES <.S 1
.EEX
AND SO ON!
 ^THE FOLLOWING DISCUSSION IS INTENDED TO GIVE THE USER SOME
INSIGHT INTO POTENTIAL USES OF MACROS WHILE
DEMONSTRATING HOW EASY MACROS ARE TO DEFINE AND USE.
.HL 1 <WHAT <MACROS <ARE
 ^MACROS HAVE TWO PARTS: A NAME, AND SOME TEXT.  ^THE NAME IS
A SINGLE WORD LONG, WHILE THE TEXT MAY BE ZERO OR MORE WORDS LONG.
 ^THE EFFECT OF A MACRO IS SIMILIARLY EASY TO DESCRIBE: WHEREVER
THE NAME OF THE MACRO APPEARS <RNF REMOVES IT AND SUBSTITUTES
THE TEXT.
 ^FOR EXAMPLE, IF THE FOLLOWING MACRO IS DEFINED:
.EX <.MACRO <CDC = ^CONTROL ^DATA ^CORPORATION
.EEX
WHENEVER <.CDC APPEARS IN THE INPUT, <RNF REMOVES IT AND SUBSTITUTES
^CONTROL ^DATA ^CORPORATION.
.MACRO NOTE * = .SAV .S 2 .LM +15 .RM -15 .P +0 1 5 .C .NOTE1 .S 1
.MACRO ENOTE = .RES .S 2
.NOTE ^NOTE THE ^DOTS
^THE MACRO NAME IS DEFINED WITHOUT A PRECEDING PERIOD (DOT).
^BUT WHEN THE MACRO IS USED, THE NAME MUST BE PRECEDED BY A DOT.
.ENOTE
.HL 1 <HOW <TO <DEFINE <A <MACRO
 ^THE SIMPLEST FORM OF MACRO DEFINITION IS:
.EX <.MACRO NAME = TEXT
.EEX
WHERE NAME IS THE NAME OF THE MACRO, AND TEXT REPRESENTS ALL THE
TEXT ON THE REST OF THE SAME LINE.
 ^AFTER THE MACRO DEFINITION, WHEREVER _.NAME APPEARS <RNF REMOVES
IT AND SUBSTITUTES THE TEXT.
.HL 1 <SUB-MACROS
 ^ALL MACRO EXPANSIONS ARE CONSIDERED TO TAKE PLACE ON THE SAME INPUT
LINE AS THE "OUTERMOST" MACRO CALL.  ^THUS, MACROS CAN BE PARAMETERIZED
IN A SIMPLE WAY BY ENDING A MACRO EXPANSION WITH A COMMAND
AND TYPING THE COMMAND ARGUMENT(S) AFTER THE MACRO CALL.  ^FOR EXAMPLE,
.EX <.MACRO <RIGHTMARG = <.RM
.EEX
WHICH COULD BE USED BY
.EX <.RIGHTMARG 65
.EEX
^BUT, AS THE EXAMPLE SHOWS, THIS APPROACH IS MOSTLY LIMITED TO TRIVIAL
COMMAND REPLACEMENTS.
^SUB-MACROS PROVIDE THE ABILITY TO PARAMETERIZE MACROS IN A MORE USEFUL
FASHION.
.HL 2 ^DEFINING ^PARAMETERIZED ^MACROS
 ^MACROS WITH SUB-MACROS ARE DEFINED BY THE FORMATS:
.EX <.MACRO NAME N = TEXT
-OR-
<.MACRO NAME * = TEXT
.EEX
^THE N IN THE FORMAT STANDS FOR A NUMBER IN THE RANGE 1 THROUGH 7.
^IT MEANS THAT THE 1 THROUGH 7 WORDS FOLLOWING THE MACRO CALL ON THE
SAME LINE ARE DYNAMICALLY MADE THE VALUES OF THE SUB-MACROS NAME1,
NAME2, _... ,NAME7.
 ^SUB-MACROS HAVE A DEFINED VALUE ONLY WHEN THE MACRO IS BEING
EXPANDED.
 ^IF AN ASTERISK IS USED INSTEAD OF A NUMBER N, IT MEANS THAT ALL
THE WORDS WHICH FOLLOW THE MACRO CALL ON THE SAME LINE ARE DYNAMICALLY
MADE THE VALUE OF THE SUB-MACRO NAME1.
 ^FOR EXAMPLE,
.EX <.MACRO <Z 2 = ^I HOPE YOU ARE <.Z1 <.X ING <.Z2 <.X ! .EEX
^WHEN <.Z IS CALLED, THE SUB-MACROS <.Z1 AND <.Z2 ARE GIVEN
VALUES EQUAL TO THE TWO WORDS WHICH FOLLOW <.Z ON THE SAME LINE.
^THUS, THE CALL
.EX <.Z FOLLOW ME .EEX
PRODUCES THE TEXT
.EX ^I HOPE YOU ARE FOLLOWING ME! .EEX
.HL 2 ^SUB-MACRO ^SEMANTICS
^SINCE THE PARAMETERS OF A MACRO ARE DEFINED AS MACROS THEMSELVES,
THEY MAY BE USED IN ANY MACRO CALLED WHILE THE SUB-MACROS ARE
DEFINED, AND NEED NOT BE "PASSED DOWN" FROM MACRO TO MACRO.
 ^IF NO WORDS OR NOT ENOUGH WORDS FOLLOW THE CALL OF A MACRO
WITH SUB-MACROS, THE SUB-MACROS ARE GIVEN NULL VALUES.  ^THAT
IS, UNLESS THERE IS ACTUALLY A WORD CORRESPONDING TO A SUB-MACRO,
IT EXPANDS TO NOTHING AT ALL.
.MACRO CHTTL = ^VARIABLES
.CH <VARIABLES
 <RNF ALLOWS THE USER TO DEFINE AND USE NUMERIC VARIABLES.
^THESE ARE HANDY (AND ARE USED INTERNALLY) FOR KEEPING TRACK OF
PAGE NUMBERS, CHAPTER NUMBERS, HEADER LEVELS, ETC.
.HL 1 <VARIABLE <SYNTAX
 ^VARIABLES ARE WORDS WHICH BEGIN WITH A DOLLAR SIGN ($),
FOLLOWED BY FROM 1 TO 9 LETTERS, NUMBERS, OR _$ CHARACTERS.
^THE CASE OF VARIABLE NAMES IS NOT SIGNIFICANT, E.G., <$HILO AND <$<HILO
ARE THE SAME VARIABLE.
 ^THE FIRST CHARACTER AFTER THE LEADING _$ CANNOT BE A NUMBER.
^THIS IS SO CHARACTER COMBINATIONS OF THE FORMS _$_<BLANK> AND
_$_<NUMBERS> ARE NOT RECOGNIZED AS VARIABLES, MAKING A NUISANCE
FOR THE USER.
 ^USERS SHOULD NOT DECLARE VARIABLES WITH TWO LEADING DOLLAR
SIGNS, AS THIS IS THE FORMAT USED BY PRE-DECLARED <RNF SYSTEM
VARIABLES.
 ^FOR EXAMPLE, THE FOLLOWING ARE VALID VARIABLE NAMES:
.TP 8
.EX <$A
 <$VARIABLE
 <$<N$
 <$L23
.EEX
WHILE THE FOLLOWING ARE INVALID:
 .EX <$100
 <$
.EEX
.HL 1 <HOW <TO <DECLARE <VARIABLES
 ^VARIABLES ARE DECLARED BY THE <.VAR COMMAND, WHICH HAS THE FORMAT:
.EX <.VAR _$NAME
.EEX
^NOTE THAT THE VARIABLE NAME IS BOTH DECLARED AND USED WITH A
LEADING _$.
 ^THE EFFECT OF <.VAR IS TO ALLOCATE SPACE FOR A NUMERIC VARIABLE,
GIVE IT THE NAME SPECIFIED, AND INITIALIZE THE VARIABLE TO ZERO.
 <RNF PROVIDES 75 SPACES FOR USER-DEFINED VARIABLES IN ADDITION
TO PREDEFINED VARIABLES.
.HL 1 <PREDEFINED <VARIABLES
 ^AS A CONVENIENCE TO THE USER, ^RNF MAKES USE OF SEVERAL PREDEFINED
VARIABLES WHILE PERFORMING VARIOUS COMMANDS.  ^THE PREDEFINED
VARIABLES ARE:
.SAV .LM +17 .P -12 0 1 .TAB 18
.B
 <$$PAGE .T ^CURRENT PAGE NUMBER.
 <$$CH .T ^CURRENT CHAPTER NUMBER.
 <$$HL .T ^CURRENT HEADER LEVEL.  ^ALSO DEFINED ARE <$$HL[1] THROUGH
<$$HL[5], WHICH CONTAIN THE CURRENT COUNTS AT EACH LEVEL.
 <$$LIST .T ^CURRENT LIST LEVEL.  ^ALSO DEFINED ARE <$$LIST[1]
THROUGH <$$LIST[10], WHICH CONTAIN THE CURRENT COUNTS AT EACH
LEVEL.
 <$$LM .T ^CURRENT LEFT MARGIN, SET BY <.LM.
 <$$RM .T ^CURRENT RIGHT MARGIN, SET BY <.RM.
 <$$SP .T ^CURRENT SPACING, SET BY <.SP.
 <$$NMP .T ^PAGE NUMBERING FLAG, SET BY <.NMP.
.RES
 ^THE VALUES OF THE PREDEFINED VARIABLES MAY BE EXAMINED OR
CHANGED BY THE USER AT ANY TIME. (^OF COURSE, CHANGING THESE
VALUES WILL AFFECT THE OPERATION OF THE BUILT IN <RNF FEATURES
WHICH USE THEM.)
.HL 1 <VARIABLE <ARRAYS
 ^ARRAYS MAY BE DECLARED BY THE <.ARRAY COMMAND, WHICH HAS THE
FORMAT:
.EX <.ARRAY _$NAME N .EEX
^THE EFFECT OF THIS DECLARATION IS THAT _$NAME IS DECLARED TO
BE AN N+1 ELEMENT ARRAY, WHICH MAY BE REFERENCED AS _$NAME[0]
THROUGH _$NAME[N].
 ^THE SUBSCRIPT MAY BE OMITTED IF THE ZEROETH ELEMENT OF THE
ARRAY IS BEING REFERENCED.  ^THAT IS, _$NAME[0] AND _$NAME
ARE EQUIVALENT.  ^THIS CONVENTION IS ADOPTED SO THAT A SINGLE
DECLARATION CAN ALLOCATE BOTH AN N-ELEMENT ARRAY AND AN
INDEX VARIABLE ASSOCIATED WITH THE ARRAY.
(^THE PREDECLARED ARRAYS <$$HL AND <$$LIST ARE USED IN THIS FASHION.)
 ^NOTE THAT THE ARRAY DECLARATION REQUIRES N+1 SPACES OF THE
ALLOWED FOR USER VARIABLES.
.HL 1 <EXPRESSIONS
 ^AN EXTREMELY USEFUL FEATURE OF <RNF IS THE ABILITY TO COMBINE
VARIABLES, NUMBERS, AND OPERATORS INTO EXPRESSIONS WHICH COMPUTE
A NUMERIC VALUE.
^THE VALUES COMPUTED BY THE EXPRESSIONS CAN IN TURN INDEX ARRAYS,
BE ASSIGNED TO VARIABLES, OR BECOME A PART OF THE OUTPUT TEXT.
.HL 2 ^EXPRESSION ^SYNTAX
 ^AN EXPRESSION IS DEFINED AS FOLLOWS:
.TAB 20 27
.EX EXPR .T ::= .T TERM _< RELOP TERM >
.NOPERIOD
 RELOP .T ::= .T <.EQ. Ý <.NE. Ý <.LT. Ý <.LE. Ý <.GT. Ý <.GE.
.PERIOD
 TERM .T ::= .T ITEM _< _< + Ý - > ITEM >...
 ITEM .T ::= .T _< + Ý - Ý _# > ELEMENT
 ELEMENT .T ::= .T ( TERM) Ý VAR Ý INTEGER
 VAR .T ::= .T _$ID _< [ TERM ] > _< = TERM >
.EEX
 ^THE ANGLE BRACKETS _< AND > IN THE SYNTAX EXPRESSIONS ENCLOSE
OPTIONAL PARTS.  ^THE CONSTRUCTION
.EX _< STUFF >...
.EEX
 INDICATES THAT STUFF IS ALLOWED TO APPEAR ZERO OR MORE TIMES.
^NOTE THAT ANGLE BRACKETS ARE USED TO DESCRIBE EXPRESSIONS; THEY
DO NOT APPEAR IN EXPRESSIONS.
 ^THE _# CHARACTER IN AN EXPRESSION REPRESENTS A LOGICAL <NOT
OPERATION.  ^THE EXPRESSION _#X HAS THE VALUE 1 IF X EQUALS
, OTHERWISE IT HAS THE VALUE 0.
 ^THE BLANKS IN THE SYNTAX EXPRESSIONS ARE NOT SIGNIFICANT AND IN FACT
BLANKS ARE NOT PERMITTED IN EXPRESSIONS.  ^THAT IS, AND EXPRESSION MUST
BE A SINGLE WORD.
 ^SOME EXAMPLES OF VALID EXPRESSIONS ARE:
.EX <$A.GR.5
 <$HL[$HL+1]=0
 <2+$$PAGE
 <$X[$X=$X+1]=$X[$X]+1
 <$A=$B=$C
.EEX
.HL 2 ^EXPRESSION ^EVALUATION
 ^EXPRESSIONS ARE EVALUATED FROM LEFT TO RIGHT, EXCEPT THAT
ASSIGNMENTS (INDICATED BY THE = SIGN) AT THE SAME LEVEL ARE
DONE FROM RIGHT TO LEFT.
 ^IN THE EXAMPLES ABOVE, <$X[$X=$X+1]=$X[$X]+1 IS EQUIVALENT
TO THE SERIES OF EXPRESSIONS <$X=$X+1 <$X[$X]=$X[$X]+1.
(^RECALL THAT THE ZEROETH ELEMENT OF AN ARRAY CAN BE REFERENCED
WITHOUT SUBSCRIPTS.)#  ^ON THE OTHER HAND, THE EXPRESSION
<$A=$B=$C IS EQUIVALENT TO <$B=$C <$A=$B.
.HL 2 ^WHERE ^EXPRESSIONS ^ARE ^USED
 ^AN EXPRESSION CAN ALWAYS BE USED AS AN ARGUMENT TO A COMMAND
WHICH REQUIRES A NUMERIC VALUE.
 ^AN EXPRESSION CAN ALSO APPEAR IN TEXT.  <RNF DECIDES WHETHER
TO EVALUATE AN EXPRESSION IN TEXT OR NOT BASED ON WHETHER THE
FIRST CHARACTER IS A _$.  ^IF IT IS, <RNF EVALUATES THE EXPRESSION;
OTHERWISE THE EXPRESSION IS TREATED LIKE ANY OTHER TEXT WORD.
 ^FOR EXAMPLE, THE EXPRESSION <$A+2 WILL BE EVALUATED, WHILE
<2+$A WILL NOT.
^IF <$A HAS THE VALUE 3, THE FORMER WILL APPEAR IN THE OUTPUT
AS "5", WHILE THE LATTER WILL APPEAR AS <"2+$A".
 ^FOR THE FEW CASES WHEN IT IS NOT CONVENIENT TO BEGIN AN EXPRESSION
TO BE EVALUATED WITH A VARIABLE NAME, THE SYNTAX:
.EX <$(<EXPR)
.EEX
WILL CAUSE EXPR TO BE EVALUATED.
.HL 2 ^SUPPRESSED ^EXPRESSIONS
 ^FREQUENTLY, ONE WISHES TO COMPUTE A VALUE AND ASSIGN IT TO
A VARIABLE -- THAT IS, EVALUATE AN EXPRESSION -- WITHOUT
PLACING ANYTHING AT ALL IN THE OUTPUT TEXT.  ^THIS IS DONE
BY TERMINATING THE EXPRESSION WITH A SEMICOLON.
 ^FOR EXAMPLE, THE WORDS:
.EX
.EX <.VAR <$A ^SEE <$A=$A+1; ONLY <$A OF THESE.
.EEX
ARE OUTPUT AS
.EX ^SEE ONLY 1 OF THESE.
.EEX
.PAGE
.FIG 20
.C .U ^THIS PAGE INTENTIONALLY LEFT BLANK. .NOU
.MACRO CHTTL = ^EXAMPLES
.CH <EXAMPLES
 ^THIS CHAPTER CONTAINS A NUMBER OF SHORT EXAMPLES DEMONSTRATING
VARIOUS FREQUENTLY USED <RNF FEATURES.
 ^THE EXAMPLES ARE INTENDED TO BE SELF-EXPLANATORY AND ARE PRESENTED
WITHOUT ACCOMPANYING TEXT.
^ALL BUT ONE OF THE EXAMPLES WAS PREPARED IN <NORMAL MODE (<RNF DEFAULT
INPUT).
.PAGE
.HL 1 <INPUT <TEXT <EXAMPLE
.ASIS
.C <RNO
.C ^INPUT ^TEXT

^INPUT TEXT TO <RNO CONSISTS OF A SEQUENCE OF WORDS AND COMMANDS
SEPARATED BY BLANKS.  ^A COMMAND IS ANY WORD WHICH BEGINS WITH
A PERIOD FOLLOWED BY A NON-DIGIT, WHILE A WORD IS ANY
SEQUENCE OF CHARACTERS WHICH
DOES NOT CONTAIN A BLANK.  ^THE FOLLOWING ARE CONSIDERED WORDS:

.I 5 ^THIS
.BR .I 5 .^B
.BR .I 5 ^W^O^RD#^W^I^T^H#^S^I^G^N^I^F^I^C^A^N^T#^B^L^
.BR .I 5 .234
.B ^OF THE ABOVE WORDS, ONLY .^B IS A COMMAND.
.B <RNO GATHERS WORDS INTO LINES.  ^BY DEFAULT, THE FIRST WORD IN
A LINE BEGINS AT THE LEFT MARGIN, AND THE LAST WORD ENDS AT
OR BEFORE THE RIGHT MARGIN.  ^THAT IS, LINES ARE LEFT JUSTIFIED.

^IN THE OUTPUT,
AT LEAST ONE BLANK APPEARS BETWEEN WORDS; TWO BLANKS FOLLOW A
PERIOD OR QUESTION MARK WHICH END A WORD.
!.PAGE
.C <RNO
.C ^INPUT ^TEXT

^INPUT TEXT TO <RNO CONSISTS OF A SEQUENCE OF WORDS AND COMMANDS
SEPARATED BY BLANKS.  ^A COMMAND IS ANY WORD WHICH BEGINS WITH
A PERIOD FOLLOWED BY A NON-DIGIT, WHILE A WORD IS ANY
SEQUENCE OF CHARACTERS WHICH
DOES NOT CONTAIN A BLANK.  ^THE FOLLOWING ARE CONSIDERED WORDS:

.I 5 ^THIS
.BR .I 5 _.^B
.BR .I 5 ^W^O^R^D_#^W^I^T^H_#^S^I^G^N^I^F^I^C^A^N^T_#^B^L^A^N^K^S
.BR .I 5 .234
.B ^OF THE ABOVE WORDS, ONLY _.^B IS A COMMAND.
.B <RNO GATHERS WORDS INTO LINES.  ^BY DEFAULT, THE FIRST WORD IN
A LINE BEGINS AT THE LEFT MARGIN, AND THE LAST WORD ENDS AT
OR BEFORE THE RIGHT MARGIN.  ^THAT IS, LINES ARE LEFT JUSTIFIED.

^IN THE OUTPUT,
AT LEAST ONE BLANK APPEARS BETWEEN WORDS; TWO BLANKS FOLLOW A
PERIOD OR QUESTION MARK WHICH END A WORD.
.PAGE
.HL 1 <PARAGRAPHING
.ASIS
.C ^PARAGRAPHING
.P +5 1 5
.PP ^THE PARAGRAPHING FACILITY IN <RNO ENABLES FAST, CONVENIENT
TEXT ENTRY IN A NATURAL FORMAT.
.PP ^PARAGRAPHING IS SET UP BY THE .<P COMMAND, WHICH HAS THE
FORMAT:
.B .I 9 .<P INDENT SPACING TEST
.PP ^INDENT IS THE COLUMN AT WHICH THE FIRST LINE OF EACH
PARAGRAPH IS TO BEGIN, SPECIFIED EITHER AS AN UNSIGNED COLUMN
NUMBER OR AS A POSITIVE OR NEGATIVE OFFSET FROM THE CURRENT
LEFT MARGIN.  ^SPACING SPECIFIES THE NUMBER OF SPACES BETWEEN
PARAGRAPHS, WHERE 1 IS THE EQUIVALENT OF A <.S 1 COMMAND,
IS THE EQUIVALENT OF A <.S2 COMMAND, ETC.  ^TEST
SPECIFIES THE NUMBER OF LINES WHICH
MUST REMAIN ON THE CURRENT PAGE, OR THE PARAGRAPH IS BEGUN
ON THE NEXT PAGE.
.PP ^THE DEFAULT IS:
.B .I 9 .<P +0 1 3
.PP ^THE .<PP COMMAND DENOTES THE BEGINNING OF A NEW PARAGRAPH.
.AP
 ^AS AN ALTERNATIVE (OR IN ADDITION) TO THE <.PP COMMAND, THE USER
CAN SELECT AUTOPARAGRAPH MODE BY MEANS OF THE <.AP COMMAND.
^IF <.AP IS IN EFFECT, A BLANK AT THE BEGINNING OF ANY LINE
(OR A BLANK LINE)
IS TAKEN TO BE A <.PP COMMAND.

(^NOTE THAT A BLANK LINE IN <.NOAP MODE IS TAKEN TO BE A <.B
COMMAND.)

^THE AUTOPARAGRAPH CONVENTIONS ALLOW A TYPIST TO ENTER AND WORK
WITH ALL TEXT IN A READABLE FORMAT WHICH IS CONVENIENT FOR
COMPUTER EDITING (FOR EXAMPLE, SINGLE SPACED WITH SINGLE CHARACTER
INDENTS), YET PRODUCE THE DRAFT AND FINAL COPIES OF WORK
IN WHATEVER STYLE IS REQUIRED.
!.PAGE
.C ^PARAGRAPHING
.P +5 1 5
.PP ^THE PARAGRAPHING FACILITY IN <RNO ENABLES FAST, CONVENIENT
TEXT ENTRY IN A NATURAL FORMAT.
.PP ^PARAGRAPHING IS SET UP BY THE _.<P COMMAND, WHICH HAS THE
FORMAT:
.B .I 9 _.<P INDENT SPACING TEST
.PP ^INDENT IS THE COLUMN AT WHICH THE FIRST LINE OF EACH
PARAGRAPH IS TO BEGIN, SPECIFIED EITHER AS AN UNSIGNED COLUMN
NUMBER OR AS A POSITIVE OR NEGATIVE OFFSET FROM THE CURRENT
LEFT MARGIN.  ^SPACING SPECIFIES THE NUMBER OF SPACES BETWEEN
PARAGRAPHS, WHERE 1 IS THE EQUIVALENT OF A <.S 1 COMMAND,
IS THE EQUIVALENT OF A <.S2 COMMAND, ETC.  ^TEST
SPECIFIES THE NUMBER OF LINES WHICH
MUST REMAIN ON THE CURRENT PAGE, OR THE PARAGRAPH IS BEGUN
ON THE NEXT PAGE.
.PP ^THE DEFAULT IS:
.B .I 9 _.<P +0 1 3
.PP ^THE _.<PP COMMAND DENOTES THE BEGINNING OF A NEW PARAGRAPH.
.AP
 ^AS AN ALTERNATIVE (OR IN ADDITION) TO THE _.<PP COMMAND, THE USER
CAN SELECT AUTOPARAGRAPH MODE BY MEANS OF THE _.<AP COMMAND.
^IF _.<AP IS IN EFFECT, A BLANK AT THE BEGINNING OF ANY LINE
(OR A BLANK LINE)
IS TAKEN TO BE A _.<PP COMMAND.

(^NOTE THAT A BLANK LINE IN _.<NOAP MODE IS TAKEN TO BE A _.<B
COMMAND.)

^THE AUTOPARAGRAPH CONVENTIONS ALLOW A TYPIST TO ENTER AND WORK
WITH ALL TEXT IN A READABLE FORMAT WHICH IS CONVENIENT FOR
COMPUTER EDITING (FOR EXAMPLE, SINGLE SPACED WITH SINGLE CHARACTER
INDENTS), YET PRODUCE THE DRAFT AND FINAL COPIES OF WORK
IN WHATEVER STYLE IS REQUIRED.
.PAGE
.HL 1 <HEADER <LEVEL <EXAMPLES
.ASIS
.AP
.HL 2 <HOW <TO <USE <HEADER <LEVELS
 ^THE .<HL COMMAND ENABLES THE TYPIST TO ORGANIZE TEXT INTO
SECTIONS, AND SECTIONS WITHIN SECTIONS, WITH SEQUENTIAL NUMBERS
WHICH ARE CHANGED BY THE COMPUTER IF SECTIONS ARE ADDED OR
DELETED.
.HL 3 ^FORMAT
 ^THE FORMAT OF THE .<HL COMMAND IS:
.S 1 .I 9 .<HL NUMBER TEXT
 ^THE NUMBER IS THE LEVEL NUMBER, WHERE 1 IS THE OUTERMOST
LEVEL, 2 IS THE NEXT INNER LEVEL, ETC.  ^THE TEXT IS THE
TITLE OF THE SECTION.
.HL 3 ^EFFECT OF THE ^COMMAND
 ^THE .<HL COMMAND STARTS A SECTION AT THE LEVEL SPECIFIED AND
USES TEXT AS THE HEADER.  ^THE NUMBER CAN BE IN THE RANGE
FROM 1 TO 5. ^THE SECTION NUMBER OUTPUT IS IN THE FORM
I.J.K.L.M.  ^IF THE DOCUMENT IS CHAPTER ORIENTED, I IS THE
CHAPTER NUMBER; OTHERWISE IT IS THE NUMBER OF .<HL 1 COMMANDS
SINCE THE BEGINNING OF THE INPUT TEXT.
 ^THE COMMAND DOES A RETURN, A TEST PAGE 9, AND PRECEDES THE
SECTION IDENTIFIER WITH 3 BLANK LINES.
^THE MARGINS AND OTHER ENVIRONMENT ARE RESET TO THE VALUES
THEY HAD BEFORE THE FIRST .<HL COMMAND (IN THE CHAPTER).
^THE SECTION NUMBER BEGINS AT THE LEFT MARGIN, FOLLOWED
BY TWO SPACES, FOLLOWED BY THE TEXT, IF ANY.
 ^A SINGLE BLANK LINE IS INSERTED AFTER THE HEADER.
.HL 2 <INCREMENTING
 ^SECTION NUMBERS ARE INCREMENTED BY 1 AT THE LEVEL OF THE
CURRENT .<HL COMMAND.
 ^EACH TIME LEVELS ARE NESTED (FOR EXAMPLE, .<HL 1 FOLLOWED
BY .<HL 2), THE NUMBERING IS RESTARTED AT 1 FOR THE HIGHER
NUMBERED LEVEL.
!.PAGE
.AP
.HL 2 <HOW <TO <USE <HEADER <LEVELS
 ^THE _.<HL COMMAND ENABLES THE TYPIST TO ORGANIZE TEXT INTO
SECTIONS, AND SECTIONS WITHIN SECTIONS, WITH SEQUENTIAL NUMBERS
WHICH ARE CHANGED BY THE COMPUTER IF SECTIONS ARE ADDED OR
DELETED.
.HL 3 ^FORMAT
 ^THE FORMAT OF THE _.<HL COMMAND IS:
.S 1 .I 9 _.<HL NUMBER TEXT
 ^THE NUMBER IS THE LEVEL NUMBER, WHERE 1 IS THE OUTERMOST
LEVEL, 2 IS THE NEXT INNER LEVEL, ETC.  ^THE TEXT IS THE
TITLE OF THE SECTION.
.HL 3 ^EFFECT OF THE ^COMMAND
 ^THE _.<HL COMMAND STARTS A SECTION AT THE LEVEL SPECIFIED AND
USES TEXT AS THE HEADER.  ^THE NUMBER CAN BE IN THE RANGE
FROM 1 TO 5. ^THE SECTION NUMBER OUTPUT IS IN THE FORM
I.J.K.L.M.  ^IF THE DOCUMENT IS CHAPTER ORIENTED, I IS THE
CHAPTER NUMBER; OTHERWISE IT IS THE NUMBER OF _.<HL 1 COMMANDS
SINCE THE BEGINNING OF THE INPUT TEXT.
 ^THE COMMAND DOES A RETURN, A TEST PAGE 9, AND PRECEDES THE
SECTION IDENTIFIER WITH 3 BLANK LINES.
^THE MARGINS AND OTHER ENVIRONMENT ARE RESET TO THE VALUES
THEY HAD BEFORE THE FIRST _.<HL COMMAND (IN THE CHAPTER).
^THE SECTION NUMBER BEGINS AT THE LEFT MARGIN, FOLLOWED
BY TWO SPACES, FOLLOWED BY THE TEXT, IF ANY.
 ^A SINGLE BLANK LINE IS INSERTED AFTER THE HEADER.
.HL 2 <INCREMENTING
 ^SECTION NUMBERS ARE INCREMENTED BY 1 AT THE LEVEL OF THE
CURRENT _.<HL COMMAND.
 ^EACH TIME LEVELS ARE NESTED (FOR EXAMPLE, _.<HL 1 FOLLOWED
BY _.<HL 2), THE NUMBERING IS RESTARTED AT 1 FOR THE HIGHER
NUMBERED LEVEL.
.PAGE
.HL 1 <EXAMPLES OF <LISTS
.ASIS
.C ^USING ^LISTS
.AP
 ^AUTOMATICALLY NUMBERED LISTS CAN BE GENERATED BY THE <.LIST,
<.LE, AND <.ELIST COMMANDS.  ^THE <.LIST COMMAND HAS THE FORMAT:
 .I 9 <.LIST SPACING
 WHERE SPACING IS A NUMBER IN THE RANGE 1 THROUGH 5 WHICH
SPECIFIES THE SPACING TO BE USED WITHIN THE LIST.
 ^THE LIST IS GENERATED AS FOLLOWS:
.LIST 1
.LE ^EACH LIST ELEMENT IS PRECEDED BY THE <.LE COMMAND.
.LE ^LIST ELEMENTS ARE SEPARATED BY "SPACING" BLANK LINES.
.LE ^EACH ELEMENT IS AUTOMATICALLY NUMBERED BEGINNING AT
BY 1.
.LE ^THE LIST IS TERMINATED BY THE <.ELIST COMMAND (WHICH
ALSO RESETS THE MARGINS AND SPACING).
.LE ^LISTS CAN BE NESTED WITHIN LISTS.  ^THIS IS HANDLED
AS FOLLOWS:
.LIST 1
.LE ^THE LEFT MARGIN IS SET 9 COLUMNS TO THE RIGHT FOR
THE OUTERMOST LIST, AND 4 COLUMNS TO THE RIGHT FOR EACH
INNER LIST.
.LE ^EACH <.LIST MUST BE TERMINATED BY A MATCHING <.ELIST.
^THE <.ELIST RESETS THE MARGINS AND SPACING AS THEY WERE
BEFORE THE <.LIST COMMAND.
.LE ^FOR USERS OF AUTOPARAGRAPHING, THE PARAGRAPH MARGIN
IS SET TO COINCIDE WITH THE LEFT MARGIN, AND PARAGRAPH
SPACING IS SET TO THE LIST SPACING PLUS 1.
 ^THIS MEANS THAT AUTOPARAGRAPHING CAN BE CONVENIENTLY
USED AT ANY LIST LEVEL.
 ^THE PARAGRAPH VALUES ARE RESET BY THE <.ELIST COMMAND.
.ELIST
.LE ^LISTS CAN BE NESTED UP TO 5 LEVELS.
.ELIST
 ^THE LIST FACILITY CAN BE A SIGNIFICANT CONVENIENCE FOR
THE TYPIST.
!.PAGE
.C ^USING ^LISTS
.AP
 ^AUTOMATICALLY NUMBERED LISTS CAN BE GENERATED BY THE <.LIST,
<.LE, AND <.ELIST COMMANDS.  ^THE <.LIST COMMAND HAS THE FORMAT:
 .I 9 <.LIST SPACING
 WHERE SPACING IS A NUMBER IN THE RANGE 1 THROUGH 5 WHICH
SPECIFIES THE SPACING TO BE USED WITHIN THE LIST.
 ^THE LIST IS GENERATED AS FOLLOWS:
.LIST 1
.LE ^EACH LIST ELEMENT IS PRECEDED BY THE <.LE COMMAND.
.LE ^LIST ELEMENTS ARE SEPARATED BY "SPACING" BLANK LINES.
.LE ^EACH ELEMENT IS AUTOMATICALLY NUMBERED BEGINNING AT
BY 1.
.LE ^THE LIST IS TERMINATED BY THE <.ELIST COMMAND (WHICH
ALSO RESETS THE MARGINS AND SPACING).
.LE ^LISTS CAN BE NESTED WITHIN LISTS.  ^THIS IS HANDLED
AS FOLLOWS:
.LIST 1
.LE ^THE LEFT MARGIN IS SET 9 COLUMNS TO THE RIGHT FOR
THE OUTERMOST LIST, AND 4 COLUMNS TO THE RIGHT FOR EACH
INNER LIST.
.LE ^EACH <.LIST MUST BE TERMINATED BY A MATCHING <.ELIST.
^THE <.ELIST RESETS THE MARGINS AND SPACING AS THEY WERE
BEFORE THE <.LIST COMMAND.
.LE ^FOR USERS OF AUTOPARAGRAPHING, THE PARAGRAPH MARGIN
IS SET TO COINCIDE WITH THE LEFT MARGIN, AND PARAGRAPH
SPACING IS SET TO THE LIST SPACING PLUS 1.
 ^THIS MEANS THAT AUTOPARAGRAPHING CAN BE CONVENIENTLY
USED AT ANY LIST LEVEL.
 ^THE PARAGRAPH VALUES ARE RESET BY THE <.ELIST COMMAND.
.ELIST
.LE ^LISTS CAN BE NESTED UP TO 5 LEVELS.
.ELIST
 ^THE LIST FACILITY CAN BE A SIGNIFICANT CONVENIENCE FOR
THE TYPIST.
.PAGE
.HL 1 <CHANGE <BAR <EXAMPLES
.ASIS
.BAR .AP
.C ^USING ^CHANGE ^BARS
.B
 ^CHANGE BARS ARE USED TO FLAG TEXT WHICH HAS BEEN
ALTERED SINCE THE LAST VERSION OF A DOCUMENT, AND ARE
COMMONLY FOUND ONLY IN TECHNICAL WRITING,
.BB WHERE THE READER MUST BE ALTERTED TO NEW FEATURES. .EB
 ^THE <.BAR COMMAND ENABLES CHANGE BARS, AND HAS THE IMMEDIATE
EFFECT OF SHIFTING ALL OUTPUT TEXT RIGHT
.BB THREE .EB
SPACES.
^THE <.NOBAR COMMAND DISABLES CHANGE BARS.  ^USUALLY, THE .BAR COMMAND
APPEARS BEFORE ANY TEXT IN A DOCUMENT, SO THE LEFT MARGIN IN THE OUTPUT
IS UNIFORM.
 ^THE <.BB (^BEGIN ^BAR) COMMAND TURNS ON CHANGE BARS.  ^THAT IS,
<.BB CAUSES A ! TO APPEAR AT THE LEFT MARGIN FOR ANY LINES WHICH
ARE OUTPUT AFTER THE <.BB
.BB (INCLUDING BLANK LINES WHICH ARE A PART OF THE TEXT). .EB
 ^THE <.EB (^END ^BAR) COMMAND SIGNIFIES THE END OF THE CHANGE
BEGUN BY <.BB, AND TURNS OFF CHANGE BARS.
 .BB ^SPACES CAUSED BY THE <.RIGHT COMMAND APPEAR TO THE LEFT OF
THE THREE EXTRA COLUMNS USED BY THE <.BAR FEATURE.
 ^BLANK LINES WHICH APPEAR AS A PART OF CHANGED TEXT ARE
ALSO FLAGGED BY A BAR.
!.PAGE
.BAR .AP
.C ^USING ^CHANGE ^BARS
.B
 ^CHANGE BARS ARE USED TO FLAG TEXT WHICH HAS BEEN
ALTERED SINCE THE LAST VERSION OF A DOCUMENT, AND ARE
COMMONLY FOUND ONLY IN TECHNICAL WRITING,
.BB WHERE THE READER MUST BE ALTERTED TO NEW FEATURES. .EB
 ^THE <.BAR COMMAND ENABLES CHANGE BARS, AND HAS THE IMMEDIATE
EFFECT OF SHIFTING ALL OUTPUT TEXT RIGHT
.BB THREE .EB
SPACES.
^THE <.NOBAR COMMAND DISABLES CHANGE BARS.  ^USUALLY, THE .BAR COMMAND
APPEARS BEFORE ANY TEXT IN A DOCUMENT, SO THE LEFT MARGIN IN THE OUTPUT
IS UNIFORM.
 ^THE <.BB (^BEGIN ^BAR) COMMAND TURNS ON CHANGE BARS.  ^THAT IS,
<.BB CAUSES A _! TO APPEAR AT THE LEFT MARGIN FOR ANY LINES WHICH
ARE OUTPUT AFTER THE <.BB
.BB (INCLUDING BLANK LINES WHICH ARE A PART OF THE TEXT). .EB
 ^THE <.EB (^END ^BAR) COMMAND SIGNIFIES THE END OF THE CHANGE
BEGUN BY <.BB, AND TURNS OFF CHANGE BARS.
 .BB ^SPACES CAUSED BY THE <.RIGHT COMMAND APPEAR TO THE LEFT OF
THE THREE EXTRA COLUMNS USED BY THE <.BAR FEATURE.
 ^BLANK LINES WHICH APPEAR AS A PART OF CHANGED TEXT ARE
ALSO FLAGGED BY A BAR.
.BR .EB
.EB
.NOBAR .PAGE
.HL 1 <TAB <EXAMPLES
.ASIS
.ASCII
.c Using <rno Tabs
.ap
 <rno tab stops are set by the <.tabs command.  The format is:
 .i 9 <.tabs c1 c2 <... c15
 where c1 through c15 are character positions, in ascending order,
where the tab stops are to be set.
(Character positions are numbered beginning at 1). To work
correctly, tab stops must not be set beyond the right margin.
 Tabs are used by the <.t command, which means "begin the next
word at the next tab stop".
 For example, the following
 .i 9 <.tabs 10 20 30 40
.br .i 9 Line <.t this <.t up <.t in <.t columns
 produces
.tabs 19 29 39 49
 .i 9 Line .t this .t up .t in .t columns
 The following features should be noted:
.tab 30 .p -21 2 5 .lm 30
 Justification .t Having tabs in a line does not suppress
justification.  Only the text after the last tab in a line is blank
padded.  This permits convenient use of "hanging" titles and
indentation.
 Left/Right .t Tabs produced by <.t cause the following
word to begin at the next tab stop.  The <.rt
command causes the following word to end at the
next tab stop.  This permits creating tables of numeric
data.
!.PAGE
.C ^USING <RNO ^TABS
.AP
 <RNO TAB STOPS ARE SET BY THE <.TABS COMMAND.  ^THE FORMAT IS:
 .I 9 <.TABS C1 C2 <... C15
 WHERE C1 THROUGH C15 ARE CHARACTER POSITIONS, IN ASCENDING ORDER,
WHERE THE TAB STOPS ARE TO BE SET.
(^CHARACTER POSITIONS ARE NUMBERED BEGINNING AT 1). ^TO WORK
CORRECTLY, TAB STOPS MUST NOT BE SET BEYOND THE RIGHT MARGIN.
 ^TABS ARE USED BY THE <.T COMMAND, WHICH MEANS "BEGIN THE NEXT
WORD AT THE NEXT TAB STOP".
 ^FOR EXAMPLE, THE FOLLOWING
 .I 9 <.TABS 10 20 30 40
.BR .I 9 ^LINE <.T THIS <.T UP <.T IN <.T COLUMNS
 PRODUCES
.TABS 19 29 39 49
 .I 9 ^LINE .T THIS .T UP .T IN .T COLUMNS
 ^THE FOLLOWING FEATURES SHOULD BE NOTED:
.TAB 30 .P -21 1 5 .LM 30
 ^JUSTIFICATION .T ^HAVING TABS IN A LINE DOES NOT SUPPRESS
JUSTIFICATION.  ^ONLY THE TEXT AFTER THE LAST TAB IN A LINE IS BLANK
PADDED.  ^THIS PERMITS CONVENIENT USE OF "HANGING" TITLES AND
INDENTATION.
 ^LEFT/^RIGHT .T ^TABS PRODUCED BY <.T CAUSE THE FOLLOWING
WORD TO BEGIN AT THE NEXT TAB STOP.  ^THE <.RT
COMMAND CAUSES THE FOLLOWING WORD TO END AT THE
NEXT TAB STOP.  ^THIS PERMITS CREATING TABLES OF NUMERIC
DATA.
.PAGE
.HL 1 <MACRO <EXAMPLES
.ASIS
.MACRO BBCB 1 = .B .B .C .BBCB1 .B
.MACRO NOTE * = .SAV .TP 8 .SP 1 .LM +15 .RM -15 .P +0 1 5 .BBCB .NOTE1
.MACRO ENOTE = .B .B .RES
.AP
.C ^THE <NOTE ^COMMAND
 ^THIS EXAMPLE SHOWS THE DEFINITION OF A USEFUL COMMAND VIA THE <.MACRO
FACILITY.
.NOTE ^WARNING
^THIS COMMAND CAN BE HABIT-FORMING.  ^USE IT SPARINGLY.
.ENOTE
^TRY IT, YOU'LL LIKE IT!
!.PAGE
.MACRO BBCB 1 = .B .B .C .BBCB1 .B
.MACRO NOTE * = .SAV .TP 8 .SP 1 .LM +15 .RM -15 .P +0 1 5 .BBCB .NOTE1
.MACRO ENOTE = .B .B .RES
.AP
.C ^THE <NOTE ^COMMAND
 ^THIS EXAMPLE SHOWS THE DEFINITION OF A USEFUL COMMAND VIA THE <.MACRO
FACILITY.
.NOTE ^WARNING
^THIS COMMAND CAN BE HABIT-FORMING.  ^USE IT SPARINGLY.
.ENOTE
^TRY IT, YOU'LL LIKE IT!
.MACRO CHTTL = ^HOW#^TO#^RUN#<RNF
.CH <HOW <TO <RUN <RNF
^THIS IS IMPLEMENTATION DEPENDENT INFORMATION!
 ^THE FOLLOWING JCL MAY BE USED TO RUN <RNF:    .NOF .NOJ .B
<//RNF <EXEC <PGM=RUNOFF,REGION=90K,PARM='/IOBUF=16K',TIME=(2,00)
<//OUTPUT  <DD <SYSOUT=(G,,0721),DCB=(LRECL=133,BLKSIZE=133,RECFM=FBA)
<//QRR     <DD <SYSOUT=A,DCB=(LRECL=90,BLKSIZE=90,RECFM=FB)
<//INPUT <DD *
_ #RUNOFF TEXT
_/*       .F .J .B
 <NOTES:
.B ^IF YOU DO NOT WISH TO SEE THE INPUT PRINTED, SPECIFY <DUMMY, INSTEAD
OF <SYSOUT=A ON THE <QRR <DD CARD.
.B ^ADJUST <REGION=90K IF <BLKSIZE PARAMETERS ARE TOO LARGE, BUT THIS
SHOULD BE SUFFICIENT FOR THE NORMAL CASE.
.B ^BE SURE TO SPECIFY THE PROPER <OUTPUT <DD SYSOUT CLASS AND FORM.
.B ^BE SURE TO SPECIFY THE CORRECT LIBRARY IN THE <//STEPLIB OR <//JOBLIB
<DD CARD.
.REM
.REM      TABLE OF CONTENTS
.REM
.TAB 25 .PS 55 72 .LM +5 .RM -5
.MACRO FRCPAGE = .TCA .TOP .B 10 .U .TCB .B 2 .TCC .NOU .B .MID
.MACRO TCA =
.MACRO TCB = .C <TABLE <OF <CONTENTS .TCBA .BR
.MACRO TCBA =
.MACRO TCC = ^SECTION .T ^TITLE AND ^PAGE .BR
.PAGE
$$PAGE=0;
.MACRO TCA = .BOT .B 5 .C .FMT 4 $$PAGE=$$PAGE+1 .BR
.MACRO TCBA = (^CONTINUED)
.B 2 .NOF .NOJ
.T <CHAPTER 1 -- <INTRODUCTION ##1
.1 .T #<FEATURES #1
.2 .T #<INPUT <TEXT #2
.2.1 .T #<NORMAL ^INPUT #2
.2.2 .T #<ASCII ^INPUT #2
.3 .T #<WORDS #3
.4 .T #<LINES #3
.5 .T #<SPACING #4
.6 .T #<PARAGRAPHS #4
.7 .T #<PAGES #5
.7.1 .T #^EXPLICIT ^PAGING ^CONTROL #5
.7.2 .T #^PAGE ^FORMAT #5
.B
.TP 3 2 .T <CHAPTER 2 -- <COMMANDS ##7
.T #<.AP #7
.T #<.ARRAY #7
.T #<.ASCII #8
.T #<.ASIS #8
.T #<.ATITLE #8
.T #<.AUTOCAP #8
.T #<.B #8
.T #<.BAR #9
.T #<.BB #9
.T #<.BOT #9
.T #<.BR #9
.T #<.C #9
.T #<.CH #9
.T #<.CR #10
.T #<.DEBUG1  #10
.T #<.DEBUG2 #10
.T #<.DEC #10
.T #<.DELMAC #10
.T #<.DOT #10
.T #<.EB #10
.T #<.ELIST #10
.T #<.ESC #11
.T #<.F #11
.T #<.FIG #11
.T #<.FLAG #11
.T #<.FLAGCAPS #11
.T #<.FLAGOVER #11
.T #<.FLAGSIG #12
.T #<.FRCPAGE #12
.T #<.FMT #12
.T #<.HL #13
.T #<.I #13
.T #<.IF #13
.T #<.INC #13
.T #<.J #14
.T #<.LE #14
.T #<.LINES #14
.T #<.LIST #14
.T #<.LPT #14
.T #<.LM #14
.T #<.LOWER #14
.T #<.MACRO #14
.T #<.MID #15
.T #<.NMP #15
.T #<.P #15
.T #<.PAGE #15
.T #<.PERIOD #15
.T #<.PNO #16
.T #<.PP #16
.T #<.PS #16
.T #<.REM #16
.T #<.RES #16
.T #<.RESPAG #16
.T #<.RIGHT #16
.T #<.RM #16
.T #<.RT #17
.T #<.S #17
.T #<.SAV #17
.T #<.SAVPAG #17
.T #<.SIG #17
.T #<.SP #17
.T #<.ST #18
.T #<.STD #18
.T #<.SUP #18
.T #<.T #18
.T #<.TABS #18
.T #<.TITLE #18
.T #<.TOP #18
.T #<.TP #18
.T #<.U #19
.T #<.UPP #19
.T #<.UPPER #19
.T #<.USB #19
.T #<.VAR #19
.T #<.X #19
.B .TP 3 3 .T <CHAPTER 3 -- <MACROS ##21
.1 .T #<WHAT <MACROS <ARE #21
.2 .T #<HOW <TO <DEFINE <A <MACRO #22
.3 .T #<SUB-MACROS #22
.3.1 .T #^DEFINING ^PARAMETERIZED ^MACROS #23
.3.2 .T #^SUB-MACRO ^SEMANTICS #23
.B .TP 3 4 .T <CHAPTER 4 -- <VARIABLES ##24
.1 .T #<VARIABLE <SYNTAX #24
.2 .T #<HOW <TO <DECLARE <VARIABLES #25
.3 .T #<PREDEFINED <VARIABLES #25
.4 .T #<VARIABLE <ARRAYS #25
.5 .T #<EXPRESSIONS #26
.5.1 .T #^EXPRESSION ^SYNTAX #26
.5.2 .T #^EXPRESSION ^EVALUATION #27
.5.3 .T #^WHERE ^EXPRESSIONS ^ARE ^USED #27
.5.4 .T #^SUPPRESSED ^EXPRESSIONS #28
.B .TP 3 5 .T <CHAPTER 5 -- <EXAMPLES ##30
.1 .T #<INPUT <TEXT <EXAMPLE #31
.2 .T #<PARAGRAPHING #33
.3 .T #<HEADER <LEVEL <EXAMPLES #35
.4 .T #<EXAMPLES <OF <LISTS #37
.5 .T #<CHANGE <BAR <EXAMPLES #39
.6 .T #<TAB <EXAMPLES #41
.7 .T #<MACRO <EXAMPLES #43
.B .TP 3 6 .T <CHAPTER 6 -- <HOW <TO <RUN <RNF ##45
.MACRO FRCPAGE = .TCA
.PAGE
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB SNAPSHOT EXT PAS HEX -
(*$D-,X+*)
(*******************************************************************
*
*             SNAPSHOT AND POST MORTEM DUMP UTILITY
*
*     THIS PROGRAM PRINTS OUT THE CURRENT STACK ENVIRONMENT FOR A
*     PASCAL PROGRAM RUNNING ON THE S.L.A.C. TRIPLEX SYSTEM (IBM 370)
*     SNAPSHOT TRACES BACK THROUGH THE STACK FRAMES OF THE PROGRAM
*     AND FOR EACH STACK FRAME PRINTS 1) THE NAME OF THE PROCEDURE
*     WHICH 'OWNS' THAT FRAME, 2) THE NAME OF THE PROCEDURE WHICH
*     CALLED THE OWNING PROCEDURE AND THE SOURCE LINE NUMBER FROM
*     WHICH THE CALL WAS MADE, 3) THE VALUES OF THE PROCEDURE'S
*     PARAMETERS AND LOCAL VARIABLES.
*
*     THIS PROGRAM IS CLOSELY AWARE OF THE RUN-TIME ENVIRONMENT OF
*     'PASCAL' PROGRAMS AND USES 'CASE VARIANT' RECORDS TO INTERPRET
*     THE CONTENTS OF MEMORY LOCATIONS DIFFERENTLY AS NEEDED. FOR
*     THIS REASON, IT SHOULD NOT BE COMPILED WITH THE 'D+' OPTION.
*
*  AUTHOR:  EARL WALDIN
*
*           COMPUTATION RESEARCH GROUP
*           STANFORD LINEAR ACCELERATOR CENTER
*           STANFORD, CA. 94305
*
*
*                                          UPDATED: 12-05-78  (SZH)
*                                          UPDATED: 08-09-79  (SZH)
*
*
******************************************************************)


PROGRAM DUMP(QRD,OUTPUT);



PROCEDURE SNAPSHOT(LEVEL,DMPKIND:INTEGER);


   (* VALUES FOR DMPKIND WHEN CALLED BY A USER PROCEDURE ARE:

      0 - FULL LISTING EXCEPT THAT FOR ARRAYS, ONLY THE FIRST
           AND LAST FEW  ENTRIES ARE PRINTED. (DEFAULT ON ABEND)

      1 - TRACE OF PROCEDURE CALLS ONLY (NO VARIABLES).

     10 - FULL LISTING INCLUDING ALL ENTRIES IN ARRAYS.

   -----------------------------------------------------------*)


   CONST
      HALFW = 65536;   (*2EXP16*)
      ADDRC = 16777216;    (*2EXP24*)
      PROCSIZE = 8192;
      VARLN = 8;
      PNAMLN = 12;
      BYL_INT  = 4;  MAL_INT  = 4;
      BYL_PTR  = 4;  MAL_PTR  = 4;
      BYL_REAL = 8;  MAL_REAL = 8;
      BYL_BOOL = 1;  MAL_BOOL = 1;
      BYL_CHAR = 1;  MAL_CHAR = 1;
      BYL_SET  = 8;  MAL_SET  = 4;
      IBFLN    = 300;
      DEFLEV   = 20;  (* DEFAULT MAX LEVEL OF STACK TO TRACE *)
#     ARRLMT   = 3 ;  (* Default # of array elements printed *)
#     STRLMT   = 140; (* LIMIT ON STRING (ARRAY OF CHAR) SIZE *)
      UNDFINT  = -2122219135 ;    (* HEX '81818181' *)
      UNDFBYTE = 129 ;            (* HEX '81'       *)

   TYPE

      ABNDP = @ABNDAREA;

      ABNDAREA = RECORD
                  ABCODE:INTEGER;
                  ABADDR:INTEGER;
                  ABSPC1:INTEGER;
                  ABLOWR:INTEGER;
                  ABUPPR:INTEGER;
                  ABCVAL:INTEGER;
#                 ABEMSG:@ MSGTYPE;
                  ABMSGL: 1..100;
                  ABREGS: ARRAY[5..12] OF INTEGER;
               END;

      MSGTYPE = ARRAY[1..100] OF CHAR;

      FUNCC = RECORD CASE INTEGER OF
               1:(C:(FULL,STKTRACE));
               2:(P:ABNDP);
               3:(I:INTEGER);
            END;

      MXSET  = SET OF 0..63 ;
      PROCNAME = ARRAY(/1..PNAMLN/) OF CHAR;

      PROC_PTR = @PROC_HEAD;    PROCTPTR = @PROC_TAIL;
      FRM_PTR = @STK_FRM;
      STK_FRM = RECORD
           CASE INTEGER OF

                  (* STACK FRAME MARK AREA *)
              1:(SPC1:INTEGER;
                 BAK_LNK:FRM_PTR;
                 FOR_LNK:FRM_PTR;
                 RET:INTEGER;
                 EPA:PROC_PTR;
                 GPR0_12:ARRAY(/0..12/) OF INTEGER;
                 SPC2,SPC3:INTEGER;
                 FPRS:ARRAY(/1..4/) OF REAL);

                  (* STACK FRAME VARIABLE OVERLAYS *)
              2:(CASE INTEGER OF
                    1:(INT_VA:ARRAY(/0..10000/) OF INTEGER);
                    2:(BOOL_VA:ARRAY(/0..10000/) OF BOOLEAN);
                    3:(CHR_VA:ARRAY(/0..10000/) OF CHAR);
                    4:(REAL_VA:ARRAY(/0..10000/) OF REAL);
                    5:(SETE:ARRAY(/0..10000/) OF MXSET);
                    6:(SPCI:INTEGER;
                           SETO:ARRAY(/0..10000/) OF MXSET) );

                  (* GLOBAL STACK AREA *)
              3:(SPCB:ARRAY(/1..18/) OF INTEGER;
                  CURNTNP:INTEGER;
                  ENDNP0:INTEGER)
           END;

      PROC_HEAD  = RECORD
            SPC1:INTEGER;
            SPNAME:ARRAY(/0..5/) OF CHAR;
            PROCLN:ARRAY(/0..1/) OF CHAR;
            END;

      PROC_TAIL = RECORD
            PROCID:ARRAY(/0..1/) OF CHAR;
            SLINNO:ARRAY(/0..1/) OF CHAR;
            FPNAME:ARRAY(/1..PNAMLN/) OF CHAR;
            LINARY:ARRAY(/1..100000/) OF CHAR;
            END;

      VARTYPE = (INT,RL,BOL,CHA,PTR,REC,PSET,ARY,SCL,FIL,UNK);


   VAR
      DMARRAY:ARRAY(/0..1/) OF FRM_PTR;
      VARTARY:ARRAY(/0..40/) OF VARTYPE;
      DEPTH,MAXDEPTH,I,J,UID,PLEN:INTEGER;
      CH:CHAR ;
      DONE: BOOLEAN ;
      TOPSTK,BOTSTK,TMPSTK:FRM_PTR;
      CPROCN:PROCNAME;
      IBF:ARRAY(/1..IBFLN/) OF CHAR;
      PAR2:FUNCC;
      ARRYLSTF:BOOLEAN;


   PROCEDURE $WRADDR(X:INTEGER);

      VAR   Z0,Z9,ZA:INTEGER; H:ARRAY(/1..6/) OF CHAR;

      BEGIN
      Z0 := ORD('0');  Z9 := ORD('9');  ZA := ORD('A');
       IF (BOTSTK@.CURNTNP <= X) AND (X <= BOTSTK@.ENDNP0)
         THEN BEGIN
            I := 6;
#              REPEAT
#              J := X MOD 16 ;  X := X DIV 16;
#              IF J >= 10 THEN   H(/I/) := CHR(ZA+(J-10))
#              ELSE  H(/I/) := CHR(Z0+J) ;
#              I := I-1 ;
#              UNTIL I = 0;
#
#           WRITE(OUTPUT, H, 'H') ;

            END

         ELSE IF X=-1 THEN WRITE(OUTPUT, 'NIL')
            ELSE WRITE(OUTPUT, 'UNDEF. (pointer)');

      END; (*WRADDR*)


#  FUNCTION $IDLEN(NAME : PROCNAME): INTEGER ;
#     VAR I : INTEGER ;
#
#     BEGIN  I := 0 ;
#
#     REPEAT I := I+1 UNTIL  (NAME(/I/) = ' ') OR ( I >= PNAMLN) ;
#
#     $IDLEN := I-1 ;
#     END ;


   PROCEDURE $GETPNAME(P:PROC_PTR; VAR PID,LEN:INTEGER;
                       VAR NAME:PROCNAME);

      VAR
        TP:RECORD  CASE INTEGER OF
           1:(I:INTEGER);
           2:(P:PROCTPTR)
           END;
        I:INTEGER;

      BEGIN
      LEN := ORD(P@.PROCLN(/0/))*256 + ORD(P@.PROCLN(/1/));
     "FOR I := 1 TO PNAMLN DO NAME(/I/) := ' ';"
      NAME := '            ' ;
      PID := 0;

      IF (LEN = 0) OR (LEN > PROCSIZE)
         THEN FOR I := 1 TO 7 DO
            NAME(/I/) := P@.SPNAME(/I/)

         ELSE BEGIN
         TP.I := ORD(P) + LEN;
         FOR I := 1 TO PNAMLN DO
            NAME(/I/) := TP.P@.FPNAME(/I/);
         PID := ORD(TP.P@.PROCID(/0/))*256 + ORD(TP.P@.PROCID(/1/));
         END;
      END;  (* $GETPNAME *)




   PROCEDURE $PRNTVAR(STKP:FRM_PTR; PNAME:PROCNAME; PID:INTEGER);

      CONST   INDENT6=6;

      TYPE   CMPCODE = (PROCESS, SUCC, TYPERR, IDERR, SYNERR,
                        NUMERR, EOFERR, BUFERR, ADDERR);

         CNTRL = (YES,NO);

      VAR
#        MAXI,I,VADDR,ALNFCT: INTEGER;  TPROCN: PROCNAME;  ERR: CMPCODE;
         INDRCT:BOOLEAN;

         SB:RECORD CASE INTEGER OF
               1:(I:INTEGER);
               2:(P:FRM_PTR)
               END;

#
#     PROCEDURE $ALIGN(VAR OFFSET: INTEGER; ALN: INTEGER);
#
#        (* $ALIGNS POSITIVE 'OFFSET' ON AN 'ALN' BYTE BOUNDARY *)
#
#        BEGIN
#        OFFSET := ((OFFSET+ALN-1) DIV ALN)*ALN;
#        END (*ALIGN*);
#
      PROCEDURE $ERRMSG(ECODE:CMPCODE; INDX:INTEGER);

         VAR   J,K:INTEGER;

         BEGIN
         WRITELN(OUTPUT) ;
         WRITE(OUTPUT, '0    ****  ERROR IN SYMBOL TABLE  ****');
         CASE ECODE OF
            TYPERR:  WRITELN(OUTPUT, '    ILLEGAL TYPE.');
            IDERR:   WRITELN(OUTPUT, '    ILLEGAL IDENTIFIER.');
            SYNERR:  WRITELN(OUTPUT, '    SYNTAX ERROR.');
            NUMERR:  WRITELN(OUTPUT, '    IMPROPER NUMBER.');
            EOFERR:  WRITELN(OUTPUT, '    PREMATURE END OF FILE.');
            BUFERR:  WRITELN(OUTPUT, '    INTERNAL BUFFER EXCEEDED.');
            ADDERR:  WRITELN(OUTPUT, '    ADDRESS EXPECTED.');
            END;

         J := 1;
         WHILE J <= INDX DO BEGIN
            WRITELN(OUTPUT);   WRITE(OUTPUT, ' ');
            IF (INDX-J+1) < 80 THEN K := INDX-J+1 ELSE K := 80;
            WHILE K > 0 DO BEGIN WRITE(OUTPUT, IBF(/J/)); J := J+1;
                  K := K-1; END;
            END;
         WRITELN(OUTPUT);
         END;  (* $ERRMSG *)


      FUNCTION $TRANSVAR(CH:CHAR):VARTYPE;

         VAR  I:INTEGER;

         BEGIN
         I := ORD(CH) - ORD('A');
         IF (0 <= I) AND (I <= (ORD('Z')-ORD('A')))
            THEN $TRANSVAR := VARTARY(/I/)
            ELSE $TRANSVAR := UNK;
         END;  (* $TRANSVAR *)



      PROCEDURE $PRNT(INDNT:INTEGER; VAR INDX,OFFSET:INTEGER;
#                       BASE:FRM_PTR; IDREQ(*,LIST*):CNTRL);

#        VAR   M,L,K,J,I,SAVALN:INTEGER;
               ubnd, lmt, lmt2, lmt3, lmt4: integer;

               I_R_S :RECORD
                        CASE INTEGER OF
                        1: (R : REAL) ;
                        2: (S : MXSET) ;
                        3: (I1: INTEGER; I2: INTEGER) ;
                      END;

               TBOL:BOOLEAN;   TCH:CHAR;

         FUNCTION $CNVTNUM(VAR J:INTEGER): INTEGER;

            VAR  ZERO,NUM:INTEGER;  SIGN:BOOLEAN;

            BEGIN
            NUM := 0;  ZERO := ORD('0');  SIGN := TRUE;
            WHILE IBF(/J/) = ' ' DO J := J+1;
            IF IBF(/J/) = '-' THEN BEGIN SIGN := FALSE; J := J+1; END;
            WHILE IBF(/J/) <> ' ' DO
               BEGIN
               NUM := 10*NUM + ORD(IBF(/J/)) - ZERO;
               J := J+1;
               END;
            J := J+1;
            IF SIGN THEN $CNVTNUM := NUM ELSE $CNVTNUM := -NUM;
            END;


         BEGIN
         IF IDREQ=YES
            THEN BEGIN   I := INDX ;
            WHILE IBF(/INDX/) <> ' ' DO
               BEGIN
              "IF LIST=YES THEN"WRITE(OUTPUT, IBF(/INDX/));
               INDX := INDX+1
               END;
            I := INDX-I ;
#           IF (I > 0) "AND (LIST=YES)"  THEN
#              IF I <= 6 THEN  WRITE(OUTPUT, ' ':6-I)
#              ELSE  BEGIN  WRITE(OUTPUT, ' ':12-I); INDNT := INDNT+INDENT6 END;
            INDX := INDX+1;
            END;

         INDX := INDX+2;

         CASE $TRANSVAR(IBF(/INDX-2/)) OF

            INT,SCL:  BEGIN "  I := OFFSET + BYL_INT -1;
                  OFFSET := I - (I MOD BYL_INT);"
#                 $ALIGN(OFFSET, BYL_INT);  $ALIGN(ALNFCT, BYL_INT);
                  I := BASE@.INT_VA(/OFFSET DIV BYL_INT/) ;
#                "IF LIST=YES THEN"
                     IF I = UNDFINT
                             THEN WRITELN(OUTPUT, ' = UNDEF. (integer/scaler)' )
                             ELSE  WRITELN(OUTPUT, ' = ', I:1);
                  OFFSET := OFFSET + BYL_INT;
                  END;

             RL:  BEGIN    "I := OFFSET + BYL_REAL -1;
                  OFFSET := I - (I MOD BYL_REAL);"
#                 $ALIGN(OFFSET, BYL_REAL);  $ALIGN(ALNFCT, BYL_REAL);
                  I_R_S.R := BASE@.REAL_VA(/OFFSET DIV BYL_REAL/) ;
#                "IF LIST=YES THEN"
                     IF (I_R_S.I1 = UNDFINT) AND (I_R_S.I2 = UNDFINT)
                            THEN WRITELN(OUTPUT, ' = UNDEF. (real)')
                            ELSE  WRITELN(OUTPUT, ' =', I_R_S.R:10);
                  OFFSET := OFFSET + BYL_REAL;
                  END;

            CHA:  BEGIN     "IF LIST=YES THEN" WRITE(OUTPUT, ' = ''');
                  (* LENGTH=1 --> NO ALIGNMENT HERE *)
                  TCH := BASE@.CHR_VA(/OFFSET/);
#                "IF LIST=YES THEN"
                     IF (64 <= ORD(TCH)) AND (ORD(TCH) <= 250)
                            THEN WRITELN(OUTPUT, TCH,'''')
                            ELSE WRITELN(OUTPUT, '#''');
                  OFFSET := OFFSET + BYL_CHAR;
                  END;

            BOL:  BEGIN
                  (* LENGTH=1 --> NO ALIGNMENT HERE *)
                  TBOL := BASE@.BOOL_VA(/OFFSET/) ;

                  "IF LIST=YES THEN"
                     IF ORD(TBOL) = UNDFBYTE
                             THEN WRITELN(OUTPUT, ' = UNDEF. (boolean)')
                             ELSE  IF TBOL THEN  WRITELN(OUTPUT, ' = TRUE')
                                ELSE  WRITELN(OUTPUT, ' = FALSE');
                  OFFSET := OFFSET + BYL_BOOL;
                  END;

            PTR:  BEGIN    "I := OFFSET + BYL_INT -1;
                  OFFSET := I - (I MOD BYL_INT);"
#                 $ALIGN(OFFSET, BYL_PTR);  $ALIGN(ALNFCT, BYL_PTR);
                 "IF LIST=YES THEN"
                     BEGIN
                     WRITE(OUTPUT, ' = ');
                     $WRADDR(BASE@.INT_VA(/ OFFSET DIV BYL_INT/));
                     WRITELN(OUTPUT);
                     END;
                  OFFSET := OFFSET + BYL_INT;
                  END;

           PSET:  BEGIN  "  I := OFFSET + MAL_SET -1;
                  OFFSET := I - (I MOD MAL_SET);"
#                 $ALIGN(OFFSET, MAL_SET);  $ALIGN(ALNFCT, MAL_SET);
                  I := OFFSET DIV BYL_SET;
                  M := OFFSET MOD BYL_SET;
                  L := $CNVTNUM(INDX);    L := $CNVTNUM(INDX);
                  J := 0;

                  IF M=0 THEN  I_R_S.S := BASE@.SETE(/I/)
                     ELSE  I_R_S.S := BASE@.SETO(/I/);

                  "IF LIST=YES THEN"
                     BEGIN
   ##                WRITELN(OUTPUT, ' = (/0..', L:1, '/)');
                     WRITE(OUTPUT, ' ':INDNT+INDENT6+3);
                     IF (I_R_S.I1 = UNDFINT) AND (I_R_S.I2 = UNDFINT)
                        THEN   WRITE(OUTPUT, ' UNDEF. (set)')

                        ELSE  REPEAT
                        IF (J MOD 10) = 0 THEN  WRITE(OUTPUT, ' ');
                        WRITE(OUTPUT, ORD(J IN I_R_S.S):1) ;
                        J := J+1;
                        UNTIL J > L ;


                     WRITELN(OUTPUT);   WRITELN(OUTPUT);
                     END;
#                 OFFSET := OFFSET + BYL_SET;
                  END;

#           REC:  BEGIN   "IF LIST=YES THEN" WRITELN(OUTPUT);
                  INDNT := INDNT+INDENT6;
                  WHILE IBF(/INDX/) <> ';' DO
                     BEGIN
#                   "IF LIST=YES THEN" WRITE(OUTPUT, ' ': INDNT+1);
#                    $PRNT(INDNT,INDX,OFFSET,BASE,YES(*,LIST*));
                     END;
                  WRITELN(OUTPUT);
                  END;

            ARY:  BEGIN   K := $CNVTNUM(INDX); M := $CNVTNUM(INDX);
                  UBND := M-K;

                  IF ($TRANSVAR(IBF(/INDX/)) = CHA) AND (UBND <= STRLMT)
                     THEN BEGIN

#                   "IF LIST=YES THEN"
                        BEGIN  WRITE(OUTPUT, ' = ''');
                        FOR I:=0 TO UBND DO
                           BEGIN
                           TCH := BASE@.CHR_VA(/OFFSET+I/);
                           IF (64 <= ORD(TCH)) AND (ORD(TCH) <= 250) THEN
                              WRITE(OUTPUT, TCH)
                           ELSE  WRITE(OUTPUT, '#');
                           END;

                        WRITELN(OUTPUT, '''');
                        END ;

                     INDX := INDX + 2;
                     OFFSET := OFFSET + BYL_CHAR*(1+UBND);
                     END

                  ELSE BEGIN
                     (* find the range of indices to be printed *)
#                    lmt := arrlmt;
#                    if (ubnd >= 500*arrlmt) or (ubnd <= 3*arrlmt) then
                        lmt := arrlmt*2 ;
#                       (* short arrays, print the whole thing,  *)
#                       (* very long arrays, print more elements *)
#                    lmt4 := ubnd-lmt;  lmt2 := lmt4 div 2;  lmt3 := lmt2+lmt+1;
                    "IF LIST=YES THEN"  WRITELN(OUTPUT);
#                    savaln := alnfct;  alnfct := BYL_CHAR;  (*=1*)

                     FOR i := 0 to ubnd DO

                        IF (i < lmt) OR ((lmt2 < i) and (i < lmt3)) OR
                           (i > lmt4) OR arrylstf  THEN
                           BEGIN
#                          J := INDX;  l := offset;
#                         "IF LIST=YES THEN"
#                             WRITE(OUTPUT, ' ':INDNT, K+I:INDENT6, ']');
#                          $PRNT(INDNT+"INDENT6"4,J,OFFSET,BASE,NO(*,LIST*));
#                          $align(offset, alnfct);
#                          l := offset-l;  (* length of array element *)
#                          END

                        ELSE
                           "IF (ARRLMT <= I) AND (I <= M-K-ARRLMT) THEN "
                           BEGIN
                           "IF LIST=YES THEN"
                              IF (i = lmt) or (i = lmt3) THEN WRITELN(OUTPUT);
                           J := INDX;
#                          offset := offset+l;  (* skip over other elements *)
                           (*PRNT(INDNT+4,J,OFFSET,BASE,NO,"no");*)
                           END ;


                     INDX := J-2;
#                    $align(alnfct, savaln);  (* update alignment factor *)
                    "IF LIST=YES THEN" WRITELN(OUTPUT) ;
                     END;
                  END;

            FIL:  "IF LIST=YES THEN"
                     BEGIN
                     WRITE(OUTPUT, ' @ = ''');
                     IF OFFSET = 0 THEN WRITE(OUTPUT, BASE@.CHR_VA(/0/))
                           ELSE WRITE(OUTPUT, BOTSTK@.CHR_VA(/OFFSET/));
                     WRITELN(OUTPUT, '''');
                     END;

            END;

         INDX := INDX+2;
         END;  (* $PRNT *)



      FUNCTION $IVSCAN(VAR INDX:INTEGER; VAR F:TEXT;
                        IDREQ:CNTRL): CMPCODE;

         TYPE STATVAR = (GTYP,GNAME,PTYP,COPY,GNUM,GTERM);

         VAR  CONT:CMPCODE; VTYPE:VARTYPE;  STATE:STATVAR;
              FIR,LAS:INTEGER;   SWITCH:BOOLEAN;

         BEGIN
         CONT := PROCESS;      SWITCH := FALSE;
         IF IDREQ=YES THEN STATE := GNAME ELSE STATE := GTYP;

         WHILE (NOT EOF(F)) AND (INDX+1<IBFLN) AND (CONT=PROCESS) DO
            BEGIN
            WHILE (F@=' ') AND (NOT EOF(F)) DO GET(F);

            FIR := INDX+1;
            IF NOT (EOF(F) OR (STATE=PTYP))
               THEN IF F@ = ';'
                      THEN BEGIN  READ(F,IBF(/FIR/));  LAS := FIR;
                      INDX := LAS+1; IBF(/INDX/) := ' '; END

                      ELSE BEGIN
                      WHILE NOT(EOF(F) OR (F@ = ';') OR (F@ = ' '))
                            AND (INDX+1 < IBFLN)
                        DO BEGIN
                        INDX := INDX+1; READ(F,IBF(/INDX/));
                        END;

                      IF INDX < IBFLN
                        THEN BEGIN    LAS := INDX;
                        INDX := INDX+1;
                        IBF(/INDX/) := ' '; END

                        ELSE CONT := BUFERR;
                      END;

            IF (NOT EOF(F)) AND (CONT = PROCESS)
               THEN BEGIN

                CASE STATE OF

                  GNAME:   IF (IBF(/FIR/) <> ';')
                              AND ((LAS-FIR)>=0)

                              THEN STATE := GTYP
                              ELSE CONT := IDERR;


                  GTYP:   BEGIN    VTYPE := $TRANSVAR(IBF(/FIR/));
                          IF (VTYPE < UNK) AND ((LAS-FIR)=0)
                            THEN  STATE := PTYP
                            ELSE  CONT := TYPERR;
                          END;

                  PTYP:  IF (VTYPE <= REC) AND (F@ = ';')

                            THEN BEGIN     CONT := SUCC;
                            READ(F,IBF(/INDX+1/)); INDX := INDX+2;
                            IBF(/INDX/) := ' ';  END

                            ELSE IF VTYPE <= PTR
                                  THEN CONT := SYNERR

                            ELSE  CASE VTYPE OF

                                  SCL,FIL: STATE := COPY;


                                  REC: BEGIN
                                       CONT := $IVSCAN(INDX,F,YES);
                                       IF CONT=SUCC THEN CONT:=PROCESS;
                                       END;

                                  PSET,ARY: STATE := GNUM;
                                END;

                  COPY:  IF IBF(/FIR/) = ';' THEN CONT:=SUCC;

                  GNUM:  BEGIN
                         IF IBF(/FIR/) = '-' THEN FIR := FIR+1;
                         FOR FIR := FIR TO LAS DO
                           IF NOT ( (ORD(IBF(/FIR/)) - ORD('0'))
                                     IN (/0..9/) )
                              THEN CONT := NUMERR;

                         IF CONT=PROCESS
                            THEN IF SWITCH
                                   THEN IF VTYPE = ARY
                                      THEN CONT := $IVSCAN(INDX,F,NO)
                                      ELSE STATE := GTERM
                                    ELSE SWITCH := TRUE;
                         END;

                  GTERM: IF IBF(/FIR/) = ';' THEN CONT := SUCC
                            ELSE CONT := SYNERR;


                  END;  (* CASE STATE *)
               END;
            END;
         IF EOF(F) AND (CONT=PROCESS) THEN CONT := EOFERR;
         IF (INDX+2 > IBFLN) AND (CONT=PROCESS) THEN CONT := BUFERR;
         $IVSCAN := CONT;

         END;(*IVSCAN*)


      BEGIN     (* $PRNTVAR *)
#     WRITELN(OUTPUT) ;
#     WRITELN(OUTPUT, '0    ****  Variables for ''', PNAME: $IDLEN(PNAME),
                      ''' are:');
      WRITELN(OUTPUT) ;
      RESET(QRD);
      TPROCN := '            ';   VADDR := -1;

      WHILE ((PNAME <> TPROCN) OR (PID<>VADDR))   AND (NOT EOF(QRD)) DO
         BEGIN
         WHILE (QRD@ <> '%') AND (NOT EOF(QRD)) DO READLN(QRD);

         IF NOT EOF(QRD)
            THEN BEGIN
            GET(QRD);
            WHILE (QRD@=' ') DO GET(QRD);

            I := 1;  TPROCN := '            ';
            WHILE (QRD@ <> ' ') DO IF I <= PNAMLN
                  THEN BEGIN READ(QRD,TPROCN(/I/));  I:=I+1 END
                  ELSE GET(QRD);

            READ(QRD, VADDR);
            READLN(QRD);
            END;


         END;

      IF (PNAME = TPROCN) AND (PID = VADDR)

         THEN BEGIN    ERR := SUCC;
         WHILE (QRD@ = ' ') AND (NOT EOF(QRD)) DO GET(QRD);
         WHILE    (NOT EOF(QRD)) AND (QRD@<>'%') AND (ERR =SUCC)
               AND (QRD@ <> '#') DO
            BEGIN
            INDRCT := QRD@ = '@';
            IF INDRCT
               THEN BEGIN    GET(QRD);
               WHILE (QRD@=' ') AND (NOT EOF(QRD)) DO GET(QRD);
               END;

            IF (ORD(QRD@) - ORD('0')) IN (/0..9/)
               THEN BEGIN
               READ(QRD,VADDR);  MAXI := 0;
               ERR := $IVSCAN(MAXI,QRD,YES);

               IF ERR = SUCC
                  THEN BEGIN "FOR I := 0 TO INDENT6 DO WRITE(OUTPUT, ' ');"
#                 WRITE(OUTPUT, ' ':(INDENT6+1)+4) ;
                  I := 1;

                  IF INDRCT
                     THEN BEGIN
                     SB.I := STKP@.INT_VA(/VADDR DIV BYL_INT/);
                     VADDR := 0;
                     END

                     ELSE SB.P := STKP;

#                 alnfct := mal_char;   (* initialize alignment factor *)
#                 $PRNT(INDENT6+4,I,VADDR,SB.P,YES(*,YES*));
                  WHILE (NOT EOF(QRD)) AND (QRD@=' ') DO GET(QRD);
                  END;

               END

               ELSE BEGIN ERR := ADDERR; MAXI := 0; END;
            END;

         IF ERR <> SUCC THEN $ERRMSG(ERR, MAXI);
         END


         ELSE WRITELN(OUTPUT, ' procedure ',PNAME,' not found in symbol_table');
      END; (*PRNTVAR*)



   FUNCTION $FROMLIN(P:PROC_PTR; RTNADD:INTEGER):INTEGER;

      CONST      ESCAPE = 254; (* HEX 'FE' *)
         ESEND = 255;  (* HEX 'FF' *)

      VAR
         NADDR,LIN,I,INDX:INTEGER;
         TL:RECORD CASE INTEGER OF
            1:(I:INTEGER);
            2:(P:PROCTPTR)
           END;

      BEGIN
      I :=  ORD(P@.PROCLN(/0/))*256 + ORD(P@.PROCLN(/1/));

      IF (I = 0) OR (I > PROCSIZE)  THEN $FROMLIN := 0
         ELSE BEGIN
         NADDR := ORD(P);
         TL.I := ORD(P) + I;
         LIN := ORD(TL.P@.SLINNO(/0/))*256 + ORD(TL.P@.SLINNO(/1/)) -1;
         INDX := 1;

         WITH TL.P@ DO
            WHILE (RTNADD > NADDR) AND (ORD(LINARY(/INDX/)) <> ESEND) DO
               BEGIN
               I := ORD(LINARY(/INDX/));
               INDX := INDX+1;
               LIN := LIN+1;
               IF I <> ESCAPE THEN NADDR := NADDR + 2*I
                  ELSE BEGIN
                  NADDR := NADDR + ORD(LINARY(/INDX/))*512
                           + ORD(LINARY(/INDX+1/))*2;
                  INDX := INDX+2;
                  END;
            END;

         $FROMLIN := LIN;
         END;

      END;  (* $FROMLIN *)


   PROCEDURE $PRNTLNK(CURSTK,PRESTK:FRM_PTR; VAR PNAME:PROCNAME;
                      VAR PID,LNGTH:INTEGER);

      VAR
         TPROCN:PROCNAME;
         I,J:INTEGER;



      BEGIN
      $GETPNAME(CURSTK@.EPA, PID, LNGTH, PNAME);
      $GETPNAME(PRESTK@.EPA,J,I,TPROCN);
      WRITELN(OUTPUT);
      WRITE(OUTPUT, '0    ****  procedure ''',PNAME: $IDLEN(PNAME),
             ''' was called by --> ''',TPROCN: $IDLEN(TPROCN), '''');

      WRITELN(OUTPUT, '  from line: ',
            $FROMLIN(PRESTK@.EPA,(CURSTK@.RET MOD ADDRC)):1);

     END; (*PRNTLNK*)


   PROCEDURE $PRNTSYSD(P:ABNDP; S:PROC_PTR);

      VAR     I,J:INTEGER;  TPROCN:PROCNAME;    CODE: 0..21;

      BEGIN
      WITH P@ DO BEGIN
         WRITE(OUTPUT, '0    ****  Run Error: ',ABCODE:4);
         $GETPNAME(S,I,J,TPROCN);
         IF (0 < J) AND (J < PROCSIZE)
            THEN WRITE(OUTPUT, '  from line: ',$FROMLIN(S,ABADDR MOD ADDRC):1)
            ELSE WRITE(OUTPUT, ' at location: ',(ABADDR MOD ADDRC)-
                                        (ABREGS[10] MOD ADDRC):1);
         WRITELN(OUTPUT, '  of procedure: ''', TPROCN: $IDLEN(TPROCN), '''');

         WRITE(OUTPUT, '0    ****  ');
         IF ABCODE < 2000
            THEN BEGIN
            CODE := ABCODE-1000;
            CASE CODE OF
               1: WRITE(OUTPUT, 'INDEX VALUE ');
               2: WRITE(OUTPUT, 'SUBRANGE VALUE ');
               3: WRITE(OUTPUT, 'ACTUAL PARAMETER ');
               4: WRITE(OUTPUT, 'SET ELEMENT/MEMBER ');
               5: WRITE(OUTPUT, 'POINTER VALUE ');
               6: WRITELN(OUTPUT, 'STACK/HEAP COLLISION.');
               7: WRITELN(OUTPUT, 'ILLEGAL INPUT/RESET OPERATION.');
               8: WRITELN(OUTPUT, 'ILLEGAL OUTPUT/REWRITE OPERATION.');
#              9: WRITELN(OUTPUT, 'SYN. I/O ERROR: ', ABEMSG@:ABMSGL) ;
              10: WRITELN(OUTPUT, 'PROGRAM RUNNING OUT OF TIME.');
              11: WRITELN(OUTPUT, 'FILE DEFINITION ERROR.');
              12: WRITELN(OUTPUT, 'PROGRAM OUT OF STACK SPACE.');
              13: WRITELN(OUTPUT, 'CALL TO UNDEFINED STNDARD PROC.');
              14: WRITELN(OUTPUT, 'FILE LINE-LIMIT EXCEEDED.');
              20: WRITELN(OUTPUT, 'ATTEMPT TO READ PAST END OF FILE.');
              21: WRITELN(OUTPUT, 'ATTEMPT TO READ BAD BOOLEAN.');
              22: WRITELN(OUTPUT, 'ATTEMPT TO READ BAD INTEGER.');
              23: WRITELN(OUTPUT, 'ATTEMPT TO READ REAL.');
              END;

            IF CODE <= 5
               THEN BEGIN
               WRITELN(OUTPUT, 'OUT OF RANGE.');
               WRITELN(OUTPUT, '0    ****  The offending value:  ',ABCVAL:1,
                 '  is not in the range:  ', ABLOWR:1, '..', ABUPPR:1) ;
               END;
            END

            ELSE IF ABCODE < 3000
               THEN BEGIN
               CODE := ABCODE-2000;
               CASE CODE OF
                  0: WRITE(OUTPUT, 'IMPRECISE');
                  1: WRITE(OUTPUT, 'OPERATION');
                  2: WRITE(OUTPUT, 'PRIVILEGED OPERATION');
                  3: WRITE(OUTPUT, 'EXECUTE');
                  4: WRITE(OUTPUT, 'PROTECTION');
                  5: WRITE(OUTPUT, 'ADDRESSING');
                  8: WRITE(OUTPUT, 'FIXED-POINT OVERFLOW');
                  9: WRITE(OUTPUT, 'FIXED-POINT DIVIDE');
                 12: WRITE(OUTPUT, 'EXPONENT OVERFLOW');
                 13: WRITE(OUTPUT, 'EXPONENT UNDERFLOW');
                 14: WRITE(OUTPUT, 'SIGNIFICANCE');
                 15: WRITE(OUTPUT, 'FLOATING-POINT DIVIDE');
                 END;

               WRITELN(OUTPUT, ' EXCEPTION.');
               END

            ELSE IF ABCODE = 3001
#              THEN WRITELN(OUTPUT, 'EXTERNAL ERROR: ', ABEMSG@:ABMSGL);

         END;   (* WITH P@ DO *)
      END;  (* $PRNTSYSD *)


   BEGIN   (* SNAPSHOT *)
  "PAR2.I := DMPKIND MOD 10;"
   I := ORD('A');
   VARTARY(/0/) := ARY;       VARTARY(/ORD('B')-I/) := BOL;
   VARTARY(/ORD('C')-I/) := CHA;
   VARTARY(/ORD('D')-I/) := REC;
   VARTARY(/ORD('I')-I/) := INT;
   VARTARY(/ORD('R')-I/) := RL;
   VARTARY(/ORD('P')-I/) := PTR;
   VARTARY(/ORD('S')-I/) := PSET;
   VARTARY(/ORD('L')-I/) := SCL;
   VARTARY(/ORD('F')-I/) := FIL;

   TOPSTK := DMARRAY(/-16/);  (* SAVED R1 IN RUNTIME STACK *)
   BOTSTK := DMARRAY(/-5/);   (* SAVED R12 IN RUNTIME STACK *)
   TMPSTK := TOPSTK@.BAK_LNK;
   REWRITE(OUTPUT) ;    (* IN CASE "OUTPUT" IS NOT OPEN *)
   WRITELN(OUTPUT, '     ****  SNAPSHOT DUMP OF PROGRAM  ****');
   WRITELN(OUTPUT) ;
   WRITE(OUTPUT, '0    ****  ''SNAPSHOT'' was called by --> ');

   IF LEVEL < 0
      THEN BEGIN
      WRITELN(OUTPUT, '''PASCAL_MONITOR''');
      PAR2.I := DMPKIND ;
      ARRYLSTF := FALSE;
      $PRNTSYSD(PAR2.P,TMPSTK@.EPA);
      LEVEL := -1;  PAR2.C := FULL;
      END

   ELSE BEGIN
      PAR2.I := DMPKIND MOD 10 ;
      ARRYLSTF := ((DMPKIND DIV 10) MOD 10) = 1;
      $GETPNAME(TMPSTK@.EPA,UID,PLEN,CPROCN);
      WRITELN(OUTPUT, '''', CPROCN: $IDLEN(CPROCN), '''  from line: ',
            $FROMLIN(TMPSTK@.EPA,TOPSTK@.RET MOD ADDRC):1);
      END;


   DEPTH := 1;
   IF LEVEL = -1 THEN MAXDEPTH := DEFLEV
      ELSE IF LEVEL = 0  THEN MAXDEPTH := ADDRC
              ELSE MAXDEPTH := LEVEL;


#  IF (PAR2.C = FULL) OR (PAR2.C =STKTRACE) THEN
#
#     REPEAT
#     DONE :=  (TMPSTK = BOTSTK) OR (DEPTH > MAXDEPTH) ;
#
#     IF PAR2.C = FULL THEN    (* DUMP VARIABLES AS WELL AS CALL TRACE *)
#        BEGIN
#        $GETPNAME(TMPSTK@.EPA, UID, PLEN, CPROCN);
#        IF (PLEN > 0) AND (PLEN < PROCSIZE)
#           THEN  $PRNTVAR(TMPSTK, CPROCN, UID);
#        END ; (* FULL DUMP *)
#
#     IF TMPSTK <> BOTSTK THEN
#        $PRNTLNK(TMPSTK, TMPSTK@.BAK_LNK, CPROCN, UID, PLEN);
#     TMPSTK := TMPSTK@.BAK_LNK;
#     DEPTH := DEPTH+1;
#     UNTIL DONE ;
#
#  WRITELN(OUTPUT, '0    ****  END OF DUMP  ****') ;
   PAGE(OUTPUT);

   END; (* SNAPSHOT *)

BEGIN
END.
++FILE PASCALN.OLDCOMP.SAMPLE                       MEMB SOMA     EXT PAS HEX -
(*$M-*)
PROGRAM SOMA(OUTPUT);


   (*************************************************************************
   *                                                                        *
   *               SOLUTIONS TO THE SOMA CUBE PROBLEM                       *
   *                                                                        *
   *                     A PASCAL PROGRAM                                   *
   *                     BY RANCE DELONG                                    *
   *                     MORAVIAN COLLEGE                                   *
   *                                                                        *
   *                     PUBLISHED IN ACM SIGPLAN NOTICES                   *
   *                     VOL. 9 NO. 10 (OCTOBER 1974)                       *
   *                                                                        *
   *************************************************************************)



TYPE
   CUBE_SET = SET OF 1..27;
   WHERE = (TOP, BOTTOM, RIGHT, LEFT, FRONT, BACK, NOWHERE);
   PIECE_DESCRIPTION = ARRAY (/1..3/) OF WHERE;
   AXES = (TBAXIS, RLAXIS, FBAXIS);
   HASH_VALUE = 0..58;
   PLIST_PTR = @ POSN_LIST_ELEMENT;
   WHERE_SET = SET OF WHERE;
   PIECE_RANGE = 1..7;
   POSN_LIST_ELEMENT = RECORD
                          PC_POSITION : CUBE_SET;
                          NEXT_POSN : PLIST_PTR
                       END;

VAR
   THE_CUBE : CUBE_SET;
   PIECE : ARRAY (/1..7/) OF PIECE_DESCRIPTION;
   MAJOR_ROTATIONS : ARRAY (/0..1/) OF AXES;
   ROTATED : ARRAY (/AXES,WHERE/) OF WHERE;
   SHIFT : ARRAY (/WHERE/) OF INTEGER;
   HASH : ARRAY (/WHERE,1..2/) OF INTEGER;
   POSN_LSTHEAD, SOLTION_PTR : ARRAY (/1..7/) OF PLIST_PTR;
   THOSE_CONSIDERED : SET OF HASH_VALUE;
   P, I, SOLUTIONS : INTEGER;
   NUMBER_USED : INTEGER;



FUNCTION ORD1(S:WHERE_SET) : INTEGER;
   VAR I,J : INTEGER;   W : WHERE;
   BEGIN
      I := 0; J := 1;
      FOR W := TOP TO NOWHERE DO
         BEGIN
            IF W IN S THEN I := I + J;
            J := 2*J
         END;
      ORD1 := I
   END (**** ORD1 ****) ;


PROCEDURE INITIALIZE;
   BEGIN
      PIECE(/1,1/) := RIGHT; PIECE(/1,2/) := FRONT; PIECE(/1,3/) := NOWHERE;
      PIECE(/2,1/) := RIGHT; PIECE(/2,2/) := FRONT; PIECE(/2,3/) := FRONT;
      PIECE(/3,1/) := RIGHT; PIECE(/3,2/) := FRONT; PIECE(/3,3/) := RIGHT;
      PIECE(/4,1/) := RIGHT; PIECE(/4,2/) := FRONT; PIECE(/4,3/) := RIGHT;
      PIECE(/5,1/) := RIGHT; PIECE(/5,2/) := TOP;   PIECE(/5,3/) := FRONT;
      PIECE(/6,1/) := RIGHT; PIECE(/6,2/) := FRONT; PIECE(/6,3/) := TOP;
      PIECE(/7,1/) := RIGHT; PIECE(/7,2/) := TOP;   PIECE(/7,3/) := FRONT;
      MAJOR_ROTATIONS(/0/) := FBAXIS; MAJOR_ROTATIONS(/1/) := RLAXIS;
      ROTATED(/TBAXIS,TOP/) := TOP; ROTATED(/TBAXIS,BOTTOM/) := BOTTOM;
      ROTATED(/TBAXIS,RIGHT/) := BACK; ROTATED(/TBAXIS,LEFT/) := FRONT;
      ROTATED(/TBAXIS,FRONT/) := RIGHT; ROTATED(/TBAXIS,BACK/) := LEFT;
      ROTATED(/TBAXIS,NOWHERE/) := NOWHERE;
      ROTATED(/RLAXIS,TOP/) := FRONT; ROTATED(/RLAXIS,BOTTOM/) := BACK;
      ROTATED(/RLAXIS,RIGHT/) := RIGHT; ROTATED(/RLAXIS,LEFT/) := LEFT;
      ROTATED(/RLAXIS,FRONT/) := BOTTOM; ROTATED(/RLAXIS,BACK/) := TOP;
      ROTATED(/RLAXIS,NOWHERE/) := NOWHERE;
      ROTATED(/FBAXIS,TOP/) := LEFT; ROTATED(/FBAXIS,BOTTOM/) := RIGHT;
      ROTATED(/FBAXIS,RIGHT/) := TOP; ROTATED(/FBAXIS,LEFT/) := BOTTOM;
      ROTATED(/FBAXIS,FRONT/) := FRONT; ROTATED(/FBAXIS,BACK/) := BACK;
      ROTATED(/FBAXIS,NOWHERE/) := NOWHERE;
      SHIFT(/TOP/) := 9; SHIFT(/BOTTOM/) := -9; SHIFT(/RIGHT/) := 1;
      SHIFT(/LEFT/) := -1; SHIFT(/FRONT/) := 3; SHIFT(/BACK/) := -3;
      SHIFT(/NOWHERE/) := 0;
      HASH(/TOP,1/) := 1; HASH(/TOP,2/) := 6; HASH(/BOTTOM,1/) := -1;
      HASH(/BOTTOM,2/) := -6; HASH(/RIGHT,1/) := 2; HASH(/RIGHT,2/) := 19;
      HASH(/LEFT,1/) := -2; HASH(/LEFT,2/) := -19; HASH(/FRONT,1/) := 3;
      HASH(/FRONT,2/) := 32; HASH(/BACK,1/) := -3; HASH(/BACK,2/) := -32;
      HASH(/NOWHERE,1/) := 0; HASH(/NOWHERE,2/) := 0;
      THE_CUBE := (//);
      (* INTFIELDSIZE := 3; *)
      NUMBER_USED := 0;
      SOLUTIONS := 0
   END (**** INITIALIZE ****) ;


PROCEDURE RECORD_SOLUTION;
   BEGIN
      SOLUTIONS := SOLUTIONS + 1;
      WRITELN(' SOLUTION ', SOLUTIONS);
      FOR (* PIECES *) P := 1 TO 7 DO
         BEGIN
            WRITE(P, '   ');
            WITH SOLTION_PTR(/P/)@ DO
               FOR I := 1 TO 27 DO IF I IN PC_POSITION THEN WRITE(I);
            WRITELN()
         END;
      WRITELN()
   END (**** RECORD_SOLUTION ****) ;


FUNCTION ORIENTATION(PIECE:PIECE_DESCRIPTION) : HASH_VALUE;
   VAR PC : SET OF WHERE;
   BEGIN   (* SYMMETRIC ORIENTATIONS RECEIVE SAME VALUE *)
      IF P IN (/1,2,7/) THEN
         IF ODD(ORD(PIECE(/1/))) THEN
               PC := (/PRED(PIECE(/1/)),PIECE(/2/)/)
            ELSE PC := (/SUCC(PIECE(/1/)),PIECE(/2/)/);
      CASE P OF
         1,2   : ORIENTATION := ORD1(PC) DIV 2
                          + 32*ORD(ORD(PIECE(/1/)) > ORD(PIECE(/3/)));
         3     : ORIENTATION := ABS(ABS(HASH(/PIECE(/1/),1/)
                          + HASH(/PIECE(/3/),1/)) + HASH(/PIECE(/2/),2/));
         4,5,6 : ORIENTATION := ABS(HASH(/PIECE(/1/),1/)
                          + HASH(/PIECE(/2/),2/) + HASH(/PIECE(/3/),1/));
         7     : ORIENTATION := ORD1(PC + (/PIECE(/3/)/))
      END
   END (**** ORIENTATION ****) ;


PROCEDURE ROTATE(VAR PIECE : PIECE_DESCRIPTION; AXIS : AXES);
   BEGIN
      FOR I := 1 TO 3 DO
         PIECE(/I/) := ROTATED(/AXIS,PIECE(/I/)/)
   END (**** ROTATE ****) ;


PROCEDURE GEN_TRANSLATIONS(PIECE : PIECE_DESCRIPTION;
                                ORIENTATION : HASH_VALUE);
   VAR RLDISP, FBDISP, DISP, J : INTEGER;
       SIZE, PART : ARRAY (/0..3/) OF INTEGER;
       CUBICLE : 1..27;
   BEGIN RLDISP := 1; FBDISP := 3; PART(/0/) := 1;
      FOR I := 0 TO 3 DO SIZE(/I/) := 3;
      THOSE_CONSIDERED := THOSE_CONSIDERED + (/ORIENTATION/);
      FOR I := 1 TO 3 DO
         BEGIN
            PART(/0/) := PART(/0/) + ORD(PIECE(/I/)) MOD 2
                        * (-SHIFT(/PIECE(/I/)/));
            SIZE(/ORD(PIECE(/I/)) DIV 2/) := SIZE(/ORD(PIECE(/I/)) DIV 2/) - 1;
         END;
      IF (* PIECE *) P IN (/3,7/) THEN
         FOR I := 1 TO 3 DO
            PART(/I/) := PART(/I DIV 2/) + SHIFT(/PIECE(/I/)/)
      ELSE
         FOR I := 1 TO 3 DO
            PART(/I/) := PART(/I-1/) + SHIFT(/PIECE(/I/)/);
      FOR I := 1 TO SIZE(/0/)*SIZE(/1/)*SIZE(/2/) DO
         BEGIN
            WITH SOLTION_PTR(/P/)@ DO (* ADD POSITION TO LIST *)
               BEGIN
                  PC_POSITION := (//);
                  FOR J := 0 TO 3 DO
                     BEGIN
                        CUBICLE := PART(/J/);
                        PC_POSITION := PC_POSITION + (/CUBICLE/)
                     END;
                  NEW(NEXT_POSN);
                  SOLTION_PTR(/P/) := NEXT_POSN;
                  NEXT_POSN@.NEXT_POSN := NIL
               END;
            IF I MOD SIZE(/1/) = 0 THEN (* SHIFT TO NEW POSITION *)
               BEGIN (* FORWARD, BACKWARD OR UPWARD MOVEMENT *)
                  RLDISP := -RLDISP;
                  IF I MOD (SIZE(/1/)*SIZE(/2/)) = 0 THEN
                     BEGIN
                        FBDISP := -FBDISP;
                        DISP := 9;
                     END
                  ELSE DISP := FBDISP
               END
            ELSE DISP := RLDISP  (* RIGHT OR LEFT *) ;
           FOR J := 0 TO 3 DO PART(/J/) := PART(/J/) + DISP
         END
   END (**** GEN_TRANSLATIONS ****) ;


PROCEDURE GEN_PIECE_POSITIONS;
   VAR M, MINOR_ROTATIONS : INTEGER; THIS_ORIENTATION : HASH_VALUE;
   BEGIN
      FOR (* PIECES *) P := 1 TO 7 DO
         BEGIN
            THOSE_CONSIDERED := (//);
            NEW(POSN_LSTHEAD(/P/)); SOLTION_PTR(/P/) := POSN_LSTHEAD(/P/);
            FOR (* MAJOR_ROTATIONS *) M := 1 TO 6 DO
               BEGIN
                  FOR MINOR_ROTATIONS := 1 TO 4 DO
                     BEGIN
                        THIS_ORIENTATION := ORIENTATION(PIECE(/P/));
                        IF NOT(THIS_ORIENTATION IN THOSE_CONSIDERED) THEN
                           GEN_TRANSLATIONS(PIECE(/P/),THIS_ORIENTATION)
                        ELSE
                           REPEAT
                              ROTATE(PIECE(/P/),TBAXIS);
                              MINOR_ROTATIONS := MINOR_ROTATIONS + 1
                           UNTIL MINOR_ROTATIONS > 3;
                        ROTATE(PIECE(/P/),TBAXIS);
                     END;
                  ROTATE(PIECE(/P/),MAJOR_ROTATIONS(/M MOD 3 DIV 2/))
               END
         END;
      POSN_LSTHEAD(/2/)@.NEXT_POSN@.NEXT_POSN@.NEXT_POSN := NIL
   END (**** GEN_PIECE_POSITIONS ****) ;


PROCEDURE GEN_SOLUTIONS(PC_NUM : PIECE_RANGE);
   BEGIN
      NUMBER_USED := NUMBER_USED + 1;
      SOLTION_PTR(/PC_NUM/) := POSN_LSTHEAD(/PC_NUM/);
      WHILE SOLTION_PTR(/PC_NUM/)@.NEXT_POSN <> NIL DO
         WITH SOLTION_PTR(/PC_NUM/)@ DO
         BEGIN
            IF THE_CUBE * PC_POSITION = (//) THEN
               BEGIN
                  THE_CUBE := THE_CUBE + PC_POSITION;
                  IF NUMBER_USED = 7 THEN RECORD_SOLUTION
                     ELSE GEN_SOLUTIONS(PC_NUM MOD 7 + 1);
                  THE_CUBE := THE_CUBE - PC_POSITION
               END;
            SOLTION_PTR(/PC_NUM/) := NEXT_POSN
         END;
      NUMBER_USED := NUMBER_USED - 1
   END (**** GEN_SOLUTIONS ****) ;


BEGIN
   INITIALIZE;
   GEN_PIECE_POSITIONS;
   GEN_SOLUTIONS(2)
END (**** SOMA ****) .
++FILE PASCALN.OLDCOMP.SOURCE                       MEMB MON1982  EXT ASS HEX -
         TITLE 'PASCSP, PASCAL RUNTIME SUPPORT AND STANDARD PROCS'      00000010
*********************************************************************** 00000020
*                                                                       00000030
*                                                                       00000040
*                                                                       00000050
*     PASCAL ENVIRONMENT AND ENTRY SETUP                                00000060
*     ------------------------------------                              00000070
*                                                                       00000080
*                                                                       00000090
*     COPYRIGHT 1976, STANFORD LINEAR ACCELERATOR CENTER.               00000100
*                                                                       00000110
*                                                                       00000120
*     THE FOLLOWING PROGRAMS CREATE  THE  RUN-TIME  ENVIRONMENT  AND    00000130
*     PROVIDE THE I/O INTERFACE FOR THE SLAC 'PASCAL' COMPILER.         00000140
*                                                                       00000150
*     EXCEPT FOR THE FEW POINTS EXPLAINED IN THIS BOX, THE INTERNALS    00000160
*     OF THESE ROUTINES SHOULD BE INVISIBLE (AND INCONSEQUENTIAL) TO    00000170
*     THE 'PASCAL' USER.                                                00000180
*                                                                       00000190
*                                                                       00000200
*                                                                       00000210
*     1) THE USER MAY SPECIFY THE SIZE OF THE RUN  TIME  STACK/HEAP,    00000220
*     THE  SIZE OF THE AREA RETURNED TO THE OPERATING SYSTEM FOR I/O    00000230
*     BUFFERS, THE MAXIMUM COUNT OF RUN  TIME  ERRORS,  THE  RUNNING    00000240
*     TIME  OF  THE  PROGRAM,  REQUEST  AN  OPTIONAL MEMORY DUMP AND    00000250
*     SPECIFY OTHER SPECIAL CONTROL OPTIONS AS FOLLOWS:                 00000260
*                                                                       00000270
*       // EXEC USERPROG,                                               00000280
*       //      PARM='USER PARMS /STACK=XXXK,IOBUF=YYYK,             &  00000290
*                            TIME=TTTS,NOSPIE,NOSNAP,NOCC,DUMP'      #  00000300
*                                                                       00000310
*       'USER PARMS': THE PARAMETER LIST TO BE PASSED TO THE USER       00000320
*                     PROGRAM (IF ANY).                                 00000330
*       'XXX' : STORAGE AREA (IN K BYTES) FOR STACK+HEAP.               00000340
*       'YYY' : STORAGE AREA (IN K BYTES) TO BE RETURNED TO SYSTEM.     00000350
*       'TTT' : PROGRAM RUNNING TIME (IN SECONDS).                      00000360
*       'DUMP': TO GENERATE AN OS STYLE MEMORY DUMP IN CASE OF AN       00000370
*               ABNORMAL PROGRAM TERMINATION.                           00000380
*       'NOSPIE': TO PREVENT INTERCEPTION OF ERROR INTERRUPTS        #  00000390
*       'NOSNAP': TO STOP USE OF SNAPSHOT RT. AFTER AN ERROR         #  00000400
*       'NOCC': TO STOP FIRST CHARACTER ON EACH LINE FROM BEING      #  00000410
*               TAKEN AS A CONTROL CHARACTER                         #  00000420
*       DEFAULT VALUE FOR 'XXXK' IS THE JOB 'REGION' SIZE.              00000430
*       DEFAULT VALUE FOR 'YYYK' IS 36K.                                00000440
*                                                                       00000450
*     2) THE VALUE OF THE RETURN CODE 'RC', IF OTHER  THAN GENERATED    00000460
*     BY  THE  USER  PROGRAM,  MAY  BE  INTERPRETED ACCORDING TO THE    00000470
*     FOLLOWING TABLE.  FOR MORE DETAILED EXPANATION  OF  THE  ERROR    00000480
*     CONDITION,  SEE  THE  CONTENTS OF THE 'OUTPUT' FILE WHICH HAVE    00000490
*     THE APPROPRIATE MESSAGES.  NOTE THAT THIS FILE (OUTPUT) SHOULD    00000500
*     BE INCLUDED IN THE USER PROGRAM IN ORDER TO GET THE  RUN  TIME    00000510
*     DIAGNOSTICS AND RELATED MESSAGES.                                 00000520
*                                                                       00000530
*       RETURN CODE:  IMPLIES:                                          00000540
*                                                                       00000550
*       1001          INDEX VALUE OUT OF RANGE                          00000560
*       1002          SUBRANGE VALUE OUT OF RANGE                       00000570
*       1003          ACTUAL PARAMETER OUT OF RANGE                     00000580
*       1004          SET MEMBER OUT OF RANGE                           00000590
*       1005          POINTER VALUE INVALID                             00000600
*       1006          STACK/HEAP COLLISION                              00000610
*       1007          ILLEGAL INPUT/RESET OPERATION                     00000620
*       1008          ILLEGAL OUTPUT/REWRITE OPERATION                  00000630
*       1009          SYNCHRONOUS I/O ERROR                             00000640
*       1010          PROGRAM EXCEEDED SPECIFIED RUNNING TIME           00000650
*       1011          ILLEGAL FILE DEFINITION (I.E., TOO MANY FILES)    00000660
*       1012          NOT ENOUGH STACK SPACE                            00000670
*       1013          UNDEFINED OR OBSOLETE CSP CALL                 #  00000680
*       1014          LINELIMIT EXCEEDED FOR A FILE                  #  00000690
*       1015          BAD FILE CONTROL BLOCK                         @  00000700
*       1016          INPUT RECORD TOO LARGE                         @  00000710
*       1020          READ PAST END OF FILE                          #  00000720
*       1021          BAD BOOLEAN INPUT                              #  00000730
*       1022          BAD INTEGER INPUT                              #  00000740
*       1023          BAD REAL INPUT                                 #  00000750
*       1024          OVER-LARGE INTEGER INPUT                       &  00000760
*                                                                       00000770
*       200X          PROGRAM INTERRUPTION CODE 'X'                     00000780
*                                                                       00000790
*       3001          MISC. EXTERNAL ERROR CONDITIONS.                  00000800
*                                                                       00000810
*       X1XX          UNABLE TO RUN SNAPSHOT, OTHER DIGITS AS ABOVE     00000820
*                                                                       00000830
*                                                                       00000840
*     3) THE CONDITIONAL ASSEMBLY FLAG &SYSTEM DETERMINES WHETHER    #  00000850
*     CERTAIN SECTIONS OF CODE ARE INCLUDED IN THE PROGRAM.          #  00000860
*     WITH &SYSTEM=1, SOME CHECKING CODE, REAL NUMBER INPUT AND THE  #  00000870
*     FORTRAN INTERFACE IS OMITTED.  THIS RESULTS IN A SMALLER       #  00000880
*     FASTER PROGRAM BUT WHICH CAN ONLY BE USED WITH "SAFE"          #  00000890
*     PROGRAMS THAT DO NOT USE MATHEMATICAL ROUTINES - SUCH AS THE   #  00000900
*     COMPILER AND THE P-ASSEMBLER.                                  #  00000910
*     WITH &SYSTEM=0, THE FULL PROGRAM IS PRODUCED AND THIS IS THE   #  00000920
*     VERSION THAT SHOULD NORMALLY BE COMBINED WITH USER PROGRAMS.   #  00000930
*     THE CONDITIONAL ASSEMBLY FLAG &IBM370 DETERMINES WHETHER       @  00000940
*     IBM370 INSTRUCTIONS MAY BE GENERATED.  WHEN &IBM370=1,         @  00000950
*     THESE INSTRUCTIONS (E.G. MVCL) ARE USED FOR SPEED IN A FEW     @  00000960
*     CASES.  WHEN &IBM370=0, ONLY IBM360 INSTRUCTIONS ARE USED.     @  00000970
*                                                                       00000980
*                                                                       00000990
*     4) THIS PROGRAM MAY BE ASSEMBLED WITH MOST STANDARD IBM        #  00001000
*     ASSEMBLERS.                                                    #  00001010
*                                                                       00001020
*                                                                       00001030
*     5) IF THE RUN PROFILE SWITCH IS ENABLED IN THE PASCAL  PROGRAM    00001040
*     (I.E.   'K+'),  THE  RUN  TIME SYSTEM WILL 'REWRITE' THE 'RAW'    00001050
*     EXECUTION COUNTS ON THE PREDEFINED 'QRR'  FILE  AFTER  RUNNING    00001060
*     THE  USER  PROGRAM.  IN SUCH CASES THE USER PROGRAM SHOULD NOT    00001070
*     USE THE 'QRR' FILE BUT THE 'DD' STATEMENT FOR THIS FILE SHOULD    00001080
*     BE INCLUDED IN THE 'GO' STEP.  THE SUBMONITOR WILL SUBSEQUENTLY   00001090
*     INVOKE THE "PASPROF" LOAD-MODULE TO PRINT THE PROFILE.            00001100
*                                                                       00001110
*                                                                       00001120
*                                                                       00001130
*                                                                       00001140
*     THESE PROGRAMS INCLUDE SOME CONTRIBUTIONS BY KEITH RICH,  JOHN    00001150
*     BANNING AND NIGEL HORSPOOL.                                       00001160
*                                                                       00001170
*                                                                       00001180
*                                                                       00001190
*                                SASSAN HAZEGHI,                        00001200
*                                                                       00001210
*                                COMPUTATION RESEARCH GROUP             00001220
*                                STANFORD LINEAR ACCELERATOR CENTER     00001230
*                                P. O. BOX 4349                         00001240
*                                STANFORD, CALIFORNIA  94305.           00001250
*                                                                       00001260
*                                                                       00001270
*                                                                       00001280
*                                LAST UPDATE:                           00001290
*                                             MAR.  15, 76.             00001300
*                                             SEPT.  8, 76.             00001310
*                                             JAN.  20, 77.             00001320
*                                             JULY  28, 77.             00001330
*                                             MAY   21, 77.             00001340
*                                             JULY   6, 78.             00001350
*                                             SEPT. 15, 78.             00001360
*                                             NOV.  11, 78.             00001370
*                                             AUG.  09, 79.             00001380
*                                                                       00001390
*     FURTHER MODIFICATIONS MADE AT MCGILL UNIVERSITY,               #  00001400
*                                                                    #  00001410
*                                R. NIGEL HORSPOOL                   #  00001420
*                                APRIL 7, 1982                       &  00001430
*
*     Minor mods made by Dave Edwards (DE), Jan/2007 - see below.
*
* See also:  $psc:pascal.mon.notes
*            $psc:pascal.lib.notes
*
* *** This module, assembled with &SYSTEM set to 0, also forms
*     part of $psc:pascal.lib (run-time library object).
*
* 28jan2007 - JCL added an top of file, and module reassembled.
*    No change to the source. See $psc:pascal.mon.notes . (DE)
* 28jan2007 - Fix year-2000 problem when setting PASDATE (for the
*    Pascal predefined variable DATE e.g. '01-28-2007'): set correct
*    century if actual year is 20yy and this seems to be a MUSIC/SP
*    system. Previously, year 20nn would be reported as 19nn.
*    (But coding is still incorrect for years like 2100, because
*    that year is not a leap year.) (DE)
*                                                                       00001440
*********************************************************************** 00001450
         EJECT                                                          00001460
**************************************************************          00001470
*                                                                       00001480
*        I/O (FILE) HANDLING MACROS                                     00001490
*                                                                       00001500
**************************************************************          00001510
*                                                                       00001520
         MACRO ,                                                        00001530
&L       FILADR ,                                                       00001540
.*       TO COMPUTE FILE BUFFER ADDRESS ETC.                            00001550
         GBLB  &SYSTEM                                               @  00001560
&L       L     AE,PFILPTR(AD)      LOAD FILE BLOCK ADDR              @  00001570
         AIF   (&SYSTEM).NOCHK                                       @  00001580
         C     AD,FILPAS(AE)       CHECK THAT FILE BLOCK POINTS      @  00001590
         BNE   BADFILE             TO PASCAL FILE VARBL.             @  00001600
.NOCHK   L     AF,FILBUF(AE)       SET I/O BUFFER POINTER            @  00001610
         MEND  ,                                                        00001620
*                                                                       00001630
         MACRO ,                                                     #  00001640
         FILDEF &NAME,&DIRECT,&KIND,&LINK                            @  00001650
.*       DEFINE A FILE                                               @  00001660
         LCLC  &NAM,&OPT1,&OPT2                                         00001670
         DS    0D                                                    #  00001680
&NAM     SETC  '&NAME'(1,3)                                          #  00001690
FIL&NAM  DC    CL8'&NAME'          PASCAL FILE IDENTIFIER            @  00001700
         DC    A(&LINK)            PTR TO NEXT FILE BLOCK            @  00001710
         DC    A(0)                PTR TO PASCAL FILE VRBL.          @  00001720
         DC    A(0)                I/O BUFFER ADDRESS                @  00001730
         DC    F'0'                LINE-LIMIT FOR FILE (ON OUTPUT)   @  00001740
         DC    H'0'                CURRENT RECORD LENGTH (TEXTFILE)  @  00001750
         AIF   ('&KIND' NE 'TEXT').FD2                               @  00001760
&OPT1    SETC  'PL'                LOCATE-MODE OUTPUT NEEDED         @  00001770
         AIF   ('&DIRECT' EQ 'OUTPUT').FD1                           @  00001780
&OPT1    SETC  'GL'                LOCATE-MODE INPUT NEEDED          @  00001790
         AIF   ('&DIRECT' EQ 'INPUT').FD1                            @  00001800
&OPT2    SETC  'PL'                BOTH LOCATE MODE INPUT & OUTPUT   @  00001810
.FD1     DC    AL1(TEXTFLAG,0)     OPEN/TEXT FLAGS, EOF FLAG         @  00001820
         DC    H'0',H'0'           CHAR PTR, CHAR START POS          @  00001830
         AGO   .FD3                                                  @  00001840
.FD2     DC    AL1(0,0)            OPEN/TEXT FLAGS, EOF FLAG         @  00001850
         DC    H'0',H'0'           MAX REC SIZE, FILE COMP. SIZE     @  00001860
&OPT1    SETC  'GM'                MOVE-MODE INPUT AND               @  00001870
&OPT2    SETC  'PM'                MOVE-MODE OUTPUT NEEDED           @  00001880
.FD3     ANOP  ,                                                     @  00001890
         DCB   DSORG=PS,DDNAME=&NAME,EODAD=EOD,SYNAD=SYNADRT,        @ X00001900
               EXLST=XL&DIRECT,BFTEK=A,MACRF=(&OPT1,&OPT2)           @  00001910
         MEND  ,                                                     @  00001920
*                                                                    #  00001930
         EJECT                                                          00001940
         GBLB  &SYSTEM,&IBM370                                       @  00001950
&SYSTEM  SETB  1                  TRUE INDICATES A COMPACT 'CSP'        00001960
&IBM370  SETB  0                  TRUE INDICATES AN IBM-370          @  00001970
*                                                                       00001980
         AIF   (&SYSTEM).SYS1                                           00001990
*        GENERAL SETUP FOR USER PROGRAM(S).                             00002000
         AGO   .USE1                                                    00002010
.SYS1    ANOP                                                           00002020
*        COMPACT SETUP, OMITS FORTRAN INTERFACE & TRACING               00002030
.USE1    ANOP                                                           00002040
*                                                                       00002050
*                                                                       00002060
*                                                                       00002070
         EJECT                                                          00002080
***************************************************************         00002090
*                                                                       00002100
*        STACK (AND SAVE AREA) LAYOUT                                   00002110
*                                                                       00002120
***************************************************************         00002130
*                                                                       00002140
*                                                                       00002150
         PRINT NOGEN                                                    00002160
         DCBD  DSORG=PS                                                 00002170
         PRINT GEN                                                      00002180
*                                                                       00002190
DYNSTORE DSECT ,                                                        00002200
         DS    20F                 PASCAL ENVIRONMENT SAVE AREA         00002210
STACK    DS    18F                 BOTTOM OF RUNTIME STACK              00002220
CLOCK    EQU   STACK               CLOCK LOCATION                       00002230
NEWPTR   DS    A                   PASCAL 'NEW' POINTER                 00002240
HEAPLIM  DS    A                   UPPER LIMIT OF HEAP ( +1 )           00002250
*                                  ALSO POINTS TO DYN2STOR              00002260
DISPREGS DS    10F                 RUN TIME DISPLAY REGISTERS           00002270
DISPLAY  EQU   DISPREGS,*-DISPREGS                                      00002280
FL1      DS    D                   R/W  FIX/FLOAT CONVERSION HELPS      00002290
FL2      DS    D                   R ONLY                               00002300
FL3      DS    D                   R/W                                  00002310
FL4      DS    D                   R ONLY                               00002320
CHKSUBS  DS    0F                  ENTRY TO RUN TIME CHECK ROUTINES     00002330
INXCHK   DS    3F                  INDEX CHECK                          00002340
RNGCHK   DS    3F                  SUBRANGE CHECK                       00002350
PRMCHK   DS    3F                  PARAMETER VALUE CHECK                00002360
PTRCHK   DS    3F                  POINTER CHECK                        00002370
PTACHK   DS    3F                  SET MEMBER CHECK                     00002380
SETCHK   DS    3F                                                       00002390
STKCHK   DS    3F                                                       00002400
TRACER   DS    3F                                                    &  00002410
INPUT    DS    3F                                                    @  00002420
OUTPUT   DS    3F                                                    @  00002430
PRD      DS    3F                                                    @  00002440
PRR      DS    3F                                                    @  00002450
QRD      DS    3F                                                    @  00002460
QRR      DS    3F                                                    @  00002470
CLEARBUF DS    XL8                  BUFFER TO CLEAR ACTIVATION RECORDS  00002480
PASDATE  DS    CL10                 PREDEFINED VARIABLE DATE            00002490
PASTIME  DS    CL10                 PREDEFINED VARIABLE TIME            00002500
OSPRMPTR DS    A                    POINTER TO O.S. PARM STRING      #  00002510
FRSTGVAR DS    0D                  FOR ALIGNMENT PURPOSES               00002520
*                                                                       00002530
*       DYNAMIC STORAGE AREA POINTED TO BY HEAPLIM                      00002540
*                                                                       00002550
DYN2STOR DSECT     ,                                                    00002560
DYNRUNC  DS        F         # OF RUN TIME FREQUENCY COUNTERS           00002570
         DS        0D                                                   00002580
DYNCOUNT DS        0F                                                   00002590
         AIF       (&SYSTEM).SYS3                                       00002600
DYN2LEN  EQU       128       EXTRA MARGIN FOR PATHOLOGICAL CALL PARMS   00002610
         AGO       .USE3                                                00002620
.SYS3    ANOP                                                           00002630
DYN2LEN  EQU       *-DYN2STOR                                           00002640
.USE3    ANOP                                                           00002650
*                                                                       00002660
         EJECT                                                          00002670
**************************************************************          00002680
*                                                                       00002690
*        PASCAL ENTRY POINT AND PROGRAM PROLOGUE                        00002700
*                                                                       00002710
**************************************************************          00002720
*                                                                       00002730
*                                                                       00002740
$PASENT  CSECT ,                                                        00002750
         ENTRY $PASENT,$PASCSP,$PASINT,$TRACER                       &  00002760
*                                                                       00002770
*                                                                       00002780
         USING *,15                                                     00002790
         SAVE  (14,12),,*                                               00002800
         LR    R10,R15                                                  00002810
         DROP  R15                                                      00002820
         USING $PASENT,R10                                              00002830
         ST    R1,OSPARMS          SAVE ADDRESS OF O.S. PARMS        #  00002840
         L     R1,0(R1)                                                 00002850
         SPACE                                                          00002860
*                                                                       00002870
*        R1 POINTS TO THE PARAMETER LIST THE FIRST HALF WORD OF         00002880
*        WHICH GIVES THE LENGTH OF THE LIST                             00002890
*                                                                       00002900
         LH    R2,0(R1)                                                 00002910
         LTR   R2,R2                                                    00002920
         BNH   NOPARM             NO PARAMETER LIST SPECIFIED           00002930
         LA    R0,256              SET MAX STRING LENGTH             #  00002940
         CR    R2,R0                                                 #  00002950
         BNH   *+6                 JUMP IF LENGTH OK                 #  00002960
         LR    R2,R0               ENFORCE THE LIMIT                 #  00002970
         LA    R8,1                INCREMENT FOR BXLE & BXH          #  00002980
         LA    R9,1(R1,R2)         LIMIT FOR BXLE & BXH              #  00002990
         LA    R1,2(,R1)           POINT AT FIRST CHAR               #  00003000
         ST    R1,OSPARMAD         SAVE ADDRESS FOR LATER            #  00003010
*                                                                       00003020
PARMRTRY CLI   0(R1),C'/'                                               00003030
         BE    PARMSLSH            SEPARATOR FOUND ?                 #  00003040
         BXLE  R1,R8,PARMRTRY                                        #  00003050
*                                                                       00003060
PARMSLSH LR    R3,R1                                                 #  00003070
         SL    R3,OSPARMAD         COMPUTE STRING LENGTH             #  00003080
         STH   R3,OSPARML          SAVE IT FOR LATER                 #  00003090
         BXH   R1,R8,NOPARM        JUMP IF STRING END                #  00003100
GOTPARM  SR    R0,R0               CLEAR NEGATE FLAG                 &  00003110
         CLI   0(R1),C','                                               00003120
         BNE   *+8                                                      00003130
         LA    R1,1(,R1)                                                00003140
         CLC   0(2,R1),=C'NO'      TEST FOR NEGATION OF KEYWORD      &  00003150
         BNE   *+12                                                  &  00003160
         LA    R0,X'FF'           SET NEGATION FLAG                  &  00003170
         LA    R1,2(,R1)                                             &  00003180
         LA    R5,KWRDTAB                                            &  00003190
         SR    R3,R3                                                 &  00003200
KWRDSRCH IC    R3,2(,R5)           LOAD KEYWORD LENGTH-1             &  00003210
         LTR   R3,R3               ZERO FLAGS TABLE END              &  00003220
         BZ    NXTPARM             SO EXIT                           &  00003230
         EX    R3,KWRDCLC          COMPARE NEXT KEYWORD              &  00003240
         BE    KWRDFND             JUMP IF MATCHED                   &  00003250
         LA    R5,4(R3,R5)         STEP TO NEXT ENTRY                &  00003260
         B     KWRDSRCH            AND REPEAT                        &  00003270
KWRDCLC  CLC   0(*-*,R1),3(R5)                                       &  00003280
KWRDFND  LA    R1,1(R3,R1)         ADVANCE IN PARM STRING            &  00003290
         CLI   1(R5),0             TEST NUMERIC INPUT FLAG           &  00003300
         BE    KWRDNON             JUMP IF NOT WANTED                &  00003310
         LTR   R0,R0          TEST IF "NO" SPECIFIED                 &  00003320
         BNZ   KWRDNON        IF SO, NO INTEGER FOLLOWS              &  00003330
         BAL   R7,GETNUM           GET AN INTEGER                    &  00003340
         LTR   R4,R4               TEST FOR VALIDITY                 &  00003350
         BNP   NXTPARM             AND IGNORE IF NO GOOD             &  00003360
         SR    R3,R3               RE-CLEAR R3 (USED BY GETNUM)      &  00003370
KWRDNON  IC    R3,0(,R5)           GET RELATIVE ADDRESS              &  00003380
         B     KWRDSTAK(R3)        AND GO TO THIS ROUTINE            &  00003390
*                                                                       00003400
KWRDSTAK LTR   R0,R0          TEST "NO" OPTION                       &  00003410
         BNZ   NXTPARM        IF SO, IGNORE                          &  00003420
         SLA   R4,10          CONVERT TO K                              00003430
         ST    R4,REQSTORE         RESET REGION SIZE                    00003440
         ST    R4,REQSTORE+4       AND SET MAXIMUM STORAGE              00003450
         B     NXTPARM                                                  00003460
*                                                                       00003470
KWRDIOB  LTR   R0,R0          TEST "NO" OPTION                       &  00003480
         BNZ   NXTPARM        IF SO, IGNORE                          &  00003490
         SLA   R4,10          CONVERT TO K                              00003500
         ST    R4,BUFSTORE         SET I/O BUFFER AMOUNT                00003510
         B     NXTPARM                                                  00003520
*                                                                       00003530
KWRDDUMP STC   R0,DUMPFLAG         SET THE DUMP FLAG                 &  00003540
         XI    DUMPFLAG,X'FF'      BUT R0 WAS REVERSED               &  00003550
         B     NXTPARM                                                  00003560
*                                                                       00003570
KWRDTIME LTR   R0,R0          TEST "NO" OPTION                       &  00003580
         LH    R5,=H'-1'      SET FOR UNLIMITED EXECUTION            &  00003590
         BNZ   KWRDTIM2                                              &  00003600
         LR    R5,R4                                                    00003610
         M     R4,=F'38400'        CONVERT TO TIMER UNITS            &  00003620
         CLI   0(R1),C'M'          TEST FOR TIME IN                  &  00003630
         BNE   KWRDTIM2            THOUSANDTHS OF A SECOND           &  00003640
         D     R4,=F'1000'         IF SO, CONVERT                    &  00003650
KWRDTIM2 ST    R5,EXECTIME         AND SAVE FOR STIMER               &  00003660
         B     NXTPARM                                                  00003670
*                                                                       00003680
KWRDCC   L     R15,=A(CCFLAG)      FLAG NOT DIRECTLY ADDRESSABLE     &  00003690
         STC   R0,0(,R15)          SET THE FLAG                      &  00003700
         B     NXTPARM                                                  00003710
*                                                                       00003720
KWRDSPIE STC   R0,SPIEFLAG         SET THE FLAG                      &  00003730
         B     NXTPARM                                               &  00003740
*                                                                       00003750
KWRDSNAP STC   R0,SNAPFLAG         SET THE FLAG                      &  00003760
         B     NXTPARM                                                  00003770
*                                                                       00003780
NXTPARM  BXLE  R1,R8,GOTPARM       STEP TO NEXT CHAR                 #  00003790
*                                                                    #  00003800
*                                                                    #  00003810
*        DDNAME-LIST PARAMETER PROCESSING                            #  00003820
*                                                                    #  00003830
NOPARM   EQU   *                                                     #  00003840
         L     R1,OSPARMS                                            #  00003850
         TM    0(R1),X'80'         TEST IF DDNAME LIST PROVIDED      #  00003860
         BO    NODDPARM                                              #  00003870
         L     R1,4(,R1)           ADDRESS OF DDNAME LIST PARM       #  00003880
         LH    R2,0(,R1)           LENGTH OF LIST IN BYTES           #  00003890
         L     AE,=A(FILLIST)      POINT AT FIRST FILE IN            @  00003900
         L     AE,0(,AE)              THE CHAIN OF FILE BLOCKS       @  00003910
DDLOOP   SH    R2,=H'8'            CHECK FOR END OF DDNAME LIST      #  00003920
         BM    NODDPARM                                              #  00003930
         TM    2(R1),X'FF'         CHECK FOR BINARY ZEROS            @  00003940
         BZ    DDDFLT              IF SO, DONT CHANGE DDNAME         #  00003950
         USING IHADCB-FILDCB,AE                                      #  00003960
         MVC   DCBDDNAM(8),2(R1)   MOVE NEW DDNAME INTO DCB          #  00003970
DDDFLT   LA    R1,8(,R1)           ADVANCE THROUGH LIST              #  00003980
         L     AE,FILLNK(AE)       ADVANCE TO NEXT FILE IN CHAIN     @  00003990
         LTR   AE,AE               TEST FOR END OF CHAIN             @  00004000
         BNZ   DDLOOP              IF NOT END, REPEAT                @  00004010
NODDPARM EQU   *                                                     #  00004020
*                                                                       00004030
*                                                                       00004040
*        GET SPACE FOR THE RUN TIME STACK                               00004050
*                                                                       00004060
         L     R0,BUFSTORE                                              00004070
         A     R0,REQSTORE         COMPUTE THE SIZE OF THE SMALLEST     00004080
         ST    R0,REQSTORE         AREA THAT WILL MEET THE DEMAND       00004090
         C     R0,REQSTORE+4                                            00004100
         BL    *+8                 UPPER BOUND OK ?                     00004110
         ST    R0,REQSTORE+4       ADJUST IT IF NEEDED.                 00004120
*                                                                       00004130
*        GET ENOUGH SPACE FOR STACK+IOBUF NOW                           00004140
*                                                                       00004150
         GETMAIN VU,LA=REQSTORE,A=ALOSTORE                              00004160
         SPACE ,                                                        00004170
*                                                                       00004180
         L     R1,ALOSTORE         GET ADDRESS OF ALLOCATED AREA        00004190
         LR    R12,R1                                                   00004200
         A     R1,ALOSTORE+4       ADD SIZE OF THE AREA                 00004210
         S     R1,BUFSTORE         BEGINNIG (ENDING !) OF THE HEAP      00004220
         S     R1,=A(8)            NAME FIELD OF THE HEAP               00004230
         USING DYNSTORE,GBR                                          @  00004240
         AIF   (&SYSTEM).SYS32                                          00004250
*                                                                       00004260
         LR    R2,R1                                                    00004270
         SR    R2,R12              R2 <-- SIZE OF THE USABLE AREA       00004280
         L     R3,=A(FRSTGVAR-STACK)                                 @  00004290
         CLR   R2,R3                                                 @  00004300
         BNH   NOCLR               SKIP IF NOT LARGE ENOUGH             00004310
         AIF   (&IBM370).M720                                        @  00004320
         LR    R2,R3                                                 @  00004330
         LD    FPR0,=XL8'8181818181818181'                              00004340
         SRA   R2,3                CONVERT BYTE COUNT TO D_WORD COUNT   00004350
         LA    R3,STACK                                              @  00004360
         STD   FPR0,0(R3)                                               00004370
         LA    R3,8(R3)                                                 00004380
         BCT   R2,*-8                                                   00004390
         AGO   .M620                                                 @  00004400
.M720    LR    R2,R12              ADDRESS OF STACK                  @  00004410
         LA    R15,X'81'                                             @  00004420
         SLL   R15,24              SET PADDING CHAR FOR MVCL         @  00004430
         MVCL  R2,R14              CLEAR THE AREA                    @  00004440
.M620    ANOP                                                        @  00004450
*                                                                       00004460
.SYS32   ANOP                                                           00004470
NOCLR    ST    R13,4(R12)          BACK LINK OF NEW SAVE AREA           00004480
         ST    R12,8(R13)          FRWRD LINK OF OLD SAVE AREA          00004490
         LR    R13,R12             RESET SAVE AREA POINTER              00004500
*                                                                       00004510
         MVC   STACK-8(8),=CL8'   STACK'                                00004520
         MVC   0(8,R1),=CL8'HEAP    '                                   00004530
         LA    R12,STACK           GLOBAL (STACK BOTTOM) POINTER        00004540
         USING STACK,R12                                                00004550
         ST    R1,NEWPTR           SET PASCAL 'NEW' PONTER              00004560
*                                                                       00004570
*        CLEAR DISPLAY PSEUDO REGISTERS                                 00004580
*                                                                       00004590
         MVI   DISPLAY,X'FF'       SET DISP REGS TO '-1'                00004600
         MVC   DISPLAY+1(L'DISPLAY-1),DISPLAY                           00004610
         SPACE ,                                                     @  00004620
*                                                                    @  00004630
*        LINK PASCAL FILE VARIABLES TO FILE CONTROL                  @  00004640
*        BLOCKS IN THIS SUBMONITOR PROGRAM                           @  00004650
*                                                                    @  00004660
         L     AE,=A(FILLIST)                                        @  00004670
         L     AE,0(,AE)           POINT TO FIRST FILE CONTROL BLOCK @  00004680
         LA    AD,INPUT            POINT TO FIRST FILE VARIABLE      @  00004690
FILLP    ST    AD,FILPAS(AE)       SET LINK FROM HERE TO THERE       @  00004700
         ST    AE,PFILPTR(AD)      AND FROM THERE TO HERE            @  00004710
         MVI   PFILEOF(AD),TRUE    INITIALIZE EOF FLAG IN PASCAL     @  00004720
         MVI   PFILEOL(AD),TRUE    INITIALIZE EOL FLAG IN PASCAL     @  00004730
         LA    AD,PFILTSIZ(AD)     ADVANCE TO NEXT BUILT IN VRBL.    @  00004740
         L     AE,FILLNK(AE)       ADVANCE TO NEXT FILE CONTROL BLOCK@  00004750
         LTR   AE,AE               TEST FOR END OF LIST              @  00004760
         BNZ   FILLP               REPEAT                            @  00004770
         SPACE ,                                                        00004780
         L     R0,BUFSTORE         SIZE OF THE AREA TO BE RETURNED      00004790
         LA    R1,8(R1)            ADDRESS OF THE AREA TO BE RETURNED   00004800
         LR    R2,R1                                                    00004810
         SR    R2,R12              R2 <-- SPACE LEFT FOR THE STACK      00004820
         C     R2,USESTORE                                              00004830
         LA    R2,SPCERR           ERROR CODE FOR LACK OF SPACE         00004840
         BL    QUIT1                                                    00004850
*                                                                       00004860
*        FREE SOME SPACE FOR O/S FILE BUFFERS (4K/FILE !)               00004870
*                                                                       00004880
         FREEMAIN R,LV=(R0),A=(R1)                                      00004890
         L     R1,ALOSTORE+4       KEEP TRACK OF HOW MUCH CORE       #  00004900
         S     R1,BUFSTORE         TO RETURN TO THE O.S.             #  00004910
         ST    R1,ALOSTORE+4       AT END OF EXECUTION               #  00004920
         SPACE ,                                                        00004930
*                                                                       00004940
*        INITIALIZE FORTRAN ENVIRONMENT (IF THERE ARE FORTRAN           00004950
*        ROUTINES IN THE LOAD MODULE)                                   00004960
*                                                                       00004970
         AIF   (&SYSTEM).SYS325                                         00004980
         L     R15,=V(IBCOM#)     SEE IF FORTRAN ENVIRONMENT INCLUDED   00004990
         LTR   R15,R15                                                  00005000
         BZ    NOFORT                                                   00005010
         BAL   R14,IBCOMINI(R15)  IF SO CALL IBCOM# INIT ENTRY POINT    00005020
*                                                                       00005030
*        NOTE: THIS CALL SAVES R13 FOR IBCOMXIT, BE SURE TO HAVE        00005040
*        THE SAVE AREA CONSISTENT PRIOR TO CALLING IBCOMXIT             00005050
*                                                                       00005060
.SYS325  ANOP                                                           00005070
*                                                                       00005080
*        SET THE 'SPIE' TO TRAP PROGRAM  INTERRUPTS                     00005090
*                                                                       00005100
NOFORT   CLI   SPIEFLAG,X'00'      TEST IF SPIE TO BE ISSUED         #  00005110
         BNE   NOSPIE                                                #  00005120
         SPIE  MF=(E,PASSPIE)     OTHERWISE TRAP TO $PASINT          #  00005130
         ST    R1,OLDPICA         SAVE PRVIOUS PICA ADDRESS             00005140
NOSPIE   EQU   *                                                        00005150
*                                                                       00005160
*        SETUP DYN2STOR AREA                                            00005170
*                                                                       00005180
         L     R1,NEWPTR          TOP OF HEAP                           00005190
         S     R1,=A(DYN2LEN)     LESS SIZE OF DYN2                     00005200
         ST    R1,HEAPLIM         AND LIMIT                             00005210
         USING DYN2STOR,R1                                              00005220
         SR    R0,R0                                                    00005230
         ST    R0,DYNRUNC         CLEAR '# OF COUNTERS' FIELD           00005240
         LH    R2,OSPARML                                            #  00005250
         LTR   R2,R2                                                 #  00005260
         BZ    OSPARM1             JUMP IF NO PARM STRING            #  00005270
         SLR   R1,R2                                                 #  00005280
         SL    R1,=F'4'            ALLOCATE PARM STRING RECORD       #  00005290
         SRL   R1,3                FORCE TO DOUBLE-WORD BOUNDARY     #  00005300
         SLL   R1,3                                                  #  00005310
         ST    R2,0(,R1)           PUT STRING LENGTH IN RECORD       #  00005320
         L     R3,OSPARMAD                                           #  00005330
         BCTR  R2,0                                                  #  00005340
         EX    R2,OSPRMMVC         MOVE STRING INTO RECORD           #  00005350
         ST    R1,OSPRMPTR         SET POINTER TO RECORD             #  00005360
         B     OSPARM2                                               #  00005370
OSPRMMVC MVC   4(0,R1),0(R3)                                         #  00005380
OSPARM1  BCTR  R2,0                SET POINTER TO NIL                #  00005390
         ST    R2,OSPRMPTR                                           #  00005400
OSPARM2  ST    R1,NEWPTR                                             #  00005410
         DROP  R1                                                    #  00005420
*                                                                       00005430
*                                                                       00005440
*                                                                       00005450
*        DISABLE INTEGER OVERFLOW, EXPONENT UNDERFLOW AND               00005460
*        SIGNIFICANCE INTERRUPTS.                                       00005470
*                                                                       00005480
         SR    R6,R6                                                    00005490
         SPM   R6                  DISABLE ALL MASKABLE INTERRUPTS   @  00005500
         SPACE ,                                                        00005510
         MVC   FL1,=X'4E00000000000000'  INITIALIZE FIX-FLOAT-FIX       00005520
         MVC   FL2,=X'4E00000080000000'  CONVERSION VALUES              00005530
         MVC   FL3,=X'0000000000000000'                                 00005540
         MVC   FL4,=X'4F08000000000000'                                 00005550
         SPACE ,                                                        00005560
         MVC   CHKSUBS(L'CALLSUBS),CALLSUBS  INIT. RUN TIME CHECK AREA  00005570
         MVC   CLOCK,EXECTIME            SET THE ALARM CLOCK            00005580
         STIMER  TASK,$TIMEOUT,TUINTVL=CLOCK                            00005590
*                                                                       00005600
*        INITIALIZE DATE/TIME PREDEFINED VARIABLES                      00005610
*                                                                       00005620
         TIME  DEC                 GET TOD IN TU                        00005630
         ST    R1,DATESAV               PUT DATE IN WORK AREA           00005640
         CP    DATESAV+2(2),=PL2'59'                                    00005650
         BNH   LY                                                       00005660
         TM    DATESAV+1,1              LEAP YEAR?                      00005670
         BNZ   NLY                      NO                              00005680
         TM    DATESAV+1,X'12'          LEAP YEAR?                      00005690
         BNM   LY                       YES                             00005700
NLY      AP    DATESAV+2(2),=P'1'                                       00005710
LY       LA    R4,JAN                                                   00005720
         LA    R3,12                                                    00005730
         ZAP   MONTH(3),=P'0'                                           00005740
MDLP     AP    MONTH(3),=P'1000'       BUMP MONTH                       00005750
         CP    DATESAV+2(2),0(2,R4)    THIS MONTH?                      00005760
         BNH   MDEND                    BR IF SO                        00005770
         SP    DATESAV+2(2),0(2,R4)    TRY NEXT                         00005780
         LA    R4,2(R4)                                                 00005790
         BCT   R3,MDLP                                                  00005800
MDEND    L     R3,DATESAV                                               00005810
         N     R3,=X'00FF0000'          GET YEAR                        00005820
         O     R3,MONTH-2               INSERT MONTH                    00005830
         L     R4,DATESAV               GET DAY                         00005840
         SRL   R4,4                                                     00005850
         N     R4,=X'000000FF'                                          00005860
         OR    R3,R4                                                    00005870
         ST    R3,DATESAV               PREPARE TO REFORMAT DATE        00005880
         UNPK  DATESAV(9),DATESAV(5)                                    00005890
         MVC   PASDATE(10),=X'04050B06070B00010203'                  @  00005900
         TR    PASDATE(10),DATESAV      RE-ORDER THE CHARACTERS      @  00005910
*** QUICK YEAR-2000 FIX (MUSIC/SP ONLY): THE CORRECT 4-DIGIT YEAR
*** IS 4 CHARS AT LOWCORE ADDR X'3AC'+12 ($NOWDATE+12).
*** NOTE: STILL, ABOVE LEAP-YEAR CODING IS WRONG STARTING IN THE
*** YEAR 2100, SINCE THAT YEAR IS NOT A LEAP YEAR.
$NOWDATE EQU   X'3AC'
         CLC   =C'20',$NOWDATE+12
         BNE   Y2KB1        19XX OR MAYBE NOT MUSIC/SP: LEAVE AS IS
         MVC   PASDATE+6(2),$NOWDATE+12  FIX 1ST 2 DIGITS OF YEAR
Y2KB1    DS    0H
*** END OF YEAR-2000 FIX.
*                                                                       00005920
*        FIX TIME OF DAY STRING                                         00005930
*                                                                       00005940
         ST    R0,DATESAV                                               00005950
         UNPK  DATESAV(7),DATESAV(4)     CONVERT TO EBCDIC              00005960
         MVC   PASTIME(10),=X'00010A02030A04054040'                  @  00005970
         TR    PASTIME(8),DATESAV        RE-ORDER THE CHARACTERS     @  00005980
*                                                                       00005990
*        FINALLY CALL THE USER PROGRAM                                  00006000
*                                                                       00006010
         LA    1,STACK                                                  00006020
         L     LINK,=A($MAINBLK)                                        00006030
         BALR  RET,LINK                                                 00006040
*                                                                       00006050
*        CLOSE THE OPEN FILES AND RETURN TO OS                          00006060
*                                                                       00006070
         SR    R2,R2               RETURN CODE = ZERO  !                00006080
QUIT1    LA    R1,PXIT             CLOSE OPEN FILES / RETURN TO OS      00006090
         L     LINK,=A($PASCSP)                                         00006100
         BR    LINK               EXIT PASCAL PROGRAM                   00006110
*                                                                       00006120
*                                                                       00006130
*        GET THE NEXT INTEGER IN THE PARAMETER LIST                     00006140
*                                                                       00006150
         BXH   R1,R8,NOPARM        QUIT IF NO MORE CHARS             #  00006160
GETNUM   CLI   0(R1),C'='                                               00006170
         BNE   GETNUM-4           SKIP UNTIL THE FIRST '='              00006180
*                                                                       00006190
         SR    R3,R3                                                    00006200
         SR    R4,R4              CLEAR ACCUMULATOR                     00006210
*                                                                       00006220
NXTDIG   BXH   R1,R8,0(R7)         RETURN IF NO MORE CHARS           #  00006230
         CLI   0(R1),C'9'                                               00006240
         BHR   R7                 OR IF A NON DIGIT                     00006250
         IC    R3,0(R1)                                                 00006260
         SH    R3,=Y(C'0')                                              00006270
         BLR   R7                 IS ENCOUNTERED                        00006280
         MH    R4,=H'10'                                                00006290
         AR    R4,R3              OTHERWISE KEEP ACCUMULATING           00006300
         B     NXTDIG                                                   00006310
*                                                                       00006320
         EJECT                                                          00006330
****************************************************************        00006340
*                                                                       00006350
*        TABLE OF CALLS FOR RUN TIME CHECK ROUTINES. TO BE COPIED       00006360
*        ,EXACTLY AS IS, ONTO THE RUN TIME STACK.                       00006370
*                                                                       00006380
****************************************************************        00006390
*                                                                       00006400
CALSUB   DS    0F                                                       00006410
CALLINX  L     R15,INXCHK+8                                             00006420
         BR    R15                                                      00006430
         DC    A($INXCHK)                                               00006440
*                                                                       00006450
CALLRNG  L     R15,RNGCHK+8                                             00006460
         BR    R15                                                      00006470
         DC    A($RNGCHK)                                               00006480
*                                                                       00006490
CALLPRM  L     R15,PRMCHK+8                                             00006500
         BR    R15                                                      00006510
         DC    A($PRMCHK)                                               00006520
*                                                                       00006530
CALLPTR  L     R15,PTRCHK+8                                             00006540
         BR    R15                                                      00006550
         DC    A($PTRCHK)                                               00006560
*                                                                       00006570
CALLPTA  L     R15,PTACHK+8                                             00006580
         BR    R15                                                      00006590
         DC    A($PTACHK)                                               00006600
*                                                                       00006610
CALLSET  L     R15,SETCHK+8                                             00006620
         BR    R15                                                      00006630
         DC    A($SETCHK)                                               00006640
*                                                                       00006650
CALLSTK  L     R15,STKCHK+8                                             00006660
         BR    R15                                                      00006670
         DC    A($STKCHK)                                               00006680
*                                                                       00006690
CALLTRC  L     R15,TRACER+8                                          &  00006700
         BR    R15                                                   &  00006710
         DC    A($TRACER)                                            &  00006720
*                                                                       00006730
CALLSUBS EQU   CALSUB,*-CALSUB                                          00006740
*                                                                       00006750
         DROP  R10                                                      00006760
         EJECT                                                          00006770
*                                                                       00006780
BUFSTORE DC    A(IOBUFSZE)                                              00006790
REQSTORE DC    A(MINSTORE,MAXSTORE)                                     00006800
ALOSTORE DS    2A                                                       00006810
OSPARMS  DS    A                   ADDRESS OF O.S. PARAMETERS        #  00006820
OSPARMAD DC    A(0)                POINTER TO O.S. STRING            #  00006830
USESTORE DC    A(8000)                                                  00006840
OLDPICA  DC    A(1)                                                  #  00006850
EXECTIME DC    XL4'7FFFFFFF'       DEFAULT TIME LIMIT                   00006860
PASSPIE  SPIE  $PASINT,((1,7),9,11,12,15),MF=L                       #  00006870
OSPARML  DC    H'0'                LENGTH OF PARM STRING             #  00006880
DUMPFLAG DC    X'00'               X'FF' IF DUMP REQUESTED              00006890
SPIEFLAG DC    X'00'               X'FF' IF SPIE NOT TO BE ISSUED    #  00006900
SNAPFLAG DC    X'00'               X'FF' IF SNAPSHOT NOT TO BE CALLED#  00006910
*                                                                       00006920
DATESAV  DS    2F        # THESE LOCATIONS TO SUCCEED WITH NO GAPS   @  00006930
         DC    C'  :-'   #      (UNPACKING BUFFERS ETC.)             @  00006940
         DC    X'1900'   #                                              00006950
MONTH    DS    3X        #                                              00006960
JAN      DC    P'31,29,31,30,31,30,31,31,30,31,30,31'                   00006970
KWRDTAB  DC    AL1(0,1,4),C'STACK'                                   &  00006980
         DC    AL1(KWRDIOB-KWRDSTAK,1,4),C'IOBUF'                    &  00006990
         DC    AL1(KWRDDUMP-KWRDSTAK,0,3),C'DUMP'                    &  00007000
         DC    AL1(KWRDTIME-KWRDSTAK,1,3),C'TIME'                    &  00007010
         DC    AL1(KWRDCC-KWRDSTAK,0,1),C'CC'                        &  00007020
         DC    AL1(KWRDSPIE-KWRDSTAK,0,3),C'SPIE'                    &  00007030
         DC    AL1(KWRDSNAP-KWRDSTAK,0,3),C'SNAP'                    &  00007040
         DC    AL1(0,0,0)          END-OF-TABLE MARKER               &  00007050
*                                                                       00007060
         LTORG ,                                                        00007070
         EJECT                                                          00007080
*********************************************************************** 00007090
*                                                                       00007100
*                                                                       00007110
*        INTERRRUPT PROCCESSING FOR PASCAL PROGRAMS                     00007120
*                                                                       00007130
*        ONLY FIXED/FLOAT DIVISION BY ZERO AND EXPONENT OVERFLOW        00007140
*        INTERRUPTS ARE EXPECTED TO BE CAUGHT HERE, OTHER INTERRUPTS    00007150
*        IN GENERAL ARE CAUSED BY STACK/HEAP OVER FLOW OR A BAD I/O     00007160
*        FILE SPECIFICATION AND OR MISSING APPROPRIATE DD STATEMENTS.   00007170
*                                                                       00007180
*********************************************************************** 00007190
         USING $PASINT,R15                                              00007200
$PASINT  B     *+12                                                     00007210
         DC    X'7',C'$PASINT'                                          00007220
         MVC   INTDATA(12),0(R1)   SAVE ALL INTERRUPT DATA           *  00007230
         MVC   INTDATA+12(20),20(R1)                                 *  00007240
         STM   R3,R13,INTDATA+24                                     *  00007250
         MVC   INTDATA+68(8),12(R1)                                  *  00007260
         LA    R0,PASINT1          GO TO PASINT1 VIA THE CONTROL     #  00007270
         ST    R0,8(R1)            PROGRAM TO CANCEL SPIE EXIT       #  00007280
         BR    R14                                                   #  00007290
         DROP  R15                                                   #  00007300
*                                                                       00007310
PASINT1  BALR  R11,0               RE-ESTABLISH ADDRESSABILITY       #  00007320
         USING *,R11                                                 #  00007330
         L     R1,=A(OLDPICA)      CANCEL THE SPIE TRAP              #  00007340
         L     1,0(R1)             THAT IS IN EFFECT                 #  00007350
         SPIE  MF=(E,(1))                                            #  00007360
*                                                                    #  00007370
*        GET INTERRUPT CODE AND POINT TO THE APPROPRIATE ERROR MESSAGE  00007380
*                                                                       00007390
         SR    R4,R4                                                    00007400
         IC    R4,INTDATA+7        GET THE INTERRUPT CODE            #  00007410
         LA    R8,2000(R4)         SET THE RETURN CODE                  00007420
         IC    R4,MSGTBL(R4)                                            00007430
         LA    R3,MSGTXT+1(R4)     R3 --> ERROR MESSAGE                 00007440
         IC    R4,MSGTXT(R4)       R4 --> MESSAGE LENGTH                00007450
         L     R14,INTDATA+8       GET LOCATION OF INTERRUPT         #  00007460
         CLI   SPUSERSA,X'FF'      SEE IF INTERR. IN SP MODULE          00007470
         BE    NOTINSP                                                  00007480
*                                                                       00007490
*        IF INTERRUPTION OCCURED WITHIN THE '$PASCSP' ROUTINE PATCH UP  00007500
*        A SAVE AREA TO POINT TO CALLERS SAVE AREA FOR A MEANINGFULL    00007510
*        ERROR MESSAGE.                                                 00007520
*                                                                       00007530
         L     R5,=A(SPUSERSA)              GET USER REGS               00007540
         LM    R12,R15,(R12-R1)*4(R5)       GET IMPORTANT VALUES        00007550
         LR    R10,R15                      SET PROC ENTRY POINT ADR    00007560
         ST    R13,FAKESA+4                 SET SAVE AREA CHAIN         00007570
         STM   R14,R15,FAKESA+12            SET RETURN ADR FIELD        00007580
         LA    R13,FAKESA                                               00007590
         L     R14,INTDATA+8       RESET INTERRUPT LOCATION          #  00007600
         B     KNOWNPRC                                                 00007610
*                                                                       00007620
*        SEE IF R10 POINTS TO THE BEGINING OF A PROC.                   00007630
*                                                                       00007640
NOTINSP  L     R12,=A(ALOSTORE)        GET THE STACK ADDRESS            00007650
         L     R12,0(R12)                                               00007660
         LA    R12,STACK-DYNSTORE(R12) POINT TO BASE OF THE STACK       00007670
         LA    R10,0(R10)                                               00007680
*        C     R10,=A($PASCSP)                                       #  00007690
*        BL    FIXENTRY                IF R10 IS OUT OF BOUND, SKIP  #  00007700
*        C     R10,=A($MAINBLK)                                      #  00007710
*        BH    FIXENTRY                                              #  00007720
         LH    R5,0(R10)               R10 IS WITHIN BOUND, SEE IF      00007730
         CH    R5,=XL2'47F0'           IT POINTS TO A PROC ENTRY POINT  00007740
         BNE   FIXENTRY                                                 00007750
         CR    R13,R12                 SEE IF SAVE AREA PTR IS          00007760
         BL    FIXENTRY                WITHIN BOUNDS                    00007770
         C     R13,NEWPTR-STACK(R12)                                    00007780
         BH    FIXENTRY                                                 00007790
         C     R10,16(R13)             CONSISTANCY CHECK                00007800
         BE    KNOWNPRC                THIS IS A USER PROCEDURE ?       00007810
*                                                                       00007820
*        R10 POINTS TO NOWHERE, FAKE A PROCEDURE HEADING                00007830
*                                                                       00007840
FIXENTRY ST    R12,4+FAKESA            CHAIN THE FAKE SAVE AREA         00007850
         L     R5,16(R12)              POINT TO $MAINBLK ENTRY POINT    00007860
         ST    R5,12+FAKESA            SET RET. ADR. FROM FAKE PROC     00007870
         LA    R10,FAKEPROC            POINT TO THE ENTRY OF FAKEPROC   00007880
         AR    R14,R10                 ALSO SET THE ERROR LOCATION ADR  00007890
         LA    R13,FAKESA                                               00007900
*                                                                       00007910
*        THIS IS THE ENTRY TO A FAKE PROC TO BE USED IF                 00007920
*        NO MEANINGFULL PROC IS FOUND AFTER AN INTRRUPT                 00007930
*                                                                       00007940
KNOWNPRC L     R15,=A($CHKMSG)                                       &  00007950
         BR    R15                GO TO PRINT ERROR MESSAGE             00007960
*                                                                       00007970
         USING *,R15                                                    00007980
FAKEPROC B     *+12                                                     00007990
         DC    AL1(7),C'UNKNOWN'                                        00008000
*                                                                       00008010
FAKESA   DC    6F'0'                                                    00008020
*                                                                    #  00008030
         DC    CL8'INTDATA'                                          #  00008040
INTDATA  DC    19F'0'              INTERRUPT DATA                    &  00008050
*                                                                       00008060
MSGTBL   DC    AL1(0,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1)   00008070
         DC    AL1(IMSG2,IMSG1,IMSG2,IMSG3,IMSG1,IMSG1,IMSG2)           00008080
*                                                                       00008090
MSGTXT   DS    0C                                                       00008100
IM1      DC    AL1(L'IMSG1),C' PROGRAM INTERRUPT, SEE RETURN CODE.'     00008110
IMSG1    EQU   IM1-MSGTXT,*-IM1-1                                       00008120
IM2      DC    AL1(L'IMSG2),C' DIVISION BY ZERO '                       00008130
IMSG2    EQU   IM2-MSGTXT,*-IM2-1                                       00008140
IM3      DC    AL1(L'IMSG3),C' EXPONENT OVERFLOW '                      00008150
IMSG3    EQU   IM3-MSGTXT,*-IM3-1                                       00008160
         DC    C'    '                                                  00008170
         DROP  R11                                                      00008180
*                                                                       00008190
***************************************************************         00008200
*                                                                       00008210
*        END OF INTERRUPT HANDLING ROUTINE                              00008220
*                                                                       00008230
***************************************************************         00008240
         EJECT                                                          00008250
         AIF   (&SYSTEM).SYS900                                         00008260
*                                                                       00008270
*      $TRACER IS CALLED FROM THE PASCAL CODE IN ORDER TO               00008280
*      ENTER A CONTROL TRANSFER INTO THE TRANSFER TABLE                 00008290
*      AND (IF DESIRED) PRINT THIS TRANSFER.                            00008300
*                                                                       00008310
*      CALLING CODE:                                                    00008320
*                       BAL 14,TRACER                                   00008330
*                       DC  AL2( PARAMETER )                            00008340
*                                                                       00008350
*      THE ROUTINE 'TRACER' IS ONE OF THE CHECK ROUTINES                00008360
*      INCLUDED ON THE PASCAL RUN STACK.  ITS STRUCTURE IS              00008370
*      SIMPLY:                                                          00008380
*               TRACER  L    15,=V($TRACER)                             00008390
*                       BR   15                                         00008400
*                                                                       00008410
*      THE HALFWORD PARAMETER TO TRACER HAS THE FOLLOWING               00008420
*      INTERPRETATIONS:                                                 00008430
*                                                                       00008440
*      1.  POSITIVE VALUE IS TAKEN TO MEAN A BRANCH TO THIS             00008450
*          ADDRESS RELATIVE TO THE START OF THE CURRENT                 00008460
*          PROCEDURE (WHOSE BASE ADDRESS IS IN REG 10).                 00008470
*          THIS IS THE USAGE FOR ALL BRANCHES INTERNAL TO A             00008480
*          PROCEDURE.                                                   00008490
*                                                                       00008500
*      2.  ZERO VALUE IMPLIES A PROCEDURE RETURN TO THE                 00008510
*          ADDRESS IN REG. 0.  NOTE: THIS IS ALSO THE USAGE             00008520
*          FOR A GOTO THAT EXITS THE CURRENT PROCEDURE.                 00008530
*                                                                       00008540
*      3.  NEGATIVE VALUE IMPLIES A PROCEDURE CALL TO THE               00008550
*          ABSOLUTE ADDRESS WHICH IS HELD IN A LOCAL V-TYPE             00008560
*          ADDRESS CONSTANT WITHIN THE CURRENT PROCEDURE.               00008570
*          THE ADDRESS CONSTANT'S OFFSET WITHIN THE CURRENT             00008580
*          PROCEDURE IS THE NEGATIVE OF THE PARAMETER VALUE.            00008590
*                                                                       00008600
         DROP  ,                                                        00008610
         USING $TRACER,R15                                              00008620
$TRACER  STM   R0,R2,TRACESA+4                                          00008630
         L     R2,TRPTR           LOAD AND ADVANCE                      00008640
         LA    R2,8(,R2)          THE CYCLIC POINTER                    00008650
         N     R2,=F'127'                                               00008660
         ST    R2,TRPTR                                                 00008670
         LH    R1,0(,R14)         LOAD AND TEST PARAMETER               00008680
         LTR   R1,R1                                                    00008690
         BNP   TRACE4             JUMP IF PROC. CALL/RETURN             00008700
         LA    R1,0(R1,R10)       R1 = DESTINATION ADDRESS              00008710
TRACE2   ST    R1,TRTABL(R2)      PUT IN TABLE                          00008720
         ST    R14,TRTABL+4(R2)   PUT ORIGIN ADDRESS+4 IN TABLE         00008730
         L     R0,TRLINES                                               00008740
         BCT   R0,TRACE6          JUMP TO PRINT TRANSFER                00008750
TRRET    BC    0,TRACE3                                                 00008760
         LR    R14,R1                                                   00008770
         LM    R0,R2,TRACESA+4                                          00008780
         BR    R14                                                      00008790
TRACE3   NI    TRRET+1,X'0F'      CLEAR BRANCH CONDITION                00008800
         LA    R14,2(,R14)                                              00008810
         ST    R1,TRACESA                                               00008820
         LM    R15,R2,TRACESA                                           00008830
         BR    R15                JUMP TO CALLED PROCEDURE              00008840
TRACE4   BZ    TRACE5             JUMP IF PROC. RETURN                  00008850
         OI    TRRET+1,X'F0'      FORCE LATER JUMP TO TRACE3            00008860
         LPR   R1,R1              MAKE OFFSET POSITIVE                  00008870
         L     R1,0(R1,R10)       LOAD THE ADDRESS CONSTANT             00008880
         O     R1,TRACEFL1        SET FLAG BYTE (FOR CALL)              00008890
         B     TRACE2                                                   00008900
TRACE5   LR    R1,R0                                                    00008910
         LA    R1,0(,R1)          CLEAR HIGH BYTE                       00008920
         O     R1,TRACEFL2        SET FLAG BYTE (FOR RETURN)            00008930
         B     TRACE2                                                   00008940
TRACE6   ST    R0,TRLINES         STORE UPDATED LINE COUNT              00008950
         L     R15,=A(TRPR1)                                            00008960
         BALR  R14,R15            CALL PRINT ROUTINE                    00008970
         USING *,R14                                                    00008980
         L     R15,=A($TRACER)    RESTORE BASE REG.                     00008990
         DROP  R14                                                      00009000
         L     R14,TRTABL+4(R2)   RESTORE RETURN REG                    00009010
         B     TRRET                                                    00009020
*                                                                       00009030
*      TRDUMP IS CALLED IN CASE OF ABNORMAL PROGRAM TERMINATION         00009040
*      TO PRINT OUT THE CONTENTS OF THE TRACE TABLE.                    00009050
*                                                                       00009060
TRDUMP   LR    R10,R15                                                  00009070
         DROP  ,                                                        00009080
         USING TRDUMP,R10                                               00009090
         USING STACK,GBR                                                00009100
         TM    TRPTR,X'80'                                              00009110
         BOR   R14                RETURN IF TABLE IS EMPTY              00009120
         ST    R14,TRDUMPSV       SAVE RETURN ADDRESS                   00009130
         L     R15,=A($PASCSP)                                          00009140
         LA    AD,OUTPUT                                                00009150
         L     AE,=A(FILOUT)                                            00009160
         TM    FILOPN(AE),WRITEOPN                                      00009170
         BNZ   TRDUMP1            JUMP IF OUTPUT FILE OPEN              00009180
         LA    R1,PREW            FORCE THE FILE TO BE OPEN             00009190
         B     TRDUMP2                                                  00009200
TRDUMP1  LA    R1,PSKP            DOUBLE-SPACE                          00009210
         LA    R2,2                                                     00009220
TRDUMP2  BALR  R14,R15                                                  00009230
         LA    R2,TRDUMPMS                                              00009240
         LA    R3,L'TRDUMPMS                                            00009250
         LR    R4,R3                                                    00009260
         LA    R1,PWRS            PUT OUT HEADING                       00009270
         BALR  R14,R15                                                  00009280
         LA    R6,16              LOAD NO. OF TABLE ENTRIES             00009290
TRDUMP3  L     R2,TRPTR                                                 00009300
         LA    R2,8(,R2)                                                00009310
         N     R2,=F'127'         CYCLICALLY ADVANCE POINTER            00009320
         ST    R2,TRPTR                                                 00009330
         LA    R15,TRPR1                                                00009340
         L     R1,TRTABL(R2)      LOAD TABLE ENTRY                      00009350
         LTR   R1,R1              TEST IF EMPTY                         00009360
         BZ    *+6                                                      00009370
         BALR  R14,R15            PRINT NON-EMPTY ENTRY                 00009380
         XC    TRPRFST(4),TRPRFST FORCE NEXT ITEM ON NEW LINE           00009390
         BCT   R6,TRDUMP3                                               00009400
         L     R14,TRDUMPSV                                             00009410
         BR    R14                RETURN                                00009420
*                                                                       00009430
*      TRPR1 OUTPUTS ONE ENTRY IN THE TRACE TABLE.  THE INDEX           00009440
*      OF THIS ENTRY IS GIVEN BY REG 2.                                 00009450
*                                                                       00009460
         DROP  ,                                                        00009470
         USING TRPR1,R15                                                00009480
         USING STACK,GBR                                                00009490
TRPR1    STM   R0,R15,TRPRSAV                                           00009500
         LR    R10,R15                                                  00009510
         USING TRPR1,R10                                                00009520
         DROP  R15                                                      00009530
         LA    R3,TRTABL(R2)                                            00009540
         MVC   TRPRDLIM(3),=C' ->'                                   &  00009550
         MVC   TRPRTAG(1),0(R3)                                      &  00009560
         LR    R6,R2                                                    00009570
         SR    R0,R0                                                    00009580
         TM    0(R3),X'FF'                                              00009590
         BZ    TRPR3              JUMP FOR NORMAL BRANCH                00009600
         BM    TRPR2              JUMP IF PROC. RETURN                  00009610
         MVC   TRPRMSG(10),=C' CALL FROM'                               00009620
         LA    R0,10                                                    00009630
         B     TRPR3                                                    00009640
TRPR2    MVC   TRPRMSG(12),=C' RETURN FROM'                             00009650
         LA    R0,12                                                    00009660
TRPR3    STH   R0,TRPRLEN         SAVE STRING LENGTH SO FAR             00009670
         L     R1,TRTABL+4(R6)    LOAD ORIGIN ADDRESS                   00009680
         SH    R1,=H'4'                                                 00009690
         LA    R15,TRLN                                              &  00009700
         BALR  R5,R15              CONVERT TO TEXT                   &  00009710
         LTR   R0,R0              TEST RETURN CODE                      00009720
         BNZ   TRPR6              JUMP IF INCOMPLETE INFO.              00009730
         TM    TRPRTAG,X'FF'      TEST TRANSFER TYPE                    00009740
         BZ    TRPR4              JUMP IF NORMAL BRANCH                 00009750
         MVC   TRPRDLIM(3),=C' TO'                                      00009760
TRPR4    LH    R1,TRPRLEN                                               00009770
         LA    R4,TRPRMSG(R1)                                           00009780
         ALR   R1,R3              COMPUTE NEW TEXT LENGTH               00009790
         EX    R3,TRPRMVC1        CATENATE STRINGS                      00009800
         LA    R1,3(,R1)                                                00009810
         ALR   R4,R3                                                    00009820
TRPR4A   MVC   0(3,R4),TRPRDLIM   CATENATE 'TO' SYMBOL                  00009830
         STH   R1,TRPRLEN                                               00009840
         L     R1,TRTABL(R6)                                            00009850
         LA    R1,0(,R1)                                                00009860
         TM    TRPRTAG,X'FF'      TEST IF PROC. CALL                    00009870
         BNO   *+8                SKIP NEXT ACTION IF NOT A CALL        00009880
         ST    R1,TRLNLAST        TELL TRLN ABOUT THE NEW PROC.         00009890
         LA    R15,TRLN                                              &  00009900
         BALR  R5,R15              CONVERT IT TO TEXT                &  00009910
         LTR   R0,R0              TEST RETURN CODE                      00009920
         BNZ   TRPR9                                                    00009930
         TM    TRPRTAG,X'FF'      TEST TRANSFER TYPE                    00009940
         BZ    TRPR5              JUMP IF NORMAL BRANCH                 00009950
         LR    R3,R4              FORCE FULL MESSAGE TEXT               00009960
TRPR5    LH    R1,TRPRLEN                                               00009970
         LA    R4,TRPRMSG(R1)                                           00009980
         ALR   R1,R3                                                    00009990
         EX    R3,TRPRMVC1        CATENATE STRINGS                      00010000
         LA    R1,2(,R1)                                                00010010
         ALR   R4,R3                                                    00010020
         MVC   0(2,R4),=C'; '                                           00010030
         STH   R1,TRPRLEN                                               00010040
         B     TRPR10             GO AND PRINT MESSAGE                  00010050
TRPR6    TM    TRPRTAG,X'FF'                                            00010060
         BZ    TRPR4              (SHOULD NOT OCCUR)                    00010070
         CH    R0,=H'4'                                                 00010080
         BH    TRPR7              JUMP IF NO INFO AT ALL                00010090
         LA    R2,6(,R2)          OTHERWISE, JUST USE                   00010100
         SH    R4,=H'6'           THE PROCEDURE NAME                    00010110
         LR    R3,R4                                                    00010120
         B     TRPR4-6                                                  00010130
TRPR7    LH    R1,TRPRLEN         IF NO INFO, WE WONT INCLUDE           00010140
         SH    R1,=H'3'           THE ORIGIN IN THE MESSAGE             00010150
         LA    R4,TRPRMSG-2(R1)                                         00010160
         B     TRPR4A                                                   00010170
TRPR9    TM    TRPRTAG,X'FF'                                            00010180
         BZ    TRPR5              (SHOULD NOT OCCUR)                    00010190
         LA    R2,5(,R2)          JUST USE THE PROCEDURE                00010200
         SH    R4,=H'5'           NAME PART                             00010210
         LR    R3,R4                                                    00010220
         B     TRPR5                                                    00010230
TRPR10   L     R15,=A($PASCSP)                                          00010240
         L     AE,=A(FILOUT)                                            00010250
         LA    AD,OUTPUT                                                00010260
         TM    FILOPN(AE),WRITEOPN                                      00010270
         BNZ   TRPR11                                                   00010280
         LA    R1,PREW                                                  00010290
         BALR  R14,R15            FORCE FILE TO BE OPEN                 00010300
         B     TRPR12A                                                  00010310
TRPR11   CLC   FILBUF(16,AE),TRPRFST   TEST IF FILE HAS BEEN USED       00010320
         BNE   TRPR12             SINCE LAST CALL TO TRPR               00010330
         LH    R1,TRPRFEND                                              00010340
         STH   R1,FILEND(AE)      RESET FILE ATTRIBUTES                 00010350
         SH    R1,FILPTR(AE)                                            00010360
         CH    R1,TRPRLEN         SEE IF ENOUGH ROOM ON LINE            00010370
         BH    TRPR13             JUMP IF NOT                           00010380
TRPR12   LA    R1,PWLN                                                  00010390
         BALR  R14,R15            FORCE NEW LINE                        00010400
TRPR12A  LA    R1,PWRS            PUT OUT A SPECIAL                     00010410
         LA    R2,=C' *TRACE:'    MARGIN MESSAGE TO                     00010420
         LA    R3,8               FLAG TRACE OUTPUT                     00010430
         LR    R4,R3                                                    00010440
         BALR  R14,R15                                                  00010450
TRPR13   LH    R3,TRPRLEN                                               00010460
         LR    R4,R3                                                    00010470
         LA    R2,TRPRMSG                                               00010480
         LA    R1,PWRS                                                  00010490
         BALR  R14,R15            OUTPUT TRACE MESSAGE                  00010500
         LH    R1,FILEND(AE)                                            00010510
         STH   R1,TRPRFEND        SAVE FILE STATUS                      00010520
         LH    R1,FILPTR(AE)                                            00010530
         BCTR  R1,0               FLAG LINE AS 'OVER-FULL'              00010540
         STH   R1,FILEND(AE)                                            00010550
         MVC   TRPRFST(16),FILBUF(AE)   SAVE COPY OF FILE STATE         00010560
         LM    R0,R15,TRPRSAV                                           00010570
         BR    R14                                                      00010580
         SPACE 2                                                        00010590
*                                                                       00010600
*     TRLN CONVERTS AN ABSOLUTE ADDRESS IN THE CODE AREA INTO A         00010610
*     TEXT STRING THAT SPECIFIES THE SOURCE LINE NUMBER AND THE         00010620
*     PROCEDURE/FUNCTION NAME.  FOR EXAMPLE, THE FOLLOWING STRING       00010630
*     IS A POSSIBLE RESULT:                                             00010640
*            ' 276 IN TREE_SEARCH '                                     00010650
*     IF THE LINE NO. IS UNAVAILABLE, A QUESTION MARK APPEARS IN        00010660
*     THE MESSAGE.  IF THE PROCEDURE NAME IS UNAVAILABLE (BECAUSE       00010670
*     THE PROCEDURE WAS NOT GENERATED BY PASCAL), THE TEXT STRING       00010680
*     WILL BE ' ? IN UNKNOWN PROC. '.                                   00010690
*                                                                       00010700
*     INPUT PARAMETER:  REG 1 MUST HOLD THE CODE ADDRESS.               00010710
*                                                                       00010720
*     OUTPUT PARAMETERS:                                                00010730
*          REG. 2 = ADDRESS OF TEXT STRING,                             00010740
*          REG. 4 = LENGTH OF TEXT STRING,                              00010750
*          REG. 3 = LENGTH OF TEXT STRING IF PROC. NAME IS OMITTED,     00010760
*          REG. 0 = RETURN CODE (0 MEANS O.K., 4 MEANS LINE NUMBER      00010770
*                   APPEARS AS '?', 8 MEANS UNKNOWN PROCEDURE).         00010780
*                                                                       00010790
         DROP  ,                                                        00010800
         USING TRLN,R15                                                 00010810
TRLN     LA    R1,0(,R1)          CLEAR HIGH BYTE                       00010820
         L     R2,TRLNLAST        BASE ADDRESS OF LAST PROC.            00010830
         LR    R0,R1                                                    00010840
         SR    R0,R2              TEST IF CURRENT ADDRESS IS WITHIN     00010850
         BM    TRLN0              THIS LAST PROC.                       00010860
         BZ    TRLN4                                                    00010870
         CH    R0,=H'8192'                                              00010880
         BNL   TRLN0                                                    00010890
         LH    R0,10(,R2)         THIS SHOULD BE THE CODE SIZE          00010900
         CL    R0,=F'8192'        OF THE PROCEDURE                      00010910
         BNL   TRLN0                                                    00010920
         AR    R0,R2                                                    00010930
         CR    R1,R0                                                    00010940
         BL    TRLN4              PASSED ALL CHECKS                     00010950
*                                                                       00010960
TRLN0    LR    R2,R1                                                    00010970
         N     R2,TRLNMSK         FORCE DOUBLE-WORD ALIGNMENT           00010980
         LH    R0,TRLNPROL        LOAD PROC. START PATTERN              00010990
         LA    R3,1024            SET 8K SEARCH LIMIT                   00011000
TRLN1    CH    R0,0(,R2)                                                00011010
         BNE   TRLN2              JUMP IF MISMATCH                      00011020
         CLC   2(3,R2),=X'F00C07'                                       00011030
         BE    TRLN6              JUMP IF MATCH FOR PROC. START         00011040
         CLC   2(3,R2),=X'F02C27'                                       00011050
         BE    TRLN6              JUMP IF MATCH FOR $MAINBLK            00011060
TRLN2    SH    R2,=H'8'                                                 00011070
         BCT   R3,TRLN1                                                 00011080
TRLN3    LA    R2,=C' ? IN UNKNOWN PROC. '                              00011090
         LA    R4,20                                                    00011100
         LA    R3,3                                                     00011110
         LA    R0,8                                                     00011120
         BR    R5                                                       00011130
TRLN4    CLC   0(5,R2),=X'47F0F00C07'                                   00011140
         BE    TRLN5              DOUBLE-CHECK FOR STANDARD ENTRY CODE  00011150
         CLC   0(5,R2),=X'47F0F02C27'                                   00011160
         BNE   TRLN3                                                    00011170
TRLN5    ST    R2,TRLNLAST        SAVE PROC. ADDR. FOR NEXT TIME        00011180
TRLN6    LH    R3,10(R2)                                                00011190
         CL    R3,=F'8192'                                              00011200
         BNL   TRLN10             JUMP IF NO LINE NUM TABLE PROVIDED    00011210
         ALR   R3,R2                                                    00011220
         MVC   TRLNMSG+10(12),4(R3)                                     00011230
         MVC   TRLNMSG(10),TRLNPAT SET UP EDIT PATTERN                  00011240
         SLR   R1,R2                                                    00011250
         SRA   R1,1               CONVERT TO HALFWORD OFFSET            00011260
         LH    R2,2(,R3)                                                00011270
         SR    R0,R0                                                    00011280
TRLN7    IC    R0,16(,R3)         LOAD ENTRY IN LINE NUM TABLE          00011290
         CH    R0,=H'250'                                               00011300
         BL    TRLN8              JUMP IF NOT ESCAPE MODE ENTRY         00011310
         CH    R0,=H'255'                                               00011320
         BE    TRLN9              EXIT IF END OF TABLE FLAG             00011330
         IC    R0,17(,R3)                                               00011340
         SLA   R0,8                                                     00011350
         SR    R1,R0              PROCESS 1ST BYTE OF LARGE ENTRY       00011360
         SR    R0,R0                                                    00011370
         IC    R0,18(,R3)         BUT TREAT LOW BYTE AS NORMAL ENTRY    00011380
         LA    R3,2(,R3)                                                00011390
TRLN8    LA    R3,1(,R3)                                                00011400
         LA    R2,1(,R2)                                                00011410
         SR    R1,R0                                                    00011420
         BP    TRLN7                                                    00011430
         BCTR  R2,0               CORRECT OVERSHOOT OF LINE NUM         00011440
TRLN9    CVD   R2,TRLNPINT                                              00011450
         LA    R1,TRLNMSG+5                                             00011460
         EDMK  TRLNMSG(6),TRLNPINT+5                                    00011470
         BCTR  R1,0                                                     00011480
         LR    R2,R1                                                    00011490
         LA    R4,TRLNMSG+22                                            00011500
         BCTR  R4,0               REMOVE                                00011510
         CLI   0(R4),C' '         TRAILING                              00011520
         BE    *-6                BLANKS FROM                           00011530
         LA    R4,1(,R4)          PROCEDURE NAME                        00011540
         SLR   R4,R1                                                    00011550
         LA    R3,TRLNMSG+6                                             00011560
         SLR   R3,R1                                                    00011570
         SR    R0,R0                                                    00011580
         BR    R5                                                       00011590
TRLN10   MVC   TRLNMSG(6),=C' ? IN '                                    00011600
         MVC   TRLNMSG+6(7),5(R2)                                       00011610
         LA    R2,TRLNMSG                                               00011620
         LA    R3,3                                                     00011630
         LA    R4,13                                                    00011640
         LA    R0,4                                                     00011650
         BR    R5                                                       00011660
*                                                                       00011670
TRTABL   DC    32F'0'              SPACE FOR 16 CONTROL TRANSFERS       00011680
TRPTR    DC    F'-8'                                                    00011690
TRACESA  DS    4F                                                       00011700
TRACEFL1 DC    XL4'FF000000'                                            00011710
TRACEFL2 DC    XL4'FE000000'                                            00011720
TRLINES  DC    F'1'               => NO TRACE OUTPUT                    00011730
TRDUMPSV DS    F                                                        00011740
TRDUMPMS DC    C'0*  TRACE OF LAST 16 CONTROL TRANSFERS'                00011750
TRPRMVC1 MVC   0(*-*,R4),0(R2)                                          00011760
TRPRSAV  DS    16F                                                      00011770
TRPRLEN  DS    1H                                                       00011780
TRPRFEND DS    1H                                                       00011790
TRPRFST  DS    16X                                                      00011800
TRPRTAG  DS    1X                                                       00011810
TRPRDLIM DS    3C                                                       00011820
TRPRMSG  DS    64C                                                      00011830
TRLNPINT DS    D                                                        00011840
TRLNMSK  DC    X'00FFFFF8'                                              00011850
TRLNPROL DC    X'47F0'                                                  00011860
TRLNMSG  DC    23C' '                                                   00011870
TRLNLAST DC    A($MAINBLK)                                              00011880
TRLNPAT  DC    X'402020202120',C' IN '                                  00011890
         LTORG                                                          00011900
         AGO   .USE900                                                  00011910
.SYS900  ANOP                                                           00011920
*                                                                       00011930
*                                                                    &  00011940
*        - DUMMY VERSION FOR COMPACT SP                              &  00011950
*                                                                    &  00011960
         USING $TRACER,R15                                           &  00011970
$TRACER  STM   R0,R1,TRACESA+4                                       &  00011980
         LH    R1,0(,R14)          LOAD PARAMETER                    &  00011990
         LTR   R1,R1               TEST FOR TRANSFER TYPE            &  00012000
         BNP   TRACE4                                                &  00012010
         LA    R14,0(R1,R10)       OFFSET WITHIN CUR. PROC.          &  00012020
         L     R1,TRACESA+8                                          &  00012030
         BR    R14                                                   &  00012040
TRACE4   BZ    TRACE5                                                &  00012050
         LPR   R1,R1                                                 &  00012060
         LA    R14,2(,R14)         COMPUTE RETURN ADDRESS            &  00012070
         L     R0,0(R1,R10)        LOAD PROC. ADDRESS                &  00012080
         ST    R0,TRACESA                                            &  00012090
         LM    R15,R1,TRACESA      LOAD AFFECTED REG.S               &  00012100
         BR    R15                 GOTO PROCEDURE                    &  00012110
TRACE5   LR    R14,R0              LOAD RETURN ADDRESS               &  00012120
         BR    R14                 AND GOTO IT                       &  00012130
TRACESA  DS    3F                                                    &  00012140
*                                                                       00012150
.USE900  ANOP                                                           00012160
         DROP ,                                                         00012170
         USING $RNGCHK,R15                                              00012180
$RNGCHK  STM   R0,R15,CHKSVALL                                       &  00012190
         BAL   R3,BADRNG                                             &  00012200
         DC    AL2(26,SUBERR),C' SUBRANGE VALUE OUT OF RANGE '       &  00012210
         USING $INXCHK,R15                                              00012220
$INXCHK  STM   R0,R15,CHKSVALL                                       &  00012230
         BAL   R3,BADRNG                                             &  00012240
         DC    AL2(23,INXERR),C' INDEX VALUE OUT OF RANGE '          &  00012250
         USING $PRMCHK,R15                                              00012260
$PRMCHK  STM   R0,R15,CHKSVALL                                       &  00012270
         BAL   R3,BADRNG                                             &  00012280
         DC    AL2(28,PARERR),C' ACTUAL PARAMETER OUT OF RANGE '     &  00012290
*                                                                       00012300
*                                                                       00012310
*        POINTER CHECK ROUTINE                                          00012320
*                                                                       00012330
*                                                                       00012340
         USING $PTACHK,R15                                              00012350
$PTACHK  SR    R0,R0                                                    00012360
         BCTR  R0,0     R0 <-- '-1'                                     00012370
         CR    R0,R2                                                    00012380
         BER   R14      NIL VALUE BEING ASSIGNED                        00012390
*                                                                       00012400
         BALR  R15,0    GO TO NEXT ROUTINE TO CNTINUE CHECKING          00012410
*                                                                       00012420
         USING $PTRCHK,R15                                              00012430
         USING STACK,R12                                             &  00012440
$PTRCHK  LM    R0,R1,NEWPTR   LOAD POINTER RANGE                        00012450
         CR    R2,R0    CHECK LOWER BOUND                               00012460
         BL    BADPTR                                                   00012470
         CR    R2,R1    CHECK UPPER BOUND                               00012480
         BNHR  R14      IF WITHIN BOUNDS, RETURN                        00012490
BADPTR   STM   R0,R15,CHKSVALL SAVE IN CASE OF RETURN                   00012500
         BAL   R3,RUNMSG                                             &  00012510
         DC    AL2(28,PTRERR),C' POINTER VALUE OUT OF RANGE '        &  00012520
*                                                                       00012530
*                                                                       00012540
*        SET MEMBER CHECK ROUTINE                                       00012550
*                                                                       00012560
         USING $SETCHK,R15                                              00012570
$SETCHK  STM   R0,R15,CHKSVALL    SAVE IN CASE OF RETURN                00012580
         BAL   R3,RUNMSG                                             &  00012590
         DC    AL2(28,SETERR),C' SET MEMBER(S) OUT OF RANGE '        &  00012600
*                                                                       00012610
*        STACK/HEAP INTERFERENCE ERROR                                  00012620
*                                                                       00012630
         USING $STKCHK,R15                                              00012640
$STKCHK  BAL   R3,RUNMSG                                             &  00012650
         DC    AL2(22,STKERR),C' STACK/HEAP COLLISION '              &  00012660
*                                                                       00012670
*        'TIME OUT' ENTRY POINT                                         00012680
*                                                                       00012690
*        ASSUMES THAT R10 POINTS TO THE CURR PROC ENTRY POINT           00012700
*        THIS MAY NOT BE TRUE UNDER MFT OR SOME OTHER VARIANTS          00012710
*        OF THE OPERATING SYSTEM. ( 'STIMER' PECULIARITY )              00012720
*                                                                       00012730
$TIMEOUT  BALR  R15,0                                                   00012740
         USING *,R15                                                    00012750
         L     R12,=A(ALOSTORE)   RESTORE STACK POINTER IN CASE !       00012760
         L     R12,0(R12)                                               00012770
         LA    R12,STACK-DYNSTORE(R12)                                  00012780
         LR    R13,R12                                                  00012790
*                                                                       00012800
         CLI   SPUSERSA,X'FF'     SEE IF TIMER WENT OFF IN '$PASCSP'    00012810
         BE    TIMEOUT2                                                 00012820
         LM    R1,R14,SPUSERSA     IF SO, RESTORE REGS ACCORDINGLY      00012830
         B     TIMEOUT4                                                 00012840
*                                                                       00012850
TIMEOUT2 L     R1,16          LOAD CVT ADDR                          #  00012860
         L     R1,0(,R1)      LOAD TCB WORDS ADDR                    #  00012870
         L     R1,4(,R1)      ADDR OF CURRENT TCB                    #  00012880
         L     R1,120(,R1)    ADDR OF TQE                            #  00012890
         L     R1,28(,R1)     ADDR OF RB                             #  00012900
         L     R1,20(,R1)     WORD2 OF OLD PSW (AT LAST)             #  00012910
         LA    R14,0(,R1)     SET ERROR LOC TO THIS ADDRESS          #  00012920
TIMEOUT3 C     R10,16(R13)        GO DOWN THE CALL CHAIN UP TO          00012930
         BE    TIMEOUT4           CURRENT PROC.                         00012940
         L     R13,8(R13)         PROCEED TO NEXT SAVE AREA             00012950
         B     TIMEOUT3                                                 00012960
TIMEOUT4 BAL   R3,RUNMSG                                             &  00012970
         DC    AL2(21,TIMERR),C' TIME LIMIT EXCEEDED '               &  00012980
*                                                                       00012990
BADRNG   BALR  R15,0                                                 &  00013000
         USING *,R15                                                 &  00013010
         LH    R0,0(,R14)          GET S-FORMAT ADDRESS PARM.        &  00013020
         STH   R0,*+6              PLANT IN NEXT INSTR.              &  00013030
         LM    R4,R5,*-*           *** SEE LINE ABOVE ***            &  00013040
         AR    R2,R5                                                 &  00013050
         AR    R4,R5                                                 &  00013060
         LR    R0,R5                                                 &  00013070
         LR    R1,R4                                                 &  00013080
         LA    R14,2(,R14)         TRUE RETURN ADDRESS               &  00013090
         ST    R14,CHKSVALL+4*R14                                    &  00013100
*                                                                       00013110
RUNMSG   BALR  R15,0                                                 &  00013120
         USING *,R15                                                 &  00013130
         LH    R4,0(,R3)           LOAD MESSAGE LENGTH               &  00013140
         LH    R8,2(,R3)           LOAD ERROR CODE                   &  00013150
         LA    R3,4(,R3)           LOAD MESSAGE ADDRESS              &  00013160
*        B     $CHKMSG                                               &  00013170
*                                                                       00013180
*                                                                       00013190
*                                                                       00013200
*        THIS IS THE ENTRY POINT FOR RUN-TIME ERROR INDICATION          00013210
*        AND THE RELATED MESSAGES.                                      00013220
*                                                                       00013230
*                                                                       00013240
$CHKMSG  BALR  R11,0                                                    00013250
         USING *,R11                                                    00013260
         DROP  R15                                                      00013270
         LA    R14,0(R14)                                               00013280
         LA    R15,0(R15)         GET RID OF FLAG BITS                  00013290
         STM   R14,R13,CHKSAVE    SAVE RELEVANT REGISTERS               00013300
         L     R15,=A($PASCSP)                                       @  00013310
         L     R1,=A(FILOUT)       REFER TO OUTPUT FILE CONTROL BLOCK@  00013320
         LA    R9,OUTPUT                                             @  00013330
         TM    FILOPN(R1),WRITEOPN  CHECK IF "OUTPUT" IS OPEN        @  00013340
         BNZ   $CHKMSG4            JUMP IF OPEN                      @  00013350
         LA    R1,PREW                                               @  00013360
         BALR  R14,R15             CALL PASCSP TO OPEN THE FILE      @  00013370
$CHKMSG4 EQU   *                                                     @  00013380
*                                                                       00013390
         L     R2,SNAPADR                                               00013400
         LTR   R2,R2               IS SNAPSHOT LOADED ?                 00013410
         BZ    NOSNAP                                                   00013420
         L     R2,=A(SNAPFLAG)                                       #  00013430
         CLI   0(R2),X'00'         SNAPSHOT TO BE USED?              #  00013440
         BNE   NOSNAP              NO                                #  00013450
         MVI   0(R2),X'FF'         PREVENT SNAPSHOT BEING REENTERED  @  00013460
         L     R2,=A(FILOUT)       FORCE "OUTPUT" FILE TO            @  00013470
         NI    FILBEG+1(R2),X'FE'  ACCEPT CONTROL CHARS              @  00013480
*                                                                       00013490
         ST    R8,CHKSAVE-4        SAVE ERROR CODE                      00013500
         GETMAIN EC,LV=SNAPAREA,A=SNAPLOCS                           #  00013510
         LTR   R15,R15             SUCCESSFUL ?                      #  00013520
         BNZ   NOSNAP              NOT ENOUGH SPACE FOR SNAPSHOT     #  00013530
         L     R1,SNAPLOCS                                           #  00013540
*        R1 POINTS TO THE BASE OF GOTTEN AREA                           00013550
         SR    R2,R2                                                    00013560
         BCTR  R2,0                R2 <-- '-1'                          00013570
         LA    R3,CHKSAVE-4        SECOND PARM OF 'SNAPSHOT'            00013580
         STM   R2,R3,LCAFTMST+FPRSAREA(R1)                           &  00013590
         L     R15,SNAPADR                                              00013600
         BALR  R14,R15                                                  00013610
         FREEMAIN R,LV=SNAPAREA,A=SNAPLOCS  RETURN THE AREA TO O.S.  #  00013620
         AIF   (&SYSTEM).SYS910                                         00013630
         L     R15,=A(TRDUMP)      CALL THE TRACE TABLE DUMP         &  00013640
         BALR  R14,R15             ROUTINE TO PRINT LAST TRANSFERS   &  00013650
.SYS910  ANOP                                                           00013660
         L     R2,=A(SNAPFLAG)                                       @  00013670
         MVI   0(R2),X'00'         REALLOW SNAPSHOT CALLS            @  00013680
         L     R2,=A(CCFLAG)                                         @  00013690
         TM    0(R2),X'FF'         TEST IF "NOCC" OPTION ON          @  00013700
         BZ    SNAPDONE            JUMP IF NOT                       @  00013710
         L     R2,=A(FILOUT)                                         @  00013720
         OI    FILBEG+1(R2),X'01'  READJUST FILE BLOCK               @  00013730
         B     SNAPDONE                                                 00013740
*                                                                       00013750
NOSNAP   L     R15,=A($PASCSP)                                       &  00013760
         LA    R8,SNPERR(R8)                                            00013770
         BAL   R6,SKIP2                                              @  00013780
*        IF AN INTERRUPT, DUMP PSW AND REGISTERS                     *  00013790
         L     R7,=A(INTDATA+4)    POINT AT INTERRUPT PSW            *  00013800
         TM    3(R7),X'FF'                                           *  00013810
         BZ    NOSNAP4             JUMP IF NOT AN OCX TYPE ERROR     *  00013820
         LA    R2,MSG8                                               *  00013830
         LA    R4,L'MSG8                                             *  00013840
         BAL   R6,MSGLINE          PRINT A DESCRIPTION               *  00013850
         BAL   R6,HEXWORD          PRINT 1ST PSW WORD                *  00013860
         LA    R7,4(,R7)                                             *  00013870
         BAL   R6,HEXWORD          PRINT 2ND PSW WORD                *  00013880
         BAL   R6,SKIP2                                              *  00013890
         LA    R2,MSG9                                               *  00013900
         LA    R4,L'MSG9                                             *  00013910
         BAL   R6,MSGLINE                                            *  00013920
         LA    R5,8                # OF REGS PER LINE                *  00013930
NOSNAP2  LA    R7,4(R7)                                              *  00013940
         BAL   R6,HEXWORD          PRINT REGS 0-7                    *  00013950
         BCT   R5,NOSNAP2                                            *  00013960
         BAL   R6,SKIP2                                              *  00013970
         LA    R2,MSG10                                              *  00013980
         LA    R4,L'MSG10                                            *  00013990
         BAL   R6,MSGLINE                                            *  00014000
         LA    R5,8                # OF REGS ON 2ND LINE             *  00014010
NOSNAP3  LA    R7,4(R7)                                              *  00014020
         BAL   R6,HEXWORD          PRINT REGS 8-15                   *  00014030
         BCT   R5,NOSNAP3                                            *  00014040
         BAL   R6,SKIP2                                              *  00014050
         LA    R2,MSG11                                              &  00014060
         LA    R4,L'MSG11                                            &  00014070
         BAL   R6,MSGLINE                                            &  00014080
         LA    R7,=A($PASENT)                                        &  00014090
         BAL   R6,HEXWORD                                            &  00014100
         BAL   R6,SKIP2                                              &  00014110
NOSNAP4  EQU   *                                                     *  00014120
*                                                                       00014130
         LA    R1,PWRS            THE FUNCTION (WRITE STRING)           00014140
         LA    R2,MSG1                                                  00014150
         LA    R4,L'MSG1                                                00014160
         LA    R3,3(R4)           STRING LENGTH AND FIELD WIDTH         00014170
         BALR  R14,R15                                                  00014180
*                                                                       00014190
         LA    R1,PWRI                 WRITE LOCATION OF ERROR          00014200
         LA    R3,11                                                    00014210
         L     R2,CHKSAVE                                               00014220
         S     R2,CHKSAVE+(R10+2)*4    RELATIVE ADDRESS OF ERROR        00014230
         BM    NOSNAP5             TEST FOR OUT-OF-RANGE             &  00014240
         CH    R2,=H'8192'                                           &  00014250
         BNH   NOSNAP6             ADDRESS OK                        &  00014260
NOSNAP5  LA    R1,PWRC             NOT OK, SO PRINT                  &  00014270
         LA    R2,C'?'             A QUESTION MARK INSTEAD           &  00014280
         LA    R3,2                                                  &  00014290
NOSNAP6  BALR  R14,R15                                                  00014300
*                                                                       00014310
         L     R2,CHKSAVE+4*(R10+2)    POINT TO PROC. ENTRY POINT       00014320
         MVC   MSG2PROC,5(R2)          AND MOVE THE PROC. NAME          00014330
         LA    R1,PWRS                                                  00014340
         LA    R2,MSG2                                                  00014350
         LA    R3,L'MSG2+7                                              00014360
         LR    R4,R3                                                    00014370
         BALR  R14,R15                                                  00014380
*                                                                       00014390
*        INDICATE THE TYPE OF RUN TIME ERROR                            00014400
*                                                                       00014410
         BAL   R6,SKIP2                                              @  00014420
         LA    R1,PWRS                                                  00014430
         LA    R2,MSG1                 ' **** '                         00014440
         LA    R4,7                                                     00014450
         LA    R3,3(R4)                                                 00014460
         BALR  R14,R15                                                  00014470
         LM    R2,R3,CHKSAVE+4*(R3+2)                                   00014480
         LR    R4,R3                                                    00014490
         BALR  R14,R15                                                  00014500
*                                                                       00014510
*        INDICATE THE STATMNT # OF THE ERROR LOCATION, IF ASKED FOR     00014520
*                                                                       00014530
         BAL   R6,PRNTLOC                                               00014540
         AIF   (&SYSTEM).SYS34                                          00014550
*                                                                       00014560
*        PRINT THE ERRONEOUS VALUE AND THE RANGE                        00014570
*                                                                       00014580
PRNTRNG  L     R0,CHKSAVE+4*(R15-R14)                                   00014590
         C     R0,=A($SETCHK)          THESE ERRORS DO NOT HAVE      *  00014600
         BNL   CALCHAIN                A RANGE TO BE PRINTED            00014610
*                                                                       00014620
         LA    R1,PWRS                                                  00014630
         LA    R2,MSG4                                                  00014640
         LA    R4,L'MSG4                                                00014650
         LA    R3,3(R4)                                                 00014660
         BALR  R14,R15                                                  00014670
         LA    R1,PWRI                                                  00014680
         L     R2,CHKSAVE+4*(R2+2)                                      00014690
         LA    R3,8                                                     00014700
         BALR  R14,R15                 PRINT THE OUT OF RANGE VALUE     00014710
         LA    R1,PWRS                                                  00014720
         LA    R2,MSG5                                                  00014730
         LA    R4,L'MSG5                                                00014740
         LR    R3,R4                                                    00014750
         BALR  R14,R15                                                  00014760
         LA    R1,PWRI                                                  00014770
         L     R2,CHKSAVE+4*(R0+2)                                      00014780
         LA    R3,8                                                     00014790
         BALR  R14,R15                 PRINT LOWER BOUND (OF THE RANGE) 00014800
         LA    R3,10                                                    00014810
         L     R2,CHKSAVE+4*(R1+2)                                      00014820
         BALR  R14,R15                 AND THE UPPER BOUND              00014830
         BAL   R6,SKIP2                                              @  00014840
*                                                                       00014850
.SYS34   ANOP                                                           00014860
CALCHAIN BAL   R6,SKIP2                                              @  00014870
         LA    R7,16                   SET MAX # OF LINKS TO BE TRACED  00014880
NXTLNK   CR    R13,R12                 SEE IF END OF STACK              00014890
         BE    ABORT                                                    00014900
         MVC   CALLED(7),5(R10)        MOVE CALLERS NAME                00014910
         L     R5,12(R13)              BACK UP TO THE HIGHER SAVE AREA  00014920
         L     R13,4(R13)                                               00014930
         L     R10,12+(R15-R14)*4(R13) ENTRY POINT OF THE 'CALLER'      00014940
         MVC   CALLER(7),5(R10)        MOVE CALLER'S 'NAME'             00014950
         LA    R2,MSG7                                                  00014960
         LA    R3,L'MSG7                                                00014970
         LR    R4,R3                                                    00014980
         LA    R1,PWRS                                                  00014990
         BALR  R14,R15                                                  00015000
         BAL   R6,PRNTLOC              PRINT WHEREABOUT OF THE CALL     00015010
         BCT   R7,NXTLNK               NEXT LEVEL IF NOT EXHAUSTED      00015020
*                                                                       00015030
*                                                                       00015040
*        TIME TO EXIT                                                   00015050
*                                                                       00015060
ABORT    LA    R1,PWLN                 TERMINATE LINE BUFFER            00015070
         BALR  R14,R15                                                  00015080
*                                                                       00015090
SNAPDONE L     R15,=A($PASCSP)                                          00015100
         LA    R9,OUTPUT                                                00015110
         LA    R1,PWLN                 ANOTHER LINE FOR LUCK         @  00015120
         BALR  R14,R15                                                  00015130
         LR    R2,R8                                                    00015140
         LA    R1,PXIT                                                  00015150
         BR    R15                                                      00015160
*                                                                       00015170
MSGLINE  LA    R1,PWRS             WRITE-STRING                      *  00015180
         LA    R3,3(R4)            SET FIELD-WIDTH                   *  00015190
         LR    R14,R6              SET RETURN ADDRESS                *  00015200
         BR    R15                 GOTO CSP                          *  00015210
*                                                                       00015220
HEXWORD  UNPK  HEXBUF(9),0(5,R7)  CHANGE ZONES TO BYTES              *  00015230
         TR    HEXBUF(8),HEXCHARS  CONVERT TO HEX. CHARS             *  00015240
         LA    R1,PWRS                                               *  00015250
         LA    R2,HEXBUF                                             *  00015260
         LA    R3,9                                                  *  00015270
         LA    R4,8                                                  *  00015280
         LR    R14,R6                                                *  00015290
         BR    R15                 GO AND PRINT THE HEX NUMBER       *  00015300
*                                                                       00015310
PRNTLOC  DS    0H                                                       00015320
SKIP2    LA    R1,PSKP                                               #  00015330
         LA    R2,2                                                  #  00015340
         BALR  R14,R15                                                  00015350
         BR    R6            RETURN TO CALLER                           00015360
.SYS36   ANOP                                                           00015370
*                                                                       00015380
NORETURN DS    X                   IF X'FF' THEN CAN RETURN             00015390
         DS    0D                                                       00015400
CHKSVALL DS    18F                                                      00015410
CHKSAVE  DS    16F                 ALSO INCLUDES THE PREV. FOUR BYTES   00015420
*                                                                       00015430
SNAPADR  DC    V(SNAPSHOT)                                              00015440
SNAPAREA EQU   4096                OVERESTIMATE OF SNAPSHOT DATA SIZE#  00015450
SNAPLOCS DS    A                   ADDRESS OF TEMP SNAPAREA          #  00015460
*                                                                       00015470
HEXBUF   DS    CL9                 UNPACKING BUFFER                  *  00015480
HEXCHARS EQU   *-240               TRANSLATE TABLE FOR CODES         *  00015490
         DC    C'0123456789ABCDEF'  X'F0' TO X'FF' ONLY              *  00015500
*                                                                       00015510
MSG1     DC    C' ****   RUN ERROR AT LOCATION :'                       00015520
*                                                                       00015530
MSG2     DC    C'  OF PROCEDURE :  '                                    00015540
MSG2PROC DS    CL7                                                      00015550
*                                                                       00015560
MSG3     DC    C'  BETWEEN P_STATEMENTS :'                              00015570
*                                                                       00015580
MSG4     DC    C' ****   THE OFFENDING VALUE :'                         00015590
*                                                                       00015600
MSG5     DC    C'  IS NOT IN THE RANGE :'                               00015610
*                                                                       00015620
MS7      DC    C'    ****   '                                           00015630
CALLED   DC    CL7' '                                                   00015640
MSG6     DC    C'  WAS CALLED BY :  '                                   00015650
CALLER   DC    CL7' '                                                   00015660
MSG7     EQU   MS7,*-MS7                                                00015670
MSG8     DC    C' **** INTERRUPT PSW: '                              *  00015680
MSG9     DC    C' **** REGS 0 -  7: '                                *  00015690
MSG10    DC    C' **** REGS 8 - 15: '                                *  00015700
MSG11    DC    C' **** ENTRY POINT, $PASENT, AT: '                   &  00015710
*                                                                       00015720
         DROP  R11                                                      00015730
         LTORG                                                          00015740
         EJECT                                                          00015750
******************************************************************      00015760
*                                                                       00015770
*                                                                       00015780
*        PASCAL I/O AND STANDARD PROCEDURE (CSP) INTERFACE              00015790
*                                                                       00015800
*        FOLLOWING CODE INTERCEPTS ERRORS DETECTED BY FORTRAN        #  00015810
*        MATH. ROUTINES.  SUCH ROUTINES ARE PRESENT IF REFERRED      #  00015820
*        TO BY THE PASCAL PROGRAM.                                   #  00015830
*                                                                       00015840
******************************************************************      00015850
         SPACE 2                                                        00015860
         AIF   (&SYSTEM).SYS38                                          00015870
*                                                                       00015880
*        IHCERRM - CALLED BY FORTRAN MATH ROUTINES IN CASE OF ERROR     00015890
*                                                                       00015900
ERRMON   DS    0H                                                    #  00015910
IHCERRM  DS    0H                                                       00015920
IHOERRM  DS    0H                                                       00015930
IHNERRM  DS    0H                                                    #  00015940
         ENTRY IHCERRM,IHOERRM,IHOERRE,IHNERRM,IHNERRE,IHCERRE       #  00015950
         ENTRY  ERRMON                                               #  00015960
         USING IHCERRM,R15                                              00015970
         L     R1,0(R1)            GET 1ST ARG - PTR TO A(LEN),C'MSG'   00015980
         SR    R4,R4                                                    00015990
         IC    R4,3(R1)            GET THE MESSAGE LENGTH               00016000
         LA    R3,4(R1)            POINT TO MESSAGE TEXT                00016010
         NOPR  0                   WARNING - THE LOCATION ERRMON+19  #  00016020
         BC    0,0                 CAN BE OVERWRITTEN BY FORTRAN     #  00016030
*                                                                       00016040
*        SET RELEVANT REGS ACCORDING TO $CHKMSG CONVENTIONS             00016050
*                                                                       00016060
         L     R13,4(R13)          POINT TO THE ORIGINAL SAVE AREA      00016070
         L     R10,12+4*1(R13)     ENTRY POINT OF THE CURRENT ROUTINE   00016080
         LR    R14,R10             SET ERROR LOC TO ENTRY POINT TOO     00016090
         L     R12,=A(ALOSTORE)                                         00016100
         L     R12,0(R12)                                               00016110
         LA    R12,STACK-DYNSTORE(R12)    AND THE GLOBAL DATA POINTER   00016120
*                                                                       00016130
         L     R15,=A($CHKMSG)                                          00016140
         LA    R8,3001             SET ERROR RETURN CODE                00016150
         BR    R15                 AND JOIN THE ERROR HANDLER           00016160
         DROP  R15                                                      00016170
*                                                                       00016180
*        THE FOLLOWING IS FOR THE FORTRAN ERROR MESSAGES                00016190
*                                                                       00016200
IHCERRE  DS    0H                                                    #  00016210
IHNERRE  DS    0H                                                    #  00016220
IHOERRE  BR    R14                 THIS SHOULD NOT BE CALLED            00016230
         LTORG                                                       #  00016240
*                                                                       00016250
         SPACE 2                                                        00016260
.SYS38   ANOP                                                           00016270
         EJECT                                                          00016280
*****************************************************************       00016290
*                                                                       00016300
*                                                                       00016310
*        $PASCSP (PASCAL I/0) ENTRY POINT                               00016320
*                                                                       00016330
*                                                                       00016340
*****************************************************************       00016350
*                                                                       00016360
         DS    0D                                                       00016370
         USING *,15                                                     00016380
$PASCSP  B     *+12                BRANCH AROUND ID                     00016390
         DC    AL1(7),CL7'$PASCSP'                                      00016400
*                                                                       00016410
         STM   R1,R15,SPUSERSA                                          00016420
         LA    R13,SPSYSTSA        SET UP SYSTEM SAVE AREA              00016430
         LR    R10,R15                                                  00016440
         LA    R11,4092(,R10)                                        @  00016450
         DROP  R15                                                      00016460
         USING $PASCSP,R10         PROVIDE TWO BASE REGS             @  00016470
         USING $PASCSP+4092,R11                                      @  00016480
         USING STACK,GBR                                             @  00016490
         USING IHADCB-FILDCB,AE                                      #  00016500
         L     R1,SUBTBL(R1)                                            00016510
         BR    R1                                                       00016520
SUBTBL   DC    A(GET,PUT,RES,RLN,REW,WLN,WRS,ELN)                       00016530
         DC    A(WRI,WRR,WRC,RDI,RDR,RDC)                               00016540
         DC    A(RDH,RDY,RDD,WRD,WRE,EOL)                            &  00016550
         DC    A(EOF,XIT,RDS,TRP,SIO,EIO,CLK,FDF,PAG,CLS)               00016560
         DC    A(RDB,WRB,SKP,LIM,MSG,EOT,CTR,TRA)                    &  00016570
SPUSERSA DC    18XL4'FFFFFFFF'                                          00016580
SPSYSTSA DS    18F                                                      00016590
*                                                                       00016600
*                                                                       00016610
*        (GET FETCH) GET A CHAR TO (AD)                                 00016620
*                                                                       00016630
FILGFE   LH    R1,FILPTR(AE)                                         #  00016640
         LA    R1,1(,R1)                                             #  00016650
         CH    R1,FILEND(AE)       TEST FOR END-OF-LINE              #  00016660
         BNL   FILGFE2             IF SO, GO AND PROVIDE A BLANK     #  00016670
         IC    R0,0(R1,AF)         PICK UP INPUT CHARACTER           #  00016680
FILGFE1  STC   R0,PFILCOMP(AD)      AND PUT INTO CALLER'S BUFFER     @  00016690
         STH   R1,FILPTR(AE)                                         #  00016700
         BR    R5                                                    #  00016710
FILGFE2  LA    R0,FILBLA           SET EOL CHARACTER                 #  00016720
         MVI   PFILEOL(AD),TRUE    SET EOL FLAG                      @  00016730
         BE    FILGFE1             GO BACK TO RETURN EOL CHAR        #  00016740
*        B     FILGET              NEED TO GET A NEW INPUT RECORD    #  00016750
*                                                                       00016760
*        GET A RECORD TO (AF)                                           00016770
*                                                                       00016780
FILGET   TM    FILEOF(AE),1                                             00016790
         BOR   R5                  RETURN IF END-OF-FILE             #  00016800
         AIF   (&SYSTEM).SYS42                                          00016810
         TM    FILOPN(AE),READOPN                                       00016820
         BZ    BADREAD             IF FILE NOT OPEN FOR READ, COMPLAIN  00016830
.SYS42   ANOP                                                           00016840
FILGET1  MVI   RRFLAG,0            CLEAR REREAD FLAG                 #  00016850
         GET   FILDCB(AE)          READ THE NEXT RECORD              #  00016860
         CLI   RRFLAG,0            TEST IF REREAD ASKED FOR          #  00016870
         BNE   FILGET1             IF SO, GO BACK AND TRY AGAIN      #  00016880
         ST    R1,FILBUF(AE)       STORE ADDRESS OF INPUT RECORD     #  00016890
         LR    AF,R1                                                 #  00016900
         LH    R1,FILBEG(AE)                                         #  00016910
         STH   R1,FILPTR(AE)       RESET CHAR. PTR                   #  00016920
         IC    R0,0(R1,AF)                                           #  00016930
         STC   R0,PFILCOMP(AD)     UPDATE CURRENT FILE ELEMENT       @  00016940
         MVI   PFILEOL(AD),FALSE   CLEAR EOL FLAG                    @  00016950
         MVC   FILEND(2,AE),DCBLRECL    RESET BUFFER LENGTH          #  00016960
         BR    R5                                                       00016970
*                                                                    @  00016980
*        (GET NON-BLANK) GET NEXT NON-BLANK TO (AD)                  @  00016990
*                                                                    @  00017000
FILGNB   LH    R1,FILPTR(AE)                                         @  00017010
         B     FILGNB1                                               @  00017020
FILGNB0  LA    R15,0(R1,AF)                                          @  00017030
         CLI   0(R15),FILBLA                                         @  00017040
         BNE   FILGNB2             JUMP IF WE HAVE A NON-BLANK       @  00017050
         LA    R1,1(,R1)           OTHERWISE, STEP TO NEXT POSITION  @  00017060
FILGNB1  CH    R1,FILEND(AE)                                         @  00017070
         BL    FILGNB0             GO BACK AND TRY AGAIN             @  00017080
         ST    R5,FILPSTSV         NEED TO REFILL THE LINE           @  00017090
         BAL   R5,FILGET                                             @  00017100
         L     R5,FILPSTSV                                           @  00017110
         TM    FILEOF(AE),1        HAVE WE HIT THE EOF?              @  00017120
         BOR   R5                  MAKE ERROR RETURN                 &  00017130
         B     FILGNB                                                @  00017140
FILGNB2  IC    R0,0(R15)           TRANSFER THE CHAR TO              @  00017150
         STC   R0,PFILCOMP(AD)     THE FILE BUFFER                   @  00017160
         MVI   PFILEOL(AD),FALSE   CLEAR EOL FLAG                    @  00017170
         STH   R1,FILPTR(AE)       RESTORE THE FILE POINTER          @  00017180
         B     4(R5)               AND MAKE NORMAL RETURN            &  00017190
*                                                                       00017200
*        (PUT-STORE) PUT A CHAR FROM (AD)                               00017210
*                                                                       00017220
FILPST   LH    R1,FILPTR(AE)                                            00017230
         CH    R1,FILEND(AE)       TEST IF BUFFER FULL               #  00017240
         BNL   FILPST1             CLEAR IT FIRST                    #  00017250
         IC    R0,PFILCOMP(AD)                                       @  00017260
         STC   R0,0(R1,AF)                                           #  00017270
         LA    R1,1(R1)            INCREMENT CHAR. PTR.              #  00017280
         STH   R1,FILPTR(AE)                                         #  00017290
         BR    R5                                                    #  00017300
FILPST1  ST    R5,FILPSTSV         SAVE RETURN ADDRESS               #  00017310
         BAL   R5,FILPUT           EMPTY THE BUFFER                  #  00017320
         L     R5,FILPSTSV                                           #  00017330
         B     FILPST                                                #  00017340
*                                                                       00017350
*        PUT A RECORD (FROM AF)                                         00017360
*                                                                       00017370
FILPUT   DS    0H                                                       00017380
         AIF   (&SYSTEM).SYS44                                          00017390
         TM    FILOPN(AE),WRITEOPN                                      00017400
         BZ    BADWRITE            IF NOT OPEN FOR WRITE, THEN COMPLAIN 00017410
.SYS44   ANOP                                                           00017420
*                                                                    #  00017430
*        PREPARE THE OUTPUT BUFFER FOR TRANSMITTING TO O.S.          #  00017440
*                                                                    #  00017450
         CLI   DCBRECFM,X'80'                                        #  00017460
         BNL   FILPUT4             JUMP IF F OR U-FORMAT             #  00017470
         LA    R0,6                MIN LENGTH FOR VBA RECORDS        #  00017480
         TM    DCBRECFM,X'06'                                        #  00017490
         BNZ   *+6                 JUMP IF CONTROL CHARS             #  00017500
         BCTR  R0,0                ADJUST MIN LENGTH                 #  00017510
         LH    R1,FILPTR(AE)                                         #  00017520
         CR    R1,R0                                                 #  00017530
         BNL   FILPUT2             JUMP IF RECORD SIZE OK            #  00017540
         LTR   AF,AF               RETURN IF THE I/O BUFFER IS NOT   #  00017550
         BZ    FILPUT4             ALLOCATED  (FILE NEWLY OPENED)    #  00017560
         LA    R0,FILBLA                                             #  00017570
         STC   R0,0(R1,AF)         PROVIDE 1 CHAR AT LEAST           #  00017580
         LA    R1,1(R1)                                              #  00017590
         AIF   (&IBM370).M701                                        @  00017600
FILPUT2  STC   R1,1(AF)            SET RDW FOR V-FORMAT              @  00017610
         SRA   R1,8                - BUT DO IT WITH 2 STC INST.S TO  @  00017620
         STC   R1,0(AF)              AVOID ALIGNMENT ERRORS ON 360'S @  00017630
         AGO   .M601                                                 @  00017640
.M701    ANOP  ,                                                     @  00017650
FILPUT2  STCM  R1,3,0(AF)            SET RDW FOR V-FORMAT            @  00017660
.M601    ANOP  ,                                                     @  00017670
*                                                                    #  00017680
FILPUT4  DS    0H                                                       00017690
         PUT   FILDCB(AE)          WRITE THE RECORD                  #  00017700
         ST    R1,FILBUF(AE)       SAVE ADDRESS OF NEXT OUTPUT BUFFER#  00017710
         MVC   FILEND(2,AE),DCBLRECL  RESET BUFFER LENGTH            #  00017720
         LR    AF,R1                                                 #  00017730
         AIF   (&SYSTEM).SYS415                                      #  00017740
         L     R0,FILLIM(AE)       LOAD LINES LIMIT                  #  00017750
         BCT   R0,FILPUT6          DECREMENT                         #  00017760
         ST    R0,FILLIM(AE)       OVERFLOW OF COUNTER               #  00017770
         B     LIMITERR                                              #  00017780
FILPUT6  ST    R0,FILLIM(AE)       PUT DECREMENTED COUNT BACK        #  00017790
.SYS415  ANOP                                                        #  00017800
*        B     FILCLR              I.E., NEXT LINE                   #  00017810
*                                                                    #  00017820
*        CLEAR THE OUTPUT BUFFER TO BLANKS                           #  00017830
*                                                                    #  00017840
FILCLR   LH    R1,FILBEG(AE)                                         #  00017850
         STH   R1,FILPTR(AE)       RESET CHAR. POINTER               #  00017860
         CLI   DCBRECFM,X'80'      JUMP IF F OR U-FORMAT             #  00017870
         BNL   FILCLR1                                               #  00017880
         TM    DCBRECFM,X'06'                                        #  00017890
         BZR   R5                  RETURN IF NO CONTROL CHAR NEEDED  #  00017900
         MVI   4(AF),FILBLA        SET DEFAULT CONTROL CHAR          #  00017910
         TM    DCBRECFM,X'04'                                        #  00017920
         BOR   R5                  RETURN IF ASCII CONTROL CHARS     #  00017930
         MVI   4(AF),X'09'         REPLACE WITH MACHINE CHAR         #  00017940
         BR    R5                                                    #  00017950
FILCLR1  LH    R15,FILEND(AE)      LOAD BUFFER LENGTH                #  00017960
         AIF   (&IBM370).M705                                        @  00017970
         LA    R14,256                                               #  00017980
         LR    R1,AF               LOAD BUFFER ADDRESS               #  00017990
         MVI   0(AF),FILBLA                                          #  00018000
         SH    R15,=H'2'                                             #  00018010
         B     FILCLR3                                               #  00018020
FILCLR2  MVC   1(256,R1),0(R1)     PROPAGATE BLANKS                  #  00018030
         AR    R1,R14                                                #  00018040
         SR    R15,R14                                               #  00018050
FILCLR3  BMR   R5                                                    #  00018060
         CR    R15,R14                                               #  00018070
         BNL   FILCLR2                                               #  00018080
         EX    R15,CLRBUF          CLEAR REMAINDER OF BUFFER         #  00018090
         AGO   .M605                                                 @  00018100
.M705    LR    R14,AF                                                @  00018110
         LA    R1,FILBLA                                             @  00018120
         SLL   R1,24               SET FILL CHARACTER                @  00018130
         MVCL  R14,R0              CLEAR THE I/O BUFFER              @  00018140
.M605    ANOP  ,                                                     @  00018150
         TM    DCBRECFM,X'02'                                        #  00018160
         BZR   R5                  RETURN IF NOT MACH CONTROL CHAR   #  00018170
         MVI   0(AF),X'09'                                           #  00018180
         BR    R5                                                    #  00018190
*                                                                    #  00018200
CLRBUF   MVC   1(0,R1),0(R1)       PROPAGATE BLANKS                  #  00018210
*                                                                       00018220
*        'END OF DATA' EXIT, THIS ROUTINE IS ENTERED WHENEVER           00018230
*        A 'GET' IS ISSUED FOR A FILE WHICH HAS REACHED THE             00018240
*        'END OF FILE' MARK. (I.E. NO MORE INPUT)                       00018250
*                                                                       00018260
EOD      LA    AG,FILDCB(AE)                                         #  00018270
         CLOSE ((AG))                                                   00018280
         TM    DCBBUFCB+3,1                                          #  00018290
         BO    EOD1                SKIP IF NO BUFFER POOL            #  00018300
         FREEPOOL (AG)                                               #  00018310
EOD1     OI    FILEOF(AE),1                                             00018320
         MVI   PFILEOF(AD),TRUE    SET EOF FLAG IN PASCAL            @  00018330
         NI    FILOPN(AE),TEXTFLAG CLEAR THE OPENFLAGS               @  00018340
         BZ    EOD2                JUMP IF NOT A TEXTFILE            @  00018350
         MVI   PFILEOL(AD),TRUE    SET EOL FLAG                      @  00018360
         MVI   PFILCOMP(AD),FILBLA                                   @  00018370
         SR    AF,AF               INDICATE NO I/O BUFFER            @  00018380
         STH   AF,FILBEG(AE)       RESET VARIOUS POINTERS            #  00018390
         STH   AF,FILEND(AE)                                         #  00018400
         STH   AF,FILPTR(AE)                                         #  00018410
         ST    AF,FILBUF(AE)                                         #  00018420
         BR    R5                                                    #  00018430
EOD2     SR    R0,R0                                                 @  00018440
         ST    R0,PFILRSZ(AD)      INDICATE ZERO LENGTH RECORD       @  00018450
         B     RTN                 GO BACK TO CALLER                 @  00018460
*                                                                       00018470
*        RESET AN INPUT FILE                                            00018480
*                                                                       00018490
*                                                                       00018500
         DC    CL4'RES '                                                00018510
RES      FILADR ,                                                       00018520
         BAL   R5,FILCLS           GO AND CLOSE THE FILE             #  00018530
*                                                                       00018540
*        (GET) OPEN A FILE                                              00018550
*                                                                       00018560
FILGOP   NI    FILOPN(AE),TEXTFLAG CLEAR OPEN FLAGS                  @  00018570
         LA    AG,FILDCB(AE)                                         #  00018580
         OPEN  ((AG),(INPUT))                                           00018590
         TM    DCBOFLGS,X'10'                                           00018600
         BNO   BADREAD                                                  00018610
         L     AF,FILBUF(AE)                                         *  00018620
         MVI   PFILEOF(AD),FALSE                                     @  00018630
         MVI   FILEOF(AE),0        CLEAR BOTH EOF FLAGS              @  00018640
         OI    FILOPN(AE),READOPN                                    @  00018650
         TM    FILOPN(AE),TEXTFLAG                                   @  00018660
         BZ    GET1                IF NON TEXT FILE, GET 1ST RECORD  @  00018670
         MVI   PFILEOL(AD),TRUE                                      @  00018680
         SR    R0,R0                                                 @  00018690
         STH   R0,FILBEG(AE)                                         @  00018700
         LH    R1,DCBLRECL                                              00018710
         TM    DCBRECFM,X'C0'                                        #  00018720
         BNO   *+8                 JUMP IF NOT U-FORMAT              #  00018730
         LH    R1,DCBBLKSI                                           #  00018740
         STH   R1,FILEND(AE)       SET LRECL FOR THE LOCAL BUF          00018750
         CLI   DCBRECFM,X'80'                                        #  00018760
         BNL   FILGOP1             JUMP IF NOT V-FORMAT              #  00018770
         MVI   FILBEG+1(AE),4      ALLOW 4-BYTE RDW/SDW              #  00018780
FILGOP1  TM    DCBRECFM,X'06'                                        #  00018790
         BZ    FILGOP2             JUMP IF NO CONTROL CHARS          #  00018800
         CLI   CCFLAG,0            OR IF CONTROL CHARS ARE NOT       #  00018810
         BE    FILGOP2             TO BE INSERTED                    #  00018820
         OI    FILBEG+1(AE),1      ADD IN 1-BYTE CONTROL CHAR        #  00018830
FILGOP2  BAL   R5,FILGET                                                00018840
         B     RTN                 RETURN TO PASCAL PROGRAM             00018850
*                                                                       00018860
*        GET AN INPUT RECORD                                            00018870
*                                                                       00018880
         DC    CL4'GET'                                                 00018890
GET      FILADR ,                                                       00018900
         TM    FILEOF(AE),1                                             00018910
         BO    RTN                                                      00018920
         TM    FILOPN(AE),TEXTFLAG                                   @  00018930
         BZ    GET1                JUMP IF NON-TEXT FILE             @  00018940
         BAL   R5,FILGFE                                                00018950
         B     RTN                                                      00018960
GET1    GET    FILDCB(AE),(AF)     READ THE NEXT RECORD              @  00018970
        CLI    DCBRECFM,X'80'                                        @  00018980
        BL     GET2                JUMP IF V-FORMAT                  @  00018990
        LH     R1,DCBLRECL                                           @  00019000
        B      GET3                                                  @  00019010
GET2    LH     R1,0(AF)            LOAD RDW                          @  00019020
        SH     R1,=H'4'            SUBTRACT RDW LENGTH               @  00019030
GET3    ST     R1,PFILRSZ(AD)      PUT SIZE BACK FOR PASCAL PROG ?   @  00019040
        CH     R1,FILCSZ(AE)       CHECK THAT INPUT RECORD ISNT      @  00019050
        BH     BADRECRD            TOO LARGE FOR BUFFER              @  00019060
        B      RTN                                                   @  00019070
*                                                                       00019080
*                                                                       00019090
*                                                                       00019100
*        EOT (SKIP BLANKS TO END OF TEXT)                            &  00019110
*                                                                       00019120
EOT      FILADR ,                                                    &  00019130
         BAL   R5,FILGNB                                             &  00019140
         B     RTN                                                   &  00019150
         B     RTN                                                   &  00019160
*                                                                       00019170
*        READ-LINE (FOR TEXTFILE ONLY)                                  00019180
*                                                                       00019190
         DC    CL4'RLN'                                                 00019200
RLN      FILADR ,                                                       00019210
         BAL   R5,FILGET                                                00019220
         B     RTN                                                      00019230
*                                                                       00019240
*                                                                       00019250
*                                                                       00019260
*        EOL (SKIP BLANKS TO END OF LINE)                            &  00019270
*                                                                       00019280
EOL      FILADR ,                                                    &  00019290
         TM    FILEOF(AE),1                                          &  00019300
         BO    RTN                 RETURN IF END OF FILE             &  00019310
         LH    R1,FILPTR(AE)                                         &  00019320
EOL1     CH    R1,FILEND(AE)                                         &  00019330
         BNL   EOL3                JUMP IF AT END OF LINE            &  00019340
         LA    R15,0(R1,AF)                                          &  00019350
         CLI   0(R15),FILBLA                                         &  00019360
         BNE   EOL2                EXIT LOOP IF A NON-BLANK          &  00019370
         LA    R1,1(,R1)           ADVANCE TO NEXT CHAR.             &  00019380
         B     EOL1                                                  &  00019390
EOL2     IC    R0,0(R15)           LOAD NON-BLANK CHAR.              &  00019400
         STC   R0,PFILCOMP(AD)     PASS TO PASCAL PROG.              &  00019410
         MVI   PFILEOL(AD),FALSE   REDUNDANT?                        &  00019420
         STH   R1,FILPTR(AE)                                         &  00019430
         B     RTN                                                   &  00019440
EOL3     MVI   PFILEOL(AD),TRUE                                      &  00019450
         MVI   PFILCOMP(AD),FILBLA                                   &  00019460
         STH   R1,FILPTR(AE)                                         &  00019470
         B     RTN                                                   &  00019480
*                                                                       00019490
*                                                                       00019500
*        RDB, (READ BOOLEAN)   ADR(FILE),ADR(BOOLEAN)                #  00019510
*                                                                       00019520
         DC    CL4'RDB'                                                 00019530
RDB      FILADR ,                                                    #  00019540
         BAL   R5,FILGNB           ADVANCE TO A NON-BLANK            @  00019550
         B     EOFREAD             ERROR RETURN FOR EOF              &  00019560
         LA    RSLT,TRUE                                             #  00019570
         OI    PFILCOMP(AD),X'40'  CONVERT TO UPPER CASE (IN CASE !)    00019580
         CLI   PFILCOMP(AD),C'T'   T = TRUE ?                        #  00019590
         BE    RDB6                                                  #  00019600
         CLI   PFILCOMP(AD),C'F'   F = FALSE ?                       #  00019610
         BNE   BADBOOL             NEITHER = AN ERROR                #  00019620
RDB4     SR    RSLT,RSLT                                             #  00019630
RDB6     STC   RSLT,0(R2)          STORE THE RESULT                  #  00019640
         BAL   R5,FILGFE           STEP TO FOLLOWING CHAR            #  00019650
         B     RTN                                                   #  00019660
*                                                                       00019670
*                                                                       00019680
*        RDC  (READ CHAR),  R2 = ADDR. OF CHAR                          00019690
*                                                                       00019700
         DC    CL4'RDC'                                                 00019710
RDC      FILADR ,                                                       00019720
         IC    R0,PFILCOMP(AD)                                          00019730
         STC   R0,0(R2)                                                 00019740
         BAL   R5,FILGFE                                                00019750
         B     RTN                                                      00019760
*                                                                       00019770
*        RDI/RDH/RDY (READ INTEGER)    AD: ADR(FILE),  R2: ADR(INT)     00019780
*                                                                       00019790
         DC    CL4'RDI'                                                 00019800
RDY      OI    RDY1+1,X'F0'        OVERWRITE NO-OP                   &  00019810
RDH      OI    RDH1+1,X'F0'        OVERWRITE NO-OP                   &  00019820
RDI      FILADR ,                                                       00019830
         LR    R4,R2               CLEAR A REGISTER PAIR  (R2,R3)       00019840
         SR    R3,R3                                                    00019850
         MVI   SIGN,1              ASSUME POSITIVE                      00019860
         BAL   R5,FILGNB           ADVANCE TO A NON-BLANK            @  00019870
         B     EOFREAD             ERROR RETURN FOR EOF              &  00019880
         CLI   PFILCOMP(AD),FILPLU                                      00019890
         BE    RDI23                                                 #  00019900
         CLI   PFILCOMP(AD),FILMIN                                      00019910
         BNE   RDI25                                                    00019920
         MVI   SIGN,0              CHANGE TO NEGATIVE                   00019930
RDI23    BAL   R5,FILGFE                                             #  00019940
RDI25    LA    R15,BADINT          PREPARE ERROR RT ADDRESS          #  00019950
RDI4     SR    R0,R0                                                 #  00019960
         IC    R0,PFILCOMP(AD)     GET DIGIT                         #  00019970
         SH    R0,=AL2(FILZER)                                       #  00019980
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #  00019990
         CH    R0,=AL2(9)                                            #  00020000
         BHR   R15                                                   #  00020010
         M     R2,=F'10'                                             #  00020020
         AR    R3,R0                                                    00020030
         BAL   R5,FILGFE                                                00020040
         BAL   R15,RDI4            LOOP BACK & SET EXIT ADDRESS      #  00020050
         TM    SIGN,1                                                   00020060
         BO    *+6                                                      00020070
         LCR   R3,R3                                                    00020080
RDH1     BC    0,RDH2              JUMP FOR RDH/RDY ROUTINES         &  00020090
         ST    R3,0(R4)                                                 00020100
         B     RTN                                                      00020110
RDH2     NI    RDH1+1,X'0F'        RESET JUMP BACK TO NO-OP          &  00020120
RDY1     BC    0,RDY2              JUMP FOR RDY ROUTINE              &  00020130
         CH    R3,=H'32767'                                          &  00020140
         BH    BIGINT                                                &  00020150
         CH    R3,=H'-32768'                                         &  00020160
         BL    BIGINT                                                &  00020170
         STH   R3,0(R4)                                              &  00020180
         B     RTN                                                   &  00020190
RDY2     NI    RDY1+1,X'0F'        RESET JUMP BACK TO NO-OP          &  00020200
         CL    R3,=F'255'                                            &  00020210
         BH    BIGINT                                                &  00020220
         STC   R3,0(R4)                                              &  00020230
         B     RTN                                                   &  00020240
*                                                                       00020250
*                                                                       00020260
*  RDS, (READ STRING), R2= STRING ADDRESS, R3=STRING LENGTH !           00020270
*                                                                       00020280
         DC    CL4'RDS'                                                 00020290
RDS      FILADR ,                                                       00020300
         AIF   (&IBM370).M710                                        @  00020310
         LH    R1,FILPTR(AE)                                            00020320
         IC    R0,PFILCOMP(AD)     START WITH CURRENT CHARACTER      #  00020330
RDSNXTCH STC   R0,0(R2)            COPY CHARS ONE-BY-ONE             #  00020340
         LA    R2,CHR(R2)                                            #  00020350
         LA    R1,1(,R1)                                             #  00020360
         CH    R1,FILEND(AE)       END OF THIS LINE?                 #  00020370
         BL    RDSF1               IF NOT, JUMP                      #  00020380
         LA    R0,FILBLA           END OF LINE CHARACTER             #  00020390
         BCT   R3,RDSNXTCH         REPEAT                            @  00020400
         STC   R0,PFILCOMP(AD)     SET EOL CHAR                      @  00020410
         MVC   FILPTR(2,AE),FILEND(AE)  INDICATE AN EOL CONDITION    @  00020420
         MVI   PFILEOL(AD),TRUE                                      @  00020430
         B     RTN                                                   @  00020440
RDSF1    IC    R0,0(R1,AF)         LOAD NEXT INPUT CHAR              #  00020450
RDSF2    BCT   R3,RDSNXTCH         REPEAT                            #  00020460
         STC   R0,PFILCOMP(AD)                                          00020470
         STH   R1,FILPTR(AE)                                            00020480
         AGO   .M610                                                    00020490
.M710    LH    R15,FILEND(AE)                                        @  00020500
         LH    R14,FILPTR(AE)                                        @  00020510
         SR    R15,R14             COMPUTE # COLUMNS LEFT            @  00020520
         BNM   *+6                                                   @  00020530
         SR    R15,R15                                               @  00020540
         AR    R14,AF              ADDR OF FIRST CHAR                @  00020550
         ICM   R15,8,=AL1(FILBLA)  SET FILL CHAR                     @  00020560
         MVCL  R2,R14              NOW COPY STRING                   @  00020570
         BL    RDSF1               JUMP IF INPUT LINE NOT FINISHED   @  00020580
         MVC   FILPTR(AE),FILEND(AE)  LINE IS FINISHED               @  00020590
         MVI   PFILCOMP(AD),FILBLA                                   @  00020600
         MVI   PFILEOL(AD),TRUE                                      @  00020610
         B     RTN                                                   @  00020620
RDSF1    IC    R0,0(R14)           GET NEXT CHAR IN LINE             @  00020630
         STC   R0,PFILCOMP(AD)                                       @  00020640
         SR    R14,AF                                                @  00020650
         STH   R14,FILPTR(AE)                                        @  00020660
.M610    ANOP                                                           00020670
         B     RTN                                                      00020680
*                                                                       00020690
*                                                                       00020700
*  REW, (REWRITE = REWIND FOR OUTPUT)                                   00020710
*                                                                       00020720
         DC    CL4'REW'                                                 00020730
REW      FILADR ,                                                       00020740
         BAL   R5,FILCLS           GO AND CLOSE THE FILE             #  00020750
*                                                                       00020760
*        (PUT) OPEN A FILE                                              00020770
*                                                                       00020780
FILPOP   NI    FILOPN(AE),TEXTFLAG PUT-OPEN THE FILE                 @  00020790
         LA    AG,FILDCB(AE)                                         #  00020800
         OPEN  ((AG),(OUTPUT))                                          00020810
         TM    DCBOFLGS,X'10'                                           00020820
         BNO   BADWRITE            REPORT ANY PROBLEM                   00020830
         OI    FILOPN(AE),WRITEOPN SET FLAGS, BUF PTRS ETC.             00020840
         OI    FILEOF(AE),1                                             00020850
         MVI   PFILEOF(AD),TRUE    OUTPUT FILES HAVE EOF TRUE        @  00020860
         SR    R0,R0                                                 @  00020870
         ST    R0,FILLIM(AE)       CLEAR OUTPUT LIMIT                @  00020880
         TM    FILOPN(AE),TEXTFLAG                                   @  00020890
         BZ    RTN                 RETURN IF NOT A TEXT FILE         @  00020900
         MVI   PFILEOL(AD),TRUE    SET EOL - IN CASE !               @  00020910
         STH   R0,FILPTR(AE)       CLEAR LINE POSN PTR               #  00020920
         ST    R0,FILBUF(AE)       NULLIFY BUFFER POINTER            #  00020930
         LH    R1,DCBLRECL         GET LRECL FROM THE DCB            #  00020940
         TM    DCBRECFM,X'C0'                                        #  00020950
         BNO   *+12                JUMP IF NOT U-FORMAT              #  00020960
         LH    R1,DCBBLKSI                                           #  00020970
         STH   R1,DCBLRECL                                           #  00020980
         STH   R0,FILBEG(AE)       RESET CHAR. START POSITION        *  00020990
         BCTR  R0,0                                                  *  00021000
         STH   R0,FILEND(AE)       INITIALIZE BUFFER TO "OVER-FULL"  *  00021010
         CLI   DCBRECFM,X'80'                                        #  00021020
         BNL   FILPOP1             JUMP IF NOT V-FORMAT              #  00021030
         MVI   FILBEG+1(AE),4      ALLOW 4-BYTE RDW/SDW              #  00021040
FILPOP1  TM    DCBRECFM,X'06'      TEST IF CONTROL CHARS             #  00021050
         BZ    RTN                                                   #  00021060
         CLI   CCFLAG,0            RETURN IF CONTROL CHARS ARE NOT   #  00021070
         BE    RTN                 TO BE INSERTED                    #  00021080
         OI    FILBEG+1(AE),1      ADD 1-BYTE CONTROL CHAR.          #  00021090
         B     RTN                                                      00021100
*                                                                       00021110
*        PUT (PASCAL 'PUT' OPERATION)                                   00021120
*                                                                       00021130
         DC    CL4'PUT '                                                00021140
PUT      FILADR ,                                                       00021150
         TM    FILEOF(AE),1                                             00021160
         BZ    RTN                                                      00021170
         TM    FILOPN(AE),TEXTFLAG                                   @  00021180
         BZ    PUT1                JUMP IF NOT A TEXT-FILE           @  00021190
         BAL   R5,FILPST                                                00021200
         B     RTN                                                      00021210
PUT1     LH    R1,FILRSZ(AE)       GET CORRECT RECORD SIZE           @  00021220
         SLL   R1,16               CONSTRUCT A RDW                   @  00021230
         ST    R1,PFILRSZ(AD)      - IN CASE FILE HAS V-FORMAT       @  00021240
         PUT   FILDCB(AE),(AF)     WRITE THE RECORD                  @  00021250
         AIF   (&SYSTEM).SYS425                                      @  00021260
         L     R0,FILLIM(AE)                                         @  00021270
         BCT   R0,PUT2             UPDATE OUTPUT LIMIT               @  00021280
         ST    R0,FILLIM(AE)       - LIMIT EXCEEDED                  @  00021290
         B     LIMITERR                                              @  00021300
PUT2     ST    R0,FILLIM(AE)       PUT UPDATED COUNT BACK            @  00021310
.SYS425  ANOP                                                        @  00021320
         B     RTN                                                   @  00021330
*                                                                       00021340
*        WLN (WRITE LINE), TERMINATE CURRENT OUTPUT LINE                00021350
*                                                                       00021360
         DC    CL4'WLN '                                                00021370
WLN      FILADR ,                                                       00021380
         LH    R1,FILPTR(AE)                                         #  00021390
         CH    R1,FILEND(AE)       IF BUFFER IS MARKED "OVER-FULL",  #  00021400
         BNH   *+12                   WE WRITE IT OUT                #  00021410
         BAL   R5,FILPUT                                             #  00021420
         LH    R1,FILPTR(AE)                                         #  00021430
         BCTR  R1,0                                                  #  00021440
         STH   R1,FILEND(AE)       FLAG BUFFER AS "OVER-FULL"        #  00021450
         B     RTN                                                   #  00021460
*                                                                       00021470
*                                                                       00021480
*        WRB (WRITE BOOLEAN):  ADR(FILE),BOOLEAN,FIELD_WIDTH         #  00021490
*                                                                       00021500
         DC    CL4'WRB'                                                 00021510
WRB      LTR   R2,R2                                                 #  00021520
         LA    R2,=C'TRUE'                                           #  00021530
         LA    R4,4                                                  #  00021540
         BNZ   WRS                 JUMP IF "TRUE"                    #  00021550
WRB1     LA    R2,=C'FALSE'                                          #  00021560
         LA    R4,5                                                  #  00021570
         B     WRS                                                   #  00021580
*                                                                       00021590
*                                                                       00021600
*        WRC   R1: ADR(FILE),  R3: FIELD_WIDTH,  R2: CHAR               00021610
*                                                                       00021620
         DC    CL4'WRC '                                                00021630
WRC      FILADR ,                                                       00021640
         BCTR  R3,0                                                     00021650
         LTR   R3,R3                                                    00021660
         BZ    WRC3                                                     00021670
         BM    RTN                                                      00021680
WRC2     MVI   PFILCOMP(AD),FILBLA                                      00021690
         BAL   R5,FILPST                                                00021700
         BCT   R3,WRC2                                                  00021710
WRC3     STC   R2,PFILCOMP(AD)                                          00021720
         BAL   R5,FILPST                                                00021730
         B     RTN                                                      00021740
*                                                                       00021750
*     WRS   ADR(FILE):R1, STRLGTH:R4, FIELD_WIDTH:R3, R2:ADR(STRING)    00021760
*                                                                       00021770
         DC    CL4'WRS '                                                00021780
WRS      FILADR ,                                                       00021790
         LTR   R3,R3                                                    00021800
         BNP   RTN                 ZERO FIELD WIDTH, RETURN             00021810
         LH    R1,FILPTR(AE)                                            00021820
         LA    R0,FILBLA           FILL CHARACTER                       00021830
WRSB1    CR    R3,R4               COMPARE FLD_LGTH TO STR_LGTH         00021840
         BNH   WRSF2               NO NEED FOR FILL CHARS               00021850
         CH    R1,FILEND(AE)                                         #  00021860
         BL    WRSF1                                                 #  00021870
         STH   R1,FILPTR(AE)       UPDATE LENGTH FIRST                  00021880
         BAL   R5,FILPUT           THEN EMPTY THE FULL BUFFER        #  00021890
         LH    R1,FILPTR(AE)                                         #  00021900
         LA    R0,FILBLA                                             #  00021910
WRSF1    STC   R0,0(R1,AF)         PLANT NEXT BLANK IN BUFFER        #  00021920
         LA    R1,1(R1)            AND ADVANCE TO NEXT POSITION      #  00021930
         BCT   R3,WRSB1                                              #  00021940
*    NOW WE HAVE R3 <= R4                                               00021950
WRSF2    DS    0H                                                       00021960
WRSB2    CH    R1,FILEND(AE)                                         #  00021970
         BL    WRSF3                                                 #  00021980
         STH   R1,FILPTR(AE)       UPDATE LENGTH FIELD                  00021990
         BAL   R5,FILPUT           THEN EMPTY THE FULL BUFFER        #  00022000
         LH    R1,FILPTR(AE)                                         #  00022010
WRSF3    IC    R0,0(R2)            PICK UP NEXT CHAR IN STRING       #  00022020
         STC   R0,0(R1,AF)         AND PLANT IT IN BUFFER            #  00022030
         LA    R2,CHR(R2)          ADVANCE IN THE STRING             #  00022040
         LA    R1,1(R1)            ADVANCE IN THE BUFFER             #  00022050
         BCT   R3,WRSB2                                              #  00022060
         STH   R1,FILPTR(AE)                                            00022070
         STC   R0,PFILCOMP(AD)                                       *  00022080
         B     RTN                                                      00022090
*                                                                       00022100
*                                                                       00022110
*        WRI ADR(FILE),WIDTH,INT                                        00022120
*                                                                       00022130
         DC    CL4'WRI '                                                00022140
WRI      DS    0H                                                    #  00022150
         CVD   R2,PINT                                               #  00022160
         MVC   ZINT,=X'402020202020202020202120'                        00022170
         LA    R1,ZINT+11                                               00022180
         EDMK  ZINT,PINT+2                                              00022190
         LTR   R2,R2                                                    00022200
         BNM   *+10                                                     00022210
         BCTR  R1,0                                                     00022220
         MVI   0(R1),C'-'                                               00022230
         LR    R2,R1                                                 #  00022240
         LA    R4,ZINT+L'ZINT                                        #  00022250
         SR    R4,R1                                                 #  00022260
         CR    R4,R3                                                 #  00022270
         BNH   WRS                 PRINT INTEGER AS A STRING         #  00022280
         LR    R3,R4               - BUT INCREASE FIELD WIDTH IF     #  00022290
         B     WRS                 NECESSARY TO PRINT ENTIRE NUMBER  #  00022300
*                                                                       00022310
*                                                                       00022320
*        RDR, READ THE NEXT (REAL) NUMBER INTO (GRG2)                   00022330
*                                                                       00022340
         DC    CL4'RDR'                                                 00022350
RDR      FILADR ,                                                       00022360
         SDR   0,0                                                      00022370
         LA    R3,1                                                     00022380
         BAL   R5,FILGNB           ADVANCE TO A NON-BLANK            @  00022390
         CLI   PFILCOMP(AD),FILPLU                                      00022400
         BE    RDR3                                                     00022410
         CLI   PFILCOMP(AD),FILMIN                                      00022420
         BNE   RDR4                                                     00022430
         LCR   R3,R3                                                    00022440
RDR3     BAL   R5,FILGFE                                                00022450
RDR4     LA    R15,BADREAL         SET ERROR EXIT ADDRESS            #  00022460
RDR45    SR    R1,R1                                                 #  00022470
         IC    R1,PFILCOMP(AD)            GET CHARACTER              #  00022480
         SH    R1,=AL2(FILZER)                                       #  00022490
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #  00022500
         CH    R1,=AL2(9)                                            #  00022510
         BHR   R15                                                   #  00022520
         MD    0,=D'10.0'                                            #  00022530
         SLA   R1,3                                                     00022540
         AD    0,DECTBL(R1)                                             00022550
         BAL   R5,FILGFE                                                00022560
         BAL   R15,RDR45           LOOP BACK & SET EXIT ADDRESS      #  00022570
RDR5     SR    R4,R4                                                    00022580
         CLI   PFILCOMP(AD),FILDOT                                      00022590
         BNE   RDR7                                                     00022600
         BAL   R5,FILGFE                                                00022610
RDR6     CLI   PFILCOMP(AD),FILZER                                      00022620
         BL    RDR7                                                     00022630
         CLI   PFILCOMP(AD),FILNIN                                      00022640
         BH    RDR7                                                     00022650
         MD    0,=D'10.0'                                               00022660
         SR    R1,R1                                                    00022670
         IC    R1,PFILCOMP(AD)                                          00022680
         SH    R1,=AL2(FILZER)                                       #  00022690
         SLA   R1,3                                                     00022700
         AD    0,DECTBL(R1)                                             00022710
         BAL   R5,FILGFE                                                00022720
         BCTR  R4,0                                                     00022730
         B     RDR6                                                     00022740
RDR7     LTR   R3,R3                                                    00022750
         BNM   *+6                                                      00022760
         LCDR  0,0                                                      00022770
         CLI   PFILCOMP(AD),C'E'                                        00022780
         BE    RDR75                                                    00022790
         CLI   PFILCOMP(AD),C'e'                                        00022800
         BNE   RDR13                                                    00022810
RDR75    LA    R3,1                                                     00022820
RDR8     BAL   R5,FILGFE                                                00022830
         CLI   PFILCOMP(AD),FILBLA                                      00022840
         BE    RDR8                                                     00022850
         ST    R4,EXPONENT                                              00022860
         SR    R4,R4                                                    00022870
RDR9     CLI   PFILCOMP(AD),FILPLU                                      00022880
         BE    RDR10                                                    00022890
         CLI   PFILCOMP(AD),FILMIN                                      00022900
         BNE   RDR11                                                    00022910
         LCR   R3,R3                                                    00022920
RDR10    BAL   R5,FILGFE                                                00022930
RDR11    LA    R15,BADREAL         SET ERROR EXIT ADDRESS            #  00022940
RDR115   SR    R1,R1                                                 #  00022950
         IC    R1,PFILCOMP(AD)     GET CHARACTER                     #  00022960
         SH    R1,=AL2(FILZER)                                       #  00022970
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #  00022980
         CH    R1,=AL2(9)                                            #  00022990
         BHR   R15                                                   #  00023000
         MH    R4,=H'10'                                                00023010
         AR    R4,R1                                                    00023020
         BAL   R5,FILGFE                                                00023030
         BAL   R15,RDR115          LOOP BACK & SET EXIT ADDRESS      #  00023040
RDR12    LTR   R3,R3                                                    00023050
         BNM   *+6                                                      00023060
         LCR   R4,R4                                                    00023070
         A     R4,EXPONENT                                              00023080
RDR13    LTR   R4,R4                                                    00023090
         BZ    RDR16                                                    00023100
         BP    RDR14                                                    00023110
         LPR   R4,R4                                                    00023120
         B     RDR15                                                    00023130
RDR14    MD    0,=D'10.0'                                               00023140
         BCT   R4,RDR14                                                 00023150
         B     RDR16                                                    00023160
RDR15    DD    0,=D'10.0'                                               00023170
         BCT   R4,RDR15                                                 00023180
RDR16    STD   0,0(R2)             PUT THE RESULT IN PASCAL VARIABLE    00023190
         B     RTN                                                      00023200
*                                                                       00023210
*        WRR, REAL NUMBER IN FPRG2, FIELDWITH IN GRG3                   00023220
*                                                                       00023230
         DC    CL4'WRR'                                                 00023240
WRR      FILADR ,                                                       00023250
         SR    R2,R2         R2 <-- POWER OF 10                         00023260
         STC   R2,SIGN                                               &  00023270
         STC   R2,EFORM                                              &  00023280
         SDR   FPR0,FPR0                                             &  00023290
         ADR   FPR2,FPR0           FORCE NORMALIZATION               &  00023300
         BNZ   WRR20                                                    00023310
*                                                                       00023320
*        PRINT 'ZERO' IN THE PROPER FORMAT                              00023330
*                                                                       00023340
         LTR   R4,R4         'F' FORMAT ?                               00023350
         BP    WRR40                                                 &  00023360
*        E-FORMAT ZERO                                                  00023370
         MVI   PFILCOMP(AD),FILBLA                                      00023380
         BAL   R5,FILPST                                                00023390
         BAL   R5,FILPST                                                00023400
         SH    R3,=H'4'                                                 00023410
         LR    R4,R3                                                    00023420
         MVI   PFILCOMP(AD),FILZER                                      00023430
         BAL   R5,FILPST                                                00023440
         MVI   PFILCOMP(AD),FILDOT                                      00023450
         BAL   R5,FILPST                                                00023460
         MVI   PFILCOMP(AD),FILZER                                      00023470
         BAL   R5,FILPST                                                00023480
*        PRINT TRAILING BLANKS                                          00023490
         LTR   R4,R4                                                 &  00023500
         BNP   RTN                                                      00023510
         MVI   PFILCOMP(AD),FILBLA                                      00023520
         BALR  R5,0                SET RETURN ADDRESS FOR FILPST     &  00023530
         BCT   R4,FILPST           CALL REPEATEDLY                   &  00023540
         B     RTN                                                      00023550
*                                                                       00023560
*        PRINT A NON_ZERO REAL NUMBER                                   00023570
*                                                                       00023580
WRR20    BNM   WRR22                                                    00023590
         MVI   SIGN,X'01'    NEGATIVE VALUE, REMEMBER THE SIGN          00023600
         BCTR  R3,0          AND ADJUST FIELD WIDTH                     00023610
         LPDR  FPR2,FPR2                                                00023620
WRR22    LD    FPR0,=D'1.0E-12'                                         00023630
         MDR   FPR0,FPR2                                                00023640
         ADR   FPR2,FPR0                                                00023650
         LDR   FPR0,FPR2     SAVE THE ORIGINAL VALUE                    00023660
*                                                                       00023670
WRR24    CD    FPR2,=D'1.0'                                             00023680
         BNL   WRR26                                                    00023690
         MD    FPR2,=D'10.0'                                            00023700
         BCT   R2,WRR24                                                 00023710
WRR26    CD    FPR2,=D'10.0'                                            00023720
         BL    WRR30                                                    00023730
         DD    FPR2,=D'10.0'                                            00023740
         LA    R2,1(R2)                                                 00023750
         B     WRR26                                                    00023760
*                                                                       00023770
*        NOW WE HAVE  "1.0 <= FPR2 < 10"                                00023780
*        AND "FPR0 = FPR2 * (10 ** R2)"                                 00023790
*                                                                       00023800
WRR30    LTR   R4,R4         SEE IF F_FORMAT REQUESTED                  00023810
         BP    WRR40                                                    00023820
*        PRINT THE VALUE IN E_FORM                                      00023830
         MVI   EFORM,X'01'   SET E_FORMAT FLAG                          00023840
         ST    R2,EXPONENT   SAVE EXPONENT VALUE                        00023850
         MVI   PFILCOMP(AD),FILBLA                                      00023860
         BAL   R5,FILPST                                                00023870
         LR    R4,R3         R4 <-- FIELD WIDTH (AT LEAST 9)            00023880
         SH    R4,=H'7'                                                 00023890
         TM    SIGN,X'01'                                               00023900
         BNZ   WRR32                                                    00023910
         MVI   PFILCOMP(AD),FILBLA  PRINT UP TO TWO LEADING BLANKS      00023920
         BAL   R5,FILPST                                                00023930
         BCTR  R4,0                                                     00023940
WRR32    LTR   R4,R4                                                    00023950
         BP    *+8                                                      00023960
         LA    R4,1                                                     00023970
         SR    R2,R2         ONLY ONE DIGIT BEFORE DECIMAL POINT        00023980
         B     WRR50                                                    00023990
*                                                                       00024000
*        F_FORMAT OUTPUT                                                00024010
*                                                                       00024020
WRR40    LTR   R2,R2                                                    00024030
         BNM   WRR44         SEE IF NEGATIVE EXPONENT                   00024040
         LDR   FPR2,FPR0     IF SO, USE THE ORIGINAL VALUE              00024050
         SR    R2,R2         ONLY ONE DIGIT BEFORE DECIMAL POINT        00024060
*                                                                       00024070
WRR44    SR    R3,R4         COMPUTE THE # OF LEADING BLANKS            00024080
         BCTR  R3,0                                                  &  00024090
         SR    R3,R2                                                    00024100
         BNP   WRR50                                                    00024110
WRR46    MVI   PFILCOMP(AD),FILBLA                                      00024120
         BALR  R5,0                SET RETURN ADDRESS FOR FILPST     &  00024130
         BCT   R3,FILPST           CALL REPEATEDLY                   &  00024140
*                                                                       00024150
*        R2 # OF DIGITS BEFORE DECIMAL POINT                            00024160
*        R4 # OF DIGITS FOLLOWING DECIMAL POINT                         00024170
*                                                                       00024180
WRR50    TM    SIGN,X'01'                                               00024190
         BZ    WRR52                                                    00024200
         MVI   PFILCOMP(AD),FILMIN                                      00024210
         BAL   R5,FILPST                                                00024220
*                                                                       00024230
WRR52    LA    R2,2(R2)                                                 00024240
         BALR  R3,0                SET RETURN ADDRESS FOR WRRDGTS    &  00024250
         BCT   R2,WRRDGTS          CALL REPEATEDLY                   &  00024260
         MVI   PFILCOMP(AD),FILDOT                                      00024270
         BAL   R5,FILPST                                                00024280
         BAL   R3,WRRDGTS          SET RETURN ADDRESS FOR WRRDGTS    &  00024290
         BCT   R4,WRRDGTS          CALL REPEATEDLY                   &  00024300
         TM    EFORM,X'01'                                              00024310
         BZ    RTN                                                      00024320
*                                                                       00024330
*        PRINT THE EXPONENT FOR E_FORMAT OUTPUT                         00024340
*                                                                       00024350
         L     R4,EXPONENT                                              00024360
         MVI   PFILCOMP(AD),FILEXP                                      00024370
         BAL   R5,FILPST                                                00024380
         MVI   PFILCOMP(AD),FILPLU                                      00024390
         LTR   R4,R4                                                    00024400
         BNM   *+8                                                      00024410
         MVI   PFILCOMP(AD),FILMIN                                      00024420
         BAL   R5,FILPST                                                00024430
         LPR   R3,R4                                                    00024440
         SR    R2,R2                                                    00024450
         D     R2,=F'10'                                                00024460
         LA    R3,FILZER(R3)                                            00024470
         STC   R3,PFILCOMP(AD)                                          00024480
         BAL   R5,FILPST                                                00024490
         LA    R2,FILZER(R2)                                            00024500
         STC   R2,PFILCOMP(AD)                                          00024510
         BAL   R5,FILPST                                                00024520
         B     RTN                                                      00024530
*                                                                       00024540
*        THIS ROUTINE PRINTS THE NEXT DIGIT OF THE VALUE                00024550
*        IN FPR2, IT USES R3 FOR ITS RETURN ADDRESS                     00024560
*        IT IS ASSUMED THAT "0 <= FPR2 < 10" AND FPR2                   00024570
*        IS UPDATED FOR THE NEXT DIGIT                                  00024580
*                                                                       00024590
WRRDGTS  SR    R1,R1                                                 #  00024600
         LA    R1,1(R1)                                              #  00024610
         SD    FPR2,=D'1.0'                                          #  00024620
         BNM   WRRDGTS+2                                             #  00024630
         AD    FPR2,=D'1.0'                                          #  00024640
         LA    R1,FILZER-1(R1)                                       #  00024650
         STC   R1,PFILCOMP(AD)                                       #  00024660
         BAL   R5,FILPST           WRITE NEXT DIGIT                  #  00024670
         MD    FPR2,=D'10.0'                                         #  00024680
         BR    R3                 RETURN TO CALLER                      00024690
*                                                                       00024700
*                                                                       00024710
*        PAG   SKIP TO NEW PAGE                                         00024720
*                                                                       00024730
         DC    CL4'PAG'                                                 00024740
PAG      SR    R2,R2                                                 #  00024750
         BCT   R2,SKP1             SET R2 = -1, THEN USE SKP ROUTINE #  00024760
*                                                                    #  00024770
*                                                                    #  00024780
*        SKP - SKIP R2 INPUT OR OUTPUT LINES                         #  00024790
*                                                                    #  00024800
         DC    CL4'SKP'                                              #  00024810
SKP      LTR   R2,R2                                                 #  00024820
         BM    RTN                                                   #  00024830
SKP1     FILADR ,                                                    #  00024840
         TM    FILOPN(AE),TEXTFLAG                                   @  00024850
         BZ    SKP9                JUMP IF NOT A TEXT FILE           @  00024860
         TM    FILOPN(AE),READOPN                                    #  00024870
         BO    SKP7                JUMP IF AN INPUT FILE             #  00024880
         LA    R0,MAXSKIP                                            #  00024890
         CR    R2,R0                                                 #  00024900
         BL    *+6                 LIMIT NUMBER OF LINES TO "MAXSKIP"#  00024910
         LR    R2,R0                                                 #  00024920
         TM    DCBRECFM,X'06'      JUMP IF FILE DOES NOT HAVE        #  00024930
         BZ    SKP6                CARRIAGE CONTROL CHARS            #  00024940
         LA    R3,3                MAX NO. OF SKIPS PER RECORD       #  00024950
         TM    DCBRECFM,X'04'                                        #  00024960
         BNZ   SKP2                JUMP IF ANS CONTROL CHARS         #  00024970
         LTR   AF,AF               FORCE AN INITIAL PUT OPERATION IF #  00024980
         BNZ   SKP3                  NO I/O BUFFER YET ALLOCATED     #  00024990
SKP2     BAL   R5,FILPUT           CLEAR LINE BUFFER                 #  00025000
SKP3     CR    R2,R3                                                 #  00025010
         LR    R4,R2                                                 #  00025020
         BNH   *+6                                                   #  00025030
         LR    R4,R3               NOW, R4 = MIN( R2, 3 )            #  00025040
         SR    R1,R1                                                 #  00025050
         CLI   DCBRECFM,X'80'                                        #  00025060
         BNL   *+8                                                   #  00025070
         LA    R1,4                                                  #  00025080
*                                                                    #  00025090
         TM    DCBRECFM,X'04'                                        #  00025100
         BZ    SKP5                JUMP IF MACHINE CHARS             #  00025110
         IC    R0,SKPASCII(R4)                                       #  00025120
         STC   R0,0(R1,AF)         SET ASCII CONTROL CHAR            #  00025130
         SR    R2,R4                                                 #  00025140
         BP    SKP2                REPEAT IF MORE LINES TO SKIP      #  00025150
         LA    R1,1(R1)                                              #  00025160
         STH   R1,FILPTR(AE)       POINT AT FIRST DATA BYTE          #  00025170
         B     RTN                                                   #  00025180
SKP5     IC    R0,SKPMACH(R4)                                        #  00025190
         STC   R0,0(R1,AF)         SET MACHINE CONTROL CHAR          #  00025200
         BAL   R5,FILPUT           AND SEND TO OUTPUT DEVICE         #  00025210
         SR    R2,R4                                                 #  00025220
         BP    SKP3                REPEAT IF MORE LINES TO SKIP      #  00025230
         B     RTN                                                   #  00025240
SKP6     BAL   R5,FILPUT           NO CONTROL CHARS                  #  00025250
         BCTR  R2,0                BUT GIVE AN APPROPRIATE NUMBER    #  00025260
         LTR   R2,R2               OF EMPTY OUTPUT RECORDS           #  00025270
         BP    SKP6                                                  #  00025280
         B     RTN                                                   #  00025290
SKP7     LTR   R2,R2               REJECT PAGE() ON AN INPUT FILE    #  00025300
         BM    BADWRITE                                              #  00025310
         BNZ   SKP8                JUMP IF > 0 SKIPS                 #  00025320
         LH    R1,FILBEG(AE)                                         #  00025330
         STH   R1,FILPTR(AE)       RESET CHAR PTR. TO REREAD LINE    #  00025340
         IC    R0,0(R1,AF)                                           #  00025350
         STC   R0,PFILCOMP(AD)     RESET CURRENT FILE ELEMENT        #  00025360
         B     RTN                                                   #  00025370
SKP8     BAL   R5,FILGET                                             #  00025380
         BCT   R2,SKP8             STEP THROUGH THE LINES            #  00025390
         B     RTN                                                   #  00025400
*                                                                    @  00025410
SKP9     LTR   R2,R2                                                 @  00025420
         BNP   RTN                 RETURN IF SKIP COUNT NON-POSITIVE @  00025430
         TM    FILOPN(AE),READOPN                                    @  00025440
         BNZ   SKP11               JUMP IF AN INPUT FILE             @  00025450
         LH    R1,FILRSZ(AE)                                         @  00025460
         SLL   R1,16               CONSTRUCT A RDW                   @  00025470
         ST    R1,PFILRSZ(AD)      - IN CASE OF A V-FORMAT FILE      @  00025480
SKP10    PUT   FILDCB(AE),(AF)     WRITE A RECORD                    @  00025490
         BCT   R2,SKP10            REPEAT                            @  00025500
         B     RTN                                                   @  00025510
SKP11    GET   FILDCB(AE),(AF)                                       @  00025520
         LH    R1,DCBLRECL         GET RECORD LENGTH                 @  00025530
         CLI   DCBRECFM,X'80'                                        @  00025540
         BNL   SKP12               JUMP IF F OR U-FORMAT             @  00025550
         LH    R1,0(AF)            GET RECORD LENGTH FROM RDW        @  00025560
         SH    R1,=H'4'                                              @  00025570
SKP12    CH    R1,FILCSZ(AE)       CHECK FOR OVERFLOW                @  00025580
         BH    BADRECRD                                              @  00025590
         BCT   R2,SKP11                                              @  00025600
         ST    R1,PFILRSZ(AD)      SET CURRENT LENGTH                @  00025610
         B     RTN                                                   @  00025620
*                                                                       00025630
*                                                                       00025640
*        CLOCK FUNCTION                                                 00025650
*                                                                       00025660
         DC    CL4'CLK'                                                 00025670
CLK      LR    R3,R0              SAVE PARAMETER                        00025680
         TTIMER ,                                                       00025690
         S     R0,CLOCK            SUBTRACT START-UP TIME               00025700
         LPR   R0,R0               MAKE POSITIVE                        00025710
         LTR   R3,R3               TEST CLOCK PARAMETER                 00025720
         BP    RTN                 >0 MEANS RAW TIMER UNITS             00025730
         LPR   R1,R0                                                    00025740
         M     R0,=FS32'0.02604166'                                     00025750
         B     RTN                RETURNS THE RESULT IN R0              00025760
*                                                                       00025770
*                                                                       00025780
*        MESSAGE PROCEDURE   R2=STRING ADDR,  R3=LENGTH              #  00025790
*                                                                    #  00025800
         DC    CL4'MSG'                                              #  00025810
MSG      LTR   R3,R3                                                 #  00025820
         BNP   RTN                                                   #  00025830
         LA    R0,L'MSGBUF-8       SET MAX. MESSAGE LENGTH           @  00025840
         CR    R3,R0                                                 #  00025850
         BNH   *+6                                                   #  00025860
         LR    R3,R0                                                 #  00025870
         EX    R3,MSGMVC                                             #  00025880
         LA    R3,4(R3)            CONSTRUCT VARIABLE-LENGTH RECORD  #  00025890
         STH   R3,MSGBUF                                             #  00025900
         LA    R3,MSGBUF(R3)                                         @  00025910
         MVC   0(4,R3),=X'00000020' SET THE ROUTING CODE             #  00025920
         MVC   MSGBUF+2(2),=X'8000'                                  @  00025930
         LA    R1,MSGBUF                                             @  00025940
         SVC   35                  ISSUE WTO REQUEST                 #  00025950
         B     RTN                                                   #  00025960
MSGMVC   MVC   MSGBUF+4(*-*),0(R2)                                   @  00025970
*                                                                       00025980
*        CTR, TO ALLOCATE AND CLEAR 'R2' RUN TIME 'COUNTERS'            00025990
*                                                                       00026000
         DC    CL4'CTR'                                                 00026010
CTR      L     R3,HEAPLIM                                               00026020
         USING DYN2STOR,R3                                              00026030
         ST    R2,DYNRUNC          SET THE # OF COUNTERS                00026040
         DROP  R3                                                       00026050
         SLA   R2,2                CONVERT COUNT TO BYTES               00026060
         LR    R4,R3               POINT TO HEAP END                    00026070
         SR    R4,R2               LOWER IT TO ITS NEW POSITION         00026080
         ST    R4,HEAPLIM          AND SAVE THE NEW HEAP LIMIT PTR      00026090
*                                                                       00026100
         SR    R5,R5               ASSUME NO OS PARMATER AREA           00026110
         L     R6,OSPRMPTR                                              00026120
         LTR   R6,R6               SEE IF THAT IS THE CASE              00026130
         BM    CTR10                                                    00026140
         LR    R5,R3               IF NOT, FIND THE LENGTH OF           00026150
         SR    R5,R6               THE OS PARM AREA                     00026160
         SR    R3,R5               AND ADJUST 'TO' AND 'FROM' PTRS      00026170
         SR    R4,R5                                                    00026180
         ST    R4,OSPRMPTR                                              00026190
CTR10    LA    R5,DYNCOUNT-DYN2STOR(R5)   ADD THE SIZE OF FIXED AREA    00026200
*        AN EXTRA BYTE IS MOVED BUT IT IS OK.                           00026210
         EX    R5,CTRMVE           AND COPY FROM THE OLD AREA.          00026220
         ST    R4,NEWPTR           UPDATE HEAP PTR                      00026230
         AR    R4,R5               POINT BACK TO THE HEAP END           00026240
         SRA   R2,2                CONVERT BACK BYTES TO WORDS          00026250
         SR    R0,R0                                                    00026260
         ST    R0,0(R4)            AND CLEAR THE COUNTER AREA           00026270
         LA    R4,4(R4)            ADJUST THE POINTER                   00026280
         BCT   R2,*-8              REPEAT AS NEEDED                     00026290
         B     RTN                                                      00026300
*                                                                       00026310
CTRMVE   MVC   0(0,R4),0(R3)                                            00026320
*                                                                       00026330
*                                                                    #  00026340
*        LINELIMIT PROCEDURE   AD=FILE,  R2=LIMIT                    #  00026350
*                                                                    #  00026360
         DC    CL4'LIM'                                              #  00026370
LIM      FILADR ,                                                    #  00026380
         ST    R2,FILLIM(AE)       SET THE NEW LIMIT                 #  00026390
         B     RTN                                                   #  00026400
*                                                                       00026410
*                                                                       00026420
*        DEFINE A FILE,  R2: NAME,  R3: FILE COMP. SIZE              @  00026430
*                                                                       00026440
         DC    CL4'FDF'                                                 00026450
FDF      DS    0H                                                       00026460
         GETMAIN EC,LV=L'#FILREC,A=(AD)                              @  00026470
         LTR   R15,R15             TEST IF STORAGE AVAILABLE         #  00026480
         BNZ   BADFDF                                                #  00026490
         L     AE,0(,AD)                                             @  00026500
         LA    R1,#FILREC          TEMPLATE FOR TEXT FILES           @  00026510
         LTR   R3,R3               R3=0 => A TEXT FILE               @  00026520
         BZ    *+8                 JUMP IF A TEXT FILE               @  00026530
         LA    R1,#NONTXT          TEMPLATE FOR NON-TEXT FILES       @  00026540
         MVC   0(L'#FILREC,AE),0(R1)  COPY TO GETMAINED AREA         @  00026550
         STH   R3,FILCSZ(AE)       SAVE FILE COMP. SIZE              @  00026560
         ST    AD,FILPAS(AE)       SET BACK LINK                     @  00026570
         L     R1,FILLIST                                            @  00026580
         ST    R1,FILLNK(AE)       LINK NEW FILE BLOCK               @  00026590
         ST    AE,FILLIST          INTO THE CHAIN                    @  00026600
         OI    FILLIST,X'80'       FLAG AS NOT BUILT-IN              @  00026610
         MVC   FILNAM(8,AE),0(R2)                                    @  00026620
         MVC   DCBDDNAM,0(R2)      MOVE THE FILE NAME TO ITS DCB FIELD  00026630
         B     RTN                                                      00026640
*                                                                       00026650
*        REQUEST FOR CONTROL TRACE OUTPUT                            &  00026660
*                                                                       00026670
TRA      EQU   *                                                     &  00026680
         AIF   (&SYSTEM).SYS920                                      &  00026690
         LTR   R2,R2                                                 &  00026700
         BP    *+6                                                   &  00026710
         SR    R2,R2               KILL OUTPUT REQUEST               &  00026720
         LA    R2,1(,R2)                                             &  00026730
         L     R15,=A(TRLINES)                                       &  00026740
         ST    R2,0(,R15)                                            &  00026750
.SYS920  ANOP                                                           00026760
         B     RTN                                                   &  00026770
*                                                                       00026780
*        GENERAL ROUTINE TO CLOSE A FILE                             #  00026790
*                                                                    #  00026800
FILCLS   TM    FILOPN(AE),READOPN+WRITEOPN                           @  00026810
         BZR   R5                  RETURN IF FILE NOT OPEN           #  00026820
         TM    FILOPN(AE),TEXTFLAG+WRITEOPN                          @  00026830
         BNO   FILCLS4             JUMP IF NONTEXT OR INPUT FILE     @  00026840
*                                                                    #  00026850
*        PREPARE THE OUTPUT BUFFER FOR TRANSMITTING TO O.S.          #  00026860
*FILCLS1                                                             #  00026870
         LH    R1,FILPTR(AE)       IF BUFFER IS IN "OVER-FULL" STATE @  00026880
         CH    R1,FILEND(AE)       WE MUST WRITE A RECORD NOW - IN   @  00026890
         BNH   FILCLS15            ORDER TO GET THE EXTRA BLANK LINE @  00026900
         ST    R5,FILCLSSV         WHEN THE FILE IS CLOSED.          @  00026910
         BAL   R5,FILPUT                                             @  00026920
         L     R5,FILCLSSV                                           @  00026930
FILCLS15 LH    R1,FILPTR(AE)                                         @  00026940
         CLI   DCBRECFM,X'80'                                        #  00026950
         BNL   FILCLS4             RETURN IF F OR U-FORMAT           #  00026960
         LA    R0,6                MIN LENGTH FOR VBA RECORDS        #  00026970
         TM    DCBRECFM,X'06'                                        #  00026980
         BNZ   *+6                 JUMP IF CONTROL CHARS             #  00026990
         BCTR  R0,0                ADJUST MIN LENGTH                 #  00027000
         CR    R1,R0                                                 #  00027010
         BNL   FILCLS2             JUMP IF RECORD SIZE OK            #  00027020
         LTR   AF,AF               RETURN IF THE I/O BUFFER IS NOT   #  00027030
         BZ    FILCLS4             ALLOCATED  (FILE NEWLY OPENED)    #  00027040
         LA    R0,FILBLA                                             #  00027050
         STC   R0,0(R1,AF)         PROVIDE 1 CHAR AT LEAST           #  00027060
         LA    R1,1(R1)                                              #  00027070
         AIF   (&IBM370).M715                                        @  00027080
FILCLS2  STC   R1,1(AF)            SET RDW FOR V-FORMAT, ONE BYTE       00027090
         SRA   R1,8                AT A TIME TO MAKE 360S HAPPY         00027100
         STC   R1,0(AF)                                                 00027110
         AGO   .M615                                                    00027120
.M715    ANOP  ,                                                     @  00027130
FILCLS2  STCM  R1,3,0(AF)          SET RDW FOR V-FORMAT              @  00027140
.M615    ANOP  ,                                                     @  00027150
*                                                                    #  00027160
FILCLS4  LA    AG,FILDCB(AE)                                         #  00027170
         CLOSE ((AG))                                                #  00027180
         TM    DCBBUFCB+3,1        TEST IF BUFFER POOL THERE         #  00027190
         BOR   R5                  RETURN IF NOT                     #  00027200
         FREEPOOL (AG)             RELEASE THE POOL                  #  00027210
         BR    R5                                                    #  00027220
*                                                                       00027230
*                                                                       00027240
*        EXIT : TO EXIT USER PROGRAM WITH A RETURN CODE                 00027250
*                                                                       00027260
         DC    CL4'XIT'                                                 00027270
XIT      C     R2,=A(1000)         IF ERROR GO TO CLOSE/EXIT ROUTINE    00027280
         BNL   CLS                                                      00027290
         L     R4,HEAPLIM                                               00027300
         USING DYN2STOR,R4                                              00027310
         L     R5,DYNRUNC                                               00027320
         LTR   R5,R5               SEE IF RUN TIME COUNTERS ARE PRESENT 00027330
         BNP   CLS                 IF NOT, QUIT.                        00027340
         LR    R6,R2               SAVE RETURN CODE                     00027350
         LA    AD,QRR              PICK THE COUNTER FILE NAME           00027360
         LA    R1,PREW                                                  00027370
         LA    R15,$PASCSP                                              00027380
         BALR  R14,R15             CALL THE $PASCSP ROUTINES            00027390
*                                                                       00027400
*        THIS CAN BE DONE ONLY IF WE KNOW THAT WE DO NOT NEED           00027410
*        TO GO BACK TO THE PROGRAM WHICH CALLED THE EXIT                00027420
*        ROUTINE.                                                       00027430
*                                                                       00027440
         LA    R1,PWRI             SET THE FUNCTION CODE                00027450
         LA    R3,10               SET THE FIELD_WIDTH                  00027460
NXTCNT   L     R2,DYNCOUNT         PICK THE NEXT COUNT VALUE            00027470
         BALR  R14,R15             OUTPUT IT                            00027480
         LA    R4,4(R4)                                                 00027490
         BCT   R5,NXTCNT           REPEAT UNTIL DONE                    00027500
         DROP  R4                                                       00027510
*                                                                       00027520
         LA    R1,PWLN                                                  00027530
         BALR  R14,R15             OUTPUT THE LAST LINE                 00027540
         MVI   PROFFLAG,X'FF'      SET FLAG TO INDICATE PASPROF CALL @  00027550
         LR    R2,R6               RESTORE RETURN CODE                  00027560
         B     CLS                 GO TO COMPLETE EXIT EPILOGUE.        00027570
*                                                                       00027580
*       CLOSE ALL THE FILES                                             00027590
*                                                                       00027600
         DC    CL4'CLS '                                                00027610
CLS      L     AE,FILLIST                                            @  00027620
CLSB1    L     AF,FILBUF(AE)                                         #  00027630
         BAL   R5,FILCLS           GO AND DO A FILE CLOSE            #  00027640
         L     R3,FILLNK(AE)       GET POINTER TO NEXT BLOCK         @  00027650
         LTR   AE,AE               TEST IF BUILT-IN FILE             @  00027660
         BNM   CLSF1               IF SO, JUMP                       #  00027670
         FREEMAIN R,LV=L'#FILREC,A=(AE)  RELEASE FILE BLOCK STORAGE  #  00027680
CLSF1    LTR   AE,R3               FOLLOW CHAIN OF FILE BLOCKS       @  00027690
         BNZ   CLSB1               REPEAT                            @  00027700
*                                                                       00027710
*        TIME TO EXIT                                                   00027720
*                                                                       00027730
         L     R1,=A(OLDPICA)                                           00027740
         TM    3(R1),1             TEST IF SPIE WAS ISSUED           #  00027750
         BO    SKIPSPIE            JUMP IF NOT                       #  00027760
         L     1,0(R1)             RESET OLD PICA ADDRESS            #  00027770
         SPIE  MF=(E,(1))          TO CANCEL ANY PASCAL SPIE         #  00027780
SKIPSPIE EQU   *                                                     #  00027790
*                                                                       00027800
*        CHECK FOR ABEND                                                00027810
*                                                                       00027820
         C         R2,=A(1000)     IF RETURN CODE < 1000                00027830
         BL        XIT2              THEN DON'T ABEND                   00027840
         L         R1,=A(DUMPFLAG)                                    & 00027850
         CLI       0(R1),X'FF'     TEST IF O.S. DUMP REQUESTED       &  00027860
         BNE       XIT2                                                 00027870
         LA    R1,X'FFF'                                             @  00027880
         NR    R1,R2                                                 @  00027890
         O     R1,=A(X'80000000')                                       00027900
         SVC   13                                                       00027910
XIT2     C     R2,=A(TIMERR)       SEE IF THIS IS A TIME OUT EXIT       00027920
         BE    XIT3                                                     00027930
         C     R2,=A(TIMERR+SNPERR)                                     00027940
         BNE   XIT4                                                     00027950
*                                                                       00027960
*        THIS ABEND IS BECAUSE THERE IS NO CLEAN AND EASY WAY           00027970
*        TO TERMINATE THE PROGRAM IN CASE OF A TIMER INTERRUPT !        00027980
*                                                                       00027990
XIT3     ABEND (R2)                                                     00028000
*                                                                       00028010
XIT4     LR    R13,R12             POINT TO STACK BASE               #  00028020
         S     R13,=A(STACK-DYNSTORE)                                #  00028030
         L     R15,=V(IBCOM#)      IS FORTRAN PRESENT ?                 00028040
         LTR   R15,R15                                                  00028050
         BZ    XIT6                                                     00028060
*                                                                       00028070
*        NOTE: THE IBCOME 'EXIT' ROUTINE USES THE SAVE AREA PASSED      00028080
*        TO THE IBCOM INIT ROUTINE. THE FOLLOWING PATCH SHOULD          00028090
*        ENSURE RETURNING TO 'XIT6' AFTER CLOSING FORTRAN I/O AND       00028100
*        CANCELING IBCOM 'SPIE' AND 'STAE'.                             00028110
*                                                                       00028120
         LA    R14,XIT6            IF SO, SET THE RETURN ADDRESS        00028130
         STM   R14,R12,12(R13)     SET 'RESTORE' AREA FOR THE CALL      00028140
         BAL   R14,IBCOMXIT(R15)   TO IBCOM# XIT ROUTINE.               00028150
         DC    AL2(0)              RETURN CODE FOR ABOVE CALL           00028160
XIT6     L     R13,4(R13)          POINT TO THE SYSTEM SAVE AREA     #  00028170
         FREEMAIN V,A=ALOSTORE     RELEASE STACK STORAGE             #  00028180
         TM    PROFFLAG,X'FF'                                        @  00028190
         BNZ   CALLPROF            JUMP IF PASPROF TO BE INVOKED     @  00028200
         LR    R15,R2              SET THE RETURN CODE               #  00028210
         L     R14,12(R13)         PICK THE RETURN ADDRESS              00028220
         LM    R0,R12,20(R13)      RESTORE OTHER REGS                   00028230
         BR    14                                                       00028240
CALLPROF L     R1,=A(OSPARMS)      GIVE PASPROF SAME PARAMETERS      @  00028250
         L     R1,0(,R1)           AS WE WERE GIVEN                  @  00028260
         L     R14,12(,R13)        SET JUST R14 (XCTL SETS REST)     @  00028270
         XCTL  (2,12),EP=PASPROF   INVOKE THE PROFILER MODULE        @  00028280
*                                                                       00028290
*                                                                       00028300
*        UNDEFINED CSP ENTRIES                                          00028310
*                                                                       00028320
TRP      DS    0H                                                       00028330
SIO      DS    0H                                                       00028340
EIO      DS    0H                                                       00028350
EOF      DS    0H                                                       00028360
ELN      DS    0H                                                       00028370
RDD      DS    0H                                                       00028380
WRD      DS    0H                                                       00028390
WRE      DS    0H                                                       00028400
         B     UNDFERR             REPORT AN ERROR                   @  00028410
*                                                                       00028420
*                                                                       00028430
*                                                                       00028440
*         RETURN TO PASCAL PROGRAM                                      00028450
*                                                                       00028460
RTN      LM    R1,R15,SPUSERSA      'RSLT' REG SHOULD NOT BE RESTORED ! 00028470
         AIF   (&SYSTEM).SYS92                                          00028480
         DROP  ,                                                        00028490
         USING $PASCSP,R15                                              00028500
         MVI   SPUSERSA,X'FF'      CLEAR 'SP' FLAG                      00028510
.SYS92   ANOP                                                           00028520
         BR    14                                                       00028530
*                                                                       00028540
*        I/O ERROR CONDITIONS, ETC.                                     00028550
*                                                                       00028560
         DROP  ,                                                        00028570
         USING $PASCSP,R10                                           @  00028580
         USING $PASCSP+4092,R11                                      @  00028590
         USING STACK,GBR                                                00028600
BADFDF   LA    R14,FDFMSG                                            @  00028610
         LA    AE,FILUNK           PROVIDE A FILE                    *  00028620
         MVC   FILNAM(8,AE),0(R2)      WITH RIGHT NAME               *  00028630
         B     ERRMSGRT                                              #  00028640
UNDFERR  LA    R14,UNDFMSG                                           @  00028650
         B     ERRMSGRT                                              #  00028660
LIMITERR LA    R14,LIMMSG                                            @  00028670
         B     ERRMSGRT                                              #  00028680
BADREAD  LA    R14,READMSG                                           @  00028690
         B     ERRMSGRT                                              #  00028700
EOFREAD  LA    R14,EOFMSG                                            @  00028710
         B     ERRMSGRT                                              #  00028720
BADBOOL  LA    R14,BOOLMSG                                           @  00028730
         B     ERRMSGRT                                              #  00028740
BIGINT   LA    R14,BIGMSG                                               00028750
         B     ERRMSGRT                                                 00028760
BADINT   LA    R14,INTMSG                                            @  00028770
         B     ERRMSGRT                                              #  00028780
BADREAL  LA    R14,REALMSG                                           @  00028790
         B     ERRMSGRT                                              #  00028800
BADRECRD LA    R14,RECRDMSG                                          @  00028810
         B     ERRMSGRT                                              @  00028820
BADFILE  LA    R14,FILERMSG                                          @  00028830
         L     AE,FILLIST          SEARCH FOR CORRECT FILE BLOCK     @  00028840
BF1      C     AD,FILPAS(AE)                                         @  00028850
         BE    ERRMSGRT            EXIT IF FOUND                     @  00028860
         L     AE,FILLNK(AE)       OTHERWISE TRY NEXT FILE           @  00028870
         LTR   AE,AE                                                 @  00028880
         BNZ   BF1                 REPEAT LOOP                       @  00028890
         LA    AE,FILUNK           NOT FOUND - SO PROVIDE            @  00028900
         B     ERRMSGRT            A DUMMY FILE BLOCK INSTEAD        @  00028910
BADWRITE LA    R14,WRITEMSG                                          @  00028920
*        B     ERRMSGRT                                              #  00028930
ERRMSGRT LH    R3,0(,R14)          GET MESSAGE LENGTH                @  00028940
         LA    R2,4(,R14)          ADDR OF TEXT FOR MESSAGE          @  00028950
         LPR   R4,R3                                                 @  00028960
         EX    R4,MSGMVC           MOVE MESSAGE INTO BIG BUFFER      @  00028970
         LTR   R3,R3               R3 < 0 => PROBLEM WITH A FILE     @  00028980
         BNM   ERR0                JUMP IF OTHER THAN A FILE ERROR   @  00028990
         LA    R5,MSGBUF+4(R4)                                       @  00029000
         MVC   0(26,R5),=C' (PASCAL FILE =         ) '                  00029010
         MVC   16(8,R5),FILNAM(AE)   MOVE FILE NAME INTO MSG         @  00029020
         LA    R4,26(,R4)          NEW MESSAGE LENGTH                @  00029030
         LA    R0,OUTPUT                                             @  00029040
         CR    AD,R0               TEST IF FILE IS "OUTPUT"          @  00029050
         BNE   ERR0                IF NOT, CARRY ON AND PRINT MESSAGE@  00029060
         MVC   MSGBUF+2(2),=X'8000'                                  @  00029070
         LA    R4,4(,R4)           CONSTRUCT VARIABLE LENGTH RECORD  @  00029080
         STH   R4,MSGBUF                                             @  00029090
         LA    R3,MSGBUF(R4)                                         @  00029100
         MVC   0(4,R3),=X'00000020'  SET ROUTING CODE                @  00029110
         LA    R1,MSGBUF                                             @  00029120
         SVC   35                  ISSUE WTO REQUEST                 @  00029130
         L     R14,QUITADR         GET ERROR EXIT ADDRESS            @  00029140
         BR    R14                 AND GO TO IT                      @  00029150
ERR0     LA    R3,MSGBUF+4         NEW MESSAGE ADDRESS                  00029160
ERR2     LH    R8,2(,R14)          ERROR CODE                        @  00029170
         L     R15,=A($CHKMSG)     WHERE TO GO NEXT                  @  00029180
         LM    R1,R2,SPUSERSA      RESTORE MOST OF THE               @  00029190
         LM    R5,R7,SPUSERSA+16   USER'S REGISTERS                  @  00029200
         LM    R9,R14,SPUSERSA+32                                    @  00029210
         BR    R15                                                   @  00029220
*                                                                    #  00029230
*                                                                       00029240
*        EXIT ROUTINE CALLED WHEN DCB IS OPENED                      #  00029250
*              IN THIS ROUTINE, WE PROVIDE SOME REASONABLE DEFAULTS  #  00029260
*              FOR THE RECFM, LRECL, BLKSIZE AND BUFNO ATTRIBUTES    #  00029270
*              THIS ROUTINE ALSO SETS THE REREAD FLAG WHEN NEEDED    #  00029280
*              AT THE CHANGE-OVER BETWEEN TWO CONCATENATED           #  00029290
*              INPUT FILES.                                          #  00029300
*                                                                    #  00029310
         DROP  ,                                                     &  00029320
         USING XLSTRTOT,R15                                          &  00029330
         USING IHADCB,R1                                             &  00029340
         USING STACK,GBR                                             &  00029350
XLSTRTOT LA    R5,DEFAULTS         ENTRY FOR OUTPUT DCB'S            &  00029360
         LA    R0,OUTPUT                                             #  00029370
         CR    AD,R0               TEST IF FILE IS "OUTPUT"          @  00029380
         BNE   *+8                 IT USES DIFFERENT DEFAULTS        &  00029390
         LA    R5,OUTDFLTS                                           #  00029400
         BAL   R15,XLSTRT2         RESET BASE REGISTER & TRANSFER    &  00029410
         USING XLSTRTIN,R15                                          &  00029420
XLSTRTIN LA    R5,DEFAULTS         ENTRY FOR INPUT AND INOUT FILES   #  00029430
         TM    DCBOFLGS,X'08'      TEST IF CONCAT. FLAG SET          #  00029440
         BZ    XLSTRT1                                               #  00029450
         MVI   RRFLAG,X'FF'        REQUEST A REREAD                  #  00029460
         B     XLSTRT2                                               #  00029470
XLSTRT1  OI    DCBOFLGS,X'08'      REQUEST PROCESSING OF CONCAT FILES#  00029480
XLSTRT2  SR    R4,R4                                                 #  00029490
         CLI   DCBBUFNO,0                                            #  00029500
         BNE   XLSTRT3             JUMP IF BUFNO PROVIDED            #  00029510
         MVC   DCBBUFNO(1),4(R5)                                     #  00029520
XLSTRT3  TM    DCBRECFM,X'FE'                                        #  00029530
         BNE   XLSTRT4             JUMP IF RECFM SPECIFIED           #  00029540
         OC    DCBRECFM(1),5(R5)                                     #  00029550
XLSTRT4  LH    R3,0(R5)            LOAD TARGET BYTES PER RECORD      #  00029560
         TM    FILOPN(AE),TEXTFLAG                                   IF 00029570
         BNZ   XLSTRT47            JUMP IF A TEXT FILE               @  00029580
         LH    R3,FILCSZ(AE)       GET FILE COMPONENT SIZE           @  00029590
         LA    AF,PFILCOMP(AD)                                       @  00029600
         CLI   DCBRECFM,X'80'                                        @  00029610
         BNL   XLSTRT45            JUMP IF RECFM=F OR U              @  00029620
         LA    R3,4(,R3)           ADD IN 4 BYTES FOR RDW            @  00029630
         S     AF,=F'4'            AND CORRECT BUFFER ADDRESS        @  00029640
XLSTRT45 ST    AF,FILBUF(AE)                                         @  00029650
         STH   R3,FILRSZ(AE)       SAVE CORRECT RECORD SIZE          @  00029660
         CH    R4,DCBLRECL                                           #  00029670
         BNE   XLSTRT5             JUMP IF LRECL SPECIFIED           #  00029680
         B     XLSTRT49            GO AND SET THE LRECL              @  00029690
XLSTRT47 CH    R4,DCBLRECL                                           @  00029700
         BNE   XLSTRT5             JUMP IF LRECL SPECIFIED           @  00029710
         TM    DCBRECFM,X'C0'                                        #  00029720
         BO    XLSTRT5             JUMP IF U-FORMAT (LEAVE LRECL=0)  #  00029730
         CLI   DCBRECFM,X'80'                                        #  00029740
         BNL   *+8                 JUMP IF F-FORMAT                  #  00029750
         LA    R3,4(R3)            ALLOW FOR RDW/SDW IN RECORD LENGTH#  00029760
         TM    DCBRECFM,X'06'                                        #  00029770
         BZ    *+8                 JUMP IF NO CONTROL CHAR.          #  00029780
         LA    R3,1(R3)            ADD IN 1 BYTE FOR CONTROL CHAR    #  00029790
XLSTRT49 STH   R3,DCBLRECL                                           #  00029800
XLSTRT5  CH    R4,DCBBLKSI                                           #  00029810
         BNER  R14            RETURN IF BLKSIZE SPECIFIED            #  00029820
         LH    R5,2(R5)       LOAD TARGET BLKSIZE                    #  00029830
         CLI   DCBRECFM,X'80'                                        #  00029840
         BNL   XLSTRT6        JUMP IF NOT V-FORMAT                   #  00029850
         LA    R3,4(R3)       LRECL+4 IS MINIMUM BLKSIZE             #  00029860
         B     XLSTRT7                                               #  00029870
XLSTRT6  TM    DCBRECFM,X'C0'                                        #  00029880
         BO    XLSTRT8        JUMP IF RECFM=U                        #  00029890
         DR    R4,R3          THEREFORE, RECFM=F HERE                #  00029900
         MR    R4,R3                                                 #  00029910
XLSTRT7  CR    R5,R3                                                 #  00029920
         BL    XLSTRT8                                               #  00029930
         LR    R3,R5                                                 #  00029940
XLSTRT8  STH   R3,DCBBLKSI                                           #  00029950
         BR    R14                                                   #  00029960
*                                                                       00029970
         USING SYNADRT,R15                                           &  00029980
         DROP  R1                                                    &  00029990
SYNADRT  LA    R3,OUTPUT      GENERATES MESSAGES FOR FILE ERRORS     &  00030000
         CR    AD,R3          CHECK IF PROBLEM WITH OUTPUT FILE      @  00030010
         BNE   *+8                 JUMP IF NOT OUTPUT FILE           @  00030020
         ST    R14,QUITADR         SAVE ERROR EXIT ADDRESS           @  00030030
         SYNADAF ACSMETH=QSAM GENERATE THE ERROR DESCRIPTION         #  00030040
         MVC   SYNMSG+5(78),50(R1)   AND MOVE IT INTO LOCAL BUFFER   #  00030050
         SYNADRLS ,           NOW RELEASE THE SYSTEM'S BUFFER        #  00030060
         LA    R14,SYNMSG                                            @  00030070
         L     R10,=A($PASCSP)     RESET SOME BASE REGS.             &  00030080
         LA    R11,4092(,R10)      (JUST IN CASE)                    &  00030090
         USING $PASCSP,R10                                           &  00030100
         USING $PASCSP+4092,R11                                      &  00030110
         DROP  R15                                                   &  00030120
         B     ERRMSGRT                                              #  00030130
*                                                                       00030140
         DROP  ,                                                        00030150
*                                                                       00030160
*          VARIOUS TABLE AND DCB DEFINITIONS                            00030170
*                                                                       00030180
DECTBL   DC    D'0,1,2,3,4,5,6,7,8,9'                                   00030190
PINT     DS    D                   PACKED INTEGER BUFFER                00030200
         DC    20AL1(FILBLA)                                            00030210
ZINT     DS    CL12                ZONED INTEGER BUFFER                 00030220
*                                                                    #  00030230
*              DCB EXIT LIST PARAMETERS                              #  00030240
*                                                                    #  00030250
         DS    0F                                                       00030260
XLINPUT  DC    X'85',AL3(XLSTRTIN)                                   #  00030270
XLINOUT  EQU   XLINPUT                                               #  00030280
XLOUTPUT DC    X'85',AL3(XLSTRTOT)                                   #  00030290
*                                                                    #  00030300
*        DEFAULT AND TARGET VALUES FOR FILES OTHER THAN "OUTPUT"     #  00030310
*                                                                    #  00030320
DEFAULTS DC    H'80'               TARGET DATA BYTES PER RECORD      #  00030330
         DC    H'1600'             TARGET BYTES PER BLOCK            #  00030340
         DC    AL1(3)              DEFAULT BUFNO VALUE               #  00030350
         DC    X'50'               DEFAULT RECFM = VB                #  00030360
*                                                                    #  00030370
*        DEFAULT AND TARGET VALUES FOR "OUTPUT" FILE                 #  00030380
*                                                                    #  00030390
OUTDFLTS DC    H'132'              TARGET DATA BYTES PER RECORD      #  00030400
         DC    H'1600'             TARGET BYTES PER BLOCK            #  00030410
         DC    AL1(5)              DEFAULT BUFNO VALUE               #  00030420
         DC    X'54'               DEFAULT RECFM = VBA               #  00030430
*                                                                    #  00030440
MAXSKIP  DC    F'60'               MAXIMUM NUMBER OF LINES TO SKIP   #  00030450
SKPASCII EQU   *+1                 TABLE OF ASCII CONTROL CHARS      #  00030460
         DC    C'1+ 0-'                                              #  00030470
SKPMACH  EQU   *+1                 TABLE OF MACHINE CONTROL CHARS    #  00030480
         DC    X'8901091119'                                         #  00030490
RRFLAG   DC    X'00'               REREAD FLAG                       #  00030500
PROFFLAG DC    X'00'               CALL PROFILE MODULE FLAG          @  00030510
SIGN     DC    C' '                                                     00030520
EFORM    DC    C' '                                                     00030530
CCFLAG   DC    X'00'               SET BY NOCC O.S. PARM STRING      #  00030540
FILPSTSV DC    A(0)                                                     00030550
FILCLSSV DC    A(0)                                                     00030560
EXPONENT DC    F'0'                                                     00030570
QUITADR  DC    A(XIT)                                                @  00030580
*                                                                       00030590
READMSG  DC    H'-25',AL2(INPERR),C' INVALID INPUT OPERATION '       @  00030600
WRITEMSG DC    H'-26',AL2(OUTERR),C' INVALID OUTPUT OPERATION '      @  00030610
FDFMSG   DC    H'-25',AL2(FDFERR),C' INVALID FILE DEFINITION '       @  00030620
UNDFMSG  DC    H'31',AL2(NDFERR),C' CALL TO UNDEF. STANDARD PROC. '  @  00030630
LIMMSG   DC    H'-26',AL2(LIMERR),C' LINELIMIT VALUE EXCEEDED '      @  00030640
EOFMSG   DC    H'-24',AL2(EOFERR),C' ILLEGAL READ AFTER EOF '        @  00030650
BOOLMSG  DC    H'-21',AL2(BOLERR),C' BAD BOOLEAN ON INPUT '          @  00030660
INTMSG   DC    H'-21',AL2(INTERR),C' BAD INTEGER ON INPUT '          @  00030670
BIGMSG   DC    H'-29',AL2(BIGERR),C' OVER-LARGE INTEGER ON INPUT '      00030680
REALMSG  DC    H'-18',AL2(RELERR),C' BAD REAL ON INPUT '             @  00030690
FILERMSG DC    H'-28',AL2(FILERR),C' INVALID FILE CONTROL BLOCK '    @  00030700
RECRDMSG DC    H'-24',AL2(RCDERR),C' INPUT RECORD TOO LARGE '        @  00030710
SYNMSG   DC    H'-79',AL2(SYNERR),CL79' '                            @  00030720
         DS    0H                                                       00030730
MSGBUF   DC    CL128' '             BUFFER FOR WTO MESSAGES          @  00030740
         LTORG ,                                                        00030750
*                                                                       00030760
FILLIST  DC    A(FILINP)           HEAD POINTER FOR CHAIN OF FILES   @  00030770
         PRINT NOGEN               TURN OFF DCB EXPANSIONS           #  00030780
*                                                                       00030790
*        FILE CONTROL BLOCKS                                         @  00030800
*                                                                       00030810
         FILDEF INPUT,INPUT,TEXT,FILOUT                              @  00030820
         FILDEF OUTPUT,OUTPUT,TEXT,FILPRD                            @  00030830
         FILDEF PRD,INOUT,TEXT,FILPRR                                @  00030840
#FILREC  EQU   FILPRD,*-FILPRD     FILE RECORD TEMPLATE                 00030850
         FILDEF PRR,INOUT,TEXT,FILQRD                                @  00030860
         FILDEF QRD,INOUT,TEXT,FILQRR                                @  00030870
         FILDEF QRR,INOUT,TEXT,0                                     @  00030880
         FILDEF UNKNOWN,INOUT,NONTEXT,0                              @  00030890
#NONTXT  EQU   FILUNK,*-FILUNK     NON-TEXT FILE TEMPLATE            @  00030900
**************************************************************          00030910
*                                                                       00030920
*        END OF $PASCSP MODULE                                          00030930
*                                                                       00030940
**************************************************************          00030950
         SPACE 3                                                        00030960
*        GLOBAL DEFINITIONS                                             00030970
*                                                                       00030980
*                                                                       00030990
*                                                                       00031000
*                                                                       00031010
*        REGISTER ASSIGNMENTS                                           00031020
*                                                                       00031030
R0       EQU   0                                                        00031040
R1       EQU   1                                                        00031050
R2       EQU   2                                                        00031060
R3       EQU   3                                                        00031070
R4       EQU   4                                                        00031080
R5       EQU   5                                                        00031090
R6       EQU   6                                                        00031100
R7       EQU   7                                                        00031110
R8       EQU   8                                                        00031120
R9       EQU   9                                                        00031130
R10      EQU   10                                                       00031140
R11      EQU   11                                                       00031150
R12      EQU   12                                                       00031160
R13      EQU   13                                                       00031170
R14      EQU   14                                                       00031180
R15      EQU   15                                                       00031190
GBR      EQU   12                                                       00031200
FPR0     EQU   0                   FLOATING REG 0                       00031210
FPR2     EQU   2                                                        00031220
FPR4     EQU   4                                                        00031230
FPR6     EQU   6                                                        00031240
K        EQU   1024                                                     00031250
IOBUFSZE EQU   36*K                SIZE OF AREA RETURNED TO OS FOR I/O  00031260
MINSTORE EQU   8*K                 MIN ACCEPTABLE DYNAMIC STORAGE SIZE  00031270
MAXSTORE EQU   4000*K              MAX REQUESTABLE DYNAMIC STORAGE      00031280
LCAFTMST EQU   80                  LOCAL VARIABLE AREA (PASCAL PROCS)   00031290
FPRSAREA EQU   32                  FP REG SAVE AREA SIZE             *  00031300
RSLT     EQU   0                                                        00031310
RET      EQU   14                  RETURN ADDRESS/LOCATION COUNTER      00031320
LINK     EQU   15                  BRANCH REGISTER                      00031330
PBASE2   EQU   11                  PROGRAM BASE REGISTER #2             00031340
PBASE1   EQU   10                  "     "      #1                      00031350
*                                                                       00031360
INXERR   EQU   1001                INDEX ERROR RETURN CODE              00031370
SUBERR   EQU   1002                SUBRANGE ERROR RETURN CODE           00031380
PARERR   EQU   1003                PARAMETER ERROR RETURN CODE          00031390
SETERR   EQU   1004                SET ELEMENT ERROR RETURN CODE        00031400
PTRERR   EQU   1005                POINTER ERROR RETURN CODE            00031410
STKERR   EQU   1006                STACK/HEAP ERROR RETURN CODE         00031420
INPERR   EQU   1007                INPUT OPERATION ERROR RETURN CODE    00031430
OUTERR   EQU   1008                OUTPUT OPERATION ERROR RETURN CODE   00031440
SYNERR   EQU   1009                SYNCHRONOUS I/O ERROR RETURN CODE #  00031450
TIMERR   EQU   1010                TIME OUT ERROR RETURN CODE           00031460
FDFERR   EQU   1011                FILE DEFINITION ERROR RETURN CODE    00031470
SPCERR   EQU   1012                'NO SPACE' ERROR RETURN CODE         00031480
NDFERR   EQU   1013                UNDEFINED CSP CALL ERROR          @  00031490
LIMERR   EQU   1014                'LINES LIMIT EXCEEDED' ERROR      #  00031500
FILERR   EQU   1015                BAD FILE CONTROL BLOCK            @  00031510
RCDERR   EQU   1016                INPUT RECORD TOO LARGE            @  00031520
EOFERR   EQU   1020                ILLEGAL READ PAST EOF             #  00031530
BOLERR   EQU   1021                BAD BOOLEAN ON INPUT              #  00031540
INTERR   EQU   1022                BAD INTEGER ON INPUT              #  00031550
RELERR   EQU   1023                BAD REAL ON INPUT                 #  00031560
BIGERR   EQU   1024                TOO BIG INTEGER ON INPUT          &  00031570
SNPERR   EQU   100                 SNAPSHOT ERROR RETURN CODE           00031580
*                                                                       00031590
*                                                                       00031600
*        MISCELLANEOUS CONSTANTS                                        00031610
*                                                                       00031620
*                                                                       00031630
*        FILE RELATED SYMBOL DEFINITIONS                                00031640
*                                                                       00031650
         EXTRN $MAINBLK                                                 00031660
         WXTRN SNAPSHOT,IBCOM#                                          00031670
IBCOMINI EQU   64                  IBCOM INITIALIZATION ENTRY POINT     00031680
IBCOMXIT EQU   68                  IBCOM TERMINATION ENTRY POINT        00031690
*                                                                       00031700
*                                                                       00031710
*        CSP ROUTINE NUMBERS                                            00031720
*                                                                       00031730
PGET     EQU   0*4                                                      00031740
PPUT     EQU   1*4                                                      00031750
PRES     EQU   2*4                                                      00031760
PRLN     EQU   3*4                                                      00031770
PREW     EQU   4*4                                                      00031780
PWLN     EQU   5*4                                                      00031790
PWRS     EQU   6*4                                                      00031800
PWRI     EQU   8*4                                                      00031810
PWRC     EQU   10*4                                                  &  00031820
PXIT     EQU   21*4                                                     00031830
PCLS     EQU   29*4                                                     00031840
PSKP     EQU   32*4                                                  #  00031850
*                                                                       00031860
*        FILE BLOCK FIELDS                                              00031870
*                                                                       00031880
FILNAM   EQU   0                   PASCAL NAME FOR FILE              @  00031890
FILLNK   EQU   8                   LINK PTR TO NEXT FILE BLOCK       @  00031900
FILPAS   EQU   12                  PTR TO PASCAL FILE VARIABLE       @  00031910
FILBUF   EQU   16                  PTR TO I/O BUFFER                 @  00031920
FILLIM   EQU   20                  OUTPUT LINES LIMIT FOR FILE       @  00031930
FILEND   EQU   24                  CURRENT BUFFER LENGTH (TEXTFILES) @  00031940
FILOPN   EQU   26                  OPEN/TEXT FLAGS                   @  00031950
FILEOF   EQU   27                  EOF FLAG                          @  00031960
FILPTR   EQU   28                  CURRENT CHAR POS (TEXTFILE)       @  00031970
FILBEG   EQU   30                  CHAR START POS   (TEXTFILE)       @  00031980
FILRSZ   EQU   28                  MAX RECORD SIZE (NON TEXTFILE)    @  00031990
FILCSZ   EQU   30                  FILE COMP. SIZE (NON TEXTFILE)    @  00032000
FILDCB   EQU   32                  DCB POSITION IN BLOCK             @  00032010
*                                                                       00032020
PFILEOF  EQU   0                   PASCAL'S EOF FLAG                 @  00032030
PFILPTR  EQU   0                   PTR TO FILE CONTROL BLOCK         @  00032040
PFILEOL  EQU   4                   PASCAL'S EOL FLAG (TEXTFILE)      @  00032050
PFILRSZ  EQU   4                   RECORD SIZE  (NON TEXTFILE)       @  00032060
PFILCOMP EQU   8                   FILE COMPONENT                    @  00032070
PFILTSIZ EQU   12                  TOTAL SIZE FOR TEXT FILE          @  00032080
*                                                                       00032090
*        INTERNAL CHARACTER CODE FOR USEFUL CHARACTERS                  00032100
*                                                                       00032110
FILEOL   EQU   0  ?                                                     00032120
FILEXP   EQU   C'E' 5                                                   00032130
FILZER   EQU   C'0' 27                                                  00032140
FILNIN   EQU   C'9' 36                                                  00032150
FILPLU   EQU   C'+' 37                                                  00032160
FILMIN   EQU   C'-' 38                                                  00032170
FILTIM   EQU   C'*' 39                                                  00032180
FILBLA   EQU   C' ' 45                                                  00032190
FILDOT   EQU   C'.' 47                                                  00032200
*                                                                       00032210
*        READ/WRITE AND TEXT FLAG VALUES                             @  00032220
*                                                                       00032230
READOPN  EQU   1                                                        00032240
WRITEOPN EQU   2                                                        00032250
TEXTFLAG EQU   4                                                     @  00032260
*                                                                       00032270
*        REGISTERS ASSOCIATED WITH FILE USAGE                           00032280
*                                                                       00032290
AD       EQU   9       @ PASCAL FILE CONTROL BLOCK                      00032300
AE       EQU   8       @ CSP FILE CONTROL BLOCK                         00032310
AF       EQU   7       @ O.S. RECORD BUFFER FOR FILE                    00032320
AG       EQU   6       @ DCB FOR FILE                                   00032330
*                                                                       00032340
*        MISCELLANEOUS CONSTANTS                                        00032350
*                                                                       00032360
FALSE    EQU   0                                                        00032370
TRUE     EQU   1                                                        00032380
CHR      EQU   1                   LENGTH (IN BYTES) OF A CHAR. VALUE   00032390
*                                                                       00032400
         END   $PASENT                                                  00032410
++FILE PASCALN.OLDCOMP.SOURCE                       MEMB PASDOC   EXT TXT HEX -
1
-
-1.  The Pascal Distribution Tape
-     This tape contains the following files:
0        File 1: This Introduction, 'PASDOC'.
0        File 2: The Pascal Compiler (source form), 'PSCLSRC'.
0        File 3: The P_Code Processor (source form), 'ASMPSRC'.
0        File 4: The I/O interface and Sub Monitor (source form),
                'PMONSRC' - may be assembled in two versions.
0        File 5: A PDS (PASLIB) with the following members:
                a) PASOBJ  (object form of file 2)
                b) ASMPOBJ (object form of file 3)
                c) PASMON  (object form of file 4.a)
                d) PASMON0 (object form of file 4.b)
                e) PASMSG  (text of Pascal error messages)
                f) PASSNAP (object form of the Pascal SNAPSHOT routine)
                g) PASPROF  (object  form  of the  Pascal  Run  Profile
                   generator)
                h) PBGN    (Misc.   MACROs needed  to run  the assembly
                   language output of the Post_Processor - if A+ option
                   is chosen).
0           File 6: A  PDS  (TESTLIB)  containing  various  contributed
                   utility  and  sample  programs  written  in  Pascal.
                   These  include:   XREF,  a  Pascal  cross  reference
                   generator;  FFT,  a Fast  Fourier Transform routine;
                   QSORT, a Quick Sort routine; SNAPSHOT, source of the
                   PASSNAP; PROFILER, source of PASPROF; RNF, a general
                   purpose text formatter;  ED, a text editor;  PCROSS,
                   PFORMAT,  PRETTY and PEDIT,  various cross-refernce,
                   formatting and editing routines for Pascal programs;
                   PINTERP,   a  P_Code interpreter;   and  some  other
                   miscellaneous programs.
0           File 7: Documentation and setup procedure  for VM/CMS users
                   'PASCMS', (courtesy Dave Rossetti of SLAC)
0           Files 8 through  14:  The  previous version  of the  system
                   which  may  be used  as  a  backup for  the  current
                   version.
-          To facilitate  inspection/manipulation of these  files,  you
      may want to unload all of them onto a Direct Access device before
1
0                                                                PAGE 2
0     proceeding to the  next sections.   The File Names  are listed in
      the output of the IEHMOVE program used to create the Distribution
      Tape.  This output is enclosed with the tape.
0          The rest of this writeup is organized as follows:  Section 2
      describes the  compiler/post-processor and  non-standard features
      of the  Pascal implementation.   Section 3  provides instructions
      and JCL for  setting up the system.   Section 4  explains some of
      the  implementation details  and provides  a  few storage  saving
      ideas.  Section 5 contains a sample program and demonstrates what
      kind of  output to expect  under various conditions.    Section 6
      indicates which  features have changed  from earlier  versions of
      the Stanford Pascal  system.   Users of previous  versions should
      take special note of this section.   Sections 2.2.1, 2.2.3-2.2.9,
      2.3.1, 2.4.1, 2.4.3, 3, 4.1 and 5 contain information of interest
      to  the  average users.   Other  parts  of  this note  are  meant
      primarily for the people who maintain the system or would like to
      modify it for their particular need.   Access to reference [1] is
      also essential for all users.
0          This system has  been developed for and  (mainly)  tested on
      the IBM 370/168 under the VS2 operating system in batch mode.  An
      interactive  version of  the compiler  has also  been adopted  to
      operate under  ORVYL (the Stanford time sharing monitor).   Other
      versions have  been running under MFT,   MVT,  VM-CMS and  MVS in
      various installations.   Further work on  the optimization of the
      object  code  and extensions  to  the  source language  are  also
      planned.
0          The compiler and  its software support are  available to the
      public (without any  explicit or implied warranty)   and we would
      appreciate receiving  bug reports  (including the  source program
      causing   the   bug   and   related    outputs)    as   well   as
      comments/suggestions from the users of the system. If you wish to
      receive updates and or revisions concerning these programs,  send
      us a note and  indicate the kind of environment in  which you use
      the system.
0          This  document  contains "printer  control"  characters  and
      should be  printed on a  printer with Upper/Lower  case character
      set.
1
0                                                                PAGE 3
02.   Stanford Pascal Compiler
-          The Stanford  Pascal Compiler is  a modified version  of the
      Zurich Pascal_P2 compiler (MAY 1974 variant) and except for a few
      minor extensions  processes the same  language (see [2]  for more
      details on Pascal_P).   The compiler itself is a 5000 line Pascal
      program that translates  the source program into  an intermediate
      form which is the machine language  for a mythical Stack Computer
      (the so called P machine, hence the name P_Compiler).  The output
      of  the  compiler   is  then  fed  to  a   post  processor,   the
      P_Translator,   which in  turn  translates  the P_Code  into  the
      IBM/370  code,   generating either  an  Object  Module or  a  370
      Assembly language program.   The P_Translator is also  written in
      Pascal (aprox.  4000 source lines)   and like the compiler  would
      benefit     from      any     improvement      in    the     code
      generation/translation of the combined system.
0          Except for a few cases  involving the movement or comparison
      of large structures (i.e. large records, arrays, etc. implemented
      by  the  "Long"  370 "SS"  type  instructions),   the  translator
      generates instructions  common to 370  and 360 series  and,  with
      small changes,  it is possible to (optionally)  generate 360-only
      instructions.
0          The  translation from  P_Code  to 370  code  is  based on  a
      general  scheme  for  converting Polish  style  expressions  into
      "Register" oriented  code without  actually simulating  the Stack
      Machine on  the Stack-less  Computer which,  due  to lack  of the
      hardware  Stack and  appropriate  instructions,    tends  to   be
      fairly   inefficient.    Furthermore,  the  organization  of  the
      translator is such that its  modification to generate object code
      for other register oriented computers should be straightforward.
0          The  run-time  support  package and  the  I/O  interface  is
      written to operate under OS/VS or  OS/MVT and has also been tried
      by other users under VM.  Using  small I/O buffers (i.e.  10..12K
      bytes),  the  current version of the  Compiler/Post_Processor can
      compile itself,  and/or other moderate  size programs,  in a 128K
      region.    A larger  region,   however,   would improve  the  I/O
      efficiency.
-2.1  The Sub_Monitor and I/O Interface
0          The Sub  Monitor and the I/O  interface consist of a  set of
      assembly language routines which set up the run time  environment
      and  implement  the  I/O   related  Standard Procedures/Functions
      of Pascal.   The sub monitor also initializes the environment for
      FORTRAN routines  (by calling #IBCOM)   if there are  any FORTRAN
      routines present.  They will be present if there are any explicit
1
0                                                                PAGE 4
0     references to  external FORTRAN  routines in  the Pascal  program
      (see  the  section  on  external routines)   or  if  any  of  the
      mathematical functions, SIN, COS, ARCTAN,  LN,  EXP or SQRT,  are
      used.    All  references  to  these  mathematical  functions  are
      implemented as  calls   to  the  corresponding   FORTRAN  double-
      precision functions.
-2.2  Implementation Restrictions/Extensions etc.
0          The modifications  to the Zurich  Compiler are  primarily in
      the  areas  of   1)   providing  TYPE  information   for  certain
      instructions  at the  P_Code level,   2)   boundary alignment  of
      variables according to the 360/370 requirements and 3) separating
      CHARacters from INTEGERs in their internal representation.  These
      changes should be transparent to the  end user.   Otherwise for a
      complete list of restrictions imposed  by the P_Compiler refer to
      [2]. In addition:
-2.2.1  Miscellaneous Restrictions
0     -Only TEXT files (FILE OF CHAR)  are presently supported.   For a
      method of circumventing this restriction, see Section 2.2.5.
0     -Files can be declared only in  the main program (i.e.  as global
      variables).
0     -Files can  be passed  only as  VAR parameters  to procedures  or
      functions.
0     -Integers are limited to the range -2**31 to 2**31-1.  This upper
      limit is the value specified by the constant MAXINT.
0     -Reals are implemented in the  double-precision format on the IBM
      360-370.   This  implies a precision  of approx.   16 significant
      digits and a range of 10**-78 to 10**76 for the magnitude.
0     -Sets are limited to 64 elements.  The ordinal range for the base
      type of the set must not extend outside the range 0..63.
0     -String  constants  are  limited  to   a  maximum  length  of  64
      characters.
0     -Reals can be printed to only  12 digit accuracy (even though all
      real arithmetic is performed to 16 digit accuracy).
0     -A  GOTO  statement leading  to  a  Label outside  the  procedure
      containing that statement is not allowed.
1
0                                                                PAGE 5
0     -The PACKED  attribute in  array and  record declarations  has no
      effect.    All   character/boolean  arrays   are  always   packed
      automatically with  one element  per byte.    Standard procedures
      PACK and UNPACK, however, are supported and can operate on PACKED
      as well as unPACKED arrays.
0     -The standard  procedure DISPOSE  (as described  in [1])   is not
      supported, instead,  dynamic storage (acquired through the use of
      the standard procedure NEW)  should be managed through the use of
      the  predefined   procedures  MARK(P:    Any_pointer_type);   and
      RELEASE(P:  Any_pointer_type).   MARK is used to save the current
      value of the Heap pointer and RELEASE will reset the Heap pointer
      to the  value specified by its  (pointer type)  argument.   As an
      example, the following sequence:
0          ... MARK(hp); ... NEW(x); ... NEW(y); ... RELEASE(hp); ...
0     leaves (the size of)  the dynamic  area unchanged.  Note that the
      pointers  "x"  and  "y"  become  "undefined"  after  the  RELEASE
      operation and cannot be used before they are redefined.  (Heap is
      the area from which dynamic storage is allocated.)
-2.2.2  Storage Allocation for Variables
0          The Compiler allocates  and aligns Pascal simple  data types
      according to the following table :
0               TYPE           SIZE      ALIGNED ON
0               CHAR,BOOLEAN   1-BYTE    1-BYTE BOUNDARY
                INTEGER        4-BYTES   4-BYTE BOUNDARY
                SET            8-BYTES   4-BYTE BOUNDARY
                REAL           8-BYTES   8-BYTE BOUNDARY
0     Dynamic  storage,   however,   is   always  allocated  on  8-Byte
      boundaries to  avoid the necessity  of alignment at  run-time (as
      opposed to the Compile Time alignment).   Note that Subranges are
      represented by their  Base type and Enumerated  types are treated
      as integers.   The P+ compilation option (see 2.2.8)  may be used
      to reduce the storage allocated to small integers,  but at a cost
      in execution time.  For the sake of space and time efficiency, it
      is a good  practice to declare program variables in  the order of
      their relative  size.   In particular,   by defining  simple type
      varibles before arrays and large records, you can ensure that all
      of the small variables may be  accessed by a short address field,
      resulting in a shorter and somewhat faster program.
-2.2.3  The Character Set and Pascal Identifiers
1
0                                                                PAGE 6
0     -Characters  are internally  represented  by  their EBCDIC  value
      (i.e.  ORD('a')  = 129 = HEX'81').  Although this should be of no
      consequence to "clean" programs that make no assumption about the
      ordinal values of characters, one should note that:  SUCC('a')  =
      'b'; but  SUCC('i') <> 'j'.   Furthermore, because of the size of
      the EBCDIC character set,  the construct:  SET OF CHAR;  is not a
      valid type (use the July 77 version of the compiler if you have a
      pressing need for this feature).
0     -Identifiers  may  be  of  any  length  but  only  the  first  12
      characters are significant.
0     -Pascal  keywords and  other identifiers  may  contain upper  and
      lower case letters interchangeably.  For example, Ident and IDENT
      are treated as the same identifier.
0     -Identifiers may include the dollar  and underscore ("$" and "_")
      characters wherever a digit may appear.
0     -The  following symbols  are  treated  identically by  the  input
      scanner of the compiler :
0               '¯'  or  '(*'     '@'   or  ''
                ''  or  '*)'     'AND' or  '&'
                '['  or  '(/'     'OR'  or  'Ý'
                ']'  or  '/)'     'NOT' or  '^'
0     Note  that comment  brackets should  be used  consistently and  a
      comment opened by the '(*' bracket  cannot be closed with the ''
      symbol.
0     -The Pascal  'uparrow' character is  represented by '@'  (the 'at
      sign' character).
0     -The '#' character  (pound sign)  is treated as  a skip character
      and ignored by the compiler.
0     -The double-quote (")  is used as a directive to skip text.   All
      text  up  to  and  including the  next  double-quote  is  totally
      ignored.
0     -The above mentioned conversions do not apply to string constants
      in which  the input characters are  not subject to  any automatic
      translation and/or interpretation.
-2.2.4  Language Extensions
0     -The range designator A..B may be used to specify constant values
      A, A+1, ...  B-1, B, instead of enumeration of all the individual
      values (e.g.  [1, 4..8,  10,  12..20] is a good set constructor).
1
0                                                                PAGE 7
0     Note that this abbreviation may also be used in CASE labels.  For
      example one can write:
0             case CH of
                 'a'..'i', 'A'..'I' : S1 ;
                 '0'..'9'           : S2 ;
              end ;
0     -Superfluous separators ' ;  ' preceding the END symbol in Record
      (and  variant)    declaration,   Case   Statement  and  Procedure
      definitions are ignored by the compiler.
0     -Functions of Type SET may be defined.
0     -The Tag field of a case variant record may be unnamed,  in which
      case no space will be allocated for it. This feature, which is in
      the 'standard' language, allows access to different variants of a
      record when the type of each  variant is known through some other
      context.
0         e.g.,  record A: Some_type ;
                 case BOOLEAN of
                      TRUE:  ( B: Type_b) ;
                      FALSE: ( C: Type_c) ;
                 end ;
-2.2.5  Files and File Handling
0     -The compiler knows about 6 predefined TEXT files, INPUT, OUTPUT,
      PRD, PRR, QRD and QRR, with INPUT used as input only, OUTPUT used
      as output only and PRD, PRR, QRD, QRR used as input after a RESET
      and as output after a REWRITE operation.
0     -The  PROGRAM  heading  should  include  the  names  of  all  the
      predefined  files used  in  the program,   otherwise  one has  to
      RESET/REWRITE these  (as well as  all other user  defined)  files
      before they are accessed.   Note that  the default mode of INPUT,
      PRD and QRD is 'input' while OUTPUT,   PRR and QRR are opened for
      'output' if they appear in the PROGRAM parameter list.   In order
      to use a predefined file in other than its default mode (e.g.  to
      use PRD  for 'output'),   instead of  listing it  in the  program
      heading,   simply 'RESET'  or 'REWRITE'  that file  prior to  the
      relevent I/O operation(s).
0     -If the file  name is missing from  the argument list of  a file-
      handling procedure/function then the file name INPUT or OUTPUT is
      inserted as  appropriate.   For example,  READLN,   READLN()  and
      READLN(INPUT)   are all  equivalent  as  are PAGE,   PAGE()   and
      PAGE(OUTPUT).
1
0                                                                PAGE 8
0     -Boolean  variables may  be input  from  textfiles.   The  single
      letter 'T'  represents TRUE and  'F' represents  FALSE.   Leading
      blanks  are ignored  and  any other  input  character results  in
      error.    The  file   pointer  is  positioned  to   the  charcter
      immediately following the 'T' or 'F' character.  Note that lower-
      case input ('t' and 'f') is also accepted.
0     -String  variables  may be  input  using  READ or  READLN.    For
      example,  if S  is a variable with the type  ARRAY[1..N] OF CHAR,
      then READ(INPUT,S) is equivalent to:
0        for I:= 1 to N do
            if not EOLN(INPUT) then READ(INPUT,S[I])
               else S[I] := ' ';
0     -Only textfiles (file of CHAR) are currently supported.   However
      the effect  of other file types  can be obtained  through overlay
      techniques.   For example,  to use the PRR file as though it were
      declared as FILE OF REAL, the following code can be used:
0          var PRR_ELEMENT: record
                            case BOOLEAN of
                                 TRUE:  (R: REAL);
                                 FALSE: (CH: array[1..8] of CHAR)
                            end;
0          ¯ we omit other declarations, etc. 
0          PRR_ELEMENT.R := 0.5;  ¯Assign REAL value
           WRITE(PRR,PRR_ELEMENT.CH);  ¯Write it as a string
0          ¯ input from the file can be performed similarly 
-2.2.6  Additional Standard Procedures and Functions
0     CARD(S:  Any_set_type)  :  returns an INTEGER result equal to the
      cardinality of the set, S.   For example, CARD( [3,8,43,60] ) has
      the value 4.
0     CLOCK(I:  INTEGER) returns an integer result corresponding to the
      value of the system clock.   If I=0,  the result is the execution
      time in  thousandths of a  second that  have been used  since the
      Pascal  program started.    Other  values  of I  currently  yield
      undefined results.
0     EXIT(I:   INTEGER)  :   causes the  Pascal  program to  terminate
      execution.   The value,  I,  is used as the program's user return
      code and can be tested in the  JCL used to run the program.   The
      value used  should be  non-negative and less  than 1000  to avoid
      confusion with the return codes used for Pascal errors.
1
0                                                                PAGE 9
0     EXPO(R:  REAL) :  returns an INTEGER result equal to the exponent
      in the internal machine representation of the real number, R.  To
      use  EXPO,   it  is  necessary to  know  that  real  numbers  are
      normalized in the form:
                                exponent
                 mantissa * 16
0     where 1/16 <=  mantissa < 1  (except  if the real number  is zero
      then the mantissa is zero and the exponent is -64).  For example,
      EXPO(1.0) is 1, EXPO(16.0) is 2, EXPO(256.0) is 3, etc.  The EXPO
      function  is  useful  for  making   fast  determinations  of  the
      magnitude of a number (much faster than using the LN function).
0     LINELIMIT(F:  TEXT;  I:  INTEGER) :  sets a limit of I subsequent
      output  lines for  the file  F.   After  I more  lines have  been
      written,   an  error  message   would  be  issued  automatically.
      Initially,   there  are  no  limits   in  effect  for  any  file.
      Performing a REWRITE  or calling LINELIMIT with  I<=0 will cancel
      any limit  in effect for  the file.   If  the file name,   F,  is
      omitted, OUTPUT is assumed.
0     MESSAGE(S:  Any_string_type)  :  causes a  character string to be
      written to the  O.S.  message log that is printed  along with the
      JCL listing for the job.   There is  a limit of 120 characters on
      the length of this message.
0     MARK(P:  Any_pointer_type) :  saves the current value of the Heap
      pointer in the pointer variable P.
0     RELEASE(P: Any_pointer_type) :  resets the heap pointer using the
      value of P.    This effectively releases all  the dynamic storage
      allocated (through the use of NEW)  since the last MARK operation
      on P.
0     SKIP(F: TEXT; I:  INTEGER) :  if F is open for output, the effect
      is similar to I successive calls  to WRITELN(F).   When I=0,  the
      next output line will overprint the  current line.   If F is open
      for  input,  the  effect  is similar  to  I  successive calls  to
      READLN(F).  When I=0, the current input line will be re-read.  If
      the file name, F, is omitted, OUTPUT is assumed.
0     SNAPSHOT(I,J:   INTEGER)  :   causes a  snapshot  dump of  active
      storage.   This  procedure requires  access to  the symbol  table
      output of the compiler which is  available only if the program is
      compiled with  the D+ option in  effect (see 2.2.8).    The first
      parameter I  specifies the number of  active procedures/functions
      whose variables are to be  printed.   For example,  I=3 specifies
      the 3 most recently entered procedures/functions.  Specifying I=0
      gives a dump of all active  procedures/functions back to the main
      program.   The  second parameter J  determines the type  of dump.
      J=10  specifies  the  maximum  amount of  information  is  to  be
1
0                                                               PAGE 10
0     printed.   J=0  is similar  except that volume  of the  output is
      reduced by printing only a few elements from the two ends and the
      middle of  arrays.   Specifying J=1 produces  only a list  of the
      active procedures and functions.
0     PACK/UNPACK :  The restrictions on the  type of the parameters to
      these standard procedures are somewhat relaxed. The target/source
      opernads need not be declard as  PACKED arrays and,  in addition,
      the source operand may be a string constant.
0     TRAP(I:  INTEGER;  VAR  V:  any type)  :  generates a  call to an
      external user supplied  routine with the entry  point '$PASTRAP'.
      The value of I is passed in GPR-0  and the address of V is passed
      in GPR-1.   The first parameter,  I,  is intended to be used as a
      'function' code  and the  second parameter  V is  to pass  values
      to/from the external routine.   The  object code for the external
      routine containing '$PASTRAP' entry point should be included with
      the object code of the Pascal program.
-2.2.7  Predefined Names
0     -ALFA is defined to be the type ARRAY[1..10] OF CHAR.
0     -TEXT is defined to be the type FILE OF CHAR.
0     -MAXINT  is defined  to be  an  integer constant  with the  value
      2147483647 (i.e.  2**31-1,  the largest one-word integer value in
      the 360/370 series).
0     -DATE is  a variable of type  ALFA (ARRAY[1..10] OF  CHAR)  whose
      value is  the date on  which execution commenced.    For example,
      '07-31-1979' corresponds to July 31, 1979.
0     -TIME is a variable of type ALFA  that contains the time at which
      execution commenced.  For example, '14:25:59  ' corresponds to 25
      minutes and 59 seconds past 2 p.m.
0     -OSPARM is a pointer variable of type:
0              @RECORD
                LENGTH: INTEGER;
                STRING: ARRAY[1..64]
                END;
0     A parameter  string may be passed  to the Pascal program  via the
      'PARM' field of the 'EXEC' JCL staement (see Section 2.3.1 ).
      When this  parameter string is  supplied,  OSPARM@.LENGTH  is the
      number of characters in the string  and the string itself is held
      in OSPARM@.STRING.  When no parameter is provided, OSPARM has the
      value NIL.  Note that the subscript bound of 64 is purely nominal
1
0                                                               PAGE 11
0     and no attempt  should be made to access elements  of STRING with
      index values greater than the LENGTH value.
-2.2.8  Compilation Options
0          Compiler Options  are (as  usual)  specified  inside COMMENT
      delimiters in any order, but with no other symbols/blanks between
      them.  These options and their default values are :
0     (*$L+,M-,D+,K-,N-,X-,P-,C+,A-,S+,F+,E ... other comments*)
0     where:
0          L+ list/(don't list) source program.
           M- no margin/(set margin) at column 72 of input lines.
           D+ enable/(disable) run-time checking.
           K- don't emit/(emit) counters for program Run Profile.
           N- Do not nest/(allow nested) comments.
           X- clear/(set) external linkage flag.
           P- Do not pack/(do pack) subrange variables into "bytes".
           C+ emit/(don't emit) P_Code.
           A- gen. 370 Obj. Mod./(gen. 370 assembly language output).
           S+ save/(don't save) GPRs on procedure/function entry.
           F+ save/(don't save) FPRs on procedure/function entry.
           E  Do a Page Eject before continuing the source listing.
0     -M Option:   The M option controls  the margins for source input.
      When M- is in effect (the default),  there are no margins and the
      entire  input  record is  read  by  the  compiler.   When  M+  is
      specified, a right margin at column 72 is set, so that columns 73
      and beyond are ignored.   M+ is useful for sequence numbered card
      input.   More  control over  the margins  of the  input lines  is
      provided by giving  the M option in the form  M(a,b).   The first
      decimal number, a, specifies the left margin and b sets the right
      margin.   That  is,  only  the contents  of columns  a through  b
      (inclusive)   are compiled  and the  rest  of the  input line  is
      ignored.   No error occurs if b is given a value greater than the
      size of source records, the input lines are read to their ends in
      such  a case.    However  there is  a  compiler limitation  which
      restricts the  maximum value of  b to  120.   (This limit  may be
      changed by  recompiling the compiler  with a different  value for
      the constant BUFLEN.)  Consequently,  M+ is equivalent to M(1,72)
      and M- is equivalent to M(1,120).   Note:   the M option does not
      come into  effect until  the following  source record.    If this
      proves inconvenient,  observe that the M  option can be placed in
      the JCL parameter string.
0     -D Option:  With the D+ option in effect, various run-time checks
      are performed.
1
0                                                               PAGE 12
0          Subranges (including  the Enumeration  type variables)   are
      checked when being assigned to or  passed as actual parameters to
      procedures.   Indices  are checked before the  indexing operation
      and Pointers  are checked  when being  assigned to  and/or before
      their use as references to other objects. Also, variables used in
      construction of Sets (through the set constructor operator [...])
      or being tested for Set membership are checked to be within range
      prior  to these  operations.    If the  value  being checked  for
      validity happens to  be a constant the appropriate  check is done
      at Compile (really post processing) time,  otherwise for the sake
      of conserving  space,  Run-Time check  routine(s)  are  called to
      perform the  proper tests (as  opposed to in-line  checking which
      would be more time-efficient).
           If  this  option  is  in  effect  during  compilation  of  a
      procedure heading,   then  the prologue of that  procedure checks
      for the availability of sufficient storage on the  run-time stack
      before  allocating   space   for   the  local  variables  of  the
      procedure.   Similarly, the growth (and shrinking) of the Heap is
      checked  to ensure  the consistency  of  the Run-Time  Stack/Heap
      structure. In order to detect uninitialized variables as early as
      possible,   the entire  stack/heap  area  as well  as  individual
      procedure activation records, are cleared to a fixed pattern (Hex
      '81').   (This can potentially make a significant contribution to
      the program's running time.)
           Pointer  values are  checked before  they  are assigned  and
      before they are dereferenced.  The value must refer to a location
      within the storage area allocated to the heap.  Also, the special
      pointer value NIL is valid on  assignment but clearly invalid for
      dereferencing.
           In case a  Run-Time error is detected,   the offending value
      with  its declared  range  as well  as  the  Procedure,  and  the
      relative location within  the procedure,  in which  the error was
      discovered will be printed.   If the D+ option is in effect while
      compiling  the procedure  heading,  the  approximate line  number
      corresponding to the error location will  also be given.   If any
      of the above checks is possible  at compile time,  then the error
      message will be generated by the post-processor and the execution
      of the program will not be attempted.  As the run-time diagnostic
      messages are sent to OUTPUT file, this file should be included in
      the set of Program files (i.e., DD statement for OUTPUT should be
      present).
           Depending on  the type of the  checking,  one to  three full
      word instructions  may be added to  the object code  per checking
      site.   This means that a  procedure which translates into almost
      8k bytes of  code,  may exceed this  limit when the D+  option is
      chosen.    In such  cases this  option should  be invoked  either
      selectively,   for  small  segments of  the  procedure,   or  the
      procedure  should  be  broken  down  into  smaller  routines  for
      debugging   purposes   (another   incentive    to   avoid   large
      procedures!).
1
0                                                               PAGE 13
0     -K  Option:   This  option will  cause the  compiler to  allocate
      counters and generate instructions needed to produce an execution
      profile of the user program.   After the (proper)  termination of
      the user Program with the above  switch on,  the Sub Monitor will
      output the counter values onto the QRR file,  which should not be
      used by the user program.    The Execution Profile Generator will
      then read these counts, as well as the source program listing and
      an auxiliary file generated by the compiler,  in order to produce
      a formatted  listing which includes  the execution count  of each
      (executable)  line of the source program.   The Execution Profile
      Generator and the necessary JCL are  included in the TESTLIB file
      on  the distribution  tape.   The  Compiler  usually generates  a
      minimal number  of additional  instructions when  this option  is
      invoked,  but in some marginal cases these extra instructions may
      cause a procedure to exceed the 8k size limitation, in which case
      the user may disable the Counts  for that procedure or divide the
      procedure into smaller segments.
0     -N Option:   When the 'N+' option is in effect,  comment brackets
      may be properly nested.   For example,   (*  (*  *)   (*  *)   *)
      would be a  valid comment form.   When 'N-' (the  default)  is in
      effect,  the comment  would be closed at the  first "*)" bracket.
      Nested  comments are  useful when  it is  desired to  comment-out
      sections of a Pascal program.   Note that the option switches can
      be set only by the first level (outer most) comments.
0     -X Option:   The immediate effect of this option is to change the
      CSECT names generated by the post-processor for Pascal procedures
      and  the  main  program.    Normally,    the  CSECT  name  for  a
      procedure/function is formed from the first few characters of its
      name followed  by a unique integer  and the main program  has the
      CSECT name $MAINBLK.    While the 'X+' option is  in effect,  the
      CSECT names are taken directly  from the procedure/function name.
      (Only the first 8 characters of  the name are significant if used
      to create  a CSECT  name.   It  is the  user's responsibility  to
      ensure that the CSECT names are all distinct.)   The main program
      is renamed to  #MAINBLK (so that it is  not automatically invoked
      by the  sub-monitor program).   The  'X+' option  facilitates the
      creation of external Pascal procedures or functions.  See Section
      2.2.9, below.
0     -P Option:   The Pack option 'P+' may be invoked universally,  if
      the  program  does  not  use  Dynamic  REAL  type  variables  (or
      records/arrays  with  REAL  components),   or selectively  around
      procedures which need large data areas (either directly,  through
      recursion or dynamic  allocation etc.)   to reduce  the program's
      data space requirement.    With the default value  of the switch,
      Dynamic storage is  allocated on double-word boundaries,   with a
      potential  for memory  fragmentation.    Furthermore,  when  this
      switch is on, scalar type variables which are in the range 0..255
      are internally  treated as  CHARs,  with  one byte  allocated per
1
0                                                               PAGE 14
0     variable.    Note  that,    in  terms  of  running   time,   this
      representation is  slightly less  efficient  than   the  standard
      representation of Scalar/Subrange Types as full word integers.
           A  byte-packed  subrange  variable cannot  be  passed  as  a
      reference (VAR)  parameter to a procedure where the corresponding
      formal parameter  is declared to  be an  INTEGER,  nor can  it be
      included in  the parameter  list of a  READ statement.   This may
      cause the compiler  to 'find' some  errors in an  otherwise well-
      formed program when the Pack option is selected.
           The 'P+'  option is incompatible  with the 'D+'  setting and
      should  not be  specified  when the  run-time  check is  enabled.
      Otherwise the values of the variables, as printed by the SNAPSHOT
      routine, may not be accurate.
0     -F  and S  Options:   If  you have  complicated REAL  expressions
      involving call(s)  to REAL functions in your program,  you should
      leave the 'F+' switch ON, otherwise the 'F-' option would be more
      efficient.   Likewise,  if you do not use complicated expressions
      involving INTEGER valued  Functions (and you have  many procedure
      calls in your program), you may get a faster running program by a
      'S-' option  for the higher models  of 370 (in  which  the LM/STM
      instructions are much slower than L/ST instructions).
-     Notes:
0          Only options  L,D,M,K and E are  of interest to  the average
      user who  should not  be concerned  with (and  confused by)   the
      details of  the other switches.  Options  F and S should  be used
      with care and  some understanding of the  code generation pattern
      of the compiler.
0          The option  list (excluding the  comment delimiters  and the
      '$' tag)  may be passed to  the compiler through the 'PARM' field
      of the JCL 'EXEC' statement. This mode is particularly useful for
      interactive  environments and  avoids the  need  for editing  the
      source program  file in  order to  set/reset some  of the  option
      switches.
-2.2.9  External Procedures
0     - Creating an External Pascal procedure
0          The  simplest approach  is  to forego  the  usage of  global
      variables within the external procedure.  This procedure can then
      be  compiled  as  part  of a  program  that  contains  no  global
      declarations,   that sets  the  X+  compilation option  and  that
      contains no main program code.   A small example of this is shown
      in  Section  3.7.   The  object  code  created for  the  external
      procedure can be concatenated to the  object code for the calling
1
0                                                               PAGE 15
0     program before  being link-edited  or loaded  into memory.    The
      calling  program must  contain  a  declaration for  the  external
      procedure.   The declaration follows the same syntax rules as for
      ordinary  procedure definitions  except  that  the code  body  is
      omitted.    The keyword  EXTERNAL  simply  follows the  procedure
      heading.
           It  is possible  for the  calling program  and the  external
      procedure to share  variables in the global  environment.   To do
      this, it is necessary to compile the external procedure using the
      identical global declarations as for  the calling program.   Also
      note  that  the  SNAPSHOT  routine cannot  print  the  values  of
      variables internal  to an  external procedure  unless the  symbol
      table  file  created  for  the   external  procedure  during  its
      compilation is saved.  It must then be concatenated to the symbol
      table  file   created  for   the  calling   program  during   its
      compilation.
0     Note:  As there is absolutely  no Type/count checking provided by
      the Loader,  it is important to  make sure that the definition of
      the separately compiled Pascal/FORTRAN programs be consistent (in
      the number and  Type of parameters)  with the  declaration of the
      corresponding procedure/function  headings in the  program making
      the calls.   In the case of a separately compiled Pascal program,
      it is also  important for the two declarations  to have identical
      static nest  levels if  there is a  potential two-way  link (i.e.
      repeated cross calls) between the modules involved.
0     -Calling an External FORTRAN Routine
0          The  FORTRAN function/subroutine  should be  declared as  an
      internal Pascal  function/procedure but with the  keyword FORTRAN
      replacing the  body of the code.    Note that all  reference type
      parameters should  be declared as  Pascal VAR parameters  and the
      basic types INTEGER, REAL,  CHAR and BOOLEAN in Pascal correspond
      to   FORTRAN's  INTEGER*4,   REAL*8,    LOGICAL*1  and  LOGICAL*1
      respectively.   For example,  to invoke FORTRAN's GAMMA function,
      the following code could be used:
0          function DGAMMA(X: REAL): REAL;  FORTRAN;
            .
            .
           RESULT := DGAMMA(1.0);
0     Note:   the double-precision  versions  of  the FORTRAN  routines
      should be used for guaranteed  compatibility.   However,  single-
      precision versions will usually work correctly.  If a Pascal REAL
      value is  passed to  a FORTRAN  REAL*4 variable,   some low-order
      digits are lost.   If a result  is returned from a FORTRAN REAL*4
      expression to  a Pascal REAL  variable  some  undefined low-order
      digits  are generated  (implying  that it  may  be impossible  to
      return an exact zero result in these circumstances).
1
0                                                               PAGE 16
0          The FORTRAN message  file FT06F001 should be  present if you
      try to run a program which will call a FORTRAN routine.   This is
      regardless of any I/O activity of the FORTRAN routine,  for which
      you may  have to  include other  DD statements  as well.   As the
      FORTRAN initialization routine (#IBCOM)  tries  to open this file
      at the entry to the monitor,   the absence of this statement will
      cause an early (hard to diagnose) ABEND.
0     -Calling an External Assembler Routine
0          One method  is to  call an  assembler routine  via the  TRAP
      built-in function.  The routine must be given an entry point name
      of $PASTRAP.   One of the routine's parameters may have any type.
      Consequently,  any amount of information  can be communicated via
      an appropriate record type parameter.
           A  second method  is  to code  the  routine  to use  FORTRAN
      parameter passing conventions and to  call this routine as though
      it were a FORTRAN routine.   The  only drawback is the limitation
      of parameter types to those that have equivalents in FORTRAN.
           Finally,  the  routine can  be called  as though  it were  a
      Pascal external routine.    To access parameters and  to return a
      result,  some  knowledge of the  Pascal run-time  organization is
      required.   The calling program creates an activation record that
      is accessed via register 13.  This record contains the parameters
      and a  location to  receive the  returned result.    The record's
      layout is shown in Section 4.    The parameters correspond to the
      first few local variables.   Note that for VAR parameters,  it is
      the address  of the  argument that  is placed  in the  activation
      record.
-2.3  The Run-Time Environment
0          Prior to entry to the user  program,  the Pascal Sub Monitor
      acquires all the remaining storage  in the user program's region,
      and returns a small portion of this space to the operating system
      to be  used for  I/O buffers.  The  rest of  the storage  area is
      shared between the  run-time STACK,  where program (compile time)
      variables  are  allocated,  and  the  HEAP,   which is  used  for
      allocation  of   dynamic  storage  (created  explicitly   by  the
      programmer  through the  Standard Procedure  NEW).   The HEAP  is
      internally organized as another stack, which grows/shrinks in the
      opposite direction of  the variable allocation STACK,   and it is
      the programmer's responsibility to ensure that the two do not run
      into each other  in the course of the  program's execution.   The
      only notable restrictions imposed by  the run-time environment on
      the source  program are:  1)   a limit  of 10 distinct  levels of
      static nesting  of procedures,  an  arbitrary limit which  may be
      increased if needed,  and 2)  a limit  of 8K bytes on the size of
      individual procedures/functions (approx. 400..500 source lines).
1
0                                                               PAGE 17
02.3.1  JCL Parameter String
0          The user  may specify the  size of the  run-time STACK/HEAP,
      the size of the area to be  used for I/O buffers by the Operating
      System,  the maximum running time of  the program,  the number of
      run-time errors to be tolerated,  and generation of a memory dump
      in the 'PARM' field of the JCL 'EXEC' statement as follows:
-     // EXEC USERPROG,PARM='USER PARMS /STACK=xxxK,IOBUF=yyyK,
                     ERRLIM=n,TIME=zzzS,NOSNAP,NOSPIE,NOCC,DUMP'
0     'USER PARMS':  Parameter string to be  passed to the user program
      (if any).   The  user program can access this  string through the
      OSPARM built-in variable (see section 2.2.7).
0     'xxxK': Size of the storage area (in K bytes) to be allocated for
      the run-time  Stack and  Heap.   This  value,  if  not specified,
      defaults to the size of the largest obtainable contiguous area of
      memory minus the size of the I/O buffer area.
0     'yyyK': Size of the storage area (in K bytes) that is returned to
      the system  for use  as I/O  buffers etc.    This value  which is
      independent of  the Stack size  parameter (i.e.  the  xxx value),
      will be defaulted to '36K',  if  not specified by the user.   The
      default value,  depending on the BLKSIZE of the files used in the
      program, should be sufficient for 6/8 files.
0     'n':  The number  of (non fatal)  run-time errors  that should be
      tolerated before  the user program  is terminated.    The default
      value for 'n' is '1' and the program will normally stop execution
      after the first run time error is detected.
0     'zzzS':   Maximum (estimated)   running time  of  the program  in
      seconds.   If  this parameter  is present,   the program  will be
      stopped after the specified time limit.
0     'NOSNAP':  This suppresses the automatic call to SNAPSHOT that is
      usually made when the Pascal program  terminates due to an error.
      The option is useful if the symbol table file is unavailable,  if
      the  SNAPSHOT dump  would  waste  too much  paper  or  if the  P+
      compilation option was used.
0     'NOSPIE':  This suppresses the interception  of 'OCn' type abends
      by  the  sub-monitor.   The  option  would  only be  useful  when
      debugging by means of OS core dumps and for particularly stubborn
      errors (or  when the  bug is  not in  the Pascal  program but  in
      another program to which Pascal is linked).
0     'NOCC':  When this keyword is NOT present, the first character on
      each output line may be  consumed for character control purposes.
1
0                                                               PAGE 18
0     If NOCC is specified,  no control characters are assumed and they
      will be automatically  inserted by the sub-monitor.    The use of
      NOCC implies that the only  methods of controlling output spacing
      are the PAGE and SKIP built-in procedures.
0     'DUMP':  This  switch will cause  an OS  style memory dump  to be
      generated when the number of run-time errors equals the 'ERRLIM'.
0          If the user program is entered through the Loader, the above
      parameter  list should  be included  in  the 'PARM'  list to  the
      Loader, and separated from the Loader parms by the '/' delimiter.
-2.3.2  Invoking Pascal from Assembler Programs
0          Any Pascal program that has been saved as a load module (see
      Section 3)  may be invoked from an assembler program.   A typical
      calling sequence could be:
0              .
               LINK  EP=PASCAL,PARAM=(PARM1),VL=1
               .
               .
      PARM1    DC    H'13',CL13'/TIME=10,DUMP'
               .
0     The parameter corresponds  to the JCL parameter  string described
      in Section 3.1.  It is set up as a halfword, containing the count
      of characters,   immediately followed by those  characters.   The
      sub-monitor imposes a maximum length of 256 characters.
           In common with many IBM-supplied processors,  it is possible
      to provide  a second parameter  to specify ddnames  that override
      those used in  the Pascal program.   Only  the predefined ddnames
      (INPUT, OUTPUT,  PRD,  PRR,  QRD,  QRR)  can be overridden.   The
      second parameter  consists of  a halfword  integer followed  by a
      character  string  containing  the   replacement  ddnames.    The
      halfword  integer must  equal  the number  of  characters in  the
      string and it must be a multiple of 8.   For example,  to replace
      INPUT with SYSIN,  OUTPUT with SYSPRINT,   PRR with SYSUT1 and to
      leave the other ddnames unchanged:
0              .
               LINK  EP=PASCAL,PARAM=(PARM1,PARM2),VL=1
               .
               .
      PARM1    DC    H'13',CL13'/TIME=10,DUMP'
      PARM2    DC    H'32'            Length of following list
               DC    CL8'SYSIN'       replaces INPUT
               DC    CL8'SYSPRINT'    replaces OUTPUT
               DC    XL8'0'           defaults to PRD
               DC    CL8'SYSUT1'      replaces PRR
               .
1
0                                                               PAGE 19
0     As seen in the example,  an  entry of binary zeros indicates that
      the built-in ddname is to be used.   The entries in the list must
      be in order corresponding to INPUT, OUTPUT, PRD, PRR, QRD, QRR.
           Before control is returned to the calling program,  the sub-
      monitor closes all files used by  the Pascal program and releases
      all dynamically acquired storage.
-2.4  Compiler Outputs and Messages
0          Unless explicitly suppressd by the 'L-' option selector, the
      compiler generates a listing of the  source program as it is read
      in.    This  listing  also   includes  sequence  number,   static
      procedure/function nest  level and program/data  location counter
      fields on each line.
           The Level  field is  used to  indicate the  static level  at
      which each procedure or function is defined with the main program
      being at level 1.  This column can be used to determine the scope
      of  identifiers  in  the  program  and  also  clearly  marks  the
      beginning and ending of functions or procedures.
           While processing variable declarations  in each procedure or
      function,  the Program/Data Location  Counter field indicates the
      amount of storage  allocated for local variables  thus far.   The
      same  field  shows  the number  of  (intermediate)   instructions
      generated  for each  procedure or  function when  the body  (code
      section)  of these  routines are being compiled.   At  the end of
      each  procedure/function this  value shows  the  total number  of
      instructions emitted up  to that point in the program  and it can
      be  used as  an  indication  of the  size  of  the program  being
      compiled.   Each intermediate (P_CODE)  instruction approximately
      corresponds to one 'RX' type (i.e. 4-byte) 370 instruction.
-2.4.1  Compilation Error Messages
0          When the  compiler finds  a syntax error,   it will  place a
      marker ('@')  pointing  to the token past the  position where the
+                                          ____
      error was actually detected (i.e.  one  should search to the left
      and above  the pointer to  find the  cause of the  error).   Each
      error indicator is followed by an 'error number' that corresponds
      to the codes given in the Pascal User Manual and Report [1].   At
      the end  of compilation,  the meanings  for each error  code that
      occurred are printed out.   Runaway comments (i.e.  comments with
      bad or  missing closing brackets)  can  be easily located  by the
      frozen value of the 'P/D LC' field and improper BEGIN/END nesting
      or missing end of procedure/functions can be traced with the help
      of the value in the 'LVL' field.
0          Note:  error codes 398 and  399 correspond to implementation
      restrictions.
1
0                                                               PAGE 20
02.4.2  Post-Processor Error Messages
0          The following error  codes mostly indicate that  an internal
      table in the post-processor has overflowed.   In such cases,  the
      easiest  fix  is  to  split   the  Pascal  program  into  smaller
      procedures/functions and to nest the procedures more deeply.   If
      it is  necessary to  create a new  version of  the post-processor
      with larger  table sizes,   the appropriate  change is  indicated
      after the error message text below.
0     253- Procedure too long (larger than 8K bytes).
           --> Divide (the procedure) and conquer.
      254- Too many long (string) constants.
           --> Recompile  the Post_Processor  with a  larger value  for
           MXSTR.
      256- Too many Procedures/Functions referenced in this Proc.
           --> Recompile  the Post_Processor  with a  larger value  for
           MXPRC.
      259- Expression too complicated.
           --> Simplify the expression by rearranging and/or breaking.
      263- Too many (Compiler generated) Labels in this Procedure.
           --> Recompile  the Post_Processor  with a  larger value  for
           MXLBL.
      281- Too many Integer constants in this Procedure.
           --> Recompile  the Post_Processor  with a  larger value  for
           MXINT
      282- Too many Double Word (REAL,SET) constants in this Procedure.
           --> Recompile  the Post_Processor  with a  larger value  for
           MXDBL.
      300- Divide by Zero (result of constant propagation).
           --> Fix up the (constant) expression evaluating to Zero.
      302- Index/subrange value out of range (constant propagation ?)
           --> Fix up the (constant) expression to be within range.
      501- Array component too large (larger than 32K).
           --> Reduce the range of the last (rightmost) indecies of the
           array and/or  reorder the  dimensions of  the array  so that
           they are ordered from the largest (leftmost) to the smallest
           (rightmost).
-     The following  errors normally indicate  an inconsistency  in the
      Compiler and/or the Post_Processor.   For more detail about these
      (and similar) messages refer to the source of the program issuing
      the message.
0     601- Type conflict of operands in the P_Program.
      602- Operand should be of type 'ADR'.
      604- Illegal type for run-time checking.
      605- Operand should be of type 'BOOL'.
      606- Undefined P_Instruction code.
      607- Undefined Standard Procedure name.
      608- Displacement field (of address) out of range.
1
0                                                               PAGE 21
0     609- 'Small' Proc Larger than 4K.
           --> Recompile the Post_Processor with "SHRT_PROC = 300".
      611- Bad INTEGER alignment.
      612- Bad REAL alignment.
      613- Bad REAL constant.
      614- Inconsistent Procedure Table file "PRD".
           --> Fix the JCL and/or the 'QRR' output of the compiler.
-          The error messages, if any, are followed by the name and the
      line number of the Procedure in which they are detected.   If the
      Statement/expression   causing  the   error   cannot  be   easily
      identified,   you should  recompile  the  program with  the  'A+'
      Option, listing the output of the Post_Processor (or the Input to
      370/Assembler).   See  Section 3.4  for an example  of how  to do
      this.    As the  source program  line numbers  appear at  regular
      intervals in this outputg as well  as the source program listing,
      it should be easy to associate the error message with its source.
-2.4.3  Run-Time Errors
0          After a  run-time error has  occurred,  there is  usually an
      error message printed (either by SNAPSHOT or by the sub-monitor).
      However,   in some  circumstances (e.g.,   if no  OUTPUT file  is
      provided)  it  is necessary to deduce  the problem from  the user
      return code that  is normally printed with  the various operating
      system messages  for the job.   The  return code value  should be
      interpreted according to the following table.
0     Return Code:  Implies:
0         1001      INDEX VALUE OUT OF RANGE
          1002      SUBRANGE VALUE OUT OF RANGE
          1003      ACTUAL PARAMETER OUT OF RANGE
          1004      SET MEMBER OUT OF RANGE
          1005      POINTER VALUE INVALID
          1006      STACK/HEAP COLLISION
          1007      ILLEGAL INPUT/RESET OPERATION
          1008      ILLEGAL OUTPUT/REWRITE OPERATION
          1009      SYNCHRONOUS I/O ERROR
          1010      PROGRAM EXCEEDED THE SPECIFIED RUNNING TIME
          1011      INVALID FILE DEFINITION
          1012      NOT ENOUGH SPACE AVAILABLE
          1013      UNDEFINED OR OBSOLETE SUBMONITOR OPERATION
                    (should not occur)
          1014      LINELIMIT EXCEEDED FOR OUTPUT FILE
          1020      ILLEGAL INPUT PAST END OF FILE
          1021      BAD BOOLEAN ON INPUT
          1022      BAD INTEGER ON INPUT
          1023      BAD REAL ON INPUT
1
0                                                               PAGE 22
0         200X      PROGRAM INTERRUPTION CODE 'X'
0         3001      EXTERNAL ERROR (e.g. BAD PARAMETER TO MATH
                    ROUTINES LOG, SQRT,.... etc)
0         X1XX      UNABLE TO CALL ON 'SNAPSHOT' AFTER A RUN ERROR
                    (this happens  if there is  not enough space  or if
                    SNAPSHOT was not included in  the Load Module or if
                    the NOSNAP parameter was specified in JCL)
                    OTHER DIGITS OF  THE RETURN CODE TO  BE INTERPRETED
                    AS ABOVE
-     NOTE:  Return  codes 1007  or  1008 could  imply  a  bad or  non-
      existant DD Statement for the accessed file,  wrong direction for
      the I/O  operation or  an attempt  to access  a file  prior to  a
      RESET/REWRITE operation.  Code 1009 usually implies that the file
      has conflicting DCB attributes.
0          In  general,   error  messages point  to  the  (approximate)
      location of the  error within the Pascal  program.   Note however
      that the  predefined files appearing  in the program  heading are
      opened on entry to the Pascal program and any problems that arise
      will cause  error messages  that refer  to the  beginning of  the
      'main' program (and not to any statements using the files).
0          Appendix A contains a complete  directory of the error codes
      and messages generated by the compiler and the run-time system.
1
0                                                               PAGE 23
03.   System Set-up and Maintenance Procedures
-     To bring up the system follow these steps:
0       a) Transfer File 5  from tape to disk,  creating  a card format
           PDS.
0       b) Perform link-edits to  create load modules for  the compiler
           (Pascal), the P-Code assembler (ASMPCODE), the run-time sub-
           monitor (PASCMON) and the run profile generator (PASPROF).
0       c) Set up your JCL and run some sample programs.
0       d) You may also want to create  a Catalogued Procedure to avoid
           the bulky JCL for standard compilations.
-          The  following  are JCL  samples  you  may find  helpful  in
      creating the Load  Modules and running programs.    Note that the
      JCL statements provided here are meant  to be used as a guideline
      and they may need to be modified  before you can run them at your
      installation.
0     a)  Copy file  5 (PASLIB)  from the distribution tape  to a disk.
      You should substitute the volume-serial numbers of a scratch disk
      and  a disk  to hold  the Pascal  object library  for the  names,
      WORK01 and DISK99, respectively.   Warning: the control cards for
      IEHMOVE have a very rigid format.  Continuations are signalled by
      a non-blank character in column 72; the continued text must begin
      in column 16 of the next card.
-3.1  Copying Object Files from the Distribution Tape
0     //         JOB
      //COPY     EXEC PGM=IEHMOVE
      //SYSPRINT DD SYSOUT=A
      //SYSUT1   DD UNIT=DISK,DISP=OLD,VOL=SER=WORK01
      //SOURCE   DD UNIT=T9-1600,DISP=(OLD,KEEP),VOL=SER=PASCAL
      //TARGET   DD UNIT=DISK,VOL=SER=DISK99,DISP=OLD
      //SYSIN    DD *
       COPY DSNAME=WYL.CG.PAS.PASLIB,                            C
                     FROM=T9-1600=(PASCAL,5),FROMDD=SOURCE,      C
                     TO=DISK=DISK99,RENAME=PASCAL.PASLIB,CATLG
      //
-3.2  Generation of Load Modules
0     //         JOB
      //LKED     EXEC PGM=IEWL,PARM='MAP,NCAL'
1
0                                                               PAGE 24
0     //SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(1,1))
      //SYSLMOD  DD UNIT=DISK,DSN=PASCAL.SYSLMOD,
      //            SPACE=(TRK,(4,3,1),RLSE),DISP=(NEW,CATLG)
      //SYSPRINT DD SYSOUT=A
      //OBJECT   DD DSN=PASCAL.PASLIB,DISP=SHR
      //SYSLIN   DD *
        INCLUDE OBJECT(PASMON0,PASOBJ)
        NAME PASCAL
        INCLUDE OBJECT(PASMON0,ASMPOBJ)
        NAME ASMPCODE
        INCLUDE OBJECT(PASMON,PASSNAP)
        LIBRARY ($MAINBLK)
        ALIAS $PASENT
        NAME PASCMON
        INCLUDE OBJECT(PASMON0,PASPROF)
        NAME PASPROF
      //
-3.3  Running a Pascal Program
0          The following set  up can be used  to compile,  post_process
      and run  a user program.   Note  that the source program  is read
      from COMPILE.INPUT,  its listing is  sent to COMPILE.OUTPUT,  the
      intermediate    code     is    sent     to    COMPILE.PRR     and
      Procedure/Symbol/Counter   tables   are  sent   to   COMPILE.QRR.
      COMPILE.QRR enables the Compiler to print an error log at the end
      of the source listing in case  it detects any syntax error.   The
      option list for the compiler may be passed in the 'PARM' field of
      the 'EXEC' card for the COMPILE step.
0          If  there are  no  compilation  errors,  the  Post-Processor
      generates an object module (POSTPROC.PRR)  which is linked to the
      run-time monitor PASCMON.  The routine SNAPSHOT forms part of the
      PASCMON module.   SNAPSHOT  can be called directly  by the Pascal
      program or it  may be called automatically by  the sub-monitor in
      case of a run error.   In  either case,  SNAPSHOT will access the
      GO.QRD file to read symbol table information.  The D+ compilation
      option must be enabled for this information to be available.
0          If  the K+  option is  chosen  in the  source program,   the
      PASPROF module is automatically invoked at the end of the GO step
      in order  to print  a brief  summary of  the statement  execution
      frequencies.    If you  wish a  full  execution profile  listing,
      follow the  instructions given  in Section  3.6.   The  GO.PRD DD
      statement is required by the execution profiler.
0     Note:  this  JCL is  set up  in the  form of  an "in-stream"  JCL
      procedure.   Ideally, the JCL procedure should be copied into the
      catalogued  JCL procedures  library at  your installation.    The
      procedure consists of the PROC JCL  card and the following cards,
1
0                                                               PAGE 25
0     up to but  not including the PEND card.   Also  observe that only
      the member PASCMON (with alias name  $PASENT)  is loaded from the
      call library PASCAL.PASLMOD listed in the GO.SYSLIB DD statement.
      It may be  more appropriate to remove PASCMON from  this file and
      place it in some other load  module library that is referenced in
      GO.SYSLIB.
0     //         JOB
      //PASCAL   PROC GOTIME=10
      //*
      //*   STEP ONE:  COMPILE THE SOURCE PROGRAM
      //*
      //COMPILE  EXEC PGM=PASCAL,COND=(0,LT)
      //STEPLIB  DD DSN=PASCAL.PASLMOD,DISP=SHR
      //OUTPUT   DD SYSOUT=A
      //PRD      DD DSN=PASCAL.PASLIB(PASMSG),DISP=SHR
      //PRR      DD DSN=&&PCODE,UNIT=SYSDA,DCB=RECFM=VB,
      //            SPACE=(TRK,(20,5),RLSE),DISP=(,PASS)
      //QRR      DD DSN=&&TABLES,UNIT=SYSDA,DCB=RECFM=VB,
      //            SPACE=(TRK,(5,2),RLSE),DISP=(,PASS)
      //*
      //*   STEP TWO:  (POST) PROCESS THE P_CODE
      //*
      //POSTPROC EXEC PGM=ASMPCODE,COND=(0,LT)
      //STEPLIB  DD DSN=PASCAL.PASLMOD,DISP=SHR
      //INPUT    DD DSN=*.COMPILE.PRR,DISP=(OLD,DELETE)
      //PRD      DD DSN=*.COMPILE.QRR,DISP=(OLD,PASS)
      //OUTPUT   DD SYSOUT=A
      //PRR      DD DSN=&&OBJECT,UNIT=SYSDA,DCB=RECFM=FB,
      //            SPACE=(TRK,(10,5),RLSE),DISP=(,PASS)
      //*
      //*    STEP THREE:  LOAD AND GO
      //*
      //GO       EXEC PGM=LOADER,COND=(0,LT),PARM='//TIME=&GOTIME'
      //STEPLIB  DD DSN=PASCAL.PASLMOD,DISP=SHR   (NEEDED FOR K+ ONLY)
      //SYSLIN   DD DSN=*.POSTPROC.PRR,DISP=(OLD,DELETE)
      //SYSLOUT  DD SYSOUT=A
      //SYSLIB   DD DSN=SYS1.FORTLIB,DISP=SHR
      //         DD DSN=PASCAL.PASLMOD,DISP=SHR
      //PRD      DD DUMMY
      //QRD      DD DSN=*.COMPILE.QRR,DISP=(OLD,DELETE)
      //QRR      DD UNIT=SYSDA,SPACE=(TRK,(2,2))
      //FT06F001 DD SYSOUT=A
      //OUTPUT   DD SYSOUT=A
      //         PEND
      //*
      //RUN      EXEC PASCAL,PARM.COMPILE='compilation option list'
      //COMPILE.INPUT DD *
0       (* the Pascal source program *)
0     //GO.INPUT DD *
1
0                                                               PAGE 26
0       (* input data, if any *)
      //
-
 3.4  Inspection of Generated Code
0          This procedure can be used to inspect the 370/Assemblly code
      generated  by the  compiler.    The JCL  assumes  that the  (JCL)
      procedure, PASCAL, has been catalogued.   If it has not, you must
      insert the  procedure definition  as given in  3.3 after  the JOB
      card.   Note:  the assembly code that is produced can be combined
      with    the   macro    definitions   that    are   provided    in
      PASCAL.PASLIB(PBGN)  and  then assembled,   loaded and  executed.
      However,  this mode of operation is not recommended (the assembly
      time could be 3-4 times that of the compilation time).
0     //         JOB
      //PEEK     EXEC PASCAL,PARM.COMPILE='A+',COND.GO=(0,LE)
      //COMPILE.INPUT DD *
0     (* Pascal source program, including other options. NOTE 'A+' *)
0     //POSTPROC.PRR DD SYSOUT=A
      //
-
 3.5  Saving Pascal Programs as Load Modules
0          In order to  create a Load Module from a  Pascal program the
      following set up  can be used.   The JCL assumes  that a dataset,
      ARTHUR.LOAD,  has  previously been  allocated and  catalogued and
      will be  used to hold  the created  load module named  BILL.   As
      before, it assumes that PASCAL is a catalogued JCL procedure.  If
      it is not,  add the procedure  definition given in section 3.3 to
      the beginning  of this  card deck.    If you  are creating  a new
      version of a compiler program (i.e.,  the PASCAL or ASMPCODE load
      modules)   you  should   substitute  PASCAL.PASLIB(PASMON0)   for
      PASCAL.PASLMOD(PASCMON)  in the JCL.   This is to use the smaller
      faster version of the sub-monitor  that is recommended for "safe"
      programs.   If you  do not make this substitution,   no harm will
      result.
0     //         JOB
      //SAVE     EXEC PASCAL,COND.GO=(0,LE)
      //COMPILE.INPUT DD *
0       (* Pascal source program *)
0     //LKED     EXEC PGM=IEWL,PARM='MAP,LET'
      //SYSUT1   DD UNIT=SYSDA,SPACE=(TRK,(50,50))
1
0                                                               PAGE 27
0     //SYSLMOD  DD DSN=ARTHUR.LOAD(BILL),DISP=OLD
      //SYSPRINT DD SYSOUT=A
      //SYSLIB   DD DSN=SYS1.FORTLIB,DISP=SHR
      //SYSLIN   DD DSN=PASCAL.PASLMOD(PASCMON),DISP=SHR
      //         DD DSN=&&OBJECT,UNIT=SYSDA,DISP=(OLD,DELETE)
      //
-          To  run a  Pascal  program that  has been  saved  as a  load
      module, the following pattern of JCL may be used:
0     //         JOB
      //GO       EXEC PGM=BILL,PARM='/NOSNAP,TIME=15'
      //STEPLIB  DD DSN=ARTHUR.BILL,DISP=SHR
      //OUTPUT   DD SYSOUT=A
      //FT06F001 DD SYSOUT=A
      //*
      //*        DD CARDS FOR OTHER FILES, IF NEEDED.
      //*
      //INPUT    DD *
        (* Input Data - if required *)
      //
-3.6  Generation of Execution Profiles
0          The standard  JCL setup  (section 3.3)   will allow  a brief
      (very  condensed)  execution  profile  to be  printed  if the  K+
      compilation option is used. In order to generate the full profile
      (a  program listing  with  execution  frequencies alongside  each
      statement),  either  of the following  schemes can be  used.  The
      first method  is quite simple but  it requires the  Pascal source
      program to be available in a disk file.  Suppose it is stored and
      catalogued under the name SOURCE.PASCAL.  The following job could
      then produce the desired profile.
0     //         JOB
      //PROFILE  EXEC PASCAL,PARM.COMPILE='K+'
      //COMPILE.INPUT DD DSN=SOURCE.PASCAL,DISP=SHR
      //GO.PRD   DD DSN=SOURCE.PASCAL,DISP=SHR
      //GO.INPUT DD *
        (* Input Data - if required *)
      //
0          Alternatively,  the following JCL can  be used to generate a
      compiler-formatted program profile.  Some of  the extra JCL is to
      ensure that a  source listing is produced even if  the COMPILE or
      POSTPROC steps terminate with error(s).   As  in 3.3,  the JCL is
      arranged to use an in-stream procedure.  This procedure, PASCALK,
      should  ideally  be  added   to  your  installation's  catalogued
      procedures library also.
1
0                                                               PAGE 28
0     //         JOB
      //PASCALK  PROC GOTIME=10
      //*
      //*   STEP ONE:  COMPILE THE SOURCE PROGRAM
      //*
      //COMPILE  EXEC PGM=PASCAL,PARM='K+',COND=(0,LT)
      //STEPLIB  DD DSN=PASCAL.PASLMOD,DISP=SHR
      //OUTPUT   DD DSN=&&LISTING,UNIT=SYSDA,
      //            SPACE=(TRK,(10,10),RLSE),DISP=(,PASS)
      //PRD      DD DSN=PASCAL.PASRLIB(PASMSG),DISP=SHR
      //PRR      DD DSN=&&PCODE,UNIT=SYSDA,DCB=RECFM=VB,
      //            SPACE=(TRK,(20,5),RLSE),DISP=(,PASS)
      //QRR      DD DSN=&&TABLES,UNIT=SYSDA,DCB=RECFM=VB,
      //            SPACE=(TRK,(5,5),RLSE),DISP=(,PASS)
      //*
      //*   STEP TWO:  (POST) PROCESS THE P_CODE
      //*
      //POSTPROC EXEC PGM=ASMPCODE,COND=(0,LT)
      //STEPLIB  DD DSN=PASCAL.PASLMOD,DISP=SHR
      //INPUT    DD DSN=*.COMPILE.PRR,DISP=(OLD,DELETE)
      //PRD      DD DSN=*.COMPILE.QRR,DISP=(OLD,PASS)
      //OUTPUT   DD SYSOUT=A
      //PRR      DD DSN=&&OBJECT,UNIT=SYSDA,DCB=RECFM=FB,
      //            SPACE=(TRK,(10,5),RLSE),DISP=(,PASS)
      //*
      //*    STEP THREE:  LOAD AND GO
      //*
      //GO       EXEC PGM=LOADER,COND=(0,LT),PARM='//TIME=&GOTIME'
      //STEPLIB  DD DSN=PASCAL.PASLMOD,DISP=SHR
      //SYSLIN   DD DSN=*.POSTPROC.PRR,DISP=(OLD,DELETE)
      //SYSLIB   DD DSN=SYS1.FORTLIB,DISP=SHR
      //         DD DSN=PASCAL.PASLMOD,DISP=SHR
      //SYSLOUT  DD SYSOUT=A
      //SYSTERM  DD SYSOUT=A
      //PRD      DD DSN=*.COMPILE.OUTPUT,DISP=(OLD,PASS)
      //QRD      DD DSN=*.COMPILE.QRR,DISP=(OLD,PASS)
      //QRR      DD UNIT=SYSDA,SPACE=(TRK,(5,2))
      //OUTPUT   DD SYSOUT=A
      //FT06F001 DD SYSOUT=A
      //*
      //*    PRINT THE SOURCE PROGRAM IF ANY STEP FAILED
      //*
      //LISTSRC  EXEC PGM=IEBGENER,COND=((1000,GT,GO),EVEN)
      //SYSPRINT DD DUMMY
      //SYSIN    DD DUMMY
      //SYSUT1   DD DSN=*.COMPILE.OUTPUT,DISP=(OLD,DELETE)
      //SYSUT2   DD SYSOUT=A
      //*
      //         PEND
      //*
      //RUNCOUNT EXEC PASCALK
      //COMPILE.INPUT DD *
1
0                                                               PAGE 29
0       (* Pascal source program *)
0     //GO.INPUT DD *
        (* input data - if any *)
      //
0          Note that the profiler's actions are controlled by the input
      that it receives in the QRR file.  If the file is empty (as it is
      with the  JCL is  Section 3.3),   a brief  summary is  generated.
      Otherwise it may  contain the program text (either  as the source
      form or in the compilation output form) in which case,  a program
      listing  with statement  execution  frequencies  on the  left  is
      printed.
-3.7  Using External Pascal Procedures
0          To compile and save an external Pascal procedure/function as
      an object module.   The existance of a pre-allocated,  catalogued
      dataset  CHARLIE.OBJECT  to  hold the  object  code  is  assumed.
      Example coding:
0     //         JOB
      //SAVE     EXEC PASCAL,PARM.COMPILE='X+',COND.GO=(0,LE)
      //COMPILE.INPUT DD *
        (*  Note the X+ option  *)
        PROGRAM DUMMY;
           PROCEDURE EXTRT( PARM1, PARM2: REAL );
              VAR X,Y,Z: INTEGER;
              BEGIN
                 (* Body of the external routine *)
              END;
           BEGIN
              (* No main program code *)
           END.
      //POSTPROC.PRR DD DSN=CHARLIE.OBJECT,DISP=OLD
      //
-     An  example of  how  to use  this  saved  external procedure  now
      follows:
-     //         JOB
      //RUN      EXEC PASCAL
      //COMPILE.INPUT DD *
        PROGRAM MAIN(INPUT,OUTPUT);
           VAR S1, S2: REAL;
               (* other declarations omitted *)
           PROCEDURE EXTRT( PARM1, PARM2: REAL );  EXTERNAL;
               (* other procedure/function defs omitted *)
        BEGIN
1
0                                                               PAGE 30
0          .
           EXTRT( S1, S2 );  (* invoke the routine *)
           .
        END.
      //GO.SYSLIN DD
      //          DD
      //          DD DSN=CHARLIE.OBJECT,DISP=SHR
      //GO.INPUT  DD *
         (* input data - if any *)
      //
-3.8  Printing the Documentation File
0          To print another  copy of this document,   the following job
      may  be  submitted.    Note  that   the  SYSUT2  output  must  be
      transmitted to a  device that supports the  full upper/lower-case
      character set.
0     //         JOB
      //LIST     EXEC PGM=IEBPTPCH
      //SYSPRINT DD SYSOUT=A
      //SYSUT1   DD UNIT=T9-1600,DISP=(OLD,KEEP),VOL=SER=PASCAL,
      //            LABEL=(1,SL),DSN=WYL.CG.PAS.PASDOC
      //SYSUT2   DD SYSOUT=A   UPPER/LOWER-CASE PRINTER
      //SYSIN    DD *
        PRINT  PREFORM=A,MAXFLDS=1
        RECORD FIELD=(80)
      //
1
0                                                               PAGE 31
04.  Some Implementation Details
0          The  Sub Monitor,   entered  via  the $PASENT  entry  point,
      acquires all the space available  to the user program,  releasing
      some 36K bytes of  it for I/O buffers,  and sets  up the run-time
      STACK/HEAP as well as the  appropriate registers.   It then calls
      the user  program (at $MAINBLK)   and eventually  regains control
      upon proper  termination of  the program  or a  call to  the EXIT
      routine within the program. The monitor, if returned to through a
      call to EXIT,  will  return the argument of the EXIT  as the Step
      Return code, otherwise it will return a zero value.
-4.1  I/O and File Structure
0          The I/O routines handle all the operations on the Predefined
      Files,   with each  file having  its own  set of  flags and  data
      control block.    Locate-mode I/O  is used  universally and  this
      implies that  there is  effectively no limit  on the  file record
      sizes  other than  the  amount of  storage  available for  system
      buffers (controlled by the IOBUF  parameter).   Most file formats
      are  supported.    The  following  list  shows  all  the  allowed
      combinations of RECFM attributes:
                ( F or V )  [ B ]  [ S ]  [ A or M ]    or    U
      where  square  brackets  enclose an  optional  choice  and  round
      brackets enclose a compulsory choice.   For example,  FBSA and VB
      are allowed combinations.
           There is one  minor quirk.   Due to  a basic incompatibility
      between locate-mode I/O and U-format records, all output U-format
      records are written with their maximum length.   However,  a file
      containing  U-format  records  with varying  sizes  can  be  read
      correctly.
           Output lines  destined for F and  U format files  are padded
      with blanks  at their right  ends so  as to achieve  the required
      LRECL for the file.   V format  files do not require such padding
      and none is performed - except that the operating system will not
      accept completely  empty lines,   these are  replaced with  lines
      containing a single blank.
           Over-long output lines (i.e.,   they contain more characters
      than the file's LRECL value)  are  split whenever the LRECL value
      is exceeded.
           If DCB  attributes are  omitted from  the JCL  (and are  not
      available from the  dataset control block)  the  sub-monitor will
      supply  reasonable  defaults.    The default  values  are  chosen
      according to  the following rules (the  rules must be  applied in
      the order given):
0       1- If RECFM  is unspecified,  it defaults  to VB for  all files
           except OUTPUT;  for that file it defaults to VBA.
1
0                                                               PAGE 32
0       2- If LRECL is unspecified,  it defaults to a basic value of 80
           for all files except OUTPUT;   for that file it is 132.   If
           the RECFM includes the V attribute,  4 is added to the basic
           value.   If  the RECFM includes the  A or M  attributes,  an
           additional 1 is added.
0       3- If the BLKSIZE is unspecified,   then the default depends on
           whether the RECFM includes the V, F or U attribute.
           V: BLKSIZE is set to 1600 for  all files except OUTPUT;  for
              that file it is 3200.
           F: BLKSIZE is  chosen to  be the  largest multiple  of LRECL
              that does not exceed the numbers given above for RECFM=V.
              However,  if this  would cause BLKSIZE to  be zero,  then
              BLKSIZE is made equal to the LRECL value.
           U: The BLKSIZE is set equal to the LRECL.
0       4- If BUFNO  is unspecified,   it defaults to  3 for  all files
           except OUTPUT; for that file it defaults to 5.
-          To conform  to the  specification of  the Revised  Report of
      Pascal,  an extra blank is inserted at the end of every record of
      a textfile  on input.    For example,   if F  is a  textfile then
      successive  calls  to  GET(F)   will  step  F@  through  all  the
      characters in  the current  input record.   When  F@ is  the last
      character, another call to GET(F) will cause F@ to be a blank and
      EOLN(F) to become True.   One more call of GET(F) will step F@ to
      the first character of the next record.
           At  the end  of a  textfile,   the actions  are as  follows.
      Suppose that F@  refers to the last character in  the last record
      of the input file  F.   Then a call to GET(F)   will make EOLN(F)
      true and make F@ be a blank, however EOF(F) is still false.   One
      more call of GET(F) causes EOLN(F) and EOF(F) to both be true and
      F@ is still a  blank.   More calls of GET(F)  do  not change this
      situation.
           Character-by-character input  beyond the  end-of-file marker
      does  not  cause a  run-time  error  -  blanks are  simply  read.
      However,  any attempt  to read a Boolean,  Integer  or Real value
      past the end of file causes a run-time error.
-4.2  Procedure/Function Call Mechanism and Stack Organization.
0          Procedure  Calls  follow  the   usual  OS  conventions.   In
      addition, register 12 (GPR 12) points to the base (bottom) of the
      STACK, serving as the base register for the GLOBAL variables. GPR
      13 points to the base of the data area (activation record) of the
      currently active  procedure,  serving  as Base  Register for  the
      (very) LOCAL variables.   Everything in between (i.e.  non LOCAL,
      non  GLOBAL)  is  accessed by  loading  the base  address of  the
      associated  activation  record  from the  DISPLAY  table  into  a
1
0                                                               PAGE 33
0     temporary register (GPR 14 or 1).  The DISPLAY table,  consisting
      of 1 entry per static nesting level of the program, is within the
      GLOBAL data frame and thus  always accessible.   Note that GLOBAL
      program variables start after the  CHARacter File buffers and the
      variables defined  within procedures,   depending on  whether the
      FPRs are saved or not,  start after the FPR Save Area or Function
      result  location.   This  scheme  allows GPR  13  to  point to  a
      Register Save Area (with the usual forward/backward links)  while
      being the LOCAL data Base Register at the same time.
0          The  current  value of  the  HEAP  pointer  is kept  in  the
      location  following   the  GPR  Save   Area  and   this  location
      corresponds to the 'NP' register of the P_Machine.  GPR 10 and 11
      are used as Base Registers for the currently active Procedure and
      GPR 2..9  as well as FPR  2..4 make up the  expression evaluation
      stack. For more information on the organization of Run-Time stack
      and the use of the Display Table see [3] and [4].
-          The  following  table  shows the  state  of  the  STACK/HEAP
      structure while running a Pascal program.
-          STACK
0          GPR12-->  000- GLOBAL  (bottom of run-time STACK)
                     004- Back Link, Save Area.
                     008- Forward Link, Save Area.
                     012- GPR Save Area, (GPR14..GPR12).
                      .
                      .
                     072- Current HEAP (NEW) Pointer, 'NP'.
                     076- End of Heap Pointer, 'NP0'.
                     080- FPR Save Area.
                      .
                      .
                     112- Fix/Float Conversion Constants. (4 Double Words)
                      .
                      .
                     144- DISPLAY[1]
                      .     .
                      .     .
                     180- DISPLAY[10]
                     248- INPUT@  (INPUT file buffer)
                     249- OUTPUT@ (OUTPUT file buffer)
                     250- PRD@    (PRD file buffer)
                     251- PRR@    (PRD file buffer)
                     252- QRD@    (QRD file Buffer)
                     253- QRR@    (QRR file buffer)
                      .           (buffers for other files)
                      .
                     280- DATE
1
0                                                               PAGE 34
0                    290- TIME
                     300- OSPARM
                     304- First (user declared) GLOBAL program variable.
                      .
                      .
                      .
                      .
0          GPR13-->  8n+0 LOCAL  (current Stack Frame)
                     +004 Back Link, Save Area.
                     +008 Forward Link, Save Area (NIL at this time).
                     +012 GPR Save Area, (GPR14..GPR12).
                      .
                      .
                     +072 FUNCTION result, (unused in case of PROCEDUREs)
                     +080 FPR save area (optional)
                     +080 LOCAL  (first local variable if FPRs not saved)
                      .
                      .
                     +112 LOCAL  (first local variable, if FPRs saved)
                      .
                      .
                      .
                      .
           NP -->    8m   Next (to be) allocated DYNAMIC variable.
                      .
                      .        (HEAP area already allocated)
                      .
           NP0 -->   8j   End of HEAP and user data space.
0          HEAP
-     Note:    Program  variables   are  allocated  in  the   order  of
      declaration  within  each  declaration   group  and  the  address
      appearing in the source listing produced by the compiler,  is the
      address  of the  first variable  allocated in  that group.    For
      example the program listing:
0        1 304 0   PROGRAM NONSENSE(OUTPUT) ;
         2 304 1   VAR  I, J, K : INTEGER;
         3 316 1        CH, NXTCH : CHAR ;
         4 318 1        ...
                        ...
0     means that Location 304 is assigned to the variable I,
                          308                             J,
                          312                             K,
                          316                             CH,
                          317                             NEXTCH,
      etc.
1
0                                                               PAGE 35
0          The  comments preceding  the source  code  of the  compiler,
      postprocessor  and  the  I/O  module  also  provide  some  useful
      information for those interested in the  organization of the run-
      time environment.
-4.3  Hints on Run Time Errors
0          In  case you  encounter  a run-time  error  while running  a
      program (i.e.  a program ABEND), first check the following points
      before resorting to the OS generated DUMP.
-     1) See if the appropriate options are specified (e.g., you should
      not run a program with the C- option selected).
0     2)  Make  sure all the  files used in  the program appear  in the
      parameter  list   of  the  PROGRAM   statement,  and/or  they are
      RESETed/REWRITten before  any operation takes place.    Also note
      that the  direction of  operation should  be compatible  with the
      file and/or the previous RESET/REWRITE on that file (i.e. no READ
      from output or  after a REWRITE etc.)   If the  run-time check is
      enabled (either by default or an explicit 'D+')  or a Run Profile
      (execution frequency of program statements)   is requested by the
      'K+' switch,   it is  important that the  JCL for  the additional
      Symbol Table  and/or Counter files  are properly included  in the
      user program.  A missing or incorrect DD statement for such files
      may cause  the program  to be  terminated in  the Pascal  monitor
      without a clear connection to the user program.
0     3)  Check that there is a DD statement for every file used in the
      program and RECFM, LRECL and BLKSIZE have acceptable values.
0     4)  The size of the region in which you run the program should be
      sufficient to accommodate the code as well as data.   The program
      listing gives you an approximate idea  of the size of the program
      and the data area.   Recursive  procedures however,  depending on
      how deep the  recursion goes,  may need much more  space than the
      size of their local variables may suggest.   You can check to see
      if the  run-time STACK  and HEAP are  colliding by  comparing the
      HEAP pointer (at GPR12@+72) and GPR13 which points to the base of
      the LOCAL data area.
0     5) Check for bad (uninitialized, out of range) indices as well as
      illegal pointer  references caused by  uninitialized/NIL pointers
      in the procedure causing the ABEND.
-     Also  see  the  extended run-time  checking  facilities  (the  D+
      compilation option).
1
0                                                               PAGE 36
04.4  Storage Saving Considerations
-          In general the P_Code assembler trades memory for speed and,
      in  particular,  it  prefers a  sequence of  RX and  RR type  370
      instructions over  the corresponding  SS type  instructions which
      tend to be more compact though  usually slower (the difference is
      quite noticeable  on the  larger 370  models).   However,   it is
      possible to  reduce the  storage requirement  of your  program in
      certain cases.
0     1) Dynamic storage  is currently allocated on  8-byte boundaries.
         If you do not  use this kind of storage for  REAL values,  you
         can change the alignment factor to 4 (= INTSIZE) as opposed to
         8 (= REALSIZE)  in the Procedure  NEW1 of the Compiler.   This
         should improve  memory usage specially  if dynamic  storage is
         heavily used.
0     2) The current sub-monitor releases some  36K bytes of storage to
         be used for  I/O buffers.   This space could be  reduced to as
         little as 8K, leaving the rest for the user program,  by using
         smaller BLKSIZEs for the files.    By reducing the above space
         to 8K, you can compile the Compiler in a 128K region.
0     3) If you  group variables  and fields  with the  same (internal)
         type together,   you may  improve the  storage utilization  by
         cutting  down  on  fragmentation  of  the  memory.    This  is
         particularly important in the case  of ARRAYs OF RECORDs which
         contain  fields of  different  types.    The rearrangement  of
         fields, however,  should not be done at the expense of clarity
         and logical continuity of  data declarations.
0     4) See the Pack Option in section 2.3.8.
1
0                                                               PAGE 37
05.  Examples
0          The following program  (a small deviation from  the standard
      Factorial example)   shows a simple  -and very expensive-  way of
      generating a table  of Fibonacci Numbers and it is  also meant to
      illustrate the  Compilation,  Post_Processing and Execution  of a
      typical Pascal program.    The compiler output has  been slightly
      edited to compress its width across the page.
-         " Sample Program, including the necessary JCL "
0     //         JOB
      //TEST     EXEC PASCAL
      //COMPILE.INPUT DD *
0     PROGRAM fib_demo(OUTPUT) ;
0     TYPE pos_int = 0..30 ;
0     VAR  i    : pos_int ;
         time  : INTEGER ;
0      FUNCTION fibonacci(j :pos_int) : INTEGER ;
       (*To evaluate fibonacci # j, for j >= 0,
                             subject to integer overflow*)
0       BEGIN
        IF j = 0 THEN fibonacci := 0
        ELSE IF j = 1 THEN fibonacci := 1
          ELSE fibonacci := fibonacci(j-1) + fibonacci(j-2) ;
        END ;
0      BEGIN (*fib_demo*)
       FOR i := 10 TO 25 DO
        BEGIN  time := CLOCK(0) ;
        WRITELN(' Fibonacci # ', i:3, ' is :', fibonacci(i):6,
        '  (Compute time =', CLOCK(0)-time:5, ' Milli Sec.)') ;
        END ;
       END.
      //
-
           " Source Program listing generated by the Compiler "
-     LINE # P/D LC LVL < Stanford Pascal Compiler, Version of July-78 >
0        1   288 1) PROGRAM fib_demo(OUTPUT);
         2   288 1)
         3   288 1) TYPE pos_int = 0..30;
1
0                                                               PAGE 38
0        4   288 1)
         5   288 1) VAR  i    : pos_int;
         6   292 1)      time : INTEGER;
         7   296 1)
         8   296 1)  FUNCTION fibonacci(j :pos_int) : INTEGER;
         9    84 2)  (*To evaluate fibonacci # j, for j >= 0,
                                          subject to integer overflow*)
        10    84 2)
        11    84 2)   BEGIN
        12     0 2)   IF j = 0 THEN fibonacci := 0
        13     5 2)   ELSE IF j = 1 THEN fibonacci := 1
        14    12 2)     ELSE fibonacci := fibonacci(j-1) + fibonacci(j-2);
        15    29 2)   END;
        16    84 2)
        17    84 2)  BEGIN (*fib_demo*)
        18     0 1)  FOR i := 10 TO 25 DO
        19    15 1)   BEGIN  time := CLOCK(0);
        20    18 1)   WRITELN(' Fibonacci # ', i:3, ' is :', fibonacci(i):6,
        21    37 1)   '  (Compute time =', CLOCK(0)-time:5, ' Milli Sec.)');
        22    53 1)   END;
        23    62 1)  END.
-       ****   NO SYNTAX ERROR(S) DETECTED.
0       ****   23 LINE(S) READ,  1 PROCEDURE(S) COMPILED,
0       ****   94 P_INSTRUCTIONS GENERATED,  0.04 SECONDS IN COMPILATION.
-
           " Post_Processor messages "
-       ****   NO ASSEMBLY ERROR(S) DETECTED.
0       ****   672 BYTES OF CODE GENERATED, 0.05 SECONDS IN P_CODE ASSEMBLY.
-
           " Output of the Sample Program "
-      Fibonacci # 10 is :    55  (Compute time =    4 Milli Sec.)
       Fibonacci # 11 is :    89  (Compute time =    5 Milli Sec.)
       Fibonacci # 12 is :   144  (Compute time =    8 Milli Sec.)
       Fibonacci # 13 is :   233  (Compute time =   12 Milli Sec.)
       Fibonacci # 14 is :   377  (Compute time =   19 Milli Sec.)
       Fibonacci # 15 is :   610  (Compute time =   31 Milli Sec.)
       Fibonacci # 16 is :   987  (Compute time =   51 Milli Sec.)
       Fibonacci # 17 is :  1597  (Compute time =   83 Milli Sec.)
       Fibonacci # 18 is :  2584  (Compute time =  133 Milli Sec.)
1
0                                                               PAGE 39
0      Fibonacci # 19 is :  4181  (Compute time =  215 Milli Sec.)
       Fibonacci # 20 is :  6765  (Compute time =  348 Milli Sec.)
       Fibonacci # 21 is : 10946  (Compute time =  565 Milli Sec.)
       Fibonacci # 22 is : 17711  (Compute time =  914 Milli Sec.)
       Fibonacci # 23 is : 28657  (Compute time = 1475 Milli Sec.)
       Fibonacci # 24 is : 46368  (Compute time = 2386 Milli Sec.)
       Fibonacci # 25 is : 75025  (Compute time = 3862 Milli Sec.)
-
0          The  following is  the result  of running  the same  program
      after having been modified to cause a Run Error.
-          " Output of the Compile/Post_Process step "
-     LINE # P/D LC LVL < Stanford Pascal Compiler, Version of July-78 >
0        1   288 1) PROGRAM fib_demo(OUTPUT);
         2   288 1)
         3   288 1) TYPE pos_int = 0..30;
         4   288 1)
         5   288 1) VAR  i    : pos_int;
         6   292 1)      time : INTEGER;
         7   296 1)
         8   296 1)  FUNCTION fibonacci(j :pos_int) : INTEGER;
         9    84 2)  (*To evaluate fibonacci # j, for j >= 0,
                                          subject to integer overflow*)
        10    84 2)
        11    84 2)   BEGIN
        12     0 2)   IF j = 0 THEN fibonacci := 0
        13     5 2)   ELSE IF j = 1 THEN fibonacci := 1
        14    12 2)     ELSE fibonacci := fibonacci(j-1) + fibonacci(j-3);
        15    29 2)   END;
        16    84 2)
        17    84 2)  BEGIN (*fib_demo*)
        18     0 1)  FOR i := 10 TO 25 DO
        19    15 1)   BEGIN  time := CLOCK(0);
        20    18 1)   WRITELN(' Fibonacci # ', i:3, ' is :', fibonacci(i):6,
        21    37 1)   '  (Compute time =', CLOCK(0)-time:5, ' Milli Sec.)');
        22    53 1)   END;
        23    62 1)  END.
-      ****   NO SYNTAX ERROR(S) DETECTED.
0      ****   23 LINE(S) READ,  1 PROCEDURE(S) COMPILED,
0      ****   94 P_INSTRUCTIONS GENERATED,  0.04 SECONDS IN COMPILATION.
1
0                                                               PAGE 40
0      ****   NO ASSEMBLY ERROR(S) DETECTED.
0      ****   672 BYTES OF CODE GENERATED, 0.05 SECONDS IN P_CODE ASSEMBLY.
-
           " Output of the GO step "
-     Fibonacci # 10 is :
        **** SNAPSHOT DUMP OF PROGRAM ****
0       **** 'SNAPSHOT' was called by --> 'Pascal_MONITOR'
        **** Run Error: 1002 from line: 14 of procedure: 'fibonacci'
        **** SUBRANGE VALUE OUT OF RANGE
        **** The offending value: -1 is not in the range: 0..30
0       **** Variables for 'fibonacci' are:
0          j   = 2
0       **** procedure 'fibonacci' was called by --> 'fibonacci' from line: 14
0       **** Variables for 'fibonacci' are:
0          j   = 3
0       **** procedure 'fibonacci' was called by --> 'fibonacci' from line: 14
0       **** Variables for 'fibonacci' are:
0          j   = 4
0       **** procedure 'fibonacci' was called by --> 'fibonacci' from line: 14
0       **** Variables for 'fibonacci' are:
0          j   = 5
0       **** procedure 'fibonacci' was called by --> 'fibonacci' from line: 14
0       **** Variables for 'fibonacci' are:
0          j   = 6
0       **** procedure 'fibonacci' was called by --> 'fibonacci' from line: 14
0       **** Variables for 'fibonacci' are:
0          j   = 7
0       **** procedure 'fibonacci' was called by --> 'fibonacci' from line: 14
1
0                                                               PAGE 41
0       **** Variables for 'fibonacci' are:
0          j   = 8
0       **** procedure 'fibonacci' was called by --> 'fibonacci' from line: 14
0       **** Variables for 'fibonacci' are:
0          j   = 9
0       **** procedure 'fibonacci' was called by --> 'fibonacci' from line: 14
0       **** Variables for 'fibonacci' are:
0          j   = 10
0       **** procedure 'fibonacci' was called by --> '$MAINBLK' from line: 20
0       **** Variables for '$MAINBLK' are:
0          i   = 10
           time  = 25
0       **** END OF DUMP ****
-          The following is  the result of yet another run  of the same
      program  with the  'K+' option.   The (only)   source listing  is
      generated by the last  step in the run and it  followes any other
      output that the user program may prooduce.  The prototype JCL for
      this  run  is provided  in  section  3.6.   (Note  the  increased
      "compute" time.)
-          " Output of the Compile/Post_Process step "
0       ****   NO ASSEMBLY ERROR(S) DETECTED.
0       ****   804 BYTES OF CODE GENERATED, 0.06 SECONDS IN P_CODE ASSEMBLY.
-
           " Output of the GO step - including the Profiler output "
-         Fibonacci # 10 is :    55  (Compute time =    3 Milli Sec.)
          Fibonacci # 11 is :    89  (Compute time =    5 Milli Sec.)
          Fibonacci # 12 is :   144  (Compute time =    8 Milli Sec.)
          Fibonacci # 13 is :   233  (Compute time =   13 Milli Sec.)
          Fibonacci # 14 is :   377  (Compute time =   20 Milli Sec.)
          Fibonacci # 15 is :   610  (Compute time =   33 Milli Sec.)
          Fibonacci # 16 is :   987  (Compute time =   54 Milli Sec.)
1
0                                                               PAGE 42
0         Fibonacci # 17 is :  1597  (Compute time =   87 Milli Sec.)
          Fibonacci # 18 is :  2584  (Compute time =  140 Milli Sec.)
          Fibonacci # 19 is :  4181  (Compute time =  227 Milli Sec.)
          Fibonacci # 20 is :  6765  (Compute time =  369 Milli Sec.)
          Fibonacci # 21 is : 10946  (Compute time =  595 Milli Sec.)
          Fibonacci # 22 is : 17711  (Compute time =  963 Milli Sec.)
          Fibonacci # 23 is : 28657  (Compute time = 1562 Milli Sec.)
          Fibonacci # 24 is : 46368  (Compute time = 2527 Milli Sec.)
          Fibonacci # 25 is : 75025  (Compute time = 4092 Milli Sec.)
-
           " Ouput of the PROFILE step "
-     LINE # RUN CNT LVL < Stanford Pascal Compiler, Version of July-78 >
-        1         1) (*$K+*)
         2         1) PROGRAM fib_demo(OUTPUT);
         3         1)
         4         1) TYPE pos_int = 0..30;
         5         1)
         6         1) VAR  i    : pos_int;
         7         1)      time : INTEGER;
         8         1)
         9         1)  FUNCTION fibonacci(j :pos_int) : INTEGER;
        10         2)  (*To evaluate fibonacci # j, for j >= 0,
                                          subject to integer overflow*)
        11         2)
        12         2)   BEGIN
        13 121338  2)   IF j = 0 THEN fibonacci := 0
        14 196329  2)   ELSE IF j = 1 THEN fibonacci := 1
        15 317651  2)     ELSE fibonacci := fibonacci(j-1) + fibonacci(j-2);
        16 635318  2)   END;
        17         2)
        18         2)  BEGIN (*fib_demo*)
        19      1  1)  FOR i := 10 TO 25 DO
        20     16  1)   BEGIN  time := CLOCK(0);
        21     16  1)   WRITELN(' Fibonacci # ', i:3, ' is :', fibonacci(i):6,
        22     16  1)   '  (Compute time =', CLOCK(0)-time:5, ' Milli Sec.)');
        23     16  1)   END;
        24      1  1)  END.
-      ****   NO SYNTAX ERROR(S) DETECTED.
0      ****   24 LINE(S) READ,  1 PROCEDURE(S) COMPILED,
0      ****   100 P_INSTRUCTIONS GENERATED,  0.05 SECONDS IN COMPILATION.
1
0                                                               PAGE 43
06.   Changed Features and New Options
-          The following list is provided as  a convenience to users of
      previous versions of Stanford Pascal.   The list briefly mentions
      the features that are new or are implemented differently from the
      earlier  versions.    These  features either  correspond  to  the
      standard Pascal now, as described in Jensen and Wirth [1], or are
      described in an earlier section of this document.
0     -Global  textfiles  may  now  be   declared  and  passed  as  VAR
      parameters to procedures or functions.
0     -The character set is now the EBCDIC character set and not the 63
      character set that  corresponded to the CDC  Scientific character
      set.
0     -The predefined constant  MAXINT,  the predefined types  ALFA and
      TEXT,   the predefined  functions  and  procedures PAGE,   ROUND,
      LINELIMIT, CARD, SKIP and EXPO are provided.
0     -The predefined variables DATE, TIME and OSPARM are added.
0     -The sub-monitor now handles most IBM file formats.
0     -The sub-monitor now supports input and output of Booleans.
0     -The sub-monitor now checks the format of Booleans,  integers and
      reals that are input.  It also rejects any attempt to read any of
      these same datatypes when the end of file is reached.
0     -The sub-monitor will automatically  invoke the execution profile
      generator (PASPROF load module)  if  the Pascal execution outputs
      run counts  to the  QRR file  (i.e.,  if  the Pascal  program was
      compiled with the K+ option).
0     -The input of character strings is now handled differently.
0     -The JCL parameters passed to the sub-monitor now include NOSNAP,
      NOSPIE and NOCC.
0     -User parameter strings may be passed to the Pascal program.
0     -Comments may  be nested (under  control of the  'N+' compilation
      option).
0     -The M (margins) compilation option has an extended meaning.
0     -The sequence number field on input cards (col.s 73-80) no longer
      is  printed  instead  of  the  source  line  number  when  M+  is
      specified.
1
0                                                               PAGE 44
0     -Compilation input is no longer  restricted to card image format.
      The input may contain any of  the allowed file formats,  but only
      the first 120 characters in each record are significant.
0     -Subranges such as 1..10 are acceptable labels in CASE statements
      or the variant  parts of records.   Also subranges  may appear in
      constants of type SET;  e.g., [1..4] is equivalent to [1,2,3,4].
0     -Functions of type SET may be declared.
0     -The tag field of a case variant record may be left unnamed.
0     -The  offsets  of  variables  in   the  stack  are  now  assigned
      differently.
0     -The  first   12  characters  of   Pascal  identifiers   are  now
      significant.
0     -Lower  case letters  may  be used  in  identifiers and  reserved
      words.
0     -External Pascal procedures may be created and used.
0     -FORTRAN  subroutines/functions   may  be   called  from   Pascal
      programs.  (A separate version of the sub-monitor is not required
      for this.)
0     -The different versions  of the run-time support  routine PMONSRC
      are  now  merged into  a  single  program  and  with the  use  of
      (boolean) assembly time switches,  one may get the compact object
      form suitable for system programs, or the full sized object to be
      used in conjunction with user programs.
0     -Standard procedures PACK and UNPACK are now implemented.
1
0                                                               PAGE 45
0     Acknowledgements
0          This note  owes a  great deal  to Nigel  Horspool of  McGill
      University  who,  amongst  other things,   converted  a group  of
      chronologically ordered  sections into the present  document.  He
      also upgraded the I/O interface to provide support for various OS
      file formats  and helped  in the  implementation of  most of  the
      improvements in  the current version.    The SNAPSHOT  routine is
      written by Eral Waldin of  SLAC.   The run-time profile generator
      PROFILER is due to  Nigel Horspool and it is based  on an earlier
      profile program by  Richard Sites of LASL.   The  programs in the
      TESTLIB are  contributed by many people  and it is hoped  that it
      will  evolve  into  a  library of  utility  routines  of  general
      interest to Pascal users.
-     References:
0     [1] K.  JENSEN, N.  WIRTH.  'Pascal, User Manual and Report' (2nd
          ed.), Springer-Verlag, New York, 1975.
0     [2] K. NORI, U.  AMMAN, K.  JENSEN, H.   NAGEL.   'The Pascal "P"
          Compiler,   Implementation  Notes',   Berichte  des Instituts
          fur Informatik, E.T.H. Zurich, DEC. 1974.
0     [3] D. GRIES. 'Compiler Construction for Digital Computers', John
          Wiley and Sons, New York, 1971.
0     [4] S. HAZEGHI. 'Bootstrap and Adaptation of a Pascal Compiler on
          the IBM/370 System',  CGTM-194,   Stanford Linear Accelerator
          Center, July 1979.
0     [5] S.  HAZEGHI, L.  WANG.  'A Short Note on High Level Languages
          and  Microprocessors', Conference Proceedings of the 2nd West
          Coast Computer Fair, San Jose, CA., March 1978.
0     [6] E.  GILBERT, D.  WALL.  'SOPAIPILLA Maintenance Manual',  CSL
          Technical Report no. 158, Stanford University, March 1978.
0     [7] B.  HITSON.   'Pascal/P_Code Cross Compiler for  the LSI-11',
          SLAC-PUB-2246, Stanford Linear Accelerator Center, Jan. 1979.
-
0                              Sassan Hazeghi,  Nov. 1976.
0                              Computation Research Group,
                               Stanford Linear Accelerator Center,
                               Box 4349,
                               Stanford, CA. 94305.
1
0                                                               PAGE 46
0                              Phone (415) 854-3300 x2359.
-                              Date of last update:   Jan.-26-77.
                                                      Mar.-04-77.
                                                      May -20-77.
                                                      June-09-77.
                                                      Nov.-15-77.
                                                      Jul.-28-78
                                                      Sep.-18-78
                                                      May -20-79
                                                      July-01-79
                                                      Aug -09-79
                                                      Sept-26-79 "RNH"
                                                      Oct.-18-79
1
0                                                               PAGE 47
0     Appendix A
-     1- Pascal compiler error messages:
0        1- error in simple type.
         2- identifier expected.
         3- "program" expected.
         4- ")" expected.
         5- ":" expected.
         6- illegal symbol.
         7- error in parameter list.
         8- "of" expected.
         9- "(" expected.
        10- error in type.
        11- left square bracket expected.
        12- right square bracket expected.
        13- "end" expected.
        14- ";" expected.
        15- integer expected.
        16- "=" expected.
        17- "begin" expected.
        18- error in declaration part.
        19- error in field list.
        20- "," expected.
        21- "*" expected.
        50- error in constant.
        51- ":=" expected.
        52- "then" expected.
        53- "until" expected.
        54- "do" expected.
        55- "to" or "downto" expected.
        56- "if" expected.
        57- "file" expected.
        58- error in factor.
        59- error in variable.
       101- identifier declared twice.
       102- low bound exceeds highbound.
       103- identifier is not of appropiate class.
       104- identifier is not declared.
       105- sign not allowed here.
       106- number expected.
       107- incompatible subrange types.
       108- file not allowed here.
       109- type must not be real.
       110- tagfield type must be scalar or subrange.
       111- incompatible with tagfield type.
       112- index type must not be real.
       113- index type must be scalar or subrange.
       114- base type must not be real.
       115- base type must be scalar or subrange.
       116- error in type of standard procedure parameter.
1
0                                                               PAGE 48
0      117- unsatisfied forward reference.
       118- forward reference type identifier in variable declaration.
       119- forward declared; repetition of parameter list not allowed.
       120- function result type must be scalar, subrange, or pointer.
       121- file value parameter not allowed.
       122- forward declared function; repetion of result type illegal.
       123- missing result type in function declaration.
       124- f-format is for real type only.
       125- error in type of standard function parameter.
       126- number of parameters does not agree with declaration.
       127- illegal parameter substitution.
       128- result type of parm function does not agree with declaratn.
       129- type conflict of operands.
       130- expression is not of set type.
       131- only tests on equality allowed.
       132- strict inclusion not allowed.
       133- file comparison not allowed.
       134- illegal type of operand(s).
       135- type of operand must be boolean.
       136- set element must be scalar or subrange.
       137- set element types not compatible.
       138- type of variable is not an array.
       139- index type is not compatible with declaration.
       140- type of variable is not a record.
       141- type of variable must be a file or pointer.
       142- illegal parameter substitution.
       143- illegal type of loop control variable.
       144- illegal type of expression.
       145- type conflict.
       146- assignment of files not allowed.
       147- label type incompatible with selecting expression.
       148- subrange bounds must be scalar.
       149- index type must not be integer.
       150- assignment to standard function is not allowed.
       151- assignment to formal function is not allowed.
       152- no such field in this record.
       153- type error in read.
       154- actual parameter must be a variable.
       155- control variable may not be declared on intermediate level.
       156- multiply defined case label.
       157- too many cases in case statement.
       158- missing corresponding variant declaration.
       159- real or string tagfields not allowed.
       160- previous declaration was not forward.
       161- duplicate forward declarations.
       162- parameter size must be constant.
       163- missing variant in declaration.
       164- substitution of standard procedure/function not allowed.
       165- multidefined label.
       166- multideclared label.
       167- undeclared label.
       168- undefined label.
1
0                                                               PAGE 49
0      169- error in base set.
       170- value parameter expected.
       171- standard file was redeclared.
       172- undeclared external file.
       173- FORTRAN procedure or function expected.
       174- Pascal procedure or function expected.
       175- missing file "input" in program heading.
       176- missing file "output" in program heading.
       177- assignment to function identifier not allowed here.
       178- multiply defined record variant.
       179- X-opt of actual proc/func does not match formal declaration.
       180- control variable must not be formal.
       181- constant part of address out of range.
       201- error in real constant- digit expected.
       202- string constant must not exceed source line.
       203- integer constant exceeds range.
       204- 8 or 9 in octal number.
       205- zero length string not allowed.
       206- integer part of real constant exceeds range.
       250- too many nested scopes of identifiers.
       251- too many nested procedures and/or functions.
       252- too many forward references of procedure entries.
       253- procedure too long.
       254- too many long constants in this procedures.
       255- too many errors in this source line.
       256- too many external references.
       257- too many externals.
       258- too many local files.
       259- expression too complicated.
       260- too many exit labels.
       300- division by zero.
       301- no case provided for this value.
       302- index expression out of bounds.
       303- value to be assigned is out of bounds.
       304- element expression out of range.
       390- premature end of program, (bad program structure).
       398- implementation restriction.
       399- variable dimension arrays not implemented.
       400- illegal expression.
       401- compiler consistency check !
1
0                                                               PAGE 50
0     2- Pascal post-processor error messages:
-      253- Procedure too long (larger than 8K bytes).
            --> Divide (the procedure) and conquer.
       254- Too many long (string) constants.
            --> Recompile  the Post_Processor with  a larger  value for
            MXSTR.
       256- Too many Procedures/Functions referenced in this Proc.
            --> Recompile  the Post_Processor with  a larger  value for
            MXPRC.
       259- Expression too complicated.
            --> Simplify the expression by rearranging and/or breaking.
       263- Too many (Compiler generated) Labels in this Procedure.
            --> Recompile  the Post_Processor with  a larger  value for
            MXLBL.
       281- Too many Integer constants in this Procedure.
            --> Recompile  the Post_Processor with  a larger  value for
            MXINT
       282- Too  many   Double  Word  (REAL,SET)   constants   in  this
            Procedure.
            --> Recompile  the Post_Processor with  a larger  value for
            MXDBL.
       300- Divide by Zero (result of constant propagation).
            --> Fix up the (constant) expression evaluating to Zero.
       302- Index/subrange value out of range (constant propagation ?)
            --> Fix up the (constant) expression to be within range.
       501- Array component too large (larger than 32K).
            --> Reduce the  range of the last  (rightmost)  indecies of
            the array  and/or reorder  the dimensions  of the  array so
            that they are  ordered from the largest  (leftmost)  to the
            smallest (rightmost).
-      Compiler/Post-processor concistancy checks:
0      601- Type conflict of operands in the P_Program.
       602- Operand should be of type 'ADR'.
       604- Illegal type for run-time checking.
       605- Operand should be of type 'BOOL'.
       606- Undefined P_Instruction code.
       607- Undefined Standard Procedure name.
       608- Displacement field (of address) out of range.
       609- Small Proc Larger than 4K.
            --> Recompile the Post_Processor with "SHRT_PROC = 300".
       611- Bad INTEGER alignment.
       612- Bad REAL alignment.
       613- Bad REAL constant.
       614- Inconsistent Procedure Table file "PRD".
            --> Fix the JCL and/or the 'QRR' output of the compiler.
1
0                                                               PAGE 51
0     3- Runtime error messages:
-     1001- index value out of range.
      1002- subrange value out of range.
      1003- actual parameter out of range.
      1004- set member out of range.
      1005- pointer value invalid.
      1006- stack/heap collision (i.e. program needs mor stak space).
      1007- illegal input/reset operation.
      1008- illegal output/rewrite operation.
      1009- synchronous i/o error.
      1010- program exceeded the specified running time.
      1011- invalid file definition.
      1012- not enough space available.
      1013- undefined or obsolete submonitor call (should not occur).
      1014- LINELIMIT exceeded for output file.
      1020- illegal input past end of file.
      1021- bad BOOLEAN on input.
      1022- bad INTEGER on input.
      1023- bad REAL on input.
0     200X- program interruption code 'X',
            --> enable debug option 'D+' and rerun the program.
0     3001- external error (e.g. bad parameter to math routines etc.)
0     X1XX- unable to call on 'snapshot' after a run error
            (this happens if  there is not enough space  or if snapshot
            was  not included  in  the load  module  or  if the  nosnap
            parameter was specified in jcl)  other digits of the return
            code to be interpreted as above
++FILE PASCALN.OLDCOMP.SOURCE                       MEMB PAS1979  EXT PAS HEX -
(*$D-,N+,L+*)

PROGRAM PASCALCOMPILER(INPUT, OUTPUT, PRR, QRR);

 (******************************************************************
  *                                                                *
  *                                                                *
  *    STEP-WISE DEVELOPMENT OF A PASCAL COMPILER                  *
  *    ******************************************                  *
  *                                                                *
  *                                                                *
  *    STEP 5:   SYNTAX ANALYSIS INCLUDING ERROR                   *
  *              HANDLING; CHECKS BASED ON DECLARA-                *
  *    10/7/73   TIONS; ADDRESS AND CODE GENERATION                *
  *              FOR A HYPOTHETICAL STACK COMPUTER                 *
  *                                                                *
  *                                                                *
  *    AUTHOR:   URS AMMANN                                        *
  *              FACHGRUPPE COMPUTERWISSENSCHAFTEN                 *
  *              EIDG. TECHNISCHE HOCHSCHULE                       *
  *              CH-8006 ZUERICH                                   *
  *                                                                *
  *                                                                *
  *    MODIFICATION OF STEP 5 OF PASCAL COMPILER                   *
  *    *****************************************                   *
  *                                                                *
  *    THE COMPILER IS NOW WRITTEN IN A SUBSET OF                  *
  *    STANDARD PASCAL  -  AS DEFINED IN THE NEW                   *
  *    MANUAL BY K. JENSEN AND N. WIRTH  - AND IT                  *
  *    PROCESSES EXACTLY THIS SUBSET.                              *
  *                                                                *
  *    AUTHOR OF CHANGES:   KESAV NORI                             *
  *                         COMPUTER GROUP                         *
  *                         T.I.F.R.                               *
  *                         HOMI BHABHA ROAD                       *
  *                         BOMBAY - 400005                        *
  *                         INDIA                                  *
  *                                                                *
  *    THESE CHANGES WERE COMPLETED AT ETH, ZURICH                 *
  *    ON 20/5/74.                                                 *
  *                                                                *
  *                                                                *
  *    +++++++++++++++++++++++++++++++++++++++++++                 *
  *                                                                *
  *                                                                *
  *                                                                *
  *    THE COMPILER IS NOW CHANGED TO:                             *
  *    *******************************                             *
  *                                                                *
  *                                                                *
  *      -PRODUCE  THE  INTERMEDIATE  CODE  IN  AN   ASSEMBLER     *
  *      READABLE  FORM  WITH  NO EXTRA SPACES BETWEEN VARIOUS     *
  *      FIELDS, 15-NOV-75                                         *
  *                                                                *
  *      -PRESERVE PROCEDURE NAMES AND THEIR STATIC LEVELS  AT     *
  *      THE  OBJECT  LEVEL,  THUS ALLOWING A SET OF 'DISPLAY'     *
  *      REGISTERS  TO  BE  USED   IN   ACCESSING   NON_LOCAL,     *
  *      NON_GLOBAL  VARIABLES  (INSTEAD  OF  GOING  THROUGH A     *
  *      CHAIN OF POINTERS), 10-DEC-75.                            *
  *                                                                *
  *      -INCLUDE  THE   TYPE   OF   THE   OPERANDS   IN   THE     *
  *      P_INSTRUCTIONS AS FOLLOWS:                                *
  *                                                                *
  *           A : ADDRESS (POINTER) OPERAND                        *
  *           B : BOOLEAN              "                           *
  *           C : CHARACTER            "                           *
  *           I : INTEGER              "                           *
  *           R : REAL                 "                           *
  *           S : SET                  "                           *
  *                                                                *
  *      THE  P_INSTRUCTION  NOW  LOOKS  LIKE:   (LAB)  OPCODE     *
  *      (TYPE),(OPERANDS)   A   NEW    PROCEDURE    'EXIT(RC:     *
  *      INTEGER)'  IS ADDED TO THE SET OF STANDARD PROCEDURES     *
  *      TO FACILITATE TERMINATING A PROGRAM AT ANY POINT  AND     *
  *      RETURNING  A  'RETURN  CODE' TO THE OPERATING SYSTEM,     *
  *      26-JAN-76.                                                *
  *                                                                *
  *      -TREAT THE INPUT AS A TEXT FILE WITH LINES  (RECORDS)     *
  *      OF LINELGTH CHAR.  EACH, THIS ALLOWS A MORE EFFICIENT     *
  *      STRING ORIENTED INPUT, 20-MAR-76.                         *
  *                                                                *
  *      -'READ' OF 'STRING' VARIABLES (I.E.  ARRAY  OF  CHAR)     *
  *      IS  NOW  IMPLEMENTED  AND  IT  IS  TO  COMPLEMENT THE     *
  *      SIMILAR  'WRITE'   FUNCTION.    ALSO   THE   STANDARD     *
  *      PROCEDURE:   TRAP(I:   INTEGER; VAR V:  [ANY TYPE] );     *
  *      IS  ADDED  TO  THE  SET  OF  STANDARD  PROCEDURES  TO     *
  *      FACILITATE  COMMUNICATION  WITH  THE  OUTSIDE  WORLD,     *
  *      10-SEP-76.                                                *
  *                                                                *
  *      -RELEVENT INFORMATION  ON/ABOUT  PROCEDURES  ARE  NOW     *
  *      SENT  TO  'QRD' FILE.  THIS INCLUDES SUCH INFORMATION     *
  *      AS THE SIZE OF THE PROCE- DURE AS WELL  AS  ITS  DATA     *
  *      AREA,  LIST  OF  THE  PROCEDURES  CALLED AND THE # OF     *
  *      CALLS,  THE  LEVEL  OF  THE  HIGHEST_LEVEL  PROCEDURE     *
  *      CALLED ETC.  THIS INFORMATION IS MAINLY INTENDED  FOR     *
  *      INTER_PROCEDURAL  ANALYSIS, BUT IT IS ALSO USEFUL FOR     *
  *      MORE EFFICIENT PROCEDURE ENTRY/EXIT CODE, 22-MAR-77.      *
  *                                                                *
  *      -TO BE COMPATIBLE WITH THE PASCAL-6000 THE FILE  NAME     *
  *      AS  WELL  AS  THE  ARGUMENT  LIST  MAY BE OMITTED FOR     *
  *      CERTAIN I/O RELATED OPERATIONS,  IN  WHICH  CASE  THE     *
  *      APPROPRIATE  DEFAULT  FILE  WILL  BE  USED  FOR  THAT     *
  *      OPERATION.  FOR EXAMPLE STATEMENTS SUCH AS "WRITELN",     *
  *      "WRITELN()"  OR  "WRITELN(OUTPUT)"  WILL HAVE SIMILAR     *
  *      EFFECT.  LIKEWISE "EOF(INPUT)", "EOF()" OR "EOF" WILL     *
  *      TRANSLATE INTO IDENTICAL EXPRESSIONS, 23-MAY-78.          *
  *                                                                *
  *      -TYPES "TEXT" (FILE OF CHAR) AND "ALFA" (PACKED ARRAY     *
  *      [1..10]  OF  CHAR)  ARE  NOW  ADDED  TO  THE  SET  OF     *
  *      PREDEFINED TYPES.  THE (INTEGER) CONSTANT "MAXINT" IS     *
  *      IS ALSO DEFINED AND SET TO  2147483647  =  (2**31)-1,     *
  *      20-MAY-78.                                                *
  *                                                                *
  *      -REAL VALUES MAY BE PRINTED IN SCIENTIFIC NOTATION OR     *
  *      THE  SO  CALLED  F_FORMAT  DEPENDING  ON  THE   FIELD     *
  *      SPECIFICATION  IN  THE 'WRITE' / 'WRITELN' STATEMENT.     *
  *      A SIMPLE FIELD SPECIFIER OF  THE  FORM  "R  :   FLDW"     *
  *      RESULTS  IN E_FORMAT WHILE "R :  FLDW:DFLD" GENERATES     *
  *      AN F_FORMAT OUTPUT, 20-MAY-78.                            *
  *                                                                *
  *      -'EXTERNAL' AND 'FORTRAN' PROCEDURES / FUNCTIONS  ARE     *
  *      NOW SUPPORTED.  IN ORDER TO MAKE THE EXTERNAL (CSECT)     *
  *      AND  INTERNAL  NAMES  IDENTICAL,  THE  NEW 'X' OPTION     *
  *      SWITCH IS INTRODUCED.  IF PROCEDURE / FUNCTION  NAMES     *
  *      IN  A  PROGRAM  ARE  NOT  DISTINCT WITHIN THE FIRST 8     *
  *      CHARACTERS,  (A  PROBLEM  WHICH  WILL   CONFUSE   THE     *
  *      "LOADER")   THE  'X-'  OPTION  WILL  GENERATE  UNIQUE     *
  *      EXTERNAL NAMES FOR ALL PROCEDURES IN THE PROGRAM, AND     *
  *      THESE NAMES SHOULD  BE  USED  FOR  THE  CORRESPONDING     *
  *      EXTERNAL/FORTRAN  ROUTINES,  OTHERWISE ONE SHOULD USE     *
  *      THE 'X+' OPTION TO BE ABLE TO USE THE EXTERNAL  NAMES     *
  *      WITH NO CHANGE, 2-JUNE-78.                                *
  *                                                                *
  *      -THE NEW  OPTION  'N+'  (DEFAULTED  TO  'N-')  PERMITS    *
  *      NESTING  OF 'COMMENTS'. IF THE NESTING IS NOT PROPERLY    *
  *      TERMINATED, PARTS OF THE SOURCE PROGRAM MAY BE TREATED    *
  *      AS COMMENT, OR VICE-VERSA.   FURTHERMORE,  THE  SOURCE    *
  *      PROGRAM  LISTING  GENERATED  BY  THE  COMPILER, IS NOW    *
  *      PAGINATED  AND  THE   COMPILER   CONSTANT   'PAGESIZE'    *
  *      DETERMINES  THE  NUMBER  OF  LINES PER EACH PAGE.  THE    *
  *      GENERATION OF PAGE HEADINGS CAN BE SUPPRESSD, IF  THEY    *
  *      ARE FOUND UNDESIRABLE (E.G.  FOR INTERACTIVE DEVICES),    *
  *      BY  SETTING  THE  'PAGESIZE'  TO  A  LARGE VALUE (E.G.    *
  *      PAGESIZE = 30000;).  YOU MAY ALSO CAUSE A  PAGE  EJECT    *
  *      IN THE SOURCE LISTING BY THE 'OPTION' SWITCH 'E' WHICH    *
  *      TAKES  EFFECT  AS  SOON  AS  IT  APPEARS  IN THE INPUT    *
  *      STREAM, 12-SEPT-78.                                       *
  *                                                                *
  *      -THE STANDARD PROCEDURES 'ROUND'  AND  'PAGE' ARE NOW     *
  *      IMPLEMENTED, 12-SEPT-78.                                  *
  *                                                                *
  *      -The  source  program,  including  the  reserved  and     *
  *      predefined  words  may  now be in upper/lower case to     *
  *      improve the program's readability, 2-Oct-78.              *
  *                                                                *
  *      -Variables DATE, TIME:  ALFA;  are  now  defined  and     *
  *      contain  the  date  and  time of the execution of the     *
  *      program upon entry to the user program, 5-May-79.         *
  *                                                                *
  *      -Predefined       procedures       LINELIMIT(f:TEXT),     *
  *      SKIP(f:TEXT),  LINELIMIT(f:TEXT),  MESSAGE(s:STRING);     *
  *      functions EXPO(r:REAL), CARD(s:SET) and the  variable     *
  *      OSPARM: @   ARRAY[1..64] OF CHAR are now added to the     *
  *      set of predefined names, 11-July-79 "RNH".                *
  *                                                                *
  *      -Standard  procedures  PACK  and   UNPACK   are   now     *
  *      implemented  and they operated on 'PACKED' ad well as     *
  *      unpacked arrays, 10-Oct.-79.                              *
  *                                                                *
  *                                                                *
  *    THE ABOVE CHANGES (INCLUDING ADDITIONS AND/OR  DELETIONS)   *
  *    HAVE BEEN TAGGED BY A '#' TAG AT THE BEGINNING OR THE END   *
  *    OF THE AFFECTED LINES.                                      *
  *                                                                *
  *                                                                *
  *                                                                *
  *                                                                *
  *                         S. HAZEGHI                             *
  *                                                                *
  *                         COMPUTATION RESEARCH GROUP             *
  *                         STANFORD LINEAR ACCELERATOR CENTER     *
  *                         STANFORD, CA. 94305.                   *
  *                                                                *
  *                                                                *
  *                                                                *
  ******************************************************************)

 (******************************************************************
  *                                                                *
  *                                                                *
  *   "BM"+"CM"  --->  IBM/360/370 TRANSLATOR (ASMPCODE)           *
  *   "S1"       --->  STANFORD-1 TRANSLATOR (SOPA-3)              *
  *   "PM"+"CM"  --->  P_CODE INTERPRETER (PINTERP9)               *
  *                                                                *
  *                                                                *
  ******************************************************************)



CONST
#      VERSION     = 'Oct.-79';
#      PAGESIZE    = 55;           (*MAX # OF LINES PER PAGE OF LISTING      *)
#      MAXINT      = 2147483647;
#      MAXADDR     = 16777215;
#      SETMAX      = 63;           (*LARGEST POSSIBLE SET ELEMENT            *)
#      BUFLEN      = 122;          (*MAX LINE LENGTH + 2                     *)
"BM"   INTSIZE     = 4;
"BM"   REALSIZE    = 8;
"BM"   CHARSIZE    = 1;
"BM"   BOOLSIZE    = 1;
"BM"   SETSIZE     = 8;
"BM"   PTRSIZE     = 4;
"S1" " INTSIZE     = 4;                                                        "
"S1" " REALSIZE    = 8;                                                        "
"S1" " CHARSIZE    = 1;                                                        "
"S1" " BOOLSIZE    = 1;                                                        "
"S1" " SETSIZE     = 8;                                                        "
"S1" " PTRSIZE     = 4;                                                        "
"PM" " INTSIZE     = 1;                                                        "
"PM" " REALSIZE    = 1;                                                        "
"PM" " CHARSIZE    = 1;                                                        "
"PM" " BOOLSIZE    = 1;                                                        "
"PM" " SETSIZE     = 1;                                                        "
"PM" " PTRSIZE     = 1;                                                        "
#      REALLNGTH   = 20;           (*STRING REPRESENTATION OF REAL NUMBERS   *)
#      DIGMAX      = 19;           (*REALLNGHT-1                             *)
#      IDLNGTH     = 12;
#      ALFALNGTH   = 10;
#      STRGLNGTH   = 64;
#      DISPLIMIT   = 20;
#      MAXLEVEL    = 10;
#      ORDCHMAX    = 255;          (*SIZE OF CHAR SET OF TARGET MACHINE      *)
"NH"   OPMAX       = 66;           (* OPCODE RANGE  *)
#      MAXERRNR    = 401;          (*MAX VAL OF ERROR CODE                   *)
#      MAXERRLOG   =   8;          (* > (MAXERRNR DIV SETMAX)                *)
#      NRSW        = 37;
#      NRSW1       = 38;           (*NRSW+1                                  *)
"NH"   NSPROC      = 39;           (* # OF STANDARD PROCS                    *)
       NPDW        = 58;           (* # OF PREDEFINED WORDS                  *)
"CT"   CTRMAX      = 16384;

"BM"   (*SAVE AREAS, FUNCTION RETURN VALUE SPACE, DISPLAY AREA, ETC.         *)
"BM"   LCAFTMST    = 80;    FPSAVEAREA  = 32;     RUNCHKAREA  = 96;
"BM"   DSPLYAREA   = 72;    FNCRSLT     = 72;
"BM"   FIRSTFILBUF = 248;          (* = LCAFTMST+RUNCHKAREA+DSPLYAREA        *)
"BM"   FIRSTUSERF  = 254;          (* = FIRSTFILEBUF+6                       *)
"BM"   LASTFILBUF  = 272;          (* LAST USER DEFINED FILE BUFFER+1        *)
"BM"   TIMEDATELOC = 280;          (* LOCATION OF TIME/DATE PREDEF. VARS     *)
"BM"   OSPARMLOC   = 300;          (* LOCATION FOR 'OSPARM' PTR.             *)
"BM"   FIRSTGVAR   = 304;          (* FIRST USER DEFINED GLOBAL VARIABLE     *)

"S1" "                             (* 'S1' CONSTANT DEFINITION               *)"
"S1" " REGPRMAREA  = 40;           (* SHOULD BE A MULTIPLE OF '4' BYTES      *)"
"S1" " LCAFTMST    = 8;   FPSAVEAREA  = 0;   RUNCHKAREA = 0;    DSPLYAREA = 0; "
"S1" " FNCRSLT     = 0;   FIRSTFILBUF = 12;  LASTFILBUF = 44;                  "
"S1" " TIMEDATELOC = 12;           (* TIME/DATE LOCATION                     *)"
"S1" " FIRSTGVAR   = 12;           (* FIRST GLOBAL VARIABLE                  *)"


"PM" " (*SAVE AREAS, FUNCTION RETURN VALUE SPACE, DISPLAY AREA, ETC. FOR P.M.*)"
"PM" " LCAFTMST    = 16;    FPSAVEAREA  =  0;     RUNCHKAREA  =  0;            "
"PM" " DSPLYAREA   =  0;    FNCRSLT     =  0;                                  "
"PM" " FIRSTFILBUF =  6;           (* = LCAFTMST+RUNCHKAREA+DSPLYAREA        *)"
"PM" " FIRSTUSERF  = 12;           (* = FIRSTFILEBUF+6                       *)"
"PM" " LASTFILBUF  = 15;           (* LAST USER DEFINED FILE BUFFER+1        *)"
"PM" " OSPARMLOC   = 16;           (* LOCATION FOR 'OSPARM' PTR.             *)"
"PM" " TIMEDATELOC = 20;           (* LOCATION OF TIME/DATE VARS             *)"
"PM" " FIRSTGVAR   = 40;           (* FIRST GLOBAL VAR ADDRESS               *)"
(*----------------------------------------------------------------------------*)


TYPE                                                        (*DESCRIBING:     *)
                                                            (************     *)


                                                            (*BASIC SYMBOLS   *)
                                                            (**************   *)

     SYMBOL       = (IDENT,INTCONST,REALCONST,STRINGCONST,NOTSY,MULOP,ADDOP,
                     RELOP,LPARENT,RPARENT,LBRACK,RBRACK,COMMA,SEMICOLON,PERIOD,
                     ARROW,COLON,DOTDOT,BECOMES,LABELSY,CONSTSY,TYPESY,VARSY,
                     FUNCSY,PROGSY,PROCSY,SETSY,PACKEDSY,ARRAYSY,RECORDSY,
                     FILESY,FORWARDSY,BEGINSY,IFSY,CASESY,REPEATSY,WHILESY,
                     FORSY,WITHSY,GOTOSY,ENDSY,ELSESY,UNTILSY,OFSY,DOSY,TOSY,
#                    DOWNTOSY,THENSY,FRTRNSY,EXTRNSY,OTHERSY);

     OPERATOR     = (MUL,RDIV,ANDOP,IDIV,IMOD,PLUS,MINUS,OROP,LTOP,LEOP,GEOP,
                     GTOP,NEOP,EQOP,INOP,NOOP,
#                    ATOZCH, NUMCH, QUOTCH, DQUOTCH, COLONCH, DOTCH, LPARCH,
#                    LBRACE, UNDSCH, DOLLARCH, SKIPCH, SPECH, ILLEGCH ) ;

     SETOFSYS     = SET OF SYMBOL;
#    SETRANGE     = SET OF 0..SETMAX;


                                                            (*CONSTANTS       *)
                                                            (**********       *)

     CSTCLASS     = (REEL,PSET,STRG);
     CSP          = @ CONSTANT;
     CONSTANT     = RECORD CASE "CCLASS:" CSTCLASS OF
                           REEL: (RVAL: PACKED ARRAY [1..REALLNGTH] OF CHAR);
                           PSET: (PVAL: SETRANGE  );
                           STRG: (SLNGTH: 0..STRGLNGTH;
                                  SVAL: PACKED ARRAY [1..STRGLNGTH] OF CHAR)
                         END;

     VALU         = RECORD CASE "INTVAL:" BOOLEAN OF  (*INTVAL NEVER USED     *)
                      TRUE:  (IVAL: INTEGER);
                      FALSE: (VALP: CSP)
                    END;

                                                           (*DATA STRUCTURES  *)
                                                           (****************  *)
     LEVRANGE     = 0..MAXLEVEL;       ADDRRANGE   = 0..MAXADDR;
     ALNRNG       = 1..8 ;             LABELRNG    = 0..1000 ;
     STRUCTFORM   = (SCALAR,SUBRANGE,POINTER,POWER,ARRAYS,RECORDS,FILES,
                     TAGFLD,VARIANT);
     DECLKIND     = (STANDARD,DECLARED);
     STP          = @ STRUCTURE;
     CTP          = @ IDENTIFIER;

     STRUCTURE    = PACKED RECORD
                    (* MARKED: BOOLEAN;  TO BE USED WITH 'T+', FOR TEST PHASE *)
                    ALN :   ALNRNG ;      (*ALIGNMENT FACTOR                  *)
                    SIZE: ADDRRANGE;
                    CASE FORM: STRUCTFORM OF
                      SCALAR:   (CASE SCALKIND: DECLKIND OF
                                   DECLARED: (FCONST: CTP));
                      SUBRANGE: (RANGETYPE: STP; MIN,MAX: VALU);
                      POINTER:  (ELTYPE: STP);
                      POWER:    (ELSET: STP);
                      ARRAYS:   (AELTYPE,INXTYPE: STP);
                      RECORDS:  (FSTFLD: CTP; RECVAR: STP);
                      FILES:    (FILTYPE: STP);
                      TAGFLD:   (TAGFIELDP: CTP; FSTVAR: STP);
                      VARIANT:  (NXTVAR,SUBVAR: STP; VARVAL: VALU)
                    END;

                                                            (*NAMES           *)
                                                            (******           *)

     IDCLASS      = (TYPES,KONST,VARS,FIELD,PROC,FUNC);
     SETOFIDS     = SET OF IDCLASS;
     IDKIND       = (ACTUAL,FORMAL);
     ALPHA        = PACKED ARRAY [1..IDLNGTH] OF CHAR;

     IDENTIFIER   = PACKED RECORD
                    NAME: ALPHA; LLINK, RLINK: CTP;
                    IDTYPE: STP; NEXT: CTP;
                    CASE KLASS: IDCLASS OF
                      KONST: (VALUES: VALU);
                      VARS:  (VKIND: IDKIND; "EBCD: BOOLEAN;"
                              VLEV: LEVRANGE; VADDR: ADDRRANGE);
                      FIELD: (FLDADDR: ADDRRANGE);
                      PROC,
                      FUNC:  (CASE PFDECKIND: DECLKIND OF
                               STANDARD: (KEY: 0..NSPROC);
                               DECLARED: (PFLEV: LEVRANGE; PFNAME: LABELRNG;
"S1" "                                     FPRMSZE,RPRMSZE,SPRMSZE: ADDRRANGE; "
                                           CASE PFKIND: IDKIND OF
                                            ACTUAL: (FWDECL, EXTRN,FRTRN,SAVEFP:
                                                     BOOLEAN)))
                    END;


     DISPRANGE    = 0..DISPLIMIT;
     WHERE        = (BLCK,CREC,VREC,REC);

                                                            (*EXPRESSIONS     *)
                                                            (************     *)
     ATTRKIND     = (CST,VARBL,EXPR);
     VACCESS      = (DRCT,INDRCT,INXD);

#    ATTR         = RECORD TYPTR, BTYPE: STP;
                     CASE KIND: ATTRKIND OF
                       CST:   (CVAL: VALU);
                       VARBL: (CASE ACCESS: VACCESS OF
                                 DRCT: (VLEVEL: LEVRANGE; DPLMT: ADDRRANGE);
                                 INDRCT: (IDPLMT: ADDRRANGE))
                     END;

     TESTP        = @ TESTPOINTER;
     TESTPOINTER  = PACKED RECORD
                      ELT1,ELT2 : STP;
                      LASTTESTP : TESTP
                      END;

                                                                 (*LABELS     *)
                                                                 (*******     *)
     LBP          = @ LABL;
     LABL         = RECORD NEXTLAB: LBP; DEFINED: BOOLEAN;
                      LABVAL, LABNAME: INTEGER
                    END;

     FRECPTR      = @FILEREC;
     FILEREC      = RECORD FILIDPTR: CTP; NEXTFILE: FRECPTR; "GEBCDF: BOOL" END;

#    ERRCODE      = 0..MAXERRNR;

"CT"   CTRRANGE   = 0..CTRMAX;
"CT"   CTRTYPE    = (CTRPROC, CTRLBL, CTRGOTO, CTRIF, CTRWHILE, CTRREPEAT,
"CT"                 CTRFOR, CTRCASE);

(*----------------------------------------------------------------------------*)


VAR


                                    (*RETURNED BY SOURCE PROGRAM SCANNER
                                     INSYMBOL:
                                     **********)

    SY: SYMBOL;                     (*LAST SYMBOL                             *)
    OP: OPERATOR;                   (*CLASSIFICATION OF LAST SYMBOL           *)
    VAL: VALU;                      (*VALUE OF LAST CONSTANT                  *)
    LNGTH: INTEGER;                 (*LENGTH OF LAST STRING CONSTANT          *)
    PROGNAME, BLANKID,
    ID:  ALPHA ;                    (*LAST IDENTIFIER (POSSIBLY TRUNCATED)    *)
    CH: CHAR;                       (*LAST CHARACTER READ                     *)
    EOL: BOOLEAN;                   (*END OF LINE FLAG                        *)


                                    (*COUNTERS:                               *)
                                    (**********                               *)

    CHCNT: 0..BUFLEN;               (*CHARACTER COUNTER                       *)
    LC, IC, OLDIC, STIC,            (*DATA LOCATION AND INSTRUCTION COUNTER   *)
    MXDATASZE :         ADDRRANGE;
#   LINECNT, OLDLN, NXTLN, PAGECNT : INTEGER;


                                    (*SWITCHES:                               *)
                                    (**********                               *)

    HP,                             (*HEADER PART                             *)
    DP,                             (*DECLARATION PART                        *)
    PRTERR,                         (*TO ALLOW FORWARD REFERENCES IN PTR TYPE *)
                                    (*DECLARATION BY SUPPRESSING ERROR MSG    *)
#   DOTFLG,                         (*ONE DOT ALREADY SEEN                    *)
#   ASSIGN,PACKDATA,                (*ASSIGNMENT GOING ON, WORD ALIGN FLAG    *)
#   LIST,PRCODE,"PRTABLES,PRTIC,"
#  "MARGIN," DEBUG, MWARN,
#   FLIPDEBUG,
#                                   (*OUTPUT OPTIONS FOR                      *)
#                                   (*  --> SOURCE PROGRAM LISTING            *)
#                                   (*  --> PRINTING SYMBOLIC CODE            *)
#                                   (*  --> DISPLAY IDENT AND STRUCT TABLES   *)
#                                   (*  --> SET INPUT MARGIN AT 72 COLS.      *)
#                                   (*  --> PRINT INST_CNTR, PROCEDURE OPTION *)
#
#   NESTCOMM,
#   ASSEMBLE,ASMVERB,"EBCDFLG,"XLINK, NAMFLAG,
#   SAVEREGS,SAVEFPRS,GET_STAT:     BOOLEAN;
#                                   (*POST PROCESSOR OPTIONS                  *)
#
                                    (*POINTERS:                               *)
                                    (**********                               *)
    INTPTR,REALPTR,CHARPTR,BOOLPTR,
    NILPTR,TEXTPTR,ALFAPTR: STP;    (*POINTERS TO ENTRIES OF STANDARD IDS     *)
    UTYPPTR,UCSTPTR,UVARPTR,
    UFLDPTR,UPRCPTR,UFCTPTR,        (*POINTERS TO ENTRIES FOR UNDECLARED IDS  *)
    FWPTR: CTP;                     (*HEAD OF CHAIN OF FORW DECL TYPE IDS     *)
#   FILEHEAD: FRECPTR ;             (*HEAD OF CHAIN OF EXTERNAL FILES         *)
    GLOBTESTP: TESTP;               (*LAST TESTPOINTER                        *)


                                    (*BOOKKEEPING OF DECLARATION LEVELS:      *)
                                    (***********************************      *)

    LEVEL: LEVRANGE;                (*CURRENT STATIC LEVEL                    *)
    DISX,                           (*LEVEL OF LAST ID SEARCHED BY SEARCHID   *)
    TOP: DISPRANGE;                 (*TOP OF DISPLAY                          *)

    DISPLAY:                        (*WHERE:   MEANS:                         *)
      ARRAY [DISPRANGE] OF
        PACKED RECORD               (*=BLCK:   ID IS VARIABLE ID              *)
          FNAME: CTP; FLABEL: LBP;  (*=CREC:   ID IS FIELD ID IN RECORD WITH  *)
          CASE OCCUR: WHERE OF      (*         CONSTANT ADDRESS               *)
            CREC: (CLEV: LEVRANGE;  (*=VREC:   ID IS FIELD ID IN RECORD WITH  *)
                  CDSPL: ADDRRANGE);(*         VARIABLE ADDRESS               *)
            VREC: (VDSPL: ADDRRANGE)
          END;                      (* --> PROCEDURE WITHSTATEMENT            *)


                                    (*RUN-TIME PROFILER COUNTERS              *)
                                    (***************************              *)

"CT"  CTRCNT     : CTRRANGE;
"CT"  CTRCNTLBL  : LABELRNG;
"CT"  CTROPTION  : BOOLEAN;
"CT"  "FIRSTCTR  : BOOLEAN;"



                                    (*EXPRESSION COMPILATION:                 *)
                                    (************************                 *)

    GATTR        : ATTR;            (*DESCRIBES THE EXPR CURRENTLY COMPILED   *)

    MXINT10      : INTEGER;

                                    (*STRUCTURED CONSTANTS:                   *)
                                    (**********************                   *)

    CONSTBEGSYS,SIMPTYPEBEGSYS,TYPEBEGSYS,BLOCKBEGSYS,SELECTSYS,FACBEGSYS,
    STATBEGSYS,TYPEDELS: SETOFSYS;

# " ATOZ, NUMERIC,
#   ALPHANUMERIC : SET OF CHAR;"    (*VALID ALPHA-NUMERICS                    *)


                                    (*BUFFERS, READ ONLY TABLES ETC.          *)
                                    (******************************           *)

    LSTOP        : CHAR;                      (*MARKS THE BEGINNING OF LINEBUF*)
    LINEBUF      : ARRAY [1..BUFLEN] OF CHAR; (*CURRENT LINE BUFFER           *)
"NH"LMARGIN, RMARGIN, LINELEN, BUFEND,
"NH"LASTCOL      : 0..BUFLEN;                 (*LEFT, RIGHT MARGINS ant PTRS  *)
#  "SEQFLD       : ARRAY [1..8] OF CHAR; (*SEQ. NUM. FIELD USED WITH $M+ ONLY*)"

#   INTLABEL,PROCLAB: LABELRNG ;

#   NXTFILBUF    : ADDRRANGE ;
#   CALL_LVL     : ARRAY[BOOLEAN] OF INTEGER ;

    RW           : ARRAY [1..NRSW(*NR. OF RES. WORDS*)] OF ALPHA;
    FRW          : ARRAY [1..14] OF 1..NRSW1;
    RSY          : ARRAY [1..NRSW(*NR. OF RES. WORDS*)] OF SYMBOL;
    ROP          : ARRAY [1..NRSW(*NR. OF RES. WORDS*)] OF OPERATOR;
    NA           : ARRAY [1..NPDW] OF ALPHA;
    MN           : ARRAY [0..OPMAX] OF PACKED ARRAY [1..4] OF CHAR;
"NH"SNA          : ARRAY [0..NSPROC] OF PACKED ARRAY[1..3] OF CHAR;
    SOP          : ARRAY [CHAR] OF OPERATOR;
#   UPSHIFT      : ARRAY [char (*SHOULD BE CHAR*) ] OF CHAR ;        (*opp*)
    SSY          : ARRAY [char (*SHOULD BE CHAR*)] OF SYMBOL;        (*opp*)
#   ERRLOG       : ARRAY [0..MAXERRLOG(* = 400 DIV SETMAX+1*)] OF SETRANGE;
""" EBCDIC       : ARRAY [CHAR] OF 0..255 ;" (*CHAR CODE CONVERSION           *)
# (*INPUT   : TEXT ;         FILE CONTAINING SOURCE PROGRAM                   *)
# (*OUTPUT  : TEXT ;         FILE USED FOR SOURCE LISTING                     *)
# (*PRR     : TEXT ;         FILE TO SEND P_CODE TO                           *)
# (*PRD     : TEXT ;         FILE TO READ TEXT OF ERROR MESSAGES FROM         *)
# (*QRR     : TEXT ;         FILE FOR :   PROCEDURE TABLES                    *)
# (*QRR     : TEXT ;                      SYMBOL TABLE                        *)
# (*QRR     : TEXT ;         AND          COUNTER TABLE.                      *)


                                    (*ERROR MESSAGES:                         *)
                                    (****************                         *)

#   ERRORCNT, CTIME: INTEGER ;      (*ERROR_COUNT, COMPILATION_TIME           *)
    ERRINX       : 0..10;           (*NR OF ERRORS IN CURRENT SOURCE LINE     *)
    ERRLIST      : ARRAY[1..10] OF
                     PACKED RECORD POS: 1..81;
                       NMR: 1..400
                     END;

"S1" "  FPRM1, SPRM1, RPRM1 : ADDRRANGE ;   REGS_FULL : BOOLEAN;               "

(*----------------------------------------------------------------------------*)



  PROCEDURE ERROR(FERRNR: ERRCODE);
  VAR  I : 0..10 (*MAXERRNR DIV SETMAX*) ;
  BEGIN
    IF ERRINX >= 9 THEN
      BEGIN ERRLIST[10].NMR := 255; ERRINX := 10 END
    ELSE
      BEGIN ERRINX := ERRINX + 1;
        ERRLIST[ERRINX].NMR := FERRNR
      END;
    ERRLIST[ERRINX].POS := CHCNT ;
#   I := FERRNR DIV (SETMAX+1) ;
#   ERRLOG[I] := ERRLOG[I]+ [FERRNR MOD (SETMAX+1)] ;
#   ERRORCNT := ERRORCNT+1 ;
  END (*ERROR*) ;


PROCEDURE PRINTERROR ;
    VAR LASTPOS,FREEPOS,CURRPOS,CURRNMR,F,K: INTEGER;
# BEGIN
#   IF NOT LIST THEN
#     BEGIN   NXTLN := NXTLN+1 ;
#    "IF MARGIN THEN  WRITE(OUTPUT, SEQFLD:9)  ELSE  WRITE(OUTPUT,LINECNT:9);"
#     WRITELN(OUTPUT, LINECNT:9, ') ':13, LINEBUF:LINELEN);
#     END ;
#   (*OUTPUT ERROR CODES*)
#   NXTLN := NXTLN+1 ;
#   WRITE(OUTPUT,'****':9, ' ':13) ;
#   LASTPOS := 0;  FREEPOS := 1;
#   FOR K := 1 TO ERRINX DO
#     BEGIN
#       WITH ERRLIST[K] DO
#         BEGIN CURRPOS := POS; CURRNMR := NMR END;
#       IF CURRPOS = LASTPOS THEN WRITE(OUTPUT,',')
#       ELSE
#         BEGIN
#           WHILE FREEPOS < CURRPOS DO
#             BEGIN WRITE(OUTPUT,' '); FREEPOS := FREEPOS + 1 END;
#           WRITE(OUTPUT,'@');
#           LASTPOS := CURRPOS
#         END;
#       IF CURRNMR < 10 THEN F := 1
#       ELSE IF CURRNMR < 100 THEN F := 2
#         ELSE F := 3;
#       WRITE(OUTPUT,CURRNMR:F);
#       FREEPOS := FREEPOS + F + 1
#     END;
#   WRITELN(OUTPUT);  ERRINX := 0 ;  PRCODE := FALSE ;
# END (*PRINTERROR*) ;


PROCEDURE HEADLINE ;
# BEGIN
#   PAGECNT := PAGECNT+1 ;  NXTLN := 0 ;
#   WRITELN(OUTPUT, '1  LINE #  P/D LC  LVL',
#                   '< Stanford PASCAL Compiler, Version of ':44,
#                   VERSION, ' >', TIME:14, DATE, 'Page':8, PAGECNT:4) ;
#   WRITELN(OUTPUT, '------  ------  ---':22,
#                   '---- ---':89) ;
#   WRITELN(OUTPUT) ;
# END (*HEADLINE*) ;


PROCEDURE ENDOFLINE ;
# LABEL 10;
# VAR I: 1..9 ;
  BEGIN   IF ERRINX > 0 THEN PRINTERROR ;
#   READLN(INPUT, LINEBUF);
#  "IF MARGIN THEN
#     FOR I := 1 TO 8 DO
#       BEGIN  SEQFLD[I] := LINEBUF[72+I] ; LINEBUF[72+I] := ' '  END ;"
    LINELEN := BUFEND;   (*THIS WILL SPEED THINGS UP IF NO MARGIN IS SET/RESET*)

    (*RUN TIME CHECK I.E. '$D+' SHOULD NOT BE ENABLED FOR THIS LOOP!*)

    REPEAT  LINELEN := LINELEN - 1; "IF LINELEN = 0 THEN GOTO 10;"
    UNTIL   LINEBUF(/LINELEN/) <> ' ';
10:"LINELEN := LINELEN + 1;" (*SO THAT LAST INPUT CHAR = BLANK, SERVES AS EOL*)

    IF LINELEN > RMARGIN THEN  BEGIN  MWARN := TRUE;  LASTCOL := RMARGIN END
    ELSE LASTCOL := LINELEN;
#   LINECNT := LINECNT+1 ;
#   IF LIST THEN
#     BEGIN
#       IF NXTLN >= PAGESIZE THEN  HEADLINE ;
#       NXTLN := NXTLN+1 ;
#      "IF MARGIN THEN  WRITE(OUTPUT, SEQFLD:9)
#       ELSE" WRITE(OUTPUT,LINECNT: 9) ;
#
#       IF IC > 0 THEN
#         BEGIN  WRITE(OUTPUT, IC:8, LEVEL:3);
#         "IF HP THEN BEGIN  IC := 0;  HP := FALSE END;"
#         END
#       ELSE
#         BEGIN
#         IF DP THEN  WRITE(OUTPUT, LC:8, LEVEL:3)
#         ELSE  (*WRITE(OUTPUT, 0:8, 0:3)*)  WRITE(OUTPUT, ' ':11)
#         END;
#
#       WRITELN(OUTPUT, ') ', LINEBUF:LINELEN) ;
#     END;
#   IF HP THEN BEGIN  IC := 0;  HP := FALSE END;
#   LINEBUF[LASTCOL+1] := '#';    (*TO STOP 'SKIPBLNK' + PROVIDE VALID EOL CH.*)
#   CHCNT := LMARGIN;
  END  (*ENDOFLINE*) ;


# PROCEDURE LISTMSGS ;
#
#   VAR I, J : ERRCODE ;
#       MSG  : ARRAY[1..64] OF CHAR ;
#
#   BEGIN
#      WRITELN(OUTPUT) ;   WRITELN(OUTPUT) ;
#      WRITELN(OUTPUT, '****':9, '   ERROR CODES FOR THIS PROGRAM :') ;
#      WRITELN(OUTPUT) ;   RESET(PRD) ;   J := 0 ;
#      FOR I := 1 TO MAXERRNR DO
#        IF (I MOD (SETMAX+1)) IN ERRLOG[I DIV (SETMAX+1)] THEN
#           BEGIN
#           WHILE (NOT EOF(PRD)) AND (I > J) DO  READLN(PRD, J, MSG) ;
#           IF J = I THEN  WRITELN('****':9, J:6, MSG) ;
#           END ;
#   END (*LISTMSGS*);


# PROCEDURE GOODBYE;
#
#   BEGIN
#   CTIME := (CLOCK(1)-CTIME)" DIV 10" ;
#   WRITELN(OUTPUT);
#   IF MWARN THEN
#      WRITELN(OUTPUT, '0', '    ****      CONTENTS OF SOURCE LINES OUTSIDE  ',
#                      LMARGIN:1, '..', RMARGIN:1, '  MARGINS IGNORED.');
#
#   WRITELN(OUTPUT);
#   IF ERRORCNT = 0 THEN  WRITE(OUTPUT, '****      NO':17)
#   ELSE  WRITE(OUTPUT, '****':9, ERRORCNT:8) ;
#   WRITELN(OUTPUT, '  SYNTAX ERROR(S) DETECTED.');
#   WRITELN(OUTPUT);
#   WRITELN(OUTPUT, '****':9, LINECNT:8, '  LINE(S) READ, ', PROCLAB:4,
#                   ' PROCEDURE(S) COMPILED,');
#   WRITELN(OUTPUT);
#   WRITELN(OUTPUT, '****':9, OLDIC:8,'  P_INSTRUCTIONS GENERATED,',
#                   "CTIME DIV 100 :4, '.', CTIME MOD 100:2,"
#                   ctime*0.001:7:2, ' SECONDS IN COMPILATION.') ;
#
#   IF ERRORCNT > 0 THEN  LISTMSGS ;
#   EXIT(ERRORCNT) ;
#   END (*GOODBYE*) ;


  PROCEDURE INSYMBOL;
    (*READ NEXT BASIC SYMBOL OF SOURCE PROGRAM AND RETURN ITS
    DESCRIPTION IN THE GLOBAL VARIABLES SY, OP, ID, VAL AND LNGTH*)
    LABEL 1,2,3;
    VAR I,K: INTEGER;
        DIGIT: PACKED ARRAY [1..REALLNGTH] OF CHAR;
        STRING: PACKED ARRAY [1..STRGLNGTH] OF CHAR;
        LVP: CSP;  TEST: BOOLEAN;


#   PROCEDURE EOFEXIT;
#
#     BEGIN
#     ERROR(390);
#     PRINTERROR;
#     GOODBYE;
#     END (*EOFEXIT*) ;


#   PROCEDURE SKIPBLNK;
#   (* SKIP BLANKS, ENDOFLINE, AND (OPTIONAL) MARGIN, SKIPS AT LEAST ONE CHAR *)
#
#     BEGIN
#       REPEAT
#
#       IF EOL THEN
#         BEGIN
#         IF EOF(INPUT)  THEN  EOFEXIT ;
#         ENDOFLINE ;
#         END ;
#
#     "IF CHCNT < LASTCOL THEN"
#         REPEAT CHCNT := CHCNT+1;  UNTIL LINEBUF[CHCNT] <> ' ';
#      (* NOTE THAT LINEBUF[LINELEN+1] <> ' ' *)
#      EOL := CHCNT > LASTCOL;
#      UNTIL NOT EOL ;
#    CH := LINEBUF[CHCNT] ;
#    END (*SKIPBLNK*) ;


    PROCEDURE NEXTCH;
#     BEGIN
#     IF EOL THEN
#        BEGIN
#        IF EOF(INPUT)  THEN  EOFEXIT ;
#        ENDOFLINE ;
#        END ;
#     CHCNT := CHCNT+1;  EOL := (CHCNT > LASTCOL);
#     CH := LINEBUF[CHCNT] ;
#     END;


#     PROCEDURE OPTIONS(CCH: CHAR (*COMMENT TERMINATOR CH*) );
#
#     FUNCTION DECNUM : INTEGER;
#       VAR NUM, D: INTEGER;
#       BEGIN
#          NUM := 0;  NEXTCH;
#          WHILE CH >= '0' DO
#             BEGIN  NUM := NUM*10+ORD(CH)-ORD('0');  NEXTCH  END;
#          DECNUM := NUM
#       END;
#
#     BEGIN
#       REPEAT  NEXTCH;  CH := UPSHIFT[CH] ;                             (*UPL*)
#         IF CH <> CCH THEN
#           BEGIN
#             IF CH = 'T' THEN
#               BEGIN NEXTCH; "PRTABLES := CH = '+'"  END
#             ELSE
#               IF CH = 'L' THEN
#                 BEGIN NEXTCH; LIST := CH = '+';
#                "  IF NOT LIST THEN WRITELN(OUTPUT) "
#                 END
#               ELSE
#                 IF CH = 'C' THEN
#                   BEGIN NEXTCH; PRCODE := CH <> '-' END
#                 ELSE
#                   IF CH = 'E' THEN
#                     BEGIN  IF LIST THEN HEADLINE ;  "NEXTCH ;
#                     EBCDFLG := CH = '+' ;"
#                     END
#                   ELSE
#                     IF CH = 'A' THEN
#                       BEGIN  NEXTCH ;  ASSEMBLE := CH ='+'  END
#                     ELSE
#                       IF CH='M' THEN
                          BEGIN  NEXTCH;
                             IF CH = '+' THEN BEGIN
                                LMARGIN := 0;  RMARGIN := 72;  END
                             ELSE IF CH = '-' THEN BEGIN
                                LMARGIN := 0;  BUFEND := BUFLEN;
                                RMARGIN := BUFLEN;
                                END
                             ELSE IF CH = '(' THEN BEGIN
                                LMARGIN := DECNUM - 1;
                                IF LMARGIN < 0 THEN LMARGIN := 0;
                                IF CH = ',' THEN  RMARGIN := DECNUM
                                            ELSE  RMARGIN := BUFLEN;
                                IF (RMARGIN <= LMARGIN) OR
                                   (RMARGIN >= BUFLEN) THEN
                                      RMARGIN := BUFLEN-1;
                                BUFEND := BUFLEN;
                                END
                          END
#                       ELSE
#                         IF CH = 'S' THEN
#                           BEGIN  NEXTCH ;  SAVEREGS := CH <> '-'  END
#                         ELSE
#                           IF CH = 'F' THEN
#                             BEGIN NEXTCH ;  SAVEFPRS := CH <> '-' ;
#                             END
#                           ELSE
#                             IF CH = 'D' THEN
#                               BEGIN  NEXTCH ;  DEBUG := CH <> '-' END
#                             ELSE
#                               IF CH = 'P' THEN
#                                 BEGIN  NEXTCH ;  PACKDATA := CH = '+' ;
#                                   IF PACKDATA THEN  MXDATASZE := INTSIZE
#                                   ELSE  MXDATASZE := REALSIZE ;
#                                 END
#                               ELSE
#                               " IF CH = 'B' THEN
#                                   BEGIN  NEXTCH ;  BYTEON := CH = '+' ;
#                                   DEBUG := BYTEON ;
#                                   END
#                                 ELSE "
#                                   IF CH = 'V' THEN
#                                     BEGIN  NEXTCH ;  ASMVERB := CH ='+' END
#                                   ELSE
#                                     IF CH = 'U' THEN
#                                        BEGIN  NEXTCH; GET_STAT := CH = '+' END
#                                     ELSE
#                                       IF CH = 'X' THEN
#                                          BEGIN  NEXTCH;  XLINK := CH = '+';
#                                          (* XLINK --> ALLOW '$' AS FIRST CH.*)
#                                          IF XLINK THEN  SOP['$'] := ATOZCH;
#                                          END
#                                       ELSE
#                                         IF CH = 'K' THEN
#                                           BEGIN   NEXTCH;
"CT"                                         CTROPTION := CH = '+' ;
"CT"                                        "IF CTROPTION THEN  REWRITE(QRR) ;"
#                                           END
#                                         ELSE IF CH = 'N' THEN
#                                           BEGIN
#                                           NEXTCH ;   NESTCOMM := CH = '+' ;
#                                           END ;
#             IF CH <> CCH THEN NEXTCH;
#           END
#       UNTIL CH <> ','
#     END (*OPTIONS*) ;


#   PROCEDURE COMMENT(CCH: CHAR (*COMMENT DELIMITER CHARACTER*) );
#
#     BEGIN (*COMMENT*)
#
#       REPEAT
#
#       IF CH <> CCH THEN
#         REPEAT
#         IF NESTCOMM THEN
#           BEGIN
#           IF CH = '¯' THEN
#              IF CCH = '' THEN  BEGIN  EOL := FALSE; COMMENT('')  END;
#           IF CH = '(' THEN
#              IF LINEBUF[CHCNT+1] = '*' THEN
#                 IF CCH = '*' THEN  (*TO PREVENT '(' FROM GOING THROUGH*)
#                    BEGIN  EOL := FALSE;  NEXTCH;  NEXTCH;  COMMENT('*')  END;
#           END;
#
#         IF CHCNT > LASTCOL THEN
#           BEGIN  IF EOF(INPUT) THEN  EOFEXIT ;
#           ENDOFLINE ;
#           END ;
#
#         CHCNT := CHCNT+1 ;
#         CH := LINEBUF[CHCNT] ;
#         UNTIL CH = CCH ;
#
#       IF CCH = '*' THEN
#         BEGIN
#         CHCNT := CHCNT+1 ;
#         CH := LINEBUF[CHCNT] ;
#         END
#       ELSE CH := ')' (*CHEATING A BIT*);
#
#       UNTIL CH = ')' ;
#
#     EOL := FALSE;    (*PREPARE FOR NEXT CALL TO 'NEXTCH'*)
#     END (*COMMENT*) ;
#
#

  BEGIN (*INSYMBOL*)
  1:
#   IF CH = ' ' THEN SKIPBLNK ;
#   CASE SOP[CH] OF
  "   'A','B','C','D','E','F','G','H','I',
      'J','K','L','M','N','O','P','Q','R',
      'S','T','U','V','W','X','Y','Z'  "
#     ATOZCH :
#       BEGIN   K := 0 ;   ID := BLANKID ;
#
#         REPEAT
#         IF K < IDLNGTH THEN
#           BEGIN K := K + 1; ID[K] := UPSHIFT[CH] (*CH*) END ;        (*UPL*)
#         NEXTCH
#         UNTIL NOT(SOP[CH] IN [ATOZCH, NUMCH, UNDSCH, DOLLARCH]) ;
#
          FOR I := FRW[K] TO FRW[K+1] - 1 DO
            IF RW[I] = ID THEN
              BEGIN SY := RSY[I]; OP := ROP[I]; GOTO 2 END;
            SY := IDENT; OP := NOOP;
  2:    END;

  "   '0','1','2','3','4','5','6','7','8','9'  "
#     NUMCH :
        BEGIN OP := NOOP; I := 0;
          REPEAT I := I+1; IF I<= DIGMAX THEN DIGIT[I] := CH; NEXTCH
          UNTIL SOP[CH] <> NUMCH ;
          IF (CH = '.') OR (UPSHIFT[CH] (*CH*) = 'E') THEN
            BEGIN
                  K := I;
                  IF CH = '.' THEN
                    BEGIN K := K+1; IF K <= DIGMAX THEN DIGIT[K] := CH;
                      NEXTCH;
#                     IF CH = '.' THEN BEGIN  DOTFLG := TRUE;  GOTO 3 END;
                      IF SOP[CH] <> NUMCH THEN
                        ERROR(201)
                      ELSE
                        REPEAT K := K + 1;
                          IF K <= DIGMAX THEN DIGIT[K] := CH; NEXTCH
                        UNTIL SOP[CH] <> NUMCH
                    END;
#                 IF UPSHIFT[CH]  (*CH*) = 'E' THEN                      (*UPL*)
                    BEGIN K := K+1; IF K <= DIGMAX THEN DIGIT[K] := CH;
                      NEXTCH;
                      IF (CH = '+') OR (CH ='-') THEN
                        BEGIN K := K+1; IF K <= DIGMAX THEN DIGIT[K] := CH;
                          NEXTCH
                        END;
                      IF SOP[CH] <> NUMCH THEN
                        ERROR(201)
                      ELSE
                        REPEAT K := K+1;
                          IF K <= DIGMAX THEN DIGIT[K] := CH; NEXTCH
                        UNTIL SOP[CH] <> NUMCH
                     END;
                   NEW(LVP,REEL); SY:= REALCONST; "LVP@.CCLASS := REEL;"
                   WITH LVP@ DO
                     BEGIN FOR I := 1 TO REALLNGTH DO RVAL[I] := ' ';
                       IF K <= DIGMAX THEN
                         FOR I := 2 TO K + 1 DO RVAL[I] := DIGIT[I-1]
                       ELSE BEGIN ERROR(203); RVAL[2] := '0';
                              RVAL[3] := '.'; RVAL[4] := '0'
                            END
                     END;
                   VAL.VALP := LVP
            END
          ELSE
  3:        BEGIN
              IF I > DIGMAX THEN BEGIN ERROR(203); VAL.IVAL := 0 END
              ELSE
                WITH VAL DO
                  BEGIN IVAL := 0;
                    FOR K := 1 TO I DO
                      BEGIN
                        IF IVAL <= MXINT10 THEN
                          IVAL := IVAL*10 + (ORD(DIGIT[K])-ORD('0'))
                        ELSE BEGIN ERROR(203); IVAL := 0 END
                      END;
                    SY := INTCONST
                 END
            END
        END;

#     QUOTCH   "''''  " :
        BEGIN LNGTH := 0; SY := STRINGCONST;  OP := NOOP;
          REPEAT
            REPEAT NEXTCH; LNGTH := LNGTH + 1;
                   IF LNGTH <= STRGLNGTH THEN STRING[LNGTH] := CH
            UNTIL (EOL) OR (CH = '''');
            IF EOL THEN ERROR(202) ELSE NEXTCH
          UNTIL CH <> '''';
          LNGTH := LNGTH - 1;   (*NOW LNGTH = NR OF CHARS IN STRING*)
          IF LNGTH = 1 THEN VAL.IVAL := ORD(STRING[1])
          ELSE
            BEGIN   NEW(LVP,STRG);  "LVP@.CLASS := STRG ;"
              IF LNGTH > STRGLNGTH THEN
                BEGIN ERROR(398); LNGTH := STRGLNGTH END;
#             IF LNGTH <= 0 THEN ERROR(205) ;
              WITH  LVP@  DO
                BEGIN SLNGTH := LNGTH;
                  FOR I := 1 TO LNGTH DO SVAL[I] := STRING[I]
                END;
              VAL.VALP := LVP
            END
        END;

#     COLONCH   "':'  ":
        BEGIN OP := NOOP; NEXTCH;
          IF CH = '=' THEN
            BEGIN SY := BECOMES; NEXTCH END
          ELSE SY := COLON
        END;

#     DOTCH   "'.'  " :
        BEGIN  OP := NOOP;  IF NOT DOTFLG THEN NEXTCH;
          IF CH = '.' THEN
            BEGIN  SY := DOTDOT;  DOTFLG := FALSE ;  NEXTCH  END
          ELSE SY := PERIOD
        END;

#     LTOP   "'<'  " :
        BEGIN NEXTCH; SY := RELOP;
          IF CH = '=' THEN
            BEGIN OP := LEOP; NEXTCH END
          ELSE
            IF CH = '>' THEN
              BEGIN OP := NEOP; NEXTCH END
            ELSE OP := LTOP
        END;

#     GTOP   "'>'  ":
        BEGIN NEXTCH; SY := RELOP;
          IF CH = '=' THEN
            BEGIN OP := GEOP; NEXTCH END
          ELSE OP := GTOP
        END;

#     LPARCH   "'('  ":
       BEGIN NEXTCH;
#        IF CH = '*' THEN
            BEGIN  NEXTCH;
            IF CH = '$' THEN OPTIONS('*');
            COMMENT('*');  NEXTCH;  GOTO 1;
            END ;
          " BEGIN NEXTCH;
              IF CH = '$' THEN OPTIONS;
              REPEAT
                WHILE CH <> '*'  DO NEXTCH;
                NEXTCH
              UNTIL CH = ')';
              NEXTCH; GOTO 1
            END ; "

#        IF CH = '/' THEN
#          BEGIN   SY := LBRACK ;  OP := NOOP ;
#          NEXTCH
#          END
         ELSE  BEGIN  SY := LPARENT; OP := NOOP  END
       END;

  "   '*','+','-',
      '=','/',')','&','Ý','^',
#     '[',']',',',';','@'   "
#     PLUS, MINUS, MUL, RDIV, EQOP, OROP, ANDOP, SPECH :
        BEGIN SY := SSY[CH]; OP := SOP[CH];
#         IF CH = '/' THEN
#           BEGIN  NEXTCH ;
#             IF CH =')' THEN
#               BEGIN  SY := RBRACK ;  OP := NOOP ;
#                 NEXTCH ;
#               END
#           END
#         ELSE  NEXTCH
        END;

#     DQUOTCH (* '"' *) :
#       BEGIN   REPEAT NEXTCH UNTIL CH = '"' ;
#         NEXTCH ;   GOTO 1 ;
#       END ;

#     LBRACE (* '¯' *) :
#       BEGIN  NEXTCH;
        IF CH = '$' THEN OPTIONS('');
        COMMENT('');  NEXTCH;  GOTO 1;
        END;

#     SKIPCH   "'#'  " :
#       BEGIN  NEXTCH ;  GOTO 1  END ;
#
#     ILLEGCH, DOLLARCH, UNDSCH   "'','_','$'  ":
#       BEGIN SY := OTHERSY; OP := NOOP; ERROR(6) ; NEXTCH END

    END (*CASE*)

  END (*INSYMBOL*) ;


  PROCEDURE ENTERID(FCP: CTP);
    (*ENTER ID POINTED AT BY FCP INTO THE NAME-TABLE,
     WHICH ON EACH DECLARATION LEVEL IS ORGANISED AS
     AN UNBALANCED BINARY TREE*)
    VAR NAM: ALPHA; LCP, LCP1: CTP; LLEFT: BOOLEAN;
  BEGIN NAM := FCP@.NAME;
    LCP := DISPLAY[TOP].FNAME;
    IF LCP = NIL THEN
      DISPLAY[TOP].FNAME := FCP
    ELSE
      BEGIN
        REPEAT LCP1 := LCP;
          IF LCP@.NAME = NAM THEN   (*NAME CONFLICT, FOLLOW RIGHT LINK*)
            BEGIN ERROR(101); LCP := LCP@.RLINK; LLEFT := FALSE END
          ELSE
            IF LCP@.NAME < NAM THEN
              BEGIN LCP := LCP@.RLINK; LLEFT := FALSE END
            ELSE BEGIN LCP := LCP@.LLINK; LLEFT := TRUE END
        UNTIL LCP = NIL;
        IF LLEFT THEN LCP1@.LLINK := FCP ELSE LCP1@.RLINK := FCP
      END;
    FCP@.LLINK := NIL; FCP@.RLINK := NIL
  END (*ENTERID*) ;


  PROCEDURE SEARCHSECTION(FCP: CTP; VAR FCP1: CTP);
    (*TO FIND RECORD FIELDS AND FORWARD DECLARED PROCEDURE ID'S
     --> PROCEDURE PROCEDUREDECLARATION
     --> PROCEDURE SELECTOR*)
     LABEL 1;
  BEGIN
    WHILE FCP <> NIL DO
      IF FCP@.NAME = ID THEN GOTO 1
      ELSE IF FCP@.NAME < ID THEN FCP := FCP@.RLINK
        ELSE FCP := FCP@.LLINK;
1:  FCP1 := FCP
  END (*SEARCHSECTION*) ;


  PROCEDURE SEARCHID(FIDCLS: SETOFIDS; VAR FCP: CTP);
    LABEL 1;
    VAR LCP: CTP;
  BEGIN
    FOR DISX := TOP DOWNTO 0 DO
      BEGIN LCP := DISPLAY[DISX].FNAME;
        WHILE LCP <> NIL DO
          IF LCP@.NAME = ID THEN
            IF LCP@.KLASS IN FIDCLS THEN GOTO 1
            ELSE
              BEGIN IF PRTERR THEN ERROR(103);
                LCP := LCP@.RLINK
              END
          ELSE
            IF LCP@.NAME < ID THEN
              LCP := LCP@.RLINK
            ELSE LCP := LCP@.LLINK
      END;
    (*SEARCH NOT SUCCSESSFUL; SUPPRESS ERROR MESSAGE IN CASE
     OF FORWARD REFERENCED TYPE ID IN POINTER TYPE DEFINITION
     --> PROCEDURE SIMPLETYPE*)
    IF PRTERR THEN
      BEGIN ERROR(104);
        (*TO AVOID RETURNING NIL, REFERENCE AN ENTRY
         FOR AN UNDECLARED ID OF APPROPRIATE CLASS
         --> PROCEDURE ENTERUNDECL*)
        IF TYPES IN FIDCLS THEN LCP := UTYPPTR
        ELSE
          IF VARS IN FIDCLS THEN LCP := UVARPTR
          ELSE
            IF FIELD IN FIDCLS THEN LCP := UFLDPTR
            ELSE
              IF KONST IN FIDCLS THEN LCP := UCSTPTR
              ELSE
                IF PROC IN FIDCLS THEN LCP := UPRCPTR
                ELSE LCP := UFCTPTR;
      END;
1:  FCP := LCP
  END (*SEARCHID*) ;


  PROCEDURE GETBOUNDS(FSP: STP; VAR FMIN,FMAX: INTEGER);
    (*GET INTERNAL BOUNDS OF SUBRANGE OR SCALAR TYPE*)
    (*ASSUME (FSP <> NIL) AND (FSP@.FORM <= SUBRANGE) AND (FSP <> INTPTR)
     AND NOT COMPTYPES(REALPTR,FSP)*)
  BEGIN
    WITH FSP@ DO
      IF FORM = SUBRANGE THEN
        BEGIN FMIN := MIN.IVAL; FMAX := MAX.IVAL END
      ELSE
        BEGIN FMIN := 0;
#         IF FSP = CHARPTR THEN "IF BYTEON THEN" FMAX := ORDCHMAX "ELSEFMAX:=63"
          ELSE
            IF (FORM = SCALAR) AND (FSP@.FCONST <> NIL) THEN
              FMAX := FSP@.FCONST@.VALUES.IVAL
            ELSE FMAX := 0
        END
  END (*GETBOUNDS*) ;


" PROCEDURE PRINTTABLES(FB: BOOLEAN);
    (*PRINT DATA STRUCTURE AND NAME TABLE*)
    VAR I, LIM: DISPRANGE;

    PROCEDURE MARKER;
      (*MARK DATA STRUCTURE ENTRIES TO AVOID MULTIPLE PRINTOUT*)
      VAR I: INTEGER;

      PROCEDURE MARKCTP(FP: CTP); FORWARD;

      PROCEDURE MARKSTP(FP: STP);
        (*MARK DATA STRUCTURES, PREVENT CYCLES*)
      BEGIN
        IF FP <> NIL THEN
          WITH FP@ DO
            BEGIN MARKED := TRUE;
              CASE FORM OF
              SCALAR:   ;
              SUBRANGE: MARKSTP(RANGETYPE);
              POINTER:  (*DON'T MARK ELTYPE: CYCLE POSSIBLE; WILL BE MARKED
                        ANYWAY, IF FP = TRUE*) ;
              POWER:    MARKSTP(ELSET) ;
              ARRAYS:   BEGIN MARKSTP(AELTYPE); MARKSTP(INXTYPE) END;
              RECORDS:  BEGIN MARKCTP(FSTFLD); MARKSTP(RECVAR) END;
              FILES:    MARKSTP(FILTYPE);
              TAGFLD:   MARKSTP(FSTVAR);
              VARIANT:  BEGIN MARKSTP(NXTVAR); MARKSTP(SUBVAR) END
              END (*CASE*)
            END (*WITH*)
      END (*MARKSTP*);

      PROCEDURE MARKCTP;
      BEGIN
        IF FP <> NIL THEN
          WITH FP@ DO
            BEGIN MARKCTP(LLINK); MARKCTP(RLINK);
              MARKSTP(IDTYPE)
            END
      END (*MARKCTP*);

    BEGIN (*MARK*)
      FOR I := TOP DOWNTO LIM DO
        MARKCTP(DISPLAY[I].FNAME)
    END (*MARK*);

    PROCEDURE FOLLOWCTP(FP: CTP); FORWARD;

    PROCEDURE FOLLOWSTP(FP: STP);
    BEGIN
      IF FP <> NIL THEN
        WITH FP@ DO
          IF MARKED THEN
            BEGIN MARKED := FALSE; WRITE(OUTPUT,' ':4,ORD(FP):6,SIZE:10);
              CASE FORM OF
              SCALAR:   BEGIN WRITE(OUTPUT,'SCALAR':10);
                          IF SCALKIND = STANDARD THEN
                           WRITE(OUTPUT,'STANDARD    ':10)
                          ELSE WRITE(OUTPUT,'DECLARED    ':10, ORD(FCONST):8);
                          WRITELN(OUTPUT)
                        END;
              SUBRANGE:BEGIN
                        WRITE(OUTPUT,'SUBRANGE    ':10,' ':4,ORD(RANGETYPE):6);
                            IF RANGETYPE <> REALPTR THEN
                              WRITE(OUTPUT,MIN.IVAL,MAX.IVAL)
                            ELSE
                              IF (MIN.VALP <> NIL) AND (MAX.VALP <> NIL) THEN
                                WRITE(OUTPUT,' ',MIN.VALP@.RVAL:9,
                                      ' ',MAX.VALP@.RVAL:9);
                            WRITELN(OUTPUT); FOLLOWSTP(RANGETYPE);
                          END;
              POINTER:  WRITELN(OUTPUT,'POINTER':10,' ':4,ORD(ELTYPE):6);
              POWER:    BEGIN WRITELN(OUTPUT,'SET':10,' ':4,ORD(ELSET):6);
                            FOLLOWSTP(ELSET)
                          END;
              ARRAYS:   BEGIN
                         WRITELN(OUTPUT,'ARRAY':10,' ':4,ORD(AELTYPE):6,' ':4,
                            ORD(INXTYPE):6);
                            FOLLOWSTP(AELTYPE); FOLLOWSTP(INXTYPE)
                          END;
              RECORDS:  BEGIN
                        WRITELN(OUTPUT,'RECORD':10,' ':4,ORD(FSTFLD):6,' ':4,
                            ORD(RECVAR):6); FOLLOWCTP(FSTFLD);
                            FOLLOWSTP(RECVAR)
                          END;
              FILES:    BEGIN WRITE(OUTPUT,'FILE':10,' ':4,ORD(FILTYPE):6);
                            FOLLOWSTP(FILTYPE)
                          END;
              TAGFLD:   BEGIN WRITELN(OUTPUT,'TAGFLD':10,' ':4,ORD(TAGFIELDP):6,
                            ' ':4,ORD(FSTVAR):6);
                            FOLLOWSTP(FSTVAR)
                          END;
              VARIANT:  BEGIN WRITELN(OUTPUT,'VARIANT':10,' ':4,ORD(NXTVAR):6,
                            ' ':4,ORD(SUBVAR):6,VARVAL.IVAL);
                            FOLLOWSTP(NXTVAR); FOLLOWSTP(SUBVAR)
                          END
              END (*CASE*)
            END (*IF MARKED*)
    END (*FOLLOWSTP*);

    PROCEDURE FOLLOWCTP;
      VAR I: INTEGER;
    BEGIN
      IF FP <> NIL THEN
        WITH FP@ DO
          BEGIN WRITE(OUTPUT,' ':4,ORD(FP):6,' ',NAME:9,' ':4,ORD(LLINK):6,
            ' ':4,ORD(RLINK):6,' ':4,ORD(IDTYPE):6);
            CASE KLASS OF
              TYPES: WRITE(OUTPUT,'TYPE':10);
              KONST: BEGIN WRITE(OUTPUT,'CONSTANT    ':10,' ':4,ORD(NEXT):6);
                     IF IDTYPE <> NIL THEN
                         IF IDTYPE = REALPTR THEN
                           BEGIN
                             IF VALUES.VALP <> NIL THEN
                               WRITE(OUTPUT,' ',VALUES.VALP@.RVAL:9)
                           END
                         ELSE
                           IF IDTYPE@.FORM = ARRAYS THEN  (*STRINGCONST*)
                             BEGIN
                               IF VALUES.VALP <> NIL THEN
                                 BEGIN WRITE(OUTPUT,' ');
                                   WITH VALUES.VALP@ DO
                                     FOR I := 1 TO SLNGTH DO
                                      WRITE(OUTPUT,SVAL[I])
                                 END
                             END
                           ELSE WRITE(OUTPUT,VALUES.IVAL)
                       END;
              VARS:  BEGIN WRITE(OUTPUT,'VARIABLE    ':10);
                        IF VKIND = ACTUAL THEN WRITE(OUTPUT,'ACTUAL':10)
                        ELSE WRITE(OUTPUT,'FORMAL':10);
                        WRITE(OUTPUT,' ':4,ORD(NEXT):6,VLEV,' ':4,VADDR:6 );
                      END;
              FIELD: WRITE(OUTPUT,'FIELD':10,' ':4,ORD(NEXT):6,' ':4,FLDADDR:6);
              PROC,
              FUNC:  BEGIN
                        IF KLASS = PROC THEN WRITE(OUTPUT,'PROCEDURE':10)
                        ELSE WRITE(OUTPUT,'FUNCTION    ':10);
                        IF PFDECKIND = STANDARD THEN
                         WRITE(OUTPUT,'STANDARD    ':10,
                          KEY:10)
                        ELSE
                          BEGIN WRITE(OUTPUT,'DECLARED    ':10, ORD(NEXT):8);
                            WRITE(OUTPUT,PFLEV,' ':4,PFNAME:6);
                            IF PFKIND = ACTUAL THEN
                              BEGIN WRITE(OUTPUT,'ACTUAL':10);
                                IF FWDECL THEN WRITE(OUTPUT,'FORWARD':10)
                                ELSE WRITE(OUTPUT,'NOTFORWARD':10);
                                IF EXTRN THEN WRITE(OUTPUT,'EXTRN':10)
                                ELSE WRITE(OUTPUT,'NOT EXTRN':10);
                              END
                            ELSE WRITE(OUTPUT,'FORMAL':10)
                          END
                     END
            END (*CASE*);
            WRITELN(OUTPUT); FOLLOWCTP(LLINK); FOLLOWCTP(RLINK);
            FOLLOWSTP(IDTYPE)
          END (*WITH*)
    END (*FOLLOWCTP*);

  BEGIN (*PRINTTABLES*)
    WRITELN(OUTPUT); WRITELN(OUTPUT); WRITELN(OUTPUT);
    IF FB THEN LIM := 0
    ELSE BEGIN LIM := TOP; WRITE(OUTPUT,' LOCAL') END;
    WRITELN(OUTPUT,' TABLES     '); WRITELN(OUTPUT);
    MARKER;
    FOR I := TOP DOWNTO LIM DO
      FOLLOWCTP(DISPLAY[I].FNAME);
      WRITELN(OUTPUT);
      IF NOT EOL THEN WRITE(OUTPUT,' ':CHCNT+16)
  END (*PRINTTABLES*); "


  PROCEDURE GENLABEL(VAR NXTLAB: INTEGER);
  BEGIN INTLABEL := INTLABEL + 1;
    NXTLAB := INTLABEL
  END (*GENLABEL*);


"E"(*THE FOLLOWING OUTPUTS ASYMBOL TABLE FILE FOR USE BY 'SNAPSHOT' PROGRAM*)
"E"
"E"PROCEDURE PRNTSYMBL(LCP:CTP);
"E"
"E"   VAR  LINELN:INTEGER;  (* CURRENT SYMBOL TABLE FILE LINE LENGTH *)
"E"
"E"   PROCEDURE PRNTVAR(VRP:CTP; VAR LINELN:INTEGER); FORWARD;
"E"
"E"   PROCEDURE PRNTTYPE(TYPP:STP; VAR LINELN:INTEGER);
"E"
"E"      VAR  VP: CTP;   MIN, MAX: INTEGER;
"E"
"E"      BEGIN
"E"      IF (LINELN+3) >= 80 THEN BEGIN WRITELN(QRR);
"E"            WRITE(QRR,' ');  LINELN := 0; END
"E"         ELSE  LINELN := LINELN+3;
"E"      IF TYPP=INTPTR THEN WRITE(QRR,'I; ')
"E"         ELSE IF TYPP=REALPTR THEN WRITE(QRR,'R; ')
"E"         ELSE IF TYPP=BOOLPTR THEN WRITE(QRR,'B; ')
"E"         ELSE IF TYPP=CHARPTR THEN WRITE(QRR,'C; ')
"E"         ELSE IF TYPP <> NIL THEN
"E"           CASE TYPP@.FORM OF
"E"
"E"           SUBRANGE,
"E"           SCALAR:  WRITE(QRR,'L; ');
"E"
"E"           POINTER: WRITE(QRR,'P; ');
"E"
"E"           POWER:   IF TYPP@.ELSET <> NIL THEN
"E"                      BEGIN     WRITE(QRR,'S ');
"E"                      IF (LINELN + 10) >= 80
"E"                         THEN BEGIN LINELN := 0;  WRITELN(QRR); END
"E"                         ELSE  LINELN := LINELN + 10;
"E"                      GETBOUNDS(TYPP@.ELSET, MIN, MAX) ;
"E"                      WRITE(QRR, MIN:3,' ', MAX:3, ' ; ');
"E"                      END;
"E"
"E"           FILES:   WRITE(QRR,'F; ');
"E"
"E"           RECORDS: BEGIN   WRITE(QRR,'D ');
"E"                    VP := TYPP@.FSTFLD;
"E"                    WHILE VP <> NIL DO BEGIN PRNTVAR(VP, LINELN);
"E"                       VP := VP@.NEXT;  END;
"E"                    IF (LINELN+2) >= 80 THEN BEGIN WRITELN(QRR);
"E"                         WRITE(QRR,' '); LINELN := 0; END
"E"                      ELSE LINELN := LINELN+2;
"E"                    WRITE(QRR,'; ');
"E"                    END;
"E"
"E"           ARRAYS:  IF TYPP@.INXTYPE <> NIL THEN
"E"                      BEGIN    WRITE(QRR,'A ');
"E"                      IF (LINELN+26) >= 80 THEN BEGIN  WRITELN(QRR);
"E"                           WRITE(QRR,' ');  LINELN := 0 END
"E"                        ELSE LINELN := LINELN+26;
"E"                      GETBOUNDS(TYPP@.INXTYPE, MIN, MAX) ;
"E"                      WRITE(QRR, MIN ,' ', MAX,' ');
"E"                      PRNTTYPE(TYPP@.AELTYPE, LINELN);
"E"                      END;
"E"           END (*CASE FORM OF...*) ;
"E"
"E"      END;    (* PRNTTYPE *)
"E"
"E"
"E"   PROCEDURE PRNTVAR;
"E"
"E"      BEGIN
"E"      IF (LINELN+IDLNGTH+1) >= 80 THEN BEGIN  WRITELN(QRR);
"E"            WRITE(QRR,' ');  LINELN := 0; END
"E"         ELSE LINELN := LINELN+IDLNGTH+1;
"E"
"E"      WRITE(QRR,VRP@.NAME,' ');
"E"      PRNTTYPE(VRP@.IDTYPE, LINELN);
"E"      END;
"E"
"E"   BEGIN   (* PRNTSYMBL *)
"E"   IF PRCODE THEN
"E"      BEGIN
"E"      CASE LCP@.KLASS OF
"E"        VARS:  BEGIN
"E"               IF LCP@.VKIND = FORMAL THEN WRITE(QRR,'@');
"E"               WRITE(QRR,LCP@.VADDR,' ',LCP@.NAME,' ');
"E"               LINELN := IDLNGTH+12;
"E"               PRNTTYPE(LCP@.IDTYPE, LINELN);
"E"               END;
"E"
"E"        PROC,FUNC:  BEGIN
"E"               WRITELN(QRR,'% ',LCP@.NAME,' ',LCP@.PFNAME);
"E"               WHILE LCP@.NEXT <> NIL DO  BEGIN
"E"                 PRNTSYMBL(LCP@.NEXT);  LCP := LCP@.NEXT;  END;
"E"               END;
"E"        TYPES,KONST,FIELD: ;
"E"        END;
"E"      WRITELN(QRR);
"E"      END (*IF PRCODE*) ;
"E"   END;  (* PRNTSYMBL *)


  PROCEDURE BLOCK(FSYS: SETOFSYS; FSY: SYMBOL; FPROCP: CTP);
#   VAR LSY: SYMBOL; TEST: BOOLEAN; SEGSIZE: INTEGER ;


    PROCEDURE SKIP(FSYS: SETOFSYS);
      (*SKIP INPUT STRING UNTIL RELEVANT SYMBOL FOUND*)
    BEGIN
    WHILE NOT(SY IN FSYS) DO
      BEGIN
      INSYMBOL
      END ;
    END (*SKIP*) ;


#    PROCEDURE ALIGN(VAR Q:ADDRRANGE;  P: ADDRRANGE) ;
#      VAR I : INTEGER ;
#
#      BEGIN
#      IF P >= REALSIZE THEN  P := REALSIZE
#      ELSE  IF P >= INTSIZE THEN  P := INTSIZE
#            ELSE IF P <= 0 THEN  IF ERRORCNT = 0 THEN  ERROR(401) ;
#      IF P >= INTSIZE THEN
#      BEGIN  I:= Q MOD P ; IF I > 0 THEN Q := Q+(P-I) END ;
#      END (*ALIGN*) ;


    PROCEDURE CONSTANT(FSYS: SETOFSYS; VAR FSP: STP; VAR FVALU: VALU);
      VAR LSP: STP; LCP: CTP; SIGN: (NONE,POS,NEG);
          LVP: CSP; I: 2..REALLNGTH;
    BEGIN LSP := NIL; FVALU.IVAL := 0;
      IF NOT(SY IN CONSTBEGSYS) THEN
        BEGIN ERROR(50); SKIP(FSYS+CONSTBEGSYS) END;
      IF SY IN CONSTBEGSYS THEN
        BEGIN
          IF SY = STRINGCONST THEN
            BEGIN
              IF LNGTH = 1 THEN LSP := CHARPTR
              ELSE
                BEGIN
                  NEW(LSP,ARRAYS);
                  WITH LSP@ DO
                    BEGIN AELTYPE := CHARPTR; INXTYPE := NIL;
                       SIZE := LNGTH*CHARSIZE; FORM := ARRAYS
                    END
                END;
              FVALU := VAL; INSYMBOL
            END
          ELSE
            BEGIN
              SIGN := NONE;
              IF (SY = ADDOP) AND (OP IN [PLUS,MINUS]) THEN
                BEGIN IF OP = PLUS THEN SIGN := POS ELSE SIGN := NEG;
                  INSYMBOL
                END;
              IF SY = IDENT THEN
                BEGIN SEARCHID([KONST],LCP);
                  WITH LCP@ DO
                    BEGIN LSP := IDTYPE; FVALU := VALUES END;
                  IF SIGN <> NONE THEN
                    IF LSP = INTPTR THEN
                      BEGIN IF SIGN = NEG THEN FVALU.IVAL := -FVALU.IVAL END
                    ELSE
                      IF LSP = REALPTR THEN
                        BEGIN
                          IF SIGN = NEG THEN
                            BEGIN NEW(LVP,REEL);
                              IF FVALU.VALP@.RVAL[1] = '-' THEN
                                LVP@.RVAL[1] := '+'
                              ELSE LVP@.RVAL[1] := '-';
                              FOR I := 2 TO REALLNGTH DO
                                LVP@.RVAL[I] := FVALU.VALP@.RVAL[I];
                              FVALU.VALP := LVP;
                            END
                          END
                        ELSE ERROR(105);
                  INSYMBOL;
                END
              ELSE
                IF SY = INTCONST THEN
                  BEGIN IF SIGN = NEG THEN VAL.IVAL := -VAL.IVAL;
                    LSP := INTPTR; FVALU := VAL; INSYMBOL
                  END
                ELSE
                  IF SY = REALCONST THEN
                    BEGIN IF SIGN = NEG THEN VAL.VALP@.RVAL[1] := '-';
                      LSP := REALPTR; FVALU := VAL; INSYMBOL
                    END
                  ELSE
                    BEGIN ERROR(106); SKIP(FSYS) END
            END;
          IF NOT (SY IN FSYS) THEN
            BEGIN ERROR(6); SKIP(FSYS) END
          END;
      FSP := LSP
    END (*CONSTANT*) ;


    FUNCTION COMPTYPES(FSP1,FSP2: STP) : BOOLEAN;
      (*DECIDE WHETHER STRUCTURES POINTED AT BY FSP1 AND FSP2 ARE COMPATIBLE*)
      VAR NXT1,NXT2: CTP; COMP: BOOLEAN;
        LTESTP1,LTESTP2 : TESTP;
    BEGIN
      IF FSP1 = FSP2 THEN COMPTYPES := TRUE
      ELSE
        IF (FSP1 <> NIL) AND (FSP2 <> NIL) THEN
          IF FSP1@.FORM = FSP2@.FORM THEN
            CASE FSP1@.FORM OF
              SCALAR:
                COMPTYPES := FALSE;
                (* IDENTICAL SCALARS DECLARED ON DIFFERENT LEVELS ARE
                 NOT RECOGNIZED TO BE COMPATIBLE*)
              SUBRANGE:
                COMPTYPES := COMPTYPES(FSP1@.RANGETYPE,FSP2@.RANGETYPE);
              POINTER:
                  BEGIN
                    COMP := FALSE; LTESTP1 := GLOBTESTP;
                    LTESTP2 := GLOBTESTP;
                    WHILE LTESTP1 <> NIL DO
                      WITH LTESTP1@ DO
                        BEGIN
                          IF (ELT1 = FSP1@.ELTYPE) AND
                            (ELT2 = FSP2@.ELTYPE) THEN COMP := TRUE;
                          LTESTP1 := LASTTESTP
                        END;
                    IF NOT COMP THEN
                      BEGIN NEW(LTESTP1);
                        WITH LTESTP1@ DO
                          BEGIN ELT1 := FSP1@.ELTYPE;
                            ELT2 := FSP2@.ELTYPE;
                            LASTTESTP := GLOBTESTP
                          END;
                        GLOBTESTP := LTESTP1;
                        COMP := COMPTYPES(FSP1@.ELTYPE,FSP2@.ELTYPE)
                      END;
                    COMPTYPES := COMP; GLOBTESTP := LTESTP2
                  END;
              POWER:
                COMPTYPES := COMPTYPES(FSP1@.ELSET,FSP2@.ELSET);
              ARRAYS:
                COMPTYPES := COMPTYPES(FSP1@.AELTYPE,FSP2@.AELTYPE)
                             AND (FSP1@.SIZE = FSP2@.SIZE);
                (*ALTERNATIVES: -- ADD A THIRD BOOLEAN TERM: INDEXTYPE MUST
                                  BE COMPATIBLE.
                               -- ADD A FOURTH BOOLEAN TERM: LOWBOUNDS MUST
                                  BE THE SAME*)
              RECORDS:
                BEGIN NXT1 := FSP1@.FSTFLD; NXT2 := FSP2@.FSTFLD; COMP:=TRUE;
                  WHILE (NXT1 <> NIL) AND (NXT2 <> NIL) DO
                    BEGIN COMP:=COMP AND COMPTYPES(NXT1@.IDTYPE,NXT2@.IDTYPE);
                      NXT1 := NXT1@.NEXT; NXT2 := NXT2@.NEXT
                    END;
                  COMPTYPES := COMP AND (NXT1 = NIL) AND (NXT2 = NIL)
                              AND(FSP1@.RECVAR = NIL)AND(FSP2@.RECVAR = NIL)
                END;
                (*IDENTICAL RECORDS ARE RECOGNIZED TO BE COMPATIBLE
                 IFF NO VARIANTS OCCUR*)
              FILES:
                COMPTYPES := COMPTYPES(FSP1@.FILTYPE,FSP2@.FILTYPE)
            END (*CASE*)
          ELSE (*FSP1@.FORM <> FSP2@.FORM*)
            IF FSP1@.FORM = SUBRANGE THEN
              COMPTYPES := COMPTYPES(FSP1@.RANGETYPE,FSP2)
            ELSE
              IF FSP2@.FORM = SUBRANGE THEN
                COMPTYPES := COMPTYPES(FSP1,FSP2@.RANGETYPE)
              ELSE COMPTYPES := FALSE
        ELSE COMPTYPES := TRUE
    END (*COMPTYPES*) ;


    FUNCTION STRING(FSP: STP) : BOOLEAN;
    BEGIN STRING := FALSE;
      IF FSP <> NIL THEN
        IF FSP@.FORM = ARRAYS THEN
#         STRING := COMPTYPES(FSP@.AELTYPE,CHARPTR)
    END (*STRING*) ;


    PROCEDURE TYP(FSYS: SETOFSYS; VAR FSP: STP; VAR FSIZE: ADDRRANGE);
      VAR LSP,LSP1,LSP2: STP; OLDTOP: DISPRANGE; LCP: CTP;
          LSIZE,DISPL: ADDRRANGE; LMIN,LMAX: INTEGER;  ALNFCT : 1..8 ;

      PROCEDURE SIMPLETYPE(FSYS:SETOFSYS; VAR FSP:STP"; VAR FSIZE:ADDRRANGE");
        VAR LSP,LSP1: STP; LCP,LCP1: CTP; TTOP: DISPRANGE;
            LCNT: INTEGER; LVALU: VALU;
      BEGIN FSIZE := 1;
        IF NOT (SY IN SIMPTYPEBEGSYS) THEN
          BEGIN ERROR(1); SKIP(FSYS + SIMPTYPEBEGSYS) END;
        IF SY IN SIMPTYPEBEGSYS THEN
          BEGIN
            IF SY = LPARENT THEN
              BEGIN TTOP := TOP;   (*DECL. CONSTS LOCAL TO INNERMOST BLOCK*)
                WHILE DISPLAY[TOP].OCCUR <> BLCK DO TOP := TOP - 1;
                NEW(LSP,SCALAR,DECLARED);
                WITH LSP@ DO
                  BEGIN SIZE := INTSIZE; FORM := SCALAR;
                    SCALKIND := DECLARED
                  END;
                LCP1 := NIL; LCNT := 0;
                REPEAT INSYMBOL;
                  IF SY = IDENT THEN
                    BEGIN NEW(LCP,KONST);
                      WITH LCP@ DO
                        BEGIN NAME := ID; IDTYPE := LSP; NEXT := LCP1;
                          VALUES.IVAL := LCNT; KLASS := KONST
                        END;
                      ENTERID(LCP);
                      LCNT := LCNT + 1;
                      LCP1 := LCP; INSYMBOL
                    END
                  ELSE ERROR(2);
                  IF NOT (SY IN FSYS + [COMMA,RPARENT]) THEN
                    BEGIN ERROR(6); SKIP(FSYS + [COMMA,RPARENT]) END
                UNTIL SY <> COMMA;
#               IF PACKDATA THEN
#                 IF LCNT < 256 THEN  LSP@.SIZE := CHARSIZE ;
#               LSP@.ALN := LSP@.SIZE ;
                LSP@.FCONST := LCP1; TOP := TTOP;
                IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
              END
            ELSE
              BEGIN
                IF SY = IDENT THEN
                  BEGIN SEARCHID([TYPES,KONST],LCP);
                    INSYMBOL;
                    IF LCP@.KLASS = KONST THEN
                      BEGIN NEW(LSP,SUBRANGE);
                        WITH LSP@, LCP@ DO
                          BEGIN RANGETYPE := IDTYPE; FORM := SUBRANGE;
                            IF STRING(RANGETYPE) THEN
                              BEGIN ERROR(148); RANGETYPE := NIL END;
#                           MIN := VALUES; SIZE := IDTYPE@.SIZE
                          END;
#                       IF SY = DOTDOT THEN INSYMBOL ELSE ERROR(5);
                        CONSTANT(FSYS,LSP1,LVALU);
                        LSP@.MAX := LVALU;
#                       IF PACKDATA THEN
#                         IF LVALU.IVAL < 256 THEN
#                           IF LSP@.MIN.IVAL >= 0 THEN  LSP@.SIZE := CHARSIZE ;
#                       LSP@.ALN := LSP@.SIZE ;
                        IF LSP@.RANGETYPE <> LSP1 THEN ERROR(107)
                      END
                    ELSE
                      BEGIN LSP := LCP@.IDTYPE;
#                     " IF LSP <> NIL THEN FSIZE := LSP@.SIZE  "
                      END
                  END (*SY = IDENT*)
                ELSE
                  BEGIN NEW(LSP,SUBRANGE); LSP@.FORM := SUBRANGE;
                    CONSTANT(FSYS + [DOTDOT],LSP1,LVALU);
                    IF STRING(LSP1) THEN
                      BEGIN ERROR(148); LSP1 := NIL END;
                    WITH LSP@ DO
#                     BEGIN RANGETYPE:=LSP1; MIN:=LVALU; SIZE:=INTSIZE;
#                     IF LSP1 <> NIL THEN SIZE := LSP1@.SIZE ;
#                     END;
#                   IF SY = DOTDOT THEN INSYMBOL ELSE ERROR(5);
                    CONSTANT(FSYS,LSP1,LVALU);
                    LSP@.MAX := LVALU;
#                   IF PACKDATA THEN
#                     IF LVALU.IVAL < 256 THEN
#                       IF LSP@.MIN.IVAL >= 0 THEN  LSP@.SIZE := CHARSIZE ;
#                   LSP@.ALN := LSP@.SIZE ;
                    IF LSP@.RANGETYPE <> LSP1 THEN ERROR(107)
                  END;
                IF LSP <> NIL THEN
                  WITH LSP@ DO
                    IF FORM = SUBRANGE THEN
                      IF RANGETYPE <> NIL THEN
                        IF RANGETYPE = REALPTR THEN ERROR(398)
                        ELSE
                          IF MIN.IVAL > MAX.IVAL THEN ERROR(102)
              END;
            FSP := LSP;
            IF NOT (SY IN FSYS) THEN
              BEGIN ERROR(6); SKIP(FSYS) END
          END
            ELSE FSP := NIL
      END (*SIMPLETYPE*) ;


#     PROCEDURE FIELDLIST(FSYS: SETOFSYS; VAR FRECVAR: STP;VAR RECALN: ALNRNG);
        VAR LCP,LCP1,NXT,NXT1: CTP; LSP,LSP1,LSP2,LSP3,LSP4: STP;
#           MINSIZE,MAXSIZE,LSIZE: ADDRRANGE; LVALU: VALU; LALNFCT : ALNRNG ;
#     BEGIN  NXT := NIL;  LSP := NIL;  RECALN := 1;
        IF NOT (SY IN FSYS+[IDENT,CASESY]) THEN
          BEGIN ERROR(19); SKIP(FSYS + [IDENT,CASESY]) END;

        WHILE SY = IDENT DO
#         BEGIN  NXT1 := NIL;
            REPEAT
              IF SY = IDENT THEN
                BEGIN NEW(LCP,FIELD);
                  WITH LCP@ DO
#                   BEGIN NAME := ID; IDTYPE := NIL; NEXT := NIL;
                      KLASS := FIELD;
                    END;
#                 IF NXT1 = NIL THEN  NXT1 := LCP;
#                 IF NXT <> NIL THEN  NXT@.NEXT := LCP;
                  NXT := LCP;
                  ENTERID(LCP);
                  INSYMBOL
                END
              ELSE ERROR(2);
              IF NOT (SY IN [COMMA,COLON]) THEN
                BEGIN ERROR(6); SKIP(FSYS + [COMMA,COLON,SEMICOLON,CASESY])
                END;
              TEST := SY <> COMMA;
              IF NOT TEST  THEN INSYMBOL
            UNTIL TEST;
            IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
            TYP(FSYS + [CASESY,SEMICOLON],LSP,LSIZE);
#           LALNFCT := 1 ;  IF LSP <> NIL THEN LALNFCT := LSP@.ALN ;
#
#           WHILE NXT1 <> NIL DO  (* ANY "FIELDS" DEFINED IN THIS ROUND ? *)
#             BEGIN
#             WITH NXT1@ DO
#               BEGIN  IDTYPE := LSP; ALIGN(DISPL,LALNFCT);  FLDADDR := DISPL;
#               DISPL := DISPL + LSIZE;  NXT1 := NEXT;
#               END;
#             END (*WHILE NXT1 <> NIL*);
#
#           IF LALNFCT > RECALN THEN RECALN := LSP@.ALN ;
#           IF SY = SEMICOLON THEN
#             BEGIN INSYMBOL;
#               IF NOT (SY IN [IDENT,CASESY,ENDSY]) THEN     (* IGNOR EXTRA ; *)
#                 BEGIN ERROR(19); SKIP(FSYS + [IDENT,CASESY]) END
#             END
#         END (*WHILE*);
#
#      "NXT := NIL;
#       WHILE NXT1 <> NIL DO
#         WITH NXT1@ DO
#           BEGIN LCP := NEXT; NEXT := NXT; NXT := NXT1; NXT1 := LCP END;"
        IF SY = CASESY THEN
          BEGIN NEW(LSP,TAGFLD);
            WITH LSP@ DO
              BEGIN TAGFIELDP := NIL; FSTVAR := NIL; FORM:=TAGFLD END;
            FRECVAR := LSP;
            INSYMBOL;
            IF SY = IDENT THEN
              BEGIN NEW(LCP,FIELD);
                WITH LCP@ DO
                  BEGIN NAME := ID; IDTYPE := NIL; KLASS:=FIELD;
#                   NEXT := NIL ; (*FLDADDR WILL BE SET WHEN TYPE IS KNOWN*)
                  END;
"TF"           PRTERR := FALSE ;  SEARCHID([TYPES],LCP1) ;  PRTERR := TRUE ;
"TF"           IF LCP1 = NIL THEN  BEGIN  (*EXPLICIT TAG FIELD *)
#               ENTERID(LCP);  INSYMBOL ;
#               IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
#               IF SY <> IDENT THEN
#                 BEGIN ERROR(2); SKIP(FSYS + [OFSY,LPARENT]) END
"TF"        ;  END (* IF LCP1 = NIL *)
#               ELSE (* NO EXPLICT TAG FIELD  *)
"TF"             LCP@.NAME := BLANKID ;
                  BEGIN SEARCHID([TYPES],LCP1);
                    LSP1 := LCP1@.IDTYPE;
                    IF LSP1 <> NIL THEN
                      WITH LSP1@ DO
#                       BEGIN
"TF"                   IF LCP@.NAME <> BLANKID THEN  BEGIN
#                       ALIGN(DISPL,ALN) ;
#                       IF ALN > RECALN THEN RECALN := ALN ;
#                       LCP@.FLDADDR := DISPL ;  DISPL := DISPL + SIZE;
"TF"                   END (* LCP@.NAME <> BLANKID *) ;
                        IF (FORM <= SUBRANGE) OR STRING(LSP1) THEN
                          BEGIN IF COMPTYPES(REALPTR,LSP1) THEN ERROR(109)
                            ELSE IF STRING(LSP1) THEN ERROR(398);
                            LCP@.IDTYPE := LSP1; LSP@.TAGFIELDP := LCP;
                          END
                        ELSE ERROR(110);
                        END (* WITH LSP1@ DO *) ;
                    INSYMBOL;
                  END
              END
            ELSE BEGIN ERROR(2); SKIP(FSYS + [OFSY,LPARENT]) END;
#           LSP@.SIZE := DISPL;
            IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
            LSP1 := NIL; MINSIZE := DISPL; MAXSIZE := DISPL;
            REPEAT LSP2 := NIL;
              REPEAT CONSTANT(FSYS + [COMMA,COLON,LPARENT],LSP3,LVALU);
                IF LSP@.TAGFIELDP <> NIL THEN
                 IF NOT COMPTYPES(LSP@.TAGFIELDP@.IDTYPE,LSP3)THEN ERROR(111);
                NEW(LSP3,VARIANT);
                WITH LSP3@ DO
                  BEGIN NXTVAR := LSP1; SUBVAR := LSP2; VARVAL := LVALU;
                    FORM := VARIANT
                  END;
                LSP1 := LSP3; LSP2 := LSP3;
                TEST := SY <> COMMA;
                IF NOT TEST THEN INSYMBOL
              UNTIL TEST;
              IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
              IF SY = LPARENT THEN INSYMBOL ELSE ERROR(9);
              FIELDLIST(FSYS + [RPARENT,SEMICOLON],LSP2,LALNFCT);
#             IF LALNFCT > RECALN THEN  RECALN := LALNFCT ;
              IF DISPL > MAXSIZE THEN MAXSIZE := DISPL;
              WHILE LSP3 <> NIL DO
                BEGIN LSP4 := LSP3@.SUBVAR; LSP3@.SUBVAR := LSP2;
                  LSP3@.SIZE := DISPL;
                  LSP3 := LSP4
                END;
              IF SY = RPARENT THEN
                BEGIN INSYMBOL;
                  IF NOT (SY IN FSYS + [SEMICOLON]) THEN
                    BEGIN ERROR(6); SKIP(FSYS + [SEMICOLON]) END
                END
              ELSE ERROR(4);
              TEST := SY <> SEMICOLON;
              IF NOT TEST THEN
                BEGIN DISPL := MINSIZE;
#                  INSYMBOL ;  TEST := SY = ENDSY ;          (* IGNORE EXTRA ;*)
                END
            UNTIL TEST;
            DISPL := MAXSIZE;
            LSP@.FSTVAR := LSP1;
          END
        ELSE FRECVAR := NIL
      END (*FIELDLIST*) ;


    BEGIN (*TYP*)
      IF NOT (SY IN TYPEBEGSYS) THEN
         BEGIN ERROR(10); SKIP(FSYS + TYPEBEGSYS) END;
      IF SY IN TYPEBEGSYS THEN
        BEGIN
          IF SY IN SIMPTYPEBEGSYS THEN SIMPLETYPE(FSYS,FSP",FSIZE")
          ELSE
    (*@*)     IF SY = ARROW THEN
              BEGIN NEW(LSP,POINTER); FSP := LSP;
                WITH LSP@ DO
                  BEGIN ELTYPE := NIL;
#                 SIZE := PTRSIZE; ALN := PTRSIZE ; FORM:=POINTER
                  END;
                INSYMBOL;
                IF SY = IDENT THEN
                  BEGIN PRTERR := FALSE; (*NO ERROR IF SEARCH NOT SUCCESSFUL*)
                    SEARCHID([TYPES],LCP); PRTERR := TRUE;
                    IF LCP = NIL THEN   (*FORWARD REFERENCED TYPE ID*)
                      BEGIN NEW(LCP,TYPES);
                        WITH LCP@ DO
                          BEGIN NAME := ID; IDTYPE := LSP;
                            NEXT := FWPTR; KLASS := TYPES
                          END;
                        FWPTR := LCP
                      END
                    ELSE
                      BEGIN
                        IF LCP@.IDTYPE <> NIL THEN
                          IF LCP@.IDTYPE@.FORM = FILES THEN ERROR(108)
                          ELSE LSP@.ELTYPE := LCP@.IDTYPE
                      END;
                    INSYMBOL;
                  END
                ELSE ERROR(2);
              END
            ELSE
              BEGIN
                IF SY = PACKEDSY THEN
                  BEGIN INSYMBOL;
                    IF NOT (SY IN TYPEDELS) THEN
                      BEGIN
                        ERROR(10); SKIP(FSYS + TYPEDELS)
                      END
                  END;
    (*ARRAY*)     IF SY = ARRAYSY THEN
                  BEGIN INSYMBOL;
                    IF SY = LBRACK THEN INSYMBOL ELSE ERROR(11);
                    LSP1 := NIL;
                    REPEAT NEW(LSP,ARRAYS);
                      WITH LSP@ DO
                        BEGIN AELTYPE := LSP1; INXTYPE := NIL; FORM:=ARRAYS END;
                      LSP1 := LSP;
                      SIMPLETYPE(FSYS + [COMMA,RBRACK,OFSY],LSP2",LSIZE");
#                   " LSP1@.SIZE := LSIZE ;  NOT USED "
                      IF LSP2 <> NIL THEN
                        IF LSP2@.FORM <= SUBRANGE THEN
                          BEGIN
                            IF LSP2 = REALPTR THEN
                              BEGIN ERROR(109); LSP2 := NIL END
                            ELSE
                              IF LSP2 = INTPTR THEN
                                BEGIN ERROR(149); LSP2 := NIL END;
                            LSP@.INXTYPE := LSP2
                          END
                        ELSE BEGIN ERROR(113); LSP2 := NIL END;
                      TEST := SY <> COMMA;
                      IF NOT TEST THEN INSYMBOL
                    UNTIL TEST;
                    IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12);
                    IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
#                   TYP(FSYS,LSP,LSIZE);
#                   IF LSP <> NIL THEN ALIGN(LSIZE,LSP@.ALN) ;
                    REPEAT
                      WITH LSP1@ DO
                        BEGIN LSP2 := AELTYPE; AELTYPE := LSP;
                          IF INXTYPE <> NIL THEN
                            BEGIN GETBOUNDS(INXTYPE,LMIN,LMAX);
                              LSIZE := LSIZE*(LMAX - LMIN + 1);
                              SIZE := LSIZE ;
#                             IF LSP <> NIL THEN
#                               ALN := LSP@.ALN (*PROPAGATE ALN*) ;
                            END
                        END;
                      LSP := LSP1; LSP1 := LSP2
                    UNTIL LSP1 = NIL
                  END
                ELSE
    (*RECORD*)      IF SY = RECORDSY THEN
                    BEGIN INSYMBOL;
                      OLDTOP := TOP;
                      IF TOP < DISPLIMIT THEN
                        BEGIN TOP := TOP + 1;
                          WITH DISPLAY[TOP] DO
                            BEGIN FNAME := NIL;
                              FLABEL := NIL;
                                  OCCUR := REC
                            END
                        END
                      ELSE ERROR(250);
                      DISPL := 0;
                      FIELDLIST(FSYS-[SEMICOLON]+[ENDSY],LSP1,ALNFCT);
                      NEW(LSP,RECORDS);
                      WITH LSP@ DO
                        BEGIN FSTFLD := DISPLAY[TOP].FNAME;
                          RECVAR := LSP1; SIZE := DISPL;
                          FORM := RECORDS ;  ALN := ALNFCT ;
                        END;
                      TOP := OLDTOP;
                      IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
                    END
                  ELSE
    (*SET*)           IF SY = SETSY THEN
                      BEGIN INSYMBOL;
                        IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
                        SIMPLETYPE(FSYS,LSP1",LSIZE");
                        IF LSP1 <> NIL THEN
                          IF (LSP1 = CHARPTR) OR (LSP1 = INTPTR) THEN ERROR(304)
                          ELSE IF (LSP1@.FORM > SUBRANGE) THEN
                            BEGIN ERROR(115); LSP1 := NIL END
                          ELSE
                            IF LSP1 = REALPTR THEN ERROR(114)
#                           ELSE IF LSP1@.FORM = SUBRANGE THEN
#                                  IF LSP1@.MAX.IVAL > SETMAX   THEN ERROR(304);
                        NEW(LSP,POWER);
                        WITH LSP@ DO
                          BEGIN ELSET:=LSP1;
                          SIZE:=SETSIZE; ALN := INTSIZE ; FORM:=POWER
                          END;
                      END
                    ELSE
    (*FILE*)            IF SY = FILESY THEN
#                      "BEGIN ERROR(398); INSYMBOL; SKIP(FSYS); LSP:= NIL END;"
#                       BEGIN  INSYMBOL ;
#                       IF SY = OFSY THEN INSYMBOL  ELSE  ERROR(8) ;
#                       SIMPLETYPE(FSYS,LSP1",LSIZE") ;
#                       IF LSP1 = NIL THEN  ERROR(398)
#                       ELSE  IF LSP1 <> CHARPTR THEN ERROR(398) ;
#                       LSP := TEXTPTR ;
#                       END ;
                FSP := LSP
              END;
          IF NOT (SY IN FSYS) THEN
            BEGIN ERROR(6); SKIP(FSYS) END
        END
      ELSE FSP := NIL;
      IF FSP = NIL THEN FSIZE := 1 ELSE FSIZE := FSP@.SIZE
    END (*TYP*) ;


    PROCEDURE LABELDECLARATION;
      VAR LLP: LBP; REDEF: BOOLEAN; LBNAME: LABELRNG ;
    BEGIN
      REPEAT
        IF SY = INTCONST THEN
          WITH DISPLAY[TOP] DO
            BEGIN LLP := FLABEL; REDEF := FALSE;
              WHILE (LLP <> NIL) AND NOT REDEF DO
                IF LLP@.LABVAL <> VAL.IVAL THEN
                  LLP := LLP@.NEXTLAB
                ELSE BEGIN REDEF := TRUE; ERROR(166) END;
              IF NOT REDEF THEN
                BEGIN NEW(LLP);
                  WITH LLP@ DO
                    BEGIN LABVAL := VAL.IVAL; GENLABEL(LBNAME);
                      DEFINED := FALSE; NEXTLAB := FLABEL; LABNAME := LBNAME
                    END;
                  FLABEL := LLP
                END;
              INSYMBOL
            END
        ELSE ERROR(15);
        IF NOT ( SY IN FSYS + [COMMA, SEMICOLON] ) THEN
          BEGIN ERROR(6); SKIP(FSYS+[COMMA,SEMICOLON]) END;
        TEST := SY <> COMMA;
        IF NOT TEST THEN INSYMBOL
      UNTIL TEST;
      IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14)
    END (* LABELDECLARATION *) ;

    PROCEDURE CONSTDECLARATION;
      VAR LCP: CTP; LSP: STP; LVALU: VALU;
    BEGIN
      IF SY <> IDENT THEN
        BEGIN ERROR(2); SKIP(FSYS + [IDENT]) END;
      WHILE SY = IDENT DO
        BEGIN NEW(LCP,KONST);
          WITH LCP@ DO
            BEGIN NAME := ID; IDTYPE := NIL; NEXT := NIL; KLASS:=KONST END;
          INSYMBOL;
          IF (SY = RELOP) AND (OP = EQOP) THEN INSYMBOL ELSE ERROR(16);
          CONSTANT(FSYS + [SEMICOLON],LSP,LVALU);
          ENTERID(LCP);
          LCP@.IDTYPE := LSP; LCP@.VALUES := LVALU;
          IF SY = SEMICOLON THEN
            BEGIN INSYMBOL;
              IF NOT (SY IN FSYS + [IDENT]) THEN
                BEGIN ERROR(6); SKIP(FSYS + [IDENT]) END
            END
          ELSE ERROR(14)
        END
    END (*CONSTDECLARATION*) ;

    PROCEDURE TYPEDECLARATION;
      VAR LCP,LCP1,LCP2: CTP; LSP: STP; LSIZE: ADDRRANGE;
    BEGIN
      IF SY <> IDENT THEN
        BEGIN ERROR(2); SKIP(FSYS + [IDENT]) END;
      WHILE SY = IDENT DO
        BEGIN NEW(LCP,TYPES);
          WITH LCP@ DO
            BEGIN NAME := ID; IDTYPE := NIL; KLASS := TYPES END;
          INSYMBOL;
          IF (SY = RELOP) AND (OP = EQOP) THEN INSYMBOL ELSE ERROR(16);
          TYP(FSYS + [SEMICOLON],LSP,LSIZE);
          ENTERID(LCP);
          LCP@.IDTYPE := LSP;
          (*HAS ANY FORWARD REFERENCE BEEN SATISFIED:*)
          LCP1 := FWPTR;
          WHILE LCP1 <> NIL DO
            BEGIN
              IF LCP1@.NAME = LCP@.NAME THEN
                BEGIN LCP1@.IDTYPE@.ELTYPE := LCP@.IDTYPE;
                  IF LCP1 <> FWPTR THEN
                    LCP2@.NEXT := LCP1@.NEXT
                  ELSE FWPTR := LCP1@.NEXT;
                END;
              LCP2 := LCP1; LCP1 := LCP1@.NEXT
            END;
          IF SY = SEMICOLON THEN
            BEGIN INSYMBOL;
              IF NOT (SY IN FSYS + [IDENT]) THEN
                BEGIN ERROR(6); SKIP(FSYS + [IDENT]) END
            END
          ELSE ERROR(14)
        END;
      IF FWPTR <> NIL THEN
        BEGIN ERROR(117); WRITELN(OUTPUT);
          REPEAT WRITELN(OUTPUT,' TYPE-ID ',FWPTR@.NAME);
            FWPTR := FWPTR@.NEXT
          UNTIL FWPTR = NIL;
       """IF NOT EOL THEN WRITE(OUTPUT,' ': CHCNT+16) """
        END
    END (*TYPEDECLARATION*) ;

    PROCEDURE VARDECLARATION;
#     VAR  LCP, NXT, NXT1: CTP;  LSP: STP;  LSIZE: ADDRRANGE;
           LFPTR : FRECPTR ;
    BEGIN NXT := NIL;
#     REPEAT  NXT1 := NIL;
#       REPEAT
#         IF SY = IDENT THEN
#           BEGIN  NEW(LCP,VARS);
#             WITH LCP@ DO
#               BEGIN  NAME := ID;  NEXT := NIL;  KLASS := VARS;
#                 IDTYPE := NIL;  VKIND := ACTUAL;  VLEV := LEVEL
#               END;
#             ENTERID(LCP);
#             IF NXT1 = NIL THEN NXT1 := LCP;       (*BEGINNING OF THIS ROUND*)
#             IF NXT <> NIL THEN NXT@.NEXT := LCP;  (*LINK TO PREVIOUS CHAIN*)
#             NXT := LCP;
#             INSYMBOL;
#           END
#         ELSE ERROR(2);
#         IF NOT (SY IN FSYS + [COMMA,COLON] + TYPEDELS) THEN
#           BEGIN ERROR(6); SKIP(FSYS+[COMMA,COLON,SEMICOLON]+TYPEDELS) END;
#         TEST := SY <> COMMA;
#         IF NOT TEST THEN INSYMBOL
#       UNTIL TEST;
#       IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
#       TYP(FSYS + [SEMICOLON] + TYPEDELS,LSP,LSIZE);
#
#       WHILE NXT1 <> NIL DO
#         WITH  NXT1@ DO
#           BEGIN   IDTYPE := LSP;
#             IF  LSP = TEXTPTR THEN  (* TEXT FILE DECLARATION *)
#               BEGIN  "EBCD := EBCDFLG ;   EBCDFLG := FALSE ; "
#               IF LEVEL > 1 THEN  ERROR(398)
#               ELSE BEGIN
#                    NEW(LFPTR);  LFPTR@.FILIDPTR := NXT1;
#                    LFPTR@.NEXTFILE := FILEHEAD;  FILEHEAD := LFPTR;
#                    END ;
#               IF NXTFILBUF >= LASTFILBUF THEN  ERROR(258 (*TOO MANY FILES*)) ;
#               VADDR := NXTFILBUF; "VLEV := 1;"
#               NXTFILBUF := NXTFILBUF+1;
#               END
#             ELSE  (* OTHER VARIABLE DECLARATION *)
#               BEGIN
#               IF LSP <> NIL THEN  ALIGN(LC,LSP@.ALN) ;
#               VADDR := LC ;  LC := LC+LSIZE
#               END ;
"E"           IF DEBUG THEN  PRNTSYMBL(NXT1);
#             NXT1 := NEXT;
#           END;

        IF SY = SEMICOLON THEN
          BEGIN INSYMBOL;
            IF NOT (SY IN FSYS + [IDENT]) THEN
              BEGIN ERROR(6); SKIP(FSYS + [IDENT]) END
          END
        ELSE ERROR(14)
      UNTIL (SY <> IDENT) AND NOT (SY IN TYPEDELS);
      IF FWPTR <> NIL THEN
        BEGIN ERROR(117); WRITELN(OUTPUT);
          REPEAT WRITELN(OUTPUT,' TYPE-ID ',FWPTR@.NAME);
            FWPTR := FWPTR@.NEXT
          UNTIL FWPTR = NIL;
      """ IF NOT EOL THEN WRITE(OUTPUT,' ': CHCNT+16) """
        END ;
    END (*VARDECLARATION*) ;

    PROCEDURE PROCDECLARATION(FSY: SYMBOL);
      VAR OLDLEV: 0..MAXLEVEL; LSY: SYMBOL; LCP,LCP1: CTP; LSP: STP;
#         FORW: BOOLEAN; OLDTOP: DISPRANGE; PARCNT: INTEGER;
          LLC,LCM: ADDRRANGE; LBNAME, OLDLABEL: INTEGER; MARKP: @INTEGER;

      PROCEDURE PARAMETERLIST(FSY: SETOFSYS; VAR FPAR: CTP);
        VAR LCP,LCP1,LCP2,LCP3: CTP; LSP: STP; LKIND: IDKIND;
          LLC,LEN : ADDRRANGE; COUNT : INTEGER;
      BEGIN   LCP1 := NIL ;
"S1" "FPRM1 := LC ; RPRM1 := 0 ;  REGS_FULL := FALSE ;                         "
        IF NOT (SY IN FSY + [LPARENT]) THEN
          BEGIN ERROR(7); SKIP(FSYS + FSY + [LPARENT]) END;
        IF SY = LPARENT THEN
          BEGIN IF FORW THEN ERROR(119);
            INSYMBOL;
            IF NOT (SY IN [IDENT,VARSY,PROCSY,FUNCSY]) THEN
              BEGIN ERROR(7); SKIP(FSYS + [IDENT,RPARENT]) END;
            WHILE SY IN [IDENT,VARSY,PROCSY,FUNCSY] DO
              BEGIN
                IF SY = PROCSY THEN
                  BEGIN ERROR(398);
                    REPEAT INSYMBOL;
                      IF SY = IDENT THEN
                      BEGIN NEW(LCP,PROC,DECLARED,FORMAL);
                          WITH LCP@ DO
                            BEGIN NAME := ID; IDTYPE := NIL; NEXT := LCP1;
                              PFLEV := LEVEL (*BEWARE OF PARAMETER PROCEDURES*);
                              KLASS:=PROC;PFDECKIND:=DECLARED;PFKIND:=FORMAL
                            END;
                          ENTERID(LCP);
                          LCP1 := LCP; LC := LC + PTRSIZE;
                          INSYMBOL
                        END
                      ELSE ERROR(2);
                      IF NOT (SY IN FSYS + [COMMA,SEMICOLON,RPARENT]) THEN
                        BEGIN ERROR(7);SKIP(FSYS+[COMMA,SEMICOLON,RPARENT])END
                    UNTIL SY <> COMMA
                  END
                ELSE
                  BEGIN
                    IF SY = FUNCSY THEN
                      BEGIN ERROR(398); LCP2 := NIL;
                        REPEAT INSYMBOL;
                          IF SY = IDENT THEN
                            BEGIN NEW(LCP,FUNC,DECLARED,FORMAL);
                              WITH LCP@ DO
                                BEGIN NAME := ID; IDTYPE := NIL; NEXT := LCP2;
                                  PFLEV := LEVEL (*BEWARE PARAM FUNCS*);
                                  KLASS:=FUNC;PFDECKIND:=DECLARED;
                                  PFKIND:=FORMAL
                                END;
                              ENTERID(LCP);
                              LCP2 := LCP; LC := LC + PTRSIZE;
                              INSYMBOL;
                            END;
                          IF NOT (SY IN [COMMA,COLON] + FSYS) THEN
                           BEGIN ERROR(7);SKIP(FSYS+[COMMA,SEMICOLON,RPARENT])
                            END
                        UNTIL SY <> COMMA;
                        IF SY = COLON THEN
                          BEGIN INSYMBOL;
                            IF SY = IDENT THEN
                              BEGIN SEARCHID([TYPES],LCP);
                                LSP := LCP@.IDTYPE;
                                IF LSP <> NIL THEN
                                 IF NOT(LSP@.FORM IN[SCALAR,SUBRANGE,POINTER])
                                    THEN BEGIN ERROR(120); LSP := NIL END;
                                LCP3 := LCP2;
                                WHILE LCP2 <> NIL DO
                                  BEGIN LCP2@.IDTYPE := LSP; LCP := LCP2;
                                    LCP2 := LCP2@.NEXT
                                  END;
                                LCP@.NEXT := LCP1; LCP1 := LCP3;
                                INSYMBOL
                              END
                            ELSE ERROR(2);
                            IF NOT (SY IN FSYS + [SEMICOLON,RPARENT]) THEN
                              BEGIN ERROR(7);SKIP(FSYS+[SEMICOLON,RPARENT])END
                          END
                        ELSE ERROR(5)
                      END
                    ELSE
                      BEGIN
                        IF SY = VARSY THEN
                          BEGIN LKIND := FORMAL; INSYMBOL END
                        ELSE LKIND := ACTUAL;
                        LCP2 := NIL;
                        COUNT := 0;
                        REPEAT
                          IF SY = IDENT THEN
                            BEGIN NEW(LCP,VARS);
                              WITH LCP@ DO
                                BEGIN NAME:=ID; IDTYPE:=NIL; KLASS:=VARS;
                                  VKIND := LKIND; NEXT := LCP2; VLEV := LEVEL;
                                END;
                              ENTERID(LCP);
                              LCP2 := LCP; COUNT := COUNT+1;
                              INSYMBOL;
                            END;
                          IF NOT (SY IN [COMMA,COLON] + FSYS) THEN
                           BEGIN ERROR(7);SKIP(FSYS+[COMMA,SEMICOLON,RPARENT])
                            END;
                          TEST := SY <> COMMA;
                          IF NOT TEST THEN INSYMBOL
                        UNTIL TEST;
                        IF SY = COLON THEN
                          BEGIN INSYMBOL;
                            IF SY = IDENT THEN
                              BEGIN  SEARCHID([TYPES],LCP); LEN := PTRSIZE ;
#                               LSP := LCP@.IDTYPE;
                                IF LSP <> NIL THEN
#                                 BEGIN
#                                 IF (LKIND=ACTUAL) THEN
#                                   IF LSP@.FORM <= POWER THEN LEN := LSP@.SIZE
#                                   ELSE IF LSP@.FORM = FILES THEN ERROR(121)  ;
"CM"                              IF LSP@.FORM = POWER THEN  ALIGN(LC,INTSIZE)
"CM"                              ELSE ALIGN(LC, LEN) ;
#                                 END;
"S1" "                          ALIGN(LEN,MXDATASZE) ;  ALIGN(LC,MXDATASZE) ;  "
                                LC := LC+COUNT*LEN ; LCP3 := LCP2 ;  LLC := LC ;
                                WHILE LCP2 <> NIL DO
                                  BEGIN LCP := LCP2;
                                    WITH LCP2@ DO
                                      BEGIN IDTYPE := LSP; LLC := LLC-LEN;
                                        VADDR := LLC;
"S1" "                                  IF NOT REGS_FULL THEN                  "
"S1" "                                  IF RPRM1+LEN <= REGPRMAREA THEN        "
"S1" "                                    RPRM1 := RPRM1+LEN                   "
"S1" "                                  ELSE  REGS_FULL := TRUE ;              "
                                      END;
                                    LCP2 := LCP2@.NEXT
                                  END;
                                LCP@.NEXT := LCP1; LCP1 := LCP3;
                                INSYMBOL
                              END
                            ELSE ERROR(2);
                            IF NOT (SY IN FSYS + [SEMICOLON,RPARENT]) THEN
                              BEGIN ERROR(7);SKIP(FSYS+[SEMICOLON,RPARENT])END
                          END
                        ELSE ERROR(5);
                      END;
                  END;
                IF SY = SEMICOLON THEN
                  BEGIN INSYMBOL;
                    IF NOT (SY IN FSYS + [IDENT,VARSY,PROCSY,FUNCSY]) THEN
                      BEGIN ERROR(7); SKIP(FSYS + [IDENT,RPARENT]) END
                  END
              END (*WHILE*) ;
            IF SY = RPARENT THEN
              BEGIN INSYMBOL;
                IF NOT (SY IN FSY + FSYS) THEN
                  BEGIN ERROR(6); SKIP(FSY + FSYS) END
              END
            ELSE ERROR(4);
            LCP3 := NIL;
            (*REVERSE POINTERS AND RESERVE LOCAL CELLS FOR COPIES OF MULTIPLE
             VALUES*)
          " ALIGN(LC,MXDATASZE) ; " (*NORMALIZE STACK BEFORE ENTRING BLOCK*)
"S1" "      FPRM1 := LC-FPRM1 ;   SPRM1 := LC ;                                "
            WHILE LCP1 <> NIL DO
              WITH LCP1@ DO
                BEGIN LCP2 := NEXT; NEXT := LCP3;
                 "IF KLASS = VARS THEN           ???"
                    IF IDTYPE <> NIL THEN
#                     IF VKIND = ACTUAL THEN
#                         IF (IDTYPE@.FORM > POWER) THEN
                            BEGIN  ALIGN(LC,IDTYPE@.ALN (*OR IDTYPE@.SIZE*) ) ;
                            VADDR := LC; LC := LC + IDTYPE@.SIZE ;
                            END ;
                  LCP3 := LCP1; LCP1 := LCP2
                END;
"S1" "      ALIGN(LC, PTRSIZE) ;  SPRM1 := LC-SPRM1 ;                          "
            FPAR := LCP3
          END
            ELSE
"S1" "        BEGIN                                                            "
              FPAR := NIL ;
"S1" "        FPRM1 := 0 ;   SPRM1 := 0 ;   RPRM1 := 0 ;                       "
"S1" "        END ;                                                            "
    END (*PARAMETERLIST*) ;

    BEGIN (*PROCDECLARATION*)
      LLC := LC; LC := LCAFTMST;  (* ADR. OF THE FIRST VAR. IN THIS PROC. *)
#     LCP := UPRCPTR ;            (* TO INITIALIZE LCP IN CASE ! *)
      IF SY = IDENT THEN
        BEGIN SEARCHSECTION(DISPLAY[TOP].FNAME,LCP); (*DECIDE WHETHER FORW.*)
          IF LCP <> NIL THEN
          BEGIN
            IF LCP@.KLASS = PROC THEN
              FORW := LCP@.FWDECL AND(FSY = PROCSY)AND(LCP@.PFKIND = ACTUAL)
            ELSE
              IF LCP@.KLASS = FUNC THEN
                FORW:=LCP@.FWDECL AND(FSY=FUNCSY)AND(LCP@.PFKIND=ACTUAL)
              ELSE FORW := FALSE;
            IF NOT FORW THEN ERROR(160)
          END
          ELSE FORW := FALSE;
          IF NOT FORW THEN
            BEGIN
              IF FSY = PROCSY THEN NEW(LCP,PROC,DECLARED,ACTUAL)
              ELSE NEW(LCP,FUNC,DECLARED,ACTUAL);
              WITH LCP@ DO
#               BEGIN NAME := ID; IDTYPE := NIL;  SAVEFP := FALSE ;
#               " EXTRN := FALSE;" PFLEV := LEVEL; PROCLAB := PROCLAB+1 ;
#                 PFDECKIND := DECLARED; PFKIND := ACTUAL; PFNAME := PROCLAB ;
                  IF FSY = PROCSY THEN KLASS := PROC
                  ELSE KLASS := FUNC
                END;
              ENTERID(LCP)
            END
          ELSE
            BEGIN LCP1 := LCP@.NEXT;
              WHILE LCP1 <> NIL DO
                BEGIN
                  WITH LCP1@ DO
                    IF KLASS = VARS THEN
                      IF IDTYPE <> NIL THEN
                        BEGIN
#                       IF VKIND = FORMAL THEN LCM := LCM+PTRSIZE
                        ELSE LCM := VADDR + IDTYPE@.SIZE;
                        IF LCM > LC THEN LC := LCM
                        END;
                  LCP1 := LCP1@.NEXT
                END
              END;
          INSYMBOL
        END
      ELSE ERROR(2);
#     OLDLEV := LEVEL; OLDTOP := TOP;  OLDLABEL := INTLABEL ;  INTLABEL := 0 ;
      IF LEVEL < MAXLEVEL THEN LEVEL := LEVEL + 1 ELSE ERROR(251);
      IF TOP < DISPLIMIT THEN
        BEGIN TOP := TOP + 1;
          WITH DISPLAY[TOP] DO
            BEGIN
              IF FORW THEN FNAME := LCP@.NEXT
              ELSE FNAME := NIL;
              FLABEL := NIL;
              OCCUR := BLCK
            END
        END
      ELSE ERROR(250);
      IF FSY = PROCSY THEN
        BEGIN PARAMETERLIST([SEMICOLON],LCP1);
          IF NOT FORW THEN LCP@.NEXT := LCP1
        END
      ELSE
        BEGIN PARAMETERLIST([SEMICOLON,COLON],LCP1);
          IF NOT FORW THEN LCP@.NEXT := LCP1;
          IF SY = COLON THEN
            BEGIN INSYMBOL;
              IF SY = IDENT THEN
                BEGIN IF FORW THEN ERROR(122);
                  SEARCHID([TYPES],LCP1);
                  LSP := LCP1@.IDTYPE;
                  LCP@.IDTYPE := LSP;
                  IF LSP <> NIL THEN
#                   BEGIN
#                   IF NOT (LSP@.FORM IN [SCALAR,SUBRANGE,POINTER,POWER]) THEN
#                     BEGIN  ERROR(120);  LCP@.IDTYPE := NIL END;
#                   IF LSP = REALPTR THEN
#                     IF SAVEFPRS THEN
#                       BEGIN  LCP1 := LCP@.NEXT ;
#                       WHILE LCP1 <> NIL DO
#                         BEGIN
#                         LCP1@.VADDR := LCP1@.VADDR+FPSAVEAREA ;
#                         LCP1 := LCP1@.NEXT ;
#                         END ;
#                       LCP@.SAVEFP := TRUE ;    (* SET SAVE FPRS FLAG *)
#                       LC := LC+FPSAVEAREA ;    (* ADJUST LOC. CNTR *)
#                       END ;
#                   END (* WITH LSP@ DO *) ;
                  INSYMBOL
                END
              ELSE BEGIN ERROR(2); SKIP(FSYS + [SEMICOLON]) END
            END
          ELSE
            IF NOT FORW THEN ERROR(123)
        END;

#     WITH LCP@ DO
#       BEGIN FWDECL := FALSE ;  FRTRN := FALSE ; EXTRN := FALSE  END ;
"S1" "                                                                         "
"S1" "IF NOT FORW THEN                                                         "
"S1" "   WITH LCP@ DO                                                          "
"S1" "     BEGIN  FPRMSZE := FPRM1 ; RPRMSZE := RPRM1 ; SPRMSZE := SPRM1  END; "
"S1" "                                                                         "
      IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
#     IF SY IN  [FORWARDSY,FRTRNSY,EXTRNSY]  THEN
#       BEGIN
#       IF SY = FORWARDSY THEN
#           IF FORW THEN ERROR(161)
#           ELSE LCP@.FWDECL := TRUE;
#         IF SY = FRTRNSY THEN  LCP@.FRTRN := TRUE ;
#         " BEGIN  LCP@.FRTRN := TRUE ;
#           LCP1 := LCP@.NEXT ;
#           WHILE LCP1 <> NIL DO
#             BEGIN  IF LCP1@.VKIND <> FORMAL THEN  ERROR(7) ;
#             LCP1 := LCP1@.NEXT ;
#             END ;
#           END (* SY = FRTRNSY *) ;  "
#         IF SY = EXTRNSY THEN LCP@.EXTRN := TRUE ;
          INSYMBOL;
          IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
          IF NOT (SY IN FSYS) THEN  BEGIN ERROR(6); SKIP(FSYS) END
        END
      ELSE
        BEGIN " LCP@.FWDECL := FALSE; "
"E"       IF DEBUG THEN  PRNTSYMBL(LCP);
          MARK(MARKP); (* MARK HEAP FOR BLOCK ENTRY *)
          REPEAT BLOCK(FSYS,SEMICOLON,LCP);
            IF SY = SEMICOLON THEN
              BEGIN "IF PRTABLES THEN PRINTTABLES(FALSE);" INSYMBOL;
                IF NOT (SY IN [BEGINSY,PROCSY,FUNCSY]) THEN
                  BEGIN ERROR(6); SKIP(FSYS) END
              END
            ELSE ERROR(14)
          UNTIL SY IN [BEGINSY,PROCSY,FUNCSY];
          RELEASE(MARKP); (* RETURN LOCAL ENTRIES ON RUNTIME HEAP *)
        END;
      LEVEL := OLDLEV; TOP := OLDTOP; LC := LLC; INTLABEL := OLDLABEL ;
    END (*PROCDECLARATION*) ;

#
#     FUNCTION PROCTYPE(FPROCP: CTP): INTEGER ;
#
#     BEGIN   PROCTYPE := ORD('P') ;
#       IF FPROCP <> NIL THEN
#         WITH FPROCP@ DO
#           BEGIN  IF FRTRN THEN  PROCTYPE := ORD('F') ;
#           IF FPROCP@.IDTYPE <> NIL THEN
#           WITH FPROCP@ DO
#             BEGIN
#             IF IDTYPE@.FORM = POWER THEN  PROCTYPE := ORD('S')
#             ELSE  IF IDTYPE = REALPTR THEN
#                     IF FRTRN THEN PROCTYPE := ORD('Z')
#                     ELSE PROCTYPE := ORD('R')
#               ELSE IF IDTYPE = BOOLPTR THEN
#                      IF FRTRN THEN PROCTYPE := ORD('X')
#                      ELSE PROCTYPE := ORD('B')
#                 ELSE IF IDTYPE@.FORM = POINTER THEN
#                   PROCTYPE := ORD('A')
#                   ELSE IF "(IDTYPE = CHARPTR) OR ((IDTYPE@.FORM = SUBRANGE)
#                           AND (IDTYPE@.RANGETYPE = CHARPTR)) "
#                           IDTYPE@.SIZE = 1 THEN PROCTYPE := ORD('C')
#                      ELSE  IF FRTRN THEN PROCTYPE := ORD('Y')
#                            ELSE PROCTYPE := ORD('I') ;
#            END
#          END (*WITH FPROCP@*) ;
#     END (*PROCTYPE*) ;
#
    PROCEDURE BODY(FSYS: SETOFSYS);
#     CONST   CIXMAX = 400;
      TYPE OPRANGE = 0..OPMAX;
#
#         CALLED_PROC = RECORD
#                         NAME : ALPHA ;
#                         LVL  : LEVRANGE ;
#                         CNT  : 1..100 ;
#                         NXT  : @ CALLED_PROC
#                       END ;
#
#   VAR
#         CALL_HEAD, T2_CLIST, T_CLIST  : @ CALLED_PROC ;
#         LOCAL_CALL,                   (* THIS PROC CALLS A LOCAL PROC *)
#        "MOD_TRACE,"                   (* TRACE VARS BEING MODIFIED *)
#         MODIFYING : BOOLEAN ;         (* A PROGRAM VAR BEING MODIFIED*)
#         VAR_REF, VAR_MOD : INTEGER ;  (* # OF VARIABLES ACCESSED/REFERENCED*)
#

          LLCP:CTP;
#         CNSTPTR:  CSP;
          (*ALLOWS REFERENCING OF NONINTEGER CONSTANTS BY AN INDEX
           (INSTEAD OF A POINTER), WHICH CAN BE STORED IN THE P2-FIELD
           OF THE INSTRUCTION RECORD UNTIL WRITEOUT.
#          --> PROCEDURE LOAD, PROCEDURE WRITEOUT*)  (*NOT NEEDED IN P_COMP.*)
          I, ENTNAME : INTEGER;
          LCMAX,LLC1: ADDRRANGE; LCP: CTP;
#         LLP: LBP;  PROCNAME : ALPHA ;
"CT"      FIRSTLN : INTEGER;  CTRNO : CTRRANGE;

      PROCEDURE PUTIC;
#     BEGIN
      (*IF (IC MOD 10 = 0) THEN WRITELN(PRR,' LOC ',IC:1);*)
      IF LINECNT > OLDLN THEN
        BEGIN  WRITELN(PRR, ' LOC ',LINECNT:1);  OLDLN := LINECNT  END ;
      END;


#    "FUNCTION FLDW(NUM : INTEGER) : INTEGER ;
#       VAR FW: 0..20 ;
#     BEGIN
#       FW := 0 ;  IF NUM < 0 THEN FW := 1 ;
#       NUM := ABS(NUM) ;
#       REPEAT
#         NUM := NUM DIV 10 ;  FW := FW+1 ;
#       UNTIL NUM = 0 ;
#       FLDW := FW
#     END (*FLDW*);"
#
#     FUNCTION GETTYPE(OPERAND: STP): INTEGER ;
#       BEGIN   GETTYPE := ORD('I') ;  (* ASSUME INTEGER TYPE *)
#         IF OPERAND = NIL THEN  BEGIN IF ERRORCNT = 0 THEN ERROR(401) END
#         ELSE
#           IF OPERAND@.FORM > POWER THEN GETTYPE := ORD('A')
#           ELSE
#             IF OPERAND@.FORM = POWER THEN GETTYPE := ORD('S')
#             ELSE
#               IF OPERAND@.FORM = POINTER THEN GETTYPE := ORD('A')
#               ELSE
#                   IF OPERAND = REALPTR THEN GETTYPE := ORD('R')
#                   ELSE
#                     IF OPERAND = BOOLPTR THEN GETTYPE := ORD('B')
#                     ELSE
#                       BEGIN
#                       IF OPERAND@.SIZE = CHARSIZE THEN GETTYPE := ORD('C')
#                       END
#       END (*GETTYPE*) ;
#
      PROCEDURE GEN0(FOP: OPRANGE);
      BEGIN
        IF PRCODE THEN BEGIN PUTIC; WRITELN(PRR,MN[FOP]:4) END;
        IC := IC + 1
      END (*GEN0*) ;

      PROCEDURE GEN1(FOP: OPRANGE; FP2: INTEGER);
        VAR K: INTEGER;
      BEGIN
        IF PRCODE THEN
          BEGIN PUTIC; WRITE(PRR,MN[FOP]:4);
            IF FOP = 30 THEN  (*CSP*)  WRITELN(PRR,SNA[FP2]:4)
            ELSE IF FOP = 37 THEN  (*LCA*)
#                  BEGIN WRITE(PRR,' ''');
#                    WITH CNSTPTR@  DO
#                      BEGIN
#                      FOR K := 1 TO SLNGTH DO
#                        BEGIN  WRITE(PRR,SVAL[K]:1);
#                        IF SVAL[K] = '''' THEN WRITE(PRR,'''')
#                        END ;
#                      STIC := STIC+SLNGTH ;
#                      END ;
#                    WRITELN(PRR,'''')
                   END
                 ELSE IF (FOP = 26) OR (FOP = 42)
"S1" "                   OR (FOP = 64)   (*PRM*)                               "
                         THEN  (*STO,RET*)
                        WRITELN(PRR,CHR(FP2):2)
                      ELSE WRITELN(PRR, ' ', FP2:1)
          END;
        IC := IC + 1
      END (*GEN1*) ;

      PROCEDURE GEN2(FOP: OPRANGE; FP1,FP2: INTEGER);
#       VAR I, J, K : INTEGER;
      BEGIN
        IF PRCODE THEN
          BEGIN PUTIC; WRITE(PRR,MN[FOP]:4,' ');
            CASE FOP OF
              22,23,35,39,43: (*DEC,INC,IND,LDO,SRO*)
                WRITELN(PRR,CHR(FP1),',',FP2:1"FLDW(FP2)") ;
              45,50: (*CHK,LDA*)
                WRITELN(PRR,FP1:1"FLDW(FP1)",',',FP2:1"FLDW(FP2)");
              47,48,49,52,53,55: (*EQU..NEQ*)
                BEGIN WRITE(PRR,CHR(FP1));
                  IF FP1 = ORD('M') THEN WRITE(PRR,',',FP2:1"FLDW(FP2)");
                  WRITELN(PRR)
                END;
              51: (*LDC*)
                CASE FP1 OF
#                 0: WRITELN(PRR,'C,''',CHR(FP2):1,'''') ;
                  1: WRITELN(PRR,'I,',FP2:1"FLDW(FP2)");
                  2: BEGIN WRITE(PRR,'R,');
#                      WITH CNSTPTR@  DO
                         FOR K := 1 TO REALLNGTH DO
                           IF RVAL[K] <> ' ' THEN WRITE(PRR,RVAL[K]);
                       WRITELN(PRR)
                     END;
                  3: WRITELN(PRR,'B,',FP2:1);
                  4: WRITELN(PRR,'N');
                  5: BEGIN WRITE(PRR,'S,(');

#                      WITH CNSTPTR@ DO
#                        FOR I := 0 TO 3 DO
#                          BEGIN  J := 0 ;  K := SETMAX  -I*16 ;
#                          FOR K := K DOWNTO K-15 DO
#                            BEGIN  J := J*2 ;
#                            IF K IN PVAL THEN J := J+1 ;
#                            END ;
#                          IF I > 0 THEN  WRITE(PRR,',') ;
#                          WRITE(PRR, J: 1"FLDW(J)") ;
#                          END (* FOR I := 0 TO 3 *) ;
#                      WRITELN(PRR,')') ;
                     END
                END
            END;
          END;
          IC := IC + 1
      END (*GEN2*) ;

#     PROCEDURE GEN3(FOP: OPRANGE; FP0,FP1,FP2: INTEGER);
#     BEGIN
#       IF PRCODE THEN
#         BEGIN PUTIC; WRITE(PRR,MN[FOP]:4);
"S1" "          IF FOP = 41 THEN  (*MST*)                                      "
"S1" "             WRITE(PRR, FP0:2)                                           "
"S1" "          ELSE                                                           "
#                  WRITE(PRR, CHR(FP0):2) ;
#               WRITELN(PRR, ',', FP1:1"FLDW(FP1)", ',', FP2:1"FLDW(FP2)") ;
#         END;
#         IC := IC + 1
#     END (*GEN3*) ;

      PROCEDURE LOAD;
      BEGIN
        WITH GATTR DO
          IF TYPTR <> NIL THEN
            BEGIN
              CASE KIND OF
                CST:   IF (TYPTR@.FORM = SCALAR) AND (TYPTR <> REALPTR) THEN
                         IF TYPTR = BOOLPTR THEN GEN2(51(*LDC*),3,CVAL.IVAL)
                         ELSE
                          IF TYPTR = CHARPTR THEN GEN2(51(*LDC*),0,CVAL.IVAL)
                           ELSE GEN2(51(*LDC*),1,CVAL.IVAL)  (*INTEGER*)
                       ELSE
                         IF TYPTR = NILPTR THEN GEN2(51(*LDC*),4,0)
                         ELSE
#                            BEGIN
#                              CNSTPTR  := CVAL.VALP;
                               IF TYPTR = REALPTR THEN
#                                GEN2(51(*LDC*),2,0)
                               ELSE
#                                 GEN2(51(*LDC*),5,0)
                             END;
                VARBL: CASE ACCESS OF
                         DRCT: " IF VLEVEL <= 1 THEN
                                    GEN2(39(*LDO*),GETTYPE(BTYPE),DPLMT)
#                                ELSE " GEN3(54(*LOD*),GETTYPE(BTYPE),
                                         " LEVEL-" VLEVEL,DPLMT);
                         INDRCT: GEN2(35(*IND*),GETTYPE(BTYPE),IDPLMT);
                         INXD:   ERROR(400)
                       END;
                EXPR:
              END;
#             IF KIND = VARBL THEN VAR_REF := VAR_REF+1 ;
              KIND := EXPR
            END
      END (*LOAD*) ;

      PROCEDURE STORE(VAR FATTR: ATTR);
      BEGIN
        WITH FATTR DO
          IF TYPTR <> NIL THEN
            CASE ACCESS OF
#             DRCT:   GEN3(56(*STR*),GETTYPE(BTYPE),VLEVEL,DPLMT);
              INDRCT: IF IDPLMT <> 0 THEN ERROR(400)
                      ELSE GEN1(26(*STO*),GETTYPE(BTYPE));
              INXD:   ERROR(400)
            END
      END (*STORE*) ;

      PROCEDURE LOADADDRESS;
      BEGIN
        WITH GATTR DO
          IF TYPTR <> NIL THEN
            BEGIN
              CASE KIND OF
                CST:   IF STRING(TYPTR) THEN
#                        BEGIN
#                        CNSTPTR := CVAL.VALP ;  GEN1(37(*LCA*),0) ;
#                        END
                       ELSE ERROR(400);
                VARBL: CASE ACCESS OF
#                        DRCT:   GEN2(50(*LDA*),VLEVEL,DPLMT);
                         INDRCT: IF IDPLMT <> 0 THEN
                                    GEN2(23(*INC*),ORD('A'),IDPLMT);
                         INXD:   ERROR(400)
                       END;
                EXPR:  ERROR(400)
              END;
              KIND := VARBL; ACCESS := INDRCT; IDPLMT := 0
            END
      END (*LOADADDRESS*) ;


      PROCEDURE GENFJP(FADDR: INTEGER);
      BEGIN LOAD;
        IF GATTR.TYPTR <> NIL THEN
          IF GATTR.TYPTR <> BOOLPTR THEN ERROR(144);
        IF PRCODE THEN BEGIN PUTIC;
#         WRITELN(PRR,MN[33]:4,' L',FADDR:1"FLDW(FADDR)") END;
        IC := IC + 1
      END (*GENFJP*) ;

      PROCEDURE GENUJPFJP(FOP: OPRANGE; FP2: INTEGER);
      BEGIN
        IF PRCODE THEN
#         BEGIN PUTIC; WRITELN(PRR, MN[FOP]:4, ' L',FP2:1"FLDW(FP2)") END ;
        IC := IC + 1
      END (*GENUJPFJP*);


#     PROCEDURE GENCUPENT(FOP: OPRANGE;FP0,FP1,FP2: INTEGER;PROCNAME: ALPHA);
#       VAR TEMPNAME : ALPHA ;
#
#       PROCEDURE MKNAME(VAR ALB: ALPHA; NLB: INTEGER ) ;
#         VAR I, J: INTEGER ;
#
#       BEGIN
#         I := 1 ;   J := 8 ;
#         IF NOT NAMFLAG THEN J := 5 ;
#           REPEAT
#           IF ALB[I] = '_' THEN  ALB[I] := '$' ;  I := I+1  ;
#           UNTIL (I > J) OR (ALB[I] = ' ') ;
#         IF NOT NAMFLAG THEN
#           FOR J := 8 DOWNTO I DO
#             BEGIN
#             ALB[J] := CHR( ORD('0')+ NLB MOD 10 ) ;
#             NLB := NLB DIV 10 ;
#             END ;
#       END (*MKNAME*) ;
#
#     BEGIN (*GENCUPENT*)
#       IF PRCODE THEN
#         BEGIN  PUTIC ;  TEMPNAME := PROCNAME ;  (*TO PRESERVE FULL NAME*)
#           IF FOP = 46 THEN (*CUP*)
#             BEGIN    MKNAME(TEMPNAME,FP2) ;
#               WRITELN(PRR,MN[46],CHR(FP0):2,',',FP1:1"FLDW(FP1)",',',
#                           TEMPNAME:8);
#             END
#           ELSE  (*ENT*)
#             BEGIN
#             IF OLDIC = 0 THEN  WRITELN(PRR,' BGN ', ASSEMBLE:1, ',',
#                                         GET_STAT:1, ',', ASMVERB:1, ',',
#                                         PROGNAME, ' ', TIME:9, DATE) ;
#             IF FPROCP <> NIL THEN  MKNAME(TEMPNAME,FP2) ;
#             WRITELN(PRR, TEMPNAME:8, MN[32], CHR(FP0):2, ',',
#                          LEVEL:1"FLDW(LEVEL)",',L', FP1:1"FLDW(FP1)",
#                          PROCNAME:14, ',', SAVEREGS:1, ',', SAVEFPRS:1, ',',
                           DEBUG:1, ',', FP2:1) ;
#             END ;
#         END ;
#       IC := IC + 1
#     END (*GENCUPENT*);

      PROCEDURE GENDEF(L1, L2: ADDRRANGE ) ;
        BEGIN
        IF PRCODE THEN  WRITELN(PRR,'L', L1:1"FLDW(L1)", MN[63(*DEF*)], L2:10);
        END (*GENDEF*) ;


#     PROCEDURE CHKBNDS(FSP: STP);
#       VAR LMIN,LMAX: INTEGER;
#     BEGIN
#       IF FSP <> NIL THEN
#         IF FSP <> BOOLPTR THEN
#           IF FSP <> INTPTR THEN
#             IF FSP <> REALPTR THEN
#               IF FSP@.FORM <= POINTER THEN
#                 BEGIN
#                   IF FSP@.FORM = POINTER (*LMAX <= LMIN*) THEN
#                     BEGIN  FLIPDEBUG := TRUE;
#                     IF ASSIGN THEN  GEN3(45(*CHK*),ORD('A'),-1,0)
#                     ELSE (* ACCESS *)  GEN3(45(*CHK*),ORD('A'),0,0)
#                     END
#                   ELSE
#                     BEGIN
#                     GETBOUNDS(FSP,LMIN,LMAX);
#                     GEN3(45(*CHK*),ORD('I'),LMIN,LMAX) ;
#                     END ;
#                 END
#     END (*CHKBNDS*);

      PROCEDURE PUTLABEL(LABNAME: INTEGER);
      BEGIN IF PRCODE THEN WRITELN(PRR, 'L', LABNAME:1"FLDW(LABNAME)", ' LAB')
      END (*PUTLABEL*);
"CT"
"CT"
"CT"   FUNCTION CTRGEN : CTRRANGE;
"CT"
"CT"   BEGIN   (* CREATE A UNIQUE STATEMENT COUNTER AND EMIT P-CODE TO INCREME
"CT"            IT *)
"CT"     (* R. L. SITES  3 AUG 77 *)
"CT"     CTRGEN := CTRCNT;
"CT"     IF CTROPTION THEN
"CT"             BEGIN
"CT"             GEN1(39(*CTI*), CTRCNT);
"CT"             CTRCNT := CTRCNT+1;
"CT"             END;
"CT"   END; (* CTRGEN *)
"CT"
"CT"   PROCEDURE CTREMIT(CTRT:CTRTYPE; CTRNO:CTRRANGE; FLN, MLN, LLN:INTEGER) ;
"CT"
"CT"
"CT"     BEGIN   (* WRITE AN ENTRY DESCRIBING A STATEMENT COUNTER. *)
"CT"     (* R. L. SITES  3 AUG 77 *)
"CT"     IF CTROPTION THEN
"CT"       BEGIN   (* IF FIRSTCTR THEN
"CT"                      BEGIN   WRITELN(CTRTBL , COMPDATE); WRITELN(
"CT"                      COMPTIME);
"CT"                      FIRSTCTR := FALSE END;
"CT"                  WRITELN(CTRLBL, (((ORD(CTRT)*CTRMAX+CTRNO)*MAXLN+FLN)
"CT"                           *MAXLN+MLN)*MAXLN+LLN:20);  *)
"CT"       WRITELN(QRR, '#CTR    ', ORD(CTRT):4, CTRNO:6, FLN:7, MLN:7, LLN:7 );
"CT"       END
"CT"   END; (* CTREMIT *)
"CT"
      PROCEDURE STATEMENT(FSYS: SETOFSYS);
        LABEL 1;
        VAR LCP: CTP; LLP: LBP; TTOP : DISPRANGE ;
"CT"        CTRNO : CTRRANGE;

        PROCEDURE EXPRESSION(FSYS: SETOFSYS); FORWARD;

        PROCEDURE SELECTOR(FSYS: SETOFSYS; FCP: CTP);
          VAR LATTR: ATTR; LCP: CTP; LMIN,LMAX: INTEGER;
(*+RM     INDEXING : BOOLEAN ;                                               +*)
        BEGIN
(*+RM     INDEXING := FALSE ;                                                +*)
          WITH FCP@, GATTR DO
            BEGIN TYPTR := IDTYPE; KIND := VARBL;
(*+RM                                                                        +*)
(*+RM       IF GET_STAT THEN                                                 +*)
(*+RM         BEGIN                                                          +*)
(*+RM         IF MODIFYING THEN  WRITE(QRR,' #MOD')                          +*)
(*+RM         ELSE WRITE(QRR,' #REF') ;                                      +*)
(*+RM         WRITE(QRR, CHR(GETTYPE("BTYPE" TYPTR)), ' ':2 );               +*)
(*+RM         END (*GET_STAT*) ;                                             +*)
(*+RM                                                                        +*)
              CASE KLASS OF
                VARS:
                  IF VKIND = ACTUAL THEN
                    BEGIN ACCESS := DRCT; VLEVEL := VLEV;
                      DPLMT := VADDR
                    END
                  ELSE
                    BEGIN
(*+RM               IF GET_STAT THEN  WRITE(QRR,' #IND',VLEV:3,VADDR:8);     +*)
#                     GEN3(54(*LOD*),ORD('A'),VLEV,VADDR);
                      ACCESS := INDRCT; IDPLMT := 0
                    END;
                FIELD:
                  WITH DISPLAY[DISX] DO
                    IF OCCUR = CREC THEN
                      BEGIN ACCESS := DRCT; VLEVEL := CLEV;
                        DPLMT := CDSPL + FLDADDR
                      END
                    ELSE
                      BEGIN
                        GEN3(54(*LOD*),ORD('A'), LEVEL,VDSPL)  ;
(*+RM                   IF GET_STAT THEN  WRITE(QRR,' #IND',LEVEL:3,VDSPL:8);+*)
                        ACCESS := INDRCT; IDPLMT := FLDADDR
                      END;
                FUNC:
                  IF PFDECKIND = STANDARD THEN ERROR(150)
                  ELSE
                    IF PFLEV = 0 THEN ERROR(150)   (*EXTERNAL FCT*)
                    ELSE
                      IF PFKIND = FORMAL THEN ERROR(151)
                      ELSE
#                       IF (FPROCP <> FCP) THEN  ERROR(177)
#                       ELSE
                          BEGIN ACCESS := DRCT; VLEVEL := PFLEV + 1;
                            DPLMT := FNCRSLT ;  (*RELAT. ADDR. OF FCT. RESULT*)
(*+RM           (*          IF MODIFYING THEN                                +*)
(*+RM                         WRITE(QRR,'  DIR',VLEVEL:3, DPLMT:7) ; *)      +*)
                          END
              END (*CASE*) ;
#             GATTR.BTYPE := GATTR.TYPTR ;
            END (*WITH*);
          IF NOT (SY IN SELECTSYS + FSYS) THEN
            BEGIN ERROR(59); SKIP(SELECTSYS + FSYS) END;
          WHILE SY IN SELECTSYS DO
            BEGIN
        (*[*)   IF SY = LBRACK THEN
                BEGIN
(*+RM                                                                        +*)
(*+RM            IF GET_STAT THEN                                            +*)
(*+RM              WITH GATTR DO                                             +*)
(*+RM                BEGIN                                                   +*)
(*+RM                IF ACCESS = DRCT THEN                                   +*)
(*+RM                  WRITE(QRR, ' #DIR',VLEVEL:3,DPLMT:8)                  +*)
(*+RM                ELSE IF (ACCESS = INDRCT) AND (IDPLMT <> 0) THEN        +*)
(*+RM                       WRITE(QRR,' #DPM   ', IDPLMT:8) ;                +*)
(*+RM                WRITE(QRR,' #INX   ') ;                                 +*)
(*+RM                IF MODIFYING THEN                                       +*)
(*+RM                   BEGIN  INDEXING := TRUE ;  MODIFYING := FALSE END ;  +*)
(*+RM                END ;                                                   +*)
(*+RM                                                                        +*)
                  REPEAT LATTR := GATTR;
                    WITH LATTR DO
                      IF TYPTR <> NIL THEN
                        IF TYPTR@.FORM <> ARRAYS THEN
                          BEGIN ERROR(138); TYPTR := NIL END;
                    LOADADDRESS;
                    INSYMBOL; EXPRESSION(FSYS + [COMMA,RBRACK]);
                    LOAD;
                    IF GATTR.TYPTR <> NIL THEN
                      IF GATTR.TYPTR@.FORM <> SCALAR THEN ERROR(113);
                    IF LATTR.TYPTR <> NIL THEN
                      WITH LATTR.TYPTR@ DO
                        BEGIN
                          IF COMPTYPES(INXTYPE,GATTR.TYPTR) THEN
                            BEGIN
                              IF INXTYPE <> NIL THEN
                                BEGIN GETBOUNDS(INXTYPE,LMIN,LMAX);
#                                 IF DEBUG THEN
#                                   GEN3(45(*CHK*),ORD('J'),LMIN,LMAX) ;
#                                 IF LMIN > 0 THEN
#                                   GEN2(22(*DEC*),GETTYPE(GATTR.BTYPE),LMIN)
#                                 ELSE IF LMIN < 0 THEN
                                     GEN2(23(*INC*),GETTYPE(GATTR.BTYPE),-LMIN)
#                                 (*OR SIMPLY GEN1(31,LMIN)*)
                                END
                            END
                          ELSE ERROR(139);
                          WITH GATTR DO
                            BEGIN TYPTR := AELTYPE; KIND := VARBL;
                              ACCESS := INDRCT; IDPLMT := 0 ;
                              IF GATTR.TYPTR <> NIL THEN
#                               BEGIN  LMIN := TYPTR@.SIZE ;
#                               ALIGN(LMIN,TYPTR@.ALN) ;
#                               GEN1(36(*IXA*),LMIN)
#                               END (*TYPTR <> NIL*) ;
                            END (*WITH GATTR DO*) ;
                        END
                  UNTIL SY <> COMMA;
                  IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12) ;
(*+RM             IF INDEXING THEN                                           +*)
(*+RM                BEGIN  MODIFYING := TRUE ;  INDEXING := FALSE END ;     +*)
                END (*IF SY = LBRACK*)
              ELSE
        (*.*)     IF SY = PERIOD THEN
                  BEGIN
                    WITH GATTR DO
                      BEGIN
                        IF TYPTR <> NIL THEN
                          IF TYPTR@.FORM <> RECORDS THEN
                            BEGIN ERROR(140); TYPTR := NIL END;
                        INSYMBOL;
                        IF SY = IDENT THEN
                          BEGIN
                            IF TYPTR <> NIL THEN
                              BEGIN SEARCHSECTION(TYPTR@.FSTFLD,LCP);
                                IF LCP = NIL THEN
                                  BEGIN ERROR(152); TYPTR := NIL END
                                ELSE
                                  WITH LCP@ DO
                                    BEGIN TYPTR := IDTYPE;
                                      CASE ACCESS OF
                                        DRCT:   DPLMT := DPLMT + FLDADDR;
                                        INDRCT: IDPLMT := IDPLMT + FLDADDR;
                                        INXD:   ERROR(400)
                                      END
                                    END
                              END;
                            INSYMBOL
                          END (*SY = IDENT*)
                        ELSE ERROR(2)
                      END (*WITH GATTR*)
                  END (*IF SY = PERIOD*)
                ELSE
        (*@*)       BEGIN
                    IF GATTR.TYPTR <> NIL THEN
                      WITH GATTR,TYPTR@ DO
                        IF FORM = POINTER THEN
#                         BEGIN
(*+RM                     IF GET_STAT THEN                                   +*)
(*+RM                       IF ACCESS = DRCT THEN                            +*)
(*+RM                         WRITE(QRR,' #PTR',VLEVEL:3,DPLMT:8)            +*)
(*+RM                       ELSE  (*ACCESS = INDRCT *)                       +*)
(*+RM                         WRITE(QRR,' #DPM   ',"LEVEL:3,"IDPLMT:8) ;     +*)
#                         LOAD ;
#                         IF DEBUG THEN  CHKBNDS(GATTR.TYPTR) ;
#                         TYPTR := ELTYPE ;
                            WITH GATTR DO
                              BEGIN KIND := VARBL; ACCESS := INDRCT;
                                IDPLMT := 0
                              END
                          END
                        ELSE
                          IF FORM = FILES THEN TYPTR := FILTYPE
                          ELSE ERROR(141);
                    INSYMBOL
                  END;
              IF NOT (SY IN FSYS + SELECTSYS) THEN
                BEGIN ERROR(6); SKIP(FSYS + SELECTSYS) END ;
#             GATTR.BTYPE := GATTR.TYPTR ;
            END (*WHILE*) ;
(*+RM                                                                        +*)
(*+RM     IF GET_STAT THEN                                                   +*)
(*+RM       WITH GATTR DO                                                    +*)
(*+RM         BEGIN                                                          +*)
(*+RM         IF ACCESS = DRCT THEN                                          +*)
(*+RM           WRITE(QRR,' #DIR', VLEVEL:3,DPLMT:8)                         +*)
(*+RM         ELSE IF (ACCESS = INDRCT) AND (IDPLMT <> 0) THEN               +*)
(*+RM           WRITE(QRR, ' #DPM   ',IDPLMT:8) ;                            +*)
(*+RM         IF MODIFYING THEN  WRITE(QRR, ' #MND   ')                      +*)
(*+RM         ELSE  WRITE(QRR,' #RND   ') ;                                  +*)
(*+RM         END ;                                                          +*)
(*+RM                                                                        +*)
        END (*SELECTOR*) ;

        PROCEDURE CALL(FSYS: SETOFSYS; FCP: CTP);
#         VAR LKEY: 0..NSPROC;  MATCHPAR: BOOLEAN ;

          PROCEDURE VARIABLE(FSYS: SETOFSYS);
            VAR LCP: CTP;
          BEGIN
            IF SY = IDENT THEN
              BEGIN SEARCHID([VARS,FIELD],LCP); INSYMBOL END
            ELSE BEGIN ERROR(2); LCP := UVARPTR END;
            SELECTOR(FSYS,LCP)
          END (*VARIABLE*) ;


#       PROCEDURE  RWSETUP(DFILE: ALPHA) ;
#       (* TO SET UP FILE ADDRESS PARAMETER FOR READ/WRITE *)
#
#         VAR  LCP : CTP ;  SAVED : BOOLEAN ; TEMPID : ALPHA ; TEMPSY : SYMBOL ;
#
#         BEGIN  SAVED := TRUE ;
#
#         IF SY = IDENT THEN
#           BEGIN  SEARCHID([VARS,FIELD,FUNC,KONST],LCP) ;
#           IF LCP@.IDTYPE <> NIL THEN
#             WITH LCP@.IDTYPE@ DO
#               IF FORM = FILES THEN
#                 IF FILTYPE = CHARPTR THEN SAVED := FALSE
#                 ELSE  ERROR(398) ;
#           END (* SY = IDENT *) ;
#
#         IF SAVED THEN (* USE IMPLIED FILE NAME *)
#           BEGIN   TEMPSY := SY ;  TEMPID := ID ;  SY := COMMA ;  ID := DFILE ;
#           SEARCHID([VARS],LCP) ;
#           END (* IF SAVED *)
#         ELSE  INSYMBOL ;
#
#         SELECTOR(FSYS+[COMMA,RPARENT],LCP) ;
#         IF GATTR.TYPTR <> TEXTPTR THEN  ERROR(116) ;
#         LOADADDRESS ; (* GET FILE ADR *)
#         GEN1(30(*CSP*),31(*SIO*)) ;
#         IF SAVED THEN  BEGIN  ID := TEMPID ;  SY := TEMPSY  END ;
#         END (*RWSETUP*) ;
#

          PROCEDURE GETPUTRESETREWRITE;

          BEGIN "VARIABLE(FSYS + [RPARENT]); LOADADDRESS;"
#         IF ODD(LKEY) (*GET, RESET*)  THEN  RWSETUP(NA[39] (*INPUT*))
#         ELSE (*PUT, REWRITE, PAGE*)  RWSETUP(NA[40] (*OUTPUT*) ) ;
#          "IF EBCDFLG THEN
#             IF LKEY > 2 THEN  (*RESET , REWRITE*)
#               BEGIN  GEN2(23(*INC*),ORD('A'),1000) ; EBCDFLG := FALSE  END ; "
"           IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM <> FILES THEN ERROR(116);
#             GEN1(30(*CSP*),31(*SIO*)) ;  "
#             GEN1(30(*CSP*),LKEY(*GET,PUT,RES,REW,PAG*)) ;
#             GEN1(30(*CSP*),32(*EIO*)) ;
          END (*GETPUTRESETREWRITE*) ;

          PROCEDURE READ1;

#         BEGIN (*ASSUME 'INPUT' FILE*)
#           RWSETUP(NA[39] (*'INPUT     '*));
            IF SY = COMMA THEN  INSYMBOL ;
#           IF LKEY = 5 (*READ*) THEN  IF SY <> IDENT THEN ERROR(2) ;
            IF SY = IDENT THEN
              REPEAT
(*+RM         MODIFYING := TRUE ;                                            +*)
              VARIABLE(FSYS + [COMMA,RPARENT]) ;
(*+RM         MODIFYING := FALSE ;                                           +*)
              LOADADDRESS ;
                IF GATTR.TYPTR <> NIL THEN
#                 IF STRING(GATTR.TYPTR) THEN
#                   BEGIN
#                   GEN2(51(*LDC*),1,GATTR.TYPTR@.SIZE DIV CHARSIZE) ;
#                   GEN1(30(*CSP*),27(*RDS*))
#                   END
#                 ELSE
#                   BEGIN
                    IF COMPTYPES(INTPTR,GATTR.TYPTR) THEN
#                     BEGIN  IF GATTR.BTYPE@.SIZE <> INTSIZE THEN ERROR(116);
                      GEN1(30(*CSP*),24(*RDI*))
                      END
                    ELSE
                      IF COMPTYPES(REALPTR,GATTR.TYPTR) THEN
                        GEN1(30(*CSP*),14(*RDR*))
                      ELSE
                        IF COMPTYPES(CHARPTR,GATTR.TYPTR) THEN
                          GEN1(30(*CSP*),5(*RDC*))
#                       ELSE
#                         IF COMPTYPES(BOOLPTR,GATTR.TYPTR) THEN
#                           GEN1(30(*CSP*),12(*RDB*))
#                         ELSE  ERROR(116) ;
#                   END ;
                TEST := SY <> COMMA;
                IF NOT TEST THEN INSYMBOL
              UNTIL TEST ;
            IF LKEY = 11 THEN
              BEGIN
                GEN1(30(*CSP*),23(*RLN*))
              END ;
            GEN1(30(*CSP*),32(*EIO*)) ;
          END (*READ*) ;

          PROCEDURE WRITE1;
            VAR LSP: STP; DEFAULT, DEFAULT1 : BOOLEAN; LLKEY: 0..NSPROC;
              LEN:ADDRRANGE;
#         BEGIN LLKEY := LKEY;  TEST := FALSE ;
#           RWSETUP(NA[40] (*'OUTPUT      '*) ) ;
#           IF SY = RPARENT THEN
#             BEGIN  "TEST := TRUE ;" IF LLKEY = 6 THEN ERROR(116) ; END ;
#           IF SY = COMMA THEN
#             BEGIN INSYMBOL; IF NOT (SY IN SIMPTYPEBEGSYS) THEN ERROR(6)  END ;
#           IF SY IN SIMPTYPEBEGSYS THEN
#             REPEAT  EXPRESSION(FSYS+[COMMA,COLON,RPARENT]) ;
                LSP := GATTR.TYPTR;
                IF LSP <> NIL THEN
                  IF LSP@.FORM <= SUBRANGE THEN LOAD ELSE LOADADDRESS;
                DEFAULT := TRUE ;  DEFAULT1 := TRUE ;
                IF SY = COLON THEN
                  BEGIN INSYMBOL; EXPRESSION(FSYS + [COMMA,COLON,RPARENT]);
                    IF GATTR.TYPTR <> NIL THEN
                      IF GATTR.TYPTR <> INTPTR THEN ERROR(116);
                    LOAD; DEFAULT := FALSE ;
                    IF SY = COLON THEN
                      BEGIN  INSYMBOL;  EXPRESSION(FSYS + [COMMA,RPARENT]);
                        IF GATTR.TYPTR <> NIL THEN
                          IF GATTR.TYPTR <> INTPTR THEN ERROR(116);
                        IF LSP <> REALPTR THEN ERROR(124);
#                       LOAD; DEFAULT1 := FALSE ; " ERROR(398);  "
                      END ;
                  END ;
                IF LSP = INTPTR THEN
                  BEGIN IF DEFAULT THEN GEN2(51(*LDC*),1,12);
                    GEN1(30(*CSP*),6(*WRI*))
                  END
                ELSE
                  IF LSP = REALPTR THEN
                    BEGIN IF DEFAULT THEN GEN2(51(*LDC*),1,14);
                      IF DEFAULT1 THEN GEN2(51(*LDC*),1,0);
                      GEN1(30(*CSP*),8(*WRR*))
                    END
                  ELSE
                    IF LSP = CHARPTR THEN
                      BEGIN IF DEFAULT THEN GEN2(51(*LDC*),1,1);
                        GEN1(30(*CSP*),9(*WRC*))
                      END
                    ELSE
#                   IF LSP = BOOLPTR THEN
#                     BEGIN IF DEFAULT THEN GEN2(51(*LDC*),1,5);
#                       GEN1(30(*CSP*),13(*WRB*))
#                     END
#                   ELSE
                      IF LSP <> NIL THEN
                        BEGIN
                          IF LSP@.FORM = SCALAR THEN ERROR(398)
                          ELSE
                            IF STRING(LSP) THEN
                              BEGIN LEN := LSP@.SIZE DIV CHARSIZE;
                                IF DEFAULT THEN
                                      GEN2(51(*LDC*),1,LEN);
                                GEN2(51(*LDC*),1,LEN);
                                GEN1(30(*CSP*),10(*WRS*))
                              END
                            ELSE ERROR(116)
                        END;
                TEST := SY <> COMMA;
#               IF NOT TEST THEN   INSYMBOL ;
#             UNTIL TEST;
#
            IF LLKEY = 12 THEN (*WRITELN*)
              BEGIN
                GEN1(30(*CSP*),22(*WLN*))
              END ;
#           GEN1(30(*CSP*),32(*EIO*)) ;
          END (*WRITE*) ;
"NH"
"NH"      PROCEDURE SKIPLIM;
"NH"      BEGIN
"NH"        RWSETUP( NA[40] (*OUTPUT*) );
"NH"        IF SY = COMMA THEN
"NH"          BEGIN INSYMBOL;
"NH"            IF NOT (SY IN SIMPTYPEBEGSYS) THEN ERROR(6)
"NH"          END;
"NH"        IF SY IN SIMPTYPEBEGSYS THEN
"NH"          BEGIN
"NH"            EXPRESSION( FSYS + [RPARENT] );
"NH"            IF GATTR.TYPTR <> NIL THEN
"NH"               IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
"NH"            LOAD;  GEN1( 30 (*CSP*), LKEY-2 (*SKP/LIM *) );
"NH"          END
"NH"      END;
"NH"
"NH"      PROCEDURE MESSAGE1;
"NH"      VAR LEN : INTEGER ;
"NH"      BEGIN
"NH"        EXPRESSION( FSYS + [RPARENT] );
"NH"        IF GATTR.TYPTR <> NIL THEN
"NH"           IF STRING(GATTR.TYPTR) THEN
"NH"              LEN := GATTR.TYPTR@.SIZE DIV CHARSIZE
"NH"           ELSE ERROR(125);
"NH"        LOADADDRESS;
"NH"        GEN2( 51 (*LDC*), 1, LEN );
"NH"        GEN1( 30 (*CSP*), 33 (*MSG*) );
"NH"      END;

          PROCEDURE PACK1;
            VAR  LSP,LSP1: STP;   LSIZE, IMIN, IMAX: INTEGER;
          BEGIN  """ERROR(398);  VARIABLE(FSYS + [COMMA,RPARENT]);"""
#           EXPRESSION(FSYS + [COMMA, RPARENT]);
            LSP := NIL; LSP1 := NIL;
            IF GATTR.TYPTR <> NIL THEN
              WITH GATTR, GATTR.TYPTR@ DO
                IF FORM = ARRAYS THEN
                  BEGIN   LSP := INXTYPE;  LSP1 := AELTYPE;
#                 IF KIND = CST THEN  BEGIN  IMIN := 1;  IMAX := SIZE  END
#                 ELSE  IF LSP <> NIL THEN  GETBOUNDS(LSP, IMIN, IMAX);
#                 LSIZE := SIZE;
#                 LOADADDRESS;
#                 END
                ELSE ERROR(116);
            IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
            EXPRESSION(FSYS + [COMMA,RPARENT]);
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM <> SCALAR THEN ERROR(116)
              ELSE
                IF NOT COMPTYPES(LSP,GATTR.TYPTR) THEN ERROR(116)
#               ELSE
#                 BEGIN
#                 LOAD;
#                 IF DEBUG THEN GEN3(45(*CHK*),ORD('J'),IMIN,IMAX) ;
#                 IF IMIN > 0 THEN
#                    GEN2(22(*DEC*),GETTYPE(GATTR.TYPTR),IMIN)
#                  ELSE IF IMIN < 0 THEN
#                    GEN2(23(*INC*),GETTYPE(GATTR.TYPTR),-IMIN);
#                  IF LSP1 <> NIL THEN
#                    BEGIN  IMIN := LSP1@.SIZE;  ALIGN(IMIN, LSP1@.ALN);
#                    GEN1(36 (*IXA*), IMIN);
#                    END;
#                  END;

            IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
            VARIABLE(FSYS + [RPARENT]);
            IF GATTR.TYPTR <> NIL THEN
              WITH GATTR.TYPTR@ DO
                IF FORM = ARRAYS THEN
                  BEGIN
                    IF NOT COMPTYPES(AELTYPE,LSP1)
                      OR NOT COMPTYPES(INXTYPE,LSP) THEN  ERROR(116)
#                   ELSE
#                     BEGIN
#                     LOADADDRESS;
#                     IF SIZE > LSIZE THEN ERROR(303 (*CANNOT PACK*));
#                     GEN1(40 (*MOV*), -SIZE);  (*MOVE BACKWARD*)
#                     END;
                  END
                ELSE ERROR(116)
          END (*PACK*) ;

          PROCEDURE UNPACK1;
#           VAR  LSP,LSP1: STP;   IMIN, IMAX, LSIZE: INTEGER;
          BEGIN """ERROR(398); VARIABLE(FSYS + [COMMA,RPARENT]);"""
#           EXPRESSION(FSYS + [COMMA, RPARENT]);
            LSP := NIL; LSP1 := NIL;
            IF GATTR.TYPTR <> NIL THEN
              WITH GATTR.TYPTR@ DO
                IF FORM = ARRAYS THEN
                  BEGIN LSP := INXTYPE; LSP1 := AELTYPE;
#                 LSIZE := SIZE;
#                 LOADADDRESS;
                  END
                ELSE ERROR(116);
            IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
            VARIABLE(FSYS + [COMMA,RPARENT]);
            IF GATTR.TYPTR <> NIL THEN
              WITH GATTR, GATTR.TYPTR@ DO
                IF FORM = ARRAYS THEN
                  BEGIN
                    IF NOT COMPTYPES(AELTYPE,LSP1)
                      OR NOT COMPTYPES(INXTYPE,LSP) THEN  ERROR(116)
                    ELSE
#                     BEGIN
#                     IF LSIZE > SIZE THEN  ERROR(303 (*SOURCE OPERAND LARGE*));
#                     IF KIND = CST THEN
#                       BEGIN  IMIN := 1;  IMAX := SIZE END
#                     ELSE IF INXTYPE <> NIL THEN GETBOUNDS(INXTYPE, IMIN,IMAX);
#                     LOADADDRESS;
#                     END;

                  END
                ELSE ERROR(116);
            IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
            EXPRESSION(FSYS + [RPARENT]);
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM <> SCALAR THEN ERROR(116)
              ELSE
                IF NOT COMPTYPES(LSP,GATTR.TYPTR) THEN ERROR(116)
#               ELSE
#                 BEGIN
#                 LOAD;
#                 IF DEBUG THEN GEN3(45(*CHK*),ORD('J'),IMIN,IMAX) ;
#                 IF IMIN > 0 THEN
#                    GEN2(22(*DEC*),GETTYPE(GATTR.TYPTR),IMIN)
#                  ELSE IF IMIN < 0 THEN
#                    GEN2(23(*INC*),GETTYPE(GATTR.TYPTR),-IMIN);
#                  IF LSP1 <> NIL THEN
#                    BEGIN  IMIN := LSP1@.SIZE;  ALIGN(IMIN, LSP1@.ALN);
#                    GEN1(36 (*IXA*), IMIN);
#                    GEN1(40 (*MOV*), -LSIZE);   (*MOVE DOWN !*)
#                    END;
#                 END;
          END (*UNPACK*) ;

          PROCEDURE NEW1;
            LABEL 1;
            VAR LSP,LSP1: STP; VARTS,LMIN,LMAX: INTEGER;
                LSIZE,LSZ: ADDRRANGE; LVAL: VALU;
          BEGIN VARIABLE(FSYS + [COMMA,RPARENT]); LOADADDRESS;
            LSP := NIL; VARTS := 0; LSIZE := 0;
            IF GATTR.TYPTR <> NIL THEN
              WITH GATTR.TYPTR@ DO
                IF FORM = POINTER THEN
                  BEGIN
                    IF ELTYPE <> NIL THEN
                      BEGIN LSIZE := ELTYPE@.SIZE;
                        IF ELTYPE@.FORM = RECORDS THEN LSP := ELTYPE@.RECVAR
                      END
                  END
                ELSE ERROR(116);
            WHILE SY = COMMA DO
              BEGIN INSYMBOL;CONSTANT(FSYS + [COMMA,RPARENT],LSP1,LVAL);
                VARTS := VARTS + 1;
                (*CHECK TO INSERT HERE: IS CONSTANT IN TAGFIELDTYPE RANGE*)
                IF LSP = NIL THEN ERROR(158)
                ELSE
                  IF LSP@.FORM <> TAGFLD THEN ERROR(162)
                  ELSE
                    IF LSP@.TAGFIELDP <> NIL THEN
                      IF STRING(LSP1) OR (LSP1 = REALPTR) THEN ERROR(159)
                      ELSE
                        IF COMPTYPES(LSP@.TAGFIELDP@.IDTYPE,LSP1) THEN
                          BEGIN
                            LSP1 := LSP@.FSTVAR;
                            WHILE LSP1 <> NIL DO
                              WITH LSP1@ DO
                                IF VARVAL.IVAL = LVAL.IVAL THEN
                                  BEGIN LSIZE := SIZE; LSP := SUBVAR;
                                    GOTO 1
                                  END
                                ELSE LSP1 := NXTVAR;
                            LSIZE := LSP@.SIZE; LSP := NIL;
                          END
                        ELSE ERROR(116);
          1:  END (*WHILE*) ;
#           ALIGN(LSIZE,MXDATASZE) ;
#           GEN1(58(*NEW*),LSIZE);
          END (*NEW*) ;

          PROCEDURE MARK1;
          BEGIN VARIABLE(FSYS+[RPARENT]);
             IF GATTR.TYPTR <> NIL THEN
               IF GATTR.TYPTR@.FORM = POINTER THEN
                 BEGIN LOADADDRESS; GEN0(59(*SAV*)) END
               ELSE ERROR(125)
          END(*MARK*);

          PROCEDURE RELEASE1;
          BEGIN  VARIABLE(FSYS+[RPARENT]);
                IF GATTR.TYPTR <> NIL THEN
                   IF GATTR.TYPTR@.FORM = POINTER THEN
                      BEGIN   LOAD;  GEN0(60(*RST*))  END
                   ELSE ERROR(125)
          END (*RELEASE*);

#         PROCEDURE TRAPEXIT ;
#
#         (*THIS PROCEDURE IS TO SIMPLIFY COMMUNICATION WITH THE OUTSIDE WORLD*)
#         (* AND PROVIDE BREAK POINTS IN THE PASCAL PROGRAM.                  *)
#         (* 'TRAP(I, R)'  RETURNS THE INTEGER CONSTANT I AS WELL AS A POINTER*)
#         (* TO THE SECOND PARAMETER 'R' (I.E. ADDRESS OF R) TO THE OPERATING *)
#         (* SYSTEM. THE FIRST PARAMETER IS INTENDED TO BE USED AS A          *)
#         (* 'FUNCTION NUMBER' AND THE SECOND ONE AS THE 'VAR' TYPE ARGUMENT  *)
#         (* WHICH MAY BE INSPECTED AND MODIFIED, TO THAT FUNCTION            *)
#
#           BEGIN  " EXPRESSION(FSYS+[RPARENT,COMMA]) ;  "
#           IF GATTR.TYPTR <> INTPTR THEN  ERROR(116) ;
#           IF LKEY = 14 THEN (*TRAP*)
#             BEGIN
#             IF SY <> COMMA THEN  ERROR(6)
#             ELSE
#               BEGIN  INSYMBOL ;
#               EXPRESSION(FSYS+[RPARENT]) ;
#               WITH GATTR DO
#                 IF TYPTR <> NIL THEN
#                   BEGIN
#                   IF KIND <> VARBL THEN
#                     IF TYPTR@.FORM <= POWER THEN
#                       BEGIN  LOAD ;
#                       KIND := VARBL ;  ACCESS := DRCT ;  VLEVEL := LEVEL ;
#                       ALIGN(LC,MXDATASZE) ;  DPLMT := LC ;  BTYPE := TYPTR ;
#                       STORE(GATTR) ;
#                       END ;
#                   LOADADDRESS ;
#                   END ;
#               END (*WITH*) ;
#             END ;
#           GEN1(30(*CSP*),LKEY+14 (*TRP*) (*XIT*)) ;
#           END (* TRAPEXIT *) ;

#         PROCEDURE SQRABS;
#         VAR OP : OPRANGE ;
#         BEGIN   OP := 0 (*ABI*) ;
#           IF LKEY = 17 THEN  OP := 24 (*SQI*) ;
#           IF GATTR.TYPTR <> NIL THEN
#             IF GATTR.TYPTR = INTPTR THEN GEN0(OP(*ABI*)(*SQI*))
#             ELSE
#               IF GATTR.TYPTR = REALPTR THEN GEN0(OP+1(*ABR*)(*ABR*))
#               ELSE BEGIN ERROR(125); GATTR.TYPTR := INTPTR END
#         END (*SQRABS*) ;

         "PROCEDURE SQR1;
          BEGIN
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR = INTPTR THEN GEN0(24(*SQI*))
              ELSE
                IF GATTR.TYPTR = REALPTR THEN GEN0(25(*SQR*))
                ELSE BEGIN ERROR(125); GATTR.TYPTR := INTPTR END
          END (*SQR*) ; "

          PROCEDURE TRUNCROUND;
          BEGIN
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR <> REALPTR THEN ERROR(125);
            GEN0(LKEY-18+27(*TRC*)(*RND*));
            GATTR.TYPTR := INTPTR
          END (*TRUNCROUND*) ;
"NH"
"NH"      PROCEDURE EXPO1;
"NH"      BEGIN
"NH"        IF GATTR.TYPTR <> NIL THEN
"NH"           IF GATTR.TYPTR = INTPTR THEN
"NH"              GEN0( 10 (*FLT*) )
"NH"           ELSE IF GATTR.TYPTR <> REALPTR THEN ERROR(125);
"NH"        GEN0( 66 (*XPO*) );  GATTR.TYPTR := INTPTR;
"NH"      END (*EXPO*);
"NH"
"NH"      PROCEDURE CARD1;
"NH"      BEGIN
"NH"        IF GATTR.TYPTR <> NIL THEN
"NH"           IF GATTR.TYPTR@.FORM <> POWER THEN ERROR(125);
"NH"        GEN0( 65 (*CRD*) );  GATTR.TYPTR := INTPTR;
"NH"      END (*CARD*);

          PROCEDURE ODD1;
          BEGIN
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
            GEN0(20(*ODD*));
            GATTR.TYPTR := BOOLPTR
          END (*ODD*) ;

          PROCEDURE ORD1;
          BEGIN
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM >= POWER THEN ERROR(125);
#           GEN0(61(*ORD*)) ;
            GATTR.TYPTR := INTPTR
          END (*ORD1*) ;

          PROCEDURE CHR1;
          BEGIN
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
#           GEN0(62(*CHR*)) ;
            GATTR.TYPTR := CHARPTR
          END (*CHR*) ;

          PROCEDURE PREDSUCCTIM;
#         BEGIN (*ERROR(398);*) (*TRANSLATES INTO 'DEC' AND 'INC'*)
#           IF GATTR.TYPTR <> NIL THEN
#              IF LKEY = 24  THEN
#                 BEGIN  IF GATTR.TYPTR <> INTPTR THEN  ERROR(116) ;
#                 GEN1(30(*CSP*),21(*CLK*)) ;
#                 END
#              ELSE
#               IF (GATTR.TYPTR = REALPTR) OR (GATTR.TYPTR@.FORM <> SCALAR) THEN
#                  ERROR(125)
#               ELSE  GEN2(LKEY(*DEC,INC*),GETTYPE(GATTR.BTYPE),1) ;
                (* LKEY HAPPENS TO BE THE OPCODE AS WELL *)
#         END (*PREDSUCCTIM*) ;

          PROCEDURE EOFEOLN;
          BEGIN
#           RWSETUP(NA[39] (*'INPUT       '*) ) ;
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM <> FILES THEN ERROR(125);  "
            ELSE GEN1(30(*CSP*),26(*ELN*));  "
            (* LKEY HAPPENS TO BE THE CSP NUMBER AS WELL ! *)
#           GEN1(30(*CSP*), LKEY(*EOF*)(*ELN*)) ;
#           GEN1(30(*CSP*),32(*EIO*)) ;
            GATTR.TYPTR := BOOLPTR
          END (*EOF*) ;

       """PROCEDURE MATH;
          BEGIN
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR = INTPTR  THEN
                BEGIN  GEN0(10(*FLT*)) ;
                GATTR.TYPTR := REALPTR ;
              END ;
              IF GATTR.TYPTR <> REALPTR THEN ERROR(116)
              ELSE   GEN1(30(*CSP*), LKEY-12(*SIN..ATAN*)) ;
          END (*MATH*) ;
       """
          PROCEDURE CALLNONSTANDARD;
            VAR NXT,LCP: CTP; LSP: STP; LKIND: IDKIND; LB: BOOLEAN;
#               LOCPAR, LLC, LSIZE: ADDRRANGE;
          BEGIN LOCPAR := 0;
            WITH FCP@ DO
              BEGIN NXT := NEXT; LKIND := PFKIND;
"CM"              GEN1(41(*MST*),PFLEV) ;
"S1" "            GEN3(41(*MST*), PFLEV+1, FPRMSZE, RPRMSZE) ;                 "
(*+CG                                                                         *)
(*+CG             T_CLIST := CALL_HEAD ;                                      *)
(*+CG             WHILE NAME < T_CLIST@.NAME DO  T_CLIST := T_CLIST@.NXT ;    *)
(*+CG             IF T_CLIST@.NAME <> NAME THEN                               *)
(*+CG               BEGIN   NEW(T2_CLIST) ;   T2_CLIST@ := T_CLIST@ ;         *)
(*+CG               T_CLIST@.NAME := NAME ;   T_CLIST@.NXT := T2_CLIST ;      *)
(*+CG               T_CLIST@.CNT := 1 ;  T_CLIST@.LVL := PFLEV ;              *)
#                   IF PFLEV = LEVEL THEN   LOCAL_CALL := TRUE ;
(*+CG               END                                                       *)
(*+CG             ELSE  T_CLIST@.CNT := T_CLIST@.CNT+1 ;                      *)
(*+CG                                                                         *)
              END;
            IF SY = LPARENT THEN
              BEGIN LLC := LC;
                REPEAT LB := FALSE; (*DECIDE WHETHER PROC/FUNC MUST BE PASSED*)
                  IF LKIND = ACTUAL THEN
                    BEGIN
                      IF NXT = NIL THEN ERROR(126)
                      ELSE LB := NXT@.KLASS IN [PROC,FUNC]
                    END ELSE ERROR(398);
                  (*FOR FORMAL PROC/FUNC LB IS FALSE AND EXPRESSION
                   WILL BE CALLED, WHICH WILL ALLWAYS INTERPRET A PROC/FUNC ID
                  AT ITS BEGINNING AS A CALL RATHER THAN A PARAMETER PASSING.
                  IN THIS IMPLEMENTATION, PARAMETER PROCEDURES/FUNCTIONS
                  ARE THEREFORE NOT ALLOWED TO HAVE PROCEDURE/FUNCTION
                  PARAMETERS*)
                  INSYMBOL;
                  IF LB THEN   (*PASS FUNCTION OR PROCEDURE*)
                    BEGIN ERROR(398);
                      IF SY <> IDENT THEN
                        BEGIN ERROR(2); SKIP(FSYS + [COMMA,RPARENT]) END
                      ELSE
                        BEGIN
                          IF NXT@.KLASS = PROC THEN SEARCHID([PROC],LCP)
                          ELSE
                            BEGIN SEARCHID([FUNC],LCP);
                              IF NOT COMPTYPES(LCP@.IDTYPE,NXT@.IDTYPE) THEN
                                ERROR(128)
                            END;
                          INSYMBOL;
                          IF NOT (SY IN FSYS + [COMMA,RPARENT]) THEN
                            BEGIN ERROR(6); SKIP(FSYS + [COMMA,RPARENT]) END
                        END
                    END (*IF LB*)
                  ELSE
                    BEGIN
(*+RM               IF NXT <> NIL THEN                                       +*)
(*+RM                  IF NXT@.VKIND = FORMAL THEN  MODIFYING := TRUE ;      +*)
                    EXPRESSION(FSYS + [COMMA,RPARENT]);
(*+RM               MODIFYING := FALSE ;                                     +*)
                      IF GATTR.TYPTR <> NIL THEN
                        IF LKIND = ACTUAL THEN
                          BEGIN
                            IF NXT <> NIL THEN
                              BEGIN LSP := NXT@.IDTYPE;
                                IF LSP <> NIL THEN
                                  BEGIN
                                    IF (NXT@.VKIND = ACTUAL) THEN
#                                     IF LSP@.FORM <= POWER THEN
#                                       BEGIN LOAD;
#                                       IF DEBUG THEN
#                                         BEGIN  ASSIGN := TRUE ;
#                                         CHKBNDS(LSP) ;  ASSIGN := FALSE ;
#                                         END ;
                                        IF COMPTYPES(REALPTR,LSP)
                                           AND (GATTR.TYPTR = INTPTR) THEN
                                          BEGIN GEN0(10(*FLT*));
                                            GATTR.TYPTR := REALPTR ;
                                            GATTR.BTYPE := REALPTR ;
                                          END;
                                        LOCPAR := LOCPAR+ 1 (*LSP@.SIZE*) ;
#                                       IF PACKDATA THEN
#                                         BEGIN
#                                         IF LSP@.SIZE = 4 THEN GEN0(61(*ORD*));
#                                         IF LSP@.SIZE = 1 THEN GEN0(62(*CHR*));
                                           END (*PACKDATA*) ;
#
#                                       IF FCP@.FRTRN THEN
#                                         BEGIN (*PASS ADDRESS OF PARAMETER*)
#                                         LSIZE := LSP@.SIZE ;
#                                         ALIGN(LC,LSIZE) ;
#                                         WITH GATTR DO
#                                           BEGIN
#                                           VLEVEL := LEVEL ;   DPLMT := LC ;
#                                           KIND := VARBL ;  ACCESS := DRCT ;
#                                           END (*WITH*) ;
#                                         STORE(GATTR) ;  LOADADDRESS ;
#                                         LC := LC+LSIZE ;
#                                         IF LC > LCMAX THEN LCMAX := LC ;
#                                         END (*IF FCP@.FRTRN*) ;
#
"S1" "                                  IF NOT FCP@.EXTRN THEN                 "
"S1" "                                    GEN1(64(*PRM*), GETTYPE(LSP));       "
                                        END
                                      ELSE  (* LSP@.FORM > POWER *)
                                        BEGIN
                                        LOADADDRESS;
                                        LOCPAR := LOCPAR+ 1 (*PTRSIZE*);
"S1" "                                  IF NOT FCP@.EXTRN THEN                 "
"S1" "                                    GEN1(64(*PRM*), ORD('A')) ;          "
                                        END
                                    ELSE  (* VKIND = FORMAL I.E. VAR PARM *)
                                      IF GATTR.KIND = VARBL THEN
                                        BEGIN  LOADADDRESS;
                                        LOCPAR := LOCPAR + 1 (*PTRSIZE*);
"S1" "                                  IF NOT FCP@.EXTRN THEN                 "
"S1" "                                    GEN1(64(*PRM*), ORD('A')) ;          "
                                        IF GATTR.BTYPE@.SIZE <> LSP@.SIZE THEN
                                          ERROR(142) ;
                                        END
                                      ELSE ERROR(154);
                                    IF NOT COMPTYPES(LSP,GATTR.TYPTR) THEN
                                      ERROR(142)
                                  END
                              END
                          END
                      ELSE (*LKIND = FORMAL*)
                        BEGIN (*PASS FORMAL PROC/FUNC PARAM*)
                        END
                    END;
                  IF (LKIND = ACTUAL) AND (NXT <> NIL) THEN NXT := NXT@.NEXT
                UNTIL SY <> COMMA;
                LC := LLC;
              IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
            END (*IF LPARENT*);
#           LOCPAR := LOCPAR*2 ;
            IF LKIND = ACTUAL THEN
              BEGIN IF NXT <> NIL THEN ERROR(126);
                WITH FCP@ DO
            "     IF EXTRN THEN GEN1(30(*CSP*),PFNAME)
#                 ELSE    "
#                   BEGIN
#                   IF SAVEFP THEN LOCPAR := LOCPAR+1 ;  (*ENCODE SAVE FPR FLG*)
                    NAMFLAG := XLINK OR FRTRN OR EXTRN ;
                    GENCUPENT(46(*CUP*),PROCTYPE(FCP),LOCPAR,PFNAME,NAME);
                    END ;
              END;
#           GATTR.TYPTR := FCP@.IDTYPE ;  GATTR.BTYPE := GATTR.TYPTR ;
          END (*CALLNONSTANDARD*) ;

        BEGIN (*CALL*)
          IF FCP@.PFDECKIND = STANDARD THEN
            BEGIN
            LKEY := FCP@.KEY;

#           IF LKEY IN [27..32 (*SIN..ATAN*)] THEN
#             BEGIN  FCP := FCP@.NEXT;  (*POINT TO FORTRAN VERSION*)
#             CALLNONSTANDARD;
#             END
#           ELSE

#             BEGIN  (*OTHER STANDARD PROCS/FUNCTIONS*)
#             IF SY = LPARENT THEN
#               BEGIN  INSYMBOL ;   MATCHPAR := TRUE ;
#               IF SY = RPARENT THEN
#                 IF NOT (LKEY IN [0,1,2,3,4,11,12,25,26]) THEN ERROR(7) ;
                         (*GET,PUT,RESET,REWRITE,RDLN,WRITELN,EOF,ELN*)
#               END
#             ELSE
#               BEGIN  IF NOT (LKEY IN [0,1,2,3,4,11,12,25,26]) THEN ERROR(6) ;
                              (*GET,PUT,RESET,REWRITE,RDLN,WRITELN,EOF,ELN*)
#             " IF SY =RPARENT THEN ERROR(6) ; "
#               MATCHPAR := FALSE ;
#               END ;

"NH"          IF LKEY IN [14..24,27..33,38,39] THEN
"NH"             (*TRAP,EXIT,ABS...MATH,ODD,CARD,EXPO*)
#               BEGIN
                IF LKEY = 14 (*TRAP*) THEN  EXPRESSION(FSYS+[COMMA])
                ELSE  EXPRESSION(FSYS+[RPARENT]) ;
                LOAD ;
                END  ;
#
#               CASE LKEY OF
#             0,1,2,
#               3,4:    GETPUTRESETREWRITE;
#              5,11:    READ1;
#              6,12:    WRITE1;
#                 7:    PACK1;
#                 8:    UNPACK1;
#                 9:    NEW1;
#                10:    RELEASE1;
#                13:    MARK1;
#             14,15:    TRAPEXIT;
#             16,17:    SQRABS;
#               "17:    SQR1;"
#             18,19:    TRUNCROUND;
#                20:    ORD1;
#                21:    CHR1;
#          22,23,24:    PREDSUCCTIM;
#             25,26:    EOFEOLN ;
#       """27,28,29,
#          30,31,32:    MATH ;  """
#                33:    ODD1;
"NH"             35:    MESSAGE1;
"NH"          36,37:    SKIPLIM;
"NH"             38:    CARD1;
"NH"             39:    EXPO1;
                END (*CASE LKEY OF*) ;

"NH"          IF LKEY IN [16..24,27..33,38,39] THEN
"NH"             GATTR.BTYPE := GATTR.TYPTR;
#             IF MATCHPAR THEN
#               IF SY = RPARENT THEN INSYMBOL ELSE  ERROR(4) ;
              END (*OTHER STANDARD PROCEDURES AND FUNCTIONS*)

            END (*IF FCP@.PFDECKIND = STANDARD*)

          ELSE CALLNONSTANDARD

        END (*CALL*) ;

        PROCEDURE EXPRESSION;
          VAR LATTR: ATTR; LOP: OPERATOR; TYPIND: CHAR; LSIZE: ADDRRANGE;

          PROCEDURE SIMPLEEXPRESSION(FSYS: SETOFSYS);
            VAR LATTR: ATTR; LOP: OPERATOR; SIGNED: BOOLEAN;

            PROCEDURE TERM(FSYS: SETOFSYS);
              VAR LATTR: ATTR; LOP: OPERATOR;

              PROCEDURE FACTOR(FSYS: SETOFSYS);
                VAR LCP: CTP; LVP: CSP; VARPART: BOOLEAN;
#                   LATTR: ATTR;
#                   CSTPART: SETRANGE  ; LSP: STP;   I: 0..64 ;
              BEGIN
                IF NOT (SY IN FACBEGSYS) THEN
                  BEGIN ERROR(58); SKIP(FSYS + FACBEGSYS);
                    GATTR.TYPTR := NIL
                  END;
                WHILE SY IN FACBEGSYS DO
                  BEGIN
                    CASE SY OF
              (*ID*)    IDENT:
                        BEGIN SEARCHID([KONST,VARS,FIELD,FUNC],LCP);
                          INSYMBOL;
                          IF LCP@.KLASS = FUNC THEN
#                           BEGIN CALL(FSYS,LCP);
#                             WITH GATTR DO
#                               BEGIN KIND := EXPR;
#                                 IF TYPTR <> NIL THEN
#                                   BEGIN  BTYPE := TYPTR ;
#                                   IF TYPTR@.FORM=SUBRANGE THEN
#                                     TYPTR := TYPTR@.RANGETYPE
#                                   END
#                               END
#                           END
                          ELSE
                            IF LCP@.KLASS = KONST THEN
                              WITH GATTR, LCP@ DO
                                BEGIN TYPTR := IDTYPE; KIND := CST;
#                                 CVAL := VALUES; GATTR.BTYPE := GATTR.TYPTR
                                END
                            ELSE
                              BEGIN SELECTOR(FSYS,LCP);
                                IF GATTR.TYPTR<>NIL THEN(*ELIM.SUBR.TYPES TO*)
                                  WITH GATTR,TYPTR@ DO(*SIMPLIFY LATER TESTS*)
                                    IF FORM = SUBRANGE THEN
                                      TYPTR := RANGETYPE
                              END
                        END;
              (*CST*)   INTCONST:
                        BEGIN
                          WITH GATTR DO
                            BEGIN TYPTR := INTPTR; KIND := CST;
#                             CVAL := VAL; BTYPE := TYPTR
                            END;
                          INSYMBOL
                        END;
                      REALCONST:
                        BEGIN
                          WITH GATTR DO
                            BEGIN TYPTR := REALPTR; KIND := CST;
#                             BTYPE := TYPTR ;   CVAL := VAL
                            END;
                          INSYMBOL
                        END;
                      STRINGCONST:
                        BEGIN
                          WITH GATTR DO
                            BEGIN
                              IF LNGTH = 1 THEN TYPTR := CHARPTR
                              ELSE
                                BEGIN NEW(LSP,ARRAYS);
                                  WITH LSP@ DO
                                    BEGIN AELTYPE := CHARPTR; FORM:=ARRAYS;
                                      INXTYPE := NIL; SIZE := LNGTH*CHARSIZE
                                    END;
                                  TYPTR := LSP
                                END;
#                             KIND := CST; CVAL := VAL;BTYPE := TYPTR;
                            END;
                          INSYMBOL
                        END;
              (* ( *)   LPARENT:
                        BEGIN INSYMBOL; EXPRESSION(FSYS + [RPARENT]);
                          IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
                        END;
              (*NOT*)   NOTSY:
                        BEGIN INSYMBOL; FACTOR(FSYS);
                          LOAD; GEN0(19(*NOT*));
                          IF GATTR.TYPTR <> NIL THEN
                            IF GATTR.TYPTR <> BOOLPTR THEN
                              BEGIN ERROR(135); GATTR.TYPTR := NIL END;
                        END;
              (*[*)     LBRACK:
                        BEGIN INSYMBOL; CSTPART := [ ]; VARPART := FALSE;
                          NEW(LSP,POWER);
                          WITH LSP@ DO
                            BEGIN ELSET:=NIL;SIZE:=SETSIZE;FORM:=POWER END;
                          IF SY = RBRACK THEN
                            BEGIN
                              WITH GATTR DO
                                BEGIN TYPTR := LSP; KIND := CST END;
                              INSYMBOL
                            END
                          ELSE
                            BEGIN
#                             REPEAT EXPRESSION(FSYS + [COMMA,DOTDOT,RBRACK]);
                                IF GATTR.TYPTR <> NIL THEN
                                  IF GATTR.TYPTR@.FORM <> SCALAR THEN
                                    BEGIN ERROR(136); GATTR.TYPTR := NIL END
                                  ELSE
                                    IF COMPTYPES(LSP@.ELSET,GATTR.TYPTR) THEN
                                      BEGIN
                                        IF GATTR.KIND = CST THEN
#                                         BEGIN
#                                         LATTR := GATTR ;
#                                         IF SY = DOTDOT THEN   (*RANGE GIVEN*)
#                                           BEGIN  INSYMBOL ;"LATTR := GATTR;"
#                                           EXPRESSION(FSYS+[COMMA,RBRACK]) ;
#                                           END ;
#                                         IF GATTR.TYPTR <> LATTR.TYPTR THEN
#                                             ERROR(137)
#                                         ELSE
#
#                                           IF (LATTR.CVAL.IVAL < 0)         OR
#                                              (GATTR.CVAL.IVAL > SETMAX  )  OR
#                                              (LATTR.CVAL.IVAL>GATTR.CVAL.IVAL)
#                                             THEN  ERROR(304)
#                                           ELSE
#                                             FOR I := LATTR.CVAL.IVAL TO
#                                                      GATTR.CVAL.IVAL DO
#                                               CSTPART := CSTPART+[I] ;
#                                         END  (* GATTR.KIND = CST *)
#                                       ELSE
#                                         BEGIN LOAD;
#                                         IF NOT COMPTYPES(GATTR.TYPTR,INTPTR)
#                                           THEN GEN0(61(*ORD*));
#                                         IF DEBUG THEN
#                                           GEN3(45(*CHK*),ORD('S'),0,SETMAX  );
#                                         GEN0(29(*SGS*));
                                          IF VARPART THEN GEN0(31(*UNI*))
                                          ELSE VARPART := TRUE
                                          END;
                                        LSP@.ELSET := GATTR.TYPTR;
                                        GATTR.TYPTR := LSP
                                      END
                                    ELSE ERROR(137);
                                TEST := SY <> COMMA;
                                IF NOT TEST THEN INSYMBOL
                              UNTIL TEST;
                              IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12)
                            END;
                          IF VARPART THEN
                            BEGIN
                              IF CSTPART <> [ ] THEN
                                BEGIN NEW(LVP,PSET); LVP@.PVAL := CSTPART;
                                  "LVP@.CCLASS := PSET;"
#                                 CNSTPTR := LVP;
#                                 GEN2(51(*LDC*),5,0);
                                  GEN0(31(*UNI*)); GATTR.KIND := EXPR
                                END
                            END
                          ELSE
                            BEGIN NEW(LVP,PSET); LVP@.PVAL := CSTPART;
                             "LVP@.CCLASS := PSET;"
                              GATTR.CVAL.VALP := LVP
                            END
                        END
                    END (*CASE*) ;
                    IF NOT (SY IN FSYS) THEN
                      BEGIN ERROR(6); SKIP(FSYS + FACBEGSYS) END
                  END (*WHILE*)
              END (*FACTOR*) ;

            BEGIN (*TERM*)
              FACTOR(FSYS + [MULOP]);
              WHILE SY = MULOP DO
                      BEGIN LOAD; LATTR := GATTR; LOP := OP;
                  INSYMBOL; FACTOR(FSYS + [MULOP]); LOAD;
                  IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
                    CASE LOP OF
            (***)       MUL:  IF (LATTR.TYPTR=INTPTR)AND(GATTR.TYPTR=INTPTR)
                              THEN GEN0(15(*MPI*))
                            ELSE
                              BEGIN
#                               IF GATTR.TYPTR = INTPTR THEN
#                                 BEGIN GEN0(10(*FLT*));
#                                   GATTR.TYPTR := REALPTR
#                                 END
#                               ELSE
#                                 IF LATTR.TYPTR = INTPTR THEN
#                                   BEGIN GEN0(9(*FLO*));
#                                     LATTR.TYPTR := REALPTR
                                    END;
                                IF (LATTR.TYPTR = REALPTR)
                                  AND(GATTR.TYPTR=REALPTR)THEN GEN0(16(*MPR*))
                                ELSE
                                  IF(LATTR.TYPTR@.FORM=POWER)
                                    AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR)THEN
                                    GEN0(12(*INT*))
                                  ELSE BEGIN ERROR(134);GATTR.TYPTR:=NIL END
                              END;
            (*/*)       RDIV: BEGIN
#                             IF GATTR.TYPTR = INTPTR THEN
#                               BEGIN GEN0(10(*FLT*));
#                                 GATTR.TYPTR := REALPTR
#                               END;
#                             IF LATTR.TYPTR = INTPTR THEN
#                               BEGIN GEN0(9(*FLO*));
#                                 LATTR.TYPTR := REALPTR
#                               END;
                              IF (LATTR.TYPTR = REALPTR)
                                AND (GATTR.TYPTR=REALPTR)THEN GEN0(7(*DVR*))
                              ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
                            END;
            (*DIV*)     IDIV: IF (LATTR.TYPTR = INTPTR)
                              AND (GATTR.TYPTR = INTPTR) THEN GEN0(6(*DVI*))
                            ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END;
            (*MOD*)     IMOD: IF (LATTR.TYPTR = INTPTR)
#                             AND (GATTR.TYPTR = INTPTR) THEN GEN0(14       )
                            ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END;
            (*AND*)     ANDOP:IF (LATTR.TYPTR = BOOLPTR)
                              AND (GATTR.TYPTR = BOOLPTR) THEN GEN0(4(*AND*))
                            ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
                    END (*CASE*)
                  ELSE GATTR.TYPTR := NIL
                END (*WHILE*)
            END (*TERM*) ;

          BEGIN (*SIMPLEEXPRESSION*)
            SIGNED := FALSE;
            IF (SY = ADDOP) AND (OP IN [PLUS,MINUS]) THEN
              BEGIN SIGNED := OP = MINUS; INSYMBOL END;
            TERM(FSYS + [ADDOP]);
            IF SIGNED THEN
              BEGIN LOAD;
                IF GATTR.TYPTR = INTPTR THEN GEN0(17(*NGI*))
                ELSE
                  IF GATTR.TYPTR = REALPTR THEN GEN0(18(*NGR*))
                  ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
              END;
            WHILE SY = ADDOP DO
              BEGIN LOAD; LATTR := GATTR; LOP := OP;
                INSYMBOL; TERM(FSYS + [ADDOP]); LOAD;
                IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
                  CASE LOP OF
          (*+*)       PLUS:
                      IF (LATTR.TYPTR = INTPTR)AND(GATTR.TYPTR = INTPTR) THEN
                        GEN0(2(*ADI*))
                      ELSE
                        BEGIN
#                         IF GATTR.TYPTR = INTPTR THEN
#                           BEGIN GEN0(10(*FLT*));
#                             GATTR.TYPTR := REALPTR
#                           END
#                         ELSE
#                           IF LATTR.TYPTR = INTPTR THEN
#                             BEGIN GEN0(9(*FLO*));
#                               LATTR.TYPTR := REALPTR
#                             END;
                          IF (LATTR.TYPTR = REALPTR)AND(GATTR.TYPTR = REALPTR)
                            THEN GEN0(3(*ADR*))
                          ELSE IF(LATTR.TYPTR@.FORM=POWER)
                                 AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
                                 GEN0(31(*UNI*))
                               ELSE BEGIN ERROR(134);GATTR.TYPTR:=NIL END
                        END;
          (*-*)       MINUS:
                      IF (LATTR.TYPTR = INTPTR)AND(GATTR.TYPTR = INTPTR) THEN
                        GEN0(21(*SBI*))
                      ELSE
                        BEGIN
#                         IF GATTR.TYPTR = INTPTR THEN
#                           BEGIN GEN0(10(*FLT*));
#                             GATTR.TYPTR := REALPTR
#                           END
#                         ELSE
#                           IF LATTR.TYPTR = INTPTR THEN
#                             BEGIN GEN0(9(*FLO*));
#                               LATTR.TYPTR := REALPTR
                              END;
                          IF (LATTR.TYPTR = REALPTR)AND(GATTR.TYPTR = REALPTR)
                            THEN GEN0(8(*SBR*))
                          ELSE
                            IF (LATTR.TYPTR@.FORM = POWER)
                              AND COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
                              GEN0(5(*DIF*))
                            ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
                        END;
          (*OR*)      OROP:
                      IF(LATTR.TYPTR=BOOLPTR)AND(GATTR.TYPTR=BOOLPTR)THEN
                        GEN0(13(*IOR*))
                      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
                  END (*CASE*)
                ELSE GATTR.TYPTR := NIL
              END (*WHILE*)
          END (*SIMPLEEXPRESSION*) ;

        BEGIN (*EXPRESSION*)
          SIMPLEEXPRESSION(FSYS + [RELOP]);
          IF SY = RELOP THEN
            BEGIN
              IF GATTR.TYPTR <> NIL THEN
                IF GATTR.TYPTR@.FORM <= POWER THEN LOAD
                ELSE LOADADDRESS;
              LATTR := GATTR; LOP := OP;
#   (*IN*)    IF LOP = INOP THEN
#               BEGIN
#               IF NOT COMPTYPES(GATTR.TYPTR,INTPTR) THEN  GEN0(61(*ORD*)) ;
#               IF DEBUG THEN GEN3(45(*CHK*),ORD('S'),0,SETMAX  ) ;
#               END ;
              INSYMBOL; SIMPLEEXPRESSION(FSYS);
              IF GATTR.TYPTR <> NIL THEN
                IF GATTR.TYPTR@.FORM <= POWER THEN LOAD
                ELSE LOADADDRESS;
              IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
                IF LOP = INOP THEN
                  IF GATTR.TYPTR@.FORM = POWER THEN
                    IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR@.ELSET) THEN
                      GEN0(11(*INN*))
                    ELSE BEGIN ERROR(129); GATTR.TYPTR := NIL END
                  ELSE BEGIN ERROR(130); GATTR.TYPTR := NIL END
                ELSE
                  BEGIN
                    IF LATTR.TYPTR <> GATTR.TYPTR THEN
#                     IF GATTR.TYPTR = INTPTR THEN
#                       BEGIN GEN0(10(*FLT*));
#                         GATTR.TYPTR := REALPTR
#                       END
#                     ELSE
#                       IF LATTR.TYPTR = INTPTR THEN
#                         BEGIN GEN0(9(*FLO*));
#                           LATTR.TYPTR := REALPTR
                          END;
                    IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
                      BEGIN LSIZE := LATTR.TYPTR@.SIZE;
                        CASE LATTR.TYPTR@.FORM OF
                          SCALAR:
                            IF LATTR.TYPTR = REALPTR THEN TYPIND := 'R'
                            ELSE
                              IF LATTR.TYPTR = BOOLPTR THEN TYPIND := 'B'
#                             ELSE
#                               IF LATTR.TYPTR = CHARPTR THEN TYPIND := 'C'
#                               ELSE TYPIND := 'I' ;
                          POINTER:
                            BEGIN
                              IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131);
                              TYPIND := 'A'
                            END;
                          POWER:
                            BEGIN IF LOP IN [LTOP,GTOP] THEN ERROR(132);
                              TYPIND := 'S'
                          END;
                          ARRAYS:
                            BEGIN
                              IF NOT STRING(LATTR.TYPTR)
                              AND(LOP IN[LTOP,LEOP,GTOP,GEOP])THEN ERROR(131);
                              TYPIND := 'M'
                            END;
                          RECORDS:
                            BEGIN
                              IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131);
                              TYPIND := 'M'
                            END;
                          FILES:
                            BEGIN ERROR(133); TYPIND := 'F' END
                        END;
                        CASE LOP OF
                          LTOP: GEN2(53(*LES*),ORD(TYPIND),LSIZE);
                          LEOP: GEN2(52(*LEQ*),ORD(TYPIND),LSIZE);
                          GTOP: GEN2(49(*GRT*),ORD(TYPIND),LSIZE);
                          GEOP: GEN2(48(*GEQ*),ORD(TYPIND),LSIZE);
                          NEOP: GEN2(55(*NEQ*),ORD(TYPIND),LSIZE);
                          EQOP: GEN2(47(*EQU*),ORD(TYPIND),LSIZE)
                        END
                      END
                    ELSE ERROR(129)
                  END;
              GATTR.TYPTR := BOOLPTR; GATTR.KIND := EXPR
            END (*SY = RELOP*)
        END (*EXPRESSION*) ;

        PROCEDURE ASSIGNMENT(FCP: CTP);
          VAR LATTR: ATTR;
        BEGIN
(*+RM     MODIFYING := TRUE ;                                                +*)
          SELECTOR(FSYS + [BECOMES],FCP);
(*+RM     MODIFYING := FALSE ;                                               +*)
#         VAR_MOD := VAR_MOD+1 ;
          IF SY = BECOMES THEN
            BEGIN
              IF GATTR.TYPTR <> NIL THEN
                IF (GATTR.ACCESS<>DRCT) OR (GATTR.TYPTR@.FORM>POWER) THEN
                  LOADADDRESS;
              LATTR := GATTR;
              INSYMBOL; EXPRESSION(FSYS);
              IF GATTR.TYPTR <> NIL THEN
                IF GATTR.TYPTR@.FORM <= POWER THEN LOAD
                ELSE LOADADDRESS;
              IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
                BEGIN
                  IF COMPTYPES(REALPTR,LATTR.TYPTR)AND(GATTR.TYPTR=INTPTR)THEN
                    BEGIN GEN0(10(*FLT*));
                      GATTR.TYPTR := REALPTR
                    END;
                  IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
                    BEGIN

#                     IF DEBUG THEN
#                       BEGIN
#                       ASSIGN := TRUE ;  CHKBNDS(LATTR.TYPTR);  ASSIGN := FALSE
#                       END ;

                      CASE LATTR.TYPTR@.FORM OF
                        SCALAR,
                        SUBRANGE,
                        POINTER,
                        POWER:   STORE(LATTR);
                        ARRAYS,
                        RECORDS: GEN1(40(*MOV*),LATTR.TYPTR@.SIZE);
                        FILES: ERROR(146)
                      END  (*CASE LATTR...*)
#                   END
                  ELSE ERROR(129)
                END
            END (*SY = BECOMES*)
          ELSE ERROR(51)
        END (*ASSIGNMENT*) ;

        PROCEDURE GOTOSTATEMENT;
          VAR LLP: LBP; FOUND: BOOLEAN; TTOP,TTOP1: DISPRANGE;
        BEGIN
          IF SY = INTCONST THEN
            BEGIN
              FOUND := FALSE;  TTOP := TOP;
#             WHILE DISPLAY[TTOP].OCCUR <> BLCK DO TTOP := TTOP - 1;
#             TTOP1 := TTOP;
#             REPEAT
                LLP := DISPLAY[TTOP].FLABEL;
                WHILE (LLP <> NIL) AND NOT FOUND DO
                  WITH LLP@ DO
                    IF LABVAL = VAL.IVAL THEN
                      BEGIN FOUND := TRUE;
                        IF TTOP = TTOP1 THEN
                          BEGIN
                          GENUJPFJP(57(*UJP*),LABNAME) ;
"CT"                      CTREMIT(CTRGOTO, 0, LINECNT, 0, LINECNT)
                          END
                        ELSE (*GOTO LEADS OUT OF PROCEDURE*) ERROR(398)
                      END
                    ELSE LLP := NEXTLAB;
                TTOP := TTOP - 1
              UNTIL FOUND OR (TTOP = 0);
              IF NOT FOUND THEN ERROR(167);
              INSYMBOL
            END
          ELSE ERROR(15)
        END (*GOTOSTATEMENT*) ;

        PROCEDURE COMPOUNDSTATEMENT;
        BEGIN
          REPEAT
            REPEAT STATEMENT(FSYS + [SEMICOLON,ENDSY])
            UNTIL NOT (SY IN STATBEGSYS);
            TEST := SY <> SEMICOLON;
            IF NOT TEST THEN INSYMBOL
          UNTIL TEST;
          IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
        END (*COMPOUNDSTATEMENET*) ;

        PROCEDURE IFSTATEMENT;
          VAR LCIX1,LCIX2: INTEGER;
"CT"          FIRSTLN, MIDLN : INTEGER;   CTRNO : CTRRANGE;
        BEGIN EXPRESSION(FSYS + [THENSY]);
          GENLABEL(LCIX1); GENFJP(LCIX1);
          IF SY = THENSY THEN INSYMBOL ELSE ERROR(52);
"CT"      FIRSTLN := LINECNT; CTRNO := CTRGEN;
"CT"      (*** COUNTER HERE ***)

          STATEMENT(FSYS + [ELSESY]);
          IF SY = ELSESY THEN
            BEGIN GENLABEL(LCIX2); GENUJPFJP(57(*UJP*),LCIX2);
              PUTLABEL(LCIX1);
              INSYMBOL;
"CT"          MIDLN := LINECNT ;
              STATEMENT(FSYS);
              PUTLABEL(LCIX2)
            END
          ELSE
            BEGIN
            PUTLABEL(LCIX1) ;
"CT"        MIDLN := 0;
            END ;
"CT"      CTREMIT(CTRIF, CTRNO, FIRSTLN, MIDLN, LINECNT)
        END (*IFSTATEMENT*) ;

        PROCEDURE CASESTATEMENT;
          LABEL 1, 2;
          TYPE CIP = @CASEINFO;
               CASEINFO = PACKED
                          RECORD NEXT: CIP;
                            CSSTART: INTEGER;
                            CSLAB: INTEGER
                          END;
#         VAR LSP,LSP1: STP; FSTPTR,LPT1,LPT2,LPT3: CIP; LVAL,LVAL1: VALU;
#             LADDR, LCIX, LCIX1, UBND, LBND: ADDRRANGE ;
#             LMIN, LMAX : INTEGER ;
"CT"          FIRSTLN : INTEGER; TEMPLN  : INTEGER;
"CT"          CTRCASES : INTEGER; CTRNO : CTRRANGE;
        BEGIN EXPRESSION(FSYS + [OFSY,COMMA,COLON]);
#         LOAD ; " ALIGN(LC,INTSIZE) ;  LLC := LC ; "
#         LSP := GATTR.TYPTR;
#         IF LSP <> NIL THEN
#           IF (LSP@.FORM <> SCALAR) OR (LSP = REALPTR) THEN
#             BEGIN  ERROR(144); LSP := NIL END
#           ELSE  IF NOT COMPTYPES(LSP,INTPTR) THEN  GEN0(61(*ORD*)) ;
#         IF DEBUG THEN  CHKBNDS(GATTR.TYPTR) ;
          IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
#         FSTPTR := NIL ;  GENLABEL(LBND) ;  GENLABEL(UBND) ;
#         GENLABEL(LCIX) ;  GENLABEL(LADDR);
#         (* WE SHOULD HAVE:  LADDR = LCIX+1 = UBND+2 = LBND+3   HERE *)
#         GENUJPFJP(44 (*XJP*), LBND) ;  "GENCASE(LBND,UBND,LCIX) ; "
"CT"      FIRSTLN := LINECNT;  CTRCASES := 0;
#         LMAX := CIXMAX;
          REPEAT
            LPT3 := NIL; GENLABEL(LCIX1);
#           IF NOT(SY IN [SEMICOLON,ENDSY]) THEN
#           BEGIN
              REPEAT CONSTANT(FSYS + [COMMA,COLON,DOTDOT],LSP1,LVAL);
                IF LSP <> NIL THEN
                  IF COMPTYPES(LSP,LSP1) THEN
#                   BEGIN
#          """      IF LSP = CHARPTR THEN  LVAL.IVAL := EBCDIC[CHR(LVAL.IVAL)];"
#                   LVAL1.IVAL := LVAL.IVAL ;
#                   IF SY = DOTDOT THEN
#                     BEGIN  INSYMBOL ;
#                     CONSTANT(FSYS+[COMMA,COLON],LSP1,LVAL1)
#                     END ;
#                   IF COMPTYPES(LSP,LSP1) THEN
#                       FOR LMIN := LVAL.IVAL TO LVAL1.IVAL DO
                          BEGIN LPT1 := FSTPTR; LPT2 := NIL;
#                         LMAX := LMAX-1;
#                         IF LMAX <= 0 THEN
#                           BEGIN  ERROR(157);  GOTO 2  END;
                          WHILE LPT1 <> NIL DO
                            WITH LPT1@ DO
                              BEGIN
                              IF CSLAB <= LMIN THEN
                                BEGIN
                                IF CSLAB = LMIN THEN ERROR(156);
                                GOTO 1
                                END;
                              LPT2 := LPT1; LPT1 := NEXT
                              END;
            1:            NEW(LPT3);
                          WITH LPT3@ DO
                            BEGIN NEXT := LPT1; CSLAB := LMIN ;
                            CSSTART := LCIX1
                            END;
                          IF LPT2 = NIL THEN FSTPTR := LPT3
                          ELSE LPT2@.NEXT := LPT3
                         END
                    ELSE ERROR(147);
                    END ;
                TEST := SY <> COMMA;
                IF NOT TEST THEN INSYMBOL
              UNTIL TEST;
#         2:
              IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
              PUTLABEL(LCIX1);
"CT"          TEMPLN := LINECNT; (*** COUNTER HERE ***)
"CT"          CTRNO := CTRGEN;  CTRCASES := CTRCASES+1 ;
              REPEAT STATEMENT(FSYS + [SEMICOLON])
              UNTIL NOT (SY IN STATBEGSYS);
              IF LPT3 <> NIL THEN
                GENUJPFJP(57(*UJP*),LADDR);
"CT"          CTREMIT(CTRCASE, CTRNO, TEMPLN, 0, LINECNT);
#           END ;
            TEST := SY <> SEMICOLON;
            IF NOT TEST THEN INSYMBOL ;
          UNTIL TEST;
          IF FSTPTR <> NIL THEN
            BEGIN LMAX := FSTPTR@.CSLAB;
              (*REVERSE POINTERS*)
              LPT1 := FSTPTR; FSTPTR := NIL;
              REPEAT LPT2 := LPT1@.NEXT; LPT1@.NEXT := FSTPTR;
                FSTPTR := LPT1; LPT1 := LPT2
              UNTIL LPT1 = NIL;
              LMIN := FSTPTR@.CSLAB;

#           END
#         ELSE  BEGIN  LMIN := 1 ;  LMAX := 0  END ;
#         GENDEF(LBND,LMIN) ;  GENDEF(UBND,LMAX) ;  PUTLABEL(LCIX) ;
          IF LMAX - LMIN < CIXMAX THEN
#           BEGIN
#           IF FSTPTR <> NIL THEN
              REPEAT
                WITH FSTPTR@ DO
                  BEGIN
                    WHILE CSLAB > LMIN DO
                      BEGIN GENUJPFJP(57(*UJP*),LADDR); LMIN:=LMIN+1 END;
                    GENUJPFJP(57(*UJP*),CSSTART);
                    FSTPTR := NEXT; LMIN := LMIN + 1
                  END
              UNTIL FSTPTR = NIL;
              PUTLABEL(LADDR) ;
"CT"          CTREMIT(CTRCASE, 0, FIRSTLN, CTRCASES, LINECNT);
            END
          ELSE ERROR(157) ;
          IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
        END (*CASESTATEMENT*) ;

        PROCEDURE REPEATSTATEMENT;
          VAR LADDR: INTEGER;
"CT"            FIRSTLN : INTEGER; CTRNO : CTRRANGE;
        BEGIN GENLABEL(LADDR); PUTLABEL(LADDR);
"CT"      FIRSTLN := LINECNT; CTRNO := CTRGEN;
"CT"      (*** COUNTER HERE ***)
          REPEAT
            REPEAT STATEMENT(FSYS + [SEMICOLON,UNTILSY])
            UNTIL NOT (SY IN STATBEGSYS);
            TEST := SY <> SEMICOLON;
            IF NOT TEST THEN INSYMBOL
          UNTIL TEST;
          IF SY = UNTILSY THEN
            BEGIN INSYMBOL; EXPRESSION(FSYS); GENFJP(LADDR) ;
"CT"            CTREMIT(CTRREPEAT, CTRNO, FIRSTLN, 0, LINECNT)
            END
          ELSE ERROR(53)
        END (*REPEATSTATEMENT*) ;

        PROCEDURE WHILESTATEMENT;
          VAR LADDR, LCIX: INTEGER;
"CT"          FIRSTLN : INTEGER; CTRNO : CTRRANGE;
        BEGIN GENLABEL(LADDR); PUTLABEL(LADDR);
          EXPRESSION(FSYS + [DOSY]); GENLABEL(LCIX); GENFJP(LCIX);
          IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
"CT"      FIRSTLN := LINECNT; CTRNO := CTRGEN;
          (*** COUNTER HERE ***)
          STATEMENT(FSYS); GENUJPFJP(57(*UJP*),LADDR); PUTLABEL(LCIX) ;
"CT"      CTREMIT(CTRWHILE, CTRNO, FIRSTLN, 0, LINECNT);
        END (*WHILESTATEMENT*) ;

        PROCEDURE FORSTATEMENT;
          VAR LATTR: ATTR; LSP: STP;  LSY: SYMBOL;
#             LCIX, LADDR: LABELRNG ;  LLC : ADDRRANGE ;
"CT"          FIRSTLN : INTEGER; CTRNO : CTRRANGE;
        BEGIN
          IF SY = IDENT THEN
            BEGIN SEARCHID([VARS],LCP);
              WITH LCP@, LATTR DO
#               BEGIN TYPTR := IDTYPE; KIND := VARBL; BTYPE := TYPTR ;
                  IF VKIND = ACTUAL THEN
                    BEGIN ACCESS := DRCT; VLEVEL := VLEV;
                      DPLMT := VADDR ;
(*+RM                 IF GET_STAT THEN                                       +*)
(*+RM                   WRITE(QRR, ' #MOD', CHR( GETTYPE(BTYPE) ), ' ':2,    +*)
(*+RM                              ' #DIR', VLEVEL:3, DPLMT:8, ' #MND   ' ) ;+*)
                    END
                  ELSE BEGIN ERROR(155); TYPTR := NIL END
                END;
              IF LATTR.TYPTR <> NIL THEN
                IF (LATTR.TYPTR@.FORM > SUBRANGE)
                   OR COMPTYPES(REALPTR,LATTR.TYPTR) THEN
                  BEGIN ERROR(143); LATTR.TYPTR := NIL END;
              INSYMBOL
            END
          ELSE
            BEGIN ERROR(2); SKIP(FSYS + [BECOMES,TOSY,DOWNTOSY,DOSY]) END;
          IF SY = BECOMES THEN
            BEGIN INSYMBOL; EXPRESSION(FSYS + [TOSY,DOWNTOSY,DOSY]);
              IF GATTR.TYPTR <> NIL THEN
                  IF GATTR.TYPTR@.FORM <> SCALAR THEN ERROR(144)
                  ELSE
                    IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
                      BEGIN LOAD;
#                     "IF DEBUG THEN CHKBNDS(LATTR.TYPTR) ;"  STORE(LATTR) ;
                      END
                    ELSE ERROR(145)
            END
          ELSE
            BEGIN ERROR(51); SKIP(FSYS + [TOSY,DOWNTOSY,DOSY]) END;
          IF SY IN [TOSY,DOWNTOSY] THEN
            BEGIN LSY := SY; INSYMBOL; EXPRESSION(FSYS + [DOSY]);
              IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM <> SCALAR THEN ERROR(144)
                ELSE
                  IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
#                   BEGIN  LOAD;  "IF DEBUG THEN  CHKBNDS(LATTR.TYPTR) ;"
#                     ALIGN(LC,INTSIZE) ;  LLC := LC ;
#                     IF GATTR.BTYPE <> INTPTR THEN  GEN0(61(*ORD*));
#                     GEN3(56(*STR*),ORD('I'),LEVEL,LLC);
#                     GATTR := LATTR; LOAD;
#                     IF GATTR.BTYPE <> INTPTR THEN  GEN0(61(*ORD*));
#                     GEN3(54(*LOD*),ORD('I'),LEVEL,LLC);
#                     IF LSY = TOSY THEN GEN2(52(*LEQ*),ORD('I'),1)
#                     ELSE GEN2(48(*GEQ*),ORD('I'),1);
#                     LC := LC + INTSIZE;
#                     IF LC > LCMAX THEN LCMAX := LC;
                    END
                  ELSE ERROR(145)
            END
          ELSE BEGIN ERROR(55); SKIP(FSYS + [DOSY]) END;
#         GENLABEL(LADDR) ;  GENLABEL(LCIX);  GENUJPFJP(33(*FJP*),LCIX);
#         PUTLABEL(LADDR) ;  (*BEGINNING OF THE FOR 'LOOP'*)
          IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
"CT"      FIRSTLN := LINECNT; CTRNO := CTRGEN;
          (*** COUNTER HERE ***)
          STATEMENT(FSYS);
#         GATTR := LATTR ;  LOAD ;
#         IF GATTR.BTYPE <> INTPTR THEN  GEN0(61(*ORD*));
#         GEN3(54(*LOD*),ORD('I'),LEVEL,LLC) ;
#         GEN2(55(*NEQ*),ORD('I'),1);
#         GENUJPFJP(33(*FJP*),LCIX) ;
#         GATTR := LATTR; LOAD;
#         IF LSY = TOSY THEN  GEN2(23(*INC*),GETTYPE(GATTR.BTYPE),1)
#         ELSE  GEN2(22(*DEC*),GETTYPE(GATTR.BTYPE),1);
#         IF DEBUG THEN CHKBNDS(LATTR.TYPTR) ;
          STORE(LATTR); GENUJPFJP(57(*UJP*),LADDR); PUTLABEL(LCIX);
          LC := LLC ;
"CT"      CTREMIT(CTRFOR, CTRNO, FIRSTLN, 0, LINECNT);
        END (*FORSTATEMENT*) ;

        PROCEDURE WITHSTATEMENT;
#         VAR LCP: CTP; LCNT: DISPRANGE; LLC: ADDRRANGE;
        BEGIN LCNT := TOP ; LLC := LC ;
          REPEAT
            IF SY = IDENT THEN
              BEGIN SEARCHID([VARS,FIELD],LCP); INSYMBOL END
            ELSE BEGIN ERROR(2); LCP := UVARPTR END;
            SELECTOR(FSYS + [COMMA,DOSY],LCP);
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM = RECORDS THEN
                IF TOP < DISPLIMIT THEN
#                 BEGIN  TOP := TOP + 1;
                    WITH DISPLAY[TOP] DO
                      BEGIN FNAME := GATTR.TYPTR@.FSTFLD;
                        FLABEL := NIL
                      END;
                    IF GATTR.ACCESS = DRCT THEN
                      WITH DISPLAY[TOP] DO
                        BEGIN OCCUR := CREC; CLEV := GATTR.VLEVEL;
                          CDSPL := GATTR.DPLMT
                        END
                    ELSE
#                     BEGIN  LOADADDRESS;  ALIGN(LC,PTRSIZE) ;
#                     GEN3(56(*STR*),ORD('A'),LEVEL,LC);(*=GETTYPE(GAT.TYP)*)
                        WITH DISPLAY[TOP] DO
                          BEGIN OCCUR := VREC; VDSPL := LC END;
#                       LC := LC + PTRSIZE;
                        IF LC > LCMAX THEN LCMAX := LC
                      END
                  END
                ELSE ERROR(250)
              ELSE ERROR(140);
            TEST := SY <> COMMA;
            IF NOT TEST THEN INSYMBOL
          UNTIL TEST;
          IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
          STATEMENT(FSYS);
#         TOP :=  LCNT ; LC := LLC ;
        END (*WITHSTATEMENT*) ;

      BEGIN (*STATEMENT*)
        IF SY = INTCONST THEN (*LABEL*)
#         BEGIN  TTOP := TOP ;
#         WHILE DISPLAY[TTOP].OCCUR <> BLCK DO  TTOP := TTOP-1 ;
#         LLP := DISPLAY[TTOP].FLABEL;
            WHILE LLP <> NIL DO
              WITH LLP@ DO
                IF LABVAL = VAL.IVAL THEN
                  BEGIN IF DEFINED THEN ERROR(165);
                    PUTLABEL(LABNAME); DEFINED := TRUE;
"CT"                CTRNO := CTRGEN;
"CT"                CTREMIT(CTRLBL, CTRNO, LINECNT, 0, LINECNT);
"CT"                (*** COUNTER HERE ***)
                    GOTO 1
                  END
                ELSE LLP := NEXTLAB;
            ERROR(167);
      1:    INSYMBOL;
            IF SY = COLON THEN INSYMBOL ELSE ERROR(5)
          END;
        IF NOT (SY IN FSYS + [IDENT]) THEN
          BEGIN ERROR(6); SKIP(FSYS) END;
        IF SY IN STATBEGSYS + [IDENT] THEN
          BEGIN
            CASE SY OF
              IDENT:    BEGIN SEARCHID([VARS,FIELD,FUNC,PROC],LCP); INSYMBOL;
                          IF LCP@.KLASS = PROC THEN CALL(FSYS,LCP)
                          ELSE ASSIGNMENT(LCP)
                        END;
              BEGINSY:  BEGIN INSYMBOL; COMPOUNDSTATEMENT END;
              GOTOSY:   BEGIN INSYMBOL; GOTOSTATEMENT END;
              IFSY:     BEGIN INSYMBOL; IFSTATEMENT END;
              CASESY:   BEGIN INSYMBOL; CASESTATEMENT END;
              WHILESY:  BEGIN INSYMBOL; WHILESTATEMENT END;
              REPEATSY: BEGIN INSYMBOL; REPEATSTATEMENT END;
              FORSY:    BEGIN INSYMBOL; FORSTATEMENT END;
              WITHSY:   BEGIN INSYMBOL; WITHSTATEMENT END
            END;
            IF NOT (SY IN [SEMICOLON,ENDSY,ELSESY,UNTILSY]) THEN
              BEGIN ERROR(6); SKIP(FSYS) END
          END
      END (*STATEMENT*) ;


    BEGIN (*BODY*)
#     IF FPROCP <> NIL THEN
#       BEGIN  ENTNAME := FPROCP@.PFNAME ;  PROCNAME := FPROCP@.NAME ; END
#     ELSE  BEGIN  ENTNAME := 0 ;  PROCNAME := '$MAINBLK    ' ;
            IF XLINK THEN PROCNAME[1] := '#' ;
            END ;
#     NAMFLAG := XLINK ;
#     GENCUPENT(32(*ENT*),PROCTYPE(FPROCP),SEGSIZE,ENTNAME,PROCNAME) ;
#     STIC := 0 ;     (* LENGTH OF STRING CONSTANTS *)
#
(*+CG NEW(CALL_HEAD) ;                                                        *)
(*+CG CALL_HEAD@.NAME := BLANKID ; CALL_HEAD@.NXT := NIL ;                    *)
(*+CG MODIFYING := FALSE ;                                                    *)
#     LOCAL_CALL := FALSE ;
#     VAR_REF := 0 ;  VAR_MOD := 0 ;
#     WRITELN(QRR, '#BGN    ', PROCNAME, LEVEL:4) ;
#
#
#     IF FPROCP = NIL THEN  (* ENTERING MAIN BLOCK *)
        BEGIN
        WHILE FILEHEAD <> NIL DO
          BEGIN
            WITH FILEHEAD@ DO
               BEGIN """ID := FILENAME;
               PRTERR := FALSE ;  SEARCHID([VARS],LLCP); PRTERR := TRUE ;
               IF LLCP <> NIL THEN
                 IF LLCP@.IDTYPE@.FORM <> FILES THEN
                   LLCP := NIL;
#              IF LLCP = NIL THEN
#                BEGIN
#                  WRITELN('**** UNDECLARED EXTERNAL FILE:':40, ID:10);
#                  ERROR(398) ;
#                END
#              ELSE (* OPEN THE FILES REQUESTED ABOVE *)   """

#                WITH FILIDPTR@ DO
#                  BEGIN
#                " IF GEBCDF THEN GEN2(50(*LDA*),1,VADDR+1000)
#                  ELSE"
#                  GEN2(50(*LDA*),1,VADDR) ;
#                  GEN1(30(*CSP*),31(*SIO*)) ;
#
"CM"               IF VADDR >= FIRSTUSERF THEN  (* USER DEFINED FILES *)
"CM"                 BEGIN
"CM"                 NEW(CNSTPTR, STRG) ;
"CM"                 CNSTPTR@.SLNGTH := 8 "IDLNGTH" ;
"CM"                 FOR I := 1 TO 8 "IDLNGTH" DO CNSTPTR@.SVAL[I] := NAME[I] ;
"CM"                 GEN1(37(*LCA*), 0) ;
"CM"                 GEN1(30(*CSP*), 30(*FDF*)) ;
"CM"                 END
"CM"               ELSE  (* I.E. IF VADDR < FIRSTUSERF *)
#                    IF ODD(VADDR) THEN  GEN1(30(*CSP*),4(*REW*))
#                    ELSE  GEN1(30(*CSP*),3(*RES*)) ;
#
#                  GEN1(30(*CSP*),32(*EIO*)) ;
#                  END ;
               END;
          FILEHEAD := FILEHEAD@.NEXTFILE
          END;
"CT"    IF CTROPTION THEN
"CT"      BEGIN
"CT"      GENLABEL(CTRCNTLBL) ;   GENUJPFJP(38(*CTS*), CTRCNTLBL) ;
"CT"      END ;
        END (* PROCESSING MAIN BLOCK *)
      ELSE (* FPROCP <> NIL ==> COPY MULTIPLE VALUES INTO LOACAL CELLS*)
#       BEGIN  LLC1 := LCAFTMST ;
#       IF FPROCP@.SAVEFP THEN LLC1 := LCAFTMST+FPSAVEAREA ;
          LCP := FPROCP@.NEXT;
          WHILE LCP <> NIL DO
            WITH LCP@ DO
              BEGIN
                IF KLASS = VARS THEN
                  IF IDTYPE <> NIL THEN
#                   IF VKIND = FORMAL THEN  (* VAR PARAMETER *)
#                     BEGIN  ALIGN(LLC1,PTRSIZE) ;
#                     LLC1 := LLC1+PTRSIZE ;
#                     END
#                   ELSE  (* VKIND = ACTUAL *)
#                     IF IDTYPE@.FORM > POWER THEN
#                       BEGIN
#                       ALIGN(LLC1,PTRSIZE) ;
#                       GEN2(50(*LDA*),LEVEL,VADDR);
#                       GEN3(54(*LOD*),ORD('A'),LEVEL,LLC1);
#                       GEN1(40(*MOV*),IDTYPE@.SIZE);
#                       LLC1 := LLC1 + PTRSIZE
#                       END
#                     ELSE  (* FORM <= POWER *)
#                       BEGIN
#                       ALIGN(LLC1,IDTYPE@.ALN) ;  LLC1 := LLC1 + IDTYPE@.SIZE ;
#                       END ;
                LCP := LCP@.NEXT;
              END;
        END;
"CT"  FIRSTLN := LINECNT; CTRNO := CTRGEN;
"CT"  (*** COUNTER HERE ***)
      LCMAX := LC;

      (* COMPILE THE STATEMENTS WITHIN THIS BLOCK (BODY) *)

      REPEAT
        REPEAT STATEMENT(FSYS + [SEMICOLON,ENDSY])
        UNTIL NOT (SY IN STATBEGSYS);
        TEST := SY <> SEMICOLON;
        IF NOT TEST THEN INSYMBOL
      UNTIL TEST;

      IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13);
      LLP := DISPLAY[TOP].FLABEL; (*TEST FOR UNDEFINED LABELS*)

      WHILE LLP <> NIL DO
        WITH LLP@ DO
          BEGIN
            IF NOT DEFINED THEN
              BEGIN
#               WRITELN(OUTPUT,'**** UNDEF. LABEL:':23,LABVAL); ERROR(168) ;
              END;
            LLP := NEXTLAB
          END;

"CT"  CTREMIT(CTRPROC, CTRNO, FIRSTLN, 0, LINECNT);
"CT"  IF FPROCP = NIL THEN            (* RESET COUNTERS *)
"CT"    BEGIN
"CT"    CTREMIT(CTRPROC, 0, 0, 0, 0); (* EOF FOR COUNTER TABLE *)
"CT"    IF ODD(CTRCNT) THEN  CTRCNT := CTRCNT+1 ;
"CT"    IF CTROPTION THEN  GENDEF(CTRCNTLBL, CTRCNT) ;
"CT"    END ;

#     GEN1(42(*RET*),PROCTYPE(FPROCP)); ALIGN(LCMAX,MXDATASZE) ;
#     IF PRCODE THEN
        BEGIN  GENDEF(SEGSIZE,LCMAX) ;
        IF FPROCP = NIL THEN  GEN0(43(*STP*) ) ;
        END ;
       "IF (FPROCP = NIL) AND  PRTABLES THEN PRINTTABLES(TRUE) "

#
#   CALL_LVL[LOCAL_CALL] := CALL_LVL[LOCAL_CALL]+1 ;
#   WRITELN(QRR) ;
#   WRITE(QRR, '#PROC   ':8,  PROCNAME:IDLNGTH, '   ', LOCAL_CALL:1,
#              IC+(STIC DIV 4):6, LCMAX:8, ' ', FLIPDEBUG:1,
#              '  REF./MOD. RATIO:', VAR_MOD:4, VAR_MOD+VAR_REF:6) ;
#   IF (VAR_MOD+VAR_REF) = 0 THEN  WRITELN(QRR,0.0:10)
#   ELSE  WRITELN(QRR, VAR_MOD/(VAR_MOD+VAR_REF):10) ;
(*+CG WHILE CALL_HEAD@.NXT <> NIL DO                                          *)
(*+CG   BEGIN                                                                 *)
(*+CG   WRITE(QRR, ' ', CALL_HEAD@.NAME, CALL_HEAD@.LVL:3, CALL_HEAD@.CNT: 4);*)
(*+CG   CALL_HEAD :=  CALL_HEAD@.NXT ;                                        *)
(*+CG   END ;                                                                 *)
#   WRITELN(QRR) ;  WRITELN(QRR, '#END') ;
#
#   OLDIC := OLDIC+ IC ;  IC := OLDIC ;  (* DISPLAY CUMULATIVE IC  *)
#   HP := TRUE;
    END (*BODY*) ;

"S1" "                                                                         "
"S1" "  PROCEDURE MKNAME(VAR ALB: ALPHA; NLB: INTEGER ) ;                      "
"S1" "    VAR I, J: INTEGER ;                                                  "
"S1" "                                                                         "
"S1" "  BEGIN                                                                  "
"S1" "    I := 1 ;                                                             "
"S1" "    WHILE (I < 6) AND (ALB[I] <> ' ') DO                                 "
"S1" "      BEGIN  IF ALB[I] = '_' THEN  ALB[I] := '$' ;  I := I+1  END ;      "
"S1" "    FOR J := 8 DOWNTO I DO                                               "
"S1" "      BEGIN                                                              "
"S1" "      ALB[J] := CHR( ORD('0')+ NLB MOD 10 ) ;                            "
"S1" "      NLB := NLB DIV 10 ;                                                "
"S1" "      END ;                                                              "
"S1" "  END (*MKNAME*) ;                                                       "


  BEGIN (*BLOCK*)
    "DP := TRUE;"  IC := 0;  GENLABEL(SEGSIZE) ;
    REPEAT
      IF SY = LABELSY THEN
        BEGIN INSYMBOL; LABELDECLARATION END;
      IF SY = CONSTSY THEN
        BEGIN INSYMBOL; CONSTDECLARATION END;
      IF SY = TYPESY THEN
        BEGIN   INSYMBOL; TYPEDECLARATION;  END;
      IF SY = VARSY THEN
        BEGIN  DP := TRUE;  INSYMBOL;  VARDECLARATION;  DP := FALSE;   END;
"S1" "                                                                         "
"S1" "  WRITE(PRR, ' SST ', CHR( PROCTYPE(FPROCP) ):1, '  ') ;                 "
"S1" "  IF FPROCP = NIL THEN                                                   "
"S1" "    WRITELN(PRR, '$MAINBLK', 1:3, 0:4, 0:4, LC-LASTFILBUF:8, 0:4)        "
"S1" "  ELSE                                                                   "
"S1" "    WITH FPROCP@ DO                                                      "
"S1" "      BEGIN  ID := NAME ;  MKNAME(ID, PFNAME) ;  ALIGN(LC,MXDATASZE) ;   "
"S1" "      WRITELN(PRR, ID:8, PFLEV+1:3, FPRMSZE:4, SPRMSZE:4,                "
"S1" "                   LC-LCAFTMST-FPRMSZE-SPRMSZE:8, RPRMSZE:4) ;           "
"S1" "      END ;                                                              "
"S1" "                                                                         "
      WHILE SY IN [PROCSY,FUNCSY] DO
        BEGIN LSY := SY; INSYMBOL; PROCDECLARATION(LSY) END;
      IF SY <> BEGINSY THEN
        BEGIN ERROR(18); SKIP(FSYS) END
    UNTIL SY IN STATBEGSYS;
    " DP := FALSE;  IC := 0; "(*RESET PROGRAM COUNTER*)
    IF SY = BEGINSY THEN INSYMBOL ELSE ERROR(17);
    REPEAT BODY(FSYS + [CASESY]);
      IF SY <> FSY THEN
        BEGIN ERROR(6); SKIP(FSYS + [FSY]) END
    UNTIL (SY = FSY) OR (SY IN BLOCKBEGSYS);
#  "DP := TRUE;"
  END (*BLOCK*) ;


  PROCEDURE PROGRAMME(FSYS:SETOFSYS);
#   VAR   LFPTR: FRECPTR ;   LCP : CTP ;
  BEGIN
#   (*REWRITE(QRR) ;         USED FOR P_TBL, SYM_TBL, CTR_TBL *)
#   (*REWRITE(PRR) ;         USED FOR P_CODE OUTPUT *)
#   CALL_LVL[FALSE] := 0 ;  CALL_LVL[TRUE] := 0 ;
    IF SY = PROGSY THEN
#     BEGIN INSYMBOL; IF SY <> IDENT THEN ERROR(2); PROGNAME := ID ; INSYMBOL;
        IF NOT (SY IN [LPARENT,SEMICOLON]) THEN ERROR(14);
        IF SY = LPARENT  THEN
          BEGIN
            REPEAT INSYMBOL;
              IF SY = IDENT THEN
#               BEGIN  SEARCHID([VARS], LCP) ;
#               IF LCP@.IDTYPE <> TEXTPTR THEN  ERROR(103)
#               ELSE
#                 BEGIN  NEW(LFPTR);
#                 WITH LFPTR@ DO
#                   BEGIN  FILIDPTR := LCP ;  NEXTFILE := FILEHEAD ;
#                 " GEBCDF := EBCDFLG ; EBCDFLG := FALSE "
#                   END;
#                 FILEHEAD := LFPTR;
#                 END ;
                INSYMBOL;
                IF NOT ( SY IN [COMMA,RPARENT] ) THEN ERROR(20)
                END
              ELSE ERROR(2)
            UNTIL SY <> COMMA;
            IF SY <> RPARENT THEN ERROR(4);
            INSYMBOL
          END;
        IF SY <> SEMICOLON THEN ERROR(14)
        ELSE INSYMBOL;
      END;

"E" IF DEBUG THEN
"E"     BEGIN   "REWRITE(QRR) ;"
"E"     WRITELN(QRR,'% $MAINBLK  0');
"E"     END ;

    REPEAT BLOCK(FSYS,PERIOD,NIL);
      IF SY <> PERIOD THEN ERROR(21)
    UNTIL SY = PERIOD ;
#   WRITELN(QRR,'#HLT  CALL_RATIO', CALL_LVL[TRUE]:4, CALL_LVL[FALSE]:4,
#                  CALL_LVL[TRUE]+CALL_LVL[FALSE]:4) ;
#   IF ERRINX > 0 THEN  PRINTERROR ;
  END (*PROGRAMME*) ;


  PROCEDURE STDNAMES;
  BEGIN
    NA[ 1] := 'FALSE       '; NA[ 2] := 'TRUE        ';
    NA[ 4] := 'PAGE        '; NA[ 5] := 'GET         '; NA[ 6]:= 'PUT         ';
    NA[ 7] := 'RESET       '; NA[ 8] := 'REWRITE     '; NA[ 9]:= 'READ        ';
    NA[10] := 'WRITE       '; NA[11] := 'PACK        '; NA[12]:= 'UNPACK      ';
    NA[13] := 'NEW         '; NA[14] := 'RELEASE     '; NA[15]:= 'READLN      ';
    NA[16] := 'WRITELN     '; NA[17] := 'MARK        '; NA[18]:= 'TRAP        ';
    NA[19] := 'EXIT        ';
    NA[20] := 'ABS         '; NA[21] := 'SQR         '; NA[22]:= 'TRUNC       ';
    NA[23] := 'ROUND       '; NA[24] := 'ORD         '; NA[25]:= 'CHR         ';
    NA[26] := 'PRED        '; NA[27] := 'SUCC        '; NA[28]:= 'CLOCK       ';
    NA[29] := 'EOF         '; NA[30] := 'EOLN        ';
    NA[31] := 'SIN         '; NA[32] := 'COS         '; NA[33]:= 'EXP         ';
    NA[34] := 'SQRT        '; NA[35] := 'LN          '; NA[36]:= 'ARCTAN      ';
    NA[37] := 'ODD         ';
#   NA[39] := 'INPUT       '; NA[40] := 'OUTPUT      '; NA[41]:= 'PRD         ';
#   NA[42] := 'PRR         '; NA[43] := 'QRD         '; NA[44]:= 'QRR         ';
#   NA[45] := 'DATE        '; NA[46] := 'TIME        ';
"NH"NA[47] := 'MESSAGE     '; NA[48] := 'SKIP        ';
"NH"NA[49] := 'LINELIMIT   '; NA[50] := 'CARD        ';
"NH"NA[51] := 'EXPO        ';
#   NA[52] := 'DSIN        '; NA[53] := 'DCOS        '; NA[54]:= 'DEXP        ';
#   NA[55] := 'DSQRT       '; NA[56] := 'DLOG        '; NA[57]:= 'DATAN       ';
  END (*STDNAMES*) ;


  PROCEDURE ENTERSTDTYPES;
    VAR SP: STP;
  BEGIN                                                  (*TYPE UNDERLIEING:  *)
                                                         (******************  *)

    NEW(INTPTR,SCALAR,STANDARD);                              (*INTEGER       *)
    WITH INTPTR@ DO
      BEGIN SIZE := INTSIZE; ALN := INTSIZE ;
            FORM := SCALAR; SCALKIND := STANDARD END;
    NEW(REALPTR,SCALAR,STANDARD);                             (*REAL          *)
    WITH REALPTR@ DO
      BEGIN SIZE := REALSIZE; ALN := MXDATASZE ;
            FORM := SCALAR; SCALKIND := STANDARD END;
    NEW(CHARPTR,SCALAR,STANDARD);                             (*CHAR          *)
    WITH CHARPTR@ DO
      BEGIN SIZE := CHARSIZE; ALN := CHARSIZE ;
            FORM := SCALAR; SCALKIND := STANDARD END;
    NEW(BOOLPTR,SCALAR,DECLARED);                             (*BOOLEAN       *)
    WITH BOOLPTR@ DO
      BEGIN SIZE := BOOLSIZE; ALN := BOOLSIZE ;
            FORM := SCALAR; SCALKIND := DECLARED END;
    NEW(NILPTR,POINTER);                                      (*NIL           *)
    WITH NILPTR@ DO
      BEGIN ELTYPE := NIL; SIZE := PTRSIZE; ALN := PTRSIZE ;
            FORM := POINTER END;
    NEW(TEXTPTR,FILES);                                       (*TEXT          *)
    WITH TEXTPTR@ DO
      BEGIN FILTYPE := CHARPTR; SIZE := CHARSIZE; ALN := CHARSIZE ;
            FORM := FILES  END ;
    NEW(ALFAPTR,ARRAYS);                                      (*ALFA          *)
    WITH ALFAPTR@ DO
      BEGIN  AELTYPE := CHARPTR; SIZE := ALFALNGTH ; ALN := CHARSIZE ;
            FORM := ARRAYS ;
            NEW(INXTYPE,SUBRANGE) ;
            INXTYPE@.FORM := SUBRANGE ;  INXTYPE@.RANGETYPE := INTPTR;
            INXTYPE@.MIN.IVAL := 1; INXTYPE@.MAX.IVAL := 10;
            (* OTHER FIELDS ARE IRRELEVENT !!! *)
      END ;
  END (*ENTERSTDTYPES*) ;

  PROCEDURE ENTSTDNAMES;
    VAR CP,CP1: CTP; I: INTEGER;
  BEGIN                                                       (*NAME:         *)
                                                              (******         *)

    NEW(CP,TYPES);                                            (*INTEGER       *)
    WITH CP@ DO
      BEGIN NAME := 'INTEGER     '; IDTYPE := INTPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);                                            (*REAL          *)
    WITH CP@ DO
      BEGIN NAME := 'REAL        '; IDTYPE := REALPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);                                            (*CHAR          *)
    WITH CP@ DO
      BEGIN NAME := 'CHAR        '; IDTYPE := CHARPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);                                            (*BOOLEAN       *)
    WITH CP@ DO
      BEGIN NAME := 'BOOLEAN     '; IDTYPE := BOOLPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);                                            (*CHAR          *)
    WITH CP@ DO
      BEGIN NAME := 'TEXT        '; IDTYPE := TEXTPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);                                            (*ALFA          *)
    WITH CP@ DO
      BEGIN NAME := 'ALFA        '; IDTYPE := ALFAPTR;  KLASS := TYPES END ;

    ENTERID(CP);
    NEW(CP,KONST);                                            (*MAXINT        *)
    WITH CP@ DO
      BEGIN NAME := 'MAXINT      '; IDTYPE := INTPTR;  KLASS := KONST;
      VALUES.IVAL := MAXINT;
      END;

    ENTERID(CP);
    CP1 := NIL;
    FOR I := 1 TO 2 DO
      BEGIN NEW(CP,KONST);                                    (*FALSE,TRUE    *)
        WITH CP@ DO
          BEGIN NAME := NA[I]; IDTYPE := BOOLPTR;
            NEXT := CP1; VALUES.IVAL := I - 1; KLASS := KONST
          END;
        ENTERID(CP); CP1 := CP
      END;
    BOOLPTR@.FCONST := CP;

    NEW(CP,KONST);                                             (*NIL          *)
    WITH CP@ DO
      BEGIN NAME := 'NIL         '; IDTYPE := NILPTR;
        NEXT := NIL; VALUES.IVAL := 0; KLASS := KONST
      END;
    ENTERID(CP);

#   FOR I := 39 TO 44 DO
      BEGIN NEW(CP,VARS);                                     (*INPUT,OUTPUT  *)
        WITH CP@ DO                                           (*PRD,PRR       *)
          BEGIN NAME := NA[I]; IDTYPE := TEXTPTR;             (*QRD,QRR       *)
            KLASS := VARS; VKIND := ACTUAL; NEXT := NIL; VLEV := 1;
            VADDR := FIRSTFILBUF+(I-39)*CHARSIZE  ;  "EBCD := FALSE ;"
          END;
        ENTERID(CP)
      END;
#
#   FOR I := 45 TO 46 DO                                  (*DATE, TIME        *)
#     BEGIN NEW(CP,VARS);
#       WITH CP@ DO
#         BEGIN NAME := NA[I]; IDTYPE := ALFAPTR;
#           KLASS := VARS; VKIND := ACTUAL; NEXT := NIL; VLEV := 1;
#           VADDR := TIMEDATELOC+(I-45)*ALFALNGTH  ;
#         END;
#       ENTERID(CP)
#     END;

#   NEW(CP, VARS);      (*OSPARM PTR                                          *)
#                       (*THE REST OF THIS CODE IS TO DEFINE:                 *)
#                       (* VAR:  OSPARM: @ RECORD                             *)
#                       (*                 LENGTH: INTEGER;                   *)
#                       (*                 STRING: ARRAY[1..64] OF CHAR       *)
#                       (*                 END;                               *)
#                       (*                                                    *)
#   WITH CP@ DO
#       BEGIN   NAME := 'OSPARM      ';
#       KLASS := VARS;  VKIND := ACTUAL;  NEXT := NIL;  VLEV := 1;
#       VADDR := OSPARMLOC;
#       ENTERID(CP);
#
#       NEW(IDTYPE, POINTER);
#       WITH IDTYPE@ DO
#         BEGIN   SIZE := PTRSIZE;  ALN := PTRSIZE;  FORM := POINTER;
#
#         NEW(ELTYPE, RECORDS);                      (*TYPE OF THE PARM RECORD*)
#         WITH ELTYPE@ DO
#           BEGIN   SIZE := INTSIZE+ STRGLNGTH*CHARSIZE;  ALN := PTRSIZE;
#           FORM := RECORDS;  RECVAR := NIL;
#
#           NEW(FSTFLD, FIELD);
#             WITH FSTFLD@ DO
#             BEGIN   NAME := 'LENGTH      ';  IDTYPE := INTPTR;   FLDADDR := 0;
#             KLASS := FIELD;
#
#             NEW(RLINK, FIELD);    (*'LENGTH' < 'STRING' --> GOING DOWN RLINK*)
#             WITH RLINK@ DO
#               BEGIN   NAME := 'STRING      ';  LLINK := NIL;  RLINK := NIL;
#               FLDADDR := PTRSIZE;  NEXT := NIL;  KLASS := FIELD;
#
#               NEW(IDTYPE, ARRAYS);
#               WITH IDTYPE@ DO
#                 BEGIN  SIZE := STRGLNGTH*CHARSIZE;  ALN := CHARSIZE;
#                 FORM := ARRAYS;  AELTYPE := CHARPTR;
#
#                 NEW(INXTYPE, SUBRANGE);
#                 WITH INXTYPE@ DO
#                   BEGIN  FORM := SUBRANGE;  RANGETYPE := INTPTR;
#                   MIN.IVAL := 1;  MAX.IVAL := STRGLNGTH;
#                   END (*WITH INXTYPE...*);
#                 END (*WITH IDTYPE...*);
#
#               END (*WITH LLINK...*);
#
#             LLINK := NIL;  NEXT := RLINK;
#             END (*WITH FSTFLD ...*);
#
#           END (*WITH ELTYPE ...*);
#
#         END (*WITH IDTYPE ...*);
#
#       END (*WITH CP ...*);
#
    NEW(CP1,VARS);                     (*PARAMETER OF PREDECLARED FUNCTIONS   *)
    WITH CP1@ DO
      BEGIN NAME := BLANKID; IDTYPE := REALPTR; KLASS := VARS;
        VKIND := ACTUAL; NEXT := NIL; VLEV := 1; VADDR := 0
      END;

#   FOR I := 4 TO 37 DO  (*PAGE,GET...ARCTAN,ODD*)
#     BEGIN NEW(CP,PROC,STANDARD);                         (*GET,PUT,RESET    *)
#       WITH CP@ DO                                        (*REWRITE,READ     *)
#         BEGIN NAME := NA[I]; IDTYPE := NIL;              (*WRITE,PACK       *)
#           NEXT := NIL; KEY := I - 4;                     (*UNPACK,PACK      *)
#           IF I <= 19 THEN KLASS := PROC ELSE KLASS := FUNC  ;
#           PFDECKIND := STANDARD;                         (*READLN,WRITELN   *)
#                                                          (*MARK,RELEASE,TRAP*)

            IF I IN [31..36 (*SIN..ARCTAN*)] THEN  (*ADD THE FORTAN SHADOW TOO*)
              BEGIN NEW(NEXT,FUNC,DECLARED,ACTUAL);     (*SIN,COS,EXP,SQRT    *)
                WITH NEXT@ DO                           (*LN,ARCTAN,EXIT      *)
                  BEGIN  NAME := NA[I-31+52]; IDTYPE := REALPTR; NEXT := CP1;
                  FWDECL := FALSE; EXTRN := FALSE; FRTRN := TRUE;
                  KLASS := FUNC; PFDECKIND := DECLARED; PFKIND := ACTUAL;
                  PFLEV := 0; PFNAME := 0;
                  END;
                ENTERID(NEXT)
              END (*IF I IN [31..36]...*);

#         END;
#       ENTERID(CP)
#     END;

"NH"FOR I := 47 TO 51 DO
"NH"  BEGIN NEW(CP,PROC,STANDARD);
"NH"    WITH CP@ DO
"NH"       BEGIN  NAME := NA[I];  IDTYPE := NIL; NEXT := NIL;
"NH"         IF I <= 49 THEN KLASS := PROC ELSE KLASS := FUNC;
"NH"         KEY := I-12;  PFDECKIND := STANDARD;
"NH"       END;
"NH"    ENTERID(CP);
"NH"  END;

#   NEW(CP,PROC,DECLARED,ACTUAL);                          (*SNAPSHOT         *)
#     WITH CP@ DO
#       BEGIN   NAME := 'SNAPSHOT    ';  IDTYPE := NIL;  FRTRN := FALSE ;
#         FWDECL := FALSE ;  EXTRN := TRUE ; PFLEV := 0 ; PFNAME := 0 ;
#         KLASS := PROC; PFDECKIND := DECLARED ;   PFKIND := ACTUAL ;
#         SAVEFP := FALSE ;
#       END;
#     ENTERID(CP) ;
#
#   NEW(CP@.NEXT,VARS);               (*PARAMETER OF PREDECLARED EXTERNAL PROC*)
#   WITH CP@.NEXT@ DO
#     BEGIN  IDTYPE := INTPTR; KLASS := VARS;
#       VKIND := ACTUAL; NEXT := NIL; VLEV := 1; VADDR := 0 ;
#     END;
#   NEW(CP1,VARS) ;
#   CP1@ := CP@.NEXT@ ;                 (*SECOND PARAMETER FOR SNAPSHOT       *)
#   CP@.NEXT@.NEXT := CP1 ;


 """FOR I := 20 TO 30 DO
      BEGIN NEW(CP,FUNC,STANDARD);                         (*ABS,SQR,TRUNC    *)
        WITH CP@ DO                                        (*ODD,ORD,CHR      *)
          BEGIN NAME := NA[I]; IDTYPE := NIL;              (*PRED,SUCC        *)
            NEXT := NIL; KEY := I - 19;                    (*CLOCK,EOF,EOLN   *)
            KLASS := FUNC; PFDECKIND := STANDARD
          END;
        ENTERID(CP)
      END;
    NEW(CP,VARS);                      (*PARAMETER OF PREDECLARED FUNCTIONS   *)
    WITH CP@ DO
      BEGIN NAME := BLANKID; IDTYPE := REALPTR; KLASS := VARS;
        VKIND := ACTUAL; NEXT := NIL; VLEV := 1; VADDR := 0
      END;
    FOR I := 31 TO 37 DO
      BEGIN NEW(CP1,FUNC,DECLARED,ACTUAL);              (*SIN,COS,EXP,SQRT    *)
        WITH CP1@ DO                                    (*LN,ARCTAN,EXIT      *)
          BEGIN NAME := NA[I]; IDTYPE := REALPTR; NEXT := CP;
            FWDECL := FALSE; EXTRN := TRUE; PFLEV := 0; PFNAME := I - 16;
            KLASS := FUNC; PFDECKIND := DECLARED; PFKIND := ACTUAL
          END;
        ENTERID(CP1)
      END;
    WITH CP1@ DO                               (*FIXUPS FOR EXIT PROCEDURE    *)
      BEGIN  IDTYPE := NIL;  NEXT := CP;  KLASS := PROC   END;
    NEW(CP,VARS);                              (*PARAMETER OF EXIT ROUTINE    *)
    WITH CP@ DO
      BEGIN NAME := BLANKID; IDTYPE := INTPTR; KLASS := VARS;
        VKIND := ACTUAL; NEXT := NIL; VLEV := 1; VADDR := 0
      END;"""

  END (*ENTSTDNAMES*) ;


  PROCEDURE ENTERUNDECL;
  BEGIN
    NEW(UTYPPTR,TYPES);
    WITH UTYPPTR@ DO
      BEGIN NAME := BLANKID; IDTYPE := NIL; KLASS := TYPES END;
    NEW(UCSTPTR,KONST);
    WITH UCSTPTR@ DO
      BEGIN NAME := BLANKID; IDTYPE := NIL; NEXT := NIL;
        VALUES.IVAL := 0; KLASS := KONST
      END;
    NEW(UVARPTR,VARS);
    WITH UVARPTR@ DO
      BEGIN NAME := BLANKID; IDTYPE := NIL; VKIND := ACTUAL;
        NEXT := NIL; VLEV := 0; VADDR := 0; KLASS := VARS
      END;
    NEW(UFLDPTR,FIELD);
    WITH UFLDPTR@ DO
      BEGIN NAME := BLANKID; IDTYPE := NIL; NEXT := NIL; FLDADDR := 0;
        KLASS := FIELD
      END;
    NEW(UPRCPTR,PROC,DECLARED,ACTUAL);
    WITH UPRCPTR@ DO
      BEGIN NAME := BLANKID; IDTYPE := NIL; FWDECL := FALSE;
        NEXT := NIL; EXTRN := FALSE; PFLEV := 0; GENLABEL(PFNAME);
        KLASS := PROC; PFDECKIND := DECLARED; PFKIND := ACTUAL
      END;
    NEW(UFCTPTR,FUNC,DECLARED,ACTUAL);
    WITH UFCTPTR@ DO
      BEGIN NAME := BLANKID; IDTYPE := NIL; NEXT := NIL;
        FWDECL := FALSE; EXTRN := FALSE; PFLEV := 0; GENLABEL(PFNAME);
        KLASS := FUNC; PFDECKIND := DECLARED; PFKIND := ACTUAL
      END
  END (*ENTERUNDECL*) ;


  PROCEDURE INITSCALARS;
  BEGIN   FWPTR := NIL;
#     "PRTABLES  := FALSE;"   LIST   := TRUE;     PRCODE    := TRUE;
#      DP        := FALSE;    PRTERR := TRUE;     ERRINX    := 0;
#      HP        := FALSE;    IC     := 0;
#      INTLABEL  := 0;
#      FILEHEAD  := NIL;
#      LC        := FIRSTGVAR;             (*ADR. OF THE FIRST GLOBAL VARIABLE*)
#      (* NOTE IN THE ABOVE RESERVATION OF BUFFER STORE FOR TEXT FILES *)
#      OLDIC     := 0;      IC       := 0 ;       EOL       := TRUE;
#      LINECNT   := 0;      CH       := ' ';      CHCNT     := 0;
#      PAGECNT   := 0;      NXTLN    := PAGESIZE; (* GENERATES FIRST HEADLINE *)
#      LMARGIN   := 0;      RMARGIN  := 80;       BUFEND    := 81;
#      OLDLN     := 0;      MWARN    := FALSE;    LSTOP     := '#';
#      GLOBTESTP := NIL;
#      PROGNAME  := '$MAINBLK    ' ;
#      BLANKID   := '            ' ;
#      MXINT10   := MAXINT DIV 10;               "DIGMAX    := REALLNGTH - 1;"
#      PROCLAB   := 0;      ERRORCNT := 0;
#      ASSEMBLE  := FALSE; "MARGIN   := FALSE;"   NESTCOMM  := FALSE ;
#      SAVEREGS  := TRUE ;  SAVEFPRS := TRUE;    "EBCDFLG   := FALSE ;"
#      DEBUG     := TRUE ; "BYTEON   :=  FALSE ; "ASSIGN    := FALSE  ;
#      FLIPDEBUG := FALSE ;
#      DOTFLG    := FALSE ; NXTFILBUF:= FIRSTUSERF ;
#      PACKDATA  := FALSE ; XLINK    := FALSE ;   (*GENERATES UNIQUE NAMES *)
"CM"   MXDATASZE := REALSIZE ;
"S1" " MXDATASZE := PTRSIZE ;                                                  "
#      GET_STAT  := FALSE ; ASMVERB  := FALSE ;
"CT"   CTRCNT    := 0 ;     CTROPTION:= FALSE ;
  END (*INITSCALARS*) ;


  PROCEDURE INITSETS;
  VAR  I : 0..10 (*MAXERRNR DIV SETMAX*) ;
  BEGIN
    CONSTBEGSYS    := [ADDOP,INTCONST,REALCONST,STRINGCONST,IDENT];
    SIMPTYPEBEGSYS := [LPARENT] + CONSTBEGSYS;
    TYPEBEGSYS     := [ARROW,PACKEDSY,ARRAYSY,RECORDSY,SETSY,FILESY]+
                      SIMPTYPEBEGSYS;
    TYPEDELS       := [ARRAYSY,RECORDSY,SETSY,FILESY];
    BLOCKBEGSYS    := [LABELSY,CONSTSY,TYPESY,VARSY,PROCSY,FUNCSY,
                       BEGINSY];
    SELECTSYS      := [ARROW,PERIOD,LBRACK];
    FACBEGSYS      := [INTCONST,REALCONST,STRINGCONST,IDENT,LPARENT,LBRACK,
                       NOTSY];
    STATBEGSYS     := [BEGINSY,GOTOSY,IFSY,WHILESY,REPEATSY,FORSY,WITHSY,
                       CASESY];
#
#   FOR I := 0 TO MAXERRLOG DO  ERRLOG[I] := [] ;   (*CLEAR ERROR LOG*)
#
  END (*INITSETS*) ;


  PROCEDURE INITTABLES;
    PROCEDURE RESWORDS;
    BEGIN
      RW[ 1]:= 'IF          '; RW[ 2]:= 'DO          '; RW[ 3]:= 'OF          ';
      RW[ 4]:= 'TO          '; RW[ 5]:= 'IN          '; RW[ 6]:= 'OR          ';
      RW[ 7]:= 'END         '; RW[ 8]:= 'FOR         '; RW[ 9]:= 'VAR         ';
      RW[10]:= 'DIV         '; RW[11]:= 'MOD         '; RW[12]:= 'SET         ';
      RW[13]:= 'AND         '; RW[14]:= 'NOT         '; RW[15]:= 'THEN        ';
      RW[16]:= 'ELSE        '; RW[17]:= 'WITH        '; RW[18]:= 'GOTO        ';
      RW[19]:= 'CASE        '; RW[20]:= 'TYPE        ';
      RW[21]:= 'FILE        '; RW[22]:= 'BEGIN       ';
      RW[23]:= 'UNTIL       '; RW[24]:= 'WHILE       '; RW[25]:= 'ARRAY       ';
      RW[26]:= 'CONST       '; RW[27]:= 'LABEL       ';
      RW[28]:= 'REPEAT      '; RW[29]:= 'RECORD      '; RW[30]:= 'DOWNTO      ';
      RW[31]:= 'PACKED      '; RW[32]:= 'FORWARD     '; RW[33]:= 'PROGRAM     ';
      RW[34]:= 'FORTRAN     '; RW[35]:= 'EXTERNAL    ';
      RW[36]:= 'FUNCTION    '; RW[37]:= 'PROCEDURE   ';

      FRW[1] :=  1; FRW[2] :=  1; FRW[3] :=  7; FRW[4] := 15; FRW[5] := 22;
      FRW[6] := 28; FRW[7] := 32; FRW[8] := 35; FRW[9] := 37;
#     FRW[10] := 38 ; FRW[11] := 38;  FRW[12] := 38; FRW[13] := 38 ;

#    "SEQFLD[9] := ' ';  SEQFLD[10] := ' '; "  (*CLEAR EXTRA CHARS IN SEQ. FLD*)
    END (*RESWORDS*) ;

    PROCEDURE SYMBOLS;
    BEGIN
      RSY[1] := IFSY; RSY[2] := DOSY; RSY[3] := OFSY; RSY[4] := TOSY;
      RSY[5] := RELOP; RSY[6] := ADDOP; RSY[7] := ENDSY; RSY[8] := FORSY;
      RSY[9] := VARSY; RSY[10] := MULOP; RSY[11] := MULOP; RSY[12] := SETSY;
      RSY[13] := MULOP; RSY[14] := NOTSY; RSY[15] := THENSY;
      RSY[16] := ELSESY; RSY[17] := WITHSY; RSY[18] := GOTOSY;
      RSY[19] := CASESY; RSY[20] := TYPESY; RSY[21] := FILESY;
      RSY[22] := BEGINSY; RSY[23] := UNTILSY; RSY[24] := WHILESY;
      RSY[25] := ARRAYSY; RSY[26] := CONSTSY; RSY[27] := LABELSY;
      RSY[28] := REPEATSY; RSY[29] := RECORDSY; RSY[30] := DOWNTOSY;
      RSY[31] := PACKEDSY; RSY[32] := FORWARDSY; RSY[33] := PROGSY;
      RSY[34] := FRTRNSY ; RSY[35] := EXTRNSY ;  RSY[36] := FUNCSY;
      RSY[37] := PROCSY;

      SSY['+'] := ADDOP;    SSY['-'] := ADDOP;
      SSY['*'] := MULOP;    SSY['/'] := MULOP;
      SSY['('] := LPARENT;  SSY[')'] := RPARENT;
      SSY['['] := LBRACK;   SSY[']'] := RBRACK;
      SSY[','] := COMMA;    SSY[':'] := COLON;
      SSY['Ý'] := ADDOP ;   SSY['&'] := MULOP ;
      SSY['<'] := RELOP;    SSY['>'] := RELOP;
      SSY['='] := RELOP;    SSY['@'] := ARROW;
      SSY[''] := ARROW;
      SSY['^'] := NOTSY ;   SSY[';'] := SEMICOLON;
      SSY['.'] := PERIOD;
    END (*SYMBOLS*) ;


    PROCEDURE RATORS;
      VAR I: INTEGER; CH: CHAR;
    BEGIN
      FOR I := 1 TO NRSW (*NR OF RES WORDS*) DO ROP[I] := NOOP;
      ROP[5] := INOP; ROP[10] := IDIV; ROP[11] := IMOD;
      ROP[6] := OROP; ROP[13] := ANDOP;

      (* THE LIMIT OF THESE LOOP IS CHAR SET DEPENDENT *)
#     FOR CH := chr(0) TO chr(255) DO    UPSHIFT[CH] := CH ;         (*opp*)
#     FOR CH := 'a' TO 'z' DO    UPSHIFT[CH] := CHR(ORD(CH) + 64) ;      (*UPL*)
      FOR I := 0 TO ORDCHMAX DO  SOP[CHR(I)] := ILLEGCH ;
      FOR CH := 'A' TO 'I' DO    SOP[CH] := ATOZCH ;
      FOR CH := 'J' TO 'R' DO    SOP[CH] := ATOZCH ;
      FOR CH := 'S' TO 'Z' DO    SOP[CH] := ATOZCH ;
      FOR CH := 'a' TO 'i' DO
         BEGIN  SOP[CH] := ATOZCH; UPSHIFT[CH] := CHR(ORD(CH) + 64)  END;(*UPL*)
      FOR CH := 'j' TO 'r' DO
         BEGIN  SOP[CH] := ATOZCH; UPSHIFT[CH] := CHR(ORD(CH) + 64)  END;(*UPL*)
      FOR CH := 's' TO 'z' DO
         BEGIN  SOP[CH] := ATOZCH; UPSHIFT[CH] := CHR(ORD(CH) + 64)  END;(*UPL*)
      FOR CH := '0' TO '9' DO    SOP[CH] := NUMCH ;
      SOP['"']  := DQUOTCH ;
      SOP['¯']  := LBRACE ;
      SOP['#']  := SKIPCH ;
      SOP['$']  := DOLLARCH ;
      SOP[''''] := QUOTCH ;
      SOP['(']  := LPARCH ;
      SOP[')']  := SPECH ;
      SOP[',']  := SPECH ;
      SOP['.']  := DOTCH ;
      SOP[':']  := COLONCH ;
      SOP[';']  := SPECH ;
      SOP['@']  := SPECH ;
      SOP['[']  := SPECH ;
      SOP['Ý']  := SPECH ;
      SOP[']']  := SPECH ;
      SOP['^']  := SPECH ;
      SOP['_']  := UNDSCH ;
      SOP['+'] := PLUS; SOP['-'] := MINUS;
      SOP['*'] := MUL;  SOP['/'] := RDIV;
      SOP['='] := EQOP;
      SOP['<'] := LTOP; SOP['>'] := GTOP;
#     SOP['Ý'] := OROP ;  SOP['&'] := ANDOP ;
    END (*RATORS*) ;

    PROCEDURE PROCMNEMONICS;
    BEGIN
      SNA[ 0] :='PAG';
      SNA[ 1] :='GET'; SNA[ 2] :='PUT'; SNA[ 3] :='RES'; SNA[ 4] :='REW';
      SNA[ 5] :='RDC'; SNA[ 6] :='WRI'; SNA[ 7] :='WRO'; SNA[ 8] :='WRR';
      SNA[ 9] :='WRC'; SNA[10] :='WRS'; SNA[11] :='PAK'; SNA[12] :='RDB';
      SNA[13] :='WRB'; SNA[14] :='RDR'; SNA[15] :='SIN'; SNA[16] :='COS';
      SNA[17] :='EXP'; SNA[18] :='SQT'; SNA[19] :='LOG'; SNA[20] :='ATN';
      SNA[21] :='CLK'; SNA[22] :='WLN'; SNA[23] :='RLN'; SNA[24] :='RDI';
      SNA[25] :='EOF'; SNA[26] :='ELN'; SNA[27] :='RDS'; SNA[28] :='TRP';
      SNA[29] :='XIT'; SNA[30] :='FDF'; SNA[31] :='SIO'; SNA[32] :='EIO';
"NH"  SNA[33] := 'MSG'; SNA[34] := 'SKP'; SNA[35] := 'LIM';
    END (*PROCMNEMONICS*) ;

    PROCEDURE INSTRMNEMONICS;
    BEGIN
      MN[ 0] :=' ABI'; MN[ 1] :=' ABR'; MN[ 2] :=' ADI'; MN[ 3] :=' ADR';
      MN[ 4] :=' AND'; MN[ 5] :=' DIF'; MN[ 6] :=' DVI'; MN[ 7] :=' DVR';
      MN[ 8] :=' SBR'; MN[ 9] :=' FLO'; MN[10] :=' FLT'; MN[11] :=' INN';
      MN[12] :=' INT'; MN[13] :=' IOR'; MN[14] :=' MOD'; MN[15] :=' MPI';
      MN[16] :=' MPR'; MN[17] :=' NGI'; MN[18] :=' NGR'; MN[19] :=' NOT';
      MN[20] :=' ODD'; MN[21] :=' SBI'; MN[22] :=' DEC'; MN[23] :=' INC';
      MN[24] :=' SQI'; MN[25] :=' SQR'; MN[26] :=' STO'; MN[27] :=' TRC';
      MN[28] :=' RND'; MN[29] :=' SGS'; MN[30] :=' CSP'; MN[31] :=' UNI';
      MN[32] :=' ENT'; MN[33] :=' FJP'; MN[34] :='    '; MN[35] :=' IND';
      MN[36] :=' IXA'; MN[37] :=' LCA'; MN[38] :=' CTS'; MN[39] :=' CTI';
      MN[40] :=' MOV'; MN[41] :=' MST'; MN[42] :=' RET'; MN[43] :=' STP';
      MN[44] :=' XJP'; MN[45] :=' CHK'; MN[46] :=' CUP'; MN[47] :=' EQU';
      MN[48] :=' GEQ'; MN[49] :=' GRT'; MN[50] :=' LDA'; MN[51] :=' LDC';
      MN[52] :=' LEQ'; MN[53] :=' LES'; MN[54] :=' LOD'; MN[55] :=' NEQ';
#     MN[56] :=' STR'; MN[57] :=' UJP'; MN[58] :=' NEW'; MN[59] :=' SAV';
#     MN[60] :=' RST'; MN[61] :=' ORD'; MN[62] :=' CHR'; MN[63] :=' DEF';
"S1" "MN[64] :=' PAR';                                                         "
"NH"  MN[65] := ' CRD';  MN[66] := ' XPO';
    END (*INSTRMNEMONICS*) ;

  BEGIN (*INITTABLES*)
    RESWORDS; SYMBOLS; RATORS;
    INSTRMNEMONICS; PROCMNEMONICS;
(*  FOR CH := 'A' TO 'I' DO  EBCDIC[CH] := 192+ORD(CH) ;
    FOR CH := 'J' TO 'R' DO  EBCDIC[CH] := 199+ORD(CH) ;
    FOR CH := 'S' TO 'Z' DO  EBCDIC[CH] := 207+ORD(CH) ;
    FOR CH := '0' TO '9' DO  EBCDIC[CH] := 213+ORD(CH) ;
    EBCDIC[' ']  :=  64 ;
    EBCDIC['!']  :=  90 ;
    EBCDIC['"']  := 127 ;
    EBCDIC['#']  := 123 ;
    EBCDIC['$']  :=  91 ;
    EBCDIC['%']  := 108 ;
    EBCDIC['&']  :=  80 ;
    EBCDIC[''''] := 125 ;
    EBCDIC['(']  :=  77 ;
    EBCDIC[')']  :=  93 ;
    EBCDIC['*']  :=  92 ;
    EBCDIC['+']  :=  78 ;
    EBCDIC[',']  :=  107;
    EBCDIC['-']  :=  96 ;
    EBCDIC['.']  :=  75 ;
    EBCDIC['/']  :=  97 ;
    EBCDIC[':']  := 122 ;
    EBCDIC[';']  :=  94 ;
    EBCDIC['<']  :=  76 ;
    EBCDIC['=']  := 126 ;
    EBCDIC['>']  := 110 ;
    EBCDIC['?']  := 111 ;
    EBCDIC['@']  := 124 ;
    EBCDIC['[']  := 173 ;
    EBCDIC['Ý']  := 106 ;
    EBCDIC[']']  := 189 ;
    EBCDIC['^']  :=  95 ;
    EBCDIC['_']  := 109 ;     CH := ' ' ;   *)
  END (*INITTABLES*) ;


BEGIN  (*PASCALCOMPILER*)
  (*INITIALIZE*)
  (************)
  INITSCALARS; INITSETS; INITTABLES;


  (*ENTER STANDARD NAMES AND STANDARD TYPES:*)
  (******************************************)

  LEVEL := 0; TOP := 0;
  WITH DISPLAY[0] DO
    BEGIN FNAME := NIL; FLABEL := NIL; OCCUR := BLCK END;
  ENTERSTDTYPES;   STDNAMES; ENTSTDNAMES;   ENTERUNDECL;
  TOP := 1; LEVEL := 1;
  WITH DISPLAY[1] DO
    BEGIN FNAME := NIL; FLABEL := NIL; OCCUR := BLCK END;

  (*set options passed as parameter to the compiler*)
  (*************************************************)

  IF OSPARM <> NIL THEN
    WITH  OSPARM@  DO
      BEGIN
      CH "LINEBUF[1]" := '¯';  LINEBUF[2] := '$';
      IF LENGTH > 64 THEN LENGTH := 64;
      FOR CHCNT := 1 TO LENGTH DO  LINEBUF[CHCNT+2] := STRING[CHCNT];
      (*THE REST OF THE LINE DOES NOT HAVE TO BE CLEARED BUT...*)
      FOR CHCNT := LENGTH TO 77 DO   LINEBUF[CHCNT+3] := ' ';
      LINEBUF[LENGTH+3] := '';  LINEBUF[LENGTH+4] := '#';
      EOL := FALSE;  CHCNT := 1;  LASTCOL := LENGTH+3;
      END (*WITH OSPARM .., IF OSPARM ...*);

  (*COMPILE:*)
  (**********)

# CTIME := CLOCK(1) ;
# (* FIRST HEADLINE PRINTED BY 'ENDOFLINE' *)
#
# INSYMBOL;
#
# PROGRAMME(BLOCKBEGSYS+STATBEGSYS-[CASESY]);
#
# (* PRINT POST COMPILATION MESSAGES *)
#
# GOODBYE;
#
# END. (*PASCALCOMPILER*)
++FILE PASCALN.OLDCOMP.SOURCE                       MEMB PAS1982  EXT PAS HEX -
(*$D-,N+*)

PROGRAM PASCALCOMPILER(INPUT, OUTPUT, PRR, QRR);

 (* minor change to allow compile of PAS1982 by
    new Stanford Pascal: fields of builtin structure
    OSPARM changed their names: length -> plength and
    string -> pstring / opp / 2019.06 *)

 (******************************************************************
  *                                                                *
  *         S T A N F O R D   P A S C A L   C O M P I L E R        *
  *                                                                *
  *                  MCGILL UNIVERSITY VERSION                     *
  *                                                                *
  *                                                                *
  *         AUTHOR OF ORIGINAL PROGRAM:                            *
  *                                                                *
  *              URS AMMANN                                        *
  *              FACHGRUPPE COMPUTERWISSENSCHAFTEN                 *
  *              EIDG. TECHNISCHE HOCHSCHULE                       *
  *              CH-8006 ZUERICH                                   *
  *                                                                *
  *                                                                *
  *         AUTHOR OF SECOND VERSION:                              *
  *                                                                *
  *              KESAV NORI                                        *
  *              COMPUTER GROUP                                    *
  *              T.I.F.R.                                          *
  *              HOMI BHABHA ROAD                                  *
  *              BOMBAY - 400005                                   *
  *              INDIA                                             *
  *                                                                *
  *                                                                *
  *         AUTHOR OF THIRD VERSION (STANFORD PASCAL):             *
  *                                                                *
  *              S. HAZEGHI                                        *
  *              COMPUTATION RESEARCH GROUP                        *
  *              STANFORD LINEAR ACCELERATOR CENTER                *
  *              STANFORD, CA. 94305.                              *
  *                                                                *
  *                                                                *
  *         AUTHOR OF FOURTH VERSION (MCGILL PASCAL):              *
  *                                                                *
  *              R. NIGEL HORSPOOL                                 *
  *              SCHOOL OF COMPUTER SCIENCE                        *
  *              MCGILL UNIVERSITY                                 *
  *              MONTREAL  QUEBEC  H3A 2K6                         *
*
* 02FEB2007 - Changes by Dave Edwards to use hex codes C0,D0
*    (was 8B,9B) for EBCDIC brace characters (curly brackets).
*    New constants CHLBRACE and CHRBRACE defined.
*    VERSION date left unchanged as MAY -82.
*    Hex C0,D0 seem to be the codes used by most current software
*    such as tn3270 clients, Ascii-EBCDIC translate tables, etc.
*    and conform to the standard IBM-037 US code page.
*    See additional notes in file ccde:pascal_info.txt .
*  - Also, in INITTABLES procedure, set UPSHIFT to only upshift
*    lowercase chars (e.g. exclude tilde, which is in the range
*    a to z), and add comments re. definition of SSY array.
*    Note that curly brackets and backslash are within the
*    range A to Z in the EBCDIC character set.
*  - Also fix spacing of text for BGN output record: change TIME:9
*    to TIME:8. Was causing last char of year to be truncated, in
*    the info text at the start of $MAINBLK csect in the object file.
*  - Source changes are identified by flag DE near beginning of lines.
*    (Write date of previous source file: 14sep1983.)
*
  *                                                                *
  *                                                                *
  ******************************************************************)



CONST
#      VERSION     = 'MAY -82';
#      PAGESIZE    = 55;           (*MAX # OF LINES PER PAGE OF LISTING      *)
#      MAXINT      = 2147483647;
#      MAXADDR     = 16777215;
#      SETMAX      = 255;          (*LARGEST POSSIBLE SET ELEMENT            *)
"**"   SSETMAX     =  63;          (*LARGEST ELEMENT USED IN THIS CODE       *)
#      BUFLEN      = 122;          (*MAX LINE LENGTH + 2                     *)
"BM"   INTSIZE     = 4;
"&&"   HINTSIZE    = 2;
"BM"   REALSIZE    = 8;
"BM"   CHARSIZE    = 1;
"&&"   MXDATASZE   = 8;
"BM"   BOOLSIZE    = 1;
"**"   WORDSIZE    = 4;            (* NUMBER OF BYTES PER WORD              *)
"**"   SETPACK     = 32;           (* NUMBER OF SET ELEMENTS PER WORD       *)
"**"   MAXSETSIZE  = 32;           (*  = (SETMAX+1) DIV SETPACK * WORDSIZE  *)
"BM"   PTRSIZE     = 4;
"@@"   FILHDRSIZE  = 8;
#      REALLNGTH   = 20;           (*STRING REPRESENTATION OF REAL NUMBERS   *)
#      DIGMAX      = 19;           (*REALLNGTH-1                             *)
#      IDLNGTH     = 12;
#      ALFALNGTH   = 10;
#      STRGLNGTH   = 64;
#      DISPLIMIT   = 20;
"&&"   MAX_BKT     = 58;           (* HASH TABLE SIZE                        *)
"&&"   MAXLEVEL    =  9;
#      ORDCHMAX    = 255;          (*SIZE OF CHAR SET OF TARGET MACHINE      *)
"&&"   OPMAX       = 76;           (* OPCODE RANGE  *)
#      MAXERRNR    = 401;          (*MAX VAL OF ERROR CODE                   *)
#      MAXERRLOG   =   8;          (* > (MAXERRNR DIV SETMAX)                *)
"&&"   NRSW        = 38;
"&&"   NRSW1       = 39;           (*NRSW+1                                  *)
"NH"   NSPROC      = 36;           (* # OF STANDARD PROCS                    *)
       NPDW        = 57;           (* # OF PREDEFINED WORDS                  *)
"CT"   CTRMAX      = 16384;
"@@"   EXTNAMSZ    = 8;            (* EXTERNAL NAME LENGTH                  *)

"BM"   (*SAVE AREAS, FUNCTION RETURN VALUE SPACE, DISPLAY AREA, ETC.         *)
"BM"   LCAFTMST    = 80;    FPSAVEAREA  = 32;     RUNCHKAREA  = 96;
"BM"   DISPADR     = 80;    FNCRSLT     = 72;     DISPAREA    = 40;
"&&"   FIRSTCONSTLC=  8;
"BM"   FIRSTFILBUF = 248;          (* = LCAFTMST+RUNCHKAREA+DSPLYAREA        *)
"@@"   TIMEDATELOC = 328;          (* LOCATION OF TIME/DATE PREDEF. VARS     *)
"@@"   OSPARMLOC   = 348;          (* LOCATION FOR 'OSPARM' PTR.             *)
"@@"   FIRSTGVAR   = 352;          (* FIRST USER DEFINED GLOBAL VARIABLE     *)
"DE"  CHLBRACE = '{';   (* LEFT CURLY BRACKET: EBCDIC HEX CODE C0 *)
"DE"  CHRBRACE = '}';   (* RIGHT CURLY BRACKET: EBCDIC HEX CODE D0 *)

(*----------------------------------------------------------------------------*)


TYPE
                                                            (*BASIC SYMBOLS   *)
                                                            (**************   *)

     SYMBOL       = (IDENT,INTCONST,REALCONST,STRINGCONST,NOTSY,MULOP,ADDOP,
                     RELOP,LPARENT,RPARENT,LBRACK,RBRACK,COMMA,SEMICOLON,PERIOD,
                     ARROW,COLON,DOTDOT,BECOMES,LABELSY,CONSTSY,TYPESY,VARSY,
                     FUNCSY,PROGSY,PROCSY,SETSY,PACKEDSY,ARRAYSY,RECORDSY,
                     FILESY,FORWARDSY,BEGINSY,IFSY,CASESY,REPEATSY,WHILESY,
                     FORSY,WITHSY,GOTOSY,ENDSY,ELSESY,UNTILSY,OFSY,DOSY,TOSY,
"&&"                 DOWNTOSY,THENSY,FRTRNSY,EXTRNSY,OTHERWISESY,OTHERSY);

     OPERATOR     = (MUL,RDIV,ANDOP,IDIV,IMOD,PLUS,MINUS,OROP,LTOP,LEOP,GEOP,
                     GTOP,NEOP,EQOP,INOP,NOOP,
#                    ATOZCH, NUMCH, QUOTCH, DQUOTCH, COLONCH, DOTCH, LPARCH,
#                    LBRACE, UNDSCH, DOLLARCH, SKIPCH, SPECH, ILLEGCH ) ;

     SETOFSYS     = SET OF SYMBOL;
"**" SSETINX      = 1..4;          (* 4 = (SETMAX+1) DIV (SSETMAX+1)  *)
"**" SSETRANGE    = SET OF 0..SSETMAX;
"**" SETRANGE     = ARRAY[SSETINX] OF SSETRANGE;


                                                            (*CONSTANTS       *)
                                                            (**********       *)
     CSTCLASS     = (REEL,PSET,STRG);
     CSP          = @ CONSTANT;
     CONSTANT     = RECORD CASE CSTCLASS OF
                           REEL: (RVAL: PACKED ARRAY [1..REALLNGTH] OF CHAR);
"**"                       PSET: (PLNGTH: 0..MAXSETSIZE; PVAL: SETRANGE  );
                           STRG: (SLNGTH: 0..STRGLNGTH;
                                  SVAL: PACKED ARRAY [1..STRGLNGTH] OF CHAR)
                         END;

     VALU         = RECORD CASE BOOLEAN OF
                      TRUE:  (IVAL: INTEGER);
                      FALSE: (VALP: CSP)
                    END;

                                                           (*DATA STRUCTURES  *)
                                                           (****************  *)
     LEVRANGE     = 0..MAXLEVEL;       ADDRRANGE   = 0..MAXADDR;
     ALNRNG       = 1..8 ;             LABELRNG    = 0..1000 ;
"&&" BKT_RNG      = 0 .. MAX_BKT ;
     STRUCTFORM   = (SCALAR,SUBRANGE,POINTER,POWER,ARRAYS,RECORDS,FILES,
                     TAGFLD,VARIANT);
     DECLKIND     = (STANDARD,DECLARED);
     STP          = @ STRUCTURE;
     CTP          = @ IDENTIFIER;

     STRUCTURE    = RECORD
                    SIZE: ADDRRANGE;
"&&"                ALN:  ALNRNG;         (*ALIGNMENT FACTOR*)
                    CASE FORM: STRUCTFORM OF
                      SCALAR:   (CASE SCALKIND: DECLKIND OF
                                   DECLARED: (FCONST: CTP));
                      SUBRANGE: (RANGETYPE: STP; MIN,MAX: VALU);
                      POINTER:  (ELTYPE: STP);
                      POWER:    (ELSET: STP);
                      ARRAYS:   (AELTYPE,INXTYPE: STP);
"&&"                  RECORDS:  (FSTFLD: CTP; RECVAR: STP;
"SY"                             NO_FLDS: 0 .. 1000;
"&&"                             FLD_DISP_LEV: -1..DISPLIMIT );
                      FILES:    (FILTYPE: STP);
                      TAGFLD:   (TAGFIELDP: CTP; FSTVAR: STP);
"&&"                  VARIANT:  (NXTVAR,SUBVAR: STP;
"&&"                             FSTSUBFLD: CTP; VARVAL: VALU)
                    END;

                                                            (*NAMES           *)
                                                            (******           *)

"&&" IDCLASS      = (TYPES,KONST,STRUCTKONST,VARS,FIELD,PROC,FUNC);
     SETOFIDS     = SET OF IDCLASS;
     IDKIND       = (ACTUAL,FORMAL);
     ALPHA        = PACKED ARRAY [1..IDLNGTH] OF CHAR;

     IDENTIFIER   = RECORD
                    NAME: ALPHA;
"&&"                IDTYPE: STP; NEXT_IN_BKT, NEXT: CTP;
"&&"                DECL_LEV: LEVRANGE;
                    CASE KLASS: IDCLASS OF
                      KONST: (VALUES: VALU);
"&&"                STRUCTKONST: (SKOWNER: CTP; SKADDR: ADDRRANGE);
                      VARS:  (VKIND: IDKIND;
                              VLEV: LEVRANGE; VADDR: ADDRRANGE);
"&&"                  FIELD: (FLDADDR: ADDRRANGE;  OWNER: STP );
                      PROC, FUNC:
                        (CASE PFDECKIND: DECLKIND OF
                           STANDARD: (KEY: 0..NSPROC);
                           DECLARED:
"&&"                         (PFLEV: INTEGER; PFNAME: LABELRNG;
"&&" "SH"                     PRMPTR,NXTFWRD: CTP;  PFKIND: IDKIND;
                              FWDECL,EXTRN,FRTRN:BOOLEAN;
"@@"                          EXTNAME: ARRAY[1..EXTNAMSZ] OF CHAR))
                    END;


     DISPRANGE    = 0..DISPLIMIT;
"&&" HASH_TABLE   = ARRAY(/ BKT_RNG /) OF CTP;
     WHERE        = (BLCK,CREC,VREC,REC);

                                                            (*EXPRESSIONS     *)
                                                            (************     *)
     ATTRKIND     = (CST,VARBL,EXPR);
"**" VACCESS      = (DRCT,INDRCT,INXD,STKEXPR);

#    ATTR         = RECORD
"&&"                 TYPTR,      (* TYPE AS AN EXPR. ON RUN-STACK *)
"&&"                 BTYPE: STP; (* TYPE AS A VARIABLE IN MEMORY  *)
                     CASE KIND: ATTRKIND OF
                       CST:   (CVAL: VALU);
                       VARBL: (CASE ACCESS: VACCESS OF
                                 DRCT: (VLEVEL: LEVRANGE; DPLMT: ADDRRANGE);
                                 INDRCT: (IDPLMT: ADDRRANGE);
"**"                             STKEXPR: (STKDPLMT,STKLEN: ADDRRANGE))
                     END;

     TESTP        = @ TESTPOINTER;
     TESTPOINTER  = PACKED RECORD
                      ELT1,ELT2 : STP;
                      LASTTESTP : TESTP
                      END;

                                                                 (*LABELS     *)
                                                                 (*******     *)
     LBP          = @ LABL;
     LABL         = RECORD NEXTLAB: LBP;  LABVAL: INTEGER;
"&&"                  LABNAME, XNO: LABELRNG;  DEFINED: BOOLEAN
                    END;

     FRECPTR      = @FILEREC;
     FILEREC      = RECORD FILIDPTR: CTP; NEXTFILE: FRECPTR;  END;

"&&" PRNTTYLISTP = @PRNTTYLIST;
"&&" PRNTTYLIST  = RECORD  ELT: STP;  TNO: 0..999;  NXT: PRNTTYLISTP  END;

#    ERRCODE      = 0..MAXERRNR;

"CT" CTRRANGE   = 0..CTRMAX;
"CT" CTRTYPE    = (CTRPROC, CTRLBL, CTRGOTO, CTRIF, CTRWHILE, CTRREPEAT,
"CT"               CTRFOR, CTRCASE);

(*----------------------------------------------------------------------------*)


VAR


                                    (*RETURNED BY SOURCE PROGRAM SCANNER
                                     INSYMBOL:
                                     **********)

    SY: SYMBOL;                     (*LAST SYMBOL                             *)
    OP: OPERATOR;                   (*CLASSIFICATION OF LAST SYMBOL           *)
    VAL: VALU;                      (*VALUE OF LAST CONSTANT                  *)
    LNGTH: INTEGER;                 (*LENGTH OF LAST STRING CONSTANT          *)
    PROGNAME,
    ID:  ALPHA ;                    (*LAST IDENTIFIER (POSSIBLY TRUNCATED)    *)
    CH: CHAR;                       (*LAST CHARACTER READ                     *)
    EOL: BOOLEAN;                   (*END OF LINE FLAG                        *)


                                    (*COUNTERS:                               *)
                                    (**********                               *)

    CHCNT: 0..BUFLEN;               (*CHARACTER COUNTER                       *)
"&&" CONSTLC,                       (*DATA LOC. FOR STRUCTURED CONSTANTS      *)
    LC, IC, OLDIC, STIC: ADDRRANGE; (*DATA LOCATION AND INSTRUCTION COUNTER   *)
#   LINECNT, OLDLN, PLCNT, ERRLN,
"&&"  PAGECNT, LASTLINELISTED: INTEGER;


                                    (*SWITCHES:                               *)
                                    (**********                               *)

    HP,                             (*HEADER PART                             *)
    PRTERR,                         (*TO ALLOW FORWARD REFERENCES IN PTR TYPE *)
                                    (*DECLARATION BY SUPPRESSING ERROR MSG    *)
#   DOTFLG,                         (*ONE DOT ALREADY SEEN                    *)
#   ASSIGN,PACKDATA,                (*ASSIGNMENT GOING ON,PACKING IN EFFECT   *)
#   LIST, PRCODE,                   (*LIST SOURCE, OUTPUT P-CODE              *)
#   DEBUG, MWARN,                   (*DEBUG CODE WANTED, MARGINS WARNING      *)
"&&"FLIPDEBUG, NOPACKING,           (*DEBUG FLIPPED, PACKING SUPPRESSED       *)
"&&" NESTCOMM, MUSIC,               (*NESTED COMMENTS ALLOWED, MUSIC SYSTEM   *)
"&&" WARNING, EXTUSED,              (*WARNINGS WANTED, EXTENSIONS USED        *)
#   ASSEMBLE, ASMVERB,              (*POSTPROCESSOR TRANSLATION, VERBOSE      *)
    XLINK, GET_STAT,                (*EXTERNAL LINKAGE, NAME CHANGE FLAG      *)
#   SAVEREGS, SAVEFPRS: BOOLEAN;
"&&" LISTTAG:   CHAR;               (* LISTING TAG, 'D'/'C'/'N'/' '           *)
"&&"DEBUG_LEV:  0 .. 9;
#
                                    (*POINTERS:                               *)
                                    (**********                               *)

"@@" INPUTPTR, OUTPUTPTR: CTP;      (* PREDEFINED FILES INPUT + OUTPUT  *)
    INTPTR,REALPTR,CHARPTR,BOOLPTR,
    NILPTR,TEXTPTR,ALFAPTR: STP;    (*POINTERS TO ENTRIES OF STANDARD IDS     *)
    UTYPPTR,UCSTPTR,UVARPTR,
    UFLDPTR,UPRCPTR,UFCTPTR,        (*POINTERS TO ENTRIES FOR UNDECLARED IDS  *)
"&&" MAINPROG,                      (*POINTER TO $MAINBLK ENTRY               *)
"&&"FRTPARHD,                       (*POINTER TO LIST OF FORTRAN PROC PARMS   *)
    FWPTR: CTP;                     (*HEAD OF CHAIN OF FORW DECL TYPE IDS     *)
#   FILEHEAD: FRECPTR ;             (*HEAD OF CHAIN OF EXTERNAL FILES         *)
"&&" OPEN_RECORD: STP;              (*CURRENT RECORD OPENED BY "WITH"         *)
    GLOBTESTP: TESTP;               (*LAST TESTPOINTER                        *)
"&&" PRNTTYPHD: PRNTTYLISTP;        (*LIST OF HEAP STORAGE ITEMS FOR DEBUG    *)
"&&" PRNTTYNO:  0..999;


                                    (*BOOKKEEPING OF DECLARATION LEVELS:      *)
                                    (***********************************      *)

    LEVEL: LEVRANGE;                (*CURRENT STATIC LEVEL                    *)
"&&" STMTNEST: 0 .. 100;            (*CURRENT STATEMENT NESTING               *)
    DISX,                           (*LEVEL OF LAST ID SEARCHED BY SEARCHID   *)
"&&"TOP: -1..DISPLIMIT;             (*TOP OF DISPLAY                          *)

    DISPLAY:                        (*WHERE:   MEANS:                         *)
      ARRAY [DISPRANGE] OF
        PACKED RECORD               (*=BLCK:   ID IS VARIABLE ID              *)
          CASE OCCUR: WHERE OF      (*=CREC:   ID IS FIELD ID IN RECORD WITH  *)
            BLCK: (FLABEL: LBP);    (*         CONSTANT ADDRESS               *)
            CREC: (CLEV: LEVRANGE;  (*=VREC:   ID IS FIELD ID IN RECORD WITH  *)
                  CDSPL: ADDRRANGE);(*         VARIABLE ADDRESS               *)
            VREC: (VDSPL: ADDRRANGE)
          END;                      (* --> PROCEDURE WITHSTATEMENT            *)


                                    (*RUN-TIME PROFILER COUNTERS              *)
                                    (***************************              *)

"CT"  CTRCNT     : CTRRANGE;
"CT"  CTRCNTLBL  : LABELRNG;
"CT"  CTROPTION  : BOOLEAN;



                                    (*EXPRESSION COMPILATION:                 *)
                                    (************************                 *)

    GATTR        : ATTR;            (*DESCRIBES THE EXPR CURRENTLY COMPILED   *)

    MXINT10      : INTEGER;

                                    (*BUFFERS, READ ONLY TABLES ETC.          *)
                                    (******************************           *)

    LSTOP        : CHAR;                      (*MARKS THE BEGINNING OF LINEBUF*)
    LINEBUF      : ARRAY [1..BUFLEN] OF CHAR; (*CURRENT LINE BUFFER           *)
"NH"LMARGIN, RMARGIN, LINELEN, BUFEND,
"NH"LASTCOL      : 0..BUFLEN;                 (*LEFT, RIGHT MARGINS ant PTRS  *)

"&&"INTLABEL, PROCLAB, XLABNO: LABELRNG ;

#   CALL_LVL     : ARRAY[BOOLEAN] OF INTEGER ;

"&&" SOP          : PACKED ARRAY [CHAR] OF OPERATOR;
     UPSHIFT      : ARRAY [char (*SHOULD BE CHAR*) ] OF CHAR ;          (*opp*)
"&&" SSY          : PACKED ARRAY [char (*SHOULD BE CHAR*)] OF SYMBOL;   (*opp*)
"&&" BUCKET      : HASH_TABLE;


"SY"                                (* SYMBOL TABLE USAGE STATISTICS          *)
"SY"                                (* ****** ***** ***** **********          *)
"SY"
"SY" FENT_CNT, SF_CNT, SF_TOT,      (* # FIELD ENTRIES, SEARCHES, PRODUCT     *)
"SY" WE_CNT, RE_CNT,                (* # "WITH" LOOKUPS, # RECORDS            *)
"SY" WS_CNT:          INTEGER;      (* # WITH STATEMENTS                      *)
"SY" PROC_CNT, ENT_CNT: ARRAY[LEVRANGE] OF INTEGER;
"SY" LU_CNT: ARRAY[LEVRANGE,DISPRANGE] OF INTEGER;
"SY" WLU_CNT: ARRAY[1..10,1..10] OF INTEGER;

                                    (*ERROR MESSAGES:                         *)
                                    (****************                         *)

#   ERRLOG       : ARRAY [0..MAXERRLOG(* = 400 DIV SSETMAX+1*)] OF SSETRANGE;
"&&"ERRORCNT, WARNCNT,              (*ERRORS AND WARNINGS COUNTS              *)
#   CTIME:      INTEGER;            (*COMPILATION TIME                        *)
    ERRINX       : 0..10;           (*NR OF ERRORS IN CURRENT SOURCE LINE     *)
"&&"ERRKIND      : CHAR;            (*KIND OF ERROR, 'E' / 'W' (WARNING)      *)
    ERRLIST      : ARRAY[1..10] OF
"&&"                 PACKED RECORD NMR: 1..401;
"&&"                        KIND: CHAR;  POS: 1..81
                     END;

                                   (* STRUCTURE CONSTANTS, READ-ONLY TABLES   *)
                                   (* ********* *********  **** **** ****** *)
CONST
"&&"  BLANKID: ALPHA = '            ';
"&&"  CONSTBEGSYS: SETOFSYS =
"&&"      (/ADDOP,INTCONST,REALCONST,STRINGCONST,IDENT/);
"&&"  SIMPTYPEBEGSYS: SETOFSYS =
"&&"      (/ADDOP,INTCONST,REALCONST,STRINGCONST,IDENT,LPARENT/);
"&&"  TYPEBEGSYS: SETOFSYS =
"&&"      (/ARROW,PACKEDSY,ARRAYSY,RECORDSY,SETSY,FILESY,ADDOP,INTCONST,
"&&"        REALCONST,STRINGCONST,IDENT,LPARENT/);
"&&"  TYPEDELS: SETOFSYS =
"&&"      (/ARRAYSY,RECORDSY,SETSY,FILESY,PACKEDSY/);
"&&"  BLOCKBEGSYS: SETOFSYS =
"&&"      (/LABELSY,CONSTSY,TYPESY,VARSY,PROCSY,FUNCSY,BEGINSY/);
"&&"  SELECTSYS: SETOFSYS =
"&&"      (/ARROW,PERIOD,LBRACK,LPARENT/);
"&&"  FACBEGSYS: SETOFSYS =
"&&"      (/INTCONST,REALCONST,STRINGCONST,IDENT,LPARENT,LBRACK,NOTSY/);
"&&"  STATBEGSYS: SETOFSYS =
"&&"      (/BEGINSY,GOTOSY,IFSY,WHILESY,REPEATSY,FORSY,WITHSY,CASESY/);
"&&"  RW: ARRAY(/1..NRSW/) OF ALPHA =
"&&"       ('IF          ', 'DO          ', 'OF          ', 'TO          ',
"&&"        'IN          ', 'OR          ', 'END         ', 'FOR         ',
"&&"        'VAR         ', 'DIV         ', 'MOD         ', 'SET         ',
"&&"        'AND         ', 'NOT         ', 'THEN        ', 'ELSE        ',
"&&"        'WITH        ', 'GOTO        ', 'CASE        ', 'TYPE        ',
"&&"        'FILE        ', 'BEGIN       ', 'UNTIL       ', 'WHILE       ',
"&&"        'ARRAY       ', 'CONST       ', 'LABEL       ', 'REPEAT      ',
"&&"        'RECORD      ', 'DOWNTO      ', 'PACKED      ', 'FORWARD     ',
"&&"        'PROGRAM     ', 'FORTRAN     ', 'EXTERNAL    ', 'FUNCTION    ',
"&&"        'PROCEDURE   ', 'OTHERWISE   ' );
"&&"  FRW: ARRAY(/1..14/) OF 1..NRSW1 =
"&&"       (1, 1, 7, 15, 22, 28, 32, 35, 37, 39, 39, 39, 39, 39);
"&&"  RSY: ARRAY(/1..NRSW/) OF SYMBOL =
"&&"       (IFSY, DOSY, OFSY, TOSY, RELOP, ADDOP, ENDSY, FORSY,
"&&"        VARSY, MULOP, MULOP, SETSY, MULOP, NOTSY, THENSY, ELSESY,
"&&"        WITHSY, GOTOSY, CASESY, TYPESY, FILESY, BEGINSY, UNTILSY, WHILESY,
"&&"        ARRAYSY, CONSTSY, LABELSY, REPEATSY,
"&&"        RECORDSY, DOWNTOSY, PACKEDSY, FORWARDSY,
"&&"        PROGSY, FRTRNSY, EXTRNSY, FUNCSY, PROCSY, OTHERWISESY);
"&&"  ROP: ARRAY(/1..NRSW/) OF OPERATOR =
"&&"       (NOOP, NOOP, NOOP, NOOP, INOP, OROP, NOOP, NOOP,
"&&"        NOOP, IDIV, IMOD, NOOP, ANDOP, NOOP, NOOP, NOOP,
"&&"        NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP,
"&&"        NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP, NOOP,
"&&"        NOOP, NOOP, NOOP, NOOP, NOOP, NOOP);
"&&"  MN: ARRAY(/0..OPMAX/) OF ARRAY(/1..4/) OF CHAR =
"&&"       (' ABI', ' ABR', ' ADI', ' ADR', ' AND', ' DIF', ' DVI', ' DVR',
"&&"        ' SBR', ' FLO', ' FLT', ' INN', ' INT', ' IOR', ' MOD', ' MPI',
"&&"        ' MPR', ' NGI', ' NGR', ' NOT', ' ODD', ' SBI', ' DEC', ' INC',
"&&"        ' SQI', ' SQR', ' STO', ' TRC', ' RND', ' SCL', ' CSP', ' UNI',
"&&"        ' ENT', ' FJP', ' POP', ' IND', ' IXA', ' LCA', ' CTS', ' CTI',
"&&"        ' MOV', ' MST', ' RET', ' STP', ' XJP', ' CHK', ' CUP', ' EQU',
"&&"        ' GEQ', ' GRT', ' LDA', ' LDC', ' LEQ', ' LES', ' LOD', ' NEQ',
"&&"        ' STR', ' UJP', ' NEW', ' SAV', ' RST', ' ORD', ' CHR', ' DEF',
"&&"        ' LAB', ' CRD', ' XPO', ' ASE', ' SLD', ' SMV', ' DFC', ' CST',
"&&"        ' BGN', ' UXJ', ' XLB', ' END', ' PAK' );
"&&"  SNA: ARRAY(/0..NSPROC/) OF ARRAY(/1..3/) OF CHAR =
"&&"       ('PAG', 'GET', 'PUT', 'RES', 'REW', 'RDC', 'WRI', 'WRE',
"&&"        'WRR', 'WRC', 'WRS', 'PAK', 'RDB', 'WRB', 'RDR', 'RDH',
"&&"        'RDY', 'EOL', 'EOT', 'RDD', 'WRD', 'CLK', 'WLN', 'RLN',
"&&"        'RDI', 'EOF', 'ELN', 'RDS', 'TRP', 'XIT', 'FDF', 'SIO',
"&&"        'EIO', 'MSG', 'SKP', 'LIM', 'TRA');

(*----------------------------------------------------------------------------*)



  PROCEDURE ERROR(FERRNR: ERRCODE);
  VAR  I : 0..10 (*MAXERRNR DIV SETMAX*) ;
  BEGIN
"&&" IF (ERRKIND <> 'W') OR WARNING THEN
"&&"   BEGIN
        IF ERRINX >= 9 THEN
"&&"      BEGIN  FERRNR := 255;  ERRINX := 10  END
"&&"    ELSE ERRINX := ERRINX + 1;
"&&"    WITH ERRLIST(/ERRINX/) DO
"&&"      BEGIN  KIND := ERRKIND;  NMR := FERRNR;  POS := CHCNT  END;
#       I := FERRNR DIV (SSETMAX+1) ;
#       ERRLOG[I] := ERRLOG[I]+ [FERRNR MOD (SSETMAX+1)] ;
"&&"    IF ERRKIND <> 'W' THEN ERRORCNT := ERRORCNT + 1
"&&"    ELSE                   WARNCNT  := WARNCNT  + 1;
"&&"  END;
"&&"  ERRKIND := 'E';
  END (*ERROR*) ;


PROCEDURE PRINTLINE ;
VAR  DCN: ADDRRANGE;
# BEGIN
"&&"   IF PLCNT >= PAGESIZE THEN
"&&"   BEGIN
#       PAGECNT := PAGECNT+1 ;  PLCNT := 0 ;
#       WRITELN(OUTPUT, '1  LINE #  D/NEST  LVL',
#                   '< STANFORD PASCAL,   MCGILL VERSION OF ':44,
#                   VERSION, ' >', TIME:14, DATE, 'PAGE':8, PAGECNT:4) ;
#       WRITELN(OUTPUT, '------  ------  ---':22,
#                   '---- ---':89) ;
#       WRITELN(OUTPUT) ;
"&&"  END;
"&&"  IF LINECNT > LASTLINELISTED THEN
"&&"    BEGIN  LASTLINELISTED := LINECNT;
"&&"      PLCNT := PLCNT + 1;
"&&"      WRITE(OUTPUT, LINECNT:9);
"&&"      IF LISTTAG = 'N' THEN DCN := STMTNEST ELSE
"&&"        IF LISTTAG = 'D' THEN DCN := LC       ELSE
"&&"          IF LISTTAG = 'C' THEN DCN := CONSTLC  ELSE DCN := 0;
"&&"      IF DCN > 0 THEN WRITE(OUTPUT, DCN:7, LISTTAG, LEVEL:3 )
"&&"      ELSE            WRITE(OUTPUT, ' ':11 );
"&&"      WRITELN(OUTPUT, ') ', LINEBUF:LINELEN );
"&&"    END;
# END (*PRINTLINE*) ;


PROCEDURE PRINTERROR ;
"&&" VAR LASTPOS,FREEPOS,CURRPOS,CURRNMR,F,K,DCN: INTEGER;
"&&"     CURRKIND,LASTKIND: CHAR;
# BEGIN
"&&" PRINTLINE;
#   PLCNT := PLCNT+2;  (* TWO LINES OF ERROR INFO *)
#   WRITE(OUTPUT,'****':9, ' ':13) ;
"&&" LASTPOS := 0;  FREEPOS := 1;  LASTKIND := '?';
#   FOR K := 1 TO ERRINX DO
#     BEGIN
#       WITH ERRLIST[K] DO
"&&"      BEGIN  CURRPOS := POS;  CURRNMR := NMR;  CURRKIND := KIND  END;
#       IF CURRPOS = LASTPOS THEN
"&&"      IF CURRKIND = LASTKIND THEN WRITE(OUTPUT,',')
"&&"      ELSE                        WRITE(OUTPUT,CURRKIND)
#       ELSE
"&&"      BEGIN  LASTKIND := CURRKIND;
#           WHILE FREEPOS < CURRPOS DO
#             BEGIN WRITE(OUTPUT,' '); FREEPOS := FREEPOS + 1 END;
"&&"        WRITE(OUTPUT,CURRKIND);
#           LASTPOS := CURRPOS
#         END;
#       IF CURRNMR < 10 THEN F := 1
#       ELSE IF CURRNMR < 100 THEN F := 2
#         ELSE F := 3;
#       WRITE(OUTPUT,CURRNMR:F);
#       FREEPOS := FREEPOS + F + 1
#     END;
"&&" WRITELN(OUTPUT);  ERRINX := 0 ;  IF ERRORCNT>0 THEN PRCODE := FALSE ;
#   IF ERRLN > 0 THEN
#     WRITELN(OUTPUT,'****':9,'  PREVIOUS ERROR/WARNING ON LINE -->', ERRLN:4);
#   ERRLN := LINECNT;
# END (*PRINTERROR*) ;


PROCEDURE ENDOFLINE ;
# LABEL 10;
"&&" VAR I: 1..9;  DCN: INTEGER;
  BEGIN   IF ERRINX > 0 THEN PRINTERROR ;
#   READLN(INPUT, LINEBUF);
    LINELEN := BUFEND;   (*THIS WILL SPEED THINGS UP IF NO MARGIN IS SET/RESET*)

    (*$D-  ... MUST BE IN EFFECT FOR THIS LOOP*)
      REPEAT  LINELEN := LINELEN - 1;
      UNTIL   LINEBUF[LINELEN] <> ' ';
    (* if needed, debug switch should be restored here ---> $D+*)
10:
    IF LINELEN > RMARGIN THEN  BEGIN  MWARN := TRUE;  LASTCOL := RMARGIN END
    ELSE LASTCOL := LINELEN;
#   LINECNT := LINECNT+1 ;
"&&" IF LIST THEN PRINTLINE;
"&&" IF HP THEN BEGIN  IC := 0;  LISTTAG := ' ';  HP := FALSE END;
#   LINEBUF[LASTCOL+1] := '#';    (*TO STOP 'SKIPBLNK' + PROVIDE VALID EOL CH.*)
#   CHCNT := LMARGIN;
  END  (*ENDOFLINE*) ;


# PROCEDURE LISTMSGS ;
#   VAR I, J : ERRCODE ;
#       MSG  : ARRAY[1..64] OF CHAR ;
#   BEGIN
#      WRITELN(OUTPUT);
#      IF ERRLN > 0 THEN
#        BEGIN  WRITELN(OUTPUT, '****':9,
"&&"              '  LAST ERROR/WARNING ON LINE -->', ERRLN:4 );
#               WRITELN(OUTPUT);
#        END;
#      WRITELN(OUTPUT);
"&&"   WRITELN(OUTPUT, '****':9, '  ERROR/WARNING CODES FOR THIS PROGRAM :') ;
#      WRITELN(OUTPUT) ;   RESET(PRD) ;   J := 0 ;
#      FOR I := 1 TO MAXERRNR DO
#        IF (I MOD (SSETMAX+1)) IN ERRLOG[I DIV (SSETMAX+1)] THEN
#           BEGIN
#           WHILE (NOT EOF(PRD)) AND (I > J) DO  READLN(PRD, J, MSG) ;
#           IF J = I THEN  WRITELN('****':9, J:6, MSG) ;
#           END ;
#   END (*LISTMSGS*);


# PROCEDURE GOODBYE;
#   BEGIN
#    CTIME := (CLOCK(0)-CTIME);
"&&" IF PAGECNT = 0 THEN  (* NO HEADING EVER PRINTED, DO ONE NOW *)
"&&"   WRITELN(OUTPUT, '****':9,
"&&"     'STANFORD PASCAL COMPILER, MCGILL VERSION OF ':50, VERSION);
"&&" IF NOT MUSIC THEN WRITELN(OUTPUT);
"&&" IF WARNING THEN
"&&"   BEGIN
"&&"     IF EXTUSED THEN
"&&"     WRITELN(OUTPUT, '0', '****':8, '  WARNING: PASCAL EXTENSIONS USED.');
"&&"     IF WARNCNT > 0 THEN WRITELN(OUTPUT, '0', '****':8,
"&&"          WARNCNT:8, '  WARNING MESSAGE(S) ISSUED.' );
#       IF MWARN THEN
#      WRITELN(OUTPUT, '0', '****':8, '  CONTENTS OF SOURCE LINES OUTSIDE  ',
#                      LMARGIN:1, '..', RMARGIN:1, '  MARGINS IGNORED.');
"&&"  END (* IF WARNING *) ;
"&&" IF NOT MUSIC THEN WRITELN(OUTPUT);
#    IF ERRORCNT = 0 THEN  WRITE(OUTPUT, '****      NO':17)
#    ELSE  WRITE(OUTPUT, '****':9, ERRORCNT:8) ;
#    WRITELN(OUTPUT, '  SYNTAX ERROR(S) DETECTED.');
"&&" IF NOT MUSIC THEN WRITELN(OUTPUT);
#    WRITELN(OUTPUT, '****':9, LINECNT:8, '  LINE(S) READ, ', PROCLAB:4,
#                    ' PROCEDURE(S) COMPILED,');
"&&" IF NOT MUSIC THEN WRITELN(OUTPUT);
#    WRITELN(OUTPUT, '****':9, OLDIC:8,'  P_INSTRUCTIONS GENERATED,',
#                    CTIME*0.001:7:2, ' SECONDS IN COMPILATION.') ;
#    IF ERRORCNT > 0 THEN  LISTMSGS ;
#    EXIT(ERRORCNT) ;
#   END (*GOODBYE*) ;


#   PROCEDURE FATALERROR( CODE: ERRCODE );
#     BEGIN
#     ERROR(CODE);
#     PRINTERROR;
#     IF CODE <> 390 THEN
#        WRITELN(OUTPUT, '0    ****   FATAL ERROR - ',
#                'COMPILATION TERMINATED PREMATURELY.' );
#     GOODBYE;
#     END (*EOFEXIT*) ;


  PROCEDURE INSYMBOL;
    (*READ NEXT BASIC SYMBOL OF SOURCE PROGRAM AND RETURN ITS
    DESCRIPTION IN THE GLOBAL VARIABLES SY, OP, ID, VAL AND LNGTH*)
    LABEL 1,2,3;
"&&"VAR I,K,STATE: INTEGER;
        DIGIT: PACKED ARRAY [1..REALLNGTH] OF CHAR;
        STRING: PACKED ARRAY [1..STRGLNGTH] OF CHAR;
"&&"    LVP: CSP;  TEST,DIGSEEN: BOOLEAN;


#   PROCEDURE SKIPBLNK;
#   (* SKIP BLANKS, ENDOFLINE, AND (OPTIONAL) MARGIN, SKIPS AT LEAST ONE CHAR *)
#
#     BEGIN
#       REPEAT
#
#       IF EOL THEN
#         BEGIN
#         IF EOF(INPUT)  THEN  FATALERROR( 390 ) ;
#         ENDOFLINE ;
#         END ;
#
#        REPEAT CHCNT := CHCNT+1;  UNTIL LINEBUF[CHCNT] <> ' ';
#        (* NOTE THAT LINEBUF[LINELEN+1] <> ' ' *)
#        EOL := CHCNT > LASTCOL;
#        UNTIL NOT EOL ;
#      CH := LINEBUF[CHCNT] ;
#    END (*SKIPBLNK*) ;


    PROCEDURE NEXTCH;
#     BEGIN
#     IF EOL THEN
#        BEGIN
#        IF EOF(INPUT)  THEN  FATALERROR( 390 ) ;
#        ENDOFLINE ;
#        END ;
#     CHCNT := CHCNT+1;  EOL := (CHCNT > LASTCOL);
#     CH := LINEBUF[CHCNT] ;
#     END;


#     PROCEDURE OPTIONS(CCH: CHAR (*COMMENT TERMINATOR CH*) );
"&&"     VAR SCH: CHAR;  OLDLIST: BOOLEAN;
#
#     FUNCTION DECNUM : INTEGER;
#       VAR NUM: INTEGER;
#       BEGIN
#          NUM := 0;  NEXTCH;
#          WHILE CH >= '0' DO
#             BEGIN  NUM := NUM*10+ORD(CH)-ORD('0');  NEXTCH  END;
#          DECNUM := NUM
#       END;
#
#     BEGIN
#       REPEAT  NEXTCH;
"&&"       IF CH IN ['a'..'z', 'A'..'Z'] THEN
"&&"         BEGIN
"&&"           SCH := UPSHIFT[CH];  NEXTCH;
"&&"           CASE SCH OF
"&&"           'L': BEGIN
"&&"                  OLDLIST := LIST;  LIST := CH <> '-';
"&&"                  IF NOT OLDLIST THEN IF LIST THEN PRINTLINE;
"&&"                END;
"&&"           'C': PRCODE := CH <> '-';
"&&"           'E': IF LIST THEN PLCNT := PAGESIZE;
"&&"           'A': ASSEMBLE := CH = '+';
"&&"           'M': BEGIN
                      IF CH = '+' THEN
                         BEGIN  LMARGIN := 0;  RMARGIN := 72;  END
                      ELSE IF CH = '-' THEN
                         BEGIN  LMARGIN := 0;  BUFEND := BUFLEN;
                                RMARGIN := BUFLEN;  END
                      ELSE IF CH = '(' THEN
                         BEGIN  LMARGIN := DECNUM - 1;
                           IF LMARGIN < 0 THEN LMARGIN := 0;
                           IF CH = ',' THEN  RMARGIN := DECNUM
                                       ELSE  RMARGIN := BUFLEN;
                           IF (RMARGIN <= LMARGIN) OR
                              (RMARGIN >= BUFLEN) THEN
                                 RMARGIN := BUFLEN-1;
                           BUFEND := BUFLEN;
                         END
                   END;
"&&"           'S': SAVEREGS := CH <> '-';
"&&"           'F': SAVEFPRS := CH <> '-';
"&&"           'D': IF CH >= '0' THEN
"&&"                  BEGIN  DEBUG_LEV := ORD(CH) - ORD('0');
"&&"                         DEBUG := DEBUG_LEV >= 2;
"&&"                  END
"&&"                ELSE
"&&"                  BEGIN  DEBUG := CH <> '-';
"&&"                         DEBUG_LEV := ORD(DEBUG)*2;
"&&"                  END;
"&&"           'V': ASMVERB := CH = '+';
"&&"           'W': WARNING := CH <> '-';
"&&"           'U': GET_STAT := CH = '+';
"&&"           'P': NOPACKING := CH = '-';
"&&"           'X': BEGIN
#                     XLINK := CH = '+';
#                     (* XLINK --> ALLOW '$' AS FIRST CH.*)
#                     IF XLINK THEN  SOP['$'] := ATOZCH;
#                   END;
"&&"           'K': CTROPTION := CH = '+';
"&&"           'N': NESTCOMM := CH = '+';
"&&"           'Z': MUSIC := CH = '+';
"&&"          END;
#             IF CH <> CCH THEN
"&&"             IF CH <> ',' THEN  NEXTCH;
#           END
#       UNTIL CH <> ','
#     END (*OPTIONS*) ;


#   PROCEDURE COMMENT(CCH: CHAR (*COMMENT DELIMITER CHARACTER*) );
#
#     BEGIN (*COMMENT*)
#
#       REPEAT
#
#       IF CH <> CCH THEN
#         REPEAT
#         IF NESTCOMM THEN
#           BEGIN
"DE" #      IF CH = CHLBRACE THEN
"DE" #         IF CCH = CHRBRACE THEN  BEGIN  EOL := FALSE;
"DE" #         COMMENT(CHRBRACE)  END;
#           IF CH = '(' THEN
#              IF LINEBUF[CHCNT+1] = '*' THEN
#                 IF CCH = '*' THEN  (*TO PREVENT
                        LEFTPAREN RIGHTBRACE FROM GOING THROUGH*)
#                    BEGIN  EOL := FALSE;  NEXTCH;  NEXTCH;  COMMENT('*')  END;
#           END;
#
#         IF CHCNT > LASTCOL THEN
#           BEGIN  IF EOF(INPUT) THEN FATALERROR( 390 ) ;
#           ENDOFLINE ;
#           END ;
#
#         CHCNT := CHCNT+1 ;
#         CH := LINEBUF[CHCNT] ;
#         UNTIL CH = CCH ;
#
#       IF CCH = '*' THEN
#         BEGIN
#         CHCNT := CHCNT+1 ;
#         CH := LINEBUF[CHCNT] ;
#         END
#       ELSE CH := ')' (*CHEATING A BIT*);
#
#       UNTIL CH = ')' ;
#
#     EOL := FALSE;    (*PREPARE FOR NEXT CALL TO 'NEXTCH'*)
#     END (*COMMENT*) ;
#
#

  BEGIN (*INSYMBOL*)
  1:
#   IF CH = ' ' THEN SKIPBLNK ;
#   CASE SOP[CH] OF
#     ATOZCH :
#       BEGIN   K := 0 ;   ID := BLANKID ;
#         REPEAT
#         IF K < IDLNGTH THEN
#           BEGIN K := K + 1; ID[K] := UPSHIFT[CH] (*CH*) END ;        (*UPL*)
#         NEXTCH
#         UNTIL NOT(SOP[CH] IN [ATOZCH, NUMCH, UNDSCH, DOLLARCH]) ;
#
          FOR I := FRW[K] TO FRW[K+1] - 1 DO
            IF RW[I] = ID THEN
              BEGIN SY := RSY[I]; OP := ROP[I]; GOTO 2 END;
            SY := IDENT; OP := NOOP;
  2:    END;

#     NUMCH :
"&&"    BEGIN OP := NOOP; K := 0;  SY := REALCONST;  STATE := 0;
"&&"      REPEAT
"&&"        DIGSEEN := FALSE;
"&&" 3:     K := K + 1;  IF K <= DIGMAX THEN DIGIT[K] := CH;
"&&"        NEXTCH;
"&&"        IF SOP[CH] = NUMCH THEN
"&&"          BEGIN  DIGSEEN := TRUE;  GOTO 3  END;
"&&"        IF DIGSEEN THEN STATE := STATE + 1;
"&&"        CASE STATE OF
"&&"0,1:      (* LEADING DIGIT SEQUENCE SCANNED *)
"&&"          IF CH = '.' THEN            STATE := 2
"&&"          ELSE IF CH = 'E' THEN       STATE := 4
"&&"            ELSE IF CH = 'e' THEN     STATE := 4
"&&"              ELSE BEGIN  SY := INTCONST;  STATE := 0  END;
"&&"2:        (* DECIMAL POINT JUST SCANNED *)
"&&"          IF CH = '.' THEN
"&&"            BEGIN  SY := INTCONST;  K := K - 1;
"&&"                   DOTFLG := TRUE;  STATE := 0   END
"&&"          ELSE IF UPSHIFT[CH] = 'E' THEN
"&&"              BEGIN  K := K - 1;  STATE := 4  END
"&&"            ELSE  STATE := -1;
"SY"3:        (* DIGIT SEQUENCE AFTER POINT JUST SEEN *)
"&&"          IF CH = 'E' THEN      STATE := 4
"&&"          ELSE IF CH = 'e' THEN STATE := 4
"&&"            ELSE STATE := 0;
"&&"4:        (* EXPONENT SYMBOL JUST SEEN *)
"&&"          IF CH = '-' THEN       STATE := 6
"&&"          ELSE IF CH = '+' THEN  STATE := 6
"&&"            ELSE  STATE := -1;
"&&"5,7:      (* DIGIT STRING IN EXPONENT JUST SEEN *)
"&&"          STATE := 0;
"&&"6:        (* BAD CHARACTER AFTER 'E+' OR 'E-' FOUND *)
"&&"          STATE := -1;
"&&"        END;
"&&"      UNTIL STATE <= 0;
"&&"      IF STATE < 0 THEN  (* LEXICAL ERROR IN REAL CONST *)
"&&"        ERROR(201);
"&&"      IF SY = REALCONST THEN
"&&"        BEGIN
"&&"          NEW( VAL.VALP, REEL );
"&&"          WITH VAL.VALP@ DO
"&&"            BEGIN FOR I := 1 TO REALLNGTH DO RVAL[I] := ' ';
"&&"              IF K <= DIGMAX THEN
"&&"                FOR I := 2 TO K + 1 DO RVAL[I] := DIGIT[I-1]
"&&"              ELSE BEGIN ERROR(203);
"&&"                     UNPACK('0.0',RVAL,2)
"&&"                   END
"&&"            END;
"&&"        END
"&&"      ELSE
"&&"        BEGIN
"&&"          VAL.IVAL := 0;
"&&"          IF K> DIGMAX THEN
"&&"            ERROR(203)
"&&"          ELSE WITH VAL DO
"&&"              FOR I := 1 TO K DO
"&&"                IF IVAL <= MXINT10 THEN
"&&"                  IVAL := IVAL*10 + (ORD(DIGIT[I])-ORD('0'))
"&&"                ELSE BEGIN ERROR(203); IVAL := 0 END
"&&"        END
        END;

#     QUOTCH   "''''  " :
        BEGIN LNGTH := 0; SY := STRINGCONST;  OP := NOOP;
          REPEAT
"&&"        REPEAT NEXTCH;
"&&"               IF EOL THEN BEGIN ERROR(202); CH := '''' END;
"&&"               LNGTH := LNGTH + 1;
                   IF LNGTH <= STRGLNGTH THEN STRING[LNGTH] := CH
"&&"        UNTIL CH = '''';
"&&"      NEXTCH
          UNTIL CH <> '''';
          LNGTH := LNGTH - 1;   (*NOW LNGTH = NR OF CHARS IN STRING*)
          IF LNGTH = 1 THEN VAL.IVAL := ORD(STRING[1])
          ELSE
            BEGIN   NEW(LVP,STRG);
              IF LNGTH > STRGLNGTH THEN
                BEGIN ERROR(398); LNGTH := STRGLNGTH END;
#             IF LNGTH <= 0 THEN ERROR(205) ;
              WITH  LVP@  DO
                BEGIN SLNGTH := LNGTH;
"&&"              SVAL := STRING
                END;
              VAL.VALP := LVP
            END
        END;

#     COLONCH   "':'  ":
        BEGIN OP := NOOP; NEXTCH;
          IF CH = '=' THEN
            BEGIN SY := BECOMES; NEXTCH END
          ELSE SY := COLON
        END;

#     DOTCH   "'.'  " :
        BEGIN  OP := NOOP;  IF NOT DOTFLG THEN NEXTCH;
          IF CH = '.' THEN
            BEGIN  SY := DOTDOT;  DOTFLG := FALSE ;  NEXTCH  END
          ELSE SY := PERIOD
        END;

#     LTOP   "'<'  " :
        BEGIN NEXTCH; SY := RELOP;
          IF CH = '=' THEN
            BEGIN OP := LEOP; NEXTCH END
          ELSE
            IF CH = '>' THEN
              BEGIN OP := NEOP; NEXTCH END
            ELSE OP := LTOP
        END;

#     GTOP   "'>'  ":
        BEGIN NEXTCH; SY := RELOP;
          IF CH = '=' THEN
            BEGIN OP := GEOP; NEXTCH END
          ELSE OP := GTOP
        END;

#     LPARCH   "'('  ":
       BEGIN NEXTCH;
#        IF CH = '*' THEN
            BEGIN  NEXTCH;
            IF CH = '$' THEN OPTIONS('*');
            COMMENT('*');  NEXTCH;  GOTO 1;
            END ;
#        IF CH = '/' THEN
#          BEGIN   SY := LBRACK ;  OP := NOOP ;
#          NEXTCH
#          END
         ELSE  BEGIN  SY := LPARENT; OP := NOOP  END
       END;

#     PLUS, MINUS, MUL, RDIV, EQOP, OROP, ANDOP, SPECH :
        BEGIN SY := SSY[CH]; OP := SOP[CH];
#         IF CH = '/' THEN
#           BEGIN  NEXTCH ;
#             IF CH =')' THEN
#               BEGIN  SY := RBRACK ;  OP := NOOP ;
#                 NEXTCH ;
#               END
#           END
#         ELSE  NEXTCH
        END;

#     DQUOTCH (* '"' *) :
#       BEGIN   REPEAT NEXTCH UNTIL CH = '"' ;
#         NEXTCH ;   GOTO 1 ;
#       END ;

#     LBRACE :
#       BEGIN  NEXTCH;
"DE"    IF CH = '$' THEN OPTIONS(CHRBRACE);
"DE"    COMMENT(CHRBRACE);  NEXTCH;  GOTO 1;
        END;

#     SKIPCH   "'#'  " :
#       BEGIN  NEXTCH ;  GOTO 1  END ;
#
#     ILLEGCH, DOLLARCH, UNDSCH   "'¢','_','$'  ":
#       BEGIN SY := OTHERSY; OP := NOOP; ERROR(6) ; NEXTCH END

    END (*CASE*)

  END (*INSYMBOL*) ;


"&&"  FUNCTION HASH( ID: ALPHA ): BKT_RNG;
"&&"    VAR  OL: RECORD  CASE INTEGER OF
"&&"               1:  ( IDK: ALPHA );
"&&"               2:  ( INT1, INT2, INT3: INTEGER )
"&&"             END;
"&&"    BEGIN
"&&"      WITH OL DO
"&&"        BEGIN  IDK := ID;  (* NO OVERFLOW CHECK FOR NEXT STMT *)
"&&"          HASH := ABS( (INT1*2 + INT2)*2 + INT3 ) MOD (MAX_BKT+1);
"&&"        END
"&&"    END  (* HASH *) ;


"&&"  PROCEDURE ENTERID( FCP: CTP );
"&&"  LABEL 1;
"&&"  VAR  K: BKT_RNG;  NAM: ALPHA;  LCP: CTP;
"&&"  BEGIN
"&&"    NAM := FCP@.NAME;  K := HASH( NAM );
"&&"    LCP := BUCKET[K];
"&&"    FCP@.DECL_LEV := LEVEL;
"&&"    FCP@.NEXT_IN_BKT := LCP;  BUCKET[K] := FCP;
"&&"    (* NOW CHECK FOR DUPLICATE DECLARATION *)
"&&"    WHILE LCP <> NIL DO
"&&"      WITH LCP@ DO
"&&"        BEGIN
"&&"          IF NAME = NAM THEN
"&&"            IF KLASS <> FIELD THEN
"&&"              BEGIN
"&&"                IF TOP = DECL_LEV THEN
"&&"                  BEGIN  ERROR(101);  GOTO 1  END
"&&"              END
"&&"            ELSE  (* SPECIAL LOOKUP FOR FIELDS *)
"&&"              IF TOP = OWNER@.FLD_DISP_LEV THEN
"&&"                BEGIN  ERROR(101);  GOTO 1  END;
"&&"          LCP := NEXT_IN_BKT;
"&&"        END;
"&&" 1:
"SY" IF GET_STAT THEN
"SY"   IF TOP = LEVEL THEN ENT_CNT[LEVEL] := ENT_CNT[LEVEL] + 1
"SY"   ELSE                FENT_CNT       := FENT_CNT       + 1;
"&&"  END  (* ENTERID *) ;


"&&"  PROCEDURE SEARCHSECTION( FSP: STP; VAR FCP: CTP );
"&&"  (* FINDS FIELD IN RECORD STRUCTURE INDICATED BY FSP *)
"&&"  LABEL 1;
"&&"  VAR  LCP: CTP;
"&&"  BEGIN
"&&"    LCP := BUCKET[ HASH(ID) ];
"&&"    WHILE LCP <> NIL DO
"&&"      WITH LCP@ DO
"&&"        BEGIN
"&&"          IF NAME = ID THEN
"&&"            IF KLASS = FIELD THEN
"&&"              IF OWNER = FSP THEN
"SY"              BEGIN
"SY"                IF GET_STAT THEN
"SY"                  BEGIN  SF_CNT := SF_CNT + 1;
"SY"                         SF_TOT := SF_TOT + FSP@.NO_FLDS;
"SY"                  END;
"&&"                GOTO 1;
"SY"              END;
"&&"          LCP := NEXT_IN_BKT;
"&&"        END;
"&&" 1:  FCP := LCP;
"&&"  END  (* SEARCHSECTION *) ;


"&&"  PROCEDURE SEARCHID( FIDCLS: SETOFIDS; VAR FCP: CTP );
"&&"  LABEL 1;
"&&"  VAR  LCP: CTP;  DL,EL: -1..DISPLIMIT;  K: BKT_RNG;
"&&"  BEGIN
"&&"    K := HASH(ID);  LCP := BUCKET[ K ];
"&&"    FCP := NIL;  EL := -1;  DISX := EL;
"&&"    WHILE LCP <> NIL DO
"&&"      WITH LCP@ DO
"&&"        BEGIN
"&&"          IF NAME = ID THEN
"&&"            BEGIN
"&&"              IF KLASS <> FIELD THEN
"&&"                DL := DECL_LEV
"&&"              ELSE
"&&"                DL := OWNER@.FLD_DISP_LEV;
"&&"              IF DL > DISX THEN
"&&"                IF KLASS IN FIDCLS THEN
"&&"                  BEGIN
"&&"                    FCP := LCP;  DISX := DL;
"&&"                    IF TOP = LEVEL THEN  (* NO POINT IN FURTHER SEARCH *)
"&&"                      GOTO 1
"&&"                  END
"&&"                ELSE
"&&"                  EL := DL;
"&&"            END;
"&&"          LCP := NEXT_IN_BKT;
"&&"        END;
"&&"  1:IF EL > DISX THEN  (* BAD IDENTIFIER ENCOUNTERED *)
"&&"      IF PRTERR THEN ERROR(103);
"&&"    IF DISX < 0 THEN
"&&"      BEGIN  (* THE SEARCH WAS UNSUCCESSFUL *)
"&&"        IF PRTERR THEN
"&&"          BEGIN  IF EL < 0 THEN ERROR(104);
"&&"            NEW( LCP );
"&&"            IF (FIELD IN FIDCLS) AND (TOP > LEVEL) THEN
"&&"              LCP@ := UFLDPTR@
"&&"            ELSE IF VARS IN FIDCLS THEN LCP@ := UVARPTR@
"&&"              ELSE IF TYPES IN FIDCLS THEN LCP@ := UTYPPTR@
"&&"                ELSE IF KONST IN FIDCLS THEN LCP@ := UCSTPTR@
"&&"                  ELSE IF PROC IN FIDCLS THEN LCP@ := UPRCPTR@
"&&"                    ELSE  (* FUNC *)          LCP@ := UFCTPTR@;
"&&"            WITH LCP@ DO
"&&"              BEGIN
"&&"                NAME := ID;  (* PREVENT RE-OCCURRENCE OF ERROR *)
"&&"                DECL_LEV := LEVEL;
"&&"                NEXT_IN_BKT := BUCKET(/K/);
"&&"                BUCKET(/K/) := LCP;  FCP := LCP;
"&&"                IF KLASS = FIELD THEN OWNER := OPEN_RECORD;
"&&"              END;
"&&"           DISX := LEVEL;
"&&"          END
"&&"        ELSE DISX := 0;
"&&"      END;
"SY" IF GET_STAT THEN
"SY"   BEGIN
"SY"     IF DISX <= LEVEL THEN
"SY"       LU_CNT[DISX,TOP] := LU_CNT[DISX,TOP] + 1
"SY"     ELSE
"SY"       WLU_CNT[DISX-LEVEL,TOP-LEVEL] := WLU_CNT[DISX-LEVEL,TOP-LEVEL]+1;
"SY"     IF TOP <> LEVEL THEN WE_CNT := WE_CNT + 1
"SY"   END;
"&&"  END  (* SEARCHID *) ;


  PROCEDURE GETBOUNDS(FSP: STP; VAR FMIN,FMAX: INTEGER);
    (*GET INTERNAL BOUNDS OF SUBRANGE OR SCALAR TYPE*)
    (*ASSUME (FSP <> NIL) AND (FSP@.FORM <= SUBRANGE) AND (FSP <> INTPTR)
     AND NOT COMPTYPES(REALPTR,FSP)*)
  BEGIN
    WITH FSP@ DO
      IF FORM = SUBRANGE THEN
        BEGIN FMIN := MIN.IVAL; FMAX := MAX.IVAL END
      ELSE
        BEGIN FMIN := 0;
#         IF FSP = CHARPTR THEN FMAX := ORDCHMAX
          ELSE
            IF (FORM = SCALAR) AND (FSP@.FCONST <> NIL) THEN
              FMAX := FSP@.FCONST@.VALUES.IVAL
            ELSE FMAX := 0
        END
  END (*GETBOUNDS*) ;

#     FUNCTION GETTYPE(OPERAND: STP): INTEGER;
#       BEGIN   GETTYPE := ORD('I') ;  (* ASSUME INTEGER TYPE *)
#         IF OPERAND = NIL THEN  BEGIN IF ERRORCNT = 0 THEN ERROR(401) END
#         ELSE
#           IF OPERAND@.FORM > POWER THEN GETTYPE := ORD('A')
#           ELSE
#             IF OPERAND@.FORM = POWER THEN GETTYPE := ORD('S')
#             ELSE
#               IF OPERAND@.FORM = POINTER THEN GETTYPE := ORD('A')
#               ELSE
#                   IF OPERAND = REALPTR THEN GETTYPE := ORD('R')
#                   ELSE
#                     IF OPERAND = BOOLPTR THEN GETTYPE := ORD('B')
#                     ELSE
"&&"                    IF OPERAND@.SIZE = HINTSIZE THEN
"&&"                      GETTYPE := ORD('H')
"&&"                    ELSE IF OPERAND@.SIZE = CHARSIZE THEN
"&&"                        GETTYPE := ORD('C')
"&&"                      ELSE ;
#       END (*GETTYPE*) ;


"**" FUNCTION OPNDSETSIZE(FATTR: ATTR): INTEGER;
"**"    (* COMPUTES THE SIZE OF A SET USED AS AN OPERAND *)
"**"    BEGIN  OPNDSETSIZE := 0;
"**"      WITH FATTR DO
"**"        IF TYPTR <> NIL THEN
"**"          CASE KIND OF
"**"          CST:   OPNDSETSIZE := CVAL.VALP@.PLNGTH;
"**"          VARBL: CASE ACCESS OF
"**"                 DRCT, INDRCT: OPNDSETSIZE := TYPTR@.SIZE;
"**"                 STKEXPR:      OPNDSETSIZE := STKLEN;
"**"                 INXD:         ERROR( 400 );
"**"                 END;
"**"          EXPR:  ERROR( 400 );
"**"          END;
"**"   END (* OPNDSETSIZE *) ;

  PROCEDURE GENLABEL(VAR NXTLAB: LABELRNG);
  BEGIN INTLABEL := INTLABEL + 1;
    NXTLAB := INTLABEL
  END (*GENLABEL*);


"E"(*THE FOLLOWING OUTPUTS A SYMBOL TABLE FILE FOR USE BY 'SNAPSHOT' PROGRAM*)
"E"
"E"PROCEDURE PRNTSYMBL(LCP:CTP);
"E"   VAR  LINELN:INTEGER;  (* CURRENT SYMBOL TABLE FILE LINE LENGTH *)
"&&"       TPT1: PRNTTYLISTP;
"E"
"&&"  PROCEDURE CHECKLN( LEN: INTEGER );
"&&"  BEGIN  IF (LINELN+LEN) >= 80 THEN
"&&"           BEGIN  WRITELN(QRR); WRITE(QRR,' '); LINELN := LEN END
"&&"         ELSE LINELN := LINELN + LEN
"&&"  END;
"E"
"&&"  PROCEDURE PRNTVAR(VRP:CTP); FORWARD;
"E"
"&&"  PROCEDURE PRNTTYPE(TYPP:STP);
"&&"    LABEL 1;
"&&"     VAR  VP, LVP: CTP;   RMIN, RMAX: INTEGER;
"&&"          TPT,LPT: PRNTTYLISTP;  TNO: 0..999;
"E"
"E"      BEGIN
"&&"     CHECKLN(4);
"&&"     IF TYPP=INTPTR THEN WRITE(QRR,'I4; ')
"E"         ELSE IF TYPP=REALPTR THEN WRITE(QRR,'R; ')
"E"         ELSE IF TYPP=BOOLPTR THEN WRITE(QRR,'B; ')
"E"         ELSE IF TYPP=CHARPTR THEN WRITE(QRR,'C; ')
"E"         ELSE IF TYPP <> NIL THEN
"&&"          WITH TYPP@ DO
"E"           CASE FORM OF
"E"
"E"           SUBRANGE:IF RANGETYPE = CHARPTR THEN
"&&"                     WRITE(QRR,'C; ')
"&&"                   ELSE IF RANGETYPE = INTPTR THEN
"&&"                     WRITE(QRR,'I',SIZE:1,'; ')
"&&"                   ELSE WRITE(QRR,'L',SIZE:1,'; ');

"&&"          SCALAR:  WRITE(QRR,'L', SIZE:1, '; ');
"E"
"&&"          POINTER: BEGIN
"&&"                   IF ELTYPE <> NIL THEN
"&&"                     BEGIN  TPT := PRNTTYPHD;  LPT := TPT;
"&&"                     WHILE TPT <> NIL DO
"&&"                       IF TPT@.ELT = ELTYPE THEN
"&&"                         BEGIN  TNO := TPT@.TNO;  GOTO 1  END
"&&"                       ELSE
"&&"                         BEGIN  LPT := TPT;  TPT := TPT@.NXT;  END;
"&&"                     NEW(TPT);
"&&"                     IF PRNTTYPHD = NIL THEN
"&&"                       PRNTTYPHD := TPT
"&&"                     ELSE
"&&"                       LPT@.NXT := TPT;
"&&"                     WITH TPT@ DO
"&&"                       BEGIN  NXT := NIL;  ELT := ELTYPE;
"&&"                          PRNTTYNO := PRNTTYNO+1;  TNO := PRNTTYNO  END;
"&&"                     TNO := PRNTTYNO;
"&&"                     END
"&&"                   ELSE  TNO := 0;
"&&"                1: CHECKLN(3);
"&&"                   WRITE(QRR,'P ',TNO:1,'; ');
"&&"                   END;
"E"
"E"           POWER:   IF ELSET <> NIL THEN
"E"                      BEGIN     WRITE(QRR,'S ');
"&&"                     CHECKLN(10);
"E"                      GETBOUNDS(ELSET, RMIN, RMAX) ;
"E"                      WRITE(QRR, RMIN:1,' ', RMAX:1, ' ; ');
"E"                      END;
"E"
"E"           FILES:   BEGIN  WRITE(QRR,'F ');
"&&"                     PRNTTYPE(FILTYPE);
"E"                    END;
"E"
"&&"          RECORDS: BEGIN   WRITE(QRR,'D',ALN:1,'(');
"&&"                   VP := FSTFLD;  LVP := VP;
"&&"                   WHILE VP <> NIL DO BEGIN PRNTVAR(VP);
"&&"                      LVP := VP;  VP := VP@.NEXT;  END;
"&&"                   IF RECVAR <> NIL THEN
"&&"                     BEGIN
"&&"                       IF RECVAR@.TAGFIELDP <> NIL THEN
"&&"                         IF RECVAR@.TAGFIELDP@.NAME <> BLANKID THEN
"&&"                           BEGIN  LVP := RECVAR@.TAGFIELDP;
"&&"                                  PRNTVAR( LVP );
"&&"                           END;
"&&"                       IF LVP <> NIL THEN
"&&"                         BEGIN  CHECKLN( 12 );
"&&"                           RMAX := SIZE - LVP@.FLDADDR;
"&&"                           IF LVP@.IDTYPE <> NIL THEN
"&&"                             RMAX := RMAX - LVP@.IDTYPE@.SIZE;
"&&"                           IF RMAX > 0 THEN
"&&"                             WRITE(QRR,'ETC=X',RMAX:1,'; ');
"&&"                         END;
"&&"                     END;
"&&"                   CHECKLN(3);
"&&"                   WRITE(QRR,'); ');
"E"                    END;
"E"
"E"           ARRAYS:  IF INXTYPE <> NIL THEN
"E"                      BEGIN    WRITE(QRR,'A ');
"&&"                     CHECKLN(26);
"E"                      GETBOUNDS(INXTYPE, RMIN, RMAX) ;
"E"                      WRITE(QRR, RMIN:1,' ', RMAX:1,' ');
"&&"                     PRNTTYPE(AELTYPE);
"E"                      END;
"E"           END (*CASE FORM OF...*)
"&&"        ELSE WRITE(QRR,';');
"E"
"E"      END;    (* PRNTTYPE *)
"E"
"E"   PROCEDURE PRNTVAR;
"&&"     VAR  I: 0 .. IDLNGTH;
"E"      BEGIN
"&&"       WITH VRP@ DO
"&&"         BEGIN  I := IDLNGTH;
"&&"           WHILE NAME(/I/) = ' ' DO  I := I - 1;
"&&"           CHECKLN( I+1 );
"&&"           WRITE( QRR, NAME:I, '=' );
"&&"           PRNTTYPE( IDTYPE );
"&&"         END
"E"      END;
"E"
"E"   BEGIN   (* PRNTSYMBL *)
"E"   IF PRCODE THEN
"&&"    IF LCP <> NIL THEN
"&&"      WITH LCP@ DO
"&&"        BEGIN
"&&"          IF KLASS = VARS THEN
"E"             BEGIN
"&&"              LINELN := 5;
"&&"              IF VKIND = FORMAL THEN
"&&"                BEGIN  WRITE(QRR,'@ ');  LINELN := 7  END;
"&&"              WRITE(QRR, VADDR:1, ' ');
"&&"              PRNTVAR( LCP );
"E"             END
"&&"          ELSE IF KLASS IN (/PROC,FUNC/) THEN
"&&"            BEGIN
"E"                 WRITELN(QRR,'% ',NAME,' ',PFNAME);
"SH"                LCP := PRMPTR;
"SH"                WHILE LCP <> NIL DO  (* SKIP PROC/FUNC PARAMETERS *)
"SH"                  BEGIN  IF LCP@.KLASS = VARS THEN PRNTSYMBL(LCP);
"SH"                         LCP := LCP@.NEXT  END;
"SH"            END;
"E"          WRITELN(QRR);
"E"        END (*IF LCP <> NIL, WITH LCP@... *)
"&&"     ELSE  (* DUMP HEAP STORAGE TYPE DEFINITIONS *)
"&&"       BEGIN
"&&"         TPT1 := PRNTTYPHD;
"&&"         WHILE TPT1 <> NIL DO
"&&"           BEGIN  WRITE(QRR,'>',TPT1@.TNO:1,' ');
"&&"             LINELN := 5;  PRNTTYPE(TPT1@.ELT);
"&&"             WRITELN(QRR);
"&&"             TPT1 := TPT1@.NXT;
"&&"           END;
"&&"         PRNTTYPHD := NIL;  PRNTTYNO := 0;
"&&"       END;
"E"   END;  (* PRNTSYMBL *)


  PROCEDURE BLOCK(FSYS: SETOFSYS; FSY: SYMBOL; FPROCP: CTP);
#   VAR LSY: SYMBOL; TEST: BOOLEAN; SEGSIZE: LABELRNG;
"&&"    LCP, FWRDPRCL: CTP;  DEC_ORDER: 0..4;


    PROCEDURE SKIP(FSYS: SETOFSYS);
      (*SKIP INPUT STRING UNTIL RELEVANT SYMBOL FOUND*)
    BEGIN
      WHILE NOT(SY IN FSYS) DO  INSYMBOL;
    END (*SKIP*) ;


#    PROCEDURE ALIGN(VAR Q:ADDRRANGE;  P: ADDRRANGE);
#      BEGIN
"&&"     CASE P OF
"&&"     REALSIZE:           Q := ((Q+7) DIV 8)*8;
"&&"     INTSIZE ",PTRSIZE": Q := ((Q+3) DIV 4)*4;
"&&"     HINTSIZE:           IF ODD(Q) THEN Q := Q + 1;
"&&"     CHARSIZE:           ;
"&&"     OTHERWISE:          IF ERRORCNT = 0 THEN ERROR(401);
"&&"     END;
#      END (*ALIGN*) ;


    PROCEDURE CONSTANT(FSYS: SETOFSYS; VAR FSP: STP; VAR FVALU: VALU);
      VAR LSP: STP; LCP: CTP; SIGN: (NONE,POS,NEG);
          LVP: CSP; I: 2..REALLNGTH;
    BEGIN LSP := NIL; FVALU.IVAL := 0;
      IF NOT(SY IN CONSTBEGSYS) THEN
        BEGIN ERROR(50); SKIP(FSYS+CONSTBEGSYS) END;
      IF SY IN CONSTBEGSYS THEN
        BEGIN
          IF SY = STRINGCONST THEN
            BEGIN
              IF LNGTH = 1 THEN LSP := CHARPTR
              ELSE
                BEGIN
                  NEW(LSP,ARRAYS);
                  WITH LSP@ DO
                    BEGIN AELTYPE := CHARPTR; INXTYPE := NIL;
                       SIZE := LNGTH*CHARSIZE; FORM := ARRAYS;
"&&"                   ALN := CHARSIZE;
                    END
                END;
              FVALU := VAL; INSYMBOL
            END
          ELSE
            BEGIN
              SIGN := NONE;
              IF (SY = ADDOP) AND (OP IN [PLUS,MINUS]) THEN
                BEGIN IF OP = PLUS THEN SIGN := POS ELSE SIGN := NEG;
                  INSYMBOL
                END;
              IF SY = IDENT THEN
                BEGIN SEARCHID([KONST],LCP);
                  WITH LCP@ DO
                    BEGIN LSP := IDTYPE; FVALU := VALUES END;
                  IF SIGN <> NONE THEN
                    IF LSP = INTPTR THEN
                      BEGIN IF SIGN = NEG THEN FVALU.IVAL := -FVALU.IVAL END
                    ELSE
                      IF LSP = REALPTR THEN
                        BEGIN
                          IF SIGN = NEG THEN
                            BEGIN NEW(LVP,REEL);
"&&"                          LVP@.RVAL := FVALU.VALP@.RVAL;
"&&"                          IF LVP@.RVAL(/1/) = '-' THEN
"&&"                            LVP@.RVAL(/1/) := '+'
"&&"                          ELSE LVP@.RVAL(/1/) := '-';
                              FVALU.VALP := LVP;
                            END
                          END
                        ELSE ERROR(105);
                  INSYMBOL;
                END
              ELSE
                IF SY = INTCONST THEN
                  BEGIN IF SIGN = NEG THEN VAL.IVAL := -VAL.IVAL;
                    LSP := INTPTR; FVALU := VAL; INSYMBOL
                  END
                ELSE
                  IF SY = REALCONST THEN
                    BEGIN IF SIGN = NEG THEN VAL.VALP@.RVAL[1] := '-';
                      LSP := REALPTR; FVALU := VAL; INSYMBOL
                    END
                  ELSE
                    BEGIN ERROR(106); SKIP(FSYS) END
            END;
          IF NOT (SY IN FSYS) THEN
            BEGIN ERROR(6); SKIP(FSYS) END
          END;
      FSP := LSP
    END (*CONSTANT*) ;


    FUNCTION COMPTYPES(FSP1,FSP2: STP) : BOOLEAN;
      (*DECIDE WHETHER STRUCTURES POINTED AT BY FSP1 AND FSP2 ARE COMPATIBLE*)
      VAR NXT1,NXT2: CTP; COMP: BOOLEAN;
        LTESTP1,LTESTP2 : TESTP;
    BEGIN
      IF FSP1 = FSP2 THEN COMPTYPES := TRUE
      ELSE
        IF (FSP1 <> NIL) AND (FSP2 <> NIL) THEN
          IF FSP1@.FORM = FSP2@.FORM THEN
            CASE FSP1@.FORM OF
              SCALAR:
                COMPTYPES := FALSE;
                (* IDENTICAL SCALARS DECLARED ON DIFFERENT LEVELS ARE
                 NOT RECOGNIZED TO BE COMPATIBLE*)
              SUBRANGE:
                COMPTYPES := COMPTYPES(FSP1@.RANGETYPE,FSP2@.RANGETYPE);
              POINTER:
                  BEGIN
                    COMP := FALSE; LTESTP1 := GLOBTESTP;
                    LTESTP2 := GLOBTESTP;
                    WHILE LTESTP1 <> NIL DO
                      WITH LTESTP1@ DO
                        BEGIN
                          IF (ELT1 = FSP1@.ELTYPE) AND
                            (ELT2 = FSP2@.ELTYPE) THEN COMP := TRUE;
                          LTESTP1 := LASTTESTP
                        END;
                    IF NOT COMP THEN
                      BEGIN NEW(LTESTP1);
                        WITH LTESTP1@ DO
                          BEGIN ELT1 := FSP1@.ELTYPE;
                            ELT2 := FSP2@.ELTYPE;
                            LASTTESTP := GLOBTESTP
                          END;
                        GLOBTESTP := LTESTP1;
                        COMP := COMPTYPES(FSP1@.ELTYPE,FSP2@.ELTYPE)
                      END;
                    COMPTYPES := COMP; GLOBTESTP := LTESTP2
                  END;
              POWER:
                COMPTYPES := COMPTYPES(FSP1@.ELSET,FSP2@.ELSET);
              ARRAYS:
                COMPTYPES := COMPTYPES(FSP1@.AELTYPE,FSP2@.AELTYPE)
                             AND (FSP1@.SIZE = FSP2@.SIZE);
                (*ALTERNATIVES: -- ADD A THIRD BOOLEAN TERM: INDEXTYPE MUST
                                  BE COMPATIBLE.
                               -- ADD A FOURTH BOOLEAN TERM: LOWBOUNDS MUST
                                  BE THE SAME*)
              RECORDS:
                BEGIN NXT1 := FSP1@.FSTFLD; NXT2 := FSP2@.FSTFLD;
"&&"              COMP := (FSP1@.RECVAR = FSP2@.RECVAR);
"&&"              WHILE COMP AND (NXT1 <> NIL) AND (NXT2 <> NIL) DO
                    BEGIN
                      IF NOT COMPTYPES(NXT1@.IDTYPE,NXT2@.IDTYPE) THEN
                        COMP := FALSE;
"&&"                  IF NXT1@.IDTYPE@.SIZE <> NXT2@.IDTYPE@.SIZE THEN
"&&"                    COMP := FALSE;
                      NXT1 := NXT1@.NEXT; NXT2 := NXT2@.NEXT
                    END;
                  COMPTYPES := COMP AND (NXT1 = NIL) AND (NXT2 = NIL)
                END;
                (*IDENTICAL RECORDS ARE RECOGNIZED TO BE COMPATIBLE
                 IFF NO VARIANTS OCCUR*)
              FILES:
                COMPTYPES := COMPTYPES(FSP1@.FILTYPE,FSP2@.FILTYPE)
            END (*CASE*)
          ELSE (*FSP1@.FORM <> FSP2@.FORM*)
            IF FSP1@.FORM = SUBRANGE THEN
              COMPTYPES := COMPTYPES(FSP1@.RANGETYPE,FSP2)
            ELSE
              IF FSP2@.FORM = SUBRANGE THEN
                COMPTYPES := COMPTYPES(FSP1,FSP2@.RANGETYPE)
              ELSE COMPTYPES := FALSE
        ELSE COMPTYPES := TRUE
    END (*COMPTYPES*) ;


    FUNCTION STRING(FSP: STP) : BOOLEAN;
    BEGIN STRING := FALSE;
      IF FSP <> NIL THEN
        IF FSP@.FORM = ARRAYS THEN
#         STRING := COMPTYPES(FSP@.AELTYPE,CHARPTR)
    END (*STRING*) ;

"**" FUNCTION CALC_SETSIZE(ELT: STP): INTEGER;
"**"    (* COMPUTES SIZE OF SET WHOSE ELEMENT TYPE IS ELT *)
"**"   VAR  MIN, MAX: INTEGER;
"**"   BEGIN  MAX := -1;
"**"      IF ELT <> NIL THEN GETBOUNDS( ELT, MIN, MAX );
"**"      CALC_SETSIZE := ((MAX+SETPACK) DIV SETPACK) * WORDSIZE;
"**"   END;

    PROCEDURE TYP(FSYS: SETOFSYS; VAR FSP: STP; VAR FSIZE: ADDRRANGE);
"&&"  VAR LSP,LSP1,LSP2: STP; OLDTOP: DISPRANGE; LCP,LCP2: CTP;
          LSIZE,DISPL: ADDRRANGE; LMIN,LMAX: INTEGER;  ALNFCT: ALNRNG ;
"&&"      OLDPACKST, PACKST2: BOOLEAN;

      PROCEDURE SIMPLETYPE(FSYS:SETOFSYS; VAR FSP:STP);
        VAR LSP,LSP1: STP; LCP,LCP1: CTP; TTOP: DISPRANGE;
"&&"        LCNT: INTEGER;  LVALU: VALU;  FLAG: BOOLEAN;
        BEGIN
        IF NOT (SY IN SIMPTYPEBEGSYS) THEN
          BEGIN ERROR(1); SKIP(FSYS + SIMPTYPEBEGSYS) END;
        IF SY IN SIMPTYPEBEGSYS THEN
          BEGIN
            IF SY = LPARENT THEN
              BEGIN TTOP := TOP;   (*DECL. CONSTS LOCAL TO INNERMOST BLOCK*)
"&&"            TOP := LEVEL;
                NEW(LSP,SCALAR,DECLARED);
                WITH LSP@ DO
                  BEGIN SIZE := INTSIZE; FORM := SCALAR;
                    SCALKIND := DECLARED
                  END;
                LCP1 := NIL; LCNT := 0;
                REPEAT INSYMBOL;
                  IF SY = IDENT THEN
                    BEGIN NEW(LCP,KONST);
                      WITH LCP@ DO
                        BEGIN NAME := ID; IDTYPE := LSP; NEXT := LCP1;
                          VALUES.IVAL := LCNT; KLASS := KONST
                        END;
                      ENTERID(LCP);
                      LCNT := LCNT + 1;
                      LCP1 := LCP; INSYMBOL
                    END
                  ELSE ERROR(2);
                  IF NOT (SY IN FSYS + [COMMA,RPARENT]) THEN
                    BEGIN ERROR(6); SKIP(FSYS + [COMMA,RPARENT]) END
                UNTIL SY <> COMMA;
"&&"            IF NOT NOPACKING THEN
"&&"                BEGIN  LSP@.SIZE := HINTSIZE;
"&&"                  IF PACKDATA THEN IF LCNT <= ORDCHMAX THEN
"&&"                    LSP@.SIZE := CHARSIZE
"&&"                END;
#               LSP@.ALN := LSP@.SIZE ;
                LSP@.FCONST := LCP1; TOP := TTOP;
                IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
              END
            ELSE
              BEGIN
                IF SY = IDENT THEN
                  BEGIN SEARCHID([TYPES,KONST],LCP);
                    INSYMBOL;
                    IF LCP@.KLASS = KONST THEN
                      BEGIN NEW(LSP,SUBRANGE);
                        WITH LSP@, LCP@ DO
                          BEGIN RANGETYPE := IDTYPE; FORM := SUBRANGE;
                            IF STRING(RANGETYPE) THEN
                              BEGIN ERROR(148); RANGETYPE := NIL END;
#                           MIN := VALUES; SIZE := IDTYPE@.SIZE
                          END;
"&&"                  END  (*IF LCP@.KLASS ...*)
"&&"                ELSE
"&&"                  LSP := NIL;  (* SIGNALS TYPE ID SEEN *)
"&&"              END
                ELSE
                  BEGIN NEW(LSP,SUBRANGE); LSP@.FORM := SUBRANGE;
                    CONSTANT(FSYS + [DOTDOT],LSP1,LVALU);
                    IF STRING(LSP1) THEN
                      BEGIN ERROR(148); LSP1 := NIL END;
                    WITH LSP@ DO
#                     BEGIN RANGETYPE:=LSP1; MIN:=LVALU; SIZE:=INTSIZE;
#                     IF LSP1 <> NIL THEN SIZE := LSP1@.SIZE ;
#                     END;
"&&"              END;
"&&"            IF LSP <> NIL THEN  (* CONSTANT JUST SEEN *)
"&&"              BEGIN
#                   IF SY = DOTDOT THEN INSYMBOL ELSE ERROR(5);
                    CONSTANT(FSYS,LSP1,LVALU);
                    LSP@.MAX := LVALU;
                    IF LSP1@.SIZE > CHARSIZE THEN  (* SCOPE FOR PACKING *)
"&&"                 IF NOT NOPACKING THEN
"&&"                  IF LVALU.IVAL <= 32767 THEN
"&&"                    IF LSP@.MIN.IVAL >= -32768 THEN
"&&"                      BEGIN  LSP@.SIZE := HINTSIZE;
"&&"                        IF PACKDATA THEN
"&&"                          IF LVALU.IVAL<=ORDCHMAX THEN
"&&"                            IF LSP@.MIN.IVAL>=0 THEN
"&&"                              LSP@.SIZE := CHARSIZE;
"&&"                      END;
#                   LSP@.ALN := LSP@.SIZE ;
                    IF LSP@.RANGETYPE <> LSP1 THEN ERROR(107)
                  END
"&&"            ELSE
"&&"              BEGIN
"&&"                LSP := LCP@.IDTYPE;  FLAG := FALSE;
"&&"                IF PACKDATA THEN IF NOT NOPACKING THEN
"&&"                  IF LSP <> NIL THEN
"&&"                    WITH LSP@ DO
"&&"                      IF SIZE > CHARSIZE THEN
"&&"                        IF FORM = SCALAR THEN
"&&"                          IF SCALKIND = DECLARED THEN
"&&"                            BEGIN  LCNT := -1;  LCP1 := FCONST;
"&&"                              WHILE LCP1 <> NIL DO
"&&"                                BEGIN  LCNT := LCNT + 1;
"&&"                                  LCP1 := LCP1@.NEXT;
"&&"                                END;
"&&"                              IF LCNT <= ORDCHMAX THEN FLAG := TRUE
"&&"                            END
"&&"                          ELSE
"&&"                        ELSE IF FORM = SUBRANGE THEN
"&&"                          IF MIN.IVAL >= 0 THEN
"&&"                            IF MAX.IVAL <= ORDCHMAX THEN FLAG := TRUE;
"&&"                IF FLAG THEN
"&&"                  BEGIN  (*CREATE PACKED VERSION OF THIS TYPE*)
"&&"                    NEW(LSP1);
"&&"                    LSP1@ := LSP@;
"&&"                    WITH LSP1@ DO
"&&"                      BEGIN  SIZE := CHARSIZE;  ALN := CHARSIZE;
"&&"                        IF FORM = SCALAR THEN  (* CONVERT TO SUBRANGE *)
"&&"                          BEGIN  FORM := SUBRANGE;
"&&"                            RANGETYPE := LSP;
"&&"                            MIN.IVAL := 0;  MAX.IVAL := LCNT;
"&&"                          END;
"&&"                      END;
"&&"                    LSP := LSP1;
"&&"                  END
"&&"              END;
                IF LSP <> NIL THEN
                  WITH LSP@ DO
                    IF FORM = SUBRANGE THEN
                      IF RANGETYPE <> NIL THEN
                        IF RANGETYPE = REALPTR THEN ERROR(398)
                        ELSE
                          IF MIN.IVAL > MAX.IVAL THEN ERROR(102)
              END;
            FSP := LSP;
            IF NOT (SY IN FSYS) THEN
              BEGIN ERROR(6); SKIP(FSYS) END
          END
            ELSE FSP := NIL
      END (*SIMPLETYPE*) ;


#     PROCEDURE FIELDLIST(FSYS: SETOFSYS; VAR FRECVAR: STP;
"&&"              VAR RECALN: ALNRNG; FLDOWNER: STP; VAR FIRSTFLD: CTP);
"&&"    LABEL 10;
        VAR LCP,LCP1,NXT,NXT1: CTP; LSP,LSP1,LSP2,LSP3,LSP4: STP;
#           MINSIZE,MAXSIZE,LSIZE: ADDRRANGE; LVALU: VALU; LALNFCT : ALNRNG ;
"&&"  BEGIN  NXT := NIL;  FIRSTFLD := NIL;  LSP := NIL;  RECALN := 1;
        IF NOT (SY IN FSYS+[IDENT,CASESY]) THEN
          BEGIN ERROR(19); SKIP(FSYS + [IDENT,CASESY]) END;

        WHILE SY = IDENT DO
#         BEGIN  NXT1 := NIL;
            REPEAT
              IF SY = IDENT THEN
                BEGIN NEW(LCP,FIELD);
                  WITH LCP@ DO
#                   BEGIN NAME := ID; IDTYPE := NIL; NEXT := NIL;
"&&"                  OWNER := FLDOWNER;  KLASS := FIELD;
"SY"                  IF GET_STAT THEN FLDOWNER@.NO_FLDS:=FLDOWNER@.NO_FLDS+1;
                    END;
#                 IF NXT1 = NIL THEN  NXT1 := LCP;
"&&"              IF NXT <> NIL THEN
"&&"                NXT@.NEXT := LCP;
                  NXT := LCP;
                  ENTERID(LCP);
                  INSYMBOL
                END
              ELSE ERROR(2);
              IF NOT (SY IN [COMMA,COLON]) THEN
                BEGIN ERROR(6); SKIP(FSYS + [COMMA,COLON,SEMICOLON,CASESY])
                END;
              TEST := SY <> COMMA;
              IF NOT TEST  THEN INSYMBOL
            UNTIL TEST;
            IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
"&&"        IF FIRSTFLD = NIL THEN FIRSTFLD := NXT1;
            TYP(FSYS + [CASESY,SEMICOLON],LSP,LSIZE);
#           LALNFCT := 1 ;  IF LSP <> NIL THEN LALNFCT := LSP@.ALN ;
#
#           WHILE NXT1 <> NIL DO  (* ANY "FIELDS" DEFINED IN THIS ROUND ? *)
#             BEGIN
#             WITH NXT1@ DO
#               BEGIN  IDTYPE := LSP; ALIGN(DISPL,LALNFCT);  FLDADDR := DISPL;
#               DISPL := DISPL + LSIZE;  NXT1 := NEXT;
#               END;
#             END (*WHILE NXT1 <> NIL*);
#
#           IF LALNFCT > RECALN THEN RECALN := LSP@.ALN ;
#           IF SY = SEMICOLON THEN
#             BEGIN INSYMBOL;
#               IF NOT (SY IN [IDENT,CASESY,ENDSY]) THEN     (* IGNOR EXTRA ; *)
#                 BEGIN ERROR(19); SKIP(FSYS + [IDENT,CASESY]) END
#             END
#         END (*WHILE*);
#
        IF SY = CASESY THEN
          BEGIN NEW(LSP,TAGFLD);
            WITH LSP@ DO
              BEGIN TAGFIELDP := NIL; FSTVAR := NIL; FORM:=TAGFLD END;
            FRECVAR := LSP;
            INSYMBOL;
            IF SY = IDENT THEN
              BEGIN NEW(LCP,FIELD);
                WITH LCP@ DO
                  BEGIN NAME := ID; IDTYPE := NIL; KLASS:=FIELD;
#                   NEXT := NIL ; (*FLDADDR WILL BE SET WHEN TYPE IS KNOWN*)
"&&"                OWNER := FLDOWNER;
"SY"                IF GET_STAT THEN FLDOWNER@.NO_FLDS:=FLDOWNER@.NO_FLDS+1;
                  END;
"TF"           INSYMBOL;
"TF"           IF SY = COLON THEN  (* EXPLICIT TAG FIELD *)
"TF"             BEGIN
#                    ENTERID(LCP);  INSYMBOL ;
#                    IF SY <> IDENT THEN
"&&"                   GOTO 10
"&&"             END
"&&"           ELSE BEGIN
"&&"                  ID := LCP@.NAME;  LCP@.NAME := BLANKID;
"&&"                END;
"&&"           SEARCHID( [TYPES], LCP1 );
               LSP1 := LCP1@.IDTYPE;
               IF LSP1 <> NIL THEN
                 WITH LSP1@ DO
#                  BEGIN
"TF"                 IF LCP@.NAME <> BLANKID THEN
                       BEGIN
#                        ALIGN(DISPL,ALN) ;
#                        IF ALN > RECALN THEN RECALN := ALN ;
#                        LCP@.FLDADDR := DISPL ;  DISPL := DISPL + SIZE;
"TF"                   END (* LCP@.NAME <> BLANKID *) ;
                     IF (FORM <= SUBRANGE) OR STRING(LSP1) THEN
                       BEGIN IF COMPTYPES(REALPTR,LSP1) THEN ERROR(109)
                         ELSE IF STRING(LSP1) THEN ERROR(398);
                         LCP@.IDTYPE := LSP1; LSP@.TAGFIELDP := LCP;
                       END
                     ELSE ERROR(110);
                   END (* WITH LSP1@ DO *) ;
"&&"           IF LCP@.NAME <> BLANKID THEN INSYMBOL;
              END
            ELSE
10:             BEGIN ERROR(2); SKIP(FSYS + [OFSY,LPARENT]) END;
#           LSP@.SIZE := DISPL;
            IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
            LSP1 := NIL; MINSIZE := DISPL; MAXSIZE := DISPL;
            REPEAT LSP2 := NIL;
              REPEAT CONSTANT(FSYS + [COMMA,COLON,LPARENT],LSP3,LVALU);
                IF LSP@.TAGFIELDP <> NIL THEN
                 IF NOT COMPTYPES(LSP@.TAGFIELDP@.IDTYPE,LSP3)THEN ERROR(111);
                NEW(LSP3,VARIANT);
                WITH LSP3@ DO
                  BEGIN NXTVAR := LSP1; SUBVAR := LSP2; VARVAL := LVALU;
"&&"                FSTSUBFLD := NIL;  FORM := VARIANT
                  END;
                LSP1 := LSP3; LSP2 := LSP3;
                TEST := SY <> COMMA;
                IF NOT TEST THEN INSYMBOL
              UNTIL TEST;
              IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
              IF SY = LPARENT THEN INSYMBOL ELSE ERROR(9);
"&&"          FIELDLIST(FSYS + [RPARENT,SEMICOLON],LSP2,LALNFCT,FLDOWNER,LCP1);
#             IF LALNFCT > RECALN THEN  RECALN := LALNFCT ;
              IF DISPL > MAXSIZE THEN MAXSIZE := DISPL;
              WHILE LSP3 <> NIL DO
"&&"            WITH LSP3@ DO
"&&"              BEGIN LSP4 := SUBVAR; SUBVAR := LSP2;
"&&"                SIZE := DISPL;  FSTSUBFLD := LCP1;  LSP3 := LSP4
                  END;
              IF SY = RPARENT THEN
                BEGIN INSYMBOL;
                  IF NOT (SY IN FSYS + [SEMICOLON]) THEN
                    BEGIN ERROR(6); SKIP(FSYS + [SEMICOLON]) END
                END
              ELSE ERROR(4);
              TEST := SY <> SEMICOLON;
              IF NOT TEST THEN
                BEGIN DISPL := MINSIZE;
#                  INSYMBOL ;  TEST := SY = ENDSY ;          (* IGNORE EXTRA ;*)
                END
            UNTIL TEST;
            DISPL := MAXSIZE;
            LSP@.FSTVAR := LSP1;
          END
        ELSE FRECVAR := NIL
      END (*FIELDLIST*) ;


    BEGIN (*TYP*)
"&&"  OLDPACKST := PACKDATA;
      IF NOT (SY IN TYPEBEGSYS) THEN
         BEGIN ERROR(10); SKIP(FSYS + TYPEBEGSYS) END;
      IF SY IN TYPEBEGSYS THEN
        BEGIN
          IF SY IN SIMPTYPEBEGSYS THEN SIMPLETYPE(FSYS,FSP)
          ELSE
    (*@*)     IF SY = ARROW THEN
              BEGIN NEW(LSP,POINTER); FSP := LSP;
                WITH LSP@ DO
                  BEGIN ELTYPE := NIL;
#                 SIZE := PTRSIZE; ALN := PTRSIZE ; FORM:=POINTER
                  END;
                INSYMBOL;
                IF SY = IDENT THEN
                  BEGIN PRTERR := FALSE; (*NO ERROR IF SEARCH NOT SUCCESSFUL*)
                    SEARCHID([TYPES],LCP); PRTERR := TRUE;
                    IF LCP = NIL THEN   (*FORWARD REFERENCED TYPE ID*)
                      BEGIN NEW(LCP,TYPES);
                        WITH LCP@ DO
                          BEGIN NAME := ID; IDTYPE := LSP;
                            NEXT := FWPTR; KLASS := TYPES
                          END;
                        FWPTR := LCP
                      END
                    ELSE
                      BEGIN
                        IF LCP@.IDTYPE <> NIL THEN
                          IF LCP@.IDTYPE@.FORM = FILES THEN ERROR(108)
                          ELSE LSP@.ELTYPE := LCP@.IDTYPE
                      END;
                    INSYMBOL;
                  END
                ELSE ERROR(2);
              END
            ELSE
              BEGIN
#"01/07"        LSP := NIL;
                IF SY = PACKEDSY THEN
                  BEGIN INSYMBOL;
"&&"                PACKDATA := TRUE;
                    IF NOT (SY IN TYPEDELS) THEN
                      BEGIN
                        ERROR(10); SKIP(FSYS + TYPEDELS)
                      END
                  END
"&&"            ELSE PACKDATA := FALSE;
    (*ARRAY*)   IF SY = ARRAYSY THEN
                  BEGIN INSYMBOL;
                    IF SY = LBRACK THEN INSYMBOL ELSE
"&&"                  BEGIN IF SY=LPARENT THEN
"&&"                        BEGIN  ERRKIND := 'W';  INSYMBOL  END;
"&&"                      ERROR(11)  END;
"&&"                LSP1 := NIL;  PACKST2 := PACKDATA;  PACKDATA := FALSE;
                    REPEAT NEW(LSP,ARRAYS);
                      WITH LSP@ DO
                        BEGIN AELTYPE := LSP1; INXTYPE := NIL; FORM:=ARRAYS END;
                      LSP1 := LSP;
"&&"                  SIMPLETYPE(FSYS + [COMMA,RBRACK,OFSY,RPARENT],LSP2);
                      IF LSP2 <> NIL THEN
                        IF LSP2@.FORM <= SUBRANGE THEN
                          BEGIN
                            IF LSP2 = REALPTR THEN
                              BEGIN ERROR(109); LSP2 := NIL END
                            ELSE
                              IF LSP2 = INTPTR THEN
                                BEGIN ERROR(149); LSP2 := NIL END;
                            LSP@.INXTYPE := LSP2
                          END
                        ELSE BEGIN ERROR(113); LSP2 := NIL END;
                      TEST := SY <> COMMA;
                      IF NOT TEST THEN INSYMBOL
                    UNTIL TEST;
                    IF SY = RBRACK THEN INSYMBOL ELSE
"&&"                  BEGIN IF SY=RPARENT THEN
"&&"                        BEGIN  ERRKIND := 'W';  INSYMBOL  END;
"&&"                      ERROR(12)  END;
                    IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
"&&"                PACKDATA := PACKST2;
#                   TYP(FSYS,LSP,LSIZE);
#                   IF LSP <> NIL THEN ALIGN(LSIZE,LSP@.ALN) ;
                    REPEAT
                      WITH LSP1@ DO
                        BEGIN LSP2 := AELTYPE; AELTYPE := LSP;
                          IF INXTYPE <> NIL THEN
                            BEGIN GETBOUNDS(INXTYPE,LMIN,LMAX);
                              LSIZE := LSIZE*(LMAX - LMIN + 1);
                              SIZE := LSIZE ;
#                             IF LSP <> NIL THEN
#                               ALN := LSP@.ALN (*PROPAGATE ALN*) ;
                            END
#"01/07"                  ELSE  (*INXTYPE = NIL*)  SIZE := 0
                        END;
                      LSP := LSP1; LSP1 := LSP2
                    UNTIL LSP1 = NIL
                  END
                ELSE
    (*RECORD*)    IF SY = RECORDSY THEN
                    BEGIN INSYMBOL;
"SY"                  IF GET_STAT THEN RE_CNT := RE_CNT + 1;
                      IF TOP < DISPLIMIT THEN
                        BEGIN TOP := TOP + 1;
                          WITH DISPLAY[TOP] DO
                            OCCUR := REC
                        END
"&&"                  ELSE FATALERROR(250);
                      DISPL := 0;
"&&"                  NEW(LSP,RECORDS);
                      WITH LSP@ DO
                        BEGIN
"&&"                      FLD_DISP_LEV := TOP;  FSTFLD := NIL;
"SY"                      NO_FLDS := 0;
"&&"                      FIELDLIST(FSYS-[SEMICOLON]+[ENDSY],LSP1,
"&&"                                ALNFCT,LSP,FSTFLD);
                          RECVAR := LSP1; SIZE := DISPL;
                          FORM := RECORDS ;  ALN := ALNFCT ;
"&&"                      FLD_DISP_LEV := -1;
                        END;
"&&"                  TOP := TOP - 1;
                      IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
                    END
                  ELSE
    (*SET*)         IF SY = SETSY THEN
                      BEGIN INSYMBOL;
                        IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
"&&"                    PACKDATA := FALSE;
                        SIMPLETYPE(FSYS,LSP1);
                        IF LSP1 <> NIL THEN
                          IF LSP1 = INTPTR THEN ERROR(304)
                          ELSE IF (LSP1@.FORM > SUBRANGE) THEN
                            BEGIN ERROR(115); LSP1 := NIL END
                          ELSE
                            IF LSP1 = REALPTR THEN ERROR(114)
#                           ELSE IF LSP1@.FORM = SUBRANGE THEN
#                                  IF LSP1@.MAX.IVAL > SETMAX   THEN ERROR(304);
                        NEW(LSP,POWER);
                        WITH LSP@ DO
                          BEGIN ELSET:=LSP1;
"**"                      SIZE := CALC_SETSIZE(LSP1);
"**"                      ALN := WORDSIZE;  FORM := POWER
                          END;
                      END
                    ELSE
    (*FILE*)            IF SY = FILESY THEN
#                       BEGIN  INSYMBOL ;
#                       IF SY = OFSY THEN INSYMBOL  ELSE  ERROR(8) ;
"@@"                    TYP(FSYS,LSP1,LSIZE) ;
"@@"                    LSP := TEXTPTR;  (* ASSUME THE COMMON CASE *)
"@@"                    IF LSP1 <> NIL THEN
"@@"                      IF LSP1 <> CHARPTR THEN  (* NOT A TEXTFILE *)
"@@"                      IF LSP1@.FORM <> FILES THEN
"@@"                        BEGIN
"@@"                          NEW(LSP,FILES);
"@@"                          WITH LSP@ DO
"@@"                            BEGIN
"@@"                              FILTYPE := LSP1;  ALN := LSP1@.ALN;
"@@"                              SIZE := LSIZE + FILHDRSIZE;
"@@"                              IF ALN < PTRSIZE THEN ALN := PTRSIZE;
"@@"                              FORM := FILES;
"@@"                            END
"@@"                        END
"@@"                      ELSE BEGIN  LSP:=NIL;  ERROR(108)  END;
#                       END ;
                FSP := LSP
              END;
          IF NOT (SY IN FSYS) THEN
            BEGIN ERROR(6); SKIP(FSYS) END
        END
      ELSE FSP := NIL;
      IF FSP = NIL THEN FSIZE := 1 ELSE FSIZE := FSP@.SIZE;
"&&"  PACKDATA := OLDPACKST;
    END (*TYP*) ;


    PROCEDURE LABELDECLARATION;
      VAR LLP: LBP; REDEF: BOOLEAN; LBNAME: LABELRNG ;
    BEGIN
      REPEAT
        IF SY = INTCONST THEN
          WITH DISPLAY[TOP] DO
            BEGIN LLP := FLABEL; REDEF := FALSE;
              WHILE (LLP <> NIL) AND NOT REDEF DO
                IF LLP@.LABVAL <> VAL.IVAL THEN
                  LLP := LLP@.NEXTLAB
                ELSE BEGIN REDEF := TRUE; ERROR(166) END;
              IF NOT REDEF THEN
                BEGIN NEW(LLP);
                  WITH LLP@ DO
                    BEGIN LABVAL := VAL.IVAL; GENLABEL(LBNAME);
"&&"                  XNO := 0;  (* 0 => NOT AN EXTERNAL ENTRY PT. *)
                      DEFINED := FALSE; NEXTLAB := FLABEL; LABNAME := LBNAME
                    END;
                  FLABEL := LLP
                END;
              INSYMBOL
            END
        ELSE ERROR(15);
        IF NOT ( SY IN FSYS + [COMMA, SEMICOLON] ) THEN
          BEGIN ERROR(6); SKIP(FSYS+[COMMA,SEMICOLON]) END;
        TEST := SY <> COMMA;
        IF NOT TEST THEN INSYMBOL
      UNTIL TEST;
      IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14)
    END (* LABELDECLARATION *) ;

"&&" PROCEDURE WRITESET( SP: CSP );
"&&"   VAR I,J,K,L,E,COL,LEN: INTEGER;  S: SETRANGE;  DELIM: CHAR;
"&&"   BEGIN  LEN := SP@.PLNGTH;  S := SP@.PVAL;
"&&"     I := 1;  DELIM := '(';  J := 0;  K := 0;  L := 0;  COL := 8;
"&&"     FOR E := 1 TO LEN*(SETPACK DIV WORDSIZE) DO
"&&"       BEGIN  J := J * 2;
"&&"         IF K IN S(/I/) THEN J := J + 1;
"&&"         L := L + 1;
"&&"         IF L = 16 THEN
"&&"           BEGIN  L := 0;
"&&"             IF COL >= 65 THEN
"&&"               BEGIN WRITELN(PRR,DELIM);  DELIM := ' ';  COL := 2  END;
"&&"             WRITE(PRR,DELIM,J:1);  DELIM := ',';
"&&"             IF J >= 1000 THEN COL := COL + 6 ELSE
"&&"             IF J >=   10 THEN COL := COL + 4 ELSE COL := COL + 2;
"&&"             J := 0;
"&&"           END;
"&&"         K := K + 1;
"&&"         IF K > SSETMAX THEN
"&&"           BEGIN  K := 0;  I := I + 1  END;
"&&"       END;
"&&"     IF LEN = 0 THEN WRITELN(PRR,'()') ELSE WRITELN(PRR,')');
"&&"   END (*WRITESET*) ;

      PROCEDURE PUTIC;
#     BEGIN
      IF LINECNT > OLDLN THEN
        BEGIN  WRITELN(PRR, ' LOC ',LINECNT:1);  OLDLN := LINECNT  END ;
      END;

"&&" PROCEDURE STRUCTCONSTANT( FSYS: SETOFSYS;  VAR FSP: STP;
"&&"                           VAR FVALU: VALU;  VAR SLC: INTEGER );
"&&"   LABEL 10;
"&&"   VAR  LSET: SETRANGE;  LVALU: VALU;  I,J,K,L,MAXELEM: INTEGER;
"&&"        LSP,LSP1,ELT,LRECVAR: STP;  FLDPR: CTP;  TEST: BOOLEAN;
"&&"        CSTEXTNAME: ARRAY(/1..EXTNAMSZ/) OF CHAR;
"&&"
"&&"   PROCEDURE STOWCONST( ELSP: STP );
"&&"     VAR  I,ELSIZE: INTEGER;  ELSP1: STP;  CH: CHAR;
"&&"     BEGIN  ELSP1 := ELSP;
"&&"       IF ELSP <> NIL THEN
"&&"         BEGIN  ALIGN(CONSTLC,ELSP@.ALN);  ELSIZE := ELSP@.SIZE  END
"&&"       ELSE ELSIZE := 1;
"&&"       STRUCTCONSTANT( FSYS+(/COMMA,RPARENT/),ELSP1,LVALU,I);
"&&"       IF NOT COMPTYPES(ELSP,ELSP1) THEN
"&&"         BEGIN  ERROR(145);  ELSP1 := NIL  END;
"&&"       IF ELSP1 <> NIL THEN
"&&"        IF PRCODE THEN IF I < 0 THEN
"&&"         BEGIN  PUTIC;  WRITE(PRR, CONSTLC:1, MN(/70/) (*DFC*) );
"&&"           IF ELSP1 = REALPTR THEN
"&&"             WRITELN(PRR,'R,':3,LVALU.VALP@.RVAL)
"&&"           ELSE IF ELSP1@.FORM <= SUBRANGE THEN
"&&"             BEGIN  CH := 'I';
"&&"               IF ELSIZE=2 THEN CH := 'H' ELSE IF ELSIZE=1 THEN CH := 'B';
"&&"               WRITELN(PRR, CH:2, ',', LVALU.IVAL:1 )
"&&"             END
"&&"           ELSE IF ELSP1@.FORM = POINTER THEN
"&&"             WRITELN(PRR,'N':2)
"&&"           ELSE IF ELSP1@.FORM = POWER THEN
"&&"             BEGIN  WRITE(PRR,'S,':3);
"&&"               LVALU.VALP@.PLNGTH := ELSP1@.SIZE;
"&&"               WRITESET( LVALU.VALP );
"&&"             END
"&&"           ELSE IF STRING(ELSP1) THEN
"&&"             BEGIN  WRITE(PRR,'M,''':4);  I := 1;
"&&"               WITH LVALU.VALP@ DO
"&&"                 WHILE I <= SLNGTH DO
"&&"                   BEGIN  WRITE(PRR,SVAL(/I/):1);
"&&"                     IF SVAL(/I/) = '''' THEN WRITE(PRR,'''');
"&&"                     I := I + 1
"&&"                   END;
"&&"               WRITELN(PRR,'''');
"&&"             END;
"&&"           CONSTLC := CONSTLC + ELSIZE;
"&&"         END;
"&&"     END (*STOWCONST*) ;

"&&"   BEGIN  (*STRUCTCONSTANT*)
"&&"     LSP := FSP;  FVALU.IVAL := 0;  SLC := -1;
"&&"     IF SY IN CONSTBEGSYS THEN  (*SIMPLE CONSTANT*)
"&&"       BEGIN
"&&"         CONSTANT( FSYS, FSP, FVALU );
"&&"         IF NOT COMPTYPES(LSP,FSP) THEN BEGIN ERROR(145); FSP := NIL END
"&&"         ELSE IF LSP <> NIL THEN FSP := LSP
"&&"       END
"&&"     ELSE IF SY = LBRACK THEN   (*SET CONSTANT*)
"&&"       BEGIN  INSYMBOL;
"&&"         ELT := NIL;  MAXELEM := -1;
"&&"         FOR I := 1 TO (SETMAX+1) DIV (SSETMAX+1) DO
"&&"           LSET(/I/) := (/ /);
"&&"         IF LSP <> NIL THEN
"&&"           IF LSP@.FORM = POWER THEN ELT := LSP@.ELSET ELSE ERROR(145);
"&&"           TEST := FALSE;
"&&"         IF SY <> RBRACK THEN
"&&"           REPEAT
"&&"             CONSTANT( FSYS+(/RBRACK,COMMA,DOTDOT/),LSP1,LVALU );
"&&"             IF NOT COMPTYPES(LSP1,ELT) THEN ERROR(145);
"&&"             ELT := LSP1;  I := LVALU.IVAL;
"&&"             IF SY = DOTDOT THEN
"&&"               BEGIN  INSYMBOL;
"&&"                 CONSTANT( FSYS+(/RBRACK,COMMA/),LSP1,LVALU );
"&&"                 IF NOT COMPTYPES(LSP1,ELT) THEN
"&&"                   BEGIN  LVALU.IVAL := I;  ERROR(137)  END
"&&"               END;
"&&"             IF (I < 0) OR (LVALU.IVAL > SETMAX) OR (I > LVALU.IVAL) THEN
"&&"               ERROR(137)
"&&"             ELSE
"&&"               BEGIN
"&&"                 IF LVALU.IVAL > MAXELEM THEN MAXELEM := LVALU.IVAL;
"&&"                 REPEAT  J := I DIV (SSETMAX+1);
"&&"                   LSET(/J+1/) := LSET(/J+1/) + (/I-J*(SSETMAX+1)/);
"&&"                   I := I + 1
"&&"                 UNTIL I > LVALU.IVAL
"&&"               END;
"&&"             IF SY = COMMA THEN INSYMBOL ELSE TEST := TRUE;
"&&"           UNTIL TEST;
"&&"         IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12);
"&&"         NEW( FVALU.VALP, PSET );
"&&"         WITH FVALU.VALP@ DO
"&&"           BEGIN  PVAL := LSET;
"&&"             PLNGTH := ((MAXELEM+SETPACK) DIV SETPACK)*WORDSIZE;
"&&"           END;
"&&"         IF LSP = NIL THEN
"&&"           BEGIN  NEW(LSP,POWER);
"&&"             WITH LSP@ DO
"&&"               BEGIN  ELSET := ELT;  FORM := POWER;
"&&"                 SIZE := FVALU.VALP@.PLNGTH;  ALN := WORDSIZE
"&&"               END;
"&&"             FSP := LSP
"&&"           END
"&&"       END  (* IF SY=LBRACK... *)
"&&"     ELSE IF SY = LPARENT THEN     (*ARRAY OR RECORD CONSTANT*)
"&&"       BEGIN  INSYMBOL;  K := 0;
"&&"         IF CONSTLC < 0 THEN  (* NO CONSTANTS WRITTEN YET *)
"&&"           WITH FPROCP@ DO
"&&"             BEGIN  CSTEXTNAME := EXTNAME;  I := EXTNAMSZ;
"&&"               IF FPROCP <> MAINPROG THEN
"&&"                 IF NOT EXTRN THEN I := 5;
"&&"               REPEAT  CSTEXTNAME(/I/) := '#';  I := I - 1
"&&"               UNTIL  CSTEXTNAME(/I/) <> ' ';
"&&"               WRITELN(PRR,CSTEXTNAME,MN(/71/) (*CST*), ' ',
"&&"                 NAME,PFNAME:5,',',ASSEMBLE:1,',',GET_STAT:1,
"&&"                 ',',ASMVERB:1);
"&&"               CONSTLC := FIRSTCONSTLC;
"&&"             END;
"&&"         IF LSP <> NIL THEN
"&&"           WITH LSP@ DO
"&&"             IF FORM = ARRAYS THEN
"&&"               BEGIN  ALIGN(CONSTLC,ALN);  SLC := CONSTLC;  J := SLC;
"&&"                 IF AELTYPE <> NIL THEN L := AELTYPE@.SIZE
"&&"                 ELSE                   L := 1;
"&&"                 ALIGN(L,ALN);  TEST := FALSE;
"&&"                 REPEAT  K := K + 1;
"&&"                   STOWCONST( AELTYPE );
"&&"                   IF SY = COMMA THEN
"&&"                     BEGIN  INSYMBOL;  J := J+L;  CONSTLC := J  END
"&&"                   ELSE  TEST := TRUE
"&&"                 UNTIL TEST;
"&&"                 IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4);
"&&"                 IF INXTYPE <> NIL THEN
"&&"                   BEGIN  GETBOUNDS(INXTYPE,I,J);  J := J-I+1  END
"&&"                 ELSE  J := SIZE DIV L;
"&&"                 IF K <> J THEN
"&&"                   IF K > J THEN ERROR(207)
"&&"                   ELSE BEGIN
"&&"                     ERRKIND := 'W';  ERROR(306);
"&&"                     IF PRCODE THEN WRITELN(PRR, SLC+SIZE-1:1,
"&&"                         MN(/70/) (*DFC*), ' B,0');
"&&"                   END;
"&&"                 CONSTLC := SLC + SIZE;
"&&"               END
"&&"             ELSE IF FORM = RECORDS THEN
"&&"               BEGIN  ALIGN(CONSTLC,ALN);  SLC := CONSTLC;  L := SIZE;
"&&"                 LRECVAR := RECVAR;  TEST := TRUE;  FLDPR := FSTFLD;
"&&"   10:           WHILE TEST AND (FLDPR <> NIL) DO
"&&"                   WITH FLDPR@ DO
"&&"                     BEGIN  CONSTLC := SLC + FLDADDR;
"&&"                       STOWCONST( IDTYPE );
"&&"                       FLDPR := NEXT;
"&&"                       IF SY = COMMA THEN INSYMBOL ELSE TEST := FALSE
"&&"                     END;
"&&"                 IF TEST THEN
"&&"                   IF LRECVAR <> NIL THEN  (*TAG FIELD VALUE IS NEXT*)
"&&"                     WITH LRECVAR@ DO
"&&"                       IF TAGFIELDP <> NIL THEN
"&&"                         WITH TAGFIELDP@ DO
"&&"                           BEGIN
"&&"                             IF NAME <> BLANKID THEN
"&&"                               BEGIN  CONSTLC := SLC + FLDADDR;
"&&"                                      STOWCONST( IDTYPE )  END
"&&"                             ELSE BEGIN
"&&"                                 CONSTANT(FSYS+(/COMMA,RPARENT/),LSP1,LVALU)
"&&"                              ;  IF NOT COMPTYPES(IDTYPE,LSP1) THEN
"&&"                                   ERROR(145);
"&&"                               END;
"&&"                             IF SY=COMMA THEN INSYMBOL ELSE TEST:=FALSE;
"&&"                             LSP1 := FSTVAR;  L := SIZE;
"&&"                             WHILE LSP1 <> NIL DO
"&&"                               WITH LSP1@ DO
"&&"                                 IF VARVAL = LVALU THEN
"&&"                                   BEGIN  LRECVAR := SUBVAR;  L := SIZE;
"&&"                                     FLDPR := FSTSUBFLD;  GOTO 10
"&&"                                   END
"&&"                                 ELSE LSP1 := NXTVAR;
"&&"                           END;
"&&"                 CONSTLC := SLC + L;
"&&"                 IF SY <> RPARENT THEN ERROR(4) ELSE INSYMBOL;
"&&"               END (* IF FORM=RECORDS... *)
"&&"             ELSE ERROR(208);  (*WRONG FORM FOR CONSTANT*)
"&&"       END (*IF SY=LPARENT*)
"&&"     ELSE ERROR(50);
"&&"   END (*STRUCTCONSTANT*);

    PROCEDURE CONSTDECLARATION;
      VAR LCP: CTP; LSP: STP; LVALU: VALU;
"&&"      SKID: ALPHA;  SKLC: ADDRRANGE;
"&&" BEGIN  LISTTAG := 'C';
      IF SY <> IDENT THEN
        BEGIN ERROR(2); SKIP(FSYS + [IDENT]) END;
      WHILE SY = IDENT DO
"&&"    BEGIN SKID := ID;  INSYMBOL;
"&&"      IF SY = COLON THEN
"&&"        BEGIN  INSYMBOL;  EXTUSED := TRUE;
"&&"               TYP( FSYS+(/RELOP/), LSP, SKLC );
"&&"        END
"&&"      ELSE LSP := NIL;
"&&"      IF (SY=RELOP) AND (OP=EQOP) THEN
"&&"        BEGIN  INSYMBOL;
"&&"          STRUCTCONSTANT( FSYS+(/SEMICOLON/), LSP, LVALU, SKLC );
"&&"          IF SKLC >= 0 THEN
"&&"            NEW(LCP,STRUCTKONST)
"&&"          ELSE NEW(LCP,KONST);
"&&"          WITH LCP@ DO
"&&"            BEGIN  NAME := SKID;  IDTYPE := LSP;  NEXT := NIL;
"&&"              IF SKLC >= 0 THEN
"&&"                BEGIN  KLASS := STRUCTKONST;  SKOWNER := FPROCP;
"&&"                       SKADDR := SKLC
"&&"                END
"&&"              ELSE BEGIN  KLASS := KONST;  VALUES := LVALU  END
"&&"            END;
"&&"          ENTERID( LCP );
"&&"        END
"&&"      ELSE ERROR(16);
          IF SY = SEMICOLON THEN
            BEGIN INSYMBOL;
              IF NOT (SY IN FSYS + [IDENT]) THEN
                BEGIN ERROR(6); SKIP(FSYS + [IDENT]) END
            END
          ELSE ERROR(14)
        END;
"&&" LISTTAG := ' ';
    END (*CONSTDECLARATION*) ;

    PROCEDURE TYPEDECLARATION;
      VAR LCP,LCP1,LCP2: CTP; LSP: STP; LSIZE: ADDRRANGE;
    BEGIN
      IF SY <> IDENT THEN
        BEGIN ERROR(2); SKIP(FSYS + [IDENT]) END;
      WHILE SY = IDENT DO
        BEGIN NEW(LCP,TYPES);
          WITH LCP@ DO
            BEGIN NAME := ID; IDTYPE := NIL; KLASS := TYPES END;
          INSYMBOL;
          IF (SY = RELOP) AND (OP = EQOP) THEN INSYMBOL ELSE ERROR(16);
          TYP(FSYS + [SEMICOLON],LSP,LSIZE);
          ENTERID(LCP);
          LCP@.IDTYPE := LSP;
          (*HAS ANY FORWARD REFERENCE BEEN SATISFIED:*)
          LCP1 := FWPTR;
          WHILE LCP1 <> NIL DO
            BEGIN
              IF LCP1@.NAME = LCP@.NAME THEN
                BEGIN LCP1@.IDTYPE@.ELTYPE := LCP@.IDTYPE;
                  IF LCP1 <> FWPTR THEN
                    LCP2@.NEXT := LCP1@.NEXT
                  ELSE FWPTR := LCP1@.NEXT;
                END;
              LCP2 := LCP1; LCP1 := LCP1@.NEXT
            END;
          IF SY = SEMICOLON THEN
            BEGIN INSYMBOL;
              IF NOT (SY IN FSYS + [IDENT]) THEN
                BEGIN ERROR(6); SKIP(FSYS + [IDENT]) END
            END
          ELSE ERROR(14)
        END;
      IF FWPTR <> NIL THEN
"&&"    BEGIN ERROR(117); WRITELN(OUTPUT);  PLCNT := PLCNT + 1;
"&&"      REPEAT WRITELN(OUTPUT,' UNDEFINED TYPE: ',FWPTR@.NAME);
"&&"        PLCNT := PLCNT + 1;  FWPTR := FWPTR@.NEXT
          UNTIL FWPTR = NIL;
        END
    END (*TYPEDECLARATION*) ;

    PROCEDURE VARDECLARATION;
#     VAR  LCP, NXT, NXT1: CTP;  LSP: STP;  LSIZE: ADDRRANGE;
           LFPTR : FRECPTR ;
"&&" BEGIN  LISTTAG := 'D';  NXT := NIL;
#     REPEAT  NXT1 := NIL;
#       REPEAT
#         IF SY = IDENT THEN
#           BEGIN  NEW(LCP,VARS);
#             WITH LCP@ DO
#               BEGIN  NAME := ID;  NEXT := NIL;  KLASS := VARS;
#                 IDTYPE := NIL;  VKIND := ACTUAL;  VLEV := LEVEL
#               END;
#             ENTERID(LCP);
#             IF NXT1 = NIL THEN NXT1 := LCP;       (*BEGINNING OF THIS ROUND*)
#             IF NXT <> NIL THEN NXT@.NEXT := LCP;  (*LINK TO PREVIOUS CHAIN*)
#             NXT := LCP;
#             INSYMBOL;
#           END
#         ELSE ERROR(2);
#         IF NOT (SY IN FSYS + [COMMA,COLON] + TYPEDELS) THEN
#           BEGIN ERROR(6); SKIP(FSYS+[COMMA,COLON,SEMICOLON]+TYPEDELS) END;
#         TEST := SY <> COMMA;
#         IF NOT TEST THEN INSYMBOL
#       UNTIL TEST;
#       IF SY = COLON THEN INSYMBOL ELSE ERROR(5);
#       TYP(FSYS + [SEMICOLON] + TYPEDELS,LSP,LSIZE);
#
#       WHILE NXT1 <> NIL DO
#         WITH  NXT1@ DO
#           BEGIN   IDTYPE := LSP;
"@@"          IF LSP <> NIL THEN
"@@"            BEGIN
"@@"              ALIGN( LC, LSP@.ALN );
"@@"              VADDR := LC;  LC := LC + LSIZE;
"@@"              IF LSP@.FORM = FILES THEN
"@@"                IF LEVEL > 1 THEN
"@@"                  ERROR( 398 )   (* ONLY GLOBAL FILES SUPPORTED *)
"@@"                ELSE BEGIN
"@@"                  NEW(LFPTR);  LFPTR@.FILIDPTR := NXT1;
"@@"                  LFPTR@.NEXTFILE := FILEHEAD;  FILEHEAD := LFPTR
"@@"                END
"@@"            END
"@@"          ELSE VADDR := LC;
"E"           IF DEBUG_LEV > 0 THEN  PRNTSYMBL(NXT1);
#             NXT1 := NEXT;
#           END;

        IF SY = SEMICOLON THEN
          BEGIN INSYMBOL;
            IF NOT (SY IN FSYS + [IDENT]) THEN
              BEGIN ERROR(6); SKIP(FSYS + [IDENT]) END
          END
        ELSE ERROR(14)
      UNTIL (SY <> IDENT) AND NOT (SY IN TYPEDELS);
"&&"  LISTTAG := ' ';
      IF FWPTR <> NIL THEN
        BEGIN ERROR(117); WRITELN(OUTPUT); PLCNT := PLCNT + 1;
          REPEAT WRITELN(OUTPUT,' UNDEFINED TYPE: ',FWPTR@.NAME);
            PLCNT := PLCNT + 1;  FWPTR := FWPTR@.NEXT
          UNTIL FWPTR = NIL;
        END ;
    END (*VARDECLARATION*) ;

"&&" PROCEDURE MKNAME(VAR ALB: ALPHA; NLB: INTEGER; NCFLAG: BOOLEAN);
       VAR I,J: INTEGER;
     BEGIN  I := 1;  J := 8;
#      IF NOT NCFLAG THEN J := 5;
#      REPEAT
#        IF ALB(/I/) = '_' THEN ALB(/I/) := '$';  I := I + 1
#      UNTIL (I > J) OR (ALB(/I/) = ' ');
#      IF NOT NCFLAG THEN
#        FOR J := 8 DOWNTO I DO
#          BEGIN  ALB(/J/) := CHR( ORD('0') + NLB MOD 10 );
#            NLB := NLB DIV 10
#          END;
#    END (*MKNAME*) ;

    PROCEDURE PROCDECLARATION(FSY: SYMBOL);
"&&" LABEL 10;
"&&"  VAR LSY: SYMBOL; LCP,LCP1,LCP2: CTP; LSP: STP;
"&&"      FORW: BOOLEAN; K, PARCNT: INTEGER;  OLDLABEL: LABELRNG;
"@@"      LLC,LCM: ADDRRANGE; I, NAME: INTEGER; MARKP: @INTEGER;
"&&"      OLD_HASH: HASH_TABLE;

"SH"  PROCEDURE PARAMETERLIST(FSY: SETOFSYS; FPAR: CTP; FW: BOOLEAN);
"**"    VAR LCP,LCP1,LCP2,LCP3,LCP4: CTP; LSP: STP; LKIND: IDKIND;
"**"      LLC,LEN,LALN: ADDRRANGE;
"SH"      LSY: SYMBOL;
"**"  BEGIN   LCP1 := NIL;  LCP := NIL;
        IF NOT (SY IN FSY + [LPARENT]) THEN
          BEGIN ERROR(7); SKIP(FSYS + FSY + [LPARENT]) END;
        IF SY = LPARENT THEN
"SH"      BEGIN IF FORW THEN ERROR(119) ELSE LC := LCAFTMST + FPSAVEAREA;
            INSYMBOL;
            IF NOT (SY IN [IDENT,VARSY,PROCSY,FUNCSY]) THEN
              BEGIN ERROR(7); SKIP(FSYS + [IDENT,RPARENT]) END;
            WHILE SY IN [IDENT,VARSY,PROCSY,FUNCSY] DO
"**"          BEGIN  LCP3 := NIL;
"SH"            IF SY IN [PROCSY,FUNCSY] THEN
"SH"              BEGIN  LSY := SY;  (*REMEMBER IF PROC OR FUNC *)
"SH"                INSYMBOL;
                      IF SY = IDENT THEN
"SH"                  BEGIN
"SH"                    IF LSY = PROCSY THEN NEW(LCP,PROC,DECLARED)
"SH"                    ELSE                 NEW(LCP,FUNC,DECLARED);
"**"                    IF LCP3<>NIL THEN LCP4@.NEXT:=LCP ELSE LCP3:=LCP;
"**"                    LCP4 := LCP;
"SH"                    ALIGN(LC, PTRSIZE);
                        WITH LCP@ DO
"**"                      BEGIN NAME := ID; IDTYPE := NIL; NEXT := NIL;
"SH"                        PFDECKIND := DECLARED;  PFKIND := FORMAL;
"SH"                        FRTRN := FALSE;  EXTRN := FALSE;
"&&"                        EXTNAME := '*PFPARM*';
"SH"                        PFLEV := LC*10 + LEVEL;
"SH"                        (*I.E. PFLEV > LCAFTMST => PROC PARM *)
"SH"                        PROCLAB := PROCLAB+1;  PFNAME := PROCLAB;
"SH"                        IF LSY = PROCSY THEN KLASS := PROC
"SH"                        ELSE                 KLASS := FUNC;
                            END;
                        ENTERID(LCP);
"&&"                    LC := LC + DISPAREA;
"SH"                    INSYMBOL;
"SH"                    LLC := LC;
"SH"                    IF LSY = PROCSY THEN
"SH"                      PARAMETERLIST( [SEMICOLON,RPARENT], LCP, FALSE )
"SH"                    ELSE
"SH"                      PARAMETERLIST( [SEMICOLON,COLON], LCP, FALSE );
"SH"                    LC := LLC;
                      END
                    ELSE ERROR(2);
"SH"                IF NOT (SY IN FSYS + [SEMICOLON,RPARENT]) THEN
"SH"                  BEGIN ERROR(7);SKIP(FSYS+[SEMICOLON,RPARENT])END
                  END
                ELSE
                  BEGIN
                    IF SY = VARSY THEN
                      BEGIN LKIND := FORMAL; INSYMBOL END
                    ELSE LKIND := ACTUAL;
                    REPEAT
                      IF SY = IDENT THEN
                        BEGIN NEW(LCP,VARS);
"**"                      IF LCP3<>NIL THEN LCP4@.NEXT:=LCP ELSE LCP3:=LCP;
"**"                      LCP4 := LCP;
                          WITH LCP@ DO
                            BEGIN NAME:=ID; IDTYPE:=NIL; KLASS:=VARS;
                              VKIND := LKIND; NEXT := NIL; VLEV := LEVEL;
                            END;
                          ENTERID(LCP);
                          INSYMBOL;
                        END;
                      IF NOT (SY IN [COMMA,COLON] + FSYS) THEN
                        BEGIN ERROR(7);SKIP(FSYS+[COMMA,SEMICOLON,RPARENT])
                        END;
                      TEST := SY <> COMMA;
                      IF NOT TEST THEN INSYMBOL
                    UNTIL TEST;
                    IF SY = COLON THEN
                      BEGIN INSYMBOL;
                        IF SY = IDENT THEN
"**"                      BEGIN  SEARCHID([TYPES],LCP4); LEN := PTRSIZE;
"**"                        LSP := LCP4@.IDTYPE;  LALN := PTRSIZE;
                            IF LSP <> NIL THEN
#                             IF (LKIND=ACTUAL) THEN
"@@"                            IF LSP@.FORM = FILES THEN
"**"                              BEGIN ERROR(121); LKIND:=FORMAL END
"**"                            ELSE
"**"                              BEGIN LEN:=LSP@.SIZE; LALN:=LSP@.ALN END;
"**"                        LCP4 := LCP3;
"**"                        WHILE LCP4 <> NIL DO
"**"                        BEGIN WITH LCP4@ DO
"**"                          BEGIN IDTYPE := LSP; ALIGN(LC,LALN);
"**"                                VADDR := LC;   LC := LC+LEN;
"**"                          END;
"**"                          LCP4 := LCP4@.NEXT
"**"                        END;
                            INSYMBOL
                          END
                        ELSE ERROR(2);
                        IF NOT (SY IN FSYS + [SEMICOLON,RPARENT]) THEN
                          BEGIN ERROR(7);SKIP(FSYS+[SEMICOLON,RPARENT])END
                      END
                    ELSE ERROR(5);
                  END;
                IF SY = SEMICOLON THEN
                  BEGIN INSYMBOL;
                    IF NOT (SY IN FSYS + [IDENT,VARSY,PROCSY,FUNCSY]) THEN
                      BEGIN ERROR(7); SKIP(FSYS + [IDENT,RPARENT]) END
                  END;
"**"            IF LCP1 <> NIL THEN LCP2@.NEXT := LCP3
"**"            ELSE LCP1 := LCP3;
"**"            LCP2 := LCP;
              END (*WHILE*) ;
            IF SY = RPARENT THEN
              BEGIN INSYMBOL;
                IF NOT (SY IN FSY + FSYS) THEN
                  BEGIN ERROR(6); SKIP(FSY + FSYS) END
              END
            ELSE ERROR(4);
"SH"      END
"SH"    ELSE  (* IF SY <> LPARENT *)
"SH"      ;
"SH"
"SH"    IF NOT FW THEN FPAR@.PRMPTR := LCP1;
"SH"
"SH"    IF FPAR@.KLASS = FUNC THEN
"SH"      IF SY = COLON THEN
"SH"        BEGIN  INSYMBOL;
"SH"          IF SY = IDENT THEN
"SH"            BEGIN  IF FW THEN ERROR(122);
"SH"              SEARCHID( [TYPES], LCP1 );
"SH"              LSP := LCP1@.IDTYPE;
"SH"              FPAR@.IDTYPE := LSP;
"SH"              IF LSP <> NIL THEN
"SH"                IF LSP@.FORM >= POWER THEN
"SH"                  BEGIN  ERROR(120);  FPAR@.IDTYPE := NIL  END;
"SH"              INSYMBOL
"SH"            END
"SH"          ELSE BEGIN  ERROR(2);  SKIP( FSYS+[SEMICOLON] )  END
"SH"        END
"SH"      ELSE
"SH"        IF NOT FW THEN ERROR(123)

    END (*PARAMETERLIST*) ;

    BEGIN (*PROCDECLARATION*)
      LLC := LC; LC := LCAFTMST + FPSAVEAREA;  (* ADR. OF 1ST VAR OR PARM *)
"@@"  LCM := LCAFTMST;
#     LCP := UPRCPTR ;            (* TO INITIALIZE LCP IN CASE ! *)
      IF SY = IDENT THEN
"&&"    BEGIN  (* SEE IF PROC. ON FORWARD DECL. LIST *)
"&&"      FORW := FALSE;
"&&"      LCP := FWRDPRCL;  LCP2 := NIL;
"&&"      WHILE LCP <> NIL DO
"&&"        IF LCP@.NAME = ID THEN
"&&"          BEGIN  FORW := TRUE;
"&&"            IF LCP2 <> NIL THEN
"&&"              LCP2@.NXTFWRD := LCP@.NXTFWRD
"&&"            ELSE
"&&"              FWRDPRCL := LCP@.NXTFWRD;
"&&"            GOTO 10;
"&&"          END
"&&"        ELSE
"&&"          BEGIN  LCP2 := LCP;
"&&"            LCP := LCP@.NXTFWRD
"&&"          END;
   10:    IF NOT FORW THEN
            BEGIN
"SH"          IF FSY = PROCSY THEN NEW(LCP,PROC,DECLARED)
"SH"          ELSE NEW(LCP,FUNC,DECLARED);
              WITH LCP@ DO
"**"            BEGIN NAME := ID; IDTYPE := NIL;
#                 PFLEV := LEVEL; PROCLAB := PROCLAB+1 ;
#                 PFDECKIND := DECLARED; PFKIND := ACTUAL; PFNAME := PROCLAB;
"&&"              MKNAME(ID,PFNAME,XLINK);
"&&"              EXTRN := XLINK;   FRTRN := FALSE;  FWDECL := FALSE;
"&&"              PACK(ID,1,EXTNAME);
                  IF FSY = PROCSY THEN KLASS := PROC
                  ELSE KLASS := FUNC
                END;
              ENTERID(LCP);
"&&"          OLD_HASH := BUCKET;  (* NEW SCOPE BEGINS NEXT *)
            END
          ELSE
"SH"        BEGIN LCP1 := LCP@.PRMPTR;  LCP@.FWDECL := FALSE;
"&&"          OLD_HASH := BUCKET;  (* NEW SCOPE BEGINS NOW *)
"&&"          LEVEL := LEVEL+1;  TOP := LEVEL;
              WHILE LCP1 <> NIL DO
                BEGIN
"&&"              ENTERID(LCP1);  (* NAME NEEDS TO BE RE-ENTERED *)
                  WITH LCP1@ DO
                    IF KLASS = VARS THEN
                      IF IDTYPE <> NIL THEN
                        BEGIN
#                       IF VKIND = FORMAL THEN LCM := VADDR+PTRSIZE
                        ELSE LCM := VADDR + IDTYPE@.SIZE;
                        IF LCM > LC THEN LC := LCM
                        END;
                  LCP1 := LCP1@.NEXT
                END;
"&&"          LEVEL := LEVEL - 1;  TOP := LEVEL
            END;
          INSYMBOL
        END
      ELSE ERROR(2);
      OLDLABEL := INTLABEL ;  INTLABEL := 0 ;
      IF LEVEL<MAXLEVEL THEN LEVEL := LEVEL+1 ELSE FATALERROR(251);
"&&"  TOP := LEVEL;
      WITH DISPLAY[TOP] DO
"&&"    BEGIN OCCUR := BLCK; FLABEL := NIL END;
"SY"  IF GET_STAT THEN
"SY"    PROC_CNT[LEVEL] := PROC_CNT[LEVEL] + 1;
"SH"  IF FSY = PROCSY THEN  PARAMETERLIST( [SEMICOLON], LCP, FORW )
"SH"  ELSE PARAMETERLIST( [SEMICOLON,COLON], LCP, FORW );

"&&"  LCP@.FWDECL := FALSE;
      IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
#     IF SY IN  [FORWARDSY,FRTRNSY,EXTRNSY]  THEN
#       BEGIN
#       IF SY = FORWARDSY THEN
"@@"      BEGIN IF FORW THEN ERROR(161);
"@@"            LCP@.FWDECL := TRUE;
"&&"            LCP@.NXTFWRD := FWRDPRCL;   (* LINK PROC. INTO *)
"&&"            FWRDPRCL := LCP;            (* FORWARD PROC. LIST *)
"@@"            INSYMBOL
"@@"      END
"@@"    ELSE BEGIN  (* SY MUST BE FRTRNSY OR EXTRNSY *)
"@@"        IF SY = FRTRNSY THEN LCP@.FRTRN := TRUE
"@@"                        ELSE LCP@.EXTRN := TRUE;
"@@"        INSYMBOL;
"&&"        WITH LCP@ DO
"@@"          IF SY = STRINGCONST THEN
"&&"            WITH VAL.VALP@ DO
"@@"              BEGIN
"&&"                WHILE LNGTH < EXTNAMSZ DO
"&&"                  BEGIN  LNGTH := LNGTH+1;  SVAL(/I/) := ' '  END;
"&&"                PACK( SVAL, 1, EXTNAME );
"@@"               INSYMBOL
"@@"             END
"@@"          ELSE
"&&"            PACK( NAME, 1, EXTNAME );
"@@"      END;
          IF SY = SEMICOLON THEN INSYMBOL ELSE ERROR(14);
          IF NOT (SY IN FSYS) THEN  BEGIN ERROR(6); SKIP(FSYS) END
        END
      ELSE
        BEGIN
"E"       IF DEBUG_LEV > 0 THEN  PRNTSYMBL(LCP);
          MARK(MARKP); (* MARK HEAP FOR BLOCK ENTRY *)
          REPEAT BLOCK(FSYS,SEMICOLON,LCP);
            IF SY = SEMICOLON THEN
              BEGIN INSYMBOL;
                IF NOT (SY IN [BEGINSY,PROCSY,FUNCSY]) THEN
                  BEGIN ERROR(6); SKIP(FSYS) END
              END
            ELSE ERROR(14)
          UNTIL SY IN [BEGINSY,PROCSY,FUNCSY];
          RELEASE(MARKP); (* RETURN LOCAL ENTRIES ON RUNTIME HEAP *)
        END;
"&&"  LEVEL := LEVEL-1; TOP := LEVEL; LC := LLC; INTLABEL := OLDLABEL ;
"&&"  BUCKET := OLD_HASH;  (*RESTORE SYMBOL TABLE*)
    END (*PROCDECLARATION*) ;

#
#     FUNCTION PROCTYPE(FPROCP: CTP): INTEGER ;
#
#     BEGIN   PROCTYPE := ORD('P') ;
#       IF FPROCP <> NIL THEN
#         WITH FPROCP@ DO
#           BEGIN  IF FRTRN THEN  PROCTYPE := ORD('F') ;
#           IF FPROCP@.IDTYPE <> NIL THEN
#           WITH FPROCP@ DO
#             BEGIN
#             IF IDTYPE = REALPTR THEN
#                     IF FRTRN THEN PROCTYPE := ORD('Z')
#                     ELSE PROCTYPE := ORD('R')
#               ELSE IF IDTYPE = BOOLPTR THEN
#                      IF FRTRN THEN PROCTYPE := ORD('X')
#                      ELSE PROCTYPE := ORD('B')
#                 ELSE IF IDTYPE@.FORM = POINTER THEN
#                   PROCTYPE := ORD('A')
#                   ELSE
#                       IF IDTYPE@.SIZE = 1 THEN PROCTYPE := ORD('C')
#                      ELSE  IF FRTRN THEN PROCTYPE := ORD('Y')
"&&"                         ELSE IF IDTYPE@.SIZE = HINTSIZE THEN
"&&"                            PROCTYPE := ORD('H')
"&&"                         ELSE  PROCTYPE := ORD('I');
#            END
#          END (*WITH FPROCP@*) ;
#     END (*PROCTYPE*) ;
#
    PROCEDURE BODY(FSYS: SETOFSYS);
#     CONST   CIXMAX = 400;
      TYPE OPRANGE = 0..OPMAX;
#
#         CALLED_PROC = RECORD
#                         NAME : ALPHA ;
#                         LVL  : LEVRANGE ;
#                         CNT  : 1..100 ;
#                         NXT  : @ CALLED_PROC
#                       END ;
#
#   VAR
#         CALL_HEAD, T2_CLIST, T_CLIST  : @ CALLED_PROC ;
#         LOCAL_CALL,                   (* THIS PROC CALLS A LOCAL PROC *)
#         MODIFYING : BOOLEAN ;         (* A PROGRAM VAR BEING MODIFIED*)
#         VAR_REF, VAR_MOD : INTEGER ;  (* # OF VARIABLES ACCESSED/REFERENCED*)
#         CNSTPTR:  CSP;
          I: INTEGER;
          LCMAX,LLC1: ADDRRANGE;  LCP,LLCP: CTP;
#         LLP: LBP;
"CT"      FIRSTLN : INTEGER;  CTRNO : CTRRANGE;



      PROCEDURE GEN0(FOP: OPRANGE);
      BEGIN
        IF PRCODE THEN BEGIN PUTIC; WRITELN(PRR,MN[FOP]:4) END;
        IC := IC + 1
      END (*GEN0*) ;

      PROCEDURE GEN1(FOP: OPRANGE; FP2: INTEGER);
        VAR K: INTEGER;
      BEGIN
        IF PRCODE THEN
          BEGIN PUTIC; WRITE(PRR,MN[FOP]:4);
            IF FOP = 30 THEN  (*CSP*)  WRITELN(PRR,SNA[FP2]:4)
            ELSE IF FOP = 37 THEN  (*LCA*)
"SH"          IF FP2 = ORD('P') THEN  (* LOAD PROCEDURE ADDRESS *)
"SH"            WRITELN(PRR, ' P,', ID:EXTNAMSZ)
"SH"          ELSE
"**"          IF FP2 <> ORD('S') THEN  (* CHAR STRING OPND *)
"**"               BEGIN WRITE(PRR,' M,''');
#                    WITH CNSTPTR@  DO
#                      BEGIN
#                      FOR K := 1 TO SLNGTH DO
#                        BEGIN  WRITE(PRR,SVAL[K]:1);
#                        IF SVAL[K] = '''' THEN WRITE(PRR,'''')
#                        END ;
#                      STIC := STIC+SLNGTH ;
#                      END ;
#                    WRITELN(PRR,'''')
                   END
"**"             ELSE  (* SET OPERAND *)
"**"               BEGIN  WRITE(PRR,' S,');
"&&"                 WRITESET( CNSTPTR );
"**"               END
                 ELSE IF (FOP = 26) OR (FOP = 42)
                         THEN  (*STO,RET*)
                        WRITELN(PRR,CHR(FP2):2)
                      ELSE WRITELN(PRR, ' ', FP2:1)
          END;
        IC := IC + 1
      END (*GEN1*) ;

      PROCEDURE GEN2(FOP: OPRANGE; FP1,FP2: INTEGER);
#       VAR I, J, K : INTEGER;
      BEGIN
        IF PRCODE THEN
          BEGIN PUTIC; WRITE(PRR,MN[FOP]:4,' ');
            CASE FOP OF
              22,23,35,39,43: (*DEC,INC,IND,LDO,SRO*)
                WRITELN(PRR,CHR(FP1),',',FP2:1 );
"&&"          29,41,50,58,68,69:  (*MST,LDA,SCL,NEW,SLD,SMV*)
                WRITELN(PRR,FP1:1,',',FP2:1);
              47,48,49,52,53,55: (*EQU..NEQ*)
                BEGIN WRITE(PRR,CHR(FP1));
                  IF FP1 = ORD('M') THEN WRITE(PRR,',',FP2:1);
                  WRITELN(PRR)
                END;
              51: (*LDC*)
                CASE FP1 OF
#                 0: WRITELN(PRR,'C,''',CHR(FP2):1,'''') ;
                  1: WRITELN(PRR,'I,',FP2:1);
                  2: BEGIN WRITE(PRR,'R,');
#                      WITH CNSTPTR@  DO
                         FOR K := 1 TO REALLNGTH DO
                           IF RVAL[K] <> ' ' THEN WRITE(PRR,RVAL[K]);
                       WRITELN(PRR)
                     END;
                  3: WRITELN(PRR,'B,',FP2:1);
                  4: WRITELN(PRR,'N');
"**"              OTHERWISE ERROR( 400 );
                END
            END;
          END;
          IC := IC + 1
      END (*GEN2*) ;

#     PROCEDURE GEN3(FOP: OPRANGE; FP0,FP1,FP2: INTEGER);
#     BEGIN
#       IF PRCODE THEN
#         BEGIN PUTIC;
"&&"        IF FOP = 76 (*PAK*) THEN
"&&"          WRITELN(PRR,MN(/FOP/):4,' ',FP0:1,' ',FP1:1,' ',FP2:1)
"&&"        ELSE
"&&"          WRITELN(PRR,MN(/FOP/):4,CHR(FP0):2,',',FP1:1,',',FP2:1)
"&&"      END;
#         IC := IC + 1
#     END (*GEN3*) ;

      PROCEDURE LOAD;
      BEGIN
        WITH GATTR DO
          IF TYPTR <> NIL THEN
            BEGIN
              CASE KIND OF
                CST:   IF (TYPTR@.FORM = SCALAR) AND (TYPTR <> REALPTR) THEN
                         IF TYPTR = BOOLPTR THEN GEN2(51(*LDC*),3,CVAL.IVAL)
                         ELSE
                          IF TYPTR = CHARPTR THEN GEN2(51(*LDC*),0,CVAL.IVAL)
                           ELSE GEN2(51(*LDC*),1,CVAL.IVAL)  (*INTEGER*)
                       ELSE
                         IF TYPTR = NILPTR THEN GEN2(51(*LDC*),4,0)
                         ELSE
#                            BEGIN
#                              CNSTPTR  := CVAL.VALP;
                               IF TYPTR = REALPTR THEN
#                                GEN2(51(*LDC*),2,0)
                               ELSE
#                                 GEN2(51(*LDC*),5,0)
                             END;
                VARBL: CASE ACCESS OF
#                        DRCT:   GEN3(54(*LOD*),GETTYPE(BTYPE),
                                         VLEVEL,DPLMT);
                         INDRCT: GEN2(35(*IND*),GETTYPE(BTYPE),IDPLMT);
"**"                     INXD,STKEXPR:   ERROR(400)
                       END;
                EXPR:
              END;
#             IF KIND = VARBL THEN VAR_REF := VAR_REF+1 ;
              KIND := EXPR
            END
      END (*LOAD*) ;

      PROCEDURE STORE(VAR FATTR: ATTR);
      BEGIN
        WITH FATTR DO
          IF TYPTR <> NIL THEN
            CASE ACCESS OF
#             DRCT:   GEN3(56(*STR*),GETTYPE(BTYPE),VLEVEL,DPLMT);
              INDRCT: IF IDPLMT <> 0 THEN ERROR(400)
                      ELSE GEN1(26(*STO*),GETTYPE(BTYPE));
"**"          INXD, STKEXPR:   ERROR(400)
            END
      END (*STORE*) ;

      PROCEDURE LOADADDRESS;
      BEGIN
        WITH GATTR DO
          IF TYPTR <> NIL THEN
            BEGIN
              CASE KIND OF
                CST:   IF STRING(TYPTR) THEN
#                        BEGIN
#                        CNSTPTR := CVAL.VALP ;  GEN1(37(*LCA*),ORD('M')) ;
#                        END
"**"                     ELSE IF TYPTR@.FORM = POWER THEN
"**"                       BEGIN  CNSTPTR := CVAL.VALP;
"**"                              GEN1(37(*LCA*),ORD('S'))
"**"                       END
                       ELSE ERROR(400);
                VARBL: CASE ACCESS OF
#                        DRCT:   GEN2(50(*LDA*),VLEVEL,DPLMT);
                         INDRCT: IF IDPLMT <> 0 THEN
                                    GEN2(23(*INC*),ORD('A'),IDPLMT);
                         INXD:   ERROR(400);
"**"                     STKEXPR: ;   (*SET ALREADY REPRESENTED BY AN ADDRESS*)
                       END;
                EXPR:  ERROR(400)
              END;
              KIND := VARBL; ACCESS := INDRCT; IDPLMT := 0
            END
      END (*LOADADDRESS*) ;


      PROCEDURE GENFJP(FADDR: INTEGER);
      BEGIN LOAD;
        IF GATTR.TYPTR <> NIL THEN
          IF GATTR.TYPTR <> BOOLPTR THEN ERROR(144);
        IF PRCODE THEN BEGIN PUTIC;
#         WRITELN(PRR,MN[33]:4,' L',FADDR:1) END;
        IC := IC + 1
      END (*GENFJP*) ;

      PROCEDURE GENUJPFJP(FOP: OPRANGE; FP2: INTEGER);
      BEGIN
        IF PRCODE THEN
#         BEGIN PUTIC; WRITELN(PRR, MN[FOP]:4, ' L',FP2:1) END ;
        IC := IC + 1
      END (*GENUJPFJP*);


      PROCEDURE GENDEF(L1, L2: ADDRRANGE ) ;
        BEGIN
        IF PRCODE THEN  WRITELN(PRR,'L', L1:1, MN[63(*DEF*)], L2:10);
        END (*GENDEF*) ;


#     PROCEDURE CHKBNDS(FSP: STP);
#       VAR LMIN,LMAX: INTEGER;
#     BEGIN
#       IF FSP <> NIL THEN
#         IF FSP <> BOOLPTR THEN
#           IF FSP <> INTPTR THEN
#             IF FSP <> REALPTR THEN
#               IF FSP@.FORM <= POINTER THEN
#                   IF FSP@.FORM = POINTER (*LMAX <= LMIN*) THEN
#                     BEGIN  FLIPDEBUG := TRUE;
#                     IF ASSIGN THEN  GEN3(45(*CHK*),ORD('A'),-1,0)
#                     ELSE (* ACCESS *)  GEN3(45(*CHK*),ORD('A'),0,0)
#                     END
#                   ELSE
#                     BEGIN
#                     GETBOUNDS(FSP,LMIN,LMAX);
#                     GEN3(45(*CHK*),ORD('I'),LMIN,LMAX) ;
#                     END ;
#     END (*CHKBNDS*);

      PROCEDURE PUTLABEL(LABNAME: INTEGER);
      BEGIN IF PRCODE THEN WRITELN(PRR, 'L', LABNAME:1, MN(/64/) (*LAB*) )
      END (*PUTLABEL*);
"CT"
"CT"
"CT"   FUNCTION CTRGEN : CTRRANGE;
"CT"
"CT"   BEGIN   (* CREATE A UNIQUE STMT COUNTER AND EMIT P-CODE TO INCREMENT IT*)
"CT"     (* R. L. SITES  3 AUG 77 *)
"CT"     CTRGEN := CTRCNT;
"CT"     IF CTROPTION THEN
"CT"             BEGIN
"CT"             GEN1(39(*CTI*), CTRCNT);
"CT"             CTRCNT := CTRCNT+1;
"CT"             END;
"CT"   END; (* CTRGEN *)
"CT"
"CT"   PROCEDURE CTREMIT(CTRT:CTRTYPE; CTRNO:CTRRANGE; FLN, MLN, LLN:INTEGER) ;
"CT"
"CT"     BEGIN   (* WRITE AN ENTRY DESCRIBING A STATEMENT COUNTER. *)
"CT"     (* R. L. SITES  3 AUG 77 *)
"CT"     IF CTROPTION THEN
"CT"       WRITELN(QRR, '#CTR    ', ORD(CTRT):4, CTRNO:6, FLN:7, MLN:7, LLN:7 );
"CT"   END; (* CTREMIT *)
"CT"
      PROCEDURE STATEMENT(FSYS: SETOFSYS);
        LABEL 1;
        VAR LCP: CTP; LLP: LBP; TTOP: DISPRANGE ;
"&&"        XLABEL: ALPHA;
"CT"        CTRNO : CTRRANGE;

        PROCEDURE EXPRESSION(FSYS: SETOFSYS); FORWARD;

"**"    PROCEDURE FORCETEMPSET;
"**"      (* "LOADS" CURRENT SET ONTO RUN-STACK *)
"**"      LABEL 10;  VAR LSIZE: ADDRRANGE;
"**"    BEGIN
"**"      WITH GATTR DO
"**"        IF TYPTR <> NIL THEN
"**"          IF TYPTR@.FORM = POWER (*REDUNDANT TEST?*) THEN
"**"            BEGIN
"**"              IF KIND = VARBL THEN
"**"                IF ACCESS = STKEXPR THEN GOTO 10;
"**"              LSIZE := OPNDSETSIZE( GATTR );
"**"              ALIGN( LC, WORDSIZE );
"**"              LOADADDRESS;
"**"              GEN2( 68 (*SLD*), LSIZE, LC );
"**"              KIND := VARBL;  ACCESS := STKEXPR;
"**"              STKLEN := LSIZE;  STKDPLMT := LC;
"**"              LC := LC + LSIZE;
"**"              IF LC > LCMAX THEN LCMAX := LC;
"**"            END;
"**"    10: END (* FORCETEMPSET *) ;

        PROCEDURE SELECTOR(FSYS: SETOFSYS; FCP: CTP);
          VAR LATTR: ATTR; LCP: CTP; LMIN,LMAX: INTEGER;
        BEGIN
          WITH FCP@, GATTR DO
"&&"        BEGIN TYPTR := IDTYPE; BTYPE := TYPTR; KIND := VARBL;
              CASE KLASS OF
                VARS:
                  IF VKIND = ACTUAL THEN
                    BEGIN ACCESS := DRCT; VLEVEL := VLEV;
                      DPLMT := VADDR
                    END
                  ELSE
                    BEGIN
#                     GEN3(54(*LOD*),ORD('A'),VLEV,VADDR);
                      ACCESS := INDRCT; IDPLMT := 0
                    END;
                FIELD:
                  WITH DISPLAY[DISX] DO
                    IF OCCUR = CREC THEN
                      BEGIN ACCESS := DRCT; VLEVEL := CLEV;
                        DPLMT := CDSPL + FLDADDR
                      END
                    ELSE
                      BEGIN
                        GEN3(54(*LOD*),ORD('A'), LEVEL,VDSPL)  ;
                        ACCESS := INDRCT; IDPLMT := FLDADDR
                      END;
"&&"            STRUCTKONST:
"&&"              BEGIN
"&&"                ID := '########    ';  LMAX := EXTNAMSZ;
"&&"                UNPACK( SKOWNER@.EXTNAME, ID, 1 );
"&&"                IF (SKOWNER <> MAINPROG) THEN
"&&"                  IF NOT SKOWNER@.EXTRN THEN LMAX := 5;
"&&"                REPEAT  ID(/LMAX/) := '#';  LMAX := LMAX - 1
"&&"                UNTIL  ID(/LMAX/) <> ' ';
"&&"                GEN1( 37(*LCA*), ORD('P') );
"&&"                ACCESS := INDRCT;  IDPLMT := SKADDR
"&&"              END;
                FUNC:
"&&"              IF FCP <> UFCTPTR THEN
                    IF PFDECKIND = STANDARD THEN ERROR(150)
                    ELSE
                    IF PFLEV = 0 THEN ERROR(150)   (*EXTERNAL FCT*)
                    ELSE
                      IF PFKIND = FORMAL THEN ERROR(151)
                      ELSE
#                       IF (FPROCP <> FCP) THEN  ERROR(177)
#                       ELSE
                          BEGIN ACCESS := DRCT; VLEVEL := PFLEV + 1;
                            DPLMT := FNCRSLT ;  (*RELAT. ADDR. OF FCT. RESULT*)
                          END
              END (*CASE*) ;
"&&"          IF TYPTR <> NIL THEN
"&&"            IF TYPTR@.FORM = SUBRANGE THEN
"&&"              TYPTR := TYPTR@.RANGETYPE;
            END (*WITH*);
          IF NOT (SY IN SELECTSYS + FSYS) THEN
            BEGIN ERROR(59); SKIP(SELECTSYS + FSYS) END;
          WHILE SY IN SELECTSYS DO
            BEGIN
"&&"          IF SY = LPARENT THEN  (* THIS IS AN ERROR, BUT .. *)
"&&"            BEGIN  SY := LBRACK;
"&&"              IF GATTR.TYPTR <> NIL THEN
"&&"                IF GATTR.TYPTR@.FORM = ARRAYS THEN
"&&"                  BEGIN  ERRKIND := 'W';  ERROR(11)  END
"&&"            END;
        (*[*)   IF SY = LBRACK THEN
                BEGIN
                  REPEAT LATTR := GATTR;
                    WITH LATTR DO
                      IF TYPTR <> NIL THEN
                        IF TYPTR@.FORM <> ARRAYS THEN
                          BEGIN ERROR(138); TYPTR := NIL END;
                    LOADADDRESS;
"&&"                INSYMBOL; EXPRESSION(FSYS + [COMMA,RBRACK,RPARENT]);
                    LOAD;
                    IF GATTR.TYPTR <> NIL THEN
                      IF GATTR.TYPTR@.FORM <> SCALAR THEN ERROR(113);
                    IF LATTR.TYPTR <> NIL THEN
                      WITH LATTR.TYPTR@ DO
                        BEGIN
                          IF COMPTYPES(INXTYPE,GATTR.TYPTR) THEN
                            BEGIN
                              IF INXTYPE <> NIL THEN
                                BEGIN GETBOUNDS(INXTYPE,LMIN,LMAX);
#                                 IF DEBUG THEN
#                                   GEN3(45(*CHK*),ORD('J'),LMIN,LMAX) ;
#                                 IF LMIN > 0 THEN
#                                   GEN2(22(*DEC*),GETTYPE(GATTR.TYPTR),LMIN)
#                                 ELSE IF LMIN < 0 THEN
                                     GEN2(23(*INC*),GETTYPE(GATTR.TYPTR),-LMIN)
#                                 (*OR SIMPLY GEN1(31,LMIN)*)
                                END
                            END
                          ELSE ERROR(139);
                          WITH GATTR DO
                            BEGIN TYPTR := AELTYPE; KIND := VARBL;
                              ACCESS := INDRCT; IDPLMT := 0 ;
                              IF GATTR.TYPTR <> NIL THEN
#                               BEGIN  LMIN := TYPTR@.SIZE ;
#                               ALIGN(LMIN,TYPTR@.ALN) ;
#                               GEN1(36(*IXA*),LMIN)
#                               END (*TYPTR <> NIL*) ;
                            END (*WITH GATTR DO*) ;
                        END
                  UNTIL SY <> COMMA;
                  IF SY = RBRACK THEN INSYMBOL ELSE
"&&"                BEGIN  IF SY = RPARENT THEN
"&&"                  BEGIN  ERRKIND := 'W';  INSYMBOL  END;
"&&"                  ERROR(12)
"&&"                END;
                END (*IF SY = LBRACK*)
              ELSE
        (*.*)     IF SY = PERIOD THEN
                  BEGIN
                    WITH GATTR DO
                      BEGIN
                        IF TYPTR <> NIL THEN
                          IF TYPTR@.FORM <> RECORDS THEN
                            BEGIN ERROR(140); TYPTR := NIL END;
                        INSYMBOL;
                        IF SY = IDENT THEN
                          BEGIN
                            IF TYPTR <> NIL THEN
"&&"                          BEGIN SEARCHSECTION(TYPTR,LCP);
                                IF LCP = NIL THEN
                                  BEGIN ERROR(152); TYPTR := NIL END
                                ELSE
                                  WITH LCP@ DO
                                    BEGIN TYPTR := IDTYPE;
                                      CASE ACCESS OF
                                        DRCT:   DPLMT := DPLMT + FLDADDR;
                                        INDRCT: IDPLMT := IDPLMT + FLDADDR;
"**"                                    INXD, STKEXPR:   ERROR(400)
                                      END
                                    END
                              END;
                            INSYMBOL
                          END (*SY = IDENT*)
                        ELSE ERROR(2)
                      END (*WITH GATTR*)
                  END (*IF SY = PERIOD*)
                ELSE
        (*@*)       BEGIN
                    IF GATTR.TYPTR <> NIL THEN
                      WITH GATTR,TYPTR@ DO
                        IF FORM = POINTER THEN
#                         BEGIN
#                         LOAD ;
#                         IF DEBUG THEN  CHKBNDS(GATTR.TYPTR) ;
#                         TYPTR := ELTYPE ;
                            WITH GATTR DO
                              BEGIN KIND := VARBL; ACCESS := INDRCT;
                                IDPLMT := 0
                              END
                          END
                        ELSE
"@@"                      IF FORM = FILES THEN
"@@"                        BEGIN
"@@"                          TYPTR := FILTYPE;
"@@"                          CASE ACCESS OF
"@@"                            DRCT:   DPLMT := DPLMT + FILHDRSIZE;
"@@"                            INDRCT: IDPLMT := IDPLMT + FILHDRSIZE;
"**"                            INXD, STKEXPR:   ERROR(400)
"@@"                          END
"@@"                        END
                          ELSE ERROR(141);
                    INSYMBOL
                  END;
              IF NOT (SY IN FSYS + SELECTSYS) THEN
                BEGIN ERROR(6); SKIP(FSYS + SELECTSYS) END ;
#             GATTR.BTYPE := GATTR.TYPTR ;
"&&"          IF GATTR.TYPTR <> NIL THEN
"&&"            IF GATTR.TYPTR@.FORM = SUBRANGE THEN
"&&"              GATTR.TYPTR := GATTR.TYPTR@.RANGETYPE;
            END (*WHILE*) ;
        END (*SELECTOR*) ;

        PROCEDURE CALL(FSYS: SETOFSYS; FCP: CTP);
"&&"      VAR LKEY: 0..NSPROC;  MATCHPAR: BOOLEAN;  RWFILE: STP;

          PROCEDURE VARIABLE(FSYS: SETOFSYS);
            VAR LCP: CTP;
          BEGIN
            IF SY = IDENT THEN
              BEGIN SEARCHID([VARS,FIELD],LCP); INSYMBOL END
            ELSE BEGIN ERROR(2); LCP := UVARPTR END;
            SELECTOR(FSYS,LCP)
          END (*VARIABLE*) ;


"@@"    PROCEDURE  RWSETUP(DFILE: CTP) ;
#       (* TO SET UP FILE ADDRESS PARAMETER FOR READ/WRITE *)
#
#         VAR  LCP : CTP ;  SAVED : BOOLEAN ; TEMPID : ALPHA ; TEMPSY : SYMBOL ;
#
"&&"      BEGIN  SAVED := TRUE;  RWFILE := NIL;
#
"&&"      IF MATCHPAR THEN  (* OTHERWISE THERE ARE NO PARAMETERS *)
#           IF SY = IDENT THEN
"&&"          BEGIN  SEARCHID([VARS,FIELD,FUNC,KONST,STRUCTKONST],LCP) ;
#             IF LCP@.IDTYPE <> NIL THEN
#               WITH LCP@.IDTYPE@ DO
#                 IF FORM = FILES THEN
"@@"                SAVED := FALSE;
#             END (* SY = IDENT *) ;
#
#         IF SAVED THEN (* USE IMPLIED FILE NAME *)
"@@"        BEGIN   TEMPSY := SY ;  TEMPID := ID ;  SY := COMMA ;
"@@"                LCP := DFILE;
#           END (* IF SAVED *)
#         ELSE  INSYMBOL ;
#
#         SELECTOR(FSYS+[COMMA,RPARENT],LCP) ;
"@@"      WITH GATTR DO
"@@"        IF NOT COMPTYPES( TYPTR, TEXTPTR ) THEN
"@@"          IF TYPTR <> NIL THEN
"@@"            IF TYPTR@.FORM <> FILES THEN ERROR(116)
"&&"            ELSE  BEGIN
"&&"              RWFILE := TYPTR@.FILTYPE;
"&&"              IF NOT (LKEY IN [1..6,25,36,37]) THEN ERROR(116);
"@@"              (* NON-TEXT FILES PERMITTED ONLY FOR:  GET, PUT, RESET,
"&&"                 READ, WRITE, REWRITE, EOF, SKIP, LINELIMIT               *)
"&&"               END;
#         LOADADDRESS ; (* GET FILE ADR *)
#         GEN1(30(*CSP*),31(*SIO*)) ;
#         IF SAVED THEN  BEGIN  ID := TEMPID ;  SY := TEMPSY  END ;
#         END (*RWSETUP*) ;
#

          PROCEDURE GETPUTRESETREWRITE;
          BEGIN
"@@"      IF ODD(LKEY) THEN RWSETUP( INPUTPTR )    (* GET, RESET *)
"@@"      ELSE              RWSETUP( OUTPUTPTR );  (* PUT, REWRITE, PAGE *)
#         GEN1(30(*CSP*),LKEY(*GET,PUT,RES,REW,PAG*)) ;
#         GEN1(30(*CSP*),32(*EIO*)) ;
          END (*GETPUTRESETREWRITE*) ;

          PROCEDURE READ1;
"&&"      VAR  CSPNO: 0..NSPROC;  TEST: BOOLEAN;
#         BEGIN (*ASSUME 'INPUT' FILE*)
"@@"        RWSETUP( INPUTPTR );
"&&"        IF RWFILE <> NIL THEN IF LKEY = 11 THEN ERROR(116);
"&&"        IF MATCHPAR THEN  (* OTHERWISE THERE ARE NO PARAMETERS *)
"&&"        BEGIN
              IF SY = COMMA THEN  INSYMBOL ;
#           IF LKEY = 5 (*READ*) THEN  IF SY <> IDENT THEN ERROR(2) ;
"&&"        TEST := FALSE;
            IF SY = IDENT THEN
              REPEAT
                VARIABLE(FSYS + [COMMA,RPARENT]) ;
                LOADADDRESS ;
                IF GATTR.TYPTR <> NIL THEN
"&&"              IF RWFILE = NIL THEN
#                   IF STRING(GATTR.TYPTR) THEN
#                     BEGIN
#                     GEN2(51(*LDC*),1,GATTR.TYPTR@.SIZE DIV CHARSIZE) ;
#                     CSPNO := 27 (*RDS*)
#                     END
#                   ELSE
#                     BEGIN
"&&"                  IF GATTR.TYPTR = INTPTR THEN
"&&"                    IF GATTR.BTYPE@.SIZE = INTSIZE THEN CSPNO := 24(*RDI*)
"&&"                    ELSE IF GATTR.BTYPE@.SIZE=HINTSIZE THEN CSPNO:=15(*RDH*)
"&&"                    ELSE CSPNO := 16 (*RDY - ONE BYTE INTEGER READ*)
                      ELSE
"&&"                    IF GATTR.TYPTR = REALPTR THEN CSPNO := 14 (*RDR*)
                        ELSE IF GATTR.TYPTR=CHARPTR THEN CSPNO := 5(*RDC*)
#                       ELSE IF GATTR.TYPTR=BOOLPTR THEN CSPNO:=12(*RDB*)
#                       ELSE BEGIN  ERROR(116); CSPNO := 24  END;
#                     END
"&&"              ELSE  (* NON-TEXT FILE INPUT *)
"&&"                BEGIN
"&&"                  IF NOT COMPTYPES( GATTR.TYPTR, RWFILE) THEN ERROR(153);
"&&"                  GEN2(51(*LDC*),1,GATTR.BTYPE@.SIZE);
"&&"                  CSPNO := 19 (*RDD*) ;
"&&"                  EXTUSED := TRUE;
"&&"                END;
"&&"            GEN1( 30 (*CSP*), CSPNO );
                IF SY = COMMA THEN INSYMBOL ELSE TEST := TRUE;
              UNTIL TEST ;
"&&"        END (*IF MATCHPAR*);
            IF LKEY = 11 THEN
                GEN1(30(*CSP*),23(*RLN*));
            GEN1(30(*CSP*),32(*EIO*)) ;
          END (*READ*) ;

          PROCEDURE WRITE1;
            VAR LSP: STP; DEFAULT, DEFAULT1, TEST: BOOLEAN;
"&&"            CSPNO, LLKEY: 0..NSPROC;  LEN: ADDRRANGE;
#         BEGIN LLKEY := LKEY;  TEST := FALSE ;
"@@"        RWSETUP( OUTPUTPTR );
"&&"        IF RWFILE <> NIL THEN IF LLKEY = 12 THEN ERROR(116);
"&&"        IF MATCHPAR THEN  (* OTHERWISE NO PARAMETERS *)
"&&"        BEGIN
#             IF SY = RPARENT THEN
#               IF LLKEY = 6 THEN ERROR(116) ;
#             IF SY = COMMA THEN
#             BEGIN INSYMBOL; IF NOT (SY IN SIMPTYPEBEGSYS) THEN ERROR(6)  END ;
#             IF SY IN SIMPTYPEBEGSYS THEN
#             REPEAT  EXPRESSION(FSYS+[COMMA,COLON,RPARENT]) ;
                LSP := GATTR.TYPTR;
                IF LSP <> NIL THEN
                  IF LSP@.FORM <= SUBRANGE THEN LOAD ELSE LOADADDRESS;
"&&"              IF RWFILE = NIL THEN
"&&"              BEGIN
                  DEFAULT := TRUE ;  DEFAULT1 := TRUE ;
                  IF SY = COLON THEN
                    BEGIN INSYMBOL; EXPRESSION(FSYS + [COMMA,COLON,RPARENT]);
"&&"                  LOAD;
                      IF GATTR.TYPTR <> NIL THEN
                        IF GATTR.TYPTR <> INTPTR THEN ERROR(116);
                      DEFAULT := FALSE ;
                      IF SY = COLON THEN
                        BEGIN  INSYMBOL;  EXPRESSION(FSYS + [COMMA,RPARENT]);
"&&"                      LOAD;
                          IF GATTR.TYPTR <> NIL THEN
                            IF GATTR.TYPTR <> INTPTR THEN ERROR(116);
                          IF LSP <> REALPTR THEN ERROR(124);
"&&"                      DEFAULT1 := FALSE ;
                        END ;
                    END ;
                  IF LSP = INTPTR THEN
                    BEGIN IF DEFAULT THEN GEN2(51(*LDC*),1,12);
"&&"                  CSPNO := 6 (*WRI*)
                    END
                  ELSE
                    IF LSP = REALPTR THEN
                      BEGIN IF DEFAULT THEN GEN2(51(*LDC*),1,14);
                        IF DEFAULT1 THEN GEN2(51(*LDC*),1,0);
"&&"                    CSPNO := 8 (*WRR*)
                      END
                    ELSE
                      IF LSP = CHARPTR THEN
                        BEGIN IF DEFAULT THEN GEN2(51(*LDC*),1,1);
"&&"                      CSPNO := 9 (*WRC*)
                        END
                      ELSE
#                     IF LSP = BOOLPTR THEN
#                       BEGIN IF DEFAULT THEN GEN2(51(*LDC*),1,5);
"&&"                      CSPNO := 13 (*WRB*)
#                       END
#                     ELSE
                        IF LSP <> NIL THEN
                          BEGIN
                            IF LSP@.FORM = SCALAR THEN ERROR(398)
                            ELSE
                              IF STRING(LSP) THEN
                                BEGIN LEN := LSP@.SIZE DIV CHARSIZE;
                                  IF DEFAULT THEN
                                        GEN2(51(*LDC*),1,LEN);
                                  GEN2(51(*LDC*),1,LEN);
"&&"                              CSPNO := 10 (*WRS*)
                                END
"&&"                        ELSE BEGIN  ERROR(116); CSPNO := 6  END
                          END
"&&"            END
"&&"            ELSE  (* NON-TEXT FILE *)
"&&"            BEGIN
"&&"              IF NOT COMPTYPES( LSP, RWFILE) THEN ERROR(145);
"&&"              GEN2(51(*LDC*),1,RWFILE@.SIZE);
"&&"              EXTUSED := TRUE;
"&&"              IF LSP <> NIL THEN
"&&"                IF LSP@.FORM <= SUBRANGE THEN  CSPNO := 7 (*WRE*)
"&&"                ELSE                           CSPNO := 20 (*WRD*)
"&&"            END;
"&&"            GEN1( 30 (*CSP*), CSPNO );
                IF SY = COMMA THEN INSYMBOL ELSE TEST := TRUE;
#             UNTIL TEST;
"&&"        END (*IF MATCHPAR*) ;
#
            IF LLKEY = 12 THEN (*WRITELN*)
                GEN1(30(*CSP*),22(*WLN*));
#           GEN1(30(*CSP*),32(*EIO*)) ;
          END (*WRITE*) ;
"NH"
"NH"      PROCEDURE SKIPLIM;
"NH"      BEGIN
"@@"        RWSETUP( OUTPUTPTR );
"NH"        IF SY = COMMA THEN
"NH"          BEGIN INSYMBOL;
"NH"            IF NOT (SY IN SIMPTYPEBEGSYS) THEN ERROR(6)
"NH"          END;
"NH"        IF SY IN SIMPTYPEBEGSYS THEN
"NH"          BEGIN
"NH"            EXPRESSION( FSYS + [RPARENT] );  LOAD;
"NH"            IF GATTR.TYPTR <> NIL THEN
"NH"               IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
"NH"            GEN1( 30 (*CSP*), LKEY-2 (*SKP/LIM *) );
"@@"            GEN1( 30 (*CSP*), 32 (*EIO*) );
"NH"          END
"NH"      END;
"NH"
"NH"      PROCEDURE MESSAGE1;
"NH"      VAR LEN : INTEGER ;
"NH"      BEGIN
"NH"        EXPRESSION( FSYS + [RPARENT] );
"NH"        IF GATTR.TYPTR <> NIL THEN
"NH"           IF STRING(GATTR.TYPTR) THEN
"NH"              LEN := GATTR.TYPTR@.SIZE DIV CHARSIZE
"NH"           ELSE ERROR(125);
"NH"        LOADADDRESS;
"NH"        GEN2( 51 (*LDC*), 1, LEN );
"NH"        GEN1( 30 (*CSP*), 33 (*MSG*) );
"NH"      END;

          PROCEDURE PACK1;
            VAR  LSP,LSP1: STP;   LSIZE, IMIN, IMAX: INTEGER;
"&&"             LCNT, RCNT, LELEMSIZE, RELEMSIZE: INTEGER;
          BEGIN
#           EXPRESSION(FSYS + [COMMA, RPARENT]);
            LSP := NIL; LSP1 := NIL;
            IF GATTR.TYPTR <> NIL THEN
              WITH GATTR, GATTR.TYPTR@ DO
                IF FORM = ARRAYS THEN
                  BEGIN   LSP := INXTYPE;  LSP1 := AELTYPE;
"&&"              IMIN := 1;  LSIZE := SIZE;  IMAX := LSIZE;
#                 IF LSP <> NIL THEN  GETBOUNDS(LSP, IMIN, IMAX);
"&&"              LCNT := IMAX - IMIN + 1;
"&&"              LELEMSIZE := LSIZE DIV LCNT;
#                 LOADADDRESS;
#                 END
                ELSE ERROR(116);
            IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
            EXPRESSION(FSYS + [COMMA,RPARENT]);
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM <> SCALAR THEN ERROR(116)
              ELSE
                IF NOT COMPTYPES(LSP,GATTR.TYPTR) THEN ERROR(116)
#               ELSE
#                 BEGIN
#                 LOAD;
#                 IF DEBUG THEN GEN3(45(*CHK*),ORD('J'),IMIN,IMAX) ;
#                 IF IMIN > 0 THEN
#                    GEN2(22(*DEC*),GETTYPE(GATTR.TYPTR),IMIN)
#                 ELSE IF IMIN < 0 THEN
#                    GEN2(23(*INC*),GETTYPE(GATTR.TYPTR),-IMIN);
"&&"              GEN1( 36 (*IXA*), LELEMSIZE );
#                 END;
            IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
            VARIABLE(FSYS + [RPARENT]);
            IF GATTR.TYPTR <> NIL THEN
              WITH GATTR.TYPTR@ DO
                IF FORM = ARRAYS THEN
                  BEGIN
                    IF NOT COMPTYPES(AELTYPE,LSP1)
                      OR NOT COMPTYPES(INXTYPE,LSP) THEN  ERROR(116)
#                   ELSE
#                     BEGIN
#                     LOADADDRESS;
"&&"                  LSP := INXTYPE;  LSP1 := AELTYPE;
"&&"                  IF LSP <> NIL THEN GETBOUNDS( LSP, IMIN, IMAX )
"&&"                  ELSE BEGIN  IMIN := 1;  IMAX := SIZE  END;
"&&"                  RCNT := IMAX - IMIN + 1;
"&&"                  RELEMSIZE := SIZE DIV RCNT;
"&&"                  IF RCNT > LCNT THEN ERROR(303);
"&&"                  IF LELEMSIZE = RELEMSIZE THEN  (* A MOVE WORKS OK *)
"&&"                    GEN1( 40(*MOV*), -SIZE )
"&&"                  ELSE
"&&"                    GEN3( 76(*PAK*), RCNT, LELEMSIZE, RELEMSIZE );
#                     END;
                  END
                ELSE ERROR(116)
          END (*PACK*) ;

          PROCEDURE UNPACK1;
#           VAR  LSP,LSP1: STP;   IMIN, IMAX, LSIZE: INTEGER;
"&&"              LCNT, RCNT, LELEMSIZE, RELEMSIZE: INTEGER;
          BEGIN
#           EXPRESSION(FSYS + [COMMA, RPARENT]);
            LSP := NIL; LSP1 := NIL;
            IF GATTR.TYPTR <> NIL THEN
              WITH GATTR.TYPTR@ DO
                IF FORM = ARRAYS THEN
                  BEGIN LSP := INXTYPE; LSP1 := AELTYPE;
#                 IMIN := 1;  LSIZE := SIZE;  IMAX := LSIZE;
"&&"              IF LSP <> NIL THEN GETBOUNDS( LSP, IMIN, IMAX );
"&&"              LCNT := IMAX - IMIN + 1;
"&&"              LELEMSIZE := LSIZE DIV LCNT;
#                 LOADADDRESS;
                  END
                ELSE ERROR(116);
            IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
            VARIABLE(FSYS + [COMMA,RPARENT]);
            IF GATTR.TYPTR <> NIL THEN
              WITH GATTR, GATTR.TYPTR@ DO
                IF FORM = ARRAYS THEN
                  BEGIN
                    IF NOT COMPTYPES(AELTYPE,LSP1)
                      OR NOT COMPTYPES(INXTYPE,LSP) THEN  ERROR(116)
                    ELSE
#                     BEGIN
#                     IF INXTYPE <> NIL THEN GETBOUNDS(INXTYPE, IMIN,IMAX)
"&&"                  ELSE BEGIN  IMIN := 1;  IMAX := SIZE  END;
"&&"                  RCNT := IMAX - IMIN + 1;
"&&"                  RELEMSIZE := SIZE DIV RCNT;
"&&"                  IF LCNT > RCNT THEN ERROR(303);
#                     LOADADDRESS;
#                     END;
                  END
                ELSE ERROR(116);
            IF SY = COMMA THEN INSYMBOL ELSE ERROR(20);
            EXPRESSION(FSYS + [RPARENT]);
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM <> SCALAR THEN ERROR(116)
              ELSE
                IF NOT COMPTYPES(LSP,GATTR.TYPTR) THEN ERROR(116)
#               ELSE
#                 BEGIN
#                 LOAD;
#                 IF DEBUG THEN GEN3(45(*CHK*),ORD('J'),IMIN,IMAX) ;
#                 IF IMIN > 0 THEN
#                    GEN2(22(*DEC*),GETTYPE(GATTR.TYPTR),IMIN)
#                  ELSE IF IMIN < 0 THEN
#                    GEN2(23(*INC*),GETTYPE(GATTR.TYPTR),-IMIN);
"&&"               GEN1( 36(*IXA*), RELEMSIZE );
"&&"               IF LELEMSIZE = RELEMSIZE THEN  (* A MOVE IS OK *)
"&&"                 GEN1( 40(*MOV*), -LSIZE )
"&&"               ELSE
"&&"                 GEN3( 76(*PAK*), LCNT, LELEMSIZE, RELEMSIZE );
#                 END;
          END (*UNPACK*) ;

          PROCEDURE NEW1;
            LABEL 1;
            VAR LSP,LSP1: STP; VARTS,LMIN,LMAX: INTEGER;
                LSIZE,LSZ: ADDRRANGE; LVAL: VALU;
"&&"            LALN: ALNRNG;
          BEGIN VARIABLE(FSYS + [COMMA,RPARENT]); LOADADDRESS;
"&&"        LSP := NIL; VARTS := 0; LSIZE := 0;  LALN := INTSIZE;
            IF GATTR.TYPTR <> NIL THEN
              WITH GATTR.TYPTR@ DO
                IF FORM = POINTER THEN
                  BEGIN
                    IF ELTYPE <> NIL THEN
                      BEGIN LSIZE := ELTYPE@.SIZE;
"&&"                    IF ELTYPE@.ALN > INTSIZE THEN
"&&"                      LALN := REALSIZE;
                        IF ELTYPE@.FORM = RECORDS THEN LSP := ELTYPE@.RECVAR
                      END
                  END
                ELSE ERROR(116);
            WHILE SY = COMMA DO
              BEGIN INSYMBOL;CONSTANT(FSYS + [COMMA,RPARENT],LSP1,LVAL);
                VARTS := VARTS + 1;
                (*CHECK TO INSERT HERE: IS CONSTANT IN TAGFIELDTYPE RANGE*)
                IF LSP = NIL THEN ERROR(158)
                ELSE
                  IF LSP@.FORM <> TAGFLD THEN ERROR(162)
                  ELSE
                    IF LSP@.TAGFIELDP <> NIL THEN
                      IF STRING(LSP1) OR (LSP1 = REALPTR) THEN ERROR(159)
                      ELSE
                        IF COMPTYPES(LSP@.TAGFIELDP@.IDTYPE,LSP1) THEN
                          BEGIN
                            LSP1 := LSP@.FSTVAR;
                            WHILE LSP1 <> NIL DO
                              WITH LSP1@ DO
                                IF VARVAL.IVAL = LVAL.IVAL THEN
                                  BEGIN LSIZE := SIZE; LSP := SUBVAR;
                                    GOTO 1
                                  END
                                ELSE LSP1 := NXTVAR;
                            LSIZE := LSP@.SIZE; LSP := NIL;
                          END
                        ELSE ERROR(116);
          1:  END (*WHILE*) ;
"&&"        ALIGN(LSIZE,INTSIZE);
"&&"        GEN2(58(*NEW*),LSIZE,LALN);
          END (*NEW*) ;

"&&"      PROCEDURE MARKRELEASE;
          BEGIN VARIABLE(FSYS+[RPARENT]);
             IF GATTR.TYPTR <> NIL THEN
               IF GATTR.TYPTR@.FORM = POINTER THEN
"&&"             IF LKEY = 13 (*MARK*) THEN
                   BEGIN LOADADDRESS; GEN0(59(*SAV*)) END
"&&"             ELSE (* LKEY = 10, RELEASE *)
"&&"               BEGIN LOAD; GEN0(60(*RST*)) END
               ELSE ERROR(125)
          END(*MARKRELEASE*);

#         PROCEDURE TRAPEXIT ;
#
#         (*THIS PROCEDURE IS TO SIMPLIFY COMMUNICATION WITH THE OUTSIDE WORLD*)
#         (* AND PROVIDE BREAK POINTS IN THE PASCAL PROGRAM.                  *)
#         (* 'TRAP(I, R)'  RETURNS THE INTEGER CONSTANT I AS WELL AS A POINTER*)
#         (* TO THE SECOND PARAMETER 'R' (I.E. ADDRESS OF R) TO THE OPERATING *)
#         (* SYSTEM. THE FIRST PARAMETER IS INTENDED TO BE USED AS A          *)
#         (* 'FUNCTION NUMBER' AND THE SECOND ONE AS THE 'VAR' TYPE ARGUMENT  *)
#         (* WHICH MAY BE INSPECTED AND MODIFIED, TO THAT FUNCTION            *)
#
"**"         VAR  LLC: ADDRRANGE;
"**"        BEGIN  LLC := LC;  (* IN CASE OF SET TYPE ARGUMENT *)
#           IF GATTR.TYPTR <> INTPTR THEN  ERROR(116) ;
#           IF LKEY = 14 THEN (*TRAP*)
#             BEGIN
#             IF SY <> COMMA THEN  ERROR(6)
#             ELSE
#               BEGIN  INSYMBOL ;
#               EXPRESSION(FSYS+[RPARENT]) ;
#               WITH GATTR DO
#                 IF TYPTR <> NIL THEN
#                   BEGIN
#                   IF KIND <> VARBL THEN
"**"                  IF TYPTR@.FORM < POWER THEN
#                       BEGIN  LOAD ;
#                       KIND := VARBL ;  ACCESS := DRCT ;  VLEVEL := LEVEL ;
#                       ALIGN(LC,MXDATASZE) ;  DPLMT := LC ;  BTYPE := TYPTR ;
#                       STORE(GATTR) ;
#                       END ;
#                   LOADADDRESS ;
#                   END ;
#               END (*WITH*) ;
#             END ;
#           GEN1(30(*CSP*),LKEY+14 (*TRP*) (*XIT*)) ;
"**"        LC := LLC;
#           END (* TRAPEXIT *) ;

#         PROCEDURE SQRABS;
#         VAR OP : OPRANGE ;
#         BEGIN   OP := 0 (*ABI*) ;
#           IF LKEY = 17 THEN  OP := 24 (*SQI*) ;
#           IF GATTR.TYPTR <> NIL THEN
#             IF GATTR.TYPTR = INTPTR THEN GEN0(OP(*ABI*)(*SQI*))
#             ELSE
#               IF GATTR.TYPTR = REALPTR THEN GEN0(OP+1(*ABR*)(*ABR*))
#               ELSE BEGIN ERROR(125); GATTR.TYPTR := INTPTR END
#         END (*SQRABS*) ;

          PROCEDURE TRUNCROUND;
          BEGIN
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR <> REALPTR THEN ERROR(125);
            GEN0(LKEY-18+27(*TRC*)(*RND*));
            GATTR.TYPTR := INTPTR
          END (*TRUNCROUND*) ;
"NH"
"NH"      PROCEDURE EXPO1;
"NH"      BEGIN
"NH"        IF GATTR.TYPTR <> NIL THEN
"NH"           IF GATTR.TYPTR = INTPTR THEN
"NH"              GEN0( 10 (*FLT*) )
"NH"           ELSE IF GATTR.TYPTR <> REALPTR THEN ERROR(125);
"NH"        GEN0( 66 (*XPO*) );  GATTR.TYPTR := INTPTR;
"NH"      END (*EXPO*);
"NH"
"NH"      PROCEDURE CARD1;
"**"      VAR  LLC, LEN: ADDRRANGE;
"NH"      BEGIN
"**"        LLC := LC;  EXPRESSION( FSYS + [RPARENT] );
"**"        IF GATTR.TYPTR <> NIL THEN
"**"          IF GATTR.TYPTR@.FORM = POWER THEN
"**"            BEGIN
"**"              FORCETEMPSET;  GEN0( 65 (*CRD*) );
"**"            END
"**"          ELSE ERROR( 125 );
"**"        LC := LLC;
"**"        GATTR.TYPTR := INTPTR;
"@@"      END  (*CARD*) ;

          PROCEDURE ODD1;
          BEGIN
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
            GEN0(20(*ODD*));
            GATTR.TYPTR := BOOLPTR
          END (*ODD*) ;

          PROCEDURE ORD1;
          BEGIN
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM >= POWER THEN ERROR(125);
#           GEN0(61(*ORD*)) ;
            GATTR.TYPTR := INTPTR
          END (*ORD1*) ;

          PROCEDURE CHR1;
          BEGIN
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR <> INTPTR THEN ERROR(125);
#           GEN0(62(*CHR*)) ;
            GATTR.TYPTR := CHARPTR
          END (*CHR*) ;

          PROCEDURE PREDSUCCTIM;
#         BEGIN  (*TRANSLATES INTO 'DEC' AND 'INC'*)
#           IF GATTR.TYPTR <> NIL THEN
"&&"           IF (LKEY = 24) OR (LKEY = 30) THEN
#                 BEGIN  IF GATTR.TYPTR <> INTPTR THEN  ERROR(116) ;
"&&"              IF LKEY=24 THEN GEN1(30(*CSP*),21(*CLK*))
"&&"              ELSE (*30*)     GEN1(30(*CSP*),36(*TRA*));
#                 END
#              ELSE
#               IF (GATTR.TYPTR = REALPTR) OR (GATTR.TYPTR@.FORM <> SCALAR) THEN
#                  ERROR(125)
#               ELSE  GEN2(LKEY(*DEC,INC*),GETTYPE(GATTR.TYPTR),1) ;
                (* LKEY HAPPENS TO BE THE OPCODE AS WELL *)
#         END (*PREDSUCCTIM*) ;

          PROCEDURE EOFEOLN;
          BEGIN
"@@"        RWSETUP( INPUTPTR );
            IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM <> FILES THEN ERROR(125);
"&&"        IF LKEY >= 28 THEN
"&&"          BEGIN  EXTUSED := TRUE;
"&&"            GEN1(30(*CSP*), LKEY-11(*EOL/EOT*) );
"&&"          END
"&&"        ELSE GEN1(30(*CSP*), LKEY(*EOF/ELN*)) ;
#           GEN1(30(*CSP*),32(*EIO*)) ;
            GATTR.TYPTR := BOOLPTR
          END (*EOF*) ;

          PROCEDURE CALLNONSTANDARD;
"&&"        LABEL 10;
"&&"        VAR NXT,LCP,LCP2: CTP;  LSP: STP;  LB: BOOLEAN;
"&&"            LOCPAR, LLC, LSIZE, LLC1, LLC2, LLC3, LLC4, LLC5: ADDRRANGE;
"@@"            I: INTEGER;  PROCNAME: ALPHA;

"SH"        FUNCTION COMPTLIST( CP1, CP2: CTP): BOOLEAN;
"SH"        (* MATCH PARAMETER LISTS CP1 AND CP2 *)
"SH"        VAR X: BOOLEAN;
"SH"        BEGIN
"SH"          WHILE (CP1 <> NIL) AND (CP2 <> NIL) DO
"SH"            BEGIN
"SH"            IF CP1@.KLASS IN [PROC,FUNC] THEN
"SH"              (* I.E. PROC PARAMETER *)
"SH"              IF (CP1@.KLASS = CP2@.KLASS) AND
"SH"                 (CP1@.IDTYPE = CP2@.IDTYPE) AND
"SH"                 (CP1@.PFDECKIND = CP2@.PFDECKIND) THEN
"SH"                X := COMPTLIST( CP1@.PRMPTR, CP2@.PRMPTR) AND
"SH"                     (CP1@.VKIND = CP2@.VKIND)
"SH"              ELSE
"SH"                X := FALSE
"SH"            ELSE
"SH"              X := COMPTYPES( CP1@.IDTYPE, CP2@.IDTYPE );
"SH"            IF X THEN
"SH"              BEGIN  CP1 := CP1@.NEXT;  CP2 := CP2@.NEXT  END
"SH"            ELSE
"SH"              CP1 := NIL;
"SH"          END  (* WHILE *);
"SH"        COMPTLIST := CP1 <> CP2;
"SH"      END  (*COMPTLIST*);

          BEGIN (*CALLNONSTANDARD*)  LOCPAR := 0;
"**"        LLC1 := LC;  ALIGN(LLC1,MXDATASZE);
            WITH FCP@ DO
"SH"          BEGIN NXT := PRMPTR;
"&&"            IF PFLEV > LCAFTMST THEN (* PROC. PARAMETER *)
"&&"              BEGIN  LLC5 := LLC1;
"&&"                     LLC1 := LLC1 + DISPAREA
"&&"              END
"&&"            ELSE LLC5 := 0;
"&&"            GEN2( 41(*MST*), PFLEV, LLC5 );
#               IF PFLEV = LEVEL THEN   LOCAL_CALL := TRUE ;
              END;
            IF SY = LPARENT THEN
"&&"          BEGIN  LSIZE := 0;  LLC := LLC1;  LLC2 := LLC1;
"**"            IF FCP@.FRTRN THEN
"**"              BEGIN  (* RESERVE STORAGE FOR COPIES OF PARMS *)
"**"                LCP := NXT;
"**"                WHILE LCP <> NIL DO
"**"                  BEGIN
"**"                    LSP := LCP@.IDTYPE;
"**"                    IF LSP<> NIL THEN
"**"                       IF LSP@.FORM <= POWER THEN
"**"                         BEGIN  ALIGN(LLC1,LSP@.ALN);
"**"                              LLC1 := LLC1 + LSP@.SIZE
"**"                         END;
"**"                     LCP := LCP@.NEXT
"**"                  END;
"&&"                ALIGN(LLC1,MXDATASZE);
"**"              END;
"**"            LLC3 := LLC1;
                REPEAT LB := FALSE; (*DECIDE WHETHER PROC/FUNC MUST BE PASSED*)
                  IF NXT = NIL THEN ERROR(126)
                  ELSE LB := NXT@.KLASS IN [PROC,FUNC];
                  (*FOR FORMAL PROC/FUNC LB IS FALSE AND EXPRESSION
                   WILL BE CALLED, WHICH WILL ALLWAYS INTERPRET A PROC/FUNC ID
                  AT ITS BEGINNING AS A CALL RATHER THAN A PARAMETER PASSING.
                  IN THIS IMPLEMENTATION, PARAMETER PROCEDURES/FUNCTIONS
                  ARE THEREFORE NOT ALLOWED TO HAVE PROCEDURE/FUNCTION
                  PARAMETERS*)
                  INSYMBOL;
                  IF LB THEN   (*PASS FUNCTION OR PROCEDURE*)
"SH"                BEGIN
                      IF SY <> IDENT THEN
                        BEGIN ERROR(2); SKIP(FSYS + [COMMA,RPARENT]) END
                      ELSE
                        BEGIN
"&&"                      SEARCHID( [NXT@.KLASS], LCP );
"SH"                      IF COMPTLIST( LCP, NXT ) THEN
"SH"                        BEGIN
"SH"                          LOCAL_CALL := TRUE;  (* => UPDATES DISP REGS *)
"SH"                          LLC4 := LLC1 + NXT@.PFLEV DIV 10;
"SH"                          (* PFLEV = ADDR OF PROC IN NEW ACTIV RECORD *)
"SH"                          LSIZE := DISPAREA;
"SH"                          IF LCP@.PFKIND = ACTUAL THEN
"SH"                            WITH LCP@ DO
"&&"                            BEGIN
"&&"                              IF FRTRN THEN
"&&"                                BEGIN  (* REMEMBER THIS PROC FOR LATER *)
"&&"                                  LCP2 := FRTPARHD;
"&&"                                  WHILE LCP2 <> NIL DO
"&&"                                    IF LCP2@.EXTNAME = EXTNAME THEN
"&&"                                      GOTO 10  (* ALREADY ON LIST *)
"&&"                                    ELSE LCP2 := LCP2@.NXTFWRD;
"&&"                                  NEW(LCP2,PROC,DECLARED);  LCP2@ := LCP@;
"&&"                                  WITH LCP2@ DO
"&&"                                    BEGIN  NAME := '            ';
"&&"                                      UNPACK(EXTNAME,NAME,1);
"&&"                                      PROCLAB := PROCLAB + 1;
"&&"                                      PFNAME := PROCLAB;
"&&"                                      NXTFWRD := FRTPARHD;
"&&"                                      FRTPARHD := LCP2;
"&&"                                    END;
"&&"                             10:  LCP := LCP2;
"&&"                                END;
"&&"                            UNPACK( EXTNAME, ID, 1 );
"SH"                            GEN1(37(*LCA*), ORD('P'));  (* PASSING PROC *)
"SH"                            GEN3(56(*STR*), ORD('A'), LEVEL, LLC4 );
"SH"                            GEN2(50(*LDA*), LEVEL, LLC4+PTRSIZE );
"SH"                            GEN2(50(*LDA*), 1, DISPADR+PTRSIZE );
"SH"                            GEN1(40(*MOV*), DISPAREA-PTRSIZE );
"SH"                            END
"SH"                          ELSE (* PROC PARM IS ITSELF A PASSED PROC *)
"SH"                            BEGIN
"SH"                            GEN2(50(*LDA*), LEVEL, LLC4 );
"SH"                            (* COPY ENTIRE PROC RECORD INTO PARM LIST *)
"SH"                            GEN2(50(*LDA*), LEVEL, LCP@.PFLEV DIV 10 );
"SH"                            GEN1(40(*MOV*), DISPAREA);
"SH"                            END;
"SH"                        END
"SH"                      ELSE ERROR(128);
                          INSYMBOL;
                          IF NOT (SY IN FSYS + [COMMA,RPARENT]) THEN
                            BEGIN ERROR(6); SKIP(FSYS + [COMMA,RPARENT]) END
                        END
                    END (*IF LB*)
                  ELSE
                    BEGIN
"**"                  IF NXT <> NIL THEN
"**"                    LC := LLC1 + NXT@.VADDR;
"**"                  LLC4 := LC;
                      EXPRESSION(FSYS + [COMMA,RPARENT]);
                      IF GATTR.TYPTR <> NIL THEN
                        BEGIN
                          IF NXT <> NIL THEN
                            BEGIN LSP := NXT@.IDTYPE;
                              IF LSP <> NIL THEN
                                BEGIN
                                  IF (NXT@.VKIND = ACTUAL) THEN
#                                   IF LSP@.FORM < POWER THEN
#                                     BEGIN LOAD;
#                                     IF DEBUG THEN
#                                       BEGIN  ASSIGN := TRUE ;
#                                       CHKBNDS(LSP) ;  ASSIGN := FALSE ;
#                                       END ;
                                      IF COMPTYPES(REALPTR,LSP) THEN
                                        IF (GATTR.TYPTR = INTPTR) THEN
                                        BEGIN GEN0(10(*FLT*));
                                          GATTR.TYPTR := REALPTR ;
                                          GATTR.BTYPE := REALPTR ;
                                        END;
                                      LOCPAR := LOCPAR+ 1 (*LSP@.SIZE*) ;
#                                     IF FCP@.FRTRN THEN
"**"                                  BEGIN
"**"                                    ALIGN(LLC2,LSP@.ALN);
"**"                                    WITH GATTR DO
"**"                                    BEGIN  VLEVEL:=LEVEL; DPLMT:=LLC2;
"&&"                                           BTYPE := LSP;
"**"                                           KIND := VARBL; ACCESS:=DRCT
"**"                                    END;
"**"                                    STORE(GATTR);  LOADADDRESS;
"**"                                    GEN3(56(*STR*),ORD('A'),LEVEL,LLC3);
"**"                                    LLC3 := LLC3 + PTRSIZE;
"**"                                    LLC2 := LLC2 + LSP@.SIZE;
"**"                                  END
"**"                                  ELSE
"**"                                    GEN3(56,GETTYPE(LSP),LEVEL,LLC4);
                                      END
"**"                                ELSE  (* LSP@.FORM >= POWER *)
"**"                                  BEGIN  LOCPAR := LOCPAR + 1;
"**"                                    IF FCP@.FRTRN THEN
"**"                                    BEGIN
"**"                                    IF (LSP@.FORM=POWER) AND
"**"                                       (GATTR.ACCESS=STKEXPR) THEN
"**"                                    BEGIN ALIGN(LLC2,LSP@.ALN);
"**"                                     FORCETEMPSET;
"**"                                     LSIZE:=OPNDSETSIZE(GATTR);
"**"                                     GEN2(50(*LDA*),LEVEL,LLC2);
"**"                                     GEN2(69(*SMV*),-LSP@.SIZE,LSIZE);
"**"                                     GEN2(50(*LDA*),LEVEL,LLC2);
"**"                                     LLC2 := LLC2 + LSP@.SIZE;
"**"                                    END
"**"                                    ELSE LOADADDRESS;
"**"                                      GEN3(56(*STR*),ORD('A'),LEVEL,LLC3);
"**"                                      LLC3 := LLC3 + PTRSIZE;
"**"                                    END
"**"                                    ELSE IF LSP@.FORM = POWER THEN
"**"                                    BEGIN
"**"                                      LSIZE := OPNDSETSIZE(GATTR);
"**"                                      LOADADDRESS;
"**"                                      GEN2(50(*LDA*),LEVEL,LLC4);
"**"                                      GEN2(69(*SMV*),-LSP@.SIZE,LSIZE);
"**"                                    END
"**"                                    ELSE BEGIN
"**"                                      LOADADDRESS;
"**"                                      GEN2(50(*LDA*),LEVEL,LLC4);
"**"                                      GEN1(40(*MOV*),-LSP@.SIZE);
"**"                                    END
                                      END
                                  ELSE  (* VKIND = FORMAL I.E. VAR PARM *)
                                    IF GATTR.KIND = VARBL THEN
                                      BEGIN  LOADADDRESS;
"**"                                  IF NOT FCP@.FRTRN THEN
"**"                                    GEN3(56,ORD('A'),LEVEL,LLC4)
"**"                                  ELSE BEGIN
"**"                                    GEN3(56,ORD('A'),LEVEL,LLC3);
"**"                                    LLC3:=LLC3+PTRSIZE;
"**"                                  END;
"**"                                  IF GATTR.ACCESS = STKEXPR THEN
"**"                                    ERROR(154);
                                      LOCPAR := LOCPAR + 1 (*PTRSIZE*);
                                      IF GATTR.BTYPE@.SIZE <> LSP@.SIZE THEN
                                        ERROR(142) ;
                                      END
                                    ELSE ERROR(154);
"**"                              IF LSP <> NIL THEN LSIZE := LSP@.SIZE;
                                  IF NOT COMPTYPES(LSP,GATTR.TYPTR) THEN
                                    ERROR(142)
                                END
                            END
                        END
                    END;
"SH"              IF (NXT <> NIL) THEN NXT := NXT@.NEXT
                UNTIL SY <> COMMA;
"**"            LC := LLC4 + LSIZE;
"**"            IF LC > LCMAX THEN LCMAX := LC;
                LC := LLC;
              IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
            END (*IF LPARENT*);
#           LOCPAR := LOCPAR*2 ;
            IF NXT <> NIL THEN ERROR(126);
            WITH FCP@ DO
#             BEGIN
"**"            IF SAVEFPRS THEN LOCPAR := LOCPAR+1;  (*ENCODE SAVEFPR FLG*)
"&&"            IF PRCODE THEN
"&&"              BEGIN  PUTIC;  WRITELN(PRR, MN(/46/) (*CUP*),
"&&"                CHR(PROCTYPE(FCP)):2, ',', LOCPAR:1, ',', EXTNAME,
"&&"                ',', LLC1:1 );
"&&"              END;
              END;
"&&"        WITH GATTR DO
"&&"          BEGIN  TYPTR := FCP@.IDTYPE;  BTYPE := TYPTR;
"&&"            IF TYPTR <> NIL THEN
"&&"              IF TYPTR@.FORM = SUBRANGE THEN
"&&"                TYPTR := TYPTR@.RANGETYPE
"&&"          END;
          END (*CALLNONSTANDARD*) ;

        BEGIN (*CALL*)
          IF FCP@.PFDECKIND = STANDARD THEN
            BEGIN
            LKEY := FCP@.KEY;
#           IF SY = LPARENT THEN
#             BEGIN  INSYMBOL ;   MATCHPAR := TRUE ;
#               IF SY = RPARENT THEN
#                 IF NOT (LKEY IN [0,1,2,3,4,11,12,25,26,28,29]) THEN ERROR(7) ;
"&&"               (*GET,PUT,RESET,REWRITE,RDLN,WRITELN,EOL,EOT,EOF,ELN*)
#             END
#           ELSE
"&&"          BEGIN  IF NOT (LKEY IN [0,1,2,3,4,11,12,25,26,28,29]) THEN
"&&"                    ERROR(7);
"&&"                    (*GET,PUT,RESET,REWRITE,RDLN,WRITELN,EOL,EOT,EOF,ELN*)
#               MATCHPAR := FALSE ;
              END;

"&&"        IF LKEY IN [14..24,30,33,39] THEN
"&&"           (*TRAP,EXIT,ABS...,TRACE,ODD,EXPO*)
#             BEGIN
                IF LKEY = 14 (*TRAP*) THEN  EXPRESSION(FSYS+[COMMA])
                ELSE  EXPRESSION(FSYS+[RPARENT]) ;
                LOAD ;
              END  ;
#
#             CASE LKEY OF
#           0,1,2,
#             3,4:    GETPUTRESETREWRITE;
#            5,11:    READ1;
#            6,12:    WRITE1;
#               7:    PACK1;
#               8:    UNPACK1;
#               9:    NEW1;
"&&"        10,13:    MARKRELEASE;
#           14,15:    TRAPEXIT;
#           16,17:    SQRABS;
#           18,19:    TRUNCROUND;
#              20:    ORD1;
#              21:    CHR1;
"&&"  22,23,24,30:    PREDSUCCTIM;
"&&"  25,26,28,29:    EOFEOLN ;
#              33:    ODD1;
"NH"           35:    MESSAGE1;
"NH"        36,37:    SKIPLIM;
"NH"           38:    CARD1;
"NH"           39:    EXPO1;
              END (*CASE LKEY OF*) ;

"&&"        IF LKEY IN [16..26,28,29,33,38,39] THEN
"NH"           GATTR.BTYPE := GATTR.TYPTR;
#           IF MATCHPAR THEN
#             IF SY = RPARENT THEN INSYMBOL ELSE  ERROR(4) ;

            END (*IF FCP@.PFDECKIND = STANDARD*)

          ELSE CALLNONSTANDARD

        END (*CALL*) ;

"**"    PROCEDURE GENSETOP( LATTR: ATTR;  OP: OPRANGE);
"**"      BEGIN
"**"        WITH GATTR DO
"**"          IF (TYPTR<>NIL) AND (LATTR.TYPTR<>NIL) THEN
"**"            IF (TYPTR@.FORM = POWER) AND
"**"               COMPTYPES( TYPTR, LATTR.TYPTR ) THEN
"**"              BEGIN
"**"                FORCETEMPSET;
"**"                GEN0( OP );
"**"                IF OP = 12 THEN IF LATTR.STKLEN < STKLEN THEN
"**"                   STKLEN := LATTR.STKLEN;
"**"                IF OP = 31 THEN IF LATTR.STKLEN > STKLEN THEN
"**"                   STKLEN := LATTR.STKLEN;
"**"                IF OP = 5 THEN STKLEN := LATTR.STKLEN;
"**"                STKDPLMT := LATTR.STKDPLMT;
"**"                LC := STKDPLMT + STKLEN;
"**"                IF LC > LCMAX THEN LCMAX := LC;
"**"              END
"**"            ELSE BEGIN
"&&"                ERROR( 134 );  GATTR.TYPTR := NIL; GATTR.BTYPE := NIL
"**"              END
"**"      END  (* GENSETOP *) ;

        PROCEDURE EXPRESSION;
"&&"      CONST COMPARE_OP: ARRAY(/LTOP..EQOP/) OF 0..OPMAX
"&&"                        = (53, 52, 48, 49, 55, 47);
          VAR LATTR: ATTR; LOP: OPERATOR; TYPIND: CHAR;
"**"          LLC,LSIZE: ADDRRANGE;

          PROCEDURE SIMPLEEXPRESSION(FSYS: SETOFSYS);
            VAR LATTR: ATTR; LOP: OPERATOR; SIGNED: BOOLEAN;

            PROCEDURE TERM(FSYS: SETOFSYS);
              VAR LATTR: ATTR; LOP: OPERATOR;

              PROCEDURE FACTOR(FSYS: SETOFSYS);
                VAR LCP: CTP; LVP: CSP; VARPART: BOOLEAN;
#                   LATTR: ATTR;
"**"                CSTPART: SETRANGE  ; LSP: STP;   I,J: INTEGER;
"**"                TS_LC, TS_SIZE: ADDRRANGE;  MAXELEM: INTEGER;
              BEGIN
                IF NOT (SY IN FACBEGSYS) THEN
                  BEGIN ERROR(58); SKIP(FSYS + FACBEGSYS);
                    GATTR.TYPTR := NIL
                  END;
                WHILE SY IN FACBEGSYS DO
                  BEGIN
                    CASE SY OF
              (*ID*)    IDENT:
"&&"                    BEGIN SEARCHID([STRUCTKONST,KONST,VARS,FIELD,FUNC],LCP);
                          INSYMBOL;
                          IF LCP@.KLASS = FUNC THEN
#                           BEGIN CALL(FSYS,LCP);
"&&"                          GATTR.KIND := EXPR
#                           END
                          ELSE
                            IF LCP@.KLASS = KONST THEN
                              WITH GATTR, LCP@ DO
                                BEGIN TYPTR := IDTYPE; KIND := CST;
"&&"                              CVAL := VALUES;
"&&"                              IF SY IN (/LBRACK,LPARENT/) THEN
"&&"                                IF STRING(TYPTR) THEN
"&&"                                  BEGIN
"&&"                                    IF SY=LPARENT THEN BEGIN
"&&"                                      ERRKIND:='W'; ERROR(11) END;
"&&"                                    LATTR := GATTR;  LOADADDRESS;
"&&"                                    INSYMBOL;
"&&"                                    EXPRESSION(FSYS+(/RBRACK,RPARENT/));
"&&"                                    LOAD;
"&&"                                    LSP := LATTR.TYPTR@.INXTYPE;
"&&"                                    IF COMPTYPES(TYPTR,LSP) THEN
"&&"                                      BEGIN
"&&"                                       IF LSP <> NIL THEN
"&&"                                         GETBOUNDS(LSP,I,J)
"&&"                                       ELSE BEGIN I:=1; J:=LATTR.TYPTR@
"&&"                                                           .SIZE END;
"&&"                                        IF DEBUG THEN GEN3(45(*CHK*),
"&&"                                           ORD('J'),I,J DIV CHARSIZE);
"&&"                                        IF I <> 0 THEN
"&&"                                          GEN2(22(*DEC*),ORD('I'),I);
"&&"                                        GEN1(36(*IXA*),CHARSIZE);
"&&"                                      END
"&&"                                    ELSE ERROR(139);
"&&"                                    TYPTR := CHARPTR;  KIND := VARBL;
"&&"                                    BTYPE := CHARPTR;
"&&"                                    ACCESS := INDRCT;  IDPLMT := 0;
"&&"                                    IF SY = RBRACK THEN INSYMBOL ELSE
"&&"                                      IF SY = RPARENT THEN BEGIN
"&&"                                        ERRKIND:='W'; ERROR(12);
"&&"                                        INSYMBOL;  END
"&&"                                      ELSE ERROR(12);
"&&"                                  END
                                END
                            ELSE
                              SELECTOR(FSYS,LCP)
                        END;
              (*CST*)   INTCONST:
                        BEGIN
                          WITH GATTR DO
                            BEGIN TYPTR := INTPTR; KIND := CST;
"&&"                          CVAL := VAL
                            END;
                          INSYMBOL
                        END;
                      REALCONST:
                        BEGIN
                          WITH GATTR DO
                            BEGIN TYPTR := REALPTR; KIND := CST;
"&&"                          CVAL := VAL
                            END;
                          INSYMBOL
                        END;
                      STRINGCONST:
                        BEGIN
                          WITH GATTR DO
                            BEGIN
                              IF LNGTH = 1 THEN TYPTR := CHARPTR
                              ELSE
                                BEGIN NEW(LSP,ARRAYS);
                                  WITH LSP@ DO
                                    BEGIN AELTYPE := CHARPTR; FORM:=ARRAYS;
                                      INXTYPE := NIL; SIZE := LNGTH*CHARSIZE;
"&&"                                  ALN := CHARSIZE;
                                    END;
                                  TYPTR := LSP
                                END;
"&&"                          KIND := CST; CVAL := VAL;
                            END;
                          INSYMBOL
                        END;
              (* ( *)   LPARENT:
                        BEGIN INSYMBOL; EXPRESSION(FSYS + [RPARENT]);
                          IF SY = RPARENT THEN INSYMBOL ELSE ERROR(4)
                        END;
              (*NOT*)   NOTSY:
                        BEGIN INSYMBOL; FACTOR(FSYS);
                          LOAD; GEN0(19(*NOT*));
                          IF GATTR.TYPTR <> NIL THEN
                            IF GATTR.TYPTR <> BOOLPTR THEN
                              BEGIN ERROR(135); GATTR.TYPTR := NIL END;
                        END;
              (*[*)     LBRACK:
"**"                    BEGIN INSYMBOL; VARPART := FALSE; MAXELEM := -1;
"**"                      FOR I:=1 TO (SETMAX+1) DIV (SSETMAX+1) DO
"**"                        CSTPART[I] := [];
                          NEW(LSP,POWER);
                          WITH LSP@ DO
"**"                        BEGIN ELSET:=NIL;SIZE:=0;FORM:=POWER END;
                          IF SY = RBRACK THEN
                            BEGIN
                              WITH GATTR DO
                                BEGIN TYPTR := LSP; KIND := CST END;
                              INSYMBOL
                            END
                          ELSE
                            BEGIN
#                             REPEAT EXPRESSION(FSYS + [COMMA,DOTDOT,RBRACK]);
                                IF GATTR.TYPTR <> NIL THEN
                                  IF GATTR.TYPTR@.FORM <> SCALAR THEN
                                    BEGIN ERROR(136); GATTR.TYPTR := NIL END
                                  ELSE
                                    IF COMPTYPES(LSP@.ELSET,GATTR.TYPTR) THEN
                                      BEGIN
"**"                                    LSP@.ELSET := GATTR.TYPTR;
                                        IF GATTR.KIND = CST THEN
#                                         BEGIN
#                                         LATTR := GATTR ;
#                                         IF SY = DOTDOT THEN   (*RANGE GIVEN*)
#                                           BEGIN  INSYMBOL ;
#                                           EXPRESSION(FSYS+[COMMA,RBRACK]) ;
"@@"                                        IF GATTR.KIND<>CST THEN
"@@"                                        BEGIN GATTR:=LATTR; ERROR(305) END;
#                                           END ;
#                                         IF GATTR.TYPTR <> LATTR.TYPTR THEN
#                                             ERROR(137)
#                                         ELSE
#
#                                           IF (LATTR.CVAL.IVAL < 0)         OR
#                                              (GATTR.CVAL.IVAL > SETMAX  )  OR
#                                              (LATTR.CVAL.IVAL>GATTR.CVAL.IVAL)
#                                             THEN  ERROR(304)
"**"                                        ELSE BEGIN
"**"                                         IF GATTR.CVAL.IVAL>MAXELEM THEN
"**"                                         BEGIN
"**"                                         IF GATTR.CVAL.IVAL>SETMAX THEN
"**"                                         BEGIN  ERROR( 304 );
"**"                                           GATTR.CVAL.IVAL := SETMAX;
"**"                                         END;
"**"                                         MAXELEM := GATTR.CVAL.IVAL
"**"                                         END;
"**"                                         FOR I := LATTR.CVAL.IVAL TO
"**"                                                  GATTR.CVAL.IVAL DO
"**"                                           BEGIN
"**"                                           J := I DIV (SSETMAX+1);
"**"                                           CSTPART[J+1] := CSTPART[J+1]
"**"                                                   + [I - J*(SSETMAX+1)];
"**"                                           END;
"**"                                         END
"**"                                       END  (*GATTR.KIND = CST *)
"**"                                    ELSE
"**"                                    BEGIN  LOAD;
"&&"                                     IF GATTR.TYPTR <> INTPTR THEN
"**"                                       GEN0(61(*ORD*));
"**"                                     IF NOT VARPART THEN
"**"                                       BEGIN  (* ALLOCATE STORAGE *)
"**"                                       TS_SIZE := MAXSETSIZE;
"**"                                       IF GATTR.TYPTR <> NIL THEN
"&&"                                        IF GATTR.TYPTR <> INTPTR THEN
"**"                                          TS_SIZE :=
"**"                                               CALC_SETSIZE(GATTR.TYPTR);
"**"                                        IF TS_SIZE > MAXSETSIZE THEN
"**"                                          TS_SIZE := MAXSETSIZE;
"**"                                        ALIGN(LC,WORDSIZE);  TS_LC := LC;
"**"                                        GEN2(29(*SCL*),TS_SIZE,LC);
"**"                                        LC := LC + TS_SIZE;
"**"                                        IF LC>LCMAX THEN LCMAX := LC;
"**"                                        VARPART := TRUE;
"**"                                        GEN1(67(*ASE*),-TS_SIZE);
"**"                                       END
"**"                                     ELSE GEN1(67(*ASE*),TS_SIZE);
"**"                                    END
"**"                                  END
"**"                                ELSE ERROR( 137 );
                                TEST := SY <> COMMA;
                                IF NOT TEST THEN INSYMBOL
                              UNTIL TEST;
                              IF SY = RBRACK THEN INSYMBOL ELSE ERROR(12)
                            END;
                          IF VARPART THEN
                            BEGIN
"**"                          IF MAXELEM >= 0 THEN
"**"                            BEGIN  NEW(LVP,PSET);
"**"                              LVP@.PVAL := CSTPART;
"**"                              LVP@.PLNGTH := ((MAXELEM+SETPACK) DIV
"**"                                              SETPACK) * WORDSIZE;
"**"                              CNSTPTR := LVP;
"**"                              ALIGN( LC, WORDSIZE );
"**"                              GEN1(37(*LCA*),ORD('S'));
"**"                              GEN2(68(*SLD*),LVP@.PLNGTH,LC);
"**"                              GEN0( 31 (*UNI*) );
"**"                              IF LVP@.PLNGTH > TS_SIZE THEN
"**"                                TS_SIZE := LVP@.PLNGTH;
"**"                              IF (TS_SIZE+LC) > LCMAX THEN
"**"                                LCMAX := TS_SIZE + LC;
"**"                            END;
"&&"                          GATTR.KIND := VARBL;
"**"                          GATTR.ACCESS := STKEXPR;
"**"                          GATTR.STKDPLMT := TS_LC;
"**"                          GATTR.STKLEN := TS_SIZE;
"**"                          LSP@.SIZE := TS_SIZE;
"**"                        END
                          ELSE
                            BEGIN NEW(LVP,PSET); LVP@.PVAL := CSTPART;
"**"                         LVP@.PLNGTH := ((MAXELEM+SETPACK) DIV
"**"                                          SETPACK) * WORDSIZE;
"**"                         LSP@.SIZE := LVP@.PLNGTH;
"**"                         GATTR.KIND := CST;
"**"                         GATTR.CVAL.VALP := LVP;
"**"                       END;
"**"                     GATTR.TYPTR := LSP;
                        END
                    END (*CASE*) ;
                    IF NOT (SY IN FSYS) THEN
                      BEGIN ERROR(6); SKIP(FSYS + FACBEGSYS) END;
"&&"              IF GATTR.KIND <> VARBL THEN
"&&"                GATTR.BTYPE := GATTR.TYPTR
"&&"              ELSE IF GATTR.TYPTR = NIL THEN
"&&"                  GATTR.BTYPE := NIL;
                  END (*WHILE*)
              END (*FACTOR*) ;

            BEGIN (*TERM*)
              FACTOR(FSYS + [MULOP]);
              WHILE SY = MULOP DO
"**"            BEGIN
"**"              IF GATTR.TYPTR <> NIL THEN
"**"                IF GATTR.TYPTR@.FORM < POWER THEN
"**"                  LOAD
"**"                ELSE FORCETEMPSET;
"**"              LATTR := GATTR;  LOP := OP;
"**"              INSYMBOL; FACTOR(FSYS + [MULOP] );
"**"              IF GATTR.TYPTR <> NIL THEN
"**"                IF GATTR.TYPTR@.FORM < POWER THEN
"**"                  LOAD;
                  IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
                    CASE LOP OF
            (***)       MUL:  IF (LATTR.TYPTR=INTPTR)AND(GATTR.TYPTR=INTPTR)
                              THEN GEN0(15(*MPI*))
                            ELSE
                              BEGIN
#                               IF GATTR.TYPTR = INTPTR THEN
#                                 BEGIN GEN0(10(*FLT*));
#                                   GATTR.TYPTR := REALPTR
#                                 END
#                               ELSE
#                                 IF LATTR.TYPTR = INTPTR THEN
#                                   BEGIN GEN0(9(*FLO*));
#                                     LATTR.TYPTR := REALPTR
                                    END;
                                IF (LATTR.TYPTR = REALPTR)
                                  AND(GATTR.TYPTR=REALPTR)THEN GEN0(16(*MPR*))
"**"                            ELSE GENSETOP(LATTR,12(*INT*));
                              END;
            (*/*)       RDIV: BEGIN
#                             IF GATTR.TYPTR = INTPTR THEN
#                               BEGIN GEN0(10(*FLT*));
#                                 GATTR.TYPTR := REALPTR
#                               END;
#                             IF LATTR.TYPTR = INTPTR THEN
#                               BEGIN GEN0(9(*FLO*));
#                                 LATTR.TYPTR := REALPTR
#                               END;
                              IF (LATTR.TYPTR = REALPTR)
                                AND (GATTR.TYPTR=REALPTR)THEN GEN0(7(*DVR*))
                              ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
                            END;
            (*DIV*)     IDIV: IF (LATTR.TYPTR = INTPTR)
                              AND (GATTR.TYPTR = INTPTR) THEN GEN0(6(*DVI*))
                            ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END;
            (*MOD*)     IMOD: IF (LATTR.TYPTR = INTPTR)
#                             AND (GATTR.TYPTR = INTPTR) THEN GEN0(14       )
                            ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END;
            (*AND*)     ANDOP:IF (LATTR.TYPTR = BOOLPTR)
                              AND (GATTR.TYPTR = BOOLPTR) THEN GEN0(4(*AND*))
                            ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
                    END (*CASE*)
                  ELSE GATTR.TYPTR := NIL;
#                 GATTR.BTYPE := GATTR.TYPTR;
                END (*WHILE*)
            END (*TERM*) ;

          BEGIN (*SIMPLEEXPRESSION*)
            SIGNED := FALSE;
            IF (SY = ADDOP) AND (OP IN [PLUS,MINUS]) THEN
              BEGIN SIGNED := OP = MINUS; INSYMBOL END;
            TERM(FSYS + [ADDOP]);
            IF SIGNED THEN
              BEGIN LOAD;
                IF GATTR.TYPTR = INTPTR THEN GEN0(17(*NGI*))
                ELSE
                  IF GATTR.TYPTR = REALPTR THEN GEN0(18(*NGR*))
                  ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
              END;
            WHILE SY = ADDOP DO
"**"          BEGIN
"**"            IF GATTR.TYPTR <> NIL THEN
"**"              IF GATTR.TYPTR@.FORM < POWER THEN
"**"                LOAD
"**"              ELSE FORCETEMPSET;
"**"            LATTR := GATTR;  LOP := OP;
"**"            INSYMBOL; TERM(FSYS + [ADDOP]);
"**"            IF GATTR.TYPTR <> NIL THEN
"**"              IF GATTR.TYPTR@.FORM < POWER THEN
"**"                LOAD;
                IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
                  CASE LOP OF
          (*+*)       PLUS:
                      IF (LATTR.TYPTR = INTPTR)AND(GATTR.TYPTR = INTPTR) THEN
                        GEN0(2(*ADI*))
                      ELSE
                        BEGIN
#                         IF GATTR.TYPTR = INTPTR THEN
#                           BEGIN GEN0(10(*FLT*));
#                             GATTR.TYPTR := REALPTR
#                           END
#                         ELSE
#                           IF LATTR.TYPTR = INTPTR THEN
#                             BEGIN GEN0(9(*FLO*));
#                               LATTR.TYPTR := REALPTR
#                             END;
                          IF (LATTR.TYPTR = REALPTR)AND(GATTR.TYPTR = REALPTR)
                            THEN GEN0(3(*ADR*))
"**"                      ELSE GENSETOP(LATTR,31(*UNI*));
                        END;
          (*-*)       MINUS:
                      IF (LATTR.TYPTR = INTPTR)AND(GATTR.TYPTR = INTPTR) THEN
                        GEN0(21(*SBI*))
                      ELSE
                        BEGIN
#                         IF GATTR.TYPTR = INTPTR THEN
#                           BEGIN GEN0(10(*FLT*));
#                             GATTR.TYPTR := REALPTR
#                           END
#                         ELSE
#                           IF LATTR.TYPTR = INTPTR THEN
#                             BEGIN GEN0(9(*FLO*));
#                               LATTR.TYPTR := REALPTR
                              END;
                          IF (LATTR.TYPTR = REALPTR)AND(GATTR.TYPTR = REALPTR)
                            THEN GEN0(8(*SBR*))
"**"                      ELSE GENSETOP(LATTR,5(*DIF*));
                        END;
          (*OR*)      OROP:
                      IF(LATTR.TYPTR=BOOLPTR)AND(GATTR.TYPTR=BOOLPTR)THEN
                        GEN0(13(*IOR*))
                      ELSE BEGIN ERROR(134); GATTR.TYPTR := NIL END
                  END (*CASE*)
                ELSE GATTR.TYPTR := NIL;
#               GATTR.BTYPE := GATTR.TYPTR;
              END (*WHILE*)
          END (*SIMPLEEXPRESSION*) ;

        BEGIN (*EXPRESSION*)
"**"      LLC := LC;  SIMPLEEXPRESSION(FSYS + [RELOP]);
          IF SY = RELOP THEN
            BEGIN
              IF GATTR.TYPTR <> NIL THEN
"**"            IF GATTR.TYPTR@.FORM < POWER THEN LOAD
"**"            ELSE IF GATTR.TYPTR@.FORM = POWER THEN FORCETEMPSET
                ELSE LOADADDRESS;
              LATTR := GATTR; LOP := OP;
"**"          IF LOP = INOP THEN
"&&"            IF GATTR.TYPTR <> INTPTR THEN
"**"              GEN0( 61 (*ORD*) );
              INSYMBOL; SIMPLEEXPRESSION(FSYS);
              IF GATTR.TYPTR <> NIL THEN
"**"            IF GATTR.TYPTR@.FORM < POWER THEN LOAD
"**"            ELSE IF GATTR.TYPTR@.FORM = POWER THEN FORCETEMPSET
                ELSE LOADADDRESS;
              IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
     (*IN*)     IF LOP = INOP THEN
                  IF GATTR.TYPTR@.FORM = POWER THEN
                    IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR@.ELSET) THEN
"**"                  GEN0( 11 (*INN*) )
                    ELSE BEGIN ERROR(129); GATTR.TYPTR := NIL END
                  ELSE BEGIN ERROR(130); GATTR.TYPTR := NIL END
                ELSE
                  BEGIN
                    IF LATTR.TYPTR <> GATTR.TYPTR THEN
#                     IF GATTR.TYPTR = INTPTR THEN
#                       BEGIN GEN0(10(*FLT*));
#                         GATTR.TYPTR := REALPTR
#                       END
#                     ELSE
#                       IF LATTR.TYPTR = INTPTR THEN
#                         BEGIN GEN0(9(*FLO*));
#                           LATTR.TYPTR := REALPTR
                          END;
                    IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
                      BEGIN LSIZE := LATTR.TYPTR@.SIZE;
                        CASE LATTR.TYPTR@.FORM OF
                          SCALAR:
                            IF LATTR.TYPTR = REALPTR THEN TYPIND := 'R'
                            ELSE
                              IF LATTR.TYPTR = BOOLPTR THEN TYPIND := 'B'
#                             ELSE
#                               IF LATTR.TYPTR = CHARPTR THEN TYPIND := 'C'
#                               ELSE TYPIND := 'I' ;
                          POINTER:
                            BEGIN
                              IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131);
                              TYPIND := 'A'
                            END;
                          POWER:
                            BEGIN IF LOP IN [LTOP,GTOP] THEN ERROR(132);
                              TYPIND := 'S';
                          END;
                          ARRAYS:
                            BEGIN
                              IF NOT STRING(LATTR.TYPTR) THEN
                                IF LOP IN[LTOP,LEOP,GTOP,GEOP] THEN ERROR(131);
                              TYPIND := 'M'
                            END;
                          RECORDS:
                            BEGIN
                              IF LOP IN [LTOP,LEOP,GTOP,GEOP] THEN ERROR(131);
                              TYPIND := 'M'
                            END;
                          FILES:
                            BEGIN ERROR(133); TYPIND := 'F' END
                        END;
"&&"                    GEN2( COMPARE_OP(/LOP/), ORD(TYPIND), LSIZE );
                      END
                    ELSE ERROR(129)
                  END;
"&&"          GATTR.TYPTR := BOOLPTR; GATTR.BTYPE := BOOLPTR;
              GATTR.KIND := EXPR;
"**"          LC := LLC;
            END (*SY = RELOP*)
        END (*EXPRESSION*) ;

        PROCEDURE ASSIGNMENT(FCP: CTP);
"**"      VAR LATTR: ATTR;  RSIZE, LLC: ADDRRANGE;
        BEGIN  LLC := LC;
          SELECTOR(FSYS + [BECOMES],FCP);
#         VAR_MOD := VAR_MOD+1 ;
          IF SY = BECOMES THEN
            BEGIN
              IF GATTR.TYPTR <> NIL THEN
                IF (GATTR.ACCESS<>DRCT) OR (GATTR.TYPTR@.FORM>=POWER) THEN
                  LOADADDRESS;
              LATTR := GATTR;
              INSYMBOL; EXPRESSION(FSYS);
              IF GATTR.TYPTR <> NIL THEN
"**"            IF GATTR.TYPTR@.FORM < POWER THEN LOAD
"**"            ELSE IF GATTR.TYPTR@.FORM = POWER THEN FORCETEMPSET
                ELSE LOADADDRESS;
              IF (LATTR.TYPTR <> NIL) AND (GATTR.TYPTR <> NIL) THEN
                BEGIN
                  IF COMPTYPES(REALPTR,LATTR.TYPTR)AND(GATTR.TYPTR=INTPTR)THEN
                    BEGIN GEN0(10(*FLT*));
                      GATTR.TYPTR := REALPTR
                    END;
                  IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
                    BEGIN

#                     IF DEBUG THEN
#                       BEGIN
"&&"                    ASSIGN := TRUE ;  CHKBNDS(LATTR.BTYPE);  ASSIGN := FALSE
#                       END ;

                      CASE LATTR.TYPTR@.FORM OF
                        SCALAR,
                        SUBRANGE,
"**"                    POINTER: STORE(LATTR);
"**"                    POWER:   GEN2(69(*SMV*),LATTR.TYPTR@.SIZE,
"**"                                            GATTR.TYPTR@.SIZE);
                        ARRAYS,
                        RECORDS: GEN1(40(*MOV*),LATTR.TYPTR@.SIZE);
                        FILES: ERROR(146)
                      END  (*CASE LATTR...*)
#                   END
                  ELSE ERROR(129)
                END
            END (*SY = BECOMES*)
          ELSE ERROR(51);
"**"  LC := LLC;
        END (*ASSIGNMENT*) ;

        PROCEDURE GOTOSTATEMENT;
"&&"      LABEL 10;
"&&"      VAR LLP: LBP;  TTOP: DISPRANGE;  XLABEL: ALPHA;
        BEGIN
          IF SY = INTCONST THEN
            BEGIN
"&&"          TTOP := LEVEL;
#             REPEAT
                LLP := DISPLAY[TTOP].FLABEL;
"&&"            WHILE LLP <> NIL DO
                  WITH LLP@ DO
                    IF LABVAL = VAL.IVAL THEN
"&&"                  BEGIN
"&&"                    IF TTOP = LEVEL THEN
"&&"                      GENUJPFJP( 57(*UJP*), LABNAME )
"&&"                    ELSE BEGIN
"&&"                      IF XNO = 0 THEN  (* FIRST DEEP GOTO TO THIS LABEL *)
"&&"                        BEGIN  XLABNO := XLABNO+1;  XNO := XLABNO  END;
"&&"                      XLABEL := '############';  MKNAME(XLABEL,XNO,FALSE);
"&&"                      IF PRCODE THEN
"&&"                        WRITELN(PRR, MN(/73/), ' ', XLABEL:EXTNAMSZ );
"&&"                    END;
"CT"                    CTREMIT( CTRGOTO, 0, LINECNT, 0, LINECNT );
"&&"                    GOTO 10
                      END
                    ELSE LLP := NEXTLAB;
                TTOP := TTOP - 1
"&&"          UNTIL TTOP = 0;
              ERROR(167);
"&&" 10:      INSYMBOL
            END
          ELSE ERROR(15)
        END (*GOTOSTATEMENT*) ;

        PROCEDURE COMPOUNDSTATEMENT;
        BEGIN
          REPEAT
            REPEAT STATEMENT(FSYS + [SEMICOLON,ENDSY])
            UNTIL NOT (SY IN STATBEGSYS);
            TEST := SY <> SEMICOLON;
            IF NOT TEST THEN INSYMBOL
          UNTIL TEST;
          IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
        END (*COMPOUNDSTATEMENET*) ;

        PROCEDURE IFSTATEMENT;
          VAR LCIX1,LCIX2: LABELRNG;
"CT"          FIRSTLN, MIDLN : INTEGER;   CTRNO : CTRRANGE;
        BEGIN EXPRESSION(FSYS + [THENSY]);
          GENLABEL(LCIX1); GENFJP(LCIX1);
          IF SY = THENSY THEN INSYMBOL ELSE ERROR(52);
"CT"      FIRSTLN := LINECNT; CTRNO := CTRGEN;
"CT"      (*** COUNTER HERE ***)

          STATEMENT(FSYS + [ELSESY]);
          IF SY = ELSESY THEN
            BEGIN GENLABEL(LCIX2); GENUJPFJP(57(*UJP*),LCIX2);
              PUTLABEL(LCIX1);
              INSYMBOL;
"CT"          MIDLN := LINECNT ;
              STATEMENT(FSYS);
              PUTLABEL(LCIX2)
            END
          ELSE
            BEGIN
            PUTLABEL(LCIX1) ;
"CT"        MIDLN := 0;
            END ;
"CT"      CTREMIT(CTRIF, CTRNO, FIRSTLN, MIDLN, LINECNT)
        END (*IFSTATEMENT*) ;

        PROCEDURE CASESTATEMENT;
"&&"      LABEL 1;
          TYPE CIP = @CASEINFO;
"&&"           CASEINFO = RECORD NEXT: CIP;
                            CSSTART: LABELRNG;
"&&"                        CSLAB1,CSLAB2: INTEGER
                          END;
#         VAR LSP,LSP1: STP; FSTPTR,LPT1,LPT2,LPT3: CIP; LVAL,LVAL1: VALU;
"&&"          LADDR, LCIX, LCIX1, UBND, LBND, XADDR: LABELRNG ;
"&&"          LMIN, LMAX : INTEGER ;  OTHWC: BOOLEAN;
"CT"          FIRSTLN : INTEGER; TEMPLN  : INTEGER;
"CT"          CTRCASES : INTEGER; CTRNO : CTRRANGE;
        BEGIN EXPRESSION(FSYS + [OFSY,COMMA,COLON]);
#         LOAD ;
#         LSP := GATTR.TYPTR;
#         IF LSP <> NIL THEN
#           IF (LSP@.FORM <> SCALAR) OR (LSP = REALPTR) THEN
#             BEGIN  ERROR(144); LSP := NIL END
#           ELSE  IF NOT COMPTYPES(LSP,INTPTR) THEN  GEN0(61(*ORD*)) ;
#         IF DEBUG THEN  CHKBNDS(GATTR.TYPTR) ;
          IF SY = OFSY THEN INSYMBOL ELSE ERROR(8);
#         FSTPTR := NIL ;  GENLABEL(LBND) ;  GENLABEL(UBND) ;
#         GENLABEL(LCIX) ;  GENLABEL(LADDR);
"&&"      GENLABEL(XADDR);
#         (* WE SHOULD HAVE:  LADDR = LCIX+1 = UBND+2 = LBND+3   HERE *)
#         GENUJPFJP(44 (*XJP*), LBND) ;
"&&"      OTHWC := FALSE;
"CT"      FIRSTLN := LINECNT;  CTRCASES := 0;
          REPEAT
            LPT3 := NIL; GENLABEL(LCIX1);
#           IF NOT(SY IN [SEMICOLON,ENDSY]) THEN
#           BEGIN
"&&"          IF SY <> OTHERWISESY THEN
"&&"            BEGIN
                  REPEAT CONSTANT(FSYS + [COMMA,COLON,DOTDOT],LSP1,LVAL);
                    IF LSP <> NIL THEN
                      IF COMPTYPES(LSP,LSP1) THEN
#                       BEGIN
#                       LVAL1.IVAL := LVAL.IVAL ;
#                       IF SY = DOTDOT THEN
#                         BEGIN  INSYMBOL ;
#                         CONSTANT(FSYS+[COMMA,COLON],LSP1,LVAL1)
#                         END ;
#                       IF COMPTYPES(LSP,LSP1) THEN
"&&"                        IF LVAL.IVAL <= LVAL1.IVAL THEN
                              BEGIN LPT1 := FSTPTR; LPT2 := NIL;
                              WHILE LPT1 <> NIL DO
                                WITH LPT1@ DO
                                  BEGIN
"&&"                                IF LVAL1.IVAL >= CSLAB2 THEN
                                      BEGIN
"&&"                                    IF LVAL.IVAL <= CSLAB2 THEN ERROR(156);
                                        GOTO 1
                                      END;
                                    LPT2 := LPT1; LPT1 := NEXT
                                  END;
                1:            NEW(LPT3);
                              WITH LPT3@ DO
                                BEGIN NEXT := LPT1;
"&&"                              CSLAB1 := LVAL.IVAL; CSLAB2 := LVAL1.IVAL;
                                  CSSTART := LCIX1
                                END;
                              IF LPT2 = NIL THEN FSTPTR := LPT3
                              ELSE LPT2@.NEXT := LPT3
                             END
"&&"                   ELSE ERROR(102)
                        ELSE ERROR(147);
                        END  ELSE ERROR(147);
                    TEST := SY <> COMMA;
                    IF NOT TEST THEN INSYMBOL
                  UNTIL TEST;
"&&"              IF SY = COLON THEN INSYMBOL ELSE ERROR(5)
"&&"            END
"&&"          ELSE  (* SY = OTHERWISESY *)
"&&"            BEGIN
"&&"              IF OTHWC THEN ERROR(156) ELSE LCIX1 := LADDR;
"&&"              OTHWC := TRUE;  INSYMBOL;
"&&"              IF SY = COLON THEN INSYMBOL  (* IGNORE : FOR NOW *)
"&&"            END;
              PUTLABEL(LCIX1);
"CT"          TEMPLN := LINECNT; (*** COUNTER HERE ***)
"CT"          CTRNO := CTRGEN;  CTRCASES := CTRCASES+1 ;
              REPEAT STATEMENT(FSYS + [SEMICOLON])
              UNTIL NOT (SY IN STATBEGSYS);
"&&"          GENUJPFJP(57(*UJP*),XADDR);
"CT"          CTREMIT(CTRCASE, CTRNO, TEMPLN, 0, LINECNT);
#           END ;
            TEST := SY <> SEMICOLON;
            IF NOT TEST THEN INSYMBOL ;
          UNTIL TEST;
          IF FSTPTR <> NIL THEN
"&&"        BEGIN LMAX := FSTPTR@.CSLAB2;
              (*REVERSE POINTERS*)
              LPT1 := FSTPTR; FSTPTR := NIL;
              REPEAT LPT2 := LPT1@.NEXT; LPT1@.NEXT := FSTPTR;
                FSTPTR := LPT1; LPT1 := LPT2
              UNTIL LPT1 = NIL;
"&&"          LMIN := FSTPTR@.CSLAB1;
#           END
#         ELSE  BEGIN  LMIN := 1 ;  LMAX := 0  END ;
#         GENDEF(LBND,LMIN) ;  GENDEF(UBND,LMAX) ;  PUTLABEL(LCIX) ;
          IF LMAX - LMIN < CIXMAX THEN
#           BEGIN
#           IF FSTPTR <> NIL THEN
              REPEAT
                WITH FSTPTR@ DO
                  BEGIN
"&&"                WHILE CSLAB1 > LMIN DO
                      BEGIN GENUJPFJP(57(*UJP*),LADDR); LMIN:=LMIN+1 END;
"&&"                REPEAT
                      GENUJPFJP(57(*UJP*),CSSTART);
"&&"                  LMIN := LMIN + 1;
"&&"                UNTIL LMIN > CSLAB2;
                    FSTPTR := NEXT;
                  END
              UNTIL FSTPTR = NIL;
"&&"          IF NOT OTHWC THEN PUTLABEL(LADDR) ;
"&&"          PUTLABEL(XADDR);
"CT"          CTREMIT(CTRCASE, 0, FIRSTLN, CTRCASES, LINECNT);
            END
          ELSE ERROR(157) ;
          IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13)
        END (*CASESTATEMENT*) ;

        PROCEDURE REPEATSTATEMENT;
          VAR LADDR: LABELRNG;
"CT"            FIRSTLN : INTEGER; CTRNO : CTRRANGE;
        BEGIN GENLABEL(LADDR); PUTLABEL(LADDR);
"CT"      FIRSTLN := LINECNT; CTRNO := CTRGEN;
"CT"      (*** COUNTER HERE ***)
          REPEAT
            REPEAT STATEMENT(FSYS + [SEMICOLON,UNTILSY])
            UNTIL NOT (SY IN STATBEGSYS);
            TEST := SY <> SEMICOLON;
            IF NOT TEST THEN INSYMBOL
          UNTIL TEST;
          IF SY = UNTILSY THEN
            BEGIN INSYMBOL; EXPRESSION(FSYS); GENFJP(LADDR) ;
"CT"            CTREMIT(CTRREPEAT, CTRNO, FIRSTLN, 0, LINECNT)
            END
          ELSE ERROR(53)
        END (*REPEATSTATEMENT*) ;

        PROCEDURE WHILESTATEMENT;
          VAR LADDR, LCIX: LABELRNG;
"CT"          FIRSTLN : INTEGER; CTRNO : CTRRANGE;
        BEGIN GENLABEL(LADDR); PUTLABEL(LADDR);
          EXPRESSION(FSYS + [DOSY]); GENLABEL(LCIX); GENFJP(LCIX);
          IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
"CT"      FIRSTLN := LINECNT; CTRNO := CTRGEN;
          (*** COUNTER HERE ***)
          STATEMENT(FSYS); GENUJPFJP(57(*UJP*),LADDR); PUTLABEL(LCIX) ;
"CT"      CTREMIT(CTRWHILE, CTRNO, FIRSTLN, 0, LINECNT);
        END (*WHILESTATEMENT*) ;

        PROCEDURE FORSTATEMENT;
"&&"      VAR LATTR: ATTR; LSP: STP;  LSY: SYMBOL;  LOP: OPRANGE;
"&&"          XT, CV1, CV2: INTEGER;  CB1, CB2: BOOLEAN;
#             LCIX, LADDR: LABELRNG;  LLC : ADDRRANGE;
"CT"          FIRSTLN : INTEGER; CTRNO : CTRRANGE;
        BEGIN
          IF SY = IDENT THEN
            BEGIN SEARCHID([VARS],LCP);
              WITH LCP@, LATTR DO
#               BEGIN TYPTR := IDTYPE; KIND := VARBL; BTYPE := TYPTR ;
"&&"              IF TYPTR <> NIL THEN
"&&"                IF TYPTR@.FORM = SUBRANGE THEN
"&&"                  TYPTR := TYPTR@.RANGETYPE;
                  IF VKIND = ACTUAL THEN
                    BEGIN ACCESS := DRCT; VLEVEL := VLEV;
                      DPLMT := VADDR ;
                    END
                  ELSE BEGIN ERROR(155); TYPTR := NIL END
                END;
              IF LATTR.TYPTR <> NIL THEN
                IF (LATTR.TYPTR@.FORM > SUBRANGE)
"&&"               OR (LATTR.TYPTR = REALPTR) THEN
                  BEGIN ERROR(143); LATTR.TYPTR := NIL END;
              INSYMBOL
            END
          ELSE
            BEGIN ERROR(2);  LATTR.TYPTR := NIL;
                  SKIP(FSYS + [BECOMES,TOSY,DOWNTOSY,DOSY]) END;
          IF SY = BECOMES THEN
            BEGIN INSYMBOL; EXPRESSION(FSYS + [TOSY,DOWNTOSY,DOSY]);
              IF GATTR.TYPTR <> NIL THEN
                  IF GATTR.TYPTR@.FORM <> SCALAR THEN ERROR(144)
                  ELSE
                    IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
"&&"                  BEGIN
"&&"                    IF GATTR.KIND = CST THEN
"&&"                      BEGIN  CB1 := TRUE;
"&&"                        CV1 := GATTR.CVAL.IVAL
"&&"                      END
"&&"                    ELSE CB1 := FALSE;
"&&"                    LOAD;
#                       STORE(LATTR);
                      END
                    ELSE ERROR(145)
            END
          ELSE
            BEGIN ERROR(51); SKIP(FSYS + [TOSY,DOWNTOSY,DOSY]) END;
"&&"      IF (SY = TOSY) OR (SY = DOWNTOSY) THEN
            BEGIN LSY := SY; INSYMBOL; EXPRESSION(FSYS + [DOSY]);
              IF GATTR.TYPTR <> NIL THEN
              IF GATTR.TYPTR@.FORM <> SCALAR THEN ERROR(144)
                ELSE
                  IF COMPTYPES(LATTR.TYPTR,GATTR.TYPTR) THEN
"&&"                BEGIN
"&&"                  IF GATTR.KIND = CST THEN
"&&"                    BEGIN  CB2 := TRUE;  LLC := LC;
"&&"                      CV2 := GATTR.CVAL.IVAL
"&&"                    END
"&&"                  ELSE
"&&"                    BEGIN  CB2 := FALSE;
"&&"                      LOAD;
"&&"                      ALIGN(LC,INTSIZE);  LLC := LC;
"&&"                      IF GATTR.TYPTR <> INTPTR THEN GEN0(61(*ORD*));
"&&"                      GEN3(56(*STR*),ORD('I'),LEVEL,LLC);
"&&"                      LC := LC + INTSIZE;
"&&"                      IF LC > LCMAX THEN LCMAX := LC;
"&&"                    END;
"&&"                  IF CB1 AND CB2 THEN
"&&"                    BEGIN  XT := 1;
"&&"                      IF LSY = TOSY THEN
"&&"                        IF CV1 > CV2 THEN XT := 0 ELSE
"&&"                      ELSE
"&&"                        IF CV1 < CV2 THEN XT := 0;
"&&"                      GEN2(51(*LDC*),3,XT);
"&&"                    END
"&&"                  ELSE
"&&"                    BEGIN
"&&"                      IF CB1 THEN
"&&"                        GEN2(51(*LDC*),1,CV1)
"&&"                      ELSE
"&&"                        BEGIN  GATTR := LATTR;  LOAD;
"&&"                          IF GATTR.TYPTR <> INTPTR THEN GEN0(61(*ORD*));
"&&"                        END;
"&&"                      IF CB2 THEN
"&&"                        GEN2(51(*LDC*),1,CV2)
"&&"                      ELSE
"&&"                        GEN3(54(*LOD*),ORD('I'),LEVEL,LLC);
"&&"                      IF LSY = TOSY THEN LOP := 52 ELSE LOP := 48;
"&&"                      GEN2(LOP,ORD('I'),1);
"&&"                    END;
"&&"                END
                  ELSE ERROR(145)
            END
          ELSE BEGIN ERROR(55); SKIP(FSYS + [DOSY]) END;
#         GENLABEL(LADDR) ;  GENLABEL(LCIX);  GENUJPFJP(33(*FJP*),LCIX);
#         PUTLABEL(LADDR) ;  (*BEGINNING OF THE FOR 'LOOP'*)
          IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
"CT"      FIRSTLN := LINECNT; CTRNO := CTRGEN;
          (*** COUNTER HERE ***)
          STATEMENT(FSYS);
#         GATTR := LATTR ;  LOAD ;
"&&"      IF GATTR.TYPTR <> INTPTR THEN  GEN0(61(*ORD*));
"&&"      IF CB2 THEN
"&&"        GEN2(51(*LDC*),1,CV2)
"&&"      ELSE
#           GEN3(54(*LOD*),ORD('I'),LEVEL,LLC);
#         GEN2(55(*NEQ*),ORD('I'),1);
#         GENUJPFJP(33(*FJP*),LCIX) ;
#         GATTR := LATTR; LOAD;
"&&"      LOP := 23 (*INC*) ;
"&&"      IF LSY <> TOSY THEN LOP := 22 (*DEC*) ;
"&&"      GEN2(LOP,GETTYPE(GATTR.TYPTR),1);
#         IF DEBUG THEN CHKBNDS(LATTR.TYPTR) ;
          STORE(LATTR); GENUJPFJP(57(*UJP*),LADDR); PUTLABEL(LCIX);
          LC := LLC ;
"CT"      CTREMIT(CTRFOR, CTRNO, FIRSTLN, 0, LINECNT);
        END (*FORSTATEMENT*) ;

        PROCEDURE WITHSTATEMENT;
#         VAR LCP: CTP; LCNT: DISPRANGE; LLC: ADDRRANGE;
"&&"          OLD_LEV: -1 .. DISPLIMIT;  REC_STR: STP;
"&&"    BEGIN LLC := LC;
"SY"    IF GET_STAT THEN WS_CNT := WS_CNT + 1;
          IF SY = IDENT THEN
            BEGIN SEARCHID([VARS,FIELD],LCP); INSYMBOL END
          ELSE BEGIN ERROR(2); LCP := UVARPTR END;
          SELECTOR(FSYS + [COMMA,DOSY],LCP);
"&&"      REC_STR := GATTR.TYPTR;
          IF GATTR.TYPTR <> NIL THEN
            IF GATTR.TYPTR@.FORM = RECORDS THEN
              IF TOP < DISPLIMIT THEN
#               BEGIN  TOP := TOP + 1;
                  WITH DISPLAY[TOP] DO
                    BEGIN
"&&"                  OLD_LEV := REC_STR@.FLD_DISP_LEV;
"&&"                  REC_STR@.FLD_DISP_LEV := TOP;
                      IF GATTR.ACCESS = DRCT THEN
                        BEGIN OCCUR := CREC; CLEV := GATTR.VLEVEL;
                          CDSPL := GATTR.DPLMT
                        END
                      ELSE
#                       BEGIN  LOADADDRESS;  ALIGN(LC,PTRSIZE) ;
#                         GEN3(56(*STR*),ORD('A'),LEVEL,LC);
                          OCCUR := VREC; VDSPL := LC;
#                         LC := LC + PTRSIZE;
                          IF LC > LCMAX THEN LCMAX := LC
                        END
"&&"                END
                END
              ELSE FATALERROR(250)
"&&"        ELSE BEGIN ERROR(140); REC_STR := NIL  END;
"&&"      OPEN_RECORD := REC_STR;
"&&"      IF SY = COMMA THEN
"&&"        BEGIN  INSYMBOL;  WITHSTATEMENT  END
"&&"      ELSE
"&&"        BEGIN
              IF SY = DOSY THEN INSYMBOL ELSE ERROR(54);
              STATEMENT(FSYS);
"&&"        END;
"&&"      IF REC_STR <> NIL THEN
"&&"        REC_STR@.FLD_DISP_LEV := OLD_LEV;
"&&"      TOP := TOP-1;  LC := LLC;  OPEN_RECORD := NIL;
        END (*WITHSTATEMENT*) ;

      BEGIN (*STATEMENT*)
        IF SY = INTCONST THEN (*LABEL*)
"&&"      BEGIN
"&&"      LLP := DISPLAY[LEVEL].FLABEL;
            WHILE LLP <> NIL DO
              WITH LLP@ DO
                IF LABVAL = VAL.IVAL THEN
                  BEGIN IF DEFINED THEN ERROR(165);
"&&"                  IF XNO > 0 THEN  (* LABEL IS AN EXTERNAL ENTRY PT. *)
"&&"                    BEGIN  XLABEL := '############';
"&&"                      MKNAME( XLABEL, XNO, FALSE );
"&&"                      IF PRCODE THEN
"&&"                        WRITELN(PRR, XLABEL:EXTNAMSZ, MN(/74/) );
"&&"                      XNO := 0;  (* IN CASE OF REDEFINITION *)
"&&"                    END;
                    PUTLABEL(LABNAME); DEFINED := TRUE;
"CT"                CTRNO := CTRGEN;
"CT"                CTREMIT(CTRLBL, CTRNO, LINECNT, 0, LINECNT);
"CT"                (*** COUNTER HERE ***)
                    GOTO 1
                  END
                ELSE LLP := NEXTLAB;
            ERROR(167);
      1:    INSYMBOL;
            IF SY = COLON THEN INSYMBOL ELSE ERROR(5)
          END;
        IF NOT (SY IN FSYS + [IDENT]) THEN
          BEGIN ERROR(6); SKIP(FSYS) END;
        IF SY IN STATBEGSYS + [IDENT] THEN
          BEGIN
            CASE SY OF
              IDENT:    BEGIN SEARCHID([VARS,FIELD,FUNC,PROC],LCP); INSYMBOL;
                          IF LCP@.KLASS = PROC THEN CALL(FSYS,LCP)
                          ELSE ASSIGNMENT(LCP)
                        END;
"&&"          BEGINSY:  BEGIN  STMTNEST := STMTNEST + 1;  INSYMBOL;
"&&"                      COMPOUNDSTATEMENT;  STMTNEST := STMTNEST - 1;  END;
              GOTOSY:   BEGIN INSYMBOL; GOTOSTATEMENT END;
              IFSY:     BEGIN INSYMBOL; IFSTATEMENT END;
"&&"          CASESY:   BEGIN   STMTNEST := STMTNEST + 1;  INSYMBOL;
"&&"                      CASESTATEMENT;  STMTNEST := STMTNEST - 1  END;
              WHILESY:  BEGIN INSYMBOL; WHILESTATEMENT END;
"&&"          REPEATSY: BEGIN   STMTNEST := STMTNEST + 1;  INSYMBOL;
"&&"                      REPEATSTATEMENT;  STMTNEST := STMTNEST - 1  END;
              FORSY:    BEGIN INSYMBOL; FORSTATEMENT END;
              WITHSY:   BEGIN INSYMBOL; WITHSTATEMENT END
            END;
            IF NOT (SY IN [SEMICOLON,ENDSY,ELSESY,UNTILSY]) THEN
              BEGIN ERROR(6); SKIP(FSYS) END
          END
      END (*STATEMENT*) ;

"&&" PROCEDURE FRTPARMS;
"&&"   (* THIS BORING PROCEDURE GENERATES DUMMY ROUTINES
"&&"      TO REPLACE FORTRAN ROUTINES PASSED AS PROC. PARAMETERS  *)
"&&"   VAR  PT, LOCPAR: INTEGER;  LLC, LCM: ADDRRANGE;  LCP1: CTP;
"&&"        FNAME: ALPHA;
"&&"   BEGIN
"&&"     LEVEL := LEVEL + 1;  OLDIC := IC;
"&&"     WHILE FRTPARHD <> NIL DO
"&&"       WITH FRTPARHD@ DO
"&&"         BEGIN  IC := 0;
"&&"           FRTRN := FALSE;  PT := PROCTYPE(FRTPARHD);
"&&"           FNAME := NAME;  MKNAME( FNAME, PFNAME, FALSE );
"&&"           WRITELN(PRR,FNAME:8, MN(/32/) (*ENT*), CHR(PT):2, ',',
"&&"              LEVEL:1, ',L', SEGSIZE:1, NAME:14, ',', SAVEREGS:1, ',',
"&&"              ASSEMBLE:1, ',', GET_STAT:1, ',', ASMVERB:1, ',',
"&&"              DEBUG_LEV:1, ',', PFNAME:1 );
"&&"           WRITELN(QRR,'#BGN    ', NAME, LEVEL:4 );
"&&"           LCP1 := PRMPTR;  LC := LCAFTMST + FPSAVEAREA;
"&&"           WHILE LCP1 <> NIL DO
"&&"             WITH LCP1@ DO
"&&"               BEGIN
"&&"                 IF KLASS = VARS THEN
"&&"                   IF IDTYPE <> NIL THEN
"&&"                     BEGIN
"&&"                       IF VKIND = FORMAL THEN LCM := VADDR + PTRSIZE
"&&"                       ELSE LCM := VADDR + IDTYPE@.SIZE;
"&&"                       IF LCM > LC THEN LC := LCM;
"&&"                     END;
"&&"                 LCP1 := NEXT
"&&"               END;
"&&"           ALIGN( LC, PTRSIZE );  LLC := LC;  LCP1 := PRMPTR;
"&&"           WHILE LCP1 <> NIL DO
"&&"             WITH LCP1@ DO
"&&"               BEGIN
"&&"                 IF KLASS = VARS THEN
"&&"                   IF IDTYPE <> NIL THEN
"&&"                     BEGIN
"&&"                       IF VKIND = FORMAL THEN
"&&"                         GEN3(54(*LOD*),ORD('A'),LEVEL,VADDR)
"&&"                       ELSE
"&&"                         GEN2(50(*LDA*),LEVEL,VADDR);
"&&"                       GEN3(56(*STR*),ORD('A'),LEVEL,LLC);
"&&"                       LLC := LLC + PTRSIZE;
"&&"                     END;
"&&"                 LCP1 := NEXT;
"&&"               END;
"&&"           FRTRN := TRUE;
"&&"           LOCPAR := (LLC - LC) DIV 2 + 1;
"&&"           PUTIC;  WRITELN(PRR, MN(/46/) (*CUP*), CHR(PROCTYPE(
"&&"                     FRTPARHD)):2, ',', LOCPAR:1, ',', EXTNAME, ',', LC:1 );
"&&"           IF KLASS = FUNC THEN
"&&"             GEN3( 56(*STR*), PT, LEVEL, FNCRSLT );
"&&"           GEN1( 42(*RET*), PT );
"&&"           GENDEF( SEGSIZE, LLC );
"&&"           WRITELN(QRR,'#PROC   ', NAME:IDLNGTH, ' ', PFNAME:1, ' ',
"&&"              FALSE:1, IC:6,LLC:8,' ',FALSE:1,' REF/MOD RATIO:', 0:4,
"&&"              0:6, 0.0:10);
"&&"           WRITELN(QRR,'#END');
"&&"           OLDIC := OLDIC + IC;
"&&"           FRTPARHD := NXTFWRD;
"&&"         END (* WHILE FRTPARHD <> NIL DO WITH ... *) ;
"&&"     LEVEL := LEVEL - 1;  IC := OLDIC;
"&&"   END  (* FRTPARMS *)  ;


    BEGIN (*BODY*)
"&&"  STMTNEST := 1;  LISTTAG := 'N';  PUTIC;
"&&"  IF FPROCP = MAINPROG THEN
"&&"    WRITELN(PRR, MN(/72/) (*BGN*), ' ', PROGNAME, ' ',
"DE"                TIME:8, ' ', DATE );
"&&"  WRITELN(PRR, FPROCP@.EXTNAME, MN(/32/) (*ENT*), CHR(PROCTYPE(FPROCP)):2,
"&&"    ',', LEVEL:1, ',L', SEGSIZE:1, FPROCP@.NAME:14, ',', SAVEREGS:1, ',',
"&&"    ASSEMBLE:1, ',', GET_STAT:1, ',', ASMVERB:1, ',', DEBUG_LEV:1, ',':1,
"&&"    FPROCP@.PFNAME:1 );
#     IC := IC + 1;  STIC := 0 ;     (* LENGTH OF STRING CONSTANTS *)
#
#     LOCAL_CALL := FALSE ;
#     VAR_REF := 0 ;  VAR_MOD := 0 ;
#     WRITELN(QRR, '#BGN    ', FPROCP@.NAME, LEVEL:4) ;
#
#
#     IF FPROCP = MAINPROG THEN  (* ENTERING MAIN BLOCK *)
        BEGIN
        WHILE FILEHEAD <> NIL DO
          BEGIN
            WITH FILEHEAD@ DO
               BEGIN
#                WITH FILIDPTR@ DO
#                  BEGIN
#                  GEN2(50(*LDA*),1,VADDR) ;
#                  GEN1(30(*CSP*),31(*SIO*)) ;
#
"@@"               IF VADDR >= FIRSTGVAR THEN  (* USER DEFINED FILES *)
"CM"                 BEGIN
"CM"                 NEW(CNSTPTR, STRG) ;
"CM"                 CNSTPTR@.SLNGTH := 8  (*OS NAME LENGTH*);
"CM"                 FOR I := 1 TO 8 DO CNSTPTR@.SVAL[I] := NAME[I] ;
"CM"                 GEN1(37(*LCA*), 0) ;
"@@"                 LLC1 := 0;   (* LENGTH CODE FOR A TEXT FILE *)
"@@"                 IF NOT COMPTYPES( IDTYPE, TEXTPTR ) THEN
"@@"                   IF IDTYPE <> NIL THEN
"@@"                     IF IDTYPE@.FILTYPE <> NIL THEN
"@@"                       LLC1 := IDTYPE@.FILTYPE@.SIZE;
"@@"                 GEN2( 51 (*LDC*), 1, LLC1 );  (* FILE COMP. SIZE *)
"CM"                 GEN1(30(*CSP*), 30(*FDF*)) ;
"CM"                 END
"CM"               ELSE  (* I.E. IF VADDR < FIRSTUSERF *)
#
"@@"                 BEGIN  I := 3;  (* CODE FOR RESET *)
"@@"                   IF FILIDPTR = OUTPUTPTR THEN I := 4  (* REWRITE *)
"@@"                   ELSE IF NAME[3] = 'R' THEN I := 4  (* REWRITE *);
"@@"                   GEN1( 30 (*CSP*), I  (* RES/REW *) )
"@@"                 END;
#                  GEN1(30(*CSP*),32(*EIO*)) ;
#                  END ;
               END;
          FILEHEAD := FILEHEAD@.NEXTFILE
          END;
"CT"    IF CTROPTION THEN
"CT"      BEGIN
"CT"      GENLABEL(CTRCNTLBL) ;   GENUJPFJP(38(*CTS*), CTRCNTLBL) ;
"CT"      END ;
        END; (* PROCESSING MAIN BLOCK *)
"CT"  FIRSTLN := LINECNT; CTRNO := CTRGEN;
"CT"  (*** COUNTER HERE ***)
      LCMAX := LC;

      (* COMPILE THE STATEMENTS WITHIN THIS BLOCK (BODY) *)

      REPEAT
        REPEAT STATEMENT(FSYS + [SEMICOLON,ENDSY])
        UNTIL NOT (SY IN STATBEGSYS);
        TEST := SY <> SEMICOLON;
        IF NOT TEST THEN INSYMBOL
      UNTIL TEST;

      IF SY = ENDSY THEN INSYMBOL ELSE ERROR(13);
"&&"  STMTNEST := 0;  LISTTAG := ' ';
      LLP := DISPLAY[TOP].FLABEL; (*TEST FOR UNDEFINED LABELS*)

      WHILE LLP <> NIL DO
        WITH LLP@ DO
          BEGIN
            IF NOT DEFINED THEN
              BEGIN
"&&"            PLCNT := PLCNT + 1;
#               WRITELN(OUTPUT,'**** UNDEF. LABEL:':23,LABVAL); ERROR(168) ;
              END;
            LLP := NEXTLAB
          END;

"CT"  CTREMIT(CTRPROC, CTRNO, FIRSTLN, 0, LINECNT);
"CT"  IF FPROCP = MAINPROG THEN            (* RESET COUNTERS *)
"CT"    BEGIN
"CT"    CTREMIT(CTRPROC, 0, 0, 0, 0); (* EOF FOR COUNTER TABLE *)
"CT"    IF ODD(CTRCNT) THEN  CTRCNT := CTRCNT+1 ;
"CT"    IF CTROPTION THEN  GENDEF(CTRCNTLBL, CTRCNT) ;
"CT"    END ;

#     GEN1(42(*RET*),PROCTYPE(FPROCP)); ALIGN(LCMAX,MXDATASZE) ;
#     IF PRCODE THEN GENDEF(SEGSIZE,LCMAX);
#
#   CALL_LVL[LOCAL_CALL] := CALL_LVL[LOCAL_CALL]+1 ;
#   WRITE(QRR, '#PROC   ',  FPROCP@.NAME:IDLNGTH, ' ', FPROCP@.PFNAME:1, ' ',
                  LOCAL_CALL:1,
#              ' ', IC+(STIC DIV 4):1, ' ', LCMAX:1, ' ', FLIPDEBUG:1,
#              ' REF/MOD RATIO:', VAR_MOD:4, VAR_MOD+VAR_REF:6) ;
#   IF (VAR_MOD+VAR_REF) = 0 THEN  WRITELN(QRR,0.0:10)
#   ELSE  WRITELN(QRR, VAR_MOD/(VAR_MOD+VAR_REF):10) ;
#   WRITELN(QRR, '#END') ;
#
#   OLDIC := OLDIC+ IC ;  IC := OLDIC ;  (* DISPLAY CUMULATIVE IC  *)
#   HP := TRUE;
"&&" IF FRTPARHD <> NIL THEN FRTPARMS;
"&&" IF FPROCP = MAINPROG THEN GEN0( 43(*STP*) );
    END (*BODY*) ;

  BEGIN (*BLOCK*)
"&&" IC := 0;  GENLABEL(SEGSIZE);  CONSTLC := -1;  FWRDPRCL := NIL;
"&&" DEC_ORDER := 0;
    REPEAT
"&&"  WHILE SY IN (/LABELSY,CONSTSY,TYPESY,VARSY/) DO
"&&"    BEGIN  LSY := SY;  INSYMBOL;
"&&"      CASE LSY OF
"&&"  LABELSY: BEGIN LABELDECLARATION;
"&&"                 IF DEC_ORDER >= 1 THEN EXTUSED := TRUE;  DEC_ORDER := 1;
"&&"           END;
"&&"  CONSTSY: BEGIN CONSTDECLARATION;
"&&"                 IF DEC_ORDER >= 2 THEN EXTUSED := TRUE;  DEC_ORDER := 2;
"&&"           END;
"&&"  TYPESY: BEGIN TYPEDECLARATION;
"&&"                IF DEC_ORDER >= 3 THEN EXTUSED := TRUE;  DEC_ORDER := 3;
"&&"          END;
"&&"  VARSY: BEGIN VARDECLARATION;
"&&"               IF DEC_ORDER >= 4 THEN EXTUSED := TRUE;  DEC_ORDER := 4;
"&&"         END;
"&&"      END;
"&&"    END;
"&&"  IF CONSTLC >= 0 THEN  (* A CONSTANTS BLOCK WAS GENERATED *)
"&&"    BEGIN  CONSTLC := -1;
"&&"      WRITELN(PRR, MN(/75/) );
"&&"    END;
"&&"  IF DEBUG_LEV > 0 THEN PRNTSYMBL( NIL );  (* PRINT HEAP TYPE DEFNS. *)
"&&"  WHILE SY IN (/PROCSY,FUNCSY/) DO
"&&"    BEGIN  LSY := SY;  INSYMBOL;  PROCDECLARATION(LSY)  END;
      IF SY <> BEGINSY THEN
        BEGIN ERROR(18); SKIP(FSYS) END
    UNTIL SY IN STATBEGSYS;
    IF SY = BEGINSY THEN INSYMBOL ELSE ERROR(17);
"&&" WHILE FWRDPRCL <> NIL DO
"&&"   BEGIN  WRITELN( '**** MISSING FORWARD DECLARED PROCEDURE:':50,
"&&"                   FWRDPRCL@.NAME:14 );
"&&"          PLCNT := PLCNT + 1;
"&&"          FWRDPRCL := FWRDPRCL@.NXTFWRD
"&&"   END;
    REPEAT BODY(FSYS + [CASESY]);
      IF SY <> FSY THEN
        BEGIN ERROR(6); SKIP(FSYS + [FSY]) END
    UNTIL (SY = FSY) OR (SY IN BLOCKBEGSYS);
  END (*BLOCK*) ;


  PROCEDURE PROGRAMME(FSYS:SETOFSYS);
#   VAR   LFPTR: FRECPTR ;   LCP : CTP ;
"&&"      I, J: INTEGER;
  BEGIN
#   CALL_LVL[FALSE] := 0 ;  CALL_LVL[TRUE] := 0 ;
    IF SY = PROGSY THEN
#     BEGIN INSYMBOL; IF SY <> IDENT THEN ERROR(2); PROGNAME := ID ; INSYMBOL;
        IF NOT (SY IN [LPARENT,SEMICOLON]) THEN ERROR(14);
        IF SY = LPARENT  THEN
"@@"      BEGIN  PRTERR := FALSE;  (* IGNORE BAD PROG. PARMS *)
            REPEAT INSYMBOL;
              IF SY = IDENT THEN
#               BEGIN  SEARCHID([VARS], LCP) ;
"@@"            IF LCP <> NIL THEN
"@@"              IF LCP@.IDTYPE = TEXTPTR THEN
#                 BEGIN  NEW(LFPTR);
#                 WITH LFPTR@ DO
#                   BEGIN  FILIDPTR := LCP ;  NEXTFILE := FILEHEAD ;
#                   END;
#                 FILEHEAD := LFPTR;
#                 END ;
                INSYMBOL;
                IF NOT ( SY IN [COMMA,RPARENT] ) THEN ERROR(20)
                END
              ELSE ERROR(2)
            UNTIL SY <> COMMA;
            IF SY <> RPARENT THEN ERROR(4);
"@@"        PRTERR := TRUE;
            INSYMBOL
          END;
        IF SY <> SEMICOLON THEN ERROR(14)
        ELSE INSYMBOL;
      END;

"&&" NEW( MAINPROG, PROC, DECLARED );
"&&" WITH MAINPROG@ DO
"&&"   BEGIN  NAME := '$MAINBLK    ';  EXTNAME := '$MAINBLK';  PFNAME := 0;
"&&"          IDTYPE := NIL;  FWDECL := FALSE;  PFLEV := 0;  KLASS := PROC;
"&&"          PFDECKIND := DECLARED;  NEXT := NIL;  NEXT_IN_BKT := NIL;
"&&"          DECL_LEV := 0;  FRTRN := FALSE;  EXTRN := FALSE;
"&&"          IF XLINK THEN
"&&"            BEGIN  EXTRN := TRUE;  EXTNAME(/1/) := '#' END;
"&&"   END;
"E" IF DEBUG_LEV > 0 THEN
"E"     WRITELN(QRR,'% $MAINBLK  0');

"&&" REPEAT BLOCK(FSYS,PERIOD,MAINPROG);
       IF SY <> PERIOD THEN ERROR(21)
     UNTIL SY = PERIOD ;
#   WRITELN(QRR,'#HLT  CALL_RATIO', CALL_LVL[TRUE]:4, CALL_LVL[FALSE]:4,
#                  CALL_LVL[TRUE]+CALL_LVL[FALSE]:4) ;
#   IF ERRINX > 0 THEN  PRINTERROR ;
"SY" IF GET_STAT THEN
"SY"   BEGIN   (* PRINT SYMBOL TABLE STATISTICS *)
"SY"     WRITELN(QRR,'&SYT1 ',FENT_CNT:1,' ',SF_CNT:1,' ',SF_TOT:1,
"SY"             ' ',WE_CNT:1,' ',RE_CNT:1,' ',WS_CNT:1);
"SY"     WRITE(QRR,'&SYT2');
"SY"     FOR I:=0 TO MAXLEVEL DO WRITE(QRR,' ',PROC_CNT[I]:1);
"SY"     WRITELN(QRR);  WRITE(QRR,'&SYT3');
"SY"     FOR I:=0 TO MAXLEVEL DO WRITE(QRR,' ',ENT_CNT[I]:1);
"SY"     FOR I := 0 TO MAXLEVEL DO
"SY"       BEGIN  WRITELN(QRR);  WRITE(QRR,'&SYT4');
"SY"         FOR J:= 0 TO DISPLIMIT DO WRITE(QRR,' ',LU_CNT[I,J]:1);
"SY"       END;
"SY"     FOR I := 1 TO 10 DO
"SY"       BEGIN  WRITELN(QRR);  WRITE(QRR,'&SYT5');
"SY"         FOR J:=1 TO 10 DO WRITE(QRR,' ',WLU_CNT[I,J]:1);
"SY"       END;
"SY"   END;
  END (*PROGRAMME*) ;


  PROCEDURE ENTERSTDTYPES;
"&&" CONST
"&&"   INTTYP: STRUCTURE = (INTSIZE, INTSIZE, SCALAR, STANDARD);
"&&"   REALTYPE: STRUCTURE = (REALSIZE, REALSIZE, SCALAR, STANDARD);
"&&"   CHARTYPE: STRUCTURE = (CHARSIZE, CHARSIZE, SCALAR, STANDARD);
"&&"   BOOLTYPE: STRUCTURE = (BOOLSIZE, BOOLSIZE, SCALAR, DECLARED, NIL);
"&&"   NILTYPE:  STRUCTURE = (PTRSIZE, PTRSIZE, POINTER, NIL);
"&&"   TEXTTYPE: STRUCTURE = (0, PTRSIZE, FILES, NIL);
"&&"   ALFATYPE: STRUCTURE = (ALFALNGTH, CHARSIZE, ARRAYS, NIL, NIL);
"&&"   ALFAINX:  STRUCTURE = (INTSIZE, INTSIZE, SUBRANGE, NIL,
"&&"                          (TRUE,1), (TRUE,ALFALNGTH));
"&&"   UTYP:  IDENTIFIER = (BLANKID, NIL, NIL, NIL, 0, TYPES);
"&&"   UCST:  IDENTIFIER = (BLANKID, NIL, NIL, NIL, 0, KONST, (TRUE, 1));
"&&"   UVAR:  IDENTIFIER = (BLANKID, NIL, NIL, NIL, 0, VARS, ACTUAL, 0, 0);
"&&"   UFLD:  IDENTIFIER = (BLANKID, NIL, NIL, NIL, 0, FIELD, 0, NIL);
"&&"   UPF :  IDENTIFIER = (BLANKID, NIL, NIL, NIL, 0, PROC, DECLARED,
"&&"                        0, 0, NIL, NIL, ACTUAL, FALSE, FALSE, FALSE,
"&&"                        '$UNK_PF ');
"&&"   UREC:  STRUCTURE =  (1, 1, RECORDS, NIL, NIL, 0, 0);
    VAR SP: STP;
    BEGIN                                                (*TYPE UNDERLYING:  *)
                                                         (*****************  *)

"&&"  NEW(INTPTR);  INTPTR@ := INTTYP;                  (*INTEGER*)
"&&"  NEW(REALPTR);  REALPTR@ := REALTYPE;              (*REAL*)
"&&"  NEW(CHARPTR);  CHARPTR@ := CHARTYPE;              (*CHAR*)
"&&"  NEW(BOOLPTR);  BOOLPTR@ := BOOLTYPE;              (*BOOLEAN*)
"&&"  NEW(NILPTR);  NILPTR@ := NILTYPE;                 (*NIL*)
"&&"  NEW(TEXTPTR);  TEXTPTR@ := TEXTTYPE;              (*TEXT*)
      WITH TEXTPTR@ DO
        BEGIN FILTYPE := CHARPTR; SIZE := CHARSIZE+FILHDRSIZE END;
"&&"  NEW(ALFAPTR);  ALFAPTR@ := ALFATYPE;              (*ALFA*)
      WITH ALFAPTR@ DO
"&&"    BEGIN  AELTYPE := CHARPTR;
"&&"          NEW(INXTYPE);  INXTYPE@ := ALFAINX;
        END ;
"&&"  NEW(UTYPPTR);  UTYPPTR@ := UTYP;
"&&"  NEW(UVARPTR);  UVARPTR@ := UVAR;
"&&"  NEW(UFLDPTR);  UFLDPTR@ := UFLD;
"&&"  NEW(UPRCPTR);  UPRCPTR@ := UPF;  GENLABEL(UPRCPTR@.PFNAME);
"&&"  NEW(UFCTPTR);  UFCTPTR@ := UPF;  GENLABEL(UFCTPTR@.PFNAME);
"&&"  NEW(SP);       SP@      := UREC; UFLDPTR@.OWNER := SP;
  END (*ENTERSTDTYPES*) ;

  PROCEDURE ENTSTDNAMES;
"@@" VAR CP,CP1: CTP; I,J: INTEGER;
"&&" CONST
"&&"     NA: ARRAY[1..NPDW] OF ALPHA =
"&&"         ('FALSE       ', 'TRUE        ', '            ', 'PAGE        ',
"&&"          'GET         ', 'PUT         ', 'RESET       ', 'REWRITE     ',
"&&"          'READ        ', 'WRITE       ', 'PACK        ', 'UNPACK      ',
"&&"          'NEW         ', 'RELEASE     ', 'READLN      ', 'WRITELN     ',
"&&"          'MARK        ', 'TRAP        ', 'EXIT        ', 'ABS         ',
"&&"          'SQR         ', 'TRUNC       ', 'ROUND       ', 'ORD         ',
"&&"          'CHR         ', 'PRED        ', 'SUCC        ', 'CLOCK       ',
"&&"          'EOF         ', 'EOLN        ', 'ODD         ', 'EOL         ',
"&&"          'EOT         ', 'TRACE       ', '            ', '            ',
"&&"          '            ', '            ', 'INPUT       ', 'OUTPUT      ',
"&&"          'PRD         ', 'PRR         ', 'QRD         ', 'QRR         ',
"&&"          'DATE        ', 'TIME        ', 'MESSAGE     ', 'SKIP        ',
"&&"          'LINELIMIT   ', 'CARD        ', 'EXPO        ', 'SIN         ',
"&&"          'COS         ', 'EXP         ', 'SQRT        ', 'LN          ',
"&&"          'ARCTAN      '  );
"&&"  XNA: ARRAY(/52..57/) OF ARRAY(/1..EXTNAMSZ/) OF CHAR =
"&&"         ('DSIN    ', 'DCOS    ', 'DEXP    ', 'DSQRT   ',
"&&"          'DLOG    ', 'DATAN   ' );

  BEGIN                                                       (*NAME:         *)
                                                              (******         *)
    NEW(CP,TYPES);                                            (*INTEGER       *)
    WITH CP@ DO
      BEGIN NAME := 'INTEGER     '; IDTYPE := INTPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);                                            (*REAL          *)
    WITH CP@ DO
      BEGIN NAME := 'REAL        '; IDTYPE := REALPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);                                            (*CHAR          *)
    WITH CP@ DO
      BEGIN NAME := 'CHAR        '; IDTYPE := CHARPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);                                            (*BOOLEAN       *)
    WITH CP@ DO
      BEGIN NAME := 'BOOLEAN     '; IDTYPE := BOOLPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);                                            (*CHAR          *)
    WITH CP@ DO
      BEGIN NAME := 'TEXT        '; IDTYPE := TEXTPTR; KLASS := TYPES END;
    ENTERID(CP);
    NEW(CP,TYPES);                                            (*ALFA          *)
    WITH CP@ DO
      BEGIN NAME := 'ALFA        '; IDTYPE := ALFAPTR;  KLASS := TYPES END ;

    ENTERID(CP);
    NEW(CP,KONST);                                            (*MAXINT        *)
    WITH CP@ DO
      BEGIN NAME := 'MAXINT      '; IDTYPE := INTPTR;  KLASS := KONST;
      VALUES.IVAL := MAXINT;
      END;

    ENTERID(CP);
    CP1 := NIL;
    FOR I := 1 TO 2 DO
      BEGIN NEW(CP,KONST);                                    (*FALSE,TRUE    *)
        WITH CP@ DO
          BEGIN NAME := NA[I]; IDTYPE := BOOLPTR;
            NEXT := CP1; VALUES.IVAL := I - 1; KLASS := KONST
          END;
        ENTERID(CP); CP1 := CP
      END;
    BOOLPTR@.FCONST := CP;

    NEW(CP,KONST);                                             (*NIL          *)
    WITH CP@ DO
      BEGIN NAME := 'NIL         '; IDTYPE := NILPTR;
        NEXT := NIL; VALUES.IVAL := 0; KLASS := KONST
      END;
    ENTERID(CP);

#   FOR I := 39 TO 44 DO
      BEGIN NEW(CP,VARS);                                     (*INPUT,OUTPUT  *)
        WITH CP@ DO                                           (*PRD,PRR       *)
          BEGIN NAME := NA[I]; IDTYPE := TEXTPTR;             (*QRD,QRR       *)
            KLASS := VARS; VKIND := ACTUAL; NEXT := NIL; VLEV := 1;
"@@"        VADDR := FIRSTFILBUF+(I-39)*(FILHDRSIZE+PTRSIZE);
"@@"        IF I <= 40 THEN
"@@"          IF I = 39 THEN INPUTPTR := CP
"@@"            ELSE        OUTPUTPTR := CP;
          END;
        ENTERID(CP)
      END;
#
#   FOR I := 45 TO 46 DO                                  (*DATE, TIME        *)
#     BEGIN NEW(CP,VARS);
#       WITH CP@ DO
#         BEGIN NAME := NA[I]; IDTYPE := ALFAPTR;
#           KLASS := VARS; VKIND := ACTUAL; NEXT := NIL; VLEV := 1;
#           VADDR := TIMEDATELOC+(I-45)*ALFALNGTH  ;
#         END;
#       ENTERID(CP)
#     END;

#   NEW(CP, VARS);      (*OSPARM PTR                                          *)
#                       (*THE REST OF THIS CODE IS TO DEFINE:                 *)
#                       (* VAR:  OSPARM: @ RECORD                             *)
#                       (*                 LENGTH: INTEGER;                   *)
#                       (*                 STRING: ARRAY[1..64] OF CHAR       *)
#                       (*                 END;                               *)
#                       (*                                                    *)
#   WITH CP@ DO
#       BEGIN   NAME := 'OSPARM      ';
#       KLASS := VARS;  VKIND := ACTUAL;  NEXT := NIL;  VLEV := 1;
#       VADDR := OSPARMLOC;
#       ENTERID(CP);
#
#       NEW(IDTYPE, POINTER);
#       WITH IDTYPE@ DO
#         BEGIN   SIZE := PTRSIZE;  ALN := PTRSIZE;  FORM := POINTER;
#
#         NEW(ELTYPE, RECORDS);                      (*TYPE OF THE PARM RECORD*)
#         WITH ELTYPE@ DO
#           BEGIN   SIZE := INTSIZE+ STRGLNGTH*CHARSIZE;  ALN := PTRSIZE;
"&&"        FORM := RECORDS;  RECVAR := NIL;  FLD_DISP_LEV := -1;
"SY"        NO_FLDS := 2;
#
#           NEW(FSTFLD, FIELD);
#             WITH FSTFLD@ DO
#             BEGIN   NAME := 'LENGTH      ';  IDTYPE := INTPTR;   FLDADDR := 0;
#             KLASS := FIELD;
"&&"          TOP := TOP + 1;  (* FIELDS ENTERED AT HIGHER SCOPE *)
"&&"          ENTERID(FSTFLD);
"&&"          OWNER := CP@.IDTYPE@.ELTYPE;
#
#             NEW(NEXT, FIELD);
#             WITH NEXT@ DO
#               BEGIN   NAME := 'STRING      ';
#               FLDADDR := PTRSIZE;  NEXT := NIL;  KLASS := FIELD;
#
#               NEW(IDTYPE, ARRAYS);
#               WITH IDTYPE@ DO
#                 BEGIN  SIZE := STRGLNGTH*CHARSIZE;  ALN := CHARSIZE;
#                 FORM := ARRAYS;  AELTYPE := CHARPTR;
#
#                 NEW(INXTYPE, SUBRANGE);
#                 WITH INXTYPE@ DO
#                   BEGIN  FORM := SUBRANGE;  RANGETYPE := INTPTR;
#                   MIN.IVAL := 1;  MAX.IVAL := STRGLNGTH;
#                   END (*WITH INXTYPE...*);
#                 END (*WITH IDTYPE...*);
#
#               END (*WITH NEXT@...*);
"&&"          ENTERID(NEXT);
"&&"          NEXT@.OWNER := CP@.IDTYPE@.ELTYPE;
"&&"            TOP := TOP - 1;
#             END (*WITH FSTFLD ...*);
#
#           END (*WITH ELTYPE ...*);
#
#         END (*WITH IDTYPE ...*);
#
#       END (*WITH CP ...*);
#
    NEW(CP1,VARS);                     (*PARAMETER OF PREDECLARED FUNCTIONS   *)
    WITH CP1@ DO
      BEGIN NAME := BLANKID; IDTYPE := REALPTR; KLASS := VARS;
        VKIND := ACTUAL; NEXT := NIL; VLEV := 1;
"&&"    VADDR := LCAFTMST + FPSAVEAREA;
      END;

"&&" FOR I := 4 TO 34 DO                                  (*PAGE,GET...TRC*)
#     BEGIN NEW(CP,PROC,STANDARD);                         (*GET,PUT,RESET    *)
#       WITH CP@ DO                                        (*REWRITE,READ     *)
#         BEGIN NAME := NA[I]; IDTYPE := NIL;              (*WRITE,PACK       *)
#           NEXT := NIL; KEY := I - 4;                     (*UNPACK,PACK      *)
"@@"        IF I = 31 (*ODD*) THEN KEY := 33;
#           IF I <= 19 THEN KLASS := PROC ELSE KLASS := FUNC  ;
"&&"        IF I = 34 THEN KLASS := PROC;
#           PFDECKIND := STANDARD;                         (*READLN,WRITELN   *)
#                                                          (*MARK,RELEASE,TRAP*)
#         END;
#       ENTERID(CP)
#     END;

"&&"FOR I := 52 TO 57 DO    (* SIN,COS,EXP,SQRT,LN,ARCTAN *)
"@@"  BEGIN NEW(CP,FUNC,DECLARED);
"@@"    WITH CP@ DO
"@@"      BEGIN
"@@"        NAME := NA[I];  IDTYPE := REALPTR;  NEXT := NIL;
"SH"        PRMPTR := CP1;  FWDECL := FALSE;  EXTRN := FALSE;  FRTRN := TRUE;
"@@"        KLASS := FUNC;    PFDECKIND := DECLARED; PFKIND := ACTUAL;
"@@"        PFLEV := 0;       PFNAME := 0;
"&&"        EXTNAME := XNA[I];
"@@"      END;
"@@"    ENTERID(CP);
"@@"  END;
"@@"
"NH"FOR I := 47 TO 51 DO
"NH"  BEGIN NEW(CP,PROC,STANDARD);
"NH"    WITH CP@ DO
"NH"       BEGIN  NAME := NA[I];  IDTYPE := NIL; NEXT := NIL;
"NH"         IF I <= 49 THEN KLASS := PROC ELSE KLASS := FUNC;
"NH"         KEY := I-12;  PFDECKIND := STANDARD;
"NH"       END;
"NH"    ENTERID(CP);
"NH"  END;

#   NEW(CP,PROC,DECLARED);                          (*SNAPSHOT         *)
#     WITH CP@ DO
#       BEGIN   NAME := 'SNAPSHOT    ';  IDTYPE := NIL;  FRTRN := FALSE ;
#         FWDECL := FALSE ;  EXTRN := TRUE ; PFLEV := 0 ; PFNAME := 0 ;
#         KLASS := PROC; PFDECKIND := DECLARED ;   PFKIND := ACTUAL ;
"@@"      EXTNAME := 'SNAPSHOT' ;  NEXT := NIL;
#       END;
#     ENTERID(CP) ;
#
#   NEW(CP@.PRMPTR,VARS);               (* FIRST PARAMETER OF SNAPSHOT *)
"&&" NEW(CP1,VARS);                     (* SECOND PARAMETER OF SNAPSHOT *)
"&&" WITH CP1@ DO
"&&"   BEGIN  IDTYPE := INTPTR;  KLASS := VARS;  VKIND := ACTUAL;
"&&"     NEXT := NIL;  VLEV := 1;  VADDR := LCAFTMST+FPSAVEAREA+INTSIZE
"&&"   END;
#   WITH CP@.PRMPTR@ DO
#     BEGIN  IDTYPE := INTPTR; KLASS := VARS;  VKIND := ACTUAL;
#       NEXT := CP1;  VLEV := 1;  VADDR := LCAFTMST+FPSAVEAREA
#     END;
  END (*ENTSTDNAMES*) ;


  PROCEDURE INITSCALARS;
  BEGIN   FWPTR := NIL;       STMTNEST := 0;    LISTTAG := ' ';
#      LIST   := TRUE;        PRCODE    := TRUE;
#      PRTERR := TRUE;     ERRINX    := 0;   CONSTLC := -1;
#      HP        := FALSE;    IC     := 0;
#      INTLABEL  := 0;
#      FILEHEAD  := NIL;
#      LC        := FIRSTGVAR;             (*ADR. OF THE FIRST GLOBAL VARIABLE*)
#      (* NOTE IN THE ABOVE RESERVATION OF BUFFER STORE FOR TEXT FILES *)
#      OLDIC     := 0;      IC       := 0 ;       EOL       := TRUE;
#      LINECNT   := 0;      CH       := ' ';      CHCNT     := 0;
#      PAGECNT   := 0;      PLCNT    := PAGESIZE; (* GENERATES FIRST HEADLINE *)
#      LMARGIN   := 0;      RMARGIN  := 80;       BUFEND    := 81;
#      OLDLN     := 0;      MWARN    := FALSE;    LSTOP     := '#';
"&&"   GLOBTESTP := NIL;    OPEN_RECORD := NIL;   LASTLINELISTED := 0;
#      PROGNAME  := '$MAINBLK    ' ;
#      MXINT10   := MAXINT DIV 10;
"&&"   PROCLAB   := 0;      ERRORCNT := 0;         WARNCNT := 0;
"&&"   ASSEMBLE  := FALSE;  NESTCOMM  := FALSE;    ERRKIND := 'E';
#      SAVEREGS  := TRUE ;  SAVEFPRS := TRUE;
"&&"   DEBUG     := TRUE ;  DEBUG_LEV := 2 ;       ASSIGN    := FALSE  ;
"&&"   FLIPDEBUG := FALSE ; EXTUSED   := FALSE;    WARNING := TRUE;
"&&"   DOTFLG    := FALSE ; NOPACKING := FALSE;
#      PACKDATA  := FALSE ; XLINK    := FALSE ;   (*GENERATES UNIQUE NAMES *)
"&&"   PRNTTYPHD := NIL;    PRNTTYNO  := 0 ;
"&&"   FRTPARHD  := NIL;    XLABNO    := 0;
#      GET_STAT  := TRUE ;  ASMVERB  := FALSE ;
"CT"   CTRCNT    := 0 ;     CTROPTION:= FALSE ;
"SY"   FENT_CNT  := 0;      SF_CNT   := 0;       SF_TOT   := 0;
"SY"   WE_CNT    := 0;      RE_CNT   := 0;       WS_CNT := 0;
  END (*INITSCALARS*) ;


  PROCEDURE INITTABLES;
"&&" VAR K: BKT_RNG;  I,J: INTEGER;

    PROCEDURE RATORS;
      VAR I: INTEGER; CH: CHAR;
    BEGIN
      (* THE LIMIT OF THESE LOOP IS CHAR SET DEPENDENT *)
#     FOR CH := chr(0) TO chr(255) DO    UPSHIFT[CH] := CH ;            (*opp*)
"DE"  (* NOP following stmt, to avoid upshifting tilde char, which
"DE"     is in the range 'a'..'z': *)
"DE" (* FOR CH := 'a' TO 'z' DO UPSHIFT[CH] := CHR(ORD(CH) + 64) ; *)    (*UPL*)
      FOR I := 0 TO ORDCHMAX DO  SOP[CHR(I)] := ILLEGCH ;
      FOR CH := 'A' TO 'I' DO    SOP[CH] := ATOZCH ;
      FOR CH := 'J' TO 'R' DO    SOP[CH] := ATOZCH ;
      FOR CH := 'S' TO 'Z' DO    SOP[CH] := ATOZCH ;
      FOR CH := 'a' TO 'i' DO
         BEGIN  SOP[CH] := ATOZCH;
         UPSHIFT[CH] := CHR(ORD(CH) + ORD('A') - ORD('a')) END;         (*opp*)
      FOR CH := 'j' TO 'r' DO
         BEGIN  SOP[CH] := ATOZCH;
         UPSHIFT[CH] := CHR(ORD(CH) + ORD('A') - ORD('a')) END;         (*opp*)
      FOR CH := 's' TO 'z' DO
         BEGIN  SOP[CH] := ATOZCH;
         UPSHIFT[CH] := CHR(ORD(CH) + ORD('A') - ORD('a')) END;         (*opp*)
      FOR CH := '0' TO '9' DO    SOP[CH] := NUMCH ;
      SOP['"']  := DQUOTCH ;
"DE"  SOP[CHLBRACE]  := LBRACE ;
      SOP['#']  := SKIPCH ;
      SOP['$']  := DOLLARCH ;
      SOP[''''] := QUOTCH ;
      SOP['(']  := LPARCH ;
      SOP[')']  := SPECH ;
      SOP[',']  := SPECH ;
      SOP['.']  := DOTCH ;
      SOP[':']  := COLONCH ;
      SOP[';']  := SPECH ;
      SOP['@']  := SPECH ;
      SOP['[']  := SPECH ;
      SOP['Ý']  := SPECH ;
      SOP[']']  := SPECH ;
      SOP['^']  := SPECH ;
      SOP['_']  := UNDSCH ;
      SOP['+'] := PLUS; SOP['-'] := MINUS;
      SOP['*'] := MUL;  SOP['/'] := RDIV;
      SOP['='] := EQOP;
      SOP['<'] := LTOP; SOP['>'] := GTOP;
#     SOP['Ý'] := OROP ;  SOP['&'] := ANDOP ;
"DE" (* Note: SSY array should be defined as full range of
        characters, but it's ok as is for now because it is
        currently indexed only for specific characters.
        It it were indexed by higher chars (e.g. backslash or
        curly brackets) in the future, its definition would
        have to change. Currently, SPECH does not include any
        of these higher chars. - D.E. 02feb2007 *)
"&&" SSY(/'+'/) := ADDOP;        SSY(/'-'/) := ADDOP;
"&&" SSY(/'*'/) := MULOP;        SSY(/'/'/) := MULOP;
"&&" SSY(/'('/) := LPARENT;      SSY(/')'/) := RPARENT;
"&&" SSY(/'['/) := LBRACK;       SSY(/']'/) := RBRACK;                  (*opp*)
"&&" SSY(/','/) := COMMA;        SSY(/':'/) := COLON;
"&&" SSY(/'Ý'/) := ADDOP;        SSY(/'&'/) := MULOP;
"&&" SSY(/'<'/) := RELOP;        SSY(/'>'/) := RELOP;
"&&" SSY(/'='/) := RELOP;        SSY(/'@'/) := ARROW;
"&&" (*SSY(/CHR(74)/) := ARROW;*)                                       (*opp*)
     SSY(/'^'/) := NOTSY;
"&&" SSY(/';'/) := SEMICOLON;    SSY(/'.'/) := PERIOD;
    END (*RATORS*) ;

  BEGIN (*INITTABLES*)
    RATORS;
"&&" FOR I := 0 TO MAXERRLOG DO  ERRLOG(/I/) := (//);  (*CLEAR ERROR LOG*)
"&&" FOR K := 0 TO MAX_BKT DO
"&&"   BUCKET[K] := NIL;
"SY"   FOR I := 0 TO MAXLEVEL DO
"SY"     BEGIN  PROC_CNT[I] := 0;  ENT_CNT[I] := 0;
"SY"      FOR J := 0 TO DISPLIMIT DO  LU_CNT[I,J] := 0;  END;
"SY"   FOR I := 1 TO 10 DO
"SY"     FOR J := 1 TO 10 DO  WLU_CNT[I,J] := 0;
"SY"   PROC_CNT[1] := 1;
  END (*INITTABLES*) ;


BEGIN  (*PASCALCOMPILER*)
  (*INITIALIZE*)
  (************)
  INITSCALARS;  INITTABLES;


  (*ENTER STANDARD NAMES AND STANDARD TYPES:*)
  (******************************************)

  LEVEL := 0; TOP := 0;
  WITH DISPLAY[0] DO
"&&" BEGIN  OCCUR := BLCK; FLABEL := NIL;  END;
  ENTERSTDTYPES;   ENTSTDNAMES;
  TOP := 1; LEVEL := 1;
  WITH DISPLAY[1] DO
"&&" BEGIN  OCCUR := BLCK; FLABEL := NIL;  END;
"SY" GET_STAT := FALSE;

  (*set options passed as parameter to the compiler*)
  (*************************************************)

  IF OSPARM <> NIL THEN
    WITH  OSPARM@  DO
      BEGIN
"DE"  CH "LINEBUF[1]" := CHLBRACE;  LINEBUF[2] := '$';
      IF pLENGTH > 64 THEN pLENGTH := 64;
      FOR CHCNT := 1 TO pLENGTH DO  LINEBUF[CHCNT+2] := pSTRING[CHCNT];
      (*THE REST OF THE LINE DOES NOT HAVE TO BE CLEARED BUT...*)
      FOR CHCNT := pLENGTH TO 77 DO   LINEBUF[CHCNT+3] := ' ';
"DE"  LINEBUF[pLENGTH+3] := CHRBRACE;  LINEBUF[pLENGTH+4] := '#';
      EOL := FALSE;  CHCNT := 1;  LASTCOL := pLENGTH+3;
      END (*WITH OSPARM .., IF OSPARM ...*);

  (*COMPILE:*)
  (**********)

# CTIME := CLOCK(0) ;
# (* FIRST HEADLINE PRINTED BY 'ENDOFLINE' *)
#
# INSYMBOL;
#
# PROGRAMME(BLOCKBEGSYS+STATBEGSYS-[CASESY]);
#
# (* PRINT POST COMPILATION MESSAGES *)
#
# GOODBYE;
#
# END. (*PASCALCOMPILER*)
++FILE PASCALN.OLDCOMP.SOURCE                       MEMB PAS2012  EXT PAS HEX -
program PASCALCOMPILER ( INPUT , OUTPUT , PRR , QRR ) ;

(********************************************************************)
(*$D-,N+                                                            *)
(*                                                                  *)
(*         S T A N F O R D   P A S C A L   C O M P I L E R          *)
(*                                                                  *)
(*                  MCGILL UNIVERSITY VERSION                       *)
(*                                                                  *)
(*                                                                  *)
(*         AUTHOR OF ORIGINAL PROGRAM:                              *)
(*                                                                  *)
(*              URS AMMANN                                          *)
(*              FACHGRUPPE COMPUTERWISSENSCHAFTEN                   *)
(*              EIDG. TECHNISCHE HOCHSCHULE                         *)
(*              CH-8006 ZUERICH                                     *)
(*                                                                  *)
(*                                                                  *)
(*         AUTHOR OF SECOND VERSION:                                *)
(*                                                                  *)
(*              KESAV NORI                                          *)
(*              COMPUTER GROUP                                      *)
(*              T.I.F.R.                                            *)
(*              HOMI BHABHA ROAD                                    *)
(*              BOMBAY - 400005                                     *)
(*              INDIA                                               *)
(*                                                                  *)
(*                                                                  *)
(*         AUTHOR OF THIRD VERSION (STANFORD PASCAL):               *)
(*                                                                  *)
(*              S. HAZEGHI                                          *)
(*              COMPUTATION RESEARCH GROUP                          *)
(*              STANFORD LINEAR ACCELERATOR CENTER                  *)
(*              STANFORD, CA. 94305.                                *)
(*                                                                  *)
(*                                                                  *)
(*         AUTHOR OF FOURTH VERSION (MCGILL PASCAL):                *)
(*                                                                  *)
(*              R. NIGEL HORSPOOL                                   *)
(*              SCHOOL OF COMPUTER SCIENCE                          *)
(*              MCGILL UNIVERSITY                                   *)
(*              MONTREAL  QUEBEC  H3A 2K6                           *)
(*                                                                  *)
(*==================================================================*)
(*                                                                  *)
(* 02FEB2007 - Changes by Dave Edwards to use hex codes C0,D0       *)
(*    (was 8B,9B) for EBCDIC brace characters (curly brackets).     *)
(*    New constants CHLBRACE and CHRBRACE defined.                  *)
(*    VERSION date left unchanged as MAY -82.                       *)
(*    Hex C0,D0 seem to be the codes used by most curr. software    *)
(*    such as tn3270 clients, Ascii-EBCDIC translate tables, etc.   *)
(*    and conform to the standard IBM-037 US code page.             *)
(*    See additional notes in file ccde:pascal_info.txt .           *)
(*  - Also, in INITTABLES procedure, set UPSHIFT to only upshift    *)
(*    lowercase chars (e.g. exclude tilde, which is in the range    *)
(*    a to z), and add comments re. definition of SSY array.        *)
(*    Note that curly brackets and backslash are within the         *)
(*    range A to Z in the EBCDIC character set.                     *)
(*  - Also fix spacing of text for BGN output record: change        *)
(*    TIME:9 to TIME:8. Was causing last char of year to be         *)
(*    truncated, in the info text at the start of $MAINBLK          *)
(*    csect in the object file.                                     *)
(*  - Source changes are identified by flag DE near beginning       *)
(*    of lines.                                                     *)
(*    (Write date of previous source file: 14sep1983.)              *)
(*                                                                  *)
(*==================================================================*)
(*                                                                  *)
(*  Oct.2011 - Extensions to the Compiler by Bernd Oppolzer         *)
(*             (berndoppolzer@yahoo.com)                            *)
(*                                                                  *)
(*    PASCAL 1982 ported to VM370 R6 on Hercules (from MUSIC/SP)    *)
(*                                                                  *)
(*    Summary of Changes:                                           *)
(*                                                                  *)
(*    - another substitute for brackets: (. .) - not only (/ /)     *)
(*                                                                  *)
(*    - substitute for pointer symbol: ->                           *)
(*                                                                  *)
(*    - comments like PL/1 and C: /* ... */                         *)
(*                                                                  *)
(*    - year 2000 problem fixed (still TIME DEC used in PASMONN)    *)
(*                                                                  *)
(*    - new loop control statements: BREAK and CONTINUE             *)
(*                                                                  *)
(*    - RETURN statement                                            *)
(*                                                                  *)
(*  to be done:                                                     *)
(*                                                                  *)
(*    - allow shorter String constants to be assigned               *)
(*      (padded with blanks)                                        *)
(*                                                                  *)
(*    - allow static definitions (local to procs and functions)     *)
(*                                                                  *)
(********************************************************************)



const VERSION = '10.2011' ;
      PAGESIZE = 55 ;

      (******************************************)
      (*MAX # OF LINES PER PAGE OF LISTING      *)
      (******************************************)

      MAXINT = 2147483647 ;
      MAXADDR = 16777215 ;
      SETMAX = 255 ;

      (******************************************)
      (*LARGEST POSSIBLE SET ELEMENT            *)
      (******************************************)

      SSETMAX = 63 ;

      (******************************************)
      (*LARGEST ELEMENT USED IN THIS CODE       *)
      (******************************************)

      BUFLEN = 122 ;

      (******************************************)
      (*MAX LINE LENGTH + 2                     *)
      (******************************************)

      INTSIZE = 4 ;
      HINTSIZE = 2 ;
      REALSIZE = 8 ;
      CHARSIZE = 1 ;
      MXDATASZE = 8 ;
      BOOLSIZE = 1 ;
      WORDSIZE = 4 ;

      (*****************************************)
      (* NUMBER OF BYTES PER WORD              *)
      (*****************************************)

      SETPACK = 32 ;

      (*****************************************)
      (* NUMBER OF SET ELEMENTS PER WORD       *)
      (*****************************************)

      MAXSETSIZE = 32 ;

      (*****************************************)
      (*  = (SETMAX+1) DIV SETPACK * WORDSIZE  *)
      (*****************************************)

      PTRSIZE = 4 ;
      FILHDRSIZE = 8 ;
      REALLNGTH = 20 ;

      (******************************************)
      (*STRING REPRESENTATION OF REAL NUMBERS   *)
      (******************************************)

      DIGMAX = 19 ;

      (******************************************)
      (*REALLNGTH-1                             *)
      (******************************************)

      IDLNGTH = 12 ;
      ALFALNGTH = 10 ;
      STRGLNGTH = 64 ;
      DISPLIMIT = 20 ;
      MAX_BKT = 58 ;

      (******************************************)
      (* HASH TABLE SIZE                        *)
      (******************************************)

      MAXLEVEL = 9 ;
      ORDCHMAX = 255 ;

      (******************************************)
      (*SIZE OF CHAR SET OF TARGET MACHINE      *)
      (******************************************)

      OPMAX = 76 ;

      (*****************)
      (* OPCODE RANGE  *)
      (*****************)

      MAXERRNR = 401 ;

      (******************************************)
      (*MAX VAL OF ERROR CODE                   *)
      (******************************************)

      MAXERRLOG = 8 ;

      (******************************************)
      (* > (MAXERRNR DIV SETMAX)                *)
      (******************************************)

      NRSW = 41 ;
      NRSW1 = 42 ;

      (************)
      (* NRSW + 1 *)
      (************)

      NSPROC = 36 ;

      (******************************************)
      (* # OF STANDARD PROCS                    *)
      (******************************************)

      NPDW = 57 ;

      (******************************************)
      (* # OF PREDEFINED WORDS                  *)
      (******************************************)

      CTRMAX = 16384 ;
      EXTNAMSZ = 8 ;

      (*****************************************)
      (* EXTERNAL NAME LENGTH                  *)
      (*SAVE AREAS, FUNCTION RETURN VALUE SPAC *)
      (*E, DISPLAY AREA, ETC.                  *)
      (*****************************************)

      LCAFTMST = 80 ;
      FPSAVEAREA = 32 ;
      RUNCHKAREA = 96 ;
      DISPADR = 80 ;
      FNCRSLT = 72 ;
      DISPAREA = 40 ;
      FIRSTCONSTLC = 8 ;
      FIRSTFILBUF = 248 ;

      (******************************************)
      (* = LCAFTMST+RUNCHKAREA+DSPLYAREA        *)
      (******************************************)

      TIMEDATELOC = 328 ;

      (******************************************)
      (* LOCATION OF TIME/DATE PREDEF. VARS     *)
      (******************************************)

      OSPARMLOC = 348 ;

      (******************************************)
      (* LOCATION FOR 'OSPARM' PTR.             *)
      (******************************************)

      FIRSTGVAR = 352 ;

      (******************************************)
      (* FIRST USER DEFINED GLOBAL VARIABLE     *)
      (******************************************)

      CHLBRACE = '{' ;

      (******************************************)
      (* LEFT CURLY BRACKET: EBCDIC HEX CODE C0 *)
      (******************************************)

      CHRBRACE = '}' ;

      (*******************************************)
      (* RIGHT CURLY BRACKET: EBCDIC HEX CODE D0 *)
      (*---------------------------------------- *)
      (*------------------------------------     *)
      (*******************************************)



type

     (******************)
     (*BASIC SYMBOLS   *)
     (**************   *)
     (******************)


     SYMBOL = ( IDENT , INTCONST , REALCONST , STRINGCONST , NOTSY ,
              MULOP , ADDOP , RELOP , LPARENT , RPARENT , LBRACK ,
              RBRACK , COMMA , SEMICOLON , PERIOD , ARROW , COLON ,
              DOTDOT , BECOMES , LABELSY , CONSTSY , TYPESY , VARSY ,
              FUNCSY , PROGSY , PROCSY , SETSY , PACKEDSY , ARRAYSY ,
              RECORDSY , FILESY , FORWARDSY , BEGINSY , IFSY , CASESY ,
              REPEATSY , WHILESY , FORSY , WITHSY , GOTOSY , ENDSY ,
              ELSESY , UNTILSY , OFSY , DOSY , TOSY , DOWNTOSY , THENSY
              , FRTRNSY , EXTRNSY , OTHERWISESY , OTHERSY , BREAKSY ,
              CONTINUESY , RETURNSY ) ;
     OPERATOR = ( MUL , RDIV , ANDOP , IDIV , IMOD , PLUS , MINUS ,
                OROP , LTOP , LEOP , GEOP , GTOP , NEOP , EQOP , INOP ,
                NOOP , ATOZCH , NUMCH , QUOTCH , DQUOTCH , COLONCH ,
                DOTCH , LPARCH , RPARCH , LBRACE , UNDSCH , DOLLARCH ,
                SKIPCH , SPECH , ILLEGCH ) ;
     SETOFSYS = set of SYMBOL ;
     SSETINX = 1 .. 4 ;

     (***********************************)
     (* 4 = (SETMAX+1) DIV (SSETMAX+1)  *)
     (***********************************)

     SSETRANGE = set of 0 .. SSETMAX ;
     SETRANGE = array [ SSETINX ] of SSETRANGE ;

     (******************)
     (*CONSTANTS       *)
     (**********       *)
     (******************)

     CSTCLASS = ( REEL , PSET , STRG ) ;
     CSP = -> CONSTANT ;
     CONSTANT = record
                  case CSTCLASS of
                    REEL :
                      ( RVAL : packed array [ 1 .. REALLNGTH ] of CHAR
                        ) ;
                    PSET :
                      ( PLNGTH : 0 .. MAXSETSIZE ;
                        PVAL : SETRANGE ) ;
                    STRG :
                      ( SLNGTH : 0 .. STRGLNGTH ;
                        SVAL : packed array [ 1 .. STRGLNGTH ] of CHAR
                        )
                end ;
     VALU = record
              case BOOLEAN of
                TRUE :
                  ( IVAL : INTEGER ) ;
                FALSE :
                  ( VALP : CSP )
            end ;

     (*******************)
     (*DATA STRUCTURES  *)
     (****************  *)
     (*******************)

     LEVRANGE = 0 .. MAXLEVEL ;
     ADDRRANGE = 0 .. MAXADDR ;
     ALNRNG = 1 .. 8 ;
     LABELRNG = 0 .. 1000 ;
     BKT_RNG = 0 .. MAX_BKT ;
     STRUCTFORM = ( SCALAR , SUBRANGE , POINTER , POWER , ARRAYS ,
                  RECORDS , FILES , TAGFLD , VARIANT ) ;
     DECLKIND = ( STANDARD , DECLARED ) ;
     STP = -> STRUCTURE ;
     CTP = -> IDENTIFIER ;
     STRUCTURE = record
                   SIZE : ADDRRANGE ;
                   ALN : ALNRNG ;

     (******************)
     (*ALIGNMENT FACTOR*)
     (******************)

                   case FORM : STRUCTFORM of
                     SCALAR :
                       ( case SCALKIND : DECLKIND of
                           DECLARED :
                             ( FCONST : CTP ) ) ;
                     SUBRANGE :
                       ( RANGETYPE : STP ;
                         MIN , MAX : VALU ) ;
                     POINTER :
                       ( ELTYPE : STP ) ;
                     POWER :
                       ( ELSET : STP ) ;
                     ARRAYS :
                       ( AELTYPE , INXTYPE : STP ) ;
                     RECORDS :
                       ( FSTFLD : CTP ;
                         RECVAR : STP ;
                         NO_FLDS : 0 .. 1000 ;
                         FLD_DISP_LEV : - 1 .. DISPLIMIT ) ;
                     FILES :
                       ( FILTYPE : STP ) ;
                     TAGFLD :
                       ( TAGFIELDP : CTP ;
                         FSTVAR : STP ) ;
                     VARIANT :
                       ( NXTVAR , SUBVAR : STP ;
                         FSTSUBFLD : CTP ;
                         VARVAL : VALU )
                 end ;

     (******************)
     (*NAMES           *)
     (******           *)
     (******************)

     IDCLASS = ( TYPES , KONST , STRUCTKONST , VARS , FIELD , PROC ,
               FUNC ) ;
     SETOFIDS = set of IDCLASS ;
     IDKIND = ( ACTUAL , FORMAL ) ;
     ALPHA = packed array [ 1 .. IDLNGTH ] of CHAR ;
     IDENTIFIER = record
                    NAME : ALPHA ;
                    IDTYPE : STP ;
                    NEXT_IN_BKT , NEXT : CTP ;
                    DECL_LEV : LEVRANGE ;
                    case KLASS : IDCLASS of
                      KONST :
                        ( VALUES : VALU ) ;
                      STRUCTKONST :
                        ( SKOWNER : CTP ;
                          SKADDR : ADDRRANGE ) ;
                      VARS :
                        ( VKIND : IDKIND ;
                          VLEV : LEVRANGE ;
                          VADDR : ADDRRANGE ) ;
                      FIELD :
                        ( FLDADDR : ADDRRANGE ;
                          OWNER : STP ) ;
                      PROC , FUNC :
                        ( case PFDECKIND : DECLKIND of
                            STANDARD :
                              ( KEY : 0 .. NSPROC ) ;
                            DECLARED :
                              ( PFLEV : INTEGER ;
                                PFNAME : LABELRNG ;
                                PRMPTR , NXTFWRD : CTP ;
                                PFKIND : IDKIND ;
                                FWDECL , EXTRN , FRTRN : BOOLEAN ;
                                EXTNAME : array [ 1 .. EXTNAMSZ ] of
                                          CHAR ) )
                  end ;
     DISPRANGE = 0 .. DISPLIMIT ;
     HASH_TABLE = array [ BKT_RNG ] of CTP ;
     WHERE = ( BLCK , CREC , VREC , REC ) ;

     (******************)
     (*EXPRESSIONS     *)
     (************     *)
     (******************)

     ATTRKIND = ( CST , VARBL , EXPR ) ;
     VACCESS = ( DRCT , INDRCT , INXD , STKEXPR ) ;
     ATTR = record
              TYPTR ,

     (*********************************)
     (* TYPE AS AN EXPR. ON RUN-STACK *)
     (*********************************)


              BTYPE : STP ;

     (*********************************)
     (* TYPE AS A VARIABLE IN MEMORY  *)
     (*********************************)

              case KIND : ATTRKIND of
                CST :
                  ( CVAL : VALU ) ;
                VARBL :
                  ( case ACCESS : VACCESS of
                      DRCT :
                        ( VLEVEL : LEVRANGE ;
                          DPLMT : ADDRRANGE ) ;
                      INDRCT :
                        ( IDPLMT : ADDRRANGE ) ;
                      STKEXPR :
                        ( STKDPLMT , STKLEN : ADDRRANGE ) )
            end ;
     TESTP = -> TESTPOINTER ;
     TESTPOINTER = packed record
                            ELT1 , ELT2 : STP ;
                            LASTTESTP : TESTP
                          end ;

     (*************)
     (*LABELS     *)
     (*******     *)
     (*************)

     LBP = -> LABL ;
     LABL = record
              NEXTLAB : LBP ;
              LABVAL : INTEGER ;
              LABNAME , XNO : LABELRNG ;
              DEFINED : BOOLEAN
            end ;
     FRECPTR = -> FILEREC ;
     FILEREC = record
                 FILIDPTR : CTP ;
                 NEXTFILE : FRECPTR ;
               end ;
     PRNTTYLISTP = -> PRNTTYLIST ;
     PRNTTYLIST = record
                    ELT : STP ;
                    TNO : 0 .. 999 ;
                    NXT : PRNTTYLISTP
                  end ;
     ERRCODE = 0 .. MAXERRNR ;
     CTRRANGE = 0 .. CTRMAX ;
     CTRTYPE = ( CTRPROC , CTRLBL , CTRGOTO , CTRIF , CTRWHILE ,
               CTRREPEAT , CTRFOR , CTRCASE ) ;
     LOOPCTL = record
                 LEVEL : INTEGER ;
                 BREAKLABEL : LABELRNG ;
                 BREAKUSED : BOOLEAN ;
                 CONTLABEL : LABELRNG ;
                 CONTUSED : BOOLEAN ;
               end ;
     SUBRCTL = record
                 RETURNLABEL : LABELRNG ;
                 RETURNUSED : BOOLEAN ;
               end ;

     (*************************************************************** *)
     (***                                                             *)
     (*-------------------------------------------------------------- *)
     (*--                                                             *)
     (*************************************************************** *)
     (***                                                             *)



var

    (**************************************************************** *)
    (******                                                           *)
    (*RETURNED BY SOURCE PROGRAM SCANNER                              *)
    (*                                                                *)
    (*                                                                *)
    (*                                                                *)
    (*                                      INSYMBOL:                 *)
    (*                                                                *)
    (*                                                                *)
    (*                                                                *)
    (*                                      *********                 *)
    (*                                                                *)
    (**************************************************************** *)
    (******                                                           *)


    SY : SYMBOL ;

    (******************************************)
    (*LAST SYMBOL                             *)
    (******************************************)

    OP : OPERATOR ;

    (******************************************)
    (*CLASSIFICATION OF LAST SYMBOL           *)
    (******************************************)

    VAL : VALU ;

    (******************************************)
    (*VALUE OF LAST CONSTANT                  *)
    (******************************************)

    LNGTH : INTEGER ;

    (******************************************)
    (*LENGTH OF LAST STRING CONSTANT          *)
    (******************************************)

    PROGNAME , ID : ALPHA ;

    (******************************************)
    (*LAST IDENTIFIER (POSSIBLY TRUNCATED)    *)
    (******************************************)

    CH : CHAR ;

    (******************************************)
    (*LAST CHARACTER READ                     *)
    (******************************************)

    EOL : BOOLEAN ;

    (******************************************)
    (*END OF LINE FLAG                        *)
    (*COUNTERS:                               *)
    (**********                               *)
    (******************************************)

    CHCNT : 0 .. BUFLEN ;

    (******************************************)
    (*CHARACTER COUNTER                       *)
    (******************************************)

    CONSTLC ,

    (******************************************)
    (*DATA LOC. FOR STRUCTURED CONSTANTS      *)
    (******************************************)


    LC , IC , OLDIC , STIC : ADDRRANGE ;

    (******************************************)
    (*DATA LOCATION AND INSTRUCTION COUNTER   *)
    (******************************************)

    LINECNT , OLDLN , PLCNT , ERRLN , PAGECNT , LASTLINELISTED :
                                                   INTEGER ;

    (******************************************)
    (*SWITCHES:                               *)
    (**********                               *)
    (******************************************)

    HP ,

    (******************************************)
    (*HEADER PART                             *)
    (******************************************)


    PRTERR ,

    (******************************************)
    (*TO ALLOW FORWARD REFERENCES IN PTR TYPE *)
    (*DECLARATION BY SUPPRESSING ERROR MSG    *)
    (******************************************)


    DOTFLG ,

    (******************************************)
    (*ONE DOT ALREADY SEEN                    *)
    (******************************************)


    ASSIGN , PACKDATA ,

    (******************************************)
    (*ASSIGNMENT GOING ON,PACKING IN EFFECT   *)
    (******************************************)


    LIST , PRCODE ,

    (******************************************)
    (*LIST SOURCE, OUTPUT P-CODE              *)
    (******************************************)


    DEBUG , MWARN ,

    (******************************************)
    (*DEBUG CODE WANTED, MARGINS WARNING      *)
    (******************************************)


    FLIPDEBUG , NOPACKING ,

    (******************************************)
    (*DEBUG FLIPPED, PACKING SUPPRESSED       *)
    (******************************************)


    NESTCOMM , MUSIC ,

    (******************************************)
    (*NESTED COMMENTS ALLOWED, MUSIC SYSTEM   *)
    (******************************************)


    WARNING , EXTUSED ,

    (******************************************)
    (*WARNINGS WANTED, EXTENSIONS USED        *)
    (******************************************)


    ASSEMBLE , ASMVERB ,

    (******************************************)
    (*POSTPROCESSOR TRANSLATION, VERBOSE      *)
    (******************************************)


    XLINK , GET_STAT ,

    (******************************************)
    (*EXTERNAL LINKAGE, NAME CHANGE FLAG      *)
    (******************************************)


    SAVEREGS , SAVEFPRS : BOOLEAN ;
    LISTTAG : CHAR ;

    (******************************************)
    (* LISTING TAG, 'D'/'C'/'N'/' '           *)
    (******************************************)

    DEBUG_LEV : 0 .. 9 ;

    (******************************************)
    (*POINTERS:                               *)
    (**********                               *)
    (******************************************)

    INPUTPTR , OUTPUTPTR : CTP ;

    (************************************)
    (* PREDEFINED FILES INPUT + OUTPUT  *)
    (************************************)

    INTPTR , REALPTR , CHARPTR , BOOLPTR , NILPTR , TEXTPTR , ALFAPTR :
                                                   STP ;

    (******************************************)
    (*POINTERS TO ENTRIES OF STANDARD IDS     *)
    (******************************************)

    UTYPPTR , UCSTPTR , UVARPTR , UFLDPTR , UPRCPTR , UFCTPTR ,

    (************************)
    (*POINTERS TO ENTRIES F *)
    (*    OR UNDECLARED IDS *)
    (*                      *)
    (************************)


    MAINPROG ,

    (******************************************)
    (*POINTER TO $MAINBLK ENTRY               *)
    (******************************************)


    FRTPARHD ,

    (******************************************)
    (*POINTER TO LIST OF FORTRAN PROC PARMS   *)
    (******************************************)


    FWPTR : CTP ;

    (******************************************)
    (*HEAD OF CHAIN OF FORW DECL TYPE IDS     *)
    (******************************************)

    FILEHEAD : FRECPTR ;

    (******************************************)
    (*HEAD OF CHAIN OF EXTERNAL FILES         *)
    (******************************************)

    OPEN_RECORD : STP ;

    (******************************************)
    (*CURRENT RECORD OPENED BY "WITH"         *)
    (******************************************)

    GLOBTESTP : TESTP ;

    (******************************************)
    (*LAST TESTPOINTER                        *)
    (******************************************)

    PRNTTYPHD : PRNTTYLISTP ;

    (******************************************)
    (*LIST OF HEAP STORAGE ITEMS FOR DEBUG    *)
    (******************************************)

    PRNTTYNO : 0 .. 999 ;

    (******************************************)
    (*BOOKKEEPING OF DECLARATION LEVELS:      *)
    (***********************************      *)
    (******************************************)

    LEVEL : LEVRANGE ;

    (******************************************)
    (*CURRENT STATIC LEVEL                    *)
    (******************************************)

    STMTNEST : 0 .. 100 ;

    (******************************************)
    (*CURRENT STATEMENT NESTING               *)
    (******************************************)

    DISX ,

    (******************************************)
    (*LEVEL OF LAST ID SEARCHED BY SEARCHID   *)
    (******************************************)


    TOP : - 1 .. DISPLIMIT ;

    (******************************************)
    (*TOP OF DISPLAY                          *)
    (******************************************)

    DISPLAY :

    (******************************************)
    (*WHERE:   MEANS:                         *)
    (******************************************)


    array [ DISPRANGE ] of packed record

    (*******************************************)
    (*=BLCK:   ID IS VARIABLE ID               *)
    (*                                         *)
    (*******************************************)

                                    case OCCUR : WHERE of

    (******************************************)
    (*=CREC:   ID IS FIELD ID IN RECORD WITH  *)
    (******************************************)

                                      BLCK :
                                        ( FLABEL : LBP ) ;

    (******************************************)
    (*         CONSTANT ADDRESS               *)
    (******************************************)

                                      CREC :
                                        ( CLEV : LEVRANGE ;

    (******************************************)
    (*=VREC:   ID IS FIELD ID IN RECORD WITH  *)
    (******************************************)

                                          CDSPL : ADDRRANGE ) ;

    (******************************************)
    (*         VARIABLE ADDRESS               *)
    (******************************************)

                                      VREC :
                                        ( VDSPL : ADDRRANGE )
                                  end ;

    (******************************************)
    (* --> PROCEDURE WITHSTATEMENT            *)
    (*RUN-TIME PROFILER COUNTERS              *)
    (***************************              *)
    (******************************************)

    CTRCNT : CTRRANGE ;
    CTRCNTLBL : LABELRNG ;
    CTROPTION : BOOLEAN ;

    (******************************************)
    (*EXPRESSION COMPILATION:                 *)
    (************************                 *)
    (******************************************)

    GATTR : ATTR ;

    (******************************************)
    (*DESCRIBES THE EXPR CURRENTLY COMPILED   *)
    (******************************************)

    MXINT10 : INTEGER ;

    (******************************************)
    (*BUFFERS, READ ONLY TABLES ETC.          *)
    (******************************           *)
    (******************************************)

    LSTOP : CHAR ;

    (********************************)
    (*MARKS THE BEGINNING OF LINEBUF*)
    (********************************)

    LINEBUF : array [ 1 .. BUFLEN ] of CHAR ;

    (********************************)
    (*CURRENT LINE BUFFER           *)
    (********************************)

    LMARGIN , RMARGIN , LINELEN , BUFEND , LASTCOL : 0 .. BUFLEN ;

    (********************************)
    (*LEFT, RIGHT MARGINS ant PTRS  *)
    (********************************)

    INTLABEL , PROCLAB , XLABNO : LABELRNG ;
    CALL_LVL : array [ BOOLEAN ] of INTEGER ;
    SOP : packed array [ CHAR ] of OPERATOR ;
    UPSHIFT : array [ ' ' .. '9'

    (****************)
    (*SHOULD BE CHAR*)
    (****************)


              ] of CHAR ;

    (********)
    (*OP    *)
    (********)

    SSY : packed array [ ' ' .. '9' ] of SYMBOL ;
    BUCKET : HASH_TABLE ;

    (******************************************)
    (* SYMBOL TABLE USAGE STATISTICS          *)
    (* ****** ***** ***** **********          *)
    (******************************************)

    FENT_CNT , SF_CNT , SF_TOT ,

    (******************************************)
    (* # FIELD ENTRIES, SEARCHES, PRODUCT     *)
    (******************************************)


    WE_CNT , RE_CNT ,

    (******************************************)
    (* # "WITH" LOOKUPS, # RECORDS            *)
    (******************************************)


    WS_CNT : INTEGER ;

    (******************************************)
    (* # WITH STATEMENTS                      *)
    (******************************************)

    PROC_CNT , ENT_CNT : array [ LEVRANGE ] of INTEGER ;
    LU_CNT : array [ LEVRANGE , DISPRANGE ] of INTEGER ;
    WLU_CNT : array [ 1 .. 10 , 1 .. 10 ] of INTEGER ;

    (******************************************)
    (*ERROR MESSAGES:                         *)
    (****************                         *)
    (******************************************)

    ERRLOG : array [ 0 .. MAXERRLOG

    (**********************)
    (* = 400 DIV SSETMAX+1*)
    (**********************)


             ] of SSETRANGE ;
    ERRORCNT , WARNCNT ,

    (******************************************)
    (*ERRORS AND WARNINGS COUNTS              *)
    (******************************************)


    CTIME : INTEGER ;

    (******************************************)
    (*COMPILATION TIME                        *)
    (******************************************)

    ERRINX : 0 .. 10 ;

    (******************************************)
    (*NR OF ERRORS IN CURRENT SOURCE LINE     *)
    (******************************************)

    ERRKIND : CHAR ;

    (******************************************)
    (*KIND OF ERROR, 'E' / 'W' (WARNING)      *)
    (******************************************)

    ERRLIST : array [ 1 .. 10 ] of packed record
                                            NMR : 1 .. 401 ;
                                            KIND : CHAR ;
                                            POS : 1 .. 81
                                          end ;

    (*******************************************)
    (* STRUCTURE CONSTANTS, READ-ONLY TABLES   *)
    (* ********* *********  **** **** ******   *)
    (*******************************************)



const BLANKID : ALPHA = '            ' ;
      CONSTBEGSYS : SETOFSYS =
      [ ADDOP , INTCONST , REALCONST , STRINGCONST , IDENT ] ;
      SIMPTYPEBEGSYS : SETOFSYS =
      [ ADDOP , INTCONST , REALCONST , STRINGCONST , IDENT , LPARENT ]
        ;
      TYPEBEGSYS : SETOFSYS =
      [ ARROW , PACKEDSY , ARRAYSY , RECORDSY , SETSY , FILESY , ADDOP
        , INTCONST , REALCONST , STRINGCONST , IDENT , LPARENT ] ;
      TYPEDELS : SETOFSYS =
      [ ARRAYSY , RECORDSY , SETSY , FILESY , PACKEDSY ] ;
      BLOCKBEGSYS : SETOFSYS =
      [ LABELSY , CONSTSY , TYPESY , VARSY , PROCSY , FUNCSY , BEGINSY
        ] ;
      SELECTSYS : SETOFSYS =
      [ ARROW , PERIOD , LBRACK , LPARENT ] ;
      FACBEGSYS : SETOFSYS =
      [ INTCONST , REALCONST , STRINGCONST , IDENT , LPARENT , LBRACK ,
        NOTSY ] ;
      STATBEGSYS : SETOFSYS =
      [ BEGINSY , GOTOSY , IFSY , WHILESY , REPEATSY , FORSY , WITHSY ,
        CASESY , BREAKSY , CONTINUESY , RETURNSY ] ;

      (*********************************************************)
      (*   new reserved symbols in the 2011 version:           *)
      (*   break, return, continue                             *)
      (*********************************************************)

      RW : array [ 1 .. NRSW ] of ALPHA =
      ( 'IF          ' , 'DO          ' , 'OF          ' ,
        'TO          ' , 'IN          ' , 'OR          ' ,
        'END         ' , 'FOR         ' , 'VAR         ' ,
        'DIV         ' , 'MOD         ' , 'SET         ' ,
        'AND         ' , 'NOT         ' , 'THEN        ' ,
        'ELSE        ' , 'WITH        ' , 'GOTO        ' ,
        'CASE        ' , 'TYPE        ' , 'FILE        ' ,
        'BEGIN       ' , 'UNTIL       ' , 'WHILE       ' ,
        'ARRAY       ' , 'CONST       ' , 'LABEL       ' ,
        'BREAK       ' , 'REPEAT      ' , 'RECORD      ' ,
        'DOWNTO      ' , 'PACKED      ' , 'RETURN      ' ,
        'FORWARD     ' , 'PROGRAM     ' , 'FORTRAN     ' ,
        'EXTERNAL    ' , 'FUNCTION    ' , 'CONTINUE    ' ,
        'PROCEDURE   ' , 'OTHERWISE   ' ) ;
      FRW : array [ 1 .. 14 ] of 1 .. NRSW1 =

      (**********************************************************)
      (*  1  2  3   4   5   6   7   8   9  10  11  12  13  14   *)
      (**********************************************************)

      ( 1 , 1 , 7 , 15 , 22 , 29 , 34 , 37 , 40 , 42 , 42 , 42 , 42 ,
        42 ) ;
      RSY : array [ 1 .. NRSW ] of SYMBOL =
      ( IFSY , DOSY , OFSY , TOSY , RELOP , ADDOP , ENDSY , FORSY ,
        VARSY , MULOP , MULOP , SETSY , MULOP , NOTSY , THENSY , ELSESY
        , WITHSY , GOTOSY , CASESY , TYPESY , FILESY , BEGINSY ,
        UNTILSY , WHILESY , ARRAYSY , CONSTSY , LABELSY , BREAKSY ,
        REPEATSY , RECORDSY , DOWNTOSY , PACKEDSY , RETURNSY ,
        FORWARDSY , PROGSY , FRTRNSY , EXTRNSY , FUNCSY , CONTINUESY ,
        PROCSY , OTHERWISESY ) ;
      ROP : array [ 1 .. NRSW ] of OPERATOR =
      ( NOOP , NOOP , NOOP , NOOP , INOP , OROP , NOOP , NOOP , NOOP ,
        IDIV , IMOD , NOOP , ANDOP , NOOP , NOOP , NOOP , NOOP , NOOP ,
        NOOP , NOOP , NOOP , NOOP , NOOP , NOOP , NOOP , NOOP , NOOP ,
        NOOP , NOOP , NOOP , NOOP , NOOP , NOOP , NOOP , NOOP , NOOP ,
        NOOP , NOOP , NOOP , NOOP , NOOP ) ;
      MN : array [ 0 .. OPMAX ] of array [ 1 .. 4 ] of CHAR =
      ( ' ABI' , ' ABR' , ' ADI' , ' ADR' , ' AND' , ' DIF' , ' DVI' ,
        ' DVR' , ' SBR' , ' FLO' , ' FLT' , ' INN' , ' INT' , ' IOR' ,
        ' MOD' , ' MPI' , ' MPR' , ' NGI' , ' NGR' , ' NOT' , ' ODD' ,
        ' SBI' , ' DEC' , ' INC' , ' SQI' , ' SQR' , ' STO' , ' TRC' ,
        ' RND' , ' SCL' , ' CSP' , ' UNI' , ' ENT' , ' FJP' , ' POP' ,
        ' IND' , ' IXA' , ' LCA' , ' CTS' , ' CTI' , ' MOV' , ' MST' ,
        ' RET' , ' STP' , ' XJP' , ' CHK' , ' CUP' , ' EQU' , ' GEQ' ,
        ' GRT' , ' LDA' , ' LDC' , ' LEQ' , ' LES' , ' LOD' , ' NEQ' ,
        ' STR' , ' UJP' , ' NEW' , ' SAV' , ' RST' , ' ORD' , ' CHR' ,
        ' DEF' , ' LAB' , ' CRD' , ' XPO' , ' ASE' , ' SLD' , ' SMV' ,
        ' DFC' , ' CST' , ' BGN' , ' UXJ' , ' XLB' , ' END' , ' PAK' )
        ;
      SNA : array [ 0 .. NSPROC ] of array [ 1 .. 3 ] of CHAR =
      ( 'PAG' , 'GET' , 'PUT' , 'RES' , 'REW' , 'RDC' , 'WRI' , 'WRE' ,
        'WRR' , 'WRC' , 'WRS' , 'PAK' , 'RDB' , 'WRB' , 'RDR' , 'RDH' ,
        'RDY' , 'EOL' , 'EOT' , 'RDD' , 'WRD' , 'CLK' , 'WLN' , 'RLN' ,
        'RDI' , 'EOF' , 'ELN' , 'RDS' , 'TRP' , 'XIT' , 'FDF' , 'SIO' ,
        'EIO' , 'MSG' , 'SKP' , 'LIM' , 'TRA' ) ;

      (*********************************************************)
      (*-------------------------------------------------------*)
      (*********************************************************)




procedure ERROR ( FERRNR : ERRCODE ) ;

(*********************)
(*MAXERRNR DIV SETMAX*)
(*********************)


   var I : 0 .. 10 ;

   begin (* ERROR *)
     if ( ERRKIND <> 'W' ) or WARNING then
       begin
         if ERRINX >= 9 then
           begin
             FERRNR := 255 ;
             ERRINX := 10
           end (* then *)
         else
           ERRINX := ERRINX + 1 ;
         with ERRLIST [ ERRINX ] do
           begin
             KIND := ERRKIND ;
             NMR := FERRNR ;
             POS := CHCNT
           end (* with *) ;
         I := FERRNR DIV ( SSETMAX + 1 ) ;
         ERRLOG [ I ] := ERRLOG [ I ] + [ FERRNR MOD ( SSETMAX + 1 ) ]
                         ;
         if ERRKIND <> 'W' then
           ERRORCNT := ERRORCNT + 1
         else
           WARNCNT := WARNCNT + 1 ;
       end (* then *) ;
     ERRKIND := 'E' ;
   end (* ERROR *) ;



procedure PRINTLINE ;

   var DCN : ADDRRANGE ;

   begin (* PRINTLINE *)
     if PLCNT >= PAGESIZE then
       begin
         PAGECNT := PAGECNT + 1 ;
         PLCNT := 0 ;
         WRITELN ( OUTPUT , '1  LINE #  D/NEST  LVL' ,
                   '< STANFORD PASCAL, OPPOLZER VERSION OF ' : 44 ,
                   VERSION , ' >' , TIME : 14 , DATE , 'PAGE' : 8 ,
                   PAGECNT : 4 ) ;
         WRITELN ( OUTPUT , '------  ------  ---' : 22 , '---- ---' :
                   89 ) ;
         WRITELN ( OUTPUT ) ;
       end (* then *) ;
     if LINECNT > LASTLINELISTED then
       begin
         LASTLINELISTED := LINECNT ;
         PLCNT := PLCNT + 1 ;
         WRITE ( OUTPUT , LINECNT : 9 ) ;
         if LISTTAG = 'N' then
           DCN := STMTNEST
         else
           if LISTTAG = 'D' then
             DCN := LC
           else
             if LISTTAG = 'C' then
               DCN := CONSTLC
             else
               DCN := 0 ;
         if DCN > 0 then
           WRITE ( OUTPUT , DCN : 7 , LISTTAG , LEVEL : 3 )
         else
           WRITE ( OUTPUT , ' ' : 11 ) ;
         WRITELN ( OUTPUT , ') ' , LINEBUF : LINELEN ) ;
       end (* then *) ;
   end (* PRINTLINE *) ;



procedure PRINTERROR ;

   var LASTPOS , FREEPOS , CURRPOS , CURRNMR , F , K , DCN : INTEGER ;
       CURRKIND , LASTKIND : CHAR ;

   begin (* PRINTERROR *)
     PRINTLINE ;
     PLCNT := PLCNT + 2 ;

     (***************************)
     (* TWO LINES OF ERROR INFO *)
     (***************************)

     WRITE ( OUTPUT , '****' : 9 , ' ' : 13 ) ;
     LASTPOS := 0 ;
     FREEPOS := 1 ;
     LASTKIND := '?' ;
     for K := 1 to ERRINX do
       begin
         with ERRLIST [ K ] do
           begin
             CURRPOS := POS ;
             CURRNMR := NMR ;
             CURRKIND := KIND
           end (* with *) ;
         if CURRPOS = LASTPOS then
           if CURRKIND = LASTKIND then
             WRITE ( OUTPUT , ',' )
           else
             WRITE ( OUTPUT , CURRKIND )
         else
           begin
             LASTKIND := CURRKIND ;
             while FREEPOS < CURRPOS do
               begin
                 WRITE ( OUTPUT , ' ' ) ;
                 FREEPOS := FREEPOS + 1
               end (* while *) ;
             WRITE ( OUTPUT , CURRKIND ) ;
             LASTPOS := CURRPOS
           end (* else *) ;
         if CURRNMR < 10 then
           F := 1
         else
           if CURRNMR < 100 then
             F := 2
           else
             F := 3 ;
         WRITE ( OUTPUT , CURRNMR : F ) ;
         FREEPOS := FREEPOS + F + 1
       end (* for *) ;
     WRITELN ( OUTPUT ) ;
     ERRINX := 0 ;
     if ERRORCNT > 0 then
       PRCODE := FALSE ;
     if ERRLN > 0 then
       WRITELN ( OUTPUT , '****' : 9 ,
                 '  PREVIOUS ERROR/WARNING ON LINE -->' , ERRLN : 4 ) ;
     ERRLN := LINECNT ;
   end (* PRINTERROR *) ;



procedure ENDOFLINE ;

   label 10 ;

   var I : 1 .. 9 ;
       DCN : INTEGER ;

   begin (* ENDOFLINE *)
     if ERRINX > 0 then
       PRINTERROR ;
     READLN ( INPUT , LINEBUF ) ;
     LINELEN := BUFEND ;

     (*******************************************************)
     (*THIS WILL SPEED THINGS UP IF NO MARGIN IS SET/RESET  *)
     (*$D-  ... MUST BE IN EFFECT FOR THIS LOOP             *)
     (*******************************************************)

     repeat
       LINELEN := LINELEN - 1 ;
     until LINEBUF [ LINELEN ] <> ' ' ;

     (***********************************************************)
     (* IF NEEDED, DEBUG SWITCH SHOULD BE RESTORED HERE ---> $D+*)
     (***********************************************************)

     10 :
     if LINELEN > RMARGIN then
       begin
         MWARN := TRUE ;
         LASTCOL := RMARGIN
       end (* then *)
     else
       LASTCOL := LINELEN ;
     LINECNT := LINECNT + 1 ;
     if LIST then
       PRINTLINE ;
     if HP then
       begin
         IC := 0 ;
         LISTTAG := ' ' ;
         HP := FALSE
       end (* then *) ;
     LINEBUF [ LASTCOL + 1 ] := '#' ;

     (********************************************)
     (*TO STOP 'SKIPBLNK' + PROVIDE VALID EOL CH.*)
     (********************************************)

     CHCNT := LMARGIN ;
   end (* ENDOFLINE *) ;



procedure LISTMSGS ;

   var I , J : ERRCODE ;
       MSG : array [ 1 .. 64 ] of CHAR ;

   begin (* LISTMSGS *)
     WRITELN ( OUTPUT ) ;
     if ERRLN > 0 then
       begin
         WRITELN ( OUTPUT , '****' : 9 ,
                   '  LAST ERROR/WARNING ON LINE -->' , ERRLN : 4 ) ;
         WRITELN ( OUTPUT ) ;
       end (* then *) ;
     WRITELN ( OUTPUT ) ;
     WRITELN ( OUTPUT , '****' : 9 ,
               '  ERROR/WARNING CODES FOR THIS PROGRAM :' ) ;
     WRITELN ( OUTPUT ) ;
     RESET ( PRD ) ;
     J := 0 ;
     for I := 1 to MAXERRNR do
       if ( I MOD ( SSETMAX + 1 ) ) in ERRLOG [ I DIV ( SSETMAX + 1 ) ]
       then
         begin
           while ( not EOF ( PRD ) ) and ( I > J ) do
             READLN ( PRD , J , MSG ) ;
           if J = I then
             WRITELN ( '****' : 9 , J : 6 , MSG ) ;
         end (* then *) ;
   end (* LISTMSGS *) ;



procedure GOODBYE ;

   begin (* GOODBYE *)
     CTIME := ( CLOCK ( 0 ) - CTIME ) ;
     if PAGECNT = 0 then

     (***************************************)
     (* NO HEADING EVER PRINTED, DO ONE NOW *)
     (***************************************)

       WRITELN ( OUTPUT , '****' : 9 ,
                 'STANFORD PASCAL COMPILER, OPPOLZER VERSION OF ' : 50
                 , VERSION ) ;
     if not MUSIC then
       WRITELN ( OUTPUT ) ;
     if WARNING then
       begin
         if EXTUSED then
           WRITELN ( OUTPUT , '0' , '****' : 8 ,
                     '  WARNING: PASCAL EXTENSIONS USED.' ) ;
         if WARNCNT > 0 then
           WRITELN ( OUTPUT , '0' , '****' : 8 , WARNCNT : 8 ,
                     '  WARNING MESSAGE(S) ISSUED.' ) ;
         if MWARN then
           WRITELN ( OUTPUT , '0' , '****' : 8 ,
                     '  CONTENTS OF SOURCE LINES OUTSIDE  ' , LMARGIN :
                     1 , '..' , RMARGIN : 1 , '  MARGINS IGNORED.' ) ;
       end (* then *) ;
     if not MUSIC then
       WRITELN ( OUTPUT ) ;
     if ERRORCNT = 0 then
       WRITE ( OUTPUT , '****      NO' : 17 )
     else
       WRITE ( OUTPUT , '****' : 9 , ERRORCNT : 8 ) ;
     WRITELN ( OUTPUT , '  SYNTAX ERROR(S) DETECTED.' ) ;
     if not MUSIC then
       WRITELN ( OUTPUT ) ;
     WRITELN ( OUTPUT , '****' : 9 , LINECNT : 8 , '  LINE(S) READ, ' ,
               PROCLAB : 4 , ' PROCEDURE(S) COMPILED,' ) ;
     if not MUSIC then
       WRITELN ( OUTPUT ) ;
     WRITELN ( OUTPUT , '****' : 9 , OLDIC : 8 ,
               '  P_INSTRUCTIONS GENERATED,' , CTIME * 0.001 : 7 : 2 ,
               ' SECONDS IN COMPILATION.' ) ;
     if ERRORCNT > 0 then
       LISTMSGS ;
     EXIT ( ERRORCNT ) ;
   end (* GOODBYE *) ;



procedure FATALERROR ( CODE : ERRCODE ) ;

   begin (* FATALERROR *)
     ERROR ( CODE ) ;
     PRINTERROR ;
     if CODE <> 390 then
       WRITELN ( OUTPUT , '0    ****   FATAL ERROR - ' ,
                 'COMPILATION TERMINATED PREMATURELY.' ) ;
     GOODBYE ;
   end (* FATALERROR *) ;



procedure INSYMBOL ;

(**************************************************************)
(*                                                            *)
(*   READ NEXT BASIS SYMBOL OF SOURCE PROGRAM AND RETURN      *)
(*   ITS DESCRIPTION IN THE GLOBAL VARIABLES                  *)
(*   SY, OP, ID, VAL AND LNGTH                                *)
(*                                                            *)
(*------------------------------------------------------------*)
(*                                                            *)
(*   REWORKED 24.10.2011 - BERND OPPOLZER                     *)
(*                                                            *)
(*   ADDED THE FOLLOWING SYMBOL SPELLINGS:                    *)
(*                                                            *)
(*   (. AND .) AS ANOTHER POSSIBILITY FOR [ ] AND (/ /)       *)
(*                                                            *)
(*   -> AS AN ALTERNATIVE FOR @                               *)
(*                                                            *)
(*   COMMENTS ALSO LIKE THIS: /* ... COMMENT ... */           *)
(*                                                            *)
(**************************************************************)


   label 1 , 2 , 3 ;

   var I , K , STATE : INTEGER ;
       DIGIT : packed array [ 1 .. REALLNGTH ] of CHAR ;
       STRING : packed array [ 1 .. STRGLNGTH ] of CHAR ;
       LVP : CSP ;
       TEST , DIGSEEN : BOOLEAN ;


   procedure SKIPBLNK ;

   (******************************************************)
   (*   SKIP BLANKS, ENDOFLINE, AND (OPTIONAL) MARGIN,   *)
   (*   SKIPS AT LEAST ONE LINE                          *)
   (******************************************************)


      begin (* SKIPBLNK *)
        repeat
          if EOL then
            begin
              if EOF ( INPUT ) then
                FATALERROR ( 390 ) ;
              ENDOFLINE ;
            end (* then *) ;
          repeat
            CHCNT := CHCNT + 1 ;
          until LINEBUF [ CHCNT ] <> ' ' ;

        (********************************************)
        (*   NOTE THAT LINEBUF[LINELEN+1] <> ' '    *)
        (********************************************)

          EOL := CHCNT > LASTCOL ;
        until not EOL ;
        CH := LINEBUF [ CHCNT ] ;
      end (* SKIPBLNK *) ;


   procedure NEXTCH ;

      begin (* NEXTCH *)
        if EOL then
          begin
            if EOF ( INPUT ) then
              FATALERROR ( 390 ) ;
            ENDOFLINE ;
          end (* then *) ;
        CHCNT := CHCNT + 1 ;
        EOL := ( CHCNT > LASTCOL ) ;
        CH := LINEBUF [ CHCNT ] ;
      end (* NEXTCH *) ;


   procedure OPTIONS ( CCH : CHAR ) ;

   (***********************************)
   (*   CCH = COMMENT TERMINATOR CH   *)
   (***********************************)


      var SCH : CHAR ;
          OLDLIST : BOOLEAN ;
          TERMCH : CHAR ;


      function DECNUM : INTEGER ;

         var NUM : INTEGER ;

         begin (* DECNUM *)
           NUM := 0 ;
           NEXTCH ;
           while CH >= '0' do
             begin
               NUM := NUM * 10 + ORD ( CH ) - ORD ( '0' ) ;
               NEXTCH
             end (* while *) ;
           DECNUM := NUM
         end (* DECNUM *) ;


      begin (* OPTIONS *)
        if ( CCH = '/' ) or ( CCH = ')' ) then
          TERMCH := '*'
        else
          TERMCH := CHRBRACE ;
        repeat
          NEXTCH ;
          if CH in [ 'a' .. 'z' , 'A' .. 'Z' ] then
            begin
              SCH := UPSHIFT [ CH ] ;
              NEXTCH ;
              case SCH of
                'L' : begin
                        OLDLIST := LIST ;
                        LIST := CH <> '-' ;
                        if not OLDLIST then
                          if LIST then
                            PRINTLINE ;
                      end (* tag/ca *) ;
                'C' : PRCODE := CH <> '-' ;
                'E' : if LIST then
                        PLCNT := PAGESIZE ;
                'A' : ASSEMBLE := CH = '+' ;
                'M' : begin
                        if CH = '+' then
                          begin
                            LMARGIN := 0 ;
                            RMARGIN := 72 ;
                          end (* then *)
                        else
                          if CH = '-' then
                            begin
                              LMARGIN := 0 ;
                              BUFEND := BUFLEN ;
                              RMARGIN := BUFLEN ;
                            end (* then *)
                          else
                            if CH = '(' then
                              begin
                                LMARGIN := DECNUM - 1 ;
                                if LMARGIN < 0 then
                                  LMARGIN := 0 ;
                                if CH = ',' then
                                  RMARGIN := DECNUM
                                else
                                  RMARGIN := BUFLEN ;
                                if ( RMARGIN <= LMARGIN ) or ( RMARGIN
                                >= BUFLEN ) then
                                  RMARGIN := BUFLEN - 1 ;
                                BUFEND := BUFLEN ;
                              end (* then *)
                      end (* tag/ca *) ;
                'S' : SAVEREGS := CH <> '-' ;
                'F' : SAVEFPRS := CH <> '-' ;
                'D' : if CH >= '0' then
                        begin
                          DEBUG_LEV := ORD ( CH ) - ORD ( '0' ) ;
                          DEBUG := DEBUG_LEV >= 2 ;
                        end (* then *)
                      else
                        begin
                          DEBUG := CH <> '-' ;
                          DEBUG_LEV := ORD ( DEBUG ) * 2 ;
                        end (* else *) ;
                'V' : ASMVERB := CH = '+' ;
                'W' : WARNING := CH <> '-' ;
                'U' : GET_STAT := CH = '+' ;
                'P' : NOPACKING := CH = '-' ;
                'X' : begin
                        XLINK := CH = '+' ;

        (****************************************)
        (*   XLINK --> ALLOW '$' AS FIRST CH.   *)
        (****************************************)

                        if XLINK then
                          SOP [ '$' ] := ATOZCH ;
                      end (* tag/ca *) ;
                'K' : CTROPTION := CH = '+' ;
                'N' : NESTCOMM := CH = '+' ;
                'Z' : MUSIC := CH = '+' ;
              end (* case *) ;
              if CH <> TERMCH then
                if CH <> ',' then
                  NEXTCH ;
            end (* then *)
        until CH <> ','
      end (* OPTIONS *) ;


   procedure COMMENT ( CCH : CHAR ) ;

   (***********************************)
   (*   CCH = COMMENT TERMINATOR CH   *)
   (***********************************)


      var TERMCH : CHAR ;

      begin (* COMMENT *)
        if ( CCH = '/' ) or ( CCH = ')' ) then
          TERMCH := '*'
        else
          TERMCH := CHRBRACE ;

        (*****************************************)
        (*   SET TERMCH - EXPECTED COMMENT       *)
        (*   TERMINATING CHARACTER               *)
        (*****************************************)

        repeat
          if CH <> TERMCH then
            repeat
              if NESTCOMM then
                begin

        (*****************************************)
        (*   ONLY ALLOW NESTING OF COMMENTS      *)
        (*   OF SAME TYPE                        *)
        (*****************************************)

                  if CH = CHLBRACE then
                    if CCH = CHRBRACE then
                      begin
                        EOL := FALSE ;
                        COMMENT ( CHRBRACE )
                      end (* then *) ;
                  if CH = '(' then
                    if LINEBUF [ CHCNT + 1 ] = '*' then
                      if CCH = ')' then
                        begin
                          EOL := FALSE ;
                          NEXTCH ;
                          NEXTCH ;
                          COMMENT ( ')' ) ;
                        end (* then *) ;
                  if CH = '/' then
                    if LINEBUF [ CHCNT + 1 ] = '*' then
                      if CCH = '/' then
                        begin
                          EOL := FALSE ;
                          NEXTCH ;
                          NEXTCH ;
                          COMMENT ( '/' ) ;
                        end (* then *) ;
                end (* then *) ;
              if CHCNT > LASTCOL then
                begin
                  if EOF ( INPUT ) then
                    FATALERROR ( 390 ) ;
                  ENDOFLINE ;
                end (* then *) ;
              CHCNT := CHCNT + 1 ;
              CH := LINEBUF [ CHCNT ] ;
            until CH = TERMCH ;
          if CCH <> CHRBRACE then
            begin
              CHCNT := CHCNT + 1 ;
              CH := LINEBUF [ CHCNT ] ;
            end (* then *)
        until CH = CCH ;

        (*****************************************)
        (*   PREPARE FOR NEXT CALL TO 'NEXTCH'   *)
        (*****************************************)

        EOL := FALSE ;
      end (* COMMENT *) ;


   begin (* INSYMBOL *)
     1 :
     if CH = ' ' then
       SKIPBLNK ;
     case SOP [ CH ] of

     (*********************)
     (*   LETTER A TO Z   *)
     (*********************)

       ATOZCH :
         begin
           K := 0 ;
           ID := BLANKID ;
           repeat
             if K < IDLNGTH then
               begin
                 K := K + 1 ;
                 ID [ K ] := UPSHIFT [ CH ]
               end (* then *) ;
             NEXTCH
           until not ( SOP [ CH ] in [ ATOZCH , NUMCH , UNDSCH ,
           DOLLARCH ] ) ;
           for I := FRW [ K ] to FRW [ K + 1 ] - 1 do
             if RW [ I ] = ID then
               begin
                 SY := RSY [ I ] ;
                 OP := ROP [ I ] ;
                 goto 2
               end (* then *) ;
           SY := IDENT ;
           OP := NOOP ;
           2 :

         end (* tag/ca *) ;

     (*********************)
     (*   NUMBER 0 TO 9   *)
     (*********************)

       NUMCH : begin
                 OP := NOOP ;
                 K := 0 ;
                 SY := REALCONST ;
                 STATE := 0 ;
                 repeat
                   DIGSEEN := FALSE ;
                   3 :
                   K := K + 1 ;
                   if K <= DIGMAX then
                     DIGIT [ K ] := CH ;
                   NEXTCH ;
                   if SOP [ CH ] = NUMCH then
                     begin
                       DIGSEEN := TRUE ;
                       goto 3
                     end (* then *) ;
                   if DIGSEEN then
                     STATE := STATE + 1 ;
                   case STATE of

     (**************************************)
     (*   LEADING DIGIT SEQUENCE SCANNED   *)
     (**************************************)

                     0 , 1 : if CH = '.' then
                               STATE := 2
                             else
                               if CH = 'E' then
                                 STATE := 4
                               else
                                 if CH = 'e' then
                                   STATE := 4
                                 else
                                   begin
                                     SY := INTCONST ;
                                     STATE := 0
                                   end (* else *) ;

     (**********************************)
     (*   DECIMAL POINT JUST SCANNED   *)
     (*   if period follows, we have   *)
     (*   no float constant, but       *)
     (*   two dots.                    *)
     (*   if rparent follows, we have  *)
     (*   substitute for rbracket      *)
     (**********************************)

                     2 : if CH = '.' then
                           begin
                             SY := INTCONST ;
                             K := K - 1 ;
                             DOTFLG := TRUE ;
                             STATE := 0
                           end (* then *)
                         else
                           if CH = ')' then
                             begin
                               SY := INTCONST ;
                               K := K - 1 ;
                               DOTFLG := TRUE ;
                               STATE := 0
                             end (* then *)
                           else
                             if UPSHIFT [ CH ] = 'E' then
                               begin
                                 K := K - 1 ;
                                 STATE := 4
                               end (* then *)
                             else
                               STATE := - 1 ;

     (********************************************)
     (*   DIGIT SEQUENCE AFTER POINT JUST SEEN   *)
     (********************************************)

                     3 : if CH = 'E' then
                           STATE := 4
                         else
                           if CH = 'e' then
                             STATE := 4
                           else
                             STATE := 0 ;

     (*********************************)
     (*   EXPONENT SYMBOL JUST SEEN   *)
     (*********************************)

                     4 : if CH = '-' then
                           STATE := 6
                         else
                           if CH = '+' then
                             STATE := 6
                           else
                             STATE := - 1 ;

     (******************************************)
     (*   DIGIT STRING IN EXPONENT JUST SEEN   *)
     (******************************************)

                     5 , 7 : STATE := 0 ;

     (**********************************************)
     (*   BAD CHARACTER AFTER 'E+' OR 'E-' FOUND   *)
     (**********************************************)

                     6 : STATE := - 1 ;
                   end (* case *) ;
                 until STATE <= 0 ;

     (***********************************)
     (*   LEXICAL ERROR IN REAL CONST   *)
     (***********************************)

                 if STATE < 0 then
                   ERROR ( 201 ) ;
                 if SY = REALCONST then
                   begin
                     NEW ( VAL . VALP , REEL ) ;
                     with VAL . VALP -> do
                       begin
                         for I := 1 to REALLNGTH do
                           RVAL [ I ] := ' ' ;
                         if K <= DIGMAX then
                           for I := 2 to K + 1 do
                             RVAL [ I ] := DIGIT [ I - 1 ]
                         else
                           begin
                             ERROR ( 203 ) ;
                             UNPACK ( '0.0' , RVAL , 2 )
                           end (* else *)
                       end (* with *) ;
                   end (* then *)
                 else
                   begin
                     VAL . IVAL := 0 ;
                     if K > DIGMAX then
                       ERROR ( 203 )
                     else
                       with VAL do
                         for I := 1 to K do
                           if IVAL <= MXINT10 then
                             IVAL := IVAL * 10 + ( ORD ( DIGIT [ I ] )
                                     - ORD ( '0' ) )
                           else
                             begin
                               ERROR ( 203 ) ;
                               IVAL := 0
                             end (* else *)
                   end (* else *)
               end (* tag/ca *) ;

     (****************************)
     (*   QUOTE = HOCHKOMMA      *)
     (****************************)

       QUOTCH :
         begin
           LNGTH := 0 ;
           SY := STRINGCONST ;
           OP := NOOP ;
           repeat
             repeat
               NEXTCH ;
               if EOL then
                 begin
                   ERROR ( 202 ) ;
                   CH := ''''
                 end (* then *) ;
               LNGTH := LNGTH + 1 ;
               if LNGTH <= STRGLNGTH then
                 STRING [ LNGTH ] := CH
             until CH = '''' ;
             NEXTCH
           until CH <> '''' ;
           LNGTH := LNGTH - 1 ;

     (*****************************************)
     (*   NOW LNGTH = NR OF CHARS IN STRING   *)
     (*****************************************)

           if LNGTH = 1 then
             VAL . IVAL := ORD ( STRING [ 1 ] )
           else
             begin
               NEW ( LVP , STRG ) ;
               if LNGTH > STRGLNGTH then
                 begin
                   ERROR ( 398 ) ;
                   LNGTH := STRGLNGTH
                 end (* then *) ;
               if LNGTH <= 0 then
                 ERROR ( 205 ) ;
               with LVP -> do
                 begin
                   SLNGTH := LNGTH ;
                   SVAL := STRING
                 end (* with *) ;
               VAL . VALP := LVP
             end (* else *)
         end (* tag/ca *) ;

     (****************************)
     (*   COLON = DOPPELPUNKT    *)
     (****************************)

       COLONCH :
         begin
           OP := NOOP ;
           NEXTCH ;
           if CH = '=' then
             begin
               SY := BECOMES ;
               NEXTCH
             end (* then *)
           else
             SY := COLON
         end (* tag/ca *) ;

     (****************************)
     (*   DOT = PUNKT            *)
     (****************************)

       DOTCH : begin
                 OP := NOOP ;
                 if not DOTFLG then
                   NEXTCH ;
                 if CH = '.' then
                   begin
                     SY := DOTDOT ;
                     DOTFLG := FALSE ;
                     NEXTCH
                   end (* then *)
                 else
                   if CH = ')' then
                     begin
                       SY := RBRACK ;
                       DOTFLG := FALSE ;
                       NEXTCH
                     end (* then *)
                   else
                     SY := PERIOD
               end (* tag/ca *) ;

     (****************************)
     (*   LT = KLEINERZEICHEN    *)
     (****************************)

       LTOP : begin
                NEXTCH ;
                SY := RELOP ;
                if CH = '=' then
                  begin
                    OP := LEOP ;
                    NEXTCH
                  end (* then *)
                else
                  if CH = '>' then
                    begin
                      OP := NEOP ;
                      NEXTCH
                    end (* then *)
                  else
                    OP := LTOP
              end (* tag/ca *) ;

     (****************************)
     (*   GT = GROESSERZEICHEN   *)
     (****************************)

       GTOP : begin
                NEXTCH ;
                SY := RELOP ;
                if CH = '=' then
                  begin
                    OP := GEOP ;
                    NEXTCH
                  end (* then *)
                else
                  OP := GTOP
              end (* tag/ca *) ;

     (*******************************)
     (*   LPARCH = LINKE KLAMMER    *)
     (*******************************)

       LPARCH :
         begin
           NEXTCH ;
           if CH = '*' then
             begin
               NEXTCH ;
               if CH = '$' then
                 OPTIONS ( ')' ) ;
               COMMENT ( ')' ) ;
               NEXTCH ;
               goto 1 ;
             end (* then *) ;
           if CH = '/' then
             begin
               SY := LBRACK ;
               OP := NOOP ;
               NEXTCH
             end (* then *)
           else
             if CH = '.' then
               begin
                 SY := LBRACK ;
                 OP := NOOP ;
                 NEXTCH
               end (* then *)
             else
               begin
                 SY := LPARENT ;
                 OP := NOOP
               end (* else *)
         end (* tag/ca *) ;

     (**********************************************************)
     (*   vielleicht wurde schon .) gelesen, beim              *)
     (*   einlesen einer zahl, die wie eine gleitkommazahl     *)
     (*   aussah: (.1..10.) - altes problem der pascal-syntax  *)
     (**********************************************************)

       RPARCH :
         begin
           if DOTFLG then
             begin
               SY := SSY [ ']' ] ;
               OP := SOP [ ']' ] ;
               DOTFLG := FALSE ;
             end (* then *)
           else
             begin
               SY := SSY [ ')' ] ;
               OP := SOP [ ')' ] ;
             end (* else *) ;
           NEXTCH
         end (* tag/ca *) ;

     (**********************************************************)
     (*   DIVERSE OPERATORZEICHEN                              *)
     (*   VEREINFACHT, WEIL LOGIK WG. RBRACK NUR BEI           *)
     (*   RDIV NOETIG IST / OPPOLZER                           *)
     (**********************************************************)

       PLUS , MUL , EQOP , OROP , ANDOP , SPECH :
         begin
           SY := SSY [ CH ] ;
           OP := SOP [ CH ] ;
           NEXTCH
         end (* tag/ca *) ;

     (**********************************************************)
     (*   RDIV = SCHRAEGSTRICH                                 *)
     (*   MAYBE A RIGHT BRACKET, IF A RIGHT PARANTH. FOLLOWS   *)
     (*   AND: MAY START /* ... */ STYLE COMMENTS              *)
     (**********************************************************)

       RDIV : begin
                NEXTCH ;
                if CH = '*' then
                  begin
                    NEXTCH ;
                    if CH = '$' then
                      OPTIONS ( '/' ) ;
                    COMMENT ( '/' ) ;
                    NEXTCH ;
                    goto 1 ;
                  end (* then *) ;
                if CH = ')' then
                  begin
                    SY := RBRACK ;
                    OP := NOOP ;
                    NEXTCH ;
                  end (* then *)
                else
                  begin
                    SY := SSY [ '/' ] ;
                    OP := SOP [ '/' ] ;
                  end (* else *)
              end (* tag/ca *) ;

     (**********************************************************)
     (*   MINUS                                                *)
     (*   MAYBE A POINTER SYM, IF A GTOP FOLLOWS               *)
     (**********************************************************)

       MINUS : begin
                 NEXTCH ;
                 if CH = '>' then
                   begin
                     SY := ARROW ;
                     OP := NOOP ;
                     NEXTCH ;
                   end (* then *)
                 else
                   begin
                     SY := SSY [ '-' ] ;
                     OP := SOP [ '-' ] ;
                   end (* else *)
               end (* tag/ca *) ;

     (*****************************************)
     (*   DOUBLE QUOTE = ANFUEHRUNGSZEICHEN   *)
     (*   ALLES ZWISCHEN ANFUEHRUNGSZEICHEN   *)
     (*   WIRD IGNORIERT !!!                  *)
     (*****************************************)

       DQUOTCH :
         begin
           repeat
             NEXTCH
           until CH = '"' ;
           NEXTCH ;
           goto 1 ;
         end (* tag/ca *) ;

     (********************************************)
     (*   LBRACE = LINKE GESCHWEIFTE KLAMMER -   *)
     (*   STANDARD KOMMENTAR IN PASCAL -         *)
     (*   HINZUGEFUEGT VON DAVE EDWARDS          *)
     (********************************************)

       LBRACE :
         begin
           NEXTCH ;
           if CH = '$' then
             OPTIONS ( CHRBRACE ) ;
           COMMENT ( CHRBRACE ) ;
           NEXTCH ;
           goto 1 ;
         end (* tag/ca *) ;

     (****************************)
     (*   SKIPCH                 *)
     (****************************)

       SKIPCH :
         begin
           NEXTCH ;
           goto 1
         end (* tag/ca *) ;

     (****************************)
     (*   ILLEGALE ZEICHEN       *)
     (****************************)

       ILLEGCH , DOLLARCH , UNDSCH :
         begin
           SY := OTHERSY ;
           OP := NOOP ;
           ERROR ( 6 ) ;
           NEXTCH
         end (* tag/ca *)
     end (* case *)
   end (* INSYMBOL *) ;



function HASH ( ID : ALPHA ) : BKT_RNG ;

   var OL : record
              case INTEGER of
                1 :
                  ( IDK : ALPHA ) ;
                2 :
                  ( INT1 , INT2 , INT3 : INTEGER )
            end ;

   begin (* HASH *)
     with OL do
       begin
         IDK := ID ;

     (***********************************)
     (* NO OVERFLOW CHECK FOR NEXT STMT *)
     (***********************************)

         HASH := ABS ( ( INT1 * 2 + INT2 ) * 2 + INT3 ) MOD ( MAX_BKT +
                 1 ) ;
       end (* with *)
   end (* HASH *) ;



procedure ENTERID ( FCP : CTP ) ;

   label 1 ;

   var K : BKT_RNG ;
       NAM : ALPHA ;
       LCP : CTP ;

   begin (* ENTERID *)
     NAM := FCP -> . NAME ;
     K := HASH ( NAM ) ;
     LCP := BUCKET [ K ] ;
     FCP -> . DECL_LEV := LEVEL ;
     FCP -> . NEXT_IN_BKT := LCP ;
     BUCKET [ K ] := FCP ;

     (***************************************)
     (* NOW CHECK FOR DUPLICATE DECLARATION *)
     (***************************************)

     while LCP <> NIL do
       with LCP -> do
         begin
           if NAME = NAM then
             if KLASS <> FIELD then
               begin
                 if TOP = DECL_LEV then
                   begin
                     ERROR ( 101 ) ;
                     goto 1
                   end (* then *)
               end (* then *)
             else

     (*****************************)
     (* SPECIAL LOOKUP FOR FIELDS *)
     (*****************************)

               if TOP = OWNER -> . FLD_DISP_LEV then
                 begin
                   ERROR ( 101 ) ;
                   goto 1
                 end (* then *) ;
           LCP := NEXT_IN_BKT ;
         end (* with *) ;
     1 :
     if GET_STAT then
       if TOP = LEVEL then
         ENT_CNT [ LEVEL ] := ENT_CNT [ LEVEL ] + 1
       else
         FENT_CNT := FENT_CNT + 1 ;
   end (* ENTERID *) ;



procedure SEARCHSECTION ( FSP : STP ; var FCP : CTP ) ;

(****************************************************)
(* FINDS FIELD IN RECORD STRUCTURE INDICATED BY FSP *)
(****************************************************)


   label 1 ;

   var LCP : CTP ;

   begin (* SEARCHSECTION *)
     LCP := BUCKET [ HASH ( ID ) ] ;
     while LCP <> NIL do
       with LCP -> do
         begin
           if NAME = ID then
             if KLASS = FIELD then
               if OWNER = FSP then
                 begin
                   if GET_STAT then
                     begin
                       SF_CNT := SF_CNT + 1 ;
                       SF_TOT := SF_TOT + FSP -> . NO_FLDS ;
                     end (* then *) ;
                   goto 1 ;
                 end (* then *) ;
           LCP := NEXT_IN_BKT ;
         end (* with *) ;
     1 :
     FCP := LCP ;
   end (* SEARCHSECTION *) ;



procedure SEARCHID ( FIDCLS : SETOFIDS ; var FCP : CTP ) ;

   label 1 ;

   var LCP : CTP ;
       DL , EL : - 1 .. DISPLIMIT ;
       K : BKT_RNG ;

   begin (* SEARCHID *)
     K := HASH ( ID ) ;
     LCP := BUCKET [ K ] ;
     FCP := NIL ;
     EL := - 1 ;
     DISX := EL ;
     while LCP <> NIL do
       with LCP -> do
         begin
           if NAME = ID then
             begin
               if KLASS <> FIELD then
                 DL := DECL_LEV
               else
                 DL := OWNER -> . FLD_DISP_LEV ;
               if DL > DISX then
                 if KLASS in FIDCLS then
                   begin
                     FCP := LCP ;
                     DISX := DL ;
                     if TOP = LEVEL then

     (*******************************)
     (* NO POINT IN FURTHER SEARCH  *)
     (*                             *)
     (*                             *)
     (*******************************)

                       goto 1
                   end (* then *)
                 else
                   EL := DL ;
             end (* then *) ;
           LCP := NEXT_IN_BKT ;
         end (* with *) ;
     1 :
     if EL > DISX then

     (******************************)
     (* BAD IDENTIFIER ENCOUNTERED *)
     (******************************)

       if PRTERR then
         ERROR ( 103 ) ;
     if DISX < 0 then
       begin

     (*******************************)
     (* THE SEARCH WAS UNSUCCESSFUL *)
     (*******************************)

         if PRTERR then
           begin
             if EL < 0 then
               ERROR ( 104 ) ;
             NEW ( LCP ) ;
             if ( FIELD in FIDCLS ) and ( TOP > LEVEL ) then
               LCP -> := UFLDPTR ->
             else
               if VARS in FIDCLS then
                 LCP -> := UVARPTR ->
               else
                 if TYPES in FIDCLS then
                   LCP -> := UTYPPTR ->
                 else
                   if KONST in FIDCLS then
                     LCP -> := UCSTPTR ->
                   else
                     if PROC in FIDCLS then
                       LCP -> := UPRCPTR ->
                     else

     (********)
     (* FUNC *)
     (********)

                       LCP -> := UFCTPTR -> ;
             with LCP -> do
               begin
                 NAME := ID ;

     (**********************************)
     (* PREVENT RE-OCCURRENCE OF ERROR *)
     (**********************************)

                 DECL_LEV := LEVEL ;
                 NEXT_IN_BKT := BUCKET [ K ] ;
                 BUCKET [ K ] := LCP ;
                 FCP := LCP ;
                 if KLASS = FIELD then
                   OWNER := OPEN_RECORD ;
               end (* with *) ;
             DISX := LEVEL ;
           end (* then *)
         else
           DISX := 0 ;
       end (* then *) ;
     if GET_STAT then
       begin
         if DISX <= LEVEL then
           LU_CNT [ DISX , TOP ] := LU_CNT [ DISX , TOP ] + 1
         else
           WLU_CNT [ DISX - LEVEL , TOP - LEVEL ] := WLU_CNT [ DISX -
                                                   LEVEL , TOP - LEVEL
                                                   ] + 1 ;
         if TOP <> LEVEL then
           WE_CNT := WE_CNT + 1
       end (* then *) ;
   end (* SEARCHID *) ;



procedure GETBOUNDS ( FSP : STP ; var FMIN , FMAX : INTEGER ) ;

(************************************************)
(*GET INTERNAL BOUNDS OF SUBRANGE OR SCALAR TYPE*)
(*ASSUME (FSP <> NIL) AND (FSP@.FORM <= SUBRANG *)
(*E) AND (FSP <> INTPTR)                        *)
(*      AND NOT COMPTYPES(REALPTR,FSP)          *)
(************************************************)


   begin (* GETBOUNDS *)
     with FSP -> do
       if FORM = SUBRANGE then
         begin
           FMIN := MIN . IVAL ;
           FMAX := MAX . IVAL
         end (* then *)
       else
         begin
           FMIN := 0 ;
           if FSP = CHARPTR then
             FMAX := ORDCHMAX
           else
             if ( FORM = SCALAR ) and ( FSP -> . FCONST <> NIL ) then
               FMAX := FSP -> . FCONST -> . VALUES . IVAL
             else
               FMAX := 0
         end (* else *)
   end (* GETBOUNDS *) ;



function GETTYPE ( OPERAND : STP ) : INTEGER ;

   begin (* GETTYPE *)
     GETTYPE := ORD ( 'I' ) ;

     (***********************)
     (* ASSUME INTEGER TYPE *)
     (***********************)

     if OPERAND = NIL then
       begin
         if ERRORCNT = 0 then
           ERROR ( 401 )
       end (* then *)
     else
       if OPERAND -> . FORM > POWER then
         GETTYPE := ORD ( 'A' )
       else
         if OPERAND -> . FORM = POWER then
           GETTYPE := ORD ( 'S' )
         else
           if OPERAND -> . FORM = POINTER then
             GETTYPE := ORD ( 'A' )
           else
             if OPERAND = REALPTR then
               GETTYPE := ORD ( 'R' )
             else
               if OPERAND = BOOLPTR then
                 GETTYPE := ORD ( 'B' )
               else
                 if OPERAND -> . SIZE = HINTSIZE then
                   GETTYPE := ORD ( 'H' )
                 else
                   if OPERAND -> . SIZE = CHARSIZE then
                     GETTYPE := ORD ( 'C' )
                   else
                     ;
   end (* GETTYPE *) ;



function OPNDSETSIZE ( FATTR : ATTR ) : INTEGER ;

(*************************************************)
(* COMPUTES THE SIZE OF A SET USED AS AN OPERAND *)
(*************************************************)


   begin (* OPNDSETSIZE *)
     OPNDSETSIZE := 0 ;
     with FATTR do
       if TYPTR <> NIL then
         case KIND of
           CST : OPNDSETSIZE := CVAL . VALP -> . PLNGTH ;
           VARBL : case ACCESS of
                     DRCT , INDRCT :
                       OPNDSETSIZE := TYPTR -> . SIZE ;
                     STKEXPR :
                       OPNDSETSIZE := STKLEN ;
                     INXD : ERROR ( 400 ) ;
                   end (* case *) ;
           EXPR : ERROR ( 400 ) ;
         end (* case *) ;
   end (* OPNDSETSIZE *) ;



procedure GENLABEL ( var NXTLAB : LABELRNG ) ;

   begin (* GENLABEL *)
     INTLABEL := INTLABEL + 1 ;
     NXTLAB := INTLABEL
   end (* GENLABEL *) ;





(**********************************************************************)
(*THE FOLLOWING OUTPUTS A SYMBOL TABLE FILE FOR USE BY 'SNAPSHOT' PRO *)
(*GRAM                                                                *)
(**********************************************************************)




procedure PRNTSYMBL ( LCP : CTP ) ;

   var LINELN : INTEGER ;

       (*****************************************)
       (* CURRENT SYMBOL TABLE FILE LINE LENGTH *)
       (*****************************************)

       TPT1 : PRNTTYLISTP ;


   procedure CHECKLN ( LEN : INTEGER ) ;

      begin (* CHECKLN *)
        if ( LINELN + LEN ) >= 80 then
          begin
            WRITELN ( QRR ) ;
            WRITE ( QRR , ' ' ) ;
            LINELN := LEN
          end (* then *)
        else
          LINELN := LINELN + LEN
      end (* CHECKLN *) ;


   procedure PRNTVAR ( VRP : CTP ) ;

      FORWARD ;


   procedure PRNTTYPE ( TYPP : STP ) ;

      label 1 ;

      var VP , LVP : CTP ;
          RMIN , RMAX : INTEGER ;
          TPT , LPT : PRNTTYLISTP ;
          TNO : 0 .. 999 ;

      begin (* PRNTTYPE *)
        CHECKLN ( 4 ) ;
        if TYPP = INTPTR then
          WRITE ( QRR , 'I4; ' )
        else
          if TYPP = REALPTR then
            WRITE ( QRR , 'R; ' )
          else
            if TYPP = BOOLPTR then
              WRITE ( QRR , 'B; ' )
            else
              if TYPP = CHARPTR then
                WRITE ( QRR , 'C; ' )
              else
                if TYPP <> NIL then
                  with TYPP -> do
                    case FORM of
                      SUBRANGE :
                        if RANGETYPE = CHARPTR then
                          WRITE ( QRR , 'C; ' )
                        else
                          if RANGETYPE = INTPTR then
                            WRITE ( QRR , 'I' , SIZE : 1 , '; ' )
                          else
                            WRITE ( QRR , 'L' , SIZE : 1 , '; ' ) ;
                      SCALAR :
                        WRITE ( QRR , 'L' , SIZE : 1 , '; ' ) ;
                      POINTER :
                        begin
                          if ELTYPE <> NIL then
                            begin
                              TPT := PRNTTYPHD ;
                              LPT := TPT ;
                              while TPT <> NIL do
                                if TPT -> . ELT = ELTYPE then
                                  begin
                                    TNO := TPT -> . TNO ;
                                    goto 1
                                  end (* then *)
                                else
                                  begin
                                    LPT := TPT ;
                                    TPT := TPT -> . NXT ;
                                  end (* else *) ;
                              NEW ( TPT ) ;
                              if PRNTTYPHD = NIL then
                                PRNTTYPHD := TPT
                              else
                                LPT -> . NXT := TPT ;
                              with TPT -> do
                                begin
                                  NXT := NIL ;
                                  ELT := ELTYPE ;
                                  PRNTTYNO := PRNTTYNO + 1 ;
                                  TNO := PRNTTYNO
                                end (* with *) ;
                              TNO := PRNTTYNO ;
                            end (* then *)
                          else
                            TNO := 0 ;
                          1 :
                          CHECKLN ( 3 ) ;
                          WRITE ( QRR , 'P ' , TNO : 1 , '; ' ) ;
                        end (* tag/ca *) ;
                      POWER : if ELSET <> NIL then
                                begin
                                  WRITE ( QRR , 'S ' ) ;
                                  CHECKLN ( 10 ) ;
                                  GETBOUNDS ( ELSET , RMIN , RMAX ) ;
                                  WRITE ( QRR , RMIN : 1 , ' ' , RMAX :
                                          1 , ' ; ' ) ;
                                end (* then *) ;
                      FILES : begin
                                WRITE ( QRR , 'F ' ) ;
                                PRNTTYPE ( FILTYPE ) ;
                              end (* tag/ca *) ;
                      RECORDS :
                        begin
                          WRITE ( QRR , 'D' , ALN : 1 , '(' ) ;
                          VP := FSTFLD ;
                          LVP := VP ;
                          while VP <> NIL do
                            begin
                              PRNTVAR ( VP ) ;
                              LVP := VP ;
                              VP := VP -> . NEXT ;
                            end (* while *) ;
                          if RECVAR <> NIL then
                            begin
                              if RECVAR -> . TAGFIELDP <> NIL then
                                if RECVAR -> . TAGFIELDP -> . NAME <>
                                BLANKID then
                                  begin
                                    LVP := RECVAR -> . TAGFIELDP ;
                                    PRNTVAR ( LVP ) ;
                                  end (* then *) ;
                              if LVP <> NIL then
                                begin
                                  CHECKLN ( 12 ) ;
                                  RMAX := SIZE - LVP -> . FLDADDR ;
                                  if LVP -> . IDTYPE <> NIL then
                                    RMAX := RMAX - LVP -> . IDTYPE -> .
                                            SIZE ;
                                  if RMAX > 0 then
                                    WRITE ( QRR , 'ETC=X' , RMAX : 1 ,
                                            '; ' ) ;
                                end (* then *) ;
                            end (* then *) ;
                          CHECKLN ( 3 ) ;
                          WRITE ( QRR , '); ' ) ;
                        end (* tag/ca *) ;
                      ARRAYS :
                        if INXTYPE <> NIL then
                          begin
                            WRITE ( QRR , 'A ' ) ;
                            CHECKLN ( 26 ) ;
                            GETBOUNDS ( INXTYPE , RMIN , RMAX ) ;
                            WRITE ( QRR , RMIN : 1 , ' ' , RMAX : 1 ,
                                    ' ' ) ;
                            PRNTTYPE ( AELTYPE ) ;
                          end (* then *) ;
                    end (* case *)
                else
                  WRITE ( QRR , ';' ) ;
      end (* PRNTTYPE *) ;

          (************)
          (* PRNTTYPE *)
          (************)



   procedure PRNTVAR ;

      var I : 0 .. IDLNGTH ;

      begin (* PRNTVAR *)
        with VRP -> do
          begin
            I := IDLNGTH ;
            while NAME [ I ] = ' ' do
              I := I - 1 ;
            CHECKLN ( I + 1 ) ;
            WRITE ( QRR , NAME : I , '=' ) ;
            PRNTTYPE ( IDTYPE ) ;
          end (* with *)
      end (* PRNTVAR *) ;


   begin (* PRNTSYMBL *)
     if PRCODE then
       if LCP <> NIL then
         with LCP -> do
           begin
             if KLASS = VARS then
               begin
                 LINELN := 5 ;
                 if VKIND = FORMAL then
                   begin
                     WRITE ( QRR , '@ ' ) ;
                     LINELN := 7
                   end (* then *) ;
                 WRITE ( QRR , VADDR : 1 , ' ' ) ;
                 PRNTVAR ( LCP ) ;
               end (* then *)
             else
               if KLASS in [ PROC , FUNC ] then
                 begin
                   WRITELN ( QRR , '% ' , NAME , ' ' , PFNAME ) ;
                   LCP := PRMPTR ;
                   while LCP <> NIL do

     (*****************************)
     (* SKIP PROC/FUNC PARAMETERS *)
     (*****************************)

                     begin
                       if LCP -> . KLASS = VARS then
                         PRNTSYMBL ( LCP ) ;
                       LCP := LCP -> . NEXT
                     end (* while *) ;
                 end (* then *) ;
             WRITELN ( QRR ) ;
           end (* with *)
       else

     (**************************************)
     (* DUMP HEAP STORAGE TYPE DEFINITIONS *)
     (**************************************)

         begin
           TPT1 := PRNTTYPHD ;
           while TPT1 <> NIL do
             begin
               WRITE ( QRR , '>' , TPT1 -> . TNO : 1 , ' ' ) ;
               LINELN := 5 ;
               PRNTTYPE ( TPT1 -> . ELT ) ;
               WRITELN ( QRR ) ;
               TPT1 := TPT1 -> . NXT ;
             end (* while *) ;
           PRNTTYPHD := NIL ;
           PRNTTYNO := 0 ;
         end (* else *) ;
   end (* PRNTSYMBL *) ;





(*************)
(* PRNTSYMBL *)
(*************)




procedure BLOCK ( FSYS : SETOFSYS ; FSY : SYMBOL ; FPROCP : CTP ) ;

   var LSY : SYMBOL ;
       TEST : BOOLEAN ;
       SEGSIZE : LABELRNG ;
       LCP , FWRDPRCL : CTP ;
       DEC_ORDER : 0 .. 4 ;


   procedure SKIP ( FSYS : SETOFSYS ) ;

   (***********************************************)
   (*SKIP INPUT STRING UNTIL RELEVANT SYMBOL FOUND*)
   (***********************************************)


      begin (* SKIP *)
        while not ( SY in FSYS ) do
          INSYMBOL ;
      end (* SKIP *) ;


   procedure ALIGN ( var Q : ADDRRANGE ; P : ADDRRANGE ) ;

      begin (* ALIGN *)
        case P of
          REALSIZE :
            Q := ( ( Q + 7 ) DIV 8 ) * 8 ;
          INTSIZE

        "********"
        ",PTRSIZE"
        "********"


          : Q := ( ( Q + 3 ) DIV 4 ) * 4 ;
          HINTSIZE :
            if ODD ( Q ) then
              Q := Q + 1 ;
          CHARSIZE :
            ;
          otherwise

          : if ERRORCNT = 0 then
              ERROR ( 401 ) ;
        end (* case *) ;
      end (* ALIGN *) ;


   procedure CONSTANT ( FSYS : SETOFSYS ; var FSP : STP ; var FVALU :
                      VALU ) ;

      var LSP : STP ;
          LCP : CTP ;
          SIGN : ( NONE , POS , NEG ) ;
          LVP : CSP ;
          I : 2 .. REALLNGTH ;

      begin (* CONSTANT *)
        LSP := NIL ;
        FVALU . IVAL := 0 ;
        if not ( SY in CONSTBEGSYS ) then
          begin
            ERROR ( 50 ) ;
            SKIP ( FSYS + CONSTBEGSYS )
          end (* then *) ;
        if SY in CONSTBEGSYS then
          begin
            if SY = STRINGCONST then
              begin
                if LNGTH = 1 then
                  LSP := CHARPTR
                else
                  begin
                    NEW ( LSP , ARRAYS ) ;
                    with LSP -> do
                      begin
                        AELTYPE := CHARPTR ;
                        INXTYPE := NIL ;
                        SIZE := LNGTH * CHARSIZE ;
                        FORM := ARRAYS ;
                        ALN := CHARSIZE ;
                      end (* with *)
                  end (* else *) ;
                FVALU := VAL ;
                INSYMBOL
              end (* then *)
            else
              begin
                SIGN := NONE ;
                if ( SY = ADDOP ) and ( OP in [ PLUS , MINUS ] ) then
                  begin
                    if OP = PLUS then
                      SIGN := POS
                    else
                      SIGN := NEG ;
                    INSYMBOL
                  end (* then *) ;
                if SY = IDENT then
                  begin
                    SEARCHID ( [ KONST ] , LCP ) ;
                    with LCP -> do
                      begin
                        LSP := IDTYPE ;
                        FVALU := VALUES
                      end (* with *) ;
                    if SIGN <> NONE then
                      if LSP = INTPTR then
                        begin
                          if SIGN = NEG then
                            FVALU . IVAL := - FVALU . IVAL
                        end (* then *)
                      else
                        if LSP = REALPTR then
                          begin
                            if SIGN = NEG then
                              begin
                                NEW ( LVP , REEL ) ;
                                LVP -> . RVAL := FVALU . VALP -> . RVAL
                                                 ;
                                if LVP -> . RVAL [ 1 ] = '-' then
                                  LVP -> . RVAL [ 1 ] := '+'
                                else
                                  LVP -> . RVAL [ 1 ] := '-' ;
                                FVALU . VALP := LVP ;
                              end (* then *)
                          end (* then *)
                        else
                          ERROR ( 105 ) ;
                    INSYMBOL ;
                  end (* then *)
                else
                  if SY = INTCONST then
                    begin
                      if SIGN = NEG then
                        VAL . IVAL := - VAL . IVAL ;
                      LSP := INTPTR ;
                      FVALU := VAL ;
                      INSYMBOL
                    end (* then *)
                  else
                    if SY = REALCONST then
                      begin
                        if SIGN = NEG then
                          VAL . VALP -> . RVAL [ 1 ] := '-' ;
                        LSP := REALPTR ;
                        FVALU := VAL ;
                        INSYMBOL
                      end (* then *)
                    else
                      begin
                        ERROR ( 106 ) ;
                        SKIP ( FSYS )
                      end (* else *)
              end (* else *) ;
            if not ( SY in FSYS ) then
              begin
                ERROR ( 6 ) ;
                SKIP ( FSYS )
              end (* then *)
          end (* then *) ;
        FSP := LSP
      end (* CONSTANT *) ;


   function COMPTYPES ( FSP1 , FSP2 : STP ) : BOOLEAN ;

   (***************************************************************** *)
   (*****                                                             *)
   (*DECIDE WHETHER STRUCTURES POINTED AT BY FSP1 AND FSP2 ARE COMPAT *)
   (*IBLE                                                             *)
   (***************************************************************** *)
   (*****                                                             *)


      var NXT1 , NXT2 : CTP ;
          COMP : BOOLEAN ;
          LTESTP1 , LTESTP2 : TESTP ;

      begin (* COMPTYPES *)
        if FSP1 = FSP2 then
          COMPTYPES := TRUE
        else
          if ( FSP1 <> NIL ) and ( FSP2 <> NIL ) then
            if FSP1 -> . FORM = FSP2 -> . FORM then
              case FSP1 -> . FORM of
                SCALAR :
                  COMPTYPES := FALSE ;

        (**************************************************************)
        (* IDENTICAL SCALARS DECLARED ON DIFFERENT LEVELS ARE         *)
        (*                                                            *)
        (*                  NOT RECOGNIZED TO BE COMPATIBLE           *)
        (**************************************************************)

                SUBRANGE :
                  COMPTYPES := COMPTYPES ( FSP1 -> . RANGETYPE , FSP2
                               -> . RANGETYPE ) ;
                POINTER :
                  begin
                    COMP := FALSE ;
                    LTESTP1 := GLOBTESTP ;
                    LTESTP2 := GLOBTESTP ;
                    while LTESTP1 <> NIL do
                      with LTESTP1 -> do
                        begin
                          if ( ELT1 = FSP1 -> . ELTYPE ) and ( ELT2 =
                          FSP2 -> . ELTYPE ) then
                            COMP := TRUE ;
                          LTESTP1 := LASTTESTP
                        end (* with *) ;
                    if not COMP then
                      begin
                        NEW ( LTESTP1 ) ;
                        with LTESTP1 -> do
                          begin
                            ELT1 := FSP1 -> . ELTYPE ;
                            ELT2 := FSP2 -> . ELTYPE ;
                            LASTTESTP := GLOBTESTP
                          end (* with *) ;
                        GLOBTESTP := LTESTP1 ;
                        COMP := COMPTYPES ( FSP1 -> . ELTYPE , FSP2 ->
                                . ELTYPE )
                      end (* then *) ;
                    COMPTYPES := COMP ;
                    GLOBTESTP := LTESTP2
                  end (* tag/ca *) ;
                POWER : COMPTYPES := COMPTYPES ( FSP1 -> . ELSET , FSP2
                                     -> . ELSET ) ;
                ARRAYS :
                  COMPTYPES := COMPTYPES ( FSP1 -> . AELTYPE , FSP2 ->
                               . AELTYPE ) and ( FSP1 -> . SIZE = FSP2
                               -> . SIZE ) ;

        (**************************************************************)
        (*ALTERNATIVES: -- ADD A THIRD BOOLEAN TERM: INDEXTYPE MUST   *)
        (*                                                            *)
        (*                                   BE COMPATIBLE.           *)
        (*                                                            *)
        (*                                -- ADD A FOURTH BOOLEAN TER *)
        (*M: LOWBOUNDS MUST                                           *)
        (*                                   BE THE SAME              *)
        (**************************************************************)

                RECORDS :
                  begin
                    NXT1 := FSP1 -> . FSTFLD ;
                    NXT2 := FSP2 -> . FSTFLD ;
                    COMP := ( FSP1 -> . RECVAR = FSP2 -> . RECVAR ) ;
                    while COMP and ( NXT1 <> NIL ) and ( NXT2 <> NIL )
                    do
                      begin
                        if not COMPTYPES ( NXT1 -> . IDTYPE , NXT2 -> .
                        IDTYPE ) then
                          COMP := FALSE ;
                        if NXT1 -> . IDTYPE -> . SIZE <> NXT2 -> .
                        IDTYPE -> . SIZE then
                          COMP := FALSE ;
                        NXT1 := NXT1 -> . NEXT ;
                        NXT2 := NXT2 -> . NEXT
                      end (* while *) ;
                    COMPTYPES := COMP and ( NXT1 = NIL ) and ( NXT2 =
                                 NIL )
                  end (* tag/ca *) ;

        (**************************************************************)
        (*IDENTICAL RECORDS ARE RECOGNIZED TO BE COMPATIBLE           *)
        (*                                                            *)
        (*                  IFF NO VARIANTS OCCUR                     *)
        (**************************************************************)

                FILES : COMPTYPES := COMPTYPES ( FSP1 -> . FILTYPE ,
                                     FSP2 -> . FILTYPE )
              end (* case *)
            else

        (**************************)
        (*FSP1@.FORM <> FSP2@.FORM*)
        (**************************)

              if FSP1 -> . FORM = SUBRANGE then
                COMPTYPES := COMPTYPES ( FSP1 -> . RANGETYPE , FSP2 )
              else
                if FSP2 -> . FORM = SUBRANGE then
                  COMPTYPES := COMPTYPES ( FSP1 , FSP2 -> . RANGETYPE )
                else
                  COMPTYPES := FALSE
          else
            COMPTYPES := TRUE
      end (* COMPTYPES *) ;


   function STRING ( FSP : STP ) : BOOLEAN ;

      begin (* STRING *)
        STRING := FALSE ;
        if FSP <> NIL then
          if FSP -> . FORM = ARRAYS then
            STRING := COMPTYPES ( FSP -> . AELTYPE , CHARPTR )
      end (* STRING *) ;


   function CALC_SETSIZE ( ELT : STP ) : INTEGER ;

   (**************************************************)
   (* COMPUTES SIZE OF SET WHOSE ELEMENT TYPE IS ELT *)
   (**************************************************)


      var MIN , MAX : INTEGER ;

      begin (* CALC_SETSIZE *)
        MAX := - 1 ;
        if ELT <> NIL then
          GETBOUNDS ( ELT , MIN , MAX ) ;
        CALC_SETSIZE := ( ( MAX + SETPACK ) DIV SETPACK ) * WORDSIZE ;
      end (* CALC_SETSIZE *) ;


   procedure TYP ( FSYS : SETOFSYS ; var FSP : STP ; var FSIZE :
                 ADDRRANGE ) ;

      var LSP , LSP1 , LSP2 : STP ;
          OLDTOP : DISPRANGE ;
          LCP , LCP2 : CTP ;
          LSIZE , DISPL : ADDRRANGE ;
          LMIN , LMAX : INTEGER ;
          ALNFCT : ALNRNG ;
          OLDPACKST , PACKST2 : BOOLEAN ;


      procedure SIMPLETYPE ( FSYS : SETOFSYS ; var FSP : STP ) ;

         var LSP , LSP1 : STP ;
             LCP , LCP1 : CTP ;
             TTOP : DISPRANGE ;
             LCNT : INTEGER ;
             LVALU : VALU ;
             FLAG : BOOLEAN ;

         begin (* SIMPLETYPE *)
           if not ( SY in SIMPTYPEBEGSYS ) then
             begin
               ERROR ( 1 ) ;
               SKIP ( FSYS + SIMPTYPEBEGSYS )
             end (* then *) ;
           if SY in SIMPTYPEBEGSYS then
             begin
               if SY = LPARENT then
                 begin
                   TTOP := TOP ;

           (***************************************)
           (*DECL. CONSTS LOCAL TO INNERMOST BLOCK*)
           (***************************************)

                   TOP := LEVEL ;
                   NEW ( LSP , SCALAR , DECLARED ) ;
                   with LSP -> do
                     begin
                       SIZE := INTSIZE ;
                       FORM := SCALAR ;
                       SCALKIND := DECLARED
                     end (* with *) ;
                   LCP1 := NIL ;
                   LCNT := 0 ;
                   repeat
                     INSYMBOL ;
                     if SY = IDENT then
                       begin
                         NEW ( LCP , KONST ) ;
                         with LCP -> do
                           begin
                             NAME := ID ;
                             IDTYPE := LSP ;
                             NEXT := LCP1 ;
                             VALUES . IVAL := LCNT ;
                             KLASS := KONST
                           end (* with *) ;
                         ENTERID ( LCP ) ;
                         LCNT := LCNT + 1 ;
                         LCP1 := LCP ;
                         INSYMBOL
                       end (* then *)
                     else
                       ERROR ( 2 ) ;
                     if not ( SY in FSYS + [ COMMA , RPARENT ] ) then
                       begin
                         ERROR ( 6 ) ;
                         SKIP ( FSYS + [ COMMA , RPARENT ] )
                       end (* then *)
                   until SY <> COMMA ;
                   if not NOPACKING then
                     begin
                       LSP -> . SIZE := HINTSIZE ;
                       if PACKDATA then
                         if LCNT <= ORDCHMAX then
                           LSP -> . SIZE := CHARSIZE
                     end (* then *) ;
                   LSP -> . ALN := LSP -> . SIZE ;
                   LSP -> . FCONST := LCP1 ;
                   TOP := TTOP ;
                   if SY = RPARENT then
                     INSYMBOL
                   else
                     ERROR ( 4 )
                 end (* then *)
               else
                 begin
                   if SY = IDENT then
                     begin
                       SEARCHID ( [ TYPES , KONST ] , LCP ) ;
                       INSYMBOL ;
                       if LCP -> . KLASS = KONST then
                         begin
                           NEW ( LSP , SUBRANGE ) ;
                           with LSP -> , LCP -> do
                             begin
                               RANGETYPE := IDTYPE ;
                               FORM := SUBRANGE ;
                               if STRING ( RANGETYPE ) then
                                 begin
                                   ERROR ( 148 ) ;
                                   RANGETYPE := NIL
                                 end (* then *) ;
                               MIN := VALUES ;
                               SIZE := IDTYPE -> . SIZE
                             end (* with *) ;
                         end (* then *)
                       else
                         LSP := NIL ;

           (************************)
           (* SIGNALS TYPE ID SEEN *)
           (************************)

                     end (* then *)
                   else
                     begin
                       NEW ( LSP , SUBRANGE ) ;
                       LSP -> . FORM := SUBRANGE ;
                       CONSTANT ( FSYS + [ DOTDOT ] , LSP1 , LVALU ) ;
                       if STRING ( LSP1 ) then
                         begin
                           ERROR ( 148 ) ;
                           LSP1 := NIL
                         end (* then *) ;
                       with LSP -> do
                         begin
                           RANGETYPE := LSP1 ;
                           MIN := LVALU ;
                           SIZE := INTSIZE ;
                           if LSP1 <> NIL then
                             SIZE := LSP1 -> . SIZE ;
                         end (* with *) ;
                     end (* else *) ;
                   if LSP <> NIL then

           (**********************)
           (* CONSTANT JUST SEEN *)
           (**********************)

                     begin
                       if SY = DOTDOT then
                         INSYMBOL
                       else
                         ERROR ( 5 ) ;
                       CONSTANT ( FSYS , LSP1 , LVALU ) ;
                       LSP -> . MAX := LVALU ;
                       if LSP1 -> . SIZE > CHARSIZE then

           (*********************)
           (* SCOPE FOR PACKING *)
           (*                   *)
           (*                   *)
           (*********************)

                         if not NOPACKING then
                           if LVALU . IVAL <= 32767 then
                             if LSP -> . MIN . IVAL >= - 32768 then
                               begin
                                 LSP -> . SIZE := HINTSIZE ;
                                 if PACKDATA then
                                   if LVALU . IVAL <= ORDCHMAX then
                                     if LSP -> . MIN . IVAL >= 0 then
                                       LSP -> . SIZE := CHARSIZE ;
                               end (* then *) ;
                       LSP -> . ALN := LSP -> . SIZE ;
                       if LSP -> . RANGETYPE <> LSP1 then
                         ERROR ( 107 )
                     end (* then *)
                   else
                     begin
                       LSP := LCP -> . IDTYPE ;
                       FLAG := FALSE ;
                       if PACKDATA then
                         if not NOPACKING then
                           if LSP <> NIL then
                             with LSP -> do
                               if SIZE > CHARSIZE then
                                 if FORM = SCALAR then
                                   if SCALKIND = DECLARED then
                                     begin
                                       LCNT := - 1 ;
                                       LCP1 := FCONST ;
                                       while LCP1 <> NIL do
                                         begin
                                           LCNT := LCNT + 1 ;
                                           LCP1 := LCP1 -> . NEXT ;
                                         end (* while *) ;
                                       if LCNT <= ORDCHMAX then
                                         FLAG := TRUE
                                     end (* then *)
                                   else

                                 else
                                   if FORM = SUBRANGE then
                                     if MIN . IVAL >= 0 then
                                       if MAX . IVAL <= ORDCHMAX then
                                         FLAG := TRUE ;
                       if FLAG then
                         begin

           (************************************)
           (*CREATE PACKED VERSION OF THIS TYPE*)
           (************************************)

                           NEW ( LSP1 ) ;
                           LSP1 -> := LSP -> ;
                           with LSP1 -> do
                             begin
                               SIZE := CHARSIZE ;
                               ALN := CHARSIZE ;
                               if FORM = SCALAR then

           (*****************)
           (* CONVERT TO SU *)
           (*               *)
           (*               *)
           (*               *)
           (* BRANGE        *)
           (*****************)

                                 begin
                                   FORM := SUBRANGE ;
                                   RANGETYPE := LSP ;
                                   MIN . IVAL := 0 ;
                                   MAX . IVAL := LCNT ;
                                 end (* then *) ;
                             end (* with *) ;
                           LSP := LSP1 ;
                         end (* then *)
                     end (* else *) ;
                   if LSP <> NIL then
                     with LSP -> do
                       if FORM = SUBRANGE then
                         if RANGETYPE <> NIL then
                           if RANGETYPE = REALPTR then
                             ERROR ( 398 )
                           else
                             if MIN . IVAL > MAX . IVAL then
                               ERROR ( 102 )
                 end (* else *) ;
               FSP := LSP ;
               if not ( SY in FSYS ) then
                 begin
                   ERROR ( 6 ) ;
                   SKIP ( FSYS )
                 end (* then *)
             end (* then *)
           else
             FSP := NIL
         end (* SIMPLETYPE *) ;


      procedure FIELDLIST ( FSYS : SETOFSYS ; var FRECVAR : STP ; var
                          RECALN : ALNRNG ; FLDOWNER : STP ; var
                          FIRSTFLD : CTP ) ;

         label 10 ;

         var LCP , LCP1 , NXT , NXT1 : CTP ;
             LSP , LSP1 , LSP2 , LSP3 , LSP4 : STP ;
             MINSIZE , MAXSIZE , LSIZE : ADDRRANGE ;
             LVALU : VALU ;
             LALNFCT : ALNRNG ;

         begin (* FIELDLIST *)
           NXT := NIL ;
           FIRSTFLD := NIL ;
           LSP := NIL ;
           RECALN := 1 ;
           if not ( SY in FSYS + [ IDENT , CASESY ] ) then
             begin
               ERROR ( 19 ) ;
               SKIP ( FSYS + [ IDENT , CASESY ] )
             end (* then *) ;
           while SY = IDENT do
             begin
               NXT1 := NIL ;
               repeat
                 if SY = IDENT then
                   begin
                     NEW ( LCP , FIELD ) ;
                     with LCP -> do
                       begin
                         NAME := ID ;
                         IDTYPE := NIL ;
                         NEXT := NIL ;
                         OWNER := FLDOWNER ;
                         KLASS := FIELD ;
                         if GET_STAT then
                           FLDOWNER -> . NO_FLDS := FLDOWNER -> .
                                                   NO_FLDS + 1 ;
                       end (* with *) ;
                     if NXT1 = NIL then
                       NXT1 := LCP ;
                     if NXT <> NIL then
                       NXT -> . NEXT := LCP ;
                     NXT := LCP ;
                     ENTERID ( LCP ) ;
                     INSYMBOL
                   end (* then *)
                 else
                   ERROR ( 2 ) ;
                 if not ( SY in [ COMMA , COLON ] ) then
                   begin
                     ERROR ( 6 ) ;
                     SKIP ( FSYS + [ COMMA , COLON , SEMICOLON , CASESY
                            ] )
                   end (* then *) ;
                 TEST := SY <> COMMA ;
                 if not TEST then
                   INSYMBOL
               until TEST ;
               if SY = COLON then
                 INSYMBOL
               else
                 ERROR ( 5 ) ;
               if FIRSTFLD = NIL then
                 FIRSTFLD := NXT1 ;
               TYP ( FSYS + [ CASESY , SEMICOLON ] , LSP , LSIZE ) ;
               LALNFCT := 1 ;
               if LSP <> NIL then
                 LALNFCT := LSP -> . ALN ;
               while NXT1 <> NIL do

           (******************************************)
           (* ANY "FIELDS" DEFINED IN THIS ROUND ?   *)
           (*                                        *)
           (******************************************)

                 begin
                   with NXT1 -> do
                     begin
                       IDTYPE := LSP ;
                       ALIGN ( DISPL , LALNFCT ) ;
                       FLDADDR := DISPL ;
                       DISPL := DISPL + LSIZE ;
                       NXT1 := NEXT ;
                     end (* with *) ;
                 end (* while *) ;
               if LALNFCT > RECALN then
                 RECALN := LSP -> . ALN ;
               if SY = SEMICOLON then
                 begin
                   INSYMBOL ;
                   if not ( SY in [ IDENT , CASESY , ENDSY ] ) then

           (**************)
           (* IGNOR EXTR *)
           (*            *)
           (*            *)
           (*   A ;      *)
           (**************)

                     begin
                       ERROR ( 19 ) ;
                       SKIP ( FSYS + [ IDENT , CASESY ] )
                     end (* then *)
                 end (* then *)
             end (* while *) ;
           if SY = CASESY then
             begin
               NEW ( LSP , TAGFLD ) ;
               with LSP -> do
                 begin
                   TAGFIELDP := NIL ;
                   FSTVAR := NIL ;
                   FORM := TAGFLD
                 end (* with *) ;
               FRECVAR := LSP ;
               INSYMBOL ;
               if SY = IDENT then
                 begin
                   NEW ( LCP , FIELD ) ;
                   with LCP -> do
                     begin
                       NAME := ID ;
                       IDTYPE := NIL ;
                       KLASS := FIELD ;
                       NEXT := NIL ;

           (****************************************)
           (*FLDADDR WILL BE SET WHEN TYPE IS KNOWN*)
           (****************************************)

                       OWNER := FLDOWNER ;
                       if GET_STAT then
                         FLDOWNER -> . NO_FLDS := FLDOWNER -> . NO_FLDS
                                                  + 1 ;
                     end (* with *) ;
                   INSYMBOL ;
                   if SY = COLON then

           (**********************)
           (* EXPLICIT TAG FIELD *)
           (**********************)

                     begin
                       ENTERID ( LCP ) ;
                       INSYMBOL ;
                       if SY <> IDENT then
                         goto 10
                     end (* then *)
                   else
                     begin
                       ID := LCP -> . NAME ;
                       LCP -> . NAME := BLANKID ;
                     end (* else *) ;
                   SEARCHID ( [ TYPES ] , LCP1 ) ;
                   LSP1 := LCP1 -> . IDTYPE ;
                   if LSP1 <> NIL then
                     with LSP1 -> do
                       begin
                         if LCP -> . NAME <> BLANKID then
                           begin
                             ALIGN ( DISPL , ALN ) ;
                             if ALN > RECALN then
                               RECALN := ALN ;
                             LCP -> . FLDADDR := DISPL ;
                             DISPL := DISPL + SIZE ;
                           end (* then *) ;
                         if ( FORM <= SUBRANGE ) or STRING ( LSP1 )
                         then
                           begin
                             if COMPTYPES ( REALPTR , LSP1 ) then
                               ERROR ( 109 )
                             else
                               if STRING ( LSP1 ) then
                                 ERROR ( 398 ) ;
                             LCP -> . IDTYPE := LSP1 ;
                             LSP -> . TAGFIELDP := LCP ;
                           end (* then *)
                         else
                           ERROR ( 110 ) ;
                       end (* with *) ;
                   if LCP -> . NAME <> BLANKID then
                     INSYMBOL ;
                 end (* then *)
               else
                 10 :
                 begin
                   ERROR ( 2 ) ;
                   SKIP ( FSYS + [ OFSY , LPARENT ] )
                 end ;
               LSP -> . SIZE := DISPL ;
               if SY = OFSY then
                 INSYMBOL
               else
                 ERROR ( 8 ) ;
               LSP1 := NIL ;
               MINSIZE := DISPL ;
               MAXSIZE := DISPL ;
               repeat
                 LSP2 := NIL ;
                 repeat
                   CONSTANT ( FSYS + [ COMMA , COLON , LPARENT ] , LSP3
                              , LVALU ) ;
                   if LSP -> . TAGFIELDP <> NIL then
                     if not COMPTYPES ( LSP -> . TAGFIELDP -> . IDTYPE
                     , LSP3 ) then
                       ERROR ( 111 ) ;
                   NEW ( LSP3 , VARIANT ) ;
                   with LSP3 -> do
                     begin
                       NXTVAR := LSP1 ;
                       SUBVAR := LSP2 ;
                       VARVAL := LVALU ;
                       FSTSUBFLD := NIL ;
                       FORM := VARIANT
                     end (* with *) ;
                   LSP1 := LSP3 ;
                   LSP2 := LSP3 ;
                   TEST := SY <> COMMA ;
                   if not TEST then
                     INSYMBOL
                 until TEST ;
                 if SY = COLON then
                   INSYMBOL
                 else
                   ERROR ( 5 ) ;
                 if SY = LPARENT then
                   INSYMBOL
                 else
                   ERROR ( 9 ) ;
                 FIELDLIST ( FSYS + [ RPARENT , SEMICOLON ] , LSP2 ,
                             LALNFCT , FLDOWNER , LCP1 ) ;
                 if LALNFCT > RECALN then
                   RECALN := LALNFCT ;
                 if DISPL > MAXSIZE then
                   MAXSIZE := DISPL ;
                 while LSP3 <> NIL do
                   with LSP3 -> do
                     begin
                       LSP4 := SUBVAR ;
                       SUBVAR := LSP2 ;
                       SIZE := DISPL ;
                       FSTSUBFLD := LCP1 ;
                       LSP3 := LSP4
                     end (* with *) ;
                 if SY = RPARENT then
                   begin
                     INSYMBOL ;
                     if not ( SY in FSYS + [ SEMICOLON ] ) then
                       begin
                         ERROR ( 6 ) ;
                         SKIP ( FSYS + [ SEMICOLON ] )
                       end (* then *)
                   end (* then *)
                 else
                   ERROR ( 4 ) ;
                 TEST := SY <> SEMICOLON ;
                 if not TEST then
                   begin
                     DISPL := MINSIZE ;
                     INSYMBOL ;
                     TEST := SY = ENDSY ;

           (*****************)
           (* IGNORE EXTRA ;*)
           (*****************)

                   end (* then *)
               until TEST ;
               DISPL := MAXSIZE ;
               LSP -> . FSTVAR := LSP1 ;
             end (* then *)
           else
             FRECVAR := NIL
         end (* FIELDLIST *) ;


      begin (* TYP *)
        OLDPACKST := PACKDATA ;
        if not ( SY in TYPEBEGSYS ) then
          begin
            ERROR ( 10 ) ;
            SKIP ( FSYS + TYPEBEGSYS )
          end (* then *) ;
        if SY in TYPEBEGSYS then
          begin
            if SY in SIMPTYPEBEGSYS then
              SIMPLETYPE ( FSYS , FSP )
            else

        (********)
        (*@     *)
        (********)

              if SY = ARROW then
                begin
                  NEW ( LSP , POINTER ) ;
                  FSP := LSP ;
                  with LSP -> do
                    begin
                      ELTYPE := NIL ;
                      SIZE := PTRSIZE ;
                      ALN := PTRSIZE ;
                      FORM := POINTER
                    end (* with *) ;
                  INSYMBOL ;
                  if SY = IDENT then
                    begin
                      PRTERR := FALSE ;

        (***********************************)
        (*NO ERROR IF SEARCH NOT SUCCESSFUL*)
        (***********************************)

                      SEARCHID ( [ TYPES ] , LCP ) ;
                      PRTERR := TRUE ;
                      if LCP = NIL then

        (****************************)
        (*FORWARD REFERENCED TYPE ID*)
        (****************************)

                        begin
                          NEW ( LCP , TYPES ) ;
                          with LCP -> do
                            begin
                              NAME := ID ;
                              IDTYPE := LSP ;
                              NEXT := FWPTR ;
                              KLASS := TYPES
                            end (* with *) ;
                          FWPTR := LCP
                        end (* then *)
                      else
                        begin
                          if LCP -> . IDTYPE <> NIL then
                            if LCP -> . IDTYPE -> . FORM = FILES then
                              ERROR ( 108 )
                            else
                              LSP -> . ELTYPE := LCP -> . IDTYPE
                        end (* else *) ;
                      INSYMBOL ;
                    end (* then *)
                  else
                    ERROR ( 2 ) ;
                end (* then *)
              else
                begin

        "********"
        "01/07   "
        "********"

                  LSP := NIL ;
                  if SY = PACKEDSY then
                    begin
                      INSYMBOL ;
                      PACKDATA := TRUE ;
                      if not ( SY in TYPEDELS ) then
                        begin
                          ERROR ( 10 ) ;
                          SKIP ( FSYS + TYPEDELS )
                        end (* then *)
                    end (* then *)
                  else
                    PACKDATA := FALSE ;

        (********)
        (*ARRAY *)
        (********)

                  if SY = ARRAYSY then
                    begin
                      INSYMBOL ;
                      if SY = LBRACK then
                        INSYMBOL
                      else
                        begin
                          if SY = LPARENT then
                            begin
                              ERRKIND := 'W' ;
                              INSYMBOL
                            end (* then *) ;
                          ERROR ( 11 )
                        end (* else *) ;
                      LSP1 := NIL ;
                      PACKST2 := PACKDATA ;
                      PACKDATA := FALSE ;
                      repeat
                        NEW ( LSP , ARRAYS ) ;
                        with LSP -> do
                          begin
                            AELTYPE := LSP1 ;
                            INXTYPE := NIL ;
                            FORM := ARRAYS
                          end (* with *) ;
                        LSP1 := LSP ;
                        SIMPLETYPE ( FSYS + [ COMMA , RBRACK , OFSY ,
                                     RPARENT ] , LSP2 ) ;
                        if LSP2 <> NIL then
                          if LSP2 -> . FORM <= SUBRANGE then
                            begin
                              if LSP2 = REALPTR then
                                begin
                                  ERROR ( 109 ) ;
                                  LSP2 := NIL
                                end (* then *)
                              else
                                if LSP2 = INTPTR then
                                  begin
                                    ERROR ( 149 ) ;
                                    LSP2 := NIL
                                  end (* then *) ;
                              LSP -> . INXTYPE := LSP2
                            end (* then *)
                          else
                            begin
                              ERROR ( 113 ) ;
                              LSP2 := NIL
                            end (* else *) ;
                        TEST := SY <> COMMA ;
                        if not TEST then
                          INSYMBOL
                      until TEST ;
                      if SY = RBRACK then
                        INSYMBOL
                      else
                        begin
                          if SY = RPARENT then
                            begin
                              ERRKIND := 'W' ;
                              INSYMBOL
                            end (* then *) ;
                          ERROR ( 12 )
                        end (* else *) ;
                      if SY = OFSY then
                        INSYMBOL
                      else
                        ERROR ( 8 ) ;
                      PACKDATA := PACKST2 ;
                      TYP ( FSYS , LSP , LSIZE ) ;
                      if LSP <> NIL then
                        ALIGN ( LSIZE , LSP -> . ALN ) ;
                      repeat
                        with LSP1 -> do
                          begin
                            LSP2 := AELTYPE ;
                            AELTYPE := LSP ;
                            if INXTYPE <> NIL then
                              begin
                                GETBOUNDS ( INXTYPE , LMIN , LMAX ) ;
                                LSIZE := LSIZE * ( LMAX - LMIN + 1 ) ;
                                SIZE := LSIZE ;
                                if LSP <> NIL then
                                  ALN := LSP -> . ALN

        (*****************)
        (*PROPAGATE ALN  *)
        (*               *)
        (*               *)
        (*               *)
        (*               *)
        (*****************)


                                         ;
                              end (* then *)

        "********"
        "01/07   "
        "********"

                            else

        (***************)
        (*INXTYPE = NIL*)
        (***************)

                              SIZE := 0
                          end (* with *) ;
                        LSP := LSP1 ;
                        LSP1 := LSP2
                      until LSP1 = NIL
                    end (* then *)
                  else

        (********)
        (*RECORD*)
        (********)

                    if SY = RECORDSY then
                      begin
                        INSYMBOL ;
                        if GET_STAT then
                          RE_CNT := RE_CNT + 1 ;
                        if TOP < DISPLIMIT then
                          begin
                            TOP := TOP + 1 ;
                            with DISPLAY [ TOP ] do
                              OCCUR := REC
                          end (* then *)
                        else
                          FATALERROR ( 250 ) ;
                        DISPL := 0 ;
                        NEW ( LSP , RECORDS ) ;
                        with LSP -> do
                          begin
                            FLD_DISP_LEV := TOP ;
                            FSTFLD := NIL ;
                            NO_FLDS := 0 ;
                            FIELDLIST ( FSYS - [ SEMICOLON ] + [ ENDSY
                                        ] , LSP1 , ALNFCT , LSP ,
                                        FSTFLD ) ;
                            RECVAR := LSP1 ;
                            SIZE := DISPL ;
                            FORM := RECORDS ;
                            ALN := ALNFCT ;
                            FLD_DISP_LEV := - 1 ;
                          end (* with *) ;
                        TOP := TOP - 1 ;
                        if SY = ENDSY then
                          INSYMBOL
                        else
                          ERROR ( 13 )
                      end (* then *)
                    else

        (********)
        (*SET   *)
        (********)

                      if SY = SETSY then
                        begin
                          INSYMBOL ;
                          if SY = OFSY then
                            INSYMBOL
                          else
                            ERROR ( 8 ) ;
                          PACKDATA := FALSE ;
                          SIMPLETYPE ( FSYS , LSP1 ) ;
                          if LSP1 <> NIL then
                            if LSP1 = INTPTR then
                              ERROR ( 304 )
                            else
                              if ( LSP1 -> . FORM > SUBRANGE ) then
                                begin
                                  ERROR ( 115 ) ;
                                  LSP1 := NIL
                                end (* then *)
                              else
                                if LSP1 = REALPTR then
                                  ERROR ( 114 )
                                else
                                  if LSP1 -> . FORM = SUBRANGE then
                                    if LSP1 -> . MAX . IVAL > SETMAX
                                    then
                                      ERROR ( 304 ) ;
                          NEW ( LSP , POWER ) ;
                          with LSP -> do
                            begin
                              ELSET := LSP1 ;
                              SIZE := CALC_SETSIZE ( LSP1 ) ;
                              ALN := WORDSIZE ;
                              FORM := POWER
                            end (* with *) ;
                        end (* then *)
                      else

        (********)
        (*FILE  *)
        (********)

                        if SY = FILESY then
                          begin
                            INSYMBOL ;
                            if SY = OFSY then
                              INSYMBOL
                            else
                              ERROR ( 8 ) ;
                            TYP ( FSYS , LSP1 , LSIZE ) ;
                            LSP := TEXTPTR ;

        (**************************)
        (* ASSUME THE COMMON CASE *)
        (**************************)

                            if LSP1 <> NIL then
                              if LSP1 <> CHARPTR then

        (***************)
        (* NOT A TEXTF *)
        (*             *)
        (*             *)
        (*             *)
        (*       ILE   *)
        (***************)

                                if LSP1 -> . FORM <> FILES then
                                  begin
                                    NEW ( LSP , FILES ) ;
                                    with LSP -> do
                                      begin
                                        FILTYPE := LSP1 ;
                                        ALN := LSP1 -> . ALN ;
                                        SIZE := LSIZE + FILHDRSIZE ;
                                        if ALN < PTRSIZE then
                                          ALN := PTRSIZE ;
                                        FORM := FILES ;
                                      end (* with *)
                                  end (* then *)
                                else
                                  begin
                                    LSP := NIL ;
                                    ERROR ( 108 )
                                  end (* else *) ;
                          end (* then *) ;
                  FSP := LSP
                end (* else *) ;
            if not ( SY in FSYS ) then
              begin
                ERROR ( 6 ) ;
                SKIP ( FSYS )
              end (* then *)
          end (* then *)
        else
          FSP := NIL ;
        if FSP = NIL then
          FSIZE := 1
        else
          FSIZE := FSP -> . SIZE ;
        PACKDATA := OLDPACKST ;
      end (* TYP *) ;


   procedure LABELDECLARATION ;

      var LLP : LBP ;
          REDEF : BOOLEAN ;
          LBNAME : LABELRNG ;

      begin (* LABELDECLARATION *)
        repeat
          if SY = INTCONST then
            with DISPLAY [ TOP ] do
              begin
                LLP := FLABEL ;
                REDEF := FALSE ;
                while ( LLP <> NIL ) and not REDEF do
                  if LLP -> . LABVAL <> VAL . IVAL then
                    LLP := LLP -> . NEXTLAB
                  else
                    begin
                      REDEF := TRUE ;
                      ERROR ( 166 )
                    end (* else *) ;
                if not REDEF then
                  begin
                    NEW ( LLP ) ;
                    with LLP -> do
                      begin
                        LABVAL := VAL . IVAL ;
                        GENLABEL ( LBNAME ) ;
                        XNO := 0 ;

        (**********************************)
        (* 0 => NOT AN EXTERNAL ENTRY PT. *)
        (**********************************)

                        DEFINED := FALSE ;
                        NEXTLAB := FLABEL ;
                        LABNAME := LBNAME
                      end (* with *) ;
                    FLABEL := LLP
                  end (* then *) ;
                INSYMBOL
              end (* with *)
          else
            ERROR ( 15 ) ;
          if not ( SY in FSYS + [ COMMA , SEMICOLON ] ) then
            begin
              ERROR ( 6 ) ;
              SKIP ( FSYS + [ COMMA , SEMICOLON ] )
            end (* then *) ;
          TEST := SY <> COMMA ;
          if not TEST then
            INSYMBOL
        until TEST ;
        if SY = SEMICOLON then
          INSYMBOL
        else
          ERROR ( 14 )
      end (* LABELDECLARATION *) ;


   procedure WRITESET ( SP : CSP ) ;

      var I , J , K , L , E , COL , LEN : INTEGER ;
          S : SETRANGE ;
          DELIM : CHAR ;

      begin (* WRITESET *)
        LEN := SP -> . PLNGTH ;
        S := SP -> . PVAL ;
        I := 1 ;
        DELIM := '(' ;
        J := 0 ;
        K := 0 ;
        L := 0 ;
        COL := 8 ;
        for E := 1 to LEN * ( SETPACK DIV WORDSIZE ) do
          begin
            J := J * 2 ;
            if K in S [ I ] then
              J := J + 1 ;
            L := L + 1 ;
            if L = 16 then
              begin
                L := 0 ;
                if COL >= 65 then
                  begin
                    WRITELN ( PRR , DELIM ) ;
                    DELIM := ' ' ;
                    COL := 2
                  end (* then *) ;
                WRITE ( PRR , DELIM , J : 1 ) ;
                DELIM := ',' ;
                if J >= 1000 then
                  COL := COL + 6
                else
                  if J >= 10 then
                    COL := COL + 4
                  else
                    COL := COL + 2 ;
                J := 0 ;
              end (* then *) ;
            K := K + 1 ;
            if K > SSETMAX then
              begin
                K := 0 ;
                I := I + 1
              end (* then *) ;
          end (* for *) ;
        if LEN = 0 then
          WRITELN ( PRR , '()' )
        else
          WRITELN ( PRR , ')' ) ;
      end (* WRITESET *) ;


   procedure PUTIC ;

      begin (* PUTIC *)
        if LINECNT > OLDLN then
          begin
            WRITELN ( PRR , ' LOC ' , LINECNT : 1 ) ;
            OLDLN := LINECNT
          end (* then *) ;
      end (* PUTIC *) ;


   procedure STRUCTCONSTANT ( FSYS : SETOFSYS ; var FSP : STP ; var
                            FVALU : VALU ; var SLC : INTEGER ) ;

      label 10 ;

      var LSET : SETRANGE ;
          LVALU : VALU ;
          I , J , K , L , MAXELEM : INTEGER ;
          LSP , LSP1 , ELT , LRECVAR : STP ;
          FLDPR : CTP ;
          TEST : BOOLEAN ;
          CSTEXTNAME : array [ 1 .. EXTNAMSZ ] of CHAR ;


      procedure STOWCONST ( ELSP : STP ) ;

         var I , ELSIZE : INTEGER ;
             ELSP1 : STP ;
             CH : CHAR ;

         begin (* STOWCONST *)
           ELSP1 := ELSP ;
           if ELSP <> NIL then
             begin
               ALIGN ( CONSTLC , ELSP -> . ALN ) ;
               ELSIZE := ELSP -> . SIZE
             end (* then *)
           else
             ELSIZE := 1 ;
           STRUCTCONSTANT ( FSYS + [ COMMA , RPARENT ] , ELSP1 , LVALU
                            , I ) ;
           if not COMPTYPES ( ELSP , ELSP1 ) then
             begin
               ERROR ( 145 ) ;
               ELSP1 := NIL
             end (* then *) ;
           if ELSP1 <> NIL then
             if PRCODE then
               if I < 0 then
                 begin
                   PUTIC ;
                   WRITE ( PRR , CONSTLC : 1 , MN [ 70 ]

           (********)
           (*DFC   *)
           (********)


                           ) ;
                   if ELSP1 = REALPTR then
                     WRITELN ( PRR , 'R,' : 3 , LVALU . VALP -> . RVAL
                               )
                   else
                     if ELSP1 -> . FORM <= SUBRANGE then
                       begin
                         CH := 'I' ;
                         if ELSIZE = 2 then
                           CH := 'H'
                         else
                           if ELSIZE = 1 then
                             CH := 'B' ;
                         WRITELN ( PRR , CH : 2 , ',' , LVALU . IVAL :
                                   1 )
                       end (* then *)
                     else
                       if ELSP1 -> . FORM = POINTER then
                         WRITELN ( PRR , 'N' : 2 )
                       else
                         if ELSP1 -> . FORM = POWER then
                           begin
                             WRITE ( PRR , 'S,' : 3 ) ;
                             LVALU . VALP -> . PLNGTH := ELSP1 -> .
                                                   SIZE ;
                             WRITESET ( LVALU . VALP ) ;
                           end (* then *)
                         else
                           if STRING ( ELSP1 ) then
                             begin
                               WRITE ( PRR , 'M,''' : 4 ) ;
                               I := 1 ;
                               with LVALU . VALP -> do
                                 while I <= SLNGTH do
                                   begin
                                     WRITE ( PRR , SVAL [ I ] : 1 ) ;
                                     if SVAL [ I ] = '''' then
                                       WRITE ( PRR , '''' ) ;
                                     I := I + 1
                                   end (* while *) ;
                               WRITELN ( PRR , '''' ) ;
                             end (* then *) ;
                   CONSTLC := CONSTLC + ELSIZE ;
                 end (* then *) ;
         end (* STOWCONST *) ;


      begin (* STRUCTCONSTANT *)
        LSP := FSP ;
        FVALU . IVAL := 0 ;
        SLC := - 1 ;
        if SY in CONSTBEGSYS then

        (*****************)
        (*SIMPLE CONSTANT*)
        (*****************)

          begin
            CONSTANT ( FSYS , FSP , FVALU ) ;
            if not COMPTYPES ( LSP , FSP ) then
              begin
                ERROR ( 145 ) ;
                FSP := NIL
              end (* then *)
            else
              if LSP <> NIL then
                FSP := LSP
          end (* then *)
        else
          if SY = LBRACK then

        (**************)
        (*SET CONSTANT*)
        (**************)

            begin
              INSYMBOL ;
              ELT := NIL ;
              MAXELEM := - 1 ;
              for I := 1 to ( SETMAX + 1 ) DIV ( SSETMAX + 1 ) do
                LSET [ I ] := [ ] ;
              if LSP <> NIL then
                if LSP -> . FORM = POWER then
                  ELT := LSP -> . ELSET
                else
                  ERROR ( 145 ) ;
              TEST := FALSE ;
              if SY <> RBRACK then
                repeat
                  CONSTANT ( FSYS + [ RBRACK , COMMA , DOTDOT ] , LSP1
                             , LVALU ) ;
                  if not COMPTYPES ( LSP1 , ELT ) then
                    ERROR ( 145 ) ;
                  ELT := LSP1 ;
                  I := LVALU . IVAL ;
                  if SY = DOTDOT then
                    begin
                      INSYMBOL ;
                      CONSTANT ( FSYS + [ RBRACK , COMMA ] , LSP1 ,
                                 LVALU ) ;
                      if not COMPTYPES ( LSP1 , ELT ) then
                        begin
                          LVALU . IVAL := I ;
                          ERROR ( 137 )
                        end (* then *)
                    end (* then *) ;
                  if ( I < 0 ) or ( LVALU . IVAL > SETMAX ) or ( I >
                  LVALU . IVAL ) then
                    ERROR ( 137 )
                  else
                    begin
                      if LVALU . IVAL > MAXELEM then
                        MAXELEM := LVALU . IVAL ;
                      repeat
                        J := I DIV ( SSETMAX + 1 ) ;
                        LSET [ J + 1 ] := LSET [ J + 1 ] + [ I - J * (
                                          SSETMAX + 1 ) ] ;
                        I := I + 1
                      until I > LVALU . IVAL
                    end (* else *) ;
                  if SY = COMMA then
                    INSYMBOL
                  else
                    TEST := TRUE ;
                until TEST ;
              if SY = RBRACK then
                INSYMBOL
              else
                ERROR ( 12 ) ;
              NEW ( FVALU . VALP , PSET ) ;
              with FVALU . VALP -> do
                begin
                  PVAL := LSET ;
                  PLNGTH := ( ( MAXELEM + SETPACK ) DIV SETPACK ) *
                            WORDSIZE ;
                end (* with *) ;
              if LSP = NIL then
                begin
                  NEW ( LSP , POWER ) ;
                  with LSP -> do
                    begin
                      ELSET := ELT ;
                      FORM := POWER ;
                      SIZE := FVALU . VALP -> . PLNGTH ;
                      ALN := WORDSIZE
                    end (* with *) ;
                  FSP := LSP
                end (* then *)
            end (* then *)
          else
            if SY = LPARENT then

        (**************************)
        (*ARRAY OR RECORD CONSTANT*)
        (**************************)

              begin
                INSYMBOL ;
                K := 0 ;
                if CONSTLC < 0 then

        (****************************)
        (* NO CONSTANTS WRITTEN YET *)
        (****************************)

                  with FPROCP -> do
                    begin
                      CSTEXTNAME := EXTNAME ;
                      I := EXTNAMSZ ;
                      if FPROCP <> MAINPROG then
                        if not EXTRN then
                          I := 5 ;
                      repeat
                        CSTEXTNAME [ I ] := '#' ;
                        I := I - 1
                      until CSTEXTNAME [ I ] <> ' ' ;
                      WRITELN ( PRR , CSTEXTNAME , MN [ 71 ]

        (********)
        (*CST   *)
        (********)


                                , ' ' , NAME , PFNAME : 5 , ',' ,
                                ASSEMBLE : 1 , ',' , GET_STAT : 1 , ','
                                , ASMVERB : 1 ) ;
                      CONSTLC := FIRSTCONSTLC ;
                    end (* with *) ;
                if LSP <> NIL then
                  with LSP -> do
                    if FORM = ARRAYS then
                      begin
                        ALIGN ( CONSTLC , ALN ) ;
                        SLC := CONSTLC ;
                        J := SLC ;
                        if AELTYPE <> NIL then
                          L := AELTYPE -> . SIZE
                        else
                          L := 1 ;
                        ALIGN ( L , ALN ) ;
                        TEST := FALSE ;
                        repeat
                          K := K + 1 ;
                          STOWCONST ( AELTYPE ) ;
                          if SY = COMMA then
                            begin
                              INSYMBOL ;
                              J := J + L ;
                              CONSTLC := J
                            end (* then *)
                          else
                            TEST := TRUE
                        until TEST ;
                        if SY = RPARENT then
                          INSYMBOL
                        else
                          ERROR ( 4 ) ;
                        if INXTYPE <> NIL then
                          begin
                            GETBOUNDS ( INXTYPE , I , J ) ;
                            J := J - I + 1
                          end (* then *)
                        else
                          J := SIZE DIV L ;
                        if K <> J then
                          if K > J then
                            ERROR ( 207 )
                          else
                            begin
                              ERRKIND := 'W' ;
                              ERROR ( 306 ) ;
                              if PRCODE then
                                WRITELN ( PRR , SLC + SIZE - 1 : 1 , MN
                                          [ 70 ]

        (********)
        (*DFC   *)
        (********)


                                          , ' B,0' ) ;
                            end (* else *) ;
                        CONSTLC := SLC + SIZE ;
                      end (* then *)
                    else
                      if FORM = RECORDS then
                        begin
                          ALIGN ( CONSTLC , ALN ) ;
                          SLC := CONSTLC ;
                          L := SIZE ;
                          LRECVAR := RECVAR ;
                          TEST := TRUE ;
                          FLDPR := FSTFLD ;
                          10 :
                          while TEST and ( FLDPR <> NIL ) do
                            with FLDPR -> do
                              begin
                                CONSTLC := SLC + FLDADDR ;
                                STOWCONST ( IDTYPE ) ;
                                FLDPR := NEXT ;
                                if SY = COMMA then
                                  INSYMBOL
                                else
                                  TEST := FALSE
                              end (* with *) ;
                          if TEST then
                            if LRECVAR <> NIL then

        (*******************)
        (*TAG FIELD VALUE  *)
        (*                 *)
        (*                 *)
        (*        IS NEXT  *)
        (*******************)

                              with LRECVAR -> do
                                if TAGFIELDP <> NIL then
                                  with TAGFIELDP -> do
                                    begin
                                      if NAME <> BLANKID then
                                        begin
                                          CONSTLC := SLC + FLDADDR ;
                                          STOWCONST ( IDTYPE )
                                        end (* then *)
                                      else
                                        begin
                                          CONSTANT ( FSYS + [ COMMA ,
                                                   RPARENT ] , LSP1 ,
                                                   LVALU ) ;
                                          if not COMPTYPES ( IDTYPE ,
                                          LSP1 ) then
                                            ERROR ( 145 ) ;
                                        end (* else *) ;
                                      if SY = COMMA then
                                        INSYMBOL
                                      else
                                        TEST := FALSE ;
                                      LSP1 := FSTVAR ;
                                      L := SIZE ;
                                      while LSP1 <> NIL do
                                        with LSP1 -> do
                                          if VARVAL = LVALU then
                                            begin
                                              LRECVAR := SUBVAR ;
                                              L := SIZE ;
                                              FLDPR := FSTSUBFLD ;
                                              goto 10
                                            end (* then *)
                                          else
                                            LSP1 := NXTVAR ;
                                    end (* with *) ;
                          CONSTLC := SLC + L ;
                          if SY <> RPARENT then
                            ERROR ( 4 )
                          else
                            INSYMBOL ;
                        end (* then *)
                      else
                        ERROR ( 208 ) ;

        (*************************)
        (*WRONG FORM FOR CONSTANT*)
        (*************************)

              end (* then *)
            else
              ERROR ( 50 ) ;
      end (* STRUCTCONSTANT *) ;


   procedure CONSTDECLARATION ;

      var LCP : CTP ;
          LSP : STP ;
          LVALU : VALU ;
          SKID : ALPHA ;
          SKLC : ADDRRANGE ;

      begin (* CONSTDECLARATION *)
        LISTTAG := 'C' ;
        if SY <> IDENT then
          begin
            ERROR ( 2 ) ;
            SKIP ( FSYS + [ IDENT ] )
          end (* then *) ;
        while SY = IDENT do
          begin
            SKID := ID ;
            INSYMBOL ;
            if SY = COLON then
              begin
                INSYMBOL ;
                EXTUSED := TRUE ;
                TYP ( FSYS + [ RELOP ] , LSP , SKLC ) ;
              end (* then *)
            else
              LSP := NIL ;
            if ( SY = RELOP ) and ( OP = EQOP ) then
              begin
                INSYMBOL ;
                STRUCTCONSTANT ( FSYS + [ SEMICOLON ] , LSP , LVALU ,
                                 SKLC ) ;
                if SKLC >= 0 then
                  NEW ( LCP , STRUCTKONST )
                else
                  NEW ( LCP , KONST ) ;
                with LCP -> do
                  begin
                    NAME := SKID ;
                    IDTYPE := LSP ;
                    NEXT := NIL ;
                    if SKLC >= 0 then
                      begin
                        KLASS := STRUCTKONST ;
                        SKOWNER := FPROCP ;
                        SKADDR := SKLC
                      end (* then *)
                    else
                      begin
                        KLASS := KONST ;
                        VALUES := LVALU
                      end (* else *)
                  end (* with *) ;
                ENTERID ( LCP ) ;
              end (* then *)
            else
              ERROR ( 16 ) ;
            if SY = SEMICOLON then
              begin
                INSYMBOL ;
                if not ( SY in FSYS + [ IDENT ] ) then
                  begin
                    ERROR ( 6 ) ;
                    SKIP ( FSYS + [ IDENT ] )
                  end (* then *)
              end (* then *)
            else
              ERROR ( 14 )
          end (* while *) ;
        LISTTAG := ' ' ;
      end (* CONSTDECLARATION *) ;


   procedure TYPEDECLARATION ;

      var LCP , LCP1 , LCP2 : CTP ;
          LSP : STP ;
          LSIZE : ADDRRANGE ;

      begin (* TYPEDECLARATION *)
        if SY <> IDENT then
          begin
            ERROR ( 2 ) ;
            SKIP ( FSYS + [ IDENT ] )
          end (* then *) ;
        while SY = IDENT do
          begin
            NEW ( LCP , TYPES ) ;
            with LCP -> do
              begin
                NAME := ID ;
                IDTYPE := NIL ;
                KLASS := TYPES
              end (* with *) ;
            INSYMBOL ;
            if ( SY = RELOP ) and ( OP = EQOP ) then
              INSYMBOL
            else
              ERROR ( 16 ) ;
            TYP ( FSYS + [ SEMICOLON ] , LSP , LSIZE ) ;
            ENTERID ( LCP ) ;
            LCP -> . IDTYPE := LSP ;

        (*******************************************)
        (*HAS ANY FORWARD REFERENCE BEEN SATISFIED:*)
        (*******************************************)

            LCP1 := FWPTR ;
            while LCP1 <> NIL do
              begin
                if LCP1 -> . NAME = LCP -> . NAME then
                  begin
                    LCP1 -> . IDTYPE -> . ELTYPE := LCP -> . IDTYPE ;
                    if LCP1 <> FWPTR then
                      LCP2 -> . NEXT := LCP1 -> . NEXT
                    else
                      FWPTR := LCP1 -> . NEXT ;
                  end (* then *) ;
                LCP2 := LCP1 ;
                LCP1 := LCP1 -> . NEXT
              end (* while *) ;
            if SY = SEMICOLON then
              begin
                INSYMBOL ;
                if not ( SY in FSYS + [ IDENT ] ) then
                  begin
                    ERROR ( 6 ) ;
                    SKIP ( FSYS + [ IDENT ] )
                  end (* then *)
              end (* then *)
            else
              ERROR ( 14 )
          end (* while *) ;
        if FWPTR <> NIL then
          begin
            ERROR ( 117 ) ;
            WRITELN ( OUTPUT ) ;
            PLCNT := PLCNT + 1 ;
            repeat
              WRITELN ( OUTPUT , ' UNDEFINED TYPE: ' , FWPTR -> . NAME
                        ) ;
              PLCNT := PLCNT + 1 ;
              FWPTR := FWPTR -> . NEXT
            until FWPTR = NIL ;
          end (* then *)
      end (* TYPEDECLARATION *) ;


   procedure VARDECLARATION ;

      var LCP , NXT , NXT1 : CTP ;
          LSP : STP ;
          LSIZE : ADDRRANGE ;
          LFPTR : FRECPTR ;

      begin (* VARDECLARATION *)
        LISTTAG := 'D' ;
        NXT := NIL ;
        repeat
          NXT1 := NIL ;
          repeat
            if SY = IDENT then
              begin
                NEW ( LCP , VARS ) ;
                with LCP -> do
                  begin
                    NAME := ID ;
                    NEXT := NIL ;
                    KLASS := VARS ;
                    IDTYPE := NIL ;
                    VKIND := ACTUAL ;
                    VLEV := LEVEL
                  end (* with *) ;
                ENTERID ( LCP ) ;
                if NXT1 = NIL then
                  NXT1 := LCP ;

        (*************************)
        (*BEGINNING OF THIS ROUND*)
        (*************************)

                if NXT <> NIL then
                  NXT -> . NEXT := LCP ;

        (************************)
        (*LINK TO PREVIOUS CHAIN*)
        (************************)

                NXT := LCP ;
                INSYMBOL ;
              end (* then *)
            else
              ERROR ( 2 ) ;
            if not ( SY in FSYS + [ COMMA , COLON ] + TYPEDELS ) then
              begin
                ERROR ( 6 ) ;
                SKIP ( FSYS + [ COMMA , COLON , SEMICOLON ] + TYPEDELS
                       )
              end (* then *) ;
            TEST := SY <> COMMA ;
            if not TEST then
              INSYMBOL
          until TEST ;
          if SY = COLON then
            INSYMBOL
          else
            ERROR ( 5 ) ;
          TYP ( FSYS + [ SEMICOLON ] + TYPEDELS , LSP , LSIZE ) ;
          while NXT1 <> NIL do
            with NXT1 -> do
              begin
                IDTYPE := LSP ;
                if LSP <> NIL then
                  begin
                    ALIGN ( LC , LSP -> . ALN ) ;
                    VADDR := LC ;
                    LC := LC + LSIZE ;
                    if LSP -> . FORM = FILES then
                      if LEVEL > 1 then
                        ERROR ( 398 )

        (*******************************)
        (* ONLY GLOBAL FILES SUPPORTED *)
        (*******************************)

                      else
                        begin
                          NEW ( LFPTR ) ;
                          LFPTR -> . FILIDPTR := NXT1 ;
                          LFPTR -> . NEXTFILE := FILEHEAD ;
                          FILEHEAD := LFPTR
                        end (* else *)
                  end (* then *)
                else
                  VADDR := LC ;
                if DEBUG_LEV > 0 then
                  PRNTSYMBL ( NXT1 ) ;
                NXT1 := NEXT ;
              end (* with *) ;
          if SY = SEMICOLON then
            begin
              INSYMBOL ;
              if not ( SY in FSYS + [ IDENT ] ) then
                begin
                  ERROR ( 6 ) ;
                  SKIP ( FSYS + [ IDENT ] )
                end (* then *)
            end (* then *)
          else
            ERROR ( 14 )
        until ( SY <> IDENT ) and not ( SY in TYPEDELS ) ;
        LISTTAG := ' ' ;
        if FWPTR <> NIL then
          begin
            ERROR ( 117 ) ;
            WRITELN ( OUTPUT ) ;
            PLCNT := PLCNT + 1 ;
            repeat
              WRITELN ( OUTPUT , ' UNDEFINED TYPE: ' , FWPTR -> . NAME
                        ) ;
              PLCNT := PLCNT + 1 ;
              FWPTR := FWPTR -> . NEXT
            until FWPTR = NIL ;
          end (* then *) ;
      end (* VARDECLARATION *) ;


   procedure MKNAME ( var ALB : ALPHA ; NLB : INTEGER ; NCFLAG :
                    BOOLEAN ) ;

      var I , J : INTEGER ;

      begin (* MKNAME *)
        I := 1 ;
        J := 8 ;
        if not NCFLAG then
          J := 5 ;
        repeat
          if ALB [ I ] = '_' then
            ALB [ I ] := '$' ;
          I := I + 1
        until ( I > J ) or ( ALB [ I ] = ' ' ) ;
        if not NCFLAG then
          for J := 8 DOWNTO I do
            begin
              ALB [ J ] := CHR ( ORD ( '0' ) + NLB MOD 10 ) ;
              NLB := NLB DIV 10
            end (* for *) ;
      end (* MKNAME *) ;


   procedure PROCDECLARATION ( FSY : SYMBOL ) ;

      label 10 ;

      var LSY : SYMBOL ;
          LCP , LCP1 , LCP2 : CTP ;
          LSP : STP ;
          FORW : BOOLEAN ;
          K , PARCNT : INTEGER ;
          OLDLABEL : LABELRNG ;
          LLC , LCM : ADDRRANGE ;
          I , NAME : INTEGER ;
          MARKP : -> INTEGER ;
          OLD_HASH : HASH_TABLE ;


      procedure PARAMETERLIST ( FSY : SETOFSYS ; FPAR : CTP ; FW :
                              BOOLEAN ) ;

         var LCP , LCP1 , LCP2 , LCP3 , LCP4 : CTP ;
             LSP : STP ;
             LKIND : IDKIND ;
             LLC , LEN , LALN : ADDRRANGE ;
             LSY : SYMBOL ;

         begin (* PARAMETERLIST *)
           LCP1 := NIL ;
           LCP := NIL ;
           if not ( SY in FSY + [ LPARENT ] ) then
             begin
               ERROR ( 7 ) ;
               SKIP ( FSYS + FSY + [ LPARENT ] )
             end (* then *) ;
           if SY = LPARENT then
             begin
               if FORW then
                 ERROR ( 119 )
               else
                 LC := LCAFTMST + FPSAVEAREA ;
               INSYMBOL ;
               if not ( SY in [ IDENT , VARSY , PROCSY , FUNCSY ] )
               then
                 begin
                   ERROR ( 7 ) ;
                   SKIP ( FSYS + [ IDENT , RPARENT ] )
                 end (* then *) ;
               while SY in [ IDENT , VARSY , PROCSY , FUNCSY ] do
                 begin
                   LCP3 := NIL ;
                   if SY in [ PROCSY , FUNCSY ] then
                     begin
                       LSY := SY ;

           (***************************)
           (*REMEMBER IF PROC OR FUNC *)
           (***************************)

                       INSYMBOL ;
                       if SY = IDENT then
                         begin
                           if LSY = PROCSY then
                             NEW ( LCP , PROC , DECLARED )
                           else
                             NEW ( LCP , FUNC , DECLARED ) ;
                           if LCP3 <> NIL then
                             LCP4 -> . NEXT := LCP
                           else
                             LCP3 := LCP ;
                           LCP4 := LCP ;
                           ALIGN ( LC , PTRSIZE ) ;
                           with LCP -> do
                             begin
                               NAME := ID ;
                               IDTYPE := NIL ;
                               NEXT := NIL ;
                               PFDECKIND := DECLARED ;
                               PFKIND := FORMAL ;
                               FRTRN := FALSE ;
                               EXTRN := FALSE ;
                               EXTNAME := '*PFPARM*' ;
                               PFLEV := LC * 10 + LEVEL ;

           (***************************************)
           (*I.E. PFLEV > LCAFTMST => PROC PARM   *)
           (*                                     *)
           (*                                     *)
           (***************************************)

                               PROCLAB := PROCLAB + 1 ;
                               PFNAME := PROCLAB ;
                               if LSY = PROCSY then
                                 KLASS := PROC
                               else
                                 KLASS := FUNC ;
                             end (* with *) ;
                           ENTERID ( LCP ) ;
                           LC := LC + DISPAREA ;
                           INSYMBOL ;
                           LLC := LC ;
                           if LSY = PROCSY then
                             PARAMETERLIST ( [ SEMICOLON , RPARENT ] ,
                                             LCP , FALSE )
                           else
                             PARAMETERLIST ( [ SEMICOLON , COLON ] ,
                                             LCP , FALSE ) ;
                           LC := LLC ;
                         end (* then *)
                       else
                         ERROR ( 2 ) ;
                       if not ( SY in FSYS + [ SEMICOLON , RPARENT ] )
                       then
                         begin
                           ERROR ( 7 ) ;
                           SKIP ( FSYS + [ SEMICOLON , RPARENT ] )
                         end (* then *)
                     end (* then *)
                   else
                     begin
                       if SY = VARSY then
                         begin
                           LKIND := FORMAL ;
                           INSYMBOL
                         end (* then *)
                       else
                         LKIND := ACTUAL ;
                       repeat
                         if SY = IDENT then
                           begin
                             NEW ( LCP , VARS ) ;
                             if LCP3 <> NIL then
                               LCP4 -> . NEXT := LCP
                             else
                               LCP3 := LCP ;
                             LCP4 := LCP ;
                             with LCP -> do
                               begin
                                 NAME := ID ;
                                 IDTYPE := NIL ;
                                 KLASS := VARS ;
                                 VKIND := LKIND ;
                                 NEXT := NIL ;
                                 VLEV := LEVEL ;
                               end (* with *) ;
                             ENTERID ( LCP ) ;
                             INSYMBOL ;
                           end (* then *) ;
                         if not ( SY in [ COMMA , COLON ] + FSYS ) then
                           begin
                             ERROR ( 7 ) ;
                             SKIP ( FSYS + [ COMMA , SEMICOLON ,
                                    RPARENT ] )
                           end (* then *) ;
                         TEST := SY <> COMMA ;
                         if not TEST then
                           INSYMBOL
                       until TEST ;
                       if SY = COLON then
                         begin
                           INSYMBOL ;
                           if SY = IDENT then
                             begin
                               SEARCHID ( [ TYPES ] , LCP4 ) ;
                               LEN := PTRSIZE ;
                               LSP := LCP4 -> . IDTYPE ;
                               LALN := PTRSIZE ;
                               if LSP <> NIL then
                                 if ( LKIND = ACTUAL ) then
                                   if LSP -> . FORM = FILES then
                                     begin
                                       ERROR ( 121 ) ;
                                       LKIND := FORMAL
                                     end (* then *)
                                   else
                                     begin
                                       LEN := LSP -> . SIZE ;
                                       LALN := LSP -> . ALN
                                     end (* else *) ;
                               LCP4 := LCP3 ;
                               while LCP4 <> NIL do
                                 begin
                                   with LCP4 -> do
                                     begin
                                       IDTYPE := LSP ;
                                       ALIGN ( LC , LALN ) ;
                                       VADDR := LC ;
                                       LC := LC + LEN ;
                                     end (* with *) ;
                                   LCP4 := LCP4 -> . NEXT
                                 end (* while *) ;
                               INSYMBOL
                             end (* then *)
                           else
                             ERROR ( 2 ) ;
                           if not ( SY in FSYS + [ SEMICOLON , RPARENT
                           ] ) then
                             begin
                               ERROR ( 7 ) ;
                               SKIP ( FSYS + [ SEMICOLON , RPARENT ] )
                             end (* then *)
                         end (* then *)
                       else
                         ERROR ( 5 ) ;
                     end (* else *) ;
                   if SY = SEMICOLON then
                     begin
                       INSYMBOL ;
                       if not ( SY in FSYS + [ IDENT , VARSY , PROCSY ,
                       FUNCSY ] ) then
                         begin
                           ERROR ( 7 ) ;
                           SKIP ( FSYS + [ IDENT , RPARENT ] )
                         end (* then *)
                     end (* then *) ;
                   if LCP1 <> NIL then
                     LCP2 -> . NEXT := LCP3
                   else
                     LCP1 := LCP3 ;
                   LCP2 := LCP ;
                 end (* while *) ;
               if SY = RPARENT then
                 begin
                   INSYMBOL ;
                   if not ( SY in FSY + FSYS ) then
                     begin
                       ERROR ( 6 ) ;
                       SKIP ( FSY + FSYS )
                     end (* then *)
                 end (* then *)
               else
                 ERROR ( 4 ) ;
             end (* then *)
           else

           (********************)
           (* IF SY <> LPARENT *)
           (********************)

             ;
           if not FW then
             FPAR -> . PRMPTR := LCP1 ;
           if FPAR -> . KLASS = FUNC then
             if SY = COLON then
               begin
                 INSYMBOL ;
                 if SY = IDENT then
                   begin
                     if FW then
                       ERROR ( 122 ) ;
                     SEARCHID ( [ TYPES ] , LCP1 ) ;
                     LSP := LCP1 -> . IDTYPE ;
                     FPAR -> . IDTYPE := LSP ;
                     if LSP <> NIL then
                       if LSP -> . FORM >= POWER then
                         begin
                           ERROR ( 120 ) ;
                           FPAR -> . IDTYPE := NIL
                         end (* then *) ;
                     INSYMBOL
                   end (* then *)
                 else
                   begin
                     ERROR ( 2 ) ;
                     SKIP ( FSYS + [ SEMICOLON ] )
                   end (* else *)
               end (* then *)
             else
               if not FW then
                 ERROR ( 123 )
         end (* PARAMETERLIST *) ;


      begin (* PROCDECLARATION *)
        LLC := LC ;
        LC := LCAFTMST + FPSAVEAREA ;

        (***************************)
        (* ADR. OF 1ST VAR OR PARM *)
        (***************************)

        LCM := LCAFTMST ;
        LCP := UPRCPTR ;

        (*******************************)
        (* TO INITIALIZE LCP IN CASE ! *)
        (*******************************)

        if SY = IDENT then
          begin

        (**************************************)
        (* SEE IF PROC. ON FORWARD DECL. LIST *)
        (**************************************)

            FORW := FALSE ;
            LCP := FWRDPRCL ;
            LCP2 := NIL ;
            while LCP <> NIL do
              if LCP -> . NAME = ID then
                begin
                  FORW := TRUE ;
                  if LCP2 <> NIL then
                    LCP2 -> . NXTFWRD := LCP -> . NXTFWRD
                  else
                    FWRDPRCL := LCP -> . NXTFWRD ;
                  goto 10 ;
                end (* then *)
              else
                begin
                  LCP2 := LCP ;
                  LCP := LCP -> . NXTFWRD
                end (* else *) ;
            10 :
            if not FORW then
              begin
                if FSY = PROCSY then
                  NEW ( LCP , PROC , DECLARED )
                else
                  NEW ( LCP , FUNC , DECLARED ) ;
                with LCP -> do
                  begin
                    NAME := ID ;
                    IDTYPE := NIL ;
                    PFLEV := LEVEL ;
                    PROCLAB := PROCLAB + 1 ;
                    PFDECKIND := DECLARED ;
                    PFKIND := ACTUAL ;
                    PFNAME := PROCLAB ;
                    MKNAME ( ID , PFNAME , XLINK ) ;
                    EXTRN := XLINK ;
                    FRTRN := FALSE ;
                    FWDECL := FALSE ;
                    PACK ( ID , 1 , EXTNAME ) ;
                    if FSY = PROCSY then
                      KLASS := PROC
                    else
                      KLASS := FUNC
                  end (* with *) ;
                ENTERID ( LCP ) ;
                OLD_HASH := BUCKET ;

        (*************************)
        (* NEW SCOPE BEGINS NEXT *)
        (*************************)

              end (* then *)
            else
              begin
                LCP1 := LCP -> . PRMPTR ;
                LCP -> . FWDECL := FALSE ;
                OLD_HASH := BUCKET ;

        (************************)
        (* NEW SCOPE BEGINS NOW *)
        (************************)

                LEVEL := LEVEL + 1 ;
                TOP := LEVEL ;
                while LCP1 <> NIL do
                  begin
                    ENTERID ( LCP1 ) ;

        (*******************************)
        (* NAME NEEDS TO BE RE-ENTERED *)
        (*******************************)

                    with LCP1 -> do
                      if KLASS = VARS then
                        if IDTYPE <> NIL then
                          begin
                            if VKIND = FORMAL then
                              LCM := VADDR + PTRSIZE
                            else
                              LCM := VADDR + IDTYPE -> . SIZE ;
                            if LCM > LC then
                              LC := LCM
                          end (* then *) ;
                    LCP1 := LCP1 -> . NEXT
                  end (* while *) ;
                LEVEL := LEVEL - 1 ;
                TOP := LEVEL
              end (* else *) ;
            INSYMBOL
          end (* then *)
        else
          ERROR ( 2 ) ;
        OLDLABEL := INTLABEL ;
        INTLABEL := 0 ;
        if LEVEL < MAXLEVEL then
          LEVEL := LEVEL + 1
        else
          FATALERROR ( 251 ) ;
        TOP := LEVEL ;
        with DISPLAY [ TOP ] do
          begin
            OCCUR := BLCK ;
            FLABEL := NIL
          end (* with *) ;
        if GET_STAT then
          PROC_CNT [ LEVEL ] := PROC_CNT [ LEVEL ] + 1 ;
        if FSY = PROCSY then
          PARAMETERLIST ( [ SEMICOLON ] , LCP , FORW )
        else
          PARAMETERLIST ( [ SEMICOLON , COLON ] , LCP , FORW ) ;
        LCP -> . FWDECL := FALSE ;
        if SY = SEMICOLON then
          INSYMBOL
        else
          ERROR ( 14 ) ;
        if SY in [ FORWARDSY , FRTRNSY , EXTRNSY ] then
          begin
            if SY = FORWARDSY then
              begin
                if FORW then
                  ERROR ( 161 ) ;
                LCP -> . FWDECL := TRUE ;
                LCP -> . NXTFWRD := FWRDPRCL ;

        (*******************)
        (* LINK PROC. INTO *)
        (*******************)

                FWRDPRCL := LCP ;

        (**********************)
        (* FORWARD PROC. LIST *)
        (**********************)

                INSYMBOL
              end (* then *)
            else
              begin

        (*********************************)
        (* SY MUST BE FRTRNSY OR EXTRNSY *)
        (*********************************)

                if SY = FRTRNSY then
                  LCP -> . FRTRN := TRUE
                else
                  LCP -> . EXTRN := TRUE ;
                INSYMBOL ;
                with LCP -> do
                  if SY = STRINGCONST then
                    with VAL . VALP -> do
                      begin
                        while LNGTH < EXTNAMSZ do
                          begin
                            LNGTH := LNGTH + 1 ;
                            SVAL [ I ] := ' '
                          end (* while *) ;
                        PACK ( SVAL , 1 , EXTNAME ) ;
                        INSYMBOL
                      end (* with *)
                  else
                    PACK ( NAME , 1 , EXTNAME ) ;
              end (* else *) ;
            if SY = SEMICOLON then
              INSYMBOL
            else
              ERROR ( 14 ) ;
            if not ( SY in FSYS ) then
              begin
                ERROR ( 6 ) ;
                SKIP ( FSYS )
              end (* then *)
          end (* then *)
        else
          begin
            if DEBUG_LEV > 0 then
              PRNTSYMBL ( LCP ) ;
            MARK ( MARKP ) ;

        (*****************************)
        (* MARK HEAP FOR BLOCK ENTRY *)
        (*****************************)

            repeat
              BLOCK ( FSYS , SEMICOLON , LCP ) ;
              if SY = SEMICOLON then
                begin
                  INSYMBOL ;
                  if not ( SY in [ BEGINSY , PROCSY , FUNCSY ] ) then
                    begin
                      ERROR ( 6 ) ;
                      SKIP ( FSYS )
                    end (* then *)
                end (* then *)
              else
                ERROR ( 14 )
            until SY in [ BEGINSY , PROCSY , FUNCSY ] ;
            RELEASE ( MARKP ) ;

        (****************************************)
        (* RETURN LOCAL ENTRIES ON RUNTIME HEAP *)
        (****************************************)

          end (* else *) ;
        LEVEL := LEVEL - 1 ;
        TOP := LEVEL ;
        LC := LLC ;
        INTLABEL := OLDLABEL ;
        BUCKET := OLD_HASH ;

        (**********************)
        (*RESTORE SYMBOL TABLE*)
        (**********************)

      end (* PROCDECLARATION *) ;


   function PROCTYPE ( FPROCP : CTP ) : INTEGER ;

      begin (* PROCTYPE *)
        PROCTYPE := ORD ( 'P' ) ;
        if FPROCP <> NIL then
          with FPROCP -> do
            begin
              if FRTRN then
                PROCTYPE := ORD ( 'F' ) ;
              if FPROCP -> . IDTYPE <> NIL then
                with FPROCP -> do
                  begin
                    if IDTYPE = REALPTR then
                      if FRTRN then
                        PROCTYPE := ORD ( 'Z' )
                      else
                        PROCTYPE := ORD ( 'R' )
                    else
                      if IDTYPE = BOOLPTR then
                        if FRTRN then
                          PROCTYPE := ORD ( 'X' )
                        else
                          PROCTYPE := ORD ( 'B' )
                      else
                        if IDTYPE -> . FORM = POINTER then
                          PROCTYPE := ORD ( 'A' )
                        else
                          if IDTYPE -> . SIZE = 1 then
                            PROCTYPE := ORD ( 'C' )
                          else
                            if FRTRN then
                              PROCTYPE := ORD ( 'Y' )
                            else
                              if IDTYPE -> . SIZE = HINTSIZE then
                                PROCTYPE := ORD ( 'H' )
                              else
                                PROCTYPE := ORD ( 'I' ) ;
                  end (* with *)
            end (* with *) ;
      end (* PROCTYPE *) ;


   procedure BODY ( FSYS : SETOFSYS ) ;

      const CIXMAX = 400 ;

      type OPRANGE = 0 .. OPMAX ;
           CALLED_PROC = record
                           NAME : ALPHA ;
                           LVL : LEVRANGE ;
                           CNT : 1 .. 100 ;
                           NXT : -> CALLED_PROC
                         end ;

      var CALL_HEAD , T2_CLIST , T_CLIST : -> CALLED_PROC ;
          LOCAL_CALL , MODIFYING : BOOLEAN ;

          (*********************************************)
          (* LOCAL_CALL = THIS PROC CALLS A LOCAL PROC *)
          (* MODIFYING = A PROGRAM VAR BEING MODIFIED  *)
          (*********************************************)

          VAR_REF , VAR_MOD : INTEGER ;

          (***************************************)
          (* # OF VARIABLES ACCESSED/REFERENCED  *)
          (***************************************)

          CNSTPTR : CSP ;
          I : INTEGER ;
          LCMAX , LLC1 : ADDRRANGE ;
          LCP , LLCP : CTP ;
          LLP : LBP ;
          FIRSTLN : INTEGER ;
          CTRNO : CTRRANGE ;
          LOOP0 : LOOPCTL ;
          SUBR : SUBRCTL ;
          LRETURN : LABELRNG ;


      procedure GEN0 ( FOP : OPRANGE ) ;

         begin (* GEN0 *)
           if PRCODE then
             begin
               PUTIC ;
               WRITELN ( PRR , MN [ FOP ] : 4 )
             end (* then *) ;
           IC := IC + 1
         end (* GEN0 *) ;


      procedure GEN1 ( FOP : OPRANGE ; FP2 : INTEGER ) ;

         var K : INTEGER ;

         begin (* GEN1 *)
           if PRCODE then
             begin
               PUTIC ;
               WRITE ( PRR , MN [ FOP ] : 4 ) ;
               if FOP = 30 then

           (********)
           (*CSP   *)
           (********)

                 WRITELN ( PRR , SNA [ FP2 ] : 4 )
               else
                 if FOP = 37 then

           (********)
           (*LCA   *)
           (********)

                   if FP2 = ORD ( 'P' ) then

           (**************************)
           (* LOAD PROCEDURE ADDRESS *)
           (**************************)

                     WRITELN ( PRR , ' P,' , ID : EXTNAMSZ )
                   else
                     if FP2 <> ORD ( 'S' ) then

           (********************)
           (* CHAR STRING OPND *)
           (********************)

                       begin
                         WRITE ( PRR , ' M,''' ) ;
                         with CNSTPTR -> do
                           begin
                             for K := 1 to SLNGTH do
                               begin
                                 WRITE ( PRR , SVAL [ K ] : 1 ) ;
                                 if SVAL [ K ] = '''' then
                                   WRITE ( PRR , '''' )
                               end (* for *) ;
                             STIC := STIC + SLNGTH ;
                           end (* with *) ;
                         WRITELN ( PRR , '''' )
                       end (* then *)
                     else

           (***************)
           (* SET OPERAND *)
           (***************)

                       begin
                         WRITE ( PRR , ' S,' ) ;
                         WRITESET ( CNSTPTR ) ;
                       end (* else *)
                 else
                   if ( FOP = 26 ) or ( FOP = 42 ) then

           (*********)
           (*STO,RET*)
           (*********)

                     WRITELN ( PRR , CHR ( FP2 ) : 2 )
                   else
                     WRITELN ( PRR , ' ' , FP2 : 1 )
             end (* then *) ;
           IC := IC + 1
         end (* GEN1 *) ;


      procedure GEN2 ( FOP : OPRANGE ; FP1 , FP2 : INTEGER ) ;

         var I , J , K : INTEGER ;

         begin (* GEN2 *)
           if PRCODE then
             begin
               PUTIC ;
               WRITE ( PRR , MN [ FOP ] : 4 , ' ' ) ;
               case FOP of
                 22 , 23 , 35 , 39 , 43 :


           (*********************)
           (*DEC,INC,IND,LDO,SRO*)
           (*********************)


                   WRITELN ( PRR , CHR ( FP1 ) , ',' , FP2 : 1 ) ;
                 29 , 41 , 50 , 58 , 68 , 69 :


           (*************************)
           (*MST,LDA,SCL,NEW,SLD,SMV*)
           (*************************)


                   WRITELN ( PRR , FP1 : 1 , ',' , FP2 : 1 ) ;
                 47 , 48 , 49 , 52 , 53 , 55 :


           (**********)
           (*EQU..NEQ*)
           (**********)


                   begin
                     WRITE ( PRR , CHR ( FP1 ) ) ;
                     if FP1 = ORD ( 'M' ) then
                       WRITE ( PRR , ',' , FP2 : 1 ) ;
                     WRITELN ( PRR )
                   end (* tag/ca *) ;
                 51 :

           (********)
           (*LDC   *)
           (********)


                      case FP1 of
                        0 : WRITELN ( PRR , 'C,''' , CHR ( FP2 ) : 1 ,
                                      '''' ) ;
                        1 : WRITELN ( PRR , 'I,' , FP2 : 1 ) ;
                        2 : begin
                              WRITE ( PRR , 'R,' ) ;
                              with CNSTPTR -> do
                                for K := 1 to REALLNGTH do
                                  if RVAL [ K ] <> ' ' then
                                    WRITE ( PRR , RVAL [ K ] ) ;
                              WRITELN ( PRR )
                            end (* tag/ca *) ;
                        3 : WRITELN ( PRR , 'B,' , FP2 : 1 ) ;
                        4 : WRITELN ( PRR , 'N' ) ;
                        otherwise
                          ERROR ( 400 ) ;
                      end (* case *)
               end (* case *) ;
             end (* then *) ;
           IC := IC + 1
         end (* GEN2 *) ;


      procedure GEN3 ( FOP : OPRANGE ; FP0 , FP1 , FP2 : INTEGER ) ;

         begin (* GEN3 *)
           if PRCODE then
             begin
               PUTIC ;
               if FOP = 76

           (********)
           (*PAK   *)
           (********)


               then
                 WRITELN ( PRR , MN [ FOP ] : 4 , ' ' , FP0 : 1 , ' ' ,
                           FP1 : 1 , ' ' , FP2 : 1 )
               else
                 WRITELN ( PRR , MN [ FOP ] : 4 , CHR ( FP0 ) : 2 , ','
                           , FP1 : 1 , ',' , FP2 : 1 )
             end (* then *) ;
           IC := IC + 1
         end (* GEN3 *) ;


      procedure LOAD ;

         begin (* LOAD *)
           with GATTR do
             if TYPTR <> NIL then
               begin
                 case KIND of
                   CST : if ( TYPTR -> . FORM = SCALAR ) and ( TYPTR <>
                         REALPTR ) then
                           if TYPTR = BOOLPTR then

           (********)
           (*LDC   *)
           (********)

                             GEN2 ( 51 , 3 , CVAL . IVAL )
                           else
                             if TYPTR = CHARPTR then

           (********)
           (*LDC   *)
           (********)

                               GEN2 ( 51 , 0 , CVAL . IVAL )
                             else

           (********)
           (*LDC   *)
           (********)

                               GEN2 ( 51 , 1 , CVAL . IVAL )

           (*********)
           (*INTEGER*)
           (*********)

                         else
                           if TYPTR = NILPTR then

           (********)
           (*LDC   *)
           (********)

                             GEN2 ( 51 , 4 , 0 )
                           else
                             begin
                               CNSTPTR := CVAL . VALP ;
                               if TYPTR = REALPTR then

           (********)
           (*LDC   *)
           (********)

                                 GEN2 ( 51 , 2 , 0 )
                               else

           (********)
           (*LDC   *)
           (********)

                                 GEN2 ( 51 , 5 , 0 )
                             end (* else *) ;
                   VARBL : case ACCESS of

           (********)
           (*LOD   *)
           (********)

                             DRCT : GEN3 ( 54 , GETTYPE ( BTYPE ) ,
                                           VLEVEL , DPLMT ) ;

           (********)
           (*IND   *)
           (********)

                             INDRCT :
                               GEN2 ( 35 , GETTYPE ( BTYPE ) , IDPLMT )
                                      ;
                             INXD , STKEXPR :
                               ERROR ( 400 )
                           end (* case *) ;
                   EXPR :
                 end (* case *) ;
                 if KIND = VARBL then
                   VAR_REF := VAR_REF + 1 ;
                 KIND := EXPR
               end (* then *)
         end (* LOAD *) ;


      procedure STORE ( var FATTR : ATTR ) ;

         begin (* STORE *)
           with FATTR do
             if TYPTR <> NIL then
               case ACCESS of

           (********)
           (*STR   *)
           (********)

                 DRCT : GEN3 ( 56 , GETTYPE ( BTYPE ) , VLEVEL , DPLMT
                               ) ;
                 INDRCT :
                   if IDPLMT <> 0 then
                     ERROR ( 400 )
                   else

           (********)
           (*STO   *)
           (********)

                     GEN1 ( 26 , GETTYPE ( BTYPE ) ) ;
                 INXD , STKEXPR :
                   ERROR ( 400 )
               end (* case *)
         end (* STORE *) ;


      procedure LOADADDRESS ;

         begin (* LOADADDRESS *)
           with GATTR do
             if TYPTR <> NIL then
               begin
                 case KIND of
                   CST : if STRING ( TYPTR ) then
                           begin
                             CNSTPTR := CVAL . VALP ;

           (********)
           (*LCA   *)
           (********)

                             GEN1 ( 37 , ORD ( 'M' ) ) ;
                           end (* then *)
                         else
                           if TYPTR -> . FORM = POWER then
                             begin
                               CNSTPTR := CVAL . VALP ;

           (********)
           (*LCA   *)
           (********)

                               GEN1 ( 37 , ORD ( 'S' ) )
                             end (* then *)
                           else
                             ERROR ( 400 ) ;
                   VARBL : case ACCESS of

           (********)
           (*LDA   *)
           (********)

                             DRCT : GEN2 ( 50 , VLEVEL , DPLMT ) ;
                             INDRCT :
                               if IDPLMT <> 0 then

           (********)
           (*INC   *)
           (********)

                                 GEN2 ( 23 , ORD ( 'A' ) , IDPLMT ) ;
                             INXD : ERROR ( 400 ) ;
                             STKEXPR :
                               ;

           (***************************************)
           (*SET ALREADY REPRESENTED BY AN ADDRESS*)
           (***************************************)

                           end (* case *) ;
                   EXPR : ERROR ( 400 )
                 end (* case *) ;
                 KIND := VARBL ;
                 ACCESS := INDRCT ;
                 IDPLMT := 0
               end (* then *)
         end (* LOADADDRESS *) ;


      procedure GENFJP ( FADDR : INTEGER ) ;

         begin (* GENFJP *)
           LOAD ;
           if GATTR . TYPTR <> NIL then
             if GATTR . TYPTR <> BOOLPTR then
               ERROR ( 144 ) ;
           if PRCODE then
             begin
               PUTIC ;
               WRITELN ( PRR , MN [ 33 ] : 4 , ' L' , FADDR : 1 )
             end (* then *) ;
           IC := IC + 1
         end (* GENFJP *) ;


      procedure GENUJPFJP ( FOP : OPRANGE ; FP2 : INTEGER ) ;

         begin (* GENUJPFJP *)
           if PRCODE then
             begin
               PUTIC ;
               WRITELN ( PRR , MN [ FOP ] : 4 , ' L' , FP2 : 1 )
             end (* then *) ;
           IC := IC + 1
         end (* GENUJPFJP *) ;


      procedure GENDEF ( L1 , L2 : ADDRRANGE ) ;

         begin (* GENDEF *)
           if PRCODE then

           (********)
           (*DEF   *)
           (********)

             WRITELN ( PRR , 'L' , L1 : 1 , MN [ 63 ] , L2 : 10 ) ;
         end (* GENDEF *) ;


      procedure CHKBNDS ( FSP : STP ) ;

         var LMIN , LMAX : INTEGER ;

         begin (* CHKBNDS *)
           if FSP <> NIL then
             if FSP <> BOOLPTR then
               if FSP <> INTPTR then
                 if FSP <> REALPTR then
                   if FSP -> . FORM <= POINTER then
                     if FSP -> . FORM = POINTER

           (**************)
           (*LMAX <= LMIN*)
           (**************)


                     then
                       begin
                         FLIPDEBUG := TRUE ;
                         if ASSIGN then

           (********)
           (*CHK   *)
           (********)

                           GEN3 ( 45 , ORD ( 'A' ) , - 1 , 0 )
                         else

           (**********)
           (* ACCESS *)
           (**********)

                           GEN3 ( 45 , ORD ( 'A' ) , 0 , 0 )

           (********)
           (*CHK   *)
           (********)

                       end (* then *)
                     else
                       begin
                         GETBOUNDS ( FSP , LMIN , LMAX ) ;

           (********)
           (*CHK   *)
           (********)

                         GEN3 ( 45 , ORD ( 'I' ) , LMIN , LMAX ) ;
                       end (* else *) ;
         end (* CHKBNDS *) ;


      procedure PUTLABEL ( LABNAME : INTEGER ) ;

         begin (* PUTLABEL *)
           if PRCODE then

           (********)
           (*LAB   *)
           (********)

             WRITELN ( PRR , 'L' , LABNAME : 1 , MN [ 64 ] )
         end (* PUTLABEL *) ;


      function CTRGEN : CTRRANGE ;

      (************************************)
      (* CREATE A UNIQUE STMT COUNTER     *)
      (* AND EMIT P-CODE TO INCREMENT IT  *)
      (* R. L. SITES  3 AUG 77            *)
      (************************************)


         begin (* CTRGEN *)
           CTRGEN := CTRCNT ;
           if CTROPTION then
             begin

           (********)
           (*CTI   *)
           (********)

               GEN1 ( 39 , CTRCNT ) ;
               CTRCNT := CTRCNT + 1 ;
             end (* then *) ;
         end (* CTRGEN *) ;

         (**********)
         (* CTRGEN *)
         (**********)



      procedure CTREMIT ( CTRT : CTRTYPE ; CTRNO : CTRRANGE ; FLN , MLN
                        , LLN : INTEGER ) ;

      (**************************************************)
      (* WRITE AN ENTRY DESCRIBING A STATEMENT COUNTER. *)
      (* R. L. SITES  3 AUG 77                          *)
      (**************************************************)


         begin (* CTREMIT *)
           if CTROPTION then
             WRITELN ( QRR , '#CTR    ' , ORD ( CTRT ) : 4 , CTRNO : 6
                       , FLN : 7 , MLN : 7 , LLN : 7 ) ;
         end (* CTREMIT *) ;


      procedure STATEMENT ( FSYS : SETOFSYS ; var LOOPC : LOOPCTL ; var
                          SUBR : SUBRCTL ) ;

         label 1 ;

         var LCP : CTP ;
             LLP : LBP ;
             TTOP : DISPRANGE ;
             XLABEL : ALPHA ;
             CTRNO : CTRRANGE ;


         procedure EXPRESSION ( FSYS : SETOFSYS ) ;

            FORWARD ;


         procedure FORCETEMPSET ;

         (**************************************)
         (* "LOADS" CURRENT SET ONTO RUN-STACK *)
         (**************************************)


            label 10 ;

            var LSIZE : ADDRRANGE ;

            begin (* FORCETEMPSET *)
              with GATTR do
                if TYPTR <> NIL then
                  if TYPTR -> . FORM = POWER

              (*****************)
              (*REDUNDANT TEST?*)
              (*****************)


                  then
                    begin
                      if KIND = VARBL then
                        if ACCESS = STKEXPR then
                          goto 10 ;
                      LSIZE := OPNDSETSIZE ( GATTR ) ;
                      ALIGN ( LC , WORDSIZE ) ;
                      LOADADDRESS ;

              (********)
              (*SLD   *)
              (********)

                      GEN2 ( 68 , LSIZE , LC ) ;
                      KIND := VARBL ;
                      ACCESS := STKEXPR ;
                      STKLEN := LSIZE ;
                      STKDPLMT := LC ;
                      LC := LC + LSIZE ;
                      if LC > LCMAX then
                        LCMAX := LC ;
                    end (* then *) ;
              10 :

            end (* FORCETEMPSET *) ;


         procedure SELECTOR ( FSYS : SETOFSYS ; FCP : CTP ) ;

            var LATTR : ATTR ;
                LCP : CTP ;
                LMIN , LMAX : INTEGER ;

            begin (* SELECTOR *)
              with FCP -> , GATTR do
                begin
                  TYPTR := IDTYPE ;
                  BTYPE := TYPTR ;
                  KIND := VARBL ;
                  case KLASS of
                    VARS : if VKIND = ACTUAL then
                             begin
                               ACCESS := DRCT ;
                               VLEVEL := VLEV ;
                               DPLMT := VADDR
                             end (* then *)
                           else
                             begin

              (********)
              (*LOD   *)
              (********)

                               GEN3 ( 54 , ORD ( 'A' ) , VLEV , VADDR )
                                      ;
                               ACCESS := INDRCT ;
                               IDPLMT := 0
                             end (* else *) ;
                    FIELD : with DISPLAY [ DISX ] do
                              if OCCUR = CREC then
                                begin
                                  ACCESS := DRCT ;
                                  VLEVEL := CLEV ;
                                  DPLMT := CDSPL + FLDADDR
                                end (* then *)
                              else
                                begin

              (********)
              (*LOD   *)
              (********)

                                  GEN3 ( 54 , ORD ( 'A' ) , LEVEL ,
                                         VDSPL ) ;
                                  ACCESS := INDRCT ;
                                  IDPLMT := FLDADDR
                                end (* else *) ;
                    STRUCTKONST :
                      begin
                        ID := '########    ' ;
                        LMAX := EXTNAMSZ ;
                        UNPACK ( SKOWNER -> . EXTNAME , ID , 1 ) ;
                        if ( SKOWNER <> MAINPROG ) then
                          if not SKOWNER -> . EXTRN then
                            LMAX := 5 ;
                        repeat
                          ID [ LMAX ] := '#' ;
                          LMAX := LMAX - 1
                        until ID [ LMAX ] <> ' ' ;

              (********)
              (*LCA   *)
              (********)

                        GEN1 ( 37 , ORD ( 'P' ) ) ;
                        ACCESS := INDRCT ;
                        IDPLMT := SKADDR
                      end (* tag/ca *) ;
                    FUNC : if FCP <> UFCTPTR then
                             if PFDECKIND = STANDARD then
                               ERROR ( 150 )
                             else
                               if PFLEV = 0 then
                                 ERROR ( 150 )

              (**************)
              (*EXTERNAL FCT*)
              (**************)

                               else
                                 if PFKIND = FORMAL then
                                   ERROR ( 151 )
                                 else
                                   if ( FPROCP <> FCP ) then
                                     ERROR ( 177 )
                                   else
                                     begin
                                       ACCESS := DRCT ;
                                       VLEVEL := PFLEV + 1 ;
                                       DPLMT := FNCRSLT ;

              (*****************************)
              (*RELAT. ADDR. OF FCT. RESULT*)
              (*****************************)

                                     end (* else *)
                  end (* case *) ;
                  if TYPTR <> NIL then
                    if TYPTR -> . FORM = SUBRANGE then
                      TYPTR := TYPTR -> . RANGETYPE ;
                end (* with *) ;
              if not ( SY in SELECTSYS + FSYS ) then
                begin
                  ERROR ( 59 ) ;
                  SKIP ( SELECTSYS + FSYS )
                end (* then *) ;
              while SY in SELECTSYS do
                begin
                  if SY = LPARENT then

              (****************************)
              (* THIS IS AN ERROR, BUT .. *)
              (****************************)

                    begin
                      SY := LBRACK ;
                      if GATTR . TYPTR <> NIL then
                        if GATTR . TYPTR -> . FORM = ARRAYS then
                          begin
                            ERRKIND := 'W' ;
                            ERROR ( 11 )
                          end (* then *)
                    end (* then *) ;

              (****************)
              (* LEFT BRACKET *)
              (****************)

                  if SY = LBRACK then
                    begin
                      repeat
                        LATTR := GATTR ;
                        with LATTR do
                          if TYPTR <> NIL then
                            if TYPTR -> . FORM <> ARRAYS then
                              begin
                                ERROR ( 138 ) ;
                                TYPTR := NIL
                              end (* then *) ;
                        LOADADDRESS ;
                        INSYMBOL ;
                        EXPRESSION ( FSYS + [ COMMA , RBRACK , RPARENT
                                     ] ) ;
                        LOAD ;
                        if GATTR . TYPTR <> NIL then
                          if GATTR . TYPTR -> . FORM <> SCALAR then
                            ERROR ( 113 ) ;
                        if LATTR . TYPTR <> NIL then
                          with LATTR . TYPTR -> do
                            begin
                              if COMPTYPES ( INXTYPE , GATTR . TYPTR )
                              then
                                begin
                                  if INXTYPE <> NIL then
                                    begin
                                      GETBOUNDS ( INXTYPE , LMIN , LMAX
                                                  ) ;
                                      if DEBUG then

              (********)
              (*CHK   *)
              (********)

                                        GEN3 ( 45 , ORD ( 'J' ) , LMIN
                                               , LMAX ) ;
                                      if LMIN > 0 then

              (********)
              (*DEC   *)
              (********)

                                        GEN2 ( 22 , GETTYPE ( GATTR .
                                               TYPTR ) , LMIN )
                                      else
                                        if LMIN < 0 then

              (********)
              (*INC   *)
              (********)

                                          GEN2 ( 23 , GETTYPE ( GATTR .
                                                 TYPTR ) , - LMIN )

              (**************************)
              (*OR SIMPLY GEN1(31, LMIN)*)
              (**************************)

                                    end (* then *)
                                end (* then *)
                              else
                                ERROR ( 139 ) ;
                              with GATTR do
                                begin
                                  TYPTR := AELTYPE ;
                                  KIND := VARBL ;
                                  ACCESS := INDRCT ;
                                  IDPLMT := 0 ;
                                  if GATTR . TYPTR <> NIL then
                                    begin
                                      LMIN := TYPTR -> . SIZE ;
                                      ALIGN ( LMIN , TYPTR -> . ALN ) ;

              (********)
              (*IXA   *)
              (********)

                                      GEN1 ( 36 , LMIN )
                                    end (* then *) ;
                                end (* with *) ;
                            end (* with *)
                      until SY <> COMMA ;
                      if SY = RBRACK then
                        INSYMBOL
                      else
                        begin
                          if SY = RPARENT then
                            begin
                              ERRKIND := 'W' ;
                              INSYMBOL
                            end (* then *) ;
                          ERROR ( 12 )
                        end (* else *) ;
                    end (* then *)
                  else

              (**********)
              (* PERIOD *)
              (**********)

                    if SY = PERIOD then
                      begin
                        with GATTR do
                          begin
                            if TYPTR <> NIL then
                              if TYPTR -> . FORM <> RECORDS then
                                begin
                                  ERROR ( 140 ) ;
                                  TYPTR := NIL
                                end (* then *) ;
                            INSYMBOL ;
                            if SY = IDENT then
                              begin
                                if TYPTR <> NIL then
                                  begin
                                    SEARCHSECTION ( TYPTR , LCP ) ;
                                    if LCP = NIL then
                                      begin
                                        ERROR ( 152 ) ;
                                        TYPTR := NIL
                                      end (* then *)
                                    else
                                      with LCP -> do
                                        begin
                                          TYPTR := IDTYPE ;
                                          case ACCESS of
                                            DRCT : DPLMT := DPLMT +
                                                   FLDADDR ;
                                            INDRCT :
                                              IDPLMT := IDPLMT +
                                                   FLDADDR ;
                                            INXD , STKEXPR :
                                              ERROR ( 400 )
                                          end (* case *)
                                        end (* with *)
                                  end (* then *) ;
                                INSYMBOL
                              end (* then *)
                            else
                              ERROR ( 2 )
                          end (* with *)
                      end (* then *)
                    else

              (******************)
              (* POINTER SYMBOL *)
              (******************)

                      begin
                        if GATTR . TYPTR <> NIL then
                          with GATTR , TYPTR -> do
                            if FORM = POINTER then
                              begin
                                LOAD ;
                                if DEBUG then
                                  CHKBNDS ( GATTR . TYPTR ) ;
                                TYPTR := ELTYPE ;
                                with GATTR do
                                  begin
                                    KIND := VARBL ;
                                    ACCESS := INDRCT ;
                                    IDPLMT := 0
                                  end (* with *)
                              end (* then *)
                            else
                              if FORM = FILES then
                                begin
                                  TYPTR := FILTYPE ;
                                  case ACCESS of
                                    DRCT : DPLMT := DPLMT + FILHDRSIZE
                                                   ;
                                    INDRCT :
                                      IDPLMT := IDPLMT + FILHDRSIZE ;
                                    INXD , STKEXPR :
                                      ERROR ( 400 )
                                  end (* case *)
                                end (* then *)
                              else
                                ERROR ( 141 ) ;
                        INSYMBOL
                      end (* else *) ;
                  if not ( SY in FSYS + SELECTSYS ) then
                    begin
                      ERROR ( 6 ) ;
                      SKIP ( FSYS + SELECTSYS )
                    end (* then *) ;
                  GATTR . BTYPE := GATTR . TYPTR ;
                  if GATTR . TYPTR <> NIL then
                    if GATTR . TYPTR -> . FORM = SUBRANGE then
                      GATTR . TYPTR := GATTR . TYPTR -> . RANGETYPE ;
                end (* while *) ;
            end (* SELECTOR *) ;


         procedure CALL ( FSYS : SETOFSYS ; FCP : CTP ) ;

            var LKEY : 0 .. NSPROC ;
                MATCHPAR : BOOLEAN ;
                RWFILE : STP ;


            procedure VARIABLE ( FSYS : SETOFSYS ) ;

               var LCP : CTP ;

               begin (* VARIABLE *)
                 if SY = IDENT then
                   begin
                     SEARCHID ( [ VARS , FIELD ] , LCP ) ;
                     INSYMBOL
                   end (* then *)
                 else
                   begin
                     ERROR ( 2 ) ;
                     LCP := UVARPTR
                   end (* else *) ;
                 SELECTOR ( FSYS , LCP )
               end (* VARIABLE *) ;


            procedure RWSETUP ( DFILE : CTP ) ;

            (***************************************************)
            (* TO SET UP FILE ADDRESS PARAMETER FOR READ/WRITE *)
            (***************************************************)


               var LCP : CTP ;
                   SAVED : BOOLEAN ;
                   TEMPID : ALPHA ;
                   TEMPSY : SYMBOL ;

               begin (* RWSETUP *)
                 SAVED := TRUE ;
                 RWFILE := NIL ;
                 if MATCHPAR then

                 (*************************************)
                 (* OTHERWISE THERE ARE NO PARAMETERS *)
                 (*************************************)

                   if SY = IDENT then
                     begin
                       SEARCHID ( [ VARS , FIELD , FUNC , KONST ,
                                  STRUCTKONST ] , LCP ) ;
                       if LCP -> . IDTYPE <> NIL then
                         with LCP -> . IDTYPE -> do
                           if FORM = FILES then
                             SAVED := FALSE ;
                     end (* then *) ;
                 if SAVED then

                 (*************************)
                 (* USE IMPLIED FILE NAME *)
                 (*************************)

                   begin
                     TEMPSY := SY ;
                     TEMPID := ID ;
                     SY := COMMA ;
                     LCP := DFILE ;
                   end (* then *)
                 else
                   INSYMBOL ;
                 SELECTOR ( FSYS + [ COMMA , RPARENT ] , LCP ) ;
                 with GATTR do
                   if not COMPTYPES ( TYPTR , TEXTPTR ) then
                     if TYPTR <> NIL then
                       if TYPTR -> . FORM <> FILES then
                         ERROR ( 116 )
                       else
                         begin
                           RWFILE := TYPTR -> . FILTYPE ;
                           if not ( LKEY in [ 1 .. 6 , 25 , 36 , 37 ] )
                           then
                             ERROR ( 116 ) ;

                 (**********************************************)
                 (*   NON-TEXT FILES PERMITTED ONLY FOR:       *)
                 (*   GET, PUT, RESET, READ, WRITE,            *)
                 (*   REWRITE, EOF, SKIP, LINELIMIT            *)
                 (**********************************************)

                         end (* else *) ;
                 LOADADDRESS ;

                 (****************)
                 (* GET FILE ADR *)
                 (****************)

                 GEN1 ( 30 , 31 ) ;

                 (************)
                 (* CSP, SIO *)
                 (************)

                 if SAVED then
                   begin
                     ID := TEMPID ;
                     SY := TEMPSY
                   end (* then *) ;
               end (* RWSETUP *) ;


            procedure GETPUTRESETREWRITE ;

               begin (* GETPUTRESETREWRITE *)
                 if ODD ( LKEY ) then
                   RWSETUP ( INPUTPTR )

                 (**************)
                 (* GET, RESET *)
                 (**************)

                 else
                   RWSETUP ( OUTPUTPTR ) ;

                 (**********************)
                 (* PUT, REWRITE, PAGE *)
                 (**********************)

                 GEN1 ( 30 , LKEY ) ;

                 (*****************************)
                 (* CSP - GET,PUT,RES,REW,PAG *)
                 (*****************************)

                 GEN1 ( 30 , 32 ) ;

                 (*************)
                 (* CSP - EIO *)
                 (*************)

               end (* GETPUTRESETREWRITE *) ;


            procedure READ1 ;

               var CSPNO : 0 .. NSPROC ;
                   TEST : BOOLEAN ;

               begin (* READ1 *)
                 RWSETUP ( INPUTPTR ) ;
                 if RWFILE <> NIL then
                   if LKEY = 11 then
                     ERROR ( 116 ) ;
                 if MATCHPAR then

                 (*************************************)
                 (* OTHERWISE THERE ARE NO PARAMETERS *)
                 (*************************************)

                   begin
                     if SY = COMMA then
                       INSYMBOL ;
                     if LKEY = 5 then

                 (********)
                 (*READ  *)
                 (********)

                       if SY <> IDENT then
                         ERROR ( 2 ) ;
                     TEST := FALSE ;
                     if SY = IDENT then
                       repeat
                         VARIABLE ( FSYS + [ COMMA , RPARENT ] ) ;
                         LOADADDRESS ;
                         if GATTR . TYPTR <> NIL then
                           if RWFILE = NIL then
                             if STRING ( GATTR . TYPTR ) then
                               begin

                 (********)
                 (*LDC   *)
                 (********)

                                 GEN2 ( 51 , 1 , GATTR . TYPTR -> .
                                        SIZE DIV CHARSIZE ) ;
                                 CSPNO := 27

                 (********)
                 (*RDS   *)
                 (********)

                               end (* then *)
                             else
                               begin
                                 if GATTR . TYPTR = INTPTR then
                                   if GATTR . BTYPE -> . SIZE = INTSIZE
                                   then
                                     CSPNO := 24

                 (********)
                 (*RDI   *)
                 (********)

                                   else
                                     if GATTR . BTYPE -> . SIZE =
                                     HINTSIZE then
                                       CSPNO := 15

                 (********)
                 (*RDH   *)
                 (********)

                                     else
                                       CSPNO := 16

                 (*****************************)
                 (*RDY - ONE BYTE INTEGER READ*)
                 (*****************************)

                                 else
                                   if GATTR . TYPTR = REALPTR then
                                     CSPNO := 14

                 (********)
                 (*RDR   *)
                 (********)

                                   else
                                     if GATTR . TYPTR = CHARPTR then
                                       CSPNO := 5

                 (********)
                 (*RDC   *)
                 (********)

                                     else
                                       if GATTR . TYPTR = BOOLPTR then
                                         CSPNO := 12

                 (********)
                 (*RDB   *)
                 (********)

                                       else
                                         begin
                                           ERROR ( 116 ) ;
                                           CSPNO := 24
                                         end (* else *) ;
                               end (* else *)
                           else

                 (***********************)
                 (* NON-TEXT FILE INPUT *)
                 (***********************)

                             begin
                               if not COMPTYPES ( GATTR . TYPTR ,
                               RWFILE ) then
                                 ERROR ( 153 ) ;

                 (********)
                 (*LDC   *)
                 (********)

                               GEN2 ( 51 , 1 , GATTR . BTYPE -> . SIZE
                                      ) ;
                               CSPNO := 19

                 (********)
                 (*RDD   *)
                 (********)


                                        ;
                               EXTUSED := TRUE ;
                             end (* else *) ;

                 (********)
                 (*CSP   *)
                 (********)

                         GEN1 ( 30 , CSPNO ) ;
                         if SY = COMMA then
                           INSYMBOL
                         else
                           TEST := TRUE ;
                       until TEST ;
                   end (* then *) ;
                 if LKEY = 11 then

                 (*************)
                 (* CSP - RLN *)
                 (*************)

                   GEN1 ( 30 , 23 ) ;

                 (*************)
                 (* CSP - EIO *)
                 (*************)

                 GEN1 ( 30 , 32 ) ;
               end (* READ1 *) ;


            procedure WRITE1 ;

               var LSP : STP ;
                   DEFAULT , DEFAULT1 , TEST : BOOLEAN ;
                   CSPNO , LLKEY : 0 .. NSPROC ;
                   LEN : ADDRRANGE ;

               begin (* WRITE1 *)
                 LLKEY := LKEY ;
                 TEST := FALSE ;
                 RWSETUP ( OUTPUTPTR ) ;
                 if RWFILE <> NIL then
                   if LLKEY = 12 then
                     ERROR ( 116 ) ;
                 if MATCHPAR then

                 (***************************)
                 (* OTHERWISE NO PARAMETERS *)
                 (***************************)

                   begin
                     if SY = RPARENT then
                       if LLKEY = 6 then
                         ERROR ( 116 ) ;
                     if SY = COMMA then
                       begin
                         INSYMBOL ;
                         if not ( SY in SIMPTYPEBEGSYS ) then
                           ERROR ( 6 )
                       end (* then *) ;
                     if SY in SIMPTYPEBEGSYS then
                       repeat
                         EXPRESSION ( FSYS + [ COMMA , COLON , RPARENT
                                      ] ) ;
                         LSP := GATTR . TYPTR ;
                         if LSP <> NIL then
                           if LSP -> . FORM <= SUBRANGE then
                             LOAD
                           else
                             LOADADDRESS ;
                         if RWFILE = NIL then
                           begin
                             DEFAULT := TRUE ;
                             DEFAULT1 := TRUE ;
                             if SY = COLON then
                               begin
                                 INSYMBOL ;
                                 EXPRESSION ( FSYS + [ COMMA , COLON ,
                                              RPARENT ] ) ;
                                 LOAD ;
                                 if GATTR . TYPTR <> NIL then
                                   if GATTR . TYPTR <> INTPTR then
                                     ERROR ( 116 ) ;
                                 DEFAULT := FALSE ;
                                 if SY = COLON then
                                   begin
                                     INSYMBOL ;
                                     EXPRESSION ( FSYS + [ COMMA ,
                                                  RPARENT ] ) ;
                                     LOAD ;
                                     if GATTR . TYPTR <> NIL then
                                       if GATTR . TYPTR <> INTPTR then
                                         ERROR ( 116 ) ;
                                     if LSP <> REALPTR then
                                       ERROR ( 124 ) ;
                                     DEFAULT1 := FALSE ;
                                   end (* then *) ;
                               end (* then *) ;
                             if LSP = INTPTR then
                               begin
                                 if DEFAULT then

                 (********)
                 (*LDC   *)
                 (********)

                                   GEN2 ( 51 , 1 , 12 ) ;
                                 CSPNO := 6

                 (********)
                 (*WRI   *)
                 (********)

                               end (* then *)
                             else
                               if LSP = REALPTR then
                                 begin
                                   if DEFAULT then

                 (********)
                 (*LDC   *)
                 (********)

                                     GEN2 ( 51 , 1 , 14 ) ;
                                   if DEFAULT1 then

                 (********)
                 (*LDC   *)
                 (********)

                                     GEN2 ( 51 , 1 , 0 ) ;
                                   CSPNO := 8

                 (********)
                 (*WRR   *)
                 (********)

                                 end (* then *)
                               else
                                 if LSP = CHARPTR then
                                   begin
                                     if DEFAULT then

                 (********)
                 (*LDC   *)
                 (********)

                                       GEN2 ( 51 , 1 , 1 ) ;
                                     CSPNO := 9

                 (********)
                 (*WRC   *)
                 (********)

                                   end (* then *)
                                 else
                                   if LSP = BOOLPTR then
                                     begin
                                       if DEFAULT then

                 (********)
                 (*LDC   *)
                 (********)

                                         GEN2 ( 51 , 1 , 5 ) ;
                                       CSPNO := 13

                 (********)
                 (*WRB   *)
                 (********)

                                     end (* then *)
                                   else
                                     if LSP <> NIL then
                                       begin
                                         if LSP -> . FORM = SCALAR then
                                           ERROR ( 398 )
                                         else
                                           if STRING ( LSP ) then
                                             begin
                                               LEN := LSP -> . SIZE DIV
                                                   CHARSIZE ;
                                               if DEFAULT then

                 (********)
                 (*LDC   *)
                 (********)

                                                 GEN2 ( 51 , 1 , LEN )
                                                   ;

                 (********)
                 (*LDC   *)
                 (********)

                                               GEN2 ( 51 , 1 , LEN ) ;
                                               CSPNO := 10

                 (********)
                 (*WRS   *)
                 (********)

                                             end (* then *)
                                           else
                                             begin
                                               ERROR ( 116 ) ;
                                               CSPNO := 6
                                             end (* else *)
                                       end (* then *)
                           end (* then *)
                         else

                 (*****************)
                 (* NON-TEXT FILE *)
                 (*****************)

                           begin
                             if not COMPTYPES ( LSP , RWFILE ) then
                               ERROR ( 145 ) ;

                 (********)
                 (*LDC   *)
                 (********)

                             GEN2 ( 51 , 1 , RWFILE -> . SIZE ) ;
                             EXTUSED := TRUE ;
                             if LSP <> NIL then
                               if LSP -> . FORM <= SUBRANGE then
                                 CSPNO := 7

                 (********)
                 (*WRE   *)
                 (********)

                               else
                                 CSPNO := 20

                 (********)
                 (*WRD   *)
                 (********)

                           end (* else *) ;

                 (********)
                 (*CSP   *)
                 (********)

                         GEN1 ( 30 , CSPNO ) ;
                         if SY = COMMA then
                           INSYMBOL
                         else
                           TEST := TRUE ;
                       until TEST ;
                   end (* then *) ;

                 (*********)
                 (*WRITELN*)
                 (*********)

                 if LLKEY = 12 then

                 (*************)
                 (* CSP - WLN *)
                 (*************)

                   GEN1 ( 30 , 22 ) ;

                 (*************)
                 (* CSP - EIO *)
                 (*************)

                 GEN1 ( 30 , 32 ) ;
               end (* WRITE1 *) ;


            procedure SKIPLIM ;

               begin (* SKIPLIM *)
                 RWSETUP ( OUTPUTPTR ) ;
                 if SY = COMMA then
                   begin
                     INSYMBOL ;
                     if not ( SY in SIMPTYPEBEGSYS ) then
                       ERROR ( 6 )
                   end (* then *) ;
                 if SY in SIMPTYPEBEGSYS then
                   begin
                     EXPRESSION ( FSYS + [ RPARENT ] ) ;
                     LOAD ;
                     if GATTR . TYPTR <> NIL then
                       if GATTR . TYPTR <> INTPTR then
                         ERROR ( 125 ) ;

                 (*****************)
                 (* CSP - SKP/LIM *)
                 (*****************)

                     GEN1 ( 30 , LKEY - 2 ) ;

                 (*************)
                 (* CSP - EIO *)
                 (*************)

                     GEN1 ( 30 , 32 ) ;
                   end (* then *)
               end (* SKIPLIM *) ;


            procedure MESSAGE1 ;

               var LEN : INTEGER ;

               begin (* MESSAGE1 *)
                 EXPRESSION ( FSYS + [ RPARENT ] ) ;
                 if GATTR . TYPTR <> NIL then
                   if STRING ( GATTR . TYPTR ) then
                     LEN := GATTR . TYPTR -> . SIZE DIV CHARSIZE
                   else
                     ERROR ( 125 ) ;
                 LOADADDRESS ;

                 (********)
                 (*LDC   *)
                 (********)

                 GEN2 ( 51 , 1 , LEN ) ;

                 (*************)
                 (* CSP - MSG *)
                 (*************)

                 GEN1 ( 30 , 33 ) ;
               end (* MESSAGE1 *) ;


            procedure PACK1 ;

               var LSP , LSP1 : STP ;
                   LSIZE , IMIN , IMAX : INTEGER ;
                   LCNT , RCNT , LELEMSIZE , RELEMSIZE : INTEGER ;

               begin (* PACK1 *)
                 EXPRESSION ( FSYS + [ COMMA , RPARENT ] ) ;
                 LSP := NIL ;
                 LSP1 := NIL ;
                 if GATTR . TYPTR <> NIL then
                   with GATTR , GATTR . TYPTR -> do
                     if FORM = ARRAYS then
                       begin
                         LSP := INXTYPE ;
                         LSP1 := AELTYPE ;
                         IMIN := 1 ;
                         LSIZE := SIZE ;
                         IMAX := LSIZE ;
                         if LSP <> NIL then
                           GETBOUNDS ( LSP , IMIN , IMAX ) ;
                         LCNT := IMAX - IMIN + 1 ;
                         LELEMSIZE := LSIZE DIV LCNT ;
                         LOADADDRESS ;
                       end (* then *)
                     else
                       ERROR ( 116 ) ;
                 if SY = COMMA then
                   INSYMBOL
                 else
                   ERROR ( 20 ) ;
                 EXPRESSION ( FSYS + [ COMMA , RPARENT ] ) ;
                 if GATTR . TYPTR <> NIL then
                   if GATTR . TYPTR -> . FORM <> SCALAR then
                     ERROR ( 116 )
                   else
                     if not COMPTYPES ( LSP , GATTR . TYPTR ) then
                       ERROR ( 116 )
                     else
                       begin
                         LOAD ;
                         if DEBUG then

                 (********)
                 (*CHK   *)
                 (********)

                           GEN3 ( 45 , ORD ( 'J' ) , IMIN , IMAX ) ;
                         if IMIN > 0 then

                 (********)
                 (*DEC   *)
                 (********)

                           GEN2 ( 22 , GETTYPE ( GATTR . TYPTR ) , IMIN
                                  )
                         else
                           if IMIN < 0 then

                 (********)
                 (*INC   *)
                 (********)

                             GEN2 ( 23 , GETTYPE ( GATTR . TYPTR ) , -
                                    IMIN ) ;

                 (********)
                 (*IXA   *)
                 (********)

                         GEN1 ( 36 , LELEMSIZE ) ;
                       end (* else *) ;
                 if SY = COMMA then
                   INSYMBOL
                 else
                   ERROR ( 20 ) ;
                 VARIABLE ( FSYS + [ RPARENT ] ) ;
                 if GATTR . TYPTR <> NIL then
                   with GATTR . TYPTR -> do
                     if FORM = ARRAYS then
                       begin
                         if not COMPTYPES ( AELTYPE , LSP1 ) or not
                         COMPTYPES ( INXTYPE , LSP ) then
                           ERROR ( 116 )
                         else
                           begin
                             LOADADDRESS ;
                             LSP := INXTYPE ;
                             LSP1 := AELTYPE ;
                             if LSP <> NIL then
                               GETBOUNDS ( LSP , IMIN , IMAX )
                             else
                               begin
                                 IMIN := 1 ;
                                 IMAX := SIZE
                               end (* else *) ;
                             RCNT := IMAX - IMIN + 1 ;
                             RELEMSIZE := SIZE DIV RCNT ;
                             if RCNT > LCNT then
                               ERROR ( 303 ) ;
                             if LELEMSIZE = RELEMSIZE then

                 (*********************)
                 (* A MOVE WORK S OK  *)
                 (*********************)

                               GEN1 ( 40 , - SIZE )

                 (********)
                 (*MOV   *)
                 (********)

                             else

                 (********)
                 (*PAK   *)
                 (********)

                               GEN3 ( 76 , RCNT , LELEMSIZE , RELEMSIZE
                                      ) ;
                           end (* else *) ;
                       end (* then *)
                     else
                       ERROR ( 116 )
               end (* PACK1 *) ;


            procedure UNPACK1 ;

               var LSP , LSP1 : STP ;
                   IMIN , IMAX , LSIZE : INTEGER ;
                   LCNT , RCNT , LELEMSIZE , RELEMSIZE : INTEGER ;

               begin (* UNPACK1 *)
                 EXPRESSION ( FSYS + [ COMMA , RPARENT ] ) ;
                 LSP := NIL ;
                 LSP1 := NIL ;
                 if GATTR . TYPTR <> NIL then
                   with GATTR . TYPTR -> do
                     if FORM = ARRAYS then
                       begin
                         LSP := INXTYPE ;
                         LSP1 := AELTYPE ;
                         IMIN := 1 ;
                         LSIZE := SIZE ;
                         IMAX := LSIZE ;
                         if LSP <> NIL then
                           GETBOUNDS ( LSP , IMIN , IMAX ) ;
                         LCNT := IMAX - IMIN + 1 ;
                         LELEMSIZE := LSIZE DIV LCNT ;
                         LOADADDRESS ;
                       end (* then *)
                     else
                       ERROR ( 116 ) ;
                 if SY = COMMA then
                   INSYMBOL
                 else
                   ERROR ( 20 ) ;
                 VARIABLE ( FSYS + [ COMMA , RPARENT ] ) ;
                 if GATTR . TYPTR <> NIL then
                   with GATTR , GATTR . TYPTR -> do
                     if FORM = ARRAYS then
                       begin
                         if not COMPTYPES ( AELTYPE , LSP1 ) or not
                         COMPTYPES ( INXTYPE , LSP ) then
                           ERROR ( 116 )
                         else
                           begin
                             if INXTYPE <> NIL then
                               GETBOUNDS ( INXTYPE , IMIN , IMAX )
                             else
                               begin
                                 IMIN := 1 ;
                                 IMAX := SIZE
                               end (* else *) ;
                             RCNT := IMAX - IMIN + 1 ;
                             RELEMSIZE := SIZE DIV RCNT ;
                             if LCNT > RCNT then
                               ERROR ( 303 ) ;
                             LOADADDRESS ;
                           end (* else *) ;
                       end (* then *)
                     else
                       ERROR ( 116 ) ;
                 if SY = COMMA then
                   INSYMBOL
                 else
                   ERROR ( 20 ) ;
                 EXPRESSION ( FSYS + [ RPARENT ] ) ;
                 if GATTR . TYPTR <> NIL then
                   if GATTR . TYPTR -> . FORM <> SCALAR then
                     ERROR ( 116 )
                   else
                     if not COMPTYPES ( LSP , GATTR . TYPTR ) then
                       ERROR ( 116 )
                     else
                       begin
                         LOAD ;
                         if DEBUG then

                 (********)
                 (*CHK   *)
                 (********)

                           GEN3 ( 45 , ORD ( 'J' ) , IMIN , IMAX ) ;
                         if IMIN > 0 then

                 (********)
                 (*DEC   *)
                 (********)

                           GEN2 ( 22 , GETTYPE ( GATTR . TYPTR ) , IMIN
                                  )
                         else
                           if IMIN < 0 then

                 (********)
                 (*INC   *)
                 (********)

                             GEN2 ( 23 , GETTYPE ( GATTR . TYPTR ) , -
                                    IMIN ) ;

                 (********)
                 (*IXA   *)
                 (********)

                         GEN1 ( 36 , RELEMSIZE ) ;
                         if LELEMSIZE = RELEMSIZE then

                 (*****************)
                 (* A MOVE IS OK  *)
                 (*****************)

                           GEN1 ( 40 , - LSIZE )

                 (********)
                 (*MOV   *)
                 (********)

                         else

                 (********)
                 (*PAK   *)
                 (********)

                           GEN3 ( 76 , LCNT , LELEMSIZE , RELEMSIZE ) ;
                       end (* else *) ;
               end (* UNPACK1 *) ;


            procedure NEW1 ;

               label 1 ;

               var LSP , LSP1 : STP ;
                   VARTS , LMIN , LMAX : INTEGER ;
                   LSIZE , LSZ : ADDRRANGE ;
                   LVAL : VALU ;
                   LALN : ALNRNG ;

               begin (* NEW1 *)
                 VARIABLE ( FSYS + [ COMMA , RPARENT ] ) ;
                 LOADADDRESS ;
                 LSP := NIL ;
                 VARTS := 0 ;
                 LSIZE := 0 ;
                 LALN := INTSIZE ;
                 if GATTR . TYPTR <> NIL then
                   with GATTR . TYPTR -> do
                     if FORM = POINTER then
                       begin
                         if ELTYPE <> NIL then
                           begin
                             LSIZE := ELTYPE -> . SIZE ;
                             if ELTYPE -> . ALN > INTSIZE then
                               LALN := REALSIZE ;
                             if ELTYPE -> . FORM = RECORDS then
                               LSP := ELTYPE -> . RECVAR
                           end (* then *)
                       end (* then *)
                     else
                       ERROR ( 116 ) ;
                 while SY = COMMA do
                   begin
                     INSYMBOL ;
                     CONSTANT ( FSYS + [ COMMA , RPARENT ] , LSP1 ,
                                LVAL ) ;
                     VARTS := VARTS + 1 ;

                 (*****************************************)
                 (*   CHECK TO INSERT HERE:               *)
                 (*   IS CONSTANT IN TAGFIELDTYPE RANGE   *)
                 (*****************************************)

                     if LSP = NIL then
                       ERROR ( 158 )
                     else
                       if LSP -> . FORM <> TAGFLD then
                         ERROR ( 162 )
                       else
                         if LSP -> . TAGFIELDP <> NIL then
                           if STRING ( LSP1 ) or ( LSP1 = REALPTR )
                           then
                             ERROR ( 159 )
                           else
                             if COMPTYPES ( LSP -> . TAGFIELDP -> .
                             IDTYPE , LSP1 ) then
                               begin
                                 LSP1 := LSP -> . FSTVAR ;
                                 while LSP1 <> NIL do
                                   with LSP1 -> do
                                     if VARVAL . IVAL = LVAL . IVAL
                                     then
                                       begin
                                         LSIZE := SIZE ;
                                         LSP := SUBVAR ;
                                         goto 1
                                       end (* then *)
                                     else
                                       LSP1 := NXTVAR ;
                                 LSIZE := LSP -> . SIZE ;
                                 LSP := NIL ;
                               end (* then *)
                             else
                               ERROR ( 116 ) ;
                     1 :

                   end (* while *) ;
                 ALIGN ( LSIZE , INTSIZE ) ;

                 (********)
                 (*NEW   *)
                 (********)

                 GEN2 ( 58 , LSIZE , LALN ) ;
               end (* NEW1 *) ;


            procedure MARKRELEASE ;

               begin (* MARKRELEASE *)
                 VARIABLE ( FSYS + [ RPARENT ] ) ;
                 if GATTR . TYPTR <> NIL then
                   if GATTR . TYPTR -> . FORM = POINTER then
                     if LKEY = 13

                 (********)
                 (*MARK  *)
                 (********)


                     then
                       begin
                         LOADADDRESS ;

                 (********)
                 (*SAV   *)
                 (********)

                         GEN0 ( 59 )
                       end (* then *)
                     else

                 (**********************)
                 (* LKEY = 10, RELEASE *)
                 (**********************)

                       begin
                         LOAD ;

                 (********)
                 (*RST   *)
                 (********)

                         GEN0 ( 60 )
                       end (* else *)
                   else
                     ERROR ( 125 )
               end (* MARKRELEASE *) ;


            procedure TRAPEXIT ;

            (**********************************************************)
            (*   THIS PROCEDURE IS TO SIMPLIFY COMMUNICATION          *)
            (*   WITH THE OUTSIDE WORLD AND PROVIDE BREAK POINTS      *)
            (*   IN THE PASCAL PROGRAM.                               *)
            (*   'TRAP(I, R)'  RETURNS THE INTEGER CONSTANT I         *)
            (*   AS WELL AS A POINTER TO THE SECOND PARAMETER 'R'     *)
            (*   (I.E. ADDRESS OF R) TO THE OPERATING SYSTEM.         *)
            (*   THE FIRST PARAMETER IS INTENDED TO BE USED AS A      *)
            (*   'FUNCTION NUMBER' AND THE SECOND ONE AS THE 'VAR'    *)
            (*   TYPE ARGUMENT WHICH MAY BE INSPECTED AND MODIFIED,   *)
            (*   TO THAT FUNCTION                                     *)
            (**********************************************************)


               var LLC : ADDRRANGE ;

               begin (* TRAPEXIT *)
                 LLC := LC ;

                 (********************************)
                 (* IN CASE OF SET TYPE ARGUMENT *)
                 (********************************)

                 if GATTR . TYPTR <> INTPTR then
                   ERROR ( 116 ) ;
                 if LKEY = 14 then

                 (********)
                 (*TRAP  *)
                 (********)

                   begin
                     if SY <> COMMA then
                       ERROR ( 6 )
                     else
                       begin
                         INSYMBOL ;
                         EXPRESSION ( FSYS + [ RPARENT ] ) ;
                         with GATTR do
                           if TYPTR <> NIL then
                             begin
                               if KIND <> VARBL then
                                 if TYPTR -> . FORM < POWER then
                                   begin
                                     LOAD ;
                                     KIND := VARBL ;
                                     ACCESS := DRCT ;
                                     VLEVEL := LEVEL ;
                                     ALIGN ( LC , MXDATASZE ) ;
                                     DPLMT := LC ;
                                     BTYPE := TYPTR ;
                                     STORE ( GATTR ) ;
                                   end (* then *) ;
                               LOADADDRESS ;
                             end (* then *) ;
                       end (* else *) ;
                   end (* then *) ;

                 (*****************)
                 (* CSP - TRP/XIT *)
                 (*****************)

                 GEN1 ( 30 , LKEY + 14 ) ;
                 LC := LLC ;
               end (* TRAPEXIT *) ;


            procedure SQRABS ;

               var OP : OPRANGE ;

               begin (* SQRABS *)
                 OP := 0 ;

                 (********)
                 (*ABI   *)
                 (********)

                 if LKEY = 17 then
                   OP := 24 ;

                 (********)
                 (*SQI   *)
                 (********)

                 if GATTR . TYPTR <> NIL then
                   if GATTR . TYPTR = INTPTR then

                 (********)
                 (*ABI   *)
                 (*SQI   *)
                 (********)

                     GEN0 ( OP )
                   else
                     if GATTR . TYPTR = REALPTR then

                 (********)
                 (*ABR   *)
                 (*ABR   *)
                 (********)

                       GEN0 ( OP + 1 )
                     else
                       begin
                         ERROR ( 125 ) ;
                         GATTR . TYPTR := INTPTR
                       end (* else *)
               end (* SQRABS *) ;


            procedure TRUNCROUND ;

               begin (* TRUNCROUND *)
                 if GATTR . TYPTR <> NIL then
                   if GATTR . TYPTR <> REALPTR then
                     ERROR ( 125 ) ;

                 (********)
                 (*TRC   *)
                 (*RND   *)
                 (********)

                 GEN0 ( LKEY - 18 + 27 ) ;
                 GATTR . TYPTR := INTPTR
               end (* TRUNCROUND *) ;


            procedure EXPO1 ;

               begin (* EXPO1 *)
                 if GATTR . TYPTR <> NIL then
                   if GATTR . TYPTR = INTPTR then

                 (********)
                 (*FLT   *)
                 (********)

                     GEN0 ( 10 )
                   else
                     if GATTR . TYPTR <> REALPTR then
                       ERROR ( 125 ) ;

                 (********)
                 (*XPO   *)
                 (********)

                 GEN0 ( 66 ) ;
                 GATTR . TYPTR := INTPTR ;
               end (* EXPO1 *) ;


            procedure CARD1 ;

               var LLC , LEN : ADDRRANGE ;

               begin (* CARD1 *)
                 LLC := LC ;
                 EXPRESSION ( FSYS + [ RPARENT ] ) ;
                 if GATTR . TYPTR <> NIL then
                   if GATTR . TYPTR -> . FORM = POWER then
                     begin
                       FORCETEMPSET ;

                 (********)
                 (*CRD   *)
                 (********)

                       GEN0 ( 65 ) ;
                     end (* then *)
                   else
                     ERROR ( 125 ) ;
                 LC := LLC ;
                 GATTR . TYPTR := INTPTR ;
               end (* CARD1 *) ;


            procedure ODD1 ;

               begin (* ODD1 *)
                 if GATTR . TYPTR <> NIL then
                   if GATTR . TYPTR <> INTPTR then
                     ERROR ( 125 ) ;

                 (********)
                 (*ODD   *)
                 (********)

                 GEN0 ( 20 ) ;
                 GATTR . TYPTR := BOOLPTR
               end (* ODD1 *) ;


            procedure ORD1 ;

               begin (* ORD1 *)
                 if GATTR . TYPTR <> NIL then
                   if GATTR . TYPTR -> . FORM >= POWER then
                     ERROR ( 125 ) ;

                 (********)
                 (*ORD   *)
                 (********)

                 GEN0 ( 61 ) ;
                 GATTR . TYPTR := INTPTR
               end (* ORD1 *) ;


            procedure CHR1 ;

               begin (* CHR1 *)
                 if GATTR . TYPTR <> NIL then
                   if GATTR . TYPTR <> INTPTR then
                     ERROR ( 125 ) ;

                 (********)
                 (*CHR   *)
                 (********)

                 GEN0 ( 62 ) ;
                 GATTR . TYPTR := CHARPTR
               end (* CHR1 *) ;


            procedure PREDSUCCTIM ;

               begin (* PREDSUCCTIM *)
                 if GATTR . TYPTR <> NIL then
                   if ( LKEY = 24 ) or ( LKEY = 30 ) then
                     begin
                       if GATTR . TYPTR <> INTPTR then
                         ERROR ( 116 ) ;
                       if LKEY = 24 then

                 (*************)
                 (* CSP - CLK *)
                 (*************)

                         GEN1 ( 30 , 21 )
                       else

                 (*************)
                 (* CSP - TRA *)
                 (*************)

                         GEN1 ( 30 , 36 ) ;
                     end (* then *)
                   else
                     if ( GATTR . TYPTR = REALPTR ) or ( GATTR . TYPTR
                     -> . FORM <> SCALAR ) then
                       ERROR ( 125 )
                     else

                 (*********)
                 (*DEC,INC*)
                 (*********)

                       GEN2 ( LKEY , GETTYPE ( GATTR . TYPTR ) , 1 ) ;

                 (*********************************************)
                 (*   LKEY HAPPENS TO BE THE OPCODE AS WELL   *)
                 (*********************************************)

               end (* PREDSUCCTIM *) ;


            procedure EOFEOLN ;

               begin (* EOFEOLN *)
                 RWSETUP ( INPUTPTR ) ;
                 if GATTR . TYPTR <> NIL then
                   if GATTR . TYPTR -> . FORM <> FILES then
                     ERROR ( 125 ) ;
                 if LKEY >= 28 then
                   begin
                     EXTUSED := TRUE ;

                 (*****************)
                 (* CSP - EOL/EOT *)
                 (*****************)

                     GEN1 ( 30 , LKEY - 11 ) ;
                   end (* then *)
                 else

                 (*****************)
                 (* CSP - EOF/ELN *)
                 (*****************)

                   GEN1 ( 30 , LKEY ) ;

                 (*************)
                 (* CSP - EIO *)
                 (*************)

                 GEN1 ( 30 , 32 ) ;
                 GATTR . TYPTR := BOOLPTR
               end (* EOFEOLN *) ;


            procedure CALLNONSTANDARD ;

               label 10 ;

               var NXT , LCP , LCP2 : CTP ;
                   LSP : STP ;
                   LB : BOOLEAN ;
                   LOCPAR , LLC , LSIZE , LLC1 , LLC2 , LLC3 , LLC4 ,
                   LLC5 : ADDRRANGE ;
                   I : INTEGER ;
                   PROCNAME : ALPHA ;


               function COMPTLIST ( CP1 , CP2 : CTP ) : BOOLEAN ;

               (*************************************)
               (* MATCH PARAMETER LISTS CP1 AND CP2 *)
               (*************************************)


                  var X : BOOLEAN ;

                  begin (* COMPTLIST *)
                    while ( CP1 <> NIL ) and ( CP2 <> NIL ) do
                      begin

                    (***********************)
                    (* I.E. PROC PARAMETER *)
                    (***********************)

                        if CP1 -> . KLASS in [ PROC , FUNC ] then
                          if ( CP1 -> . KLASS = CP2 -> . KLASS ) and (
                          CP1 -> . IDTYPE = CP2 -> . IDTYPE ) and ( CP1
                          -> . PFDECKIND = CP2 -> . PFDECKIND ) then
                            X := COMPTLIST ( CP1 -> . PRMPTR , CP2 -> .
                                 PRMPTR ) and ( CP1 -> . VKIND = CP2 ->
                                 . VKIND )
                          else
                            X := FALSE
                        else
                          X := COMPTYPES ( CP1 -> . IDTYPE , CP2 -> .
                               IDTYPE ) ;
                        if X then
                          begin
                            CP1 := CP1 -> . NEXT ;
                            CP2 := CP2 -> . NEXT
                          end (* then *)
                        else
                          CP1 := NIL ;
                      end (* while *) ;
                    COMPTLIST := CP1 <> CP2 ;
                  end (* COMPTLIST *) ;


               begin (* CALLNONSTANDARD *)
                 LOCPAR := 0 ;
                 LLC1 := LC ;
                 ALIGN ( LLC1 , MXDATASZE ) ;
                 with FCP -> do
                   begin
                     NXT := PRMPTR ;
                     if PFLEV > LCAFTMST then

                 (*******************)
                 (* PROC. PARAMETER *)
                 (*******************)

                       begin
                         LLC5 := LLC1 ;
                         LLC1 := LLC1 + DISPAREA
                       end (* then *)
                     else
                       LLC5 := 0 ;

                 (********)
                 (*MST   *)
                 (********)

                     GEN2 ( 41 , PFLEV , LLC5 ) ;
                     if PFLEV = LEVEL then
                       LOCAL_CALL := TRUE ;
                   end (* with *) ;
                 if SY = LPARENT then
                   begin
                     LSIZE := 0 ;
                     LLC := LLC1 ;
                     LLC2 := LLC1 ;
                     if FCP -> . FRTRN then
                       begin

                 (***************************************)
                 (* RESERVE STORAGE FOR COPIES OF PARMS *)
                 (***************************************)

                         LCP := NXT ;
                         while LCP <> NIL do
                           begin
                             LSP := LCP -> . IDTYPE ;
                             if LSP <> NIL then
                               if LSP -> . FORM <= POWER then
                                 begin
                                   ALIGN ( LLC1 , LSP -> . ALN ) ;
                                   LLC1 := LLC1 + LSP -> . SIZE
                                 end (* then *) ;
                             LCP := LCP -> . NEXT
                           end (* while *) ;
                         ALIGN ( LLC1 , MXDATASZE ) ;
                       end (* then *) ;
                     LLC3 := LLC1 ;
                     repeat
                       LB := FALSE ;

                 (*****************************************)
                 (*DECIDE WHETHER PROC/FUNC MUST BE PASSED*)
                 (*****************************************)

                       if NXT = NIL then
                         ERROR ( 126 )
                       else
                         LB := NXT -> . KLASS in [ PROC , FUNC ] ;

                 (*********************************************)
                 (*   FOR FORMAL PROC/FUNC LB IS FALSE AND    *)
                 (*   EXPRESSION WILL BE CALLED, WHICH WILL   *)
                 (*   ALWAYS INTERPRET A PROC/FUNC ID AT      *)
                 (*   ITS BEGINNING AS A CALL RATHER THAN     *)
                 (*   A PARAMETER PASSING. IN THIS            *)
                 (*   IMPLEMENTATION, PARAMETER PROCEDURES    *)
                 (*   /FUNCTIONS ARE THEREFORE NOT ALLOWED    *)
                 (*   TO HAVE PROCEDURE/FUNCTION PARAMETERS   *)
                 (*********************************************)

                       INSYMBOL ;
                       if LB then

                 (****************************)
                 (*PASS FUNCTION OR PROCEDURE*)
                 (****************************)

                         begin
                           if SY <> IDENT then
                             begin
                               ERROR ( 2 ) ;
                               SKIP ( FSYS + [ COMMA , RPARENT ] )
                             end (* then *)
                           else
                             begin
                               SEARCHID ( [ NXT -> . KLASS ] , LCP ) ;
                               if COMPTLIST ( LCP , NXT ) then
                                 begin
                                   LOCAL_CALL := TRUE ;

                 (************************)
                 (* => UPDATES DISP REGS *)
                 (************************)

                                   LLC4 := LLC1 + NXT -> . PFLEV DIV 10
                                           ;

                 (**********************************************)
                 (* PFLEV = ADDR OF PROC IN NEW ACTIV RECORD   *)
                 (**********************************************)

                                   LSIZE := DISPAREA ;
                                   if LCP -> . PFKIND = ACTUAL then
                                     with LCP -> do
                                       begin
                                         if FRTRN then
                                           begin

                 (********************************)
                 (* REMEMBER THIS PROC FOR LATER *)
                 (********************************)

                                             LCP2 := FRTPARHD ;
                                             while LCP2 <> NIL do
                                               if LCP2 -> . EXTNAME =
                                               EXTNAME then
                                                 goto 10

                 (********************)
                 (* ALREADY ON LIST  *)
                 (********************)

                                               else
                                                 LCP2 := LCP2 -> .
                                                   NXTFWRD ;
                                             NEW ( LCP2 , PROC ,
                                                   DECLARED ) ;
                                             LCP2 -> := LCP -> ;
                                             with LCP2 -> do
                                               begin
                                                 NAME := '            '
                                                   ;
                                                 UNPACK ( EXTNAME ,
                                                   NAME , 1 ) ;
                                                 PROCLAB := PROCLAB + 1
                                                   ;
                                                 PFNAME := PROCLAB ;
                                                 NXTFWRD := FRTPARHD ;
                                                 FRTPARHD := LCP2 ;
                                               end (* with *) ;
                                             10 :
                                             LCP := LCP2 ;
                                           end (* then *) ;

                 (*****************)
                 (* PASSING PROC  *)
                 (*****************)

                                         UNPACK ( EXTNAME , ID , 1 ) ;

                 (********)
                 (*LCA   *)
                 (********)

                                         GEN1 ( 37 , ORD ( 'P' ) ) ;

                 (********)
                 (*STR   *)
                 (********)

                                         GEN3 ( 56 , ORD ( 'A' ) ,
                                                LEVEL , LLC4 ) ;

                 (********)
                 (*LDA   *)
                 (********)

                                         GEN2 ( 50 , LEVEL , LLC4 +
                                                PTRSIZE ) ;

                 (********)
                 (*LDA   *)
                 (********)

                                         GEN2 ( 50 , 1 , DISPADR +
                                                PTRSIZE ) ;

                 (********)
                 (*MOV   *)
                 (********)

                                         GEN1 ( 40 , DISPAREA - PTRSIZE
                                                ) ;
                                       end (* with *)
                                   else

                 (***************************************)
                 (* PROC PARM IS ITSELF A PASSED PROC   *)
                 (***************************************)

                                     begin

                 (********)
                 (*LDA   *)
                 (********)

                                       GEN2 ( 50 , LEVEL , LLC4 ) ;

                 (********************************************)
                 (* COPY ENTIRE PROC RECORD IN TO PARM LIST  *)
                 (********************************************)

                                       GEN2 ( 50 , LEVEL , LCP -> .
                                              PFLEV DIV 10 ) ;

                 (********)
                 (*MOV   *)
                 (********)

                                       GEN1 ( 40 , DISPAREA ) ;
                                     end (* else *) ;
                                 end (* then *)
                               else
                                 ERROR ( 128 ) ;
                               INSYMBOL ;
                               if not ( SY in FSYS + [ COMMA , RPARENT
                               ] ) then
                                 begin
                                   ERROR ( 6 ) ;
                                   SKIP ( FSYS + [ COMMA , RPARENT ] )
                                 end (* then *)
                             end (* else *)
                         end (* then *)
                       else
                         begin
                           if NXT <> NIL then
                             LC := LLC1 + NXT -> . VADDR ;
                           LLC4 := LC ;
                           EXPRESSION ( FSYS + [ COMMA , RPARENT ] ) ;
                           if GATTR . TYPTR <> NIL then
                             begin
                               if NXT <> NIL then
                                 begin
                                   LSP := NXT -> . IDTYPE ;
                                   if LSP <> NIL then
                                     begin
                                       if ( NXT -> . VKIND = ACTUAL )
                                       then
                                         if LSP -> . FORM < POWER then
                                           begin
                                             LOAD ;
                                             if DEBUG then
                                               begin
                                                 ASSIGN := TRUE ;
                                                 CHKBNDS ( LSP ) ;
                                                 ASSIGN := FALSE ;
                                               end (* then *) ;
                                             if COMPTYPES ( REALPTR ,
                                             LSP ) then
                                               if ( GATTR . TYPTR =
                                               INTPTR ) then
                                                 begin

                 (********)
                 (*FLT   *)
                 (********)

                                                   GEN0 ( 10 ) ;
                                                   GATTR . TYPTR :=
                                                   REALPTR ;
                                                   GATTR . BTYPE :=
                                                   REALPTR ;
                                                 end (* then *) ;
                                             LOCPAR := LOCPAR + 1 ;

                 (************)
                 (*LSP->.SIZE*)
                 (************)

                                             if FCP -> . FRTRN then
                                               begin
                                                 ALIGN ( LLC2 , LSP ->
                                                   . ALN ) ;
                                                 with GATTR do
                                                   begin
                                                   VLEVEL := LEVEL ;
                                                   DPLMT := LLC2 ;
                                                   BTYPE := LSP ;
                                                   KIND := VARBL ;
                                                   ACCESS := DRCT
                                                   end (* with *) ;
                                                 STORE ( GATTR ) ;
                                                 LOADADDRESS ;

                 (********)
                 (*STR   *)
                 (********)

                                                 GEN3 ( 56 , ORD ( 'A'
                                                   ) , LEVEL , LLC3 ) ;
                                                 LLC3 := LLC3 + PTRSIZE
                                                   ;
                                                 LLC2 := LLC2 + LSP ->
                                                   . SIZE ;
                                               end (* then *)
                                             else
                                               GEN3 ( 56 , GETTYPE (
                                                   LSP ) , LEVEL , LLC4
                                                   ) ;
                                           end (* then *)
                                         else

                 (***********************)
                 (* LSP->.FORM >= POWER *)
                 (***********************)

                                           begin
                                             LOCPAR := LOCPAR + 1 ;
                                             if FCP -> . FRTRN then
                                               begin
                                                 if ( LSP -> . FORM =
                                                 POWER ) and ( GATTR .
                                                 ACCESS = STKEXPR )
                                                 then
                                                   begin
                                                   ALIGN ( LLC2 , LSP
                                                   -> . ALN ) ;
                                                   FORCETEMPSET ;
                                                   LSIZE := OPNDSETSIZE
                                                   ( GATTR ) ;

                 (********)
                 (*LDA   *)
                 (********)

                                                   GEN2 ( 50 , LEVEL ,
                                                   LLC2 ) ;

                 (********)
                 (*SMV   *)
                 (********)

                                                   GEN2 ( 69 , - LSP ->
                                                   . SIZE , LSIZE ) ;

                 (********)
                 (*LDA   *)
                 (********)

                                                   GEN2 ( 50 , LEVEL ,
                                                   LLC2 ) ;
                                                   LLC2 := LLC2 + LSP
                                                   -> . SIZE ;
                                                   end (* then *)
                                                 else
                                                   LOADADDRESS ;

                 (********)
                 (*STR   *)
                 (********)

                                                 GEN3 ( 56 , ORD ( 'A'
                                                   ) , LEVEL , LLC3 ) ;
                                                 LLC3 := LLC3 + PTRSIZE
                                                   ;
                                               end (* then *)
                                             else
                                               if LSP -> . FORM = POWER
                                               then
                                                 begin
                                                   LSIZE := OPNDSETSIZE
                                                   ( GATTR ) ;
                                                   LOADADDRESS ;

                 (********)
                 (*LDA   *)
                 (********)

                                                   GEN2 ( 50 , LEVEL ,
                                                   LLC4 ) ;

                 (********)
                 (*SMV   *)
                 (********)

                                                   GEN2 ( 69 , - LSP ->
                                                   . SIZE , LSIZE ) ;
                                                 end (* then *)
                                               else
                                                 begin
                                                   LOADADDRESS ;

                 (********)
                 (*LDA   *)
                 (********)

                                                   GEN2 ( 50 , LEVEL ,
                                                   LLC4 ) ;

                 (********)
                 (*MOV   *)
                 (********)

                                                   GEN1 ( 40 , - LSP ->
                                                   . SIZE ) ;
                                                 end (* else *)
                                           end (* else *)
                                       else

                 (**********************************)
                 (* VKIND = FORMAL I.E.  V AR PARM *)
                 (**********************************)

                                         if GATTR . KIND = VARBL then
                                           begin
                                             LOADADDRESS ;
                                             if not FCP -> . FRTRN then
                                               GEN3 ( 56 , ORD ( 'A' )
                                                   , LEVEL , LLC4 )
                                             else
                                               begin
                                                 GEN3 ( 56 , ORD ( 'A'
                                                   ) , LEVEL , LLC3 ) ;
                                                 LLC3 := LLC3 + PTRSIZE
                                                   ;
                                               end (* else *) ;
                                             if GATTR . ACCESS =
                                             STKEXPR then
                                               ERROR ( 154 ) ;
                                             LOCPAR := LOCPAR + 1 ;

                 (*********)
                 (*PTRSIZE*)
                 (*********)

                                             if GATTR . BTYPE -> . SIZE
                                             <> LSP -> . SIZE then
                                               ERROR ( 142 ) ;
                                           end (* then *)
                                         else
                                           ERROR ( 154 ) ;
                                       if LSP <> NIL then
                                         LSIZE := LSP -> . SIZE ;
                                       if not COMPTYPES ( LSP , GATTR .
                                       TYPTR ) then
                                         ERROR ( 142 )
                                     end (* then *)
                                 end (* then *)
                             end (* then *)
                         end (* else *) ;
                       if ( NXT <> NIL ) then
                         NXT := NXT -> . NEXT
                     until SY <> COMMA ;
                     LC := LLC4 + LSIZE ;
                     if LC > LCMAX then
                       LCMAX := LC ;
                     LC := LLC ;
                     if SY = RPARENT then
                       INSYMBOL
                     else
                       ERROR ( 4 )
                   end (* then *) ;
                 LOCPAR := LOCPAR * 2 ;
                 if NXT <> NIL then
                   ERROR ( 126 ) ;
                 with FCP -> do
                   begin
                     if SAVEFPRS then
                       LOCPAR := LOCPAR + 1 ;

                 (********************)
                 (*ENCODE SAVEFPR FLG*)
                 (********************)

                     if PRCODE then
                       begin
                         PUTIC ;

                 (********)
                 (*CUP   *)
                 (********)

                         WRITELN ( PRR , MN [ 46 ] , CHR ( PROCTYPE (
                                   FCP ) ) : 2 , ',' , LOCPAR : 1 , ','
                                   , EXTNAME , ',' , LLC1 : 1 ) ;
                       end (* then *) ;
                   end (* with *) ;
                 with GATTR do
                   begin
                     TYPTR := FCP -> . IDTYPE ;
                     BTYPE := TYPTR ;
                     if TYPTR <> NIL then
                       if TYPTR -> . FORM = SUBRANGE then
                         TYPTR := TYPTR -> . RANGETYPE
                   end (* with *) ;
               end (* CALLNONSTANDARD *) ;


            begin (* CALL *)
              if FCP -> . PFDECKIND = STANDARD then
                begin
                  LKEY := FCP -> . KEY ;
                  if SY = LPARENT then
                    begin
                      INSYMBOL ;
                      MATCHPAR := TRUE ;
                      if SY = RPARENT then
                        if not ( LKEY in [ 0 , 1 , 2 , 3 , 4 , 11 , 12
                        , 25 , 26 , 28 , 29 ] ) then
                          ERROR ( 7 ) ;

              (*****************************************************)
              (*GET,PUT,RESET,REWRITE,RDLN,WRITELN,EOL,EOT,EOF,ELN *)
              (*****************************************************)

                    end (* then *)
                  else
                    begin
                      if not ( LKEY in [ 0 , 1 , 2 , 3 , 4 , 11 , 12 ,
                      25 , 26 , 28 , 29 ] ) then
                        ERROR ( 7 ) ;

              (*****************************************************)
              (*GET,PUT,RESET,REWRITE,RDLN,WRITELN,EOL,EOT,EOF,ELN *)
              (*****************************************************)

                      MATCHPAR := FALSE ;
                    end (* else *) ;
                  if LKEY in [ 14 .. 24 , 30 , 33 , 39 ] then

              (*********************************)
              (*TRAP,EXIT,ABS...,TRACE,ODD,EXPO*)
              (*********************************)

                    begin

              (********)
              (*TRAP  *)
              (********)

                      if LKEY = 14 then
                        EXPRESSION ( FSYS + [ COMMA ] )
                      else
                        EXPRESSION ( FSYS + [ RPARENT ] ) ;
                      LOAD ;
                    end (* then *) ;
                  case LKEY of
                    0 , 1 , 2 , 3 , 4 :
                      GETPUTRESETREWRITE ;
                    5 , 11 :
                      READ1 ;
                    6 , 12 :
                      WRITE1 ;
                    7 : PACK1 ;
                    8 : UNPACK1 ;
                    9 : NEW1 ;
                    10 , 13 :
                      MARKRELEASE ;
                    14 , 15 :
                      TRAPEXIT ;
                    16 , 17 :
                      SQRABS ;
                    18 , 19 :
                      TRUNCROUND ;
                    20 : ORD1 ;
                    21 : CHR1 ;
                    22 , 23 , 24 , 30 :
                      PREDSUCCTIM ;
                    25 , 26 , 28 , 29 :
                      EOFEOLN ;
                    33 : ODD1 ;
                    35 : MESSAGE1 ;
                    36 , 37 :
                      SKIPLIM ;
                    38 : CARD1 ;
                    39 : EXPO1 ;
                  end (* case *) ;
                  if LKEY in [ 16 .. 26 , 28 , 29 , 33 , 38 , 39 ] then
                    GATTR . BTYPE := GATTR . TYPTR ;
                  if MATCHPAR then
                    if SY = RPARENT then
                      INSYMBOL
                    else
                      ERROR ( 4 ) ;
                end (* then *)
              else
                CALLNONSTANDARD
            end (* CALL *) ;


         procedure GENSETOP ( LATTR : ATTR ; OP : OPRANGE ) ;

            begin (* GENSETOP *)
              with GATTR do
                if ( TYPTR <> NIL ) and ( LATTR . TYPTR <> NIL ) then
                  if ( TYPTR -> . FORM = POWER ) and COMPTYPES ( TYPTR
                  , LATTR . TYPTR ) then
                    begin
                      FORCETEMPSET ;
                      GEN0 ( OP ) ;
                      if OP = 12 then
                        if LATTR . STKLEN < STKLEN then
                          STKLEN := LATTR . STKLEN ;
                      if OP = 31 then
                        if LATTR . STKLEN > STKLEN then
                          STKLEN := LATTR . STKLEN ;
                      if OP = 5 then
                        STKLEN := LATTR . STKLEN ;
                      STKDPLMT := LATTR . STKDPLMT ;
                      LC := STKDPLMT + STKLEN ;
                      if LC > LCMAX then
                        LCMAX := LC ;
                    end (* then *)
                  else
                    begin
                      ERROR ( 134 ) ;
                      GATTR . TYPTR := NIL ;
                      GATTR . BTYPE := NIL
                    end (* else *)
            end (* GENSETOP *) ;


         procedure EXPRESSION ;

            const COMPARE_OP : array [ LTOP .. EQOP ] of 0 .. OPMAX =
                  ( 53 , 52 , 48 , 49 , 55 , 47 ) ;

            var LATTR : ATTR ;
                LOP : OPERATOR ;
                TYPIND : CHAR ;
                LLC , LSIZE : ADDRRANGE ;


            procedure SIMPLEEXPRESSION ( FSYS : SETOFSYS ) ;

               var LATTR : ATTR ;
                   LOP : OPERATOR ;
                   SIGNED : BOOLEAN ;


               procedure TERM ( FSYS : SETOFSYS ) ;

                  var LATTR : ATTR ;
                      LOP : OPERATOR ;


                  procedure FACTOR ( FSYS : SETOFSYS ) ;

                     var LCP : CTP ;
                         LVP : CSP ;
                         VARPART : BOOLEAN ;
                         LATTR : ATTR ;
                         CSTPART : SETRANGE ;
                         LSP : STP ;
                         I , J : INTEGER ;
                         TS_LC , TS_SIZE : ADDRRANGE ;
                         MAXELEM : INTEGER ;

                     begin (* FACTOR *)
                       if not ( SY in FACBEGSYS ) then
                         begin
                           ERROR ( 58 ) ;
                           SKIP ( FSYS + FACBEGSYS ) ;
                           GATTR . TYPTR := NIL
                         end (* then *) ;
                       while SY in FACBEGSYS do
                         begin
                           case SY of
                             IDENT : begin
                                       SEARCHID ( [ STRUCTKONST , KONST
                                                  , VARS , FIELD , FUNC
                                                  ] , LCP ) ;
                                       INSYMBOL ;
                                       if LCP -> . KLASS = FUNC then
                                         begin
                                           CALL ( FSYS , LCP ) ;
                                           GATTR . KIND := EXPR
                                         end (* then *)
                                       else
                                         if LCP -> . KLASS = KONST then
                                           with GATTR , LCP -> do
                                             begin
                                               TYPTR := IDTYPE ;
                                               KIND := CST ;
                                               CVAL := VALUES ;
                                               if SY in [ LBRACK ,
                                               LPARENT ] then
                                                 if STRING ( TYPTR )
                                                 then
                                                   begin
                                                   if SY = LPARENT then
                                                   begin
                                                   ERRKIND := 'W' ;
                                                   ERROR ( 11 )
                                                   end (* then *) ;
                                                   LATTR := GATTR ;
                                                   LOADADDRESS ;
                                                   INSYMBOL ;
                                                   EXPRESSION ( FSYS +
                                                   [ RBRACK , RPARENT ]
                                                   ) ;
                                                   LOAD ;
                                                   LSP := LATTR . TYPTR
                                                   -> . INXTYPE ;
                                                   if COMPTYPES ( TYPTR
                                                   , LSP ) then
                                                   begin
                                                   if LSP <> NIL then
                                                   GETBOUNDS ( LSP , I
                                                   , J )
                                                   else
                                                   begin
                                                   I := 1 ;
                                                   J := LATTR . TYPTR
                                                   -> . SIZE
                                                   end (* else *) ;
                                                   if DEBUG then

                       (********)
                       (*CHK   *)
                       (********)

                                                   GEN3 ( 45 , ORD (
                                                   'J' ) , I , J DIV
                                                   CHARSIZE ) ;
                                                   if I <> 0 then

                       (********)
                       (*DEC   *)
                       (********)

                                                   GEN2 ( 22 , ORD (
                                                   'I' ) , I ) ;

                       (********)
                       (*IXA   *)
                       (********)

                                                   GEN1 ( 36 , CHARSIZE
                                                   ) ;
                                                   end (* then *)
                                                   else
                                                   ERROR ( 139 ) ;
                                                   TYPTR := CHARPTR ;
                                                   KIND := VARBL ;
                                                   BTYPE := CHARPTR ;
                                                   ACCESS := INDRCT ;
                                                   IDPLMT := 0 ;
                                                   if SY = RBRACK then
                                                   INSYMBOL
                                                   else
                                                   if SY = RPARENT then
                                                   begin
                                                   ERRKIND := 'W' ;
                                                   ERROR ( 12 ) ;
                                                   INSYMBOL ;
                                                   end (* then *)
                                                   else
                                                   ERROR ( 12 ) ;
                                                   end (* then *)
                                             end (* with *)
                                         else
                                           SELECTOR ( FSYS , LCP )
                                     end (* tag/ca *) ;
                             INTCONST :
                               begin
                                 with GATTR do
                                   begin
                                     TYPTR := INTPTR ;
                                     KIND := CST ;
                                     CVAL := VAL
                                   end (* with *) ;
                                 INSYMBOL
                               end (* tag/ca *) ;
                             REALCONST :
                               begin
                                 with GATTR do
                                   begin
                                     TYPTR := REALPTR ;
                                     KIND := CST ;
                                     CVAL := VAL
                                   end (* with *) ;
                                 INSYMBOL
                               end (* tag/ca *) ;
                             STRINGCONST :
                               begin
                                 with GATTR do
                                   begin
                                     if LNGTH = 1 then
                                       TYPTR := CHARPTR
                                     else
                                       begin
                                         NEW ( LSP , ARRAYS ) ;
                                         with LSP -> do
                                           begin
                                             AELTYPE := CHARPTR ;
                                             FORM := ARRAYS ;
                                             INXTYPE := NIL ;
                                             SIZE := LNGTH * CHARSIZE ;
                                             ALN := CHARSIZE ;
                                           end (* with *) ;
                                         TYPTR := LSP
                                       end (* else *) ;
                                     KIND := CST ;
                                     CVAL := VAL ;
                                   end (* with *) ;
                                 INSYMBOL
                               end (* tag/ca *) ;
                             LPARENT :
                               begin
                                 INSYMBOL ;
                                 EXPRESSION ( FSYS + [ RPARENT ] ) ;
                                 if SY = RPARENT then
                                   INSYMBOL
                                 else
                                   ERROR ( 4 )
                               end (* tag/ca *) ;
                             NOTSY : begin
                                       INSYMBOL ;
                                       FACTOR ( FSYS ) ;
                                       LOAD ;

                       (********)
                       (*NOT   *)
                       (********)

                                       GEN0 ( 19 ) ;
                                       if GATTR . TYPTR <> NIL then
                                         if GATTR . TYPTR <> BOOLPTR
                                         then
                                           begin
                                             ERROR ( 135 ) ;
                                             GATTR . TYPTR := NIL
                                           end (* then *) ;
                                     end (* tag/ca *) ;
                             LBRACK :
                               begin
                                 INSYMBOL ;
                                 VARPART := FALSE ;
                                 MAXELEM := - 1 ;
                                 for I := 1 to ( SETMAX + 1 ) DIV (
                                 SSETMAX + 1 ) do
                                   CSTPART [ I ] := [ ] ;
                                 NEW ( LSP , POWER ) ;
                                 with LSP -> do
                                   begin
                                     ELSET := NIL ;
                                     SIZE := 0 ;
                                     FORM := POWER
                                   end (* with *) ;
                                 if SY = RBRACK then
                                   begin
                                     with GATTR do
                                       begin
                                         TYPTR := LSP ;
                                         KIND := CST
                                       end (* with *) ;
                                     INSYMBOL
                                   end (* then *)
                                 else
                                   begin
                                     repeat
                                       EXPRESSION ( FSYS + [ COMMA ,
                                                   DOTDOT , RBRACK ] )
                                                   ;
                                       if GATTR . TYPTR <> NIL then
                                         if GATTR . TYPTR -> . FORM <>
                                         SCALAR then
                                           begin
                                             ERROR ( 136 ) ;
                                             GATTR . TYPTR := NIL
                                           end (* then *)
                                         else
                                           if COMPTYPES ( LSP -> .
                                           ELSET , GATTR . TYPTR ) then
                                             begin
                                               LSP -> . ELSET := GATTR
                                                   . TYPTR ;
                                               if GATTR . KIND = CST
                                               then
                                                 begin
                                                   LATTR := GATTR ;
                                                   if SY = DOTDOT then

                       (***************)
                       (* RANGE GIVEN *)
                       (***************)

                                                   begin
                                                   INSYMBOL ;
                                                   EXPRESSION ( FSYS +
                                                   [ COMMA , RBRACK ] )
                                                   ;
                                                   if GATTR . KIND <>
                                                   CST then
                                                   begin
                                                   GATTR := LATTR ;
                                                   ERROR ( 305 )
                                                   end (* then *) ;
                                                   end (* then *) ;
                                                   if GATTR . TYPTR <>
                                                   LATTR . TYPTR then
                                                   ERROR ( 137 )
                                                   else
                                                   if ( LATTR . CVAL .
                                                   IVAL < 0 ) or (
                                                   GATTR . CVAL . IVAL
                                                   > SETMAX ) or (
                                                   LATTR . CVAL . IVAL
                                                   > GATTR . CVAL .
                                                   IVAL ) then
                                                   ERROR ( 304 )
                                                   else
                                                   begin
                                                   if GATTR . CVAL .
                                                   IVAL > MAXELEM then
                                                   begin
                                                   if GATTR . CVAL .
                                                   IVAL > SETMAX then
                                                   begin
                                                   ERROR ( 304 ) ;
                                                   GATTR . CVAL . IVAL
                                                   := SETMAX ;
                                                   end (* then *) ;
                                                   MAXELEM := GATTR .
                                                   CVAL . IVAL
                                                   end (* then *) ;
                                                   for I := LATTR .
                                                   CVAL . IVAL to GATTR
                                                   . CVAL . IVAL do
                                                   begin
                                                   J := I DIV ( SSETMAX
                                                   + 1 ) ;
                                                   CSTPART [ J + 1 ] :=
                                                   CSTPART [ J + 1 ] +
                                                   [ I - J * ( SSETMAX
                                                   + 1 ) ] ;
                                                   end (* for *) ;
                                                   end (* else *)
                                                 end (* then *)
                                               else
                                                 begin
                                                   LOAD ;
                                                   if GATTR . TYPTR <>
                                                   INTPTR then

                       (********)
                       (*ORD   *)
                       (********)

                                                   GEN0 ( 61 ) ;
                                                   if not VARPART then
                                                   begin

                       (**********************)
                       (* ALLOCATE STORAGE   *)
                       (**********************)

                                                   TS_SIZE :=
                                                   MAXSETSIZE ;
                                                   if GATTR . TYPTR <>
                                                   NIL then
                                                   if GATTR . TYPTR <>
                                                   INTPTR then
                                                   TS_SIZE :=
                                                   CALC_SETSIZE ( GATTR
                                                   . TYPTR ) ;
                                                   if TS_SIZE >
                                                   MAXSETSIZE then
                                                   TS_SIZE :=
                                                   MAXSETSIZE ;
                                                   ALIGN ( LC ,
                                                   WORDSIZE ) ;
                                                   TS_LC := LC ;

                       (********)
                       (*SCL   *)
                       (********)

                                                   GEN2 ( 29 , TS_SIZE
                                                   , LC ) ;
                                                   LC := LC + TS_SIZE ;
                                                   if LC > LCMAX then
                                                   LCMAX := LC ;
                                                   VARPART := TRUE ;

                       (********)
                       (*ASE   *)
                       (********)

                                                   GEN1 ( 67 , -
                                                   TS_SIZE ) ;
                                                   end (* then *)
                                                   else

                       (********)
                       (*ASE   *)
                       (********)

                                                   GEN1 ( 67 , TS_SIZE
                                                   ) ;
                                                 end (* else *)
                                             end (* then *)
                                           else
                                             ERROR ( 137 ) ;
                                       TEST := SY <> COMMA ;
                                       if not TEST then
                                         INSYMBOL
                                     until TEST ;
                                     if SY = RBRACK then
                                       INSYMBOL
                                     else
                                       ERROR ( 12 )
                                   end (* else *) ;
                                 if VARPART then
                                   begin
                                     if MAXELEM >= 0 then
                                       begin
                                         NEW ( LVP , PSET ) ;
                                         LVP -> . PVAL := CSTPART ;
                                         LVP -> . PLNGTH := ( ( MAXELEM
                                                   + SETPACK ) DIV
                                                   SETPACK ) * WORDSIZE
                                                   ;
                                         CNSTPTR := LVP ;
                                         ALIGN ( LC , WORDSIZE ) ;

                       (********)
                       (*LCA   *)
                       (********)

                                         GEN1 ( 37 , ORD ( 'S' ) ) ;

                       (********)
                       (*SLD   *)
                       (********)

                                         GEN2 ( 68 , LVP -> . PLNGTH ,
                                                LC ) ;

                       (********)
                       (*UNI   *)
                       (********)

                                         GEN0 ( 31 ) ;
                                         if LVP -> . PLNGTH > TS_SIZE
                                         then
                                           TS_SIZE := LVP -> . PLNGTH ;
                                         if ( TS_SIZE + LC ) > LCMAX
                                         then
                                           LCMAX := TS_SIZE + LC ;
                                       end (* then *) ;
                                     GATTR . KIND := VARBL ;
                                     GATTR . ACCESS := STKEXPR ;
                                     GATTR . STKDPLMT := TS_LC ;
                                     GATTR . STKLEN := TS_SIZE ;
                                     LSP -> . SIZE := TS_SIZE ;
                                   end (* then *)
                                 else
                                   begin
                                     NEW ( LVP , PSET ) ;
                                     LVP -> . PVAL := CSTPART ;
                                     LVP -> . PLNGTH := ( ( MAXELEM +
                                                   SETPACK ) DIV
                                                   SETPACK ) * WORDSIZE
                                                   ;
                                     LSP -> . SIZE := LVP -> . PLNGTH ;
                                     GATTR . KIND := CST ;
                                     GATTR . CVAL . VALP := LVP ;
                                   end (* else *) ;
                                 GATTR . TYPTR := LSP ;
                               end (* tag/ca *)
                           end (* case *) ;
                           if not ( SY in FSYS ) then
                             begin
                               ERROR ( 6 ) ;
                               SKIP ( FSYS + FACBEGSYS )
                             end (* then *) ;
                           if GATTR . KIND <> VARBL then
                             GATTR . BTYPE := GATTR . TYPTR
                           else
                             if GATTR . TYPTR = NIL then
                               GATTR . BTYPE := NIL ;
                         end (* while *)
                     end (* FACTOR *) ;


                  begin (* TERM *)
                    FACTOR ( FSYS + [ MULOP ] ) ;
                    while SY = MULOP do
                      begin
                        if GATTR . TYPTR <> NIL then
                          if GATTR . TYPTR -> . FORM < POWER then
                            LOAD
                          else
                            FORCETEMPSET ;
                        LATTR := GATTR ;
                        LOP := OP ;
                        INSYMBOL ;
                        FACTOR ( FSYS + [ MULOP ] ) ;
                        if GATTR . TYPTR <> NIL then
                          if GATTR . TYPTR -> . FORM < POWER then
                            LOAD ;
                        if ( LATTR . TYPTR <> NIL ) and ( GATTR . TYPTR
                        <> NIL ) then
                          case LOP of
                            MUL : if ( LATTR . TYPTR = INTPTR ) and (
                                  GATTR . TYPTR = INTPTR ) then

                    (********)
                    (*MPI   *)
                    (********)

                                    GEN0 ( 15 )
                                  else
                                    begin
                                      if GATTR . TYPTR = INTPTR then
                                        begin

                    (********)
                    (*FLT   *)
                    (********)

                                          GEN0 ( 10 ) ;
                                          GATTR . TYPTR := REALPTR
                                        end (* then *)
                                      else
                                        if LATTR . TYPTR = INTPTR then
                                          begin

                    (********)
                    (*FLO   *)
                    (********)

                                            GEN0 ( 9 ) ;
                                            LATTR . TYPTR := REALPTR
                                          end (* then *) ;
                                      if ( LATTR . TYPTR = REALPTR )
                                      and ( GATTR . TYPTR = REALPTR )
                                      then

                    (********)
                    (*MPR   *)
                    (********)

                                        GEN0 ( 16 )
                                      else

                    (********)
                    (*INT   *)
                    (********)

                                        GENSETOP ( LATTR , 12 ) ;
                                    end (* else *) ;
                            RDIV : begin
                                     if GATTR . TYPTR = INTPTR then
                                       begin

                    (********)
                    (*FLT   *)
                    (********)

                                         GEN0 ( 10 ) ;
                                         GATTR . TYPTR := REALPTR
                                       end (* then *) ;
                                     if LATTR . TYPTR = INTPTR then
                                       begin

                    (********)
                    (*FLO   *)
                    (********)

                                         GEN0 ( 9 ) ;
                                         LATTR . TYPTR := REALPTR
                                       end (* then *) ;
                                     if ( LATTR . TYPTR = REALPTR ) and
                                     ( GATTR . TYPTR = REALPTR ) then

                    (********)
                    (*DVR   *)
                    (********)

                                       GEN0 ( 7 )
                                     else
                                       begin
                                         ERROR ( 134 ) ;
                                         GATTR . TYPTR := NIL
                                       end (* else *)
                                   end (* tag/ca *) ;
                            IDIV : if ( LATTR . TYPTR = INTPTR ) and (
                                   GATTR . TYPTR = INTPTR ) then

                    (********)
                    (*DVI   *)
                    (********)

                                     GEN0 ( 6 )
                                   else
                                     begin
                                       ERROR ( 134 ) ;
                                       GATTR . TYPTR := NIL
                                     end (* else *) ;
                            IMOD : if ( LATTR . TYPTR = INTPTR ) and (
                                   GATTR . TYPTR = INTPTR ) then
                                     GEN0 ( 14 )
                                   else
                                     begin
                                       ERROR ( 134 ) ;
                                       GATTR . TYPTR := NIL
                                     end (* else *) ;
                            ANDOP : if ( LATTR . TYPTR = BOOLPTR ) and
                                    ( GATTR . TYPTR = BOOLPTR ) then

                    (********)
                    (*AND   *)
                    (********)

                                      GEN0 ( 4 )
                                    else
                                      begin
                                        ERROR ( 134 ) ;
                                        GATTR . TYPTR := NIL
                                      end (* else *)
                          end (* case *)
                        else
                          GATTR . TYPTR := NIL ;
                        GATTR . BTYPE := GATTR . TYPTR ;
                      end (* while *)
                  end (* TERM *) ;


               begin (* SIMPLEEXPRESSION *)
                 SIGNED := FALSE ;
                 if ( SY = ADDOP ) and ( OP in [ PLUS , MINUS ] ) then
                   begin
                     SIGNED := OP = MINUS ;
                     INSYMBOL
                   end (* then *) ;
                 TERM ( FSYS + [ ADDOP ] ) ;
                 if SIGNED then
                   begin
                     LOAD ;
                     if GATTR . TYPTR = INTPTR then

                 (********)
                 (*NGI   *)
                 (********)

                       GEN0 ( 17 )
                     else
                       if GATTR . TYPTR = REALPTR then

                 (********)
                 (*NGR   *)
                 (********)

                         GEN0 ( 18 )
                       else
                         begin
                           ERROR ( 134 ) ;
                           GATTR . TYPTR := NIL
                         end (* else *)
                   end (* then *) ;
                 while SY = ADDOP do
                   begin
                     if GATTR . TYPTR <> NIL then
                       if GATTR . TYPTR -> . FORM < POWER then
                         LOAD
                       else
                         FORCETEMPSET ;
                     LATTR := GATTR ;
                     LOP := OP ;
                     INSYMBOL ;
                     TERM ( FSYS + [ ADDOP ] ) ;
                     if GATTR . TYPTR <> NIL then
                       if GATTR . TYPTR -> . FORM < POWER then
                         LOAD ;
                     if ( LATTR . TYPTR <> NIL ) and ( GATTR . TYPTR <>
                     NIL ) then
                       case LOP of
                         PLUS : if ( LATTR . TYPTR = INTPTR ) and (
                                GATTR . TYPTR = INTPTR ) then

                 (********)
                 (*ADI   *)
                 (********)

                                  GEN0 ( 2 )
                                else
                                  begin
                                    if GATTR . TYPTR = INTPTR then
                                      begin

                 (********)
                 (*FLT   *)
                 (********)

                                        GEN0 ( 10 ) ;
                                        GATTR . TYPTR := REALPTR
                                      end (* then *)
                                    else
                                      if LATTR . TYPTR = INTPTR then
                                        begin

                 (********)
                 (*FLO   *)
                 (********)

                                          GEN0 ( 9 ) ;
                                          LATTR . TYPTR := REALPTR
                                        end (* then *) ;
                                    if ( LATTR . TYPTR = REALPTR ) and
                                    ( GATTR . TYPTR = REALPTR ) then

                 (********)
                 (*ADR   *)
                 (********)

                                      GEN0 ( 3 )
                                    else

                 (********)
                 (*UNI   *)
                 (********)

                                      GENSETOP ( LATTR , 31 ) ;
                                  end (* else *) ;
                         MINUS : if ( LATTR . TYPTR = INTPTR ) and (
                                 GATTR . TYPTR = INTPTR ) then

                 (********)
                 (*SBI   *)
                 (********)

                                   GEN0 ( 21 )
                                 else
                                   begin
                                     if GATTR . TYPTR = INTPTR then
                                       begin

                 (********)
                 (*FLT   *)
                 (********)

                                         GEN0 ( 10 ) ;
                                         GATTR . TYPTR := REALPTR
                                       end (* then *)
                                     else
                                       if LATTR . TYPTR = INTPTR then
                                         begin

                 (********)
                 (*FLO   *)
                 (********)

                                           GEN0 ( 9 ) ;
                                           LATTR . TYPTR := REALPTR
                                         end (* then *) ;
                                     if ( LATTR . TYPTR = REALPTR ) and
                                     ( GATTR . TYPTR = REALPTR ) then

                 (********)
                 (*SBR   *)
                 (********)

                                       GEN0 ( 8 )
                                     else

                 (********)
                 (*DIF   *)
                 (********)

                                       GENSETOP ( LATTR , 5 ) ;
                                   end (* else *) ;
                         OROP : if ( LATTR . TYPTR = BOOLPTR ) and (
                                GATTR . TYPTR = BOOLPTR ) then

                 (********)
                 (*IOR   *)
                 (********)

                                  GEN0 ( 13 )
                                else
                                  begin
                                    ERROR ( 134 ) ;
                                    GATTR . TYPTR := NIL
                                  end (* else *)
                       end (* case *)
                     else
                       GATTR . TYPTR := NIL ;
                     GATTR . BTYPE := GATTR . TYPTR ;
                   end (* while *)
               end (* SIMPLEEXPRESSION *) ;


            begin (* EXPRESSION *)
              LLC := LC ;
              SIMPLEEXPRESSION ( FSYS + [ RELOP ] ) ;
              if SY = RELOP then
                begin
                  if GATTR . TYPTR <> NIL then
                    if GATTR . TYPTR -> . FORM < POWER then
                      LOAD
                    else
                      if GATTR . TYPTR -> . FORM = POWER then
                        FORCETEMPSET
                      else
                        LOADADDRESS ;
                  LATTR := GATTR ;
                  LOP := OP ;
                  if LOP = INOP then
                    if GATTR . TYPTR <> INTPTR then

              (********)
              (*ORD   *)
              (********)

                      GEN0 ( 61 ) ;
                  INSYMBOL ;
                  SIMPLEEXPRESSION ( FSYS ) ;
                  if GATTR . TYPTR <> NIL then
                    if GATTR . TYPTR -> . FORM < POWER then
                      LOAD
                    else
                      if GATTR . TYPTR -> . FORM = POWER then
                        FORCETEMPSET
                      else
                        LOADADDRESS ;
                  if ( LATTR . TYPTR <> NIL ) and ( GATTR . TYPTR <>
                  NIL ) then

              (********)
              (*IN    *)
              (********)

                    if LOP = INOP then
                      if GATTR . TYPTR -> . FORM = POWER then
                        if COMPTYPES ( LATTR . TYPTR , GATTR . TYPTR ->
                        . ELSET ) then

              (********)
              (*INN   *)
              (********)

                          GEN0 ( 11 )
                        else
                          begin
                            ERROR ( 129 ) ;
                            GATTR . TYPTR := NIL
                          end (* else *)
                      else
                        begin
                          ERROR ( 130 ) ;
                          GATTR . TYPTR := NIL
                        end (* else *)
                    else
                      begin
                        if LATTR . TYPTR <> GATTR . TYPTR then
                          if GATTR . TYPTR = INTPTR then
                            begin

              (********)
              (*FLT   *)
              (********)

                              GEN0 ( 10 ) ;
                              GATTR . TYPTR := REALPTR
                            end (* then *)
                          else
                            if LATTR . TYPTR = INTPTR then
                              begin

              (********)
              (*FLO   *)
              (********)

                                GEN0 ( 9 ) ;
                                LATTR . TYPTR := REALPTR
                              end (* then *) ;
                        if COMPTYPES ( LATTR . TYPTR , GATTR . TYPTR )
                        then
                          begin
                            LSIZE := LATTR . TYPTR -> . SIZE ;
                            case LATTR . TYPTR -> . FORM of
                              SCALAR :
                                if LATTR . TYPTR = REALPTR then
                                  TYPIND := 'R'
                                else
                                  if LATTR . TYPTR = BOOLPTR then
                                    TYPIND := 'B'
                                  else
                                    if LATTR . TYPTR = CHARPTR then
                                      TYPIND := 'C'
                                    else
                                      TYPIND := 'I' ;
                              POINTER :
                                begin
                                  if LOP in [ LTOP , LEOP , GTOP , GEOP
                                  ] then
                                    ERROR ( 131 ) ;
                                  TYPIND := 'A'
                                end (* tag/ca *) ;
                              POWER : begin
                                        if LOP in [ LTOP , GTOP ] then
                                          ERROR ( 132 ) ;
                                        TYPIND := 'S' ;
                                      end (* tag/ca *) ;
                              ARRAYS :
                                begin
                                  if not STRING ( LATTR . TYPTR ) then
                                    if LOP in [ LTOP , LEOP , GTOP ,
                                    GEOP ] then
                                      ERROR ( 131 ) ;
                                  TYPIND := 'M'
                                end (* tag/ca *) ;
                              RECORDS :
                                begin
                                  if LOP in [ LTOP , LEOP , GTOP , GEOP
                                  ] then
                                    ERROR ( 131 ) ;
                                  TYPIND := 'M'
                                end (* tag/ca *) ;
                              FILES : begin
                                        ERROR ( 133 ) ;
                                        TYPIND := 'F'
                                      end (* tag/ca *)
                            end (* case *) ;
                            GEN2 ( COMPARE_OP [ LOP ] , ORD ( TYPIND )
                                   , LSIZE ) ;
                          end (* then *)
                        else
                          ERROR ( 129 )
                      end (* else *) ;
                  GATTR . TYPTR := BOOLPTR ;
                  GATTR . BTYPE := BOOLPTR ;
                  GATTR . KIND := EXPR ;
                  LC := LLC ;
                end (* then *)
            end (* EXPRESSION *) ;


         procedure ASSIGNMENT ( FCP : CTP ) ;

            var LATTR : ATTR ;
                RSIZE , LLC : ADDRRANGE ;

            begin (* ASSIGNMENT *)
              LLC := LC ;
              SELECTOR ( FSYS + [ BECOMES ] , FCP ) ;
              VAR_MOD := VAR_MOD + 1 ;
              if SY = BECOMES then
                begin
                  if GATTR . TYPTR <> NIL then
                    if ( GATTR . ACCESS <> DRCT ) or ( GATTR . TYPTR ->
                    . FORM >= POWER ) then
                      LOADADDRESS ;
                  LATTR := GATTR ;
                  INSYMBOL ;
                  EXPRESSION ( FSYS ) ;
                  if GATTR . TYPTR <> NIL then
                    if GATTR . TYPTR -> . FORM < POWER then
                      LOAD
                    else
                      if GATTR . TYPTR -> . FORM = POWER then
                        FORCETEMPSET
                      else
                        LOADADDRESS ;
                  if ( LATTR . TYPTR <> NIL ) and ( GATTR . TYPTR <>
                  NIL ) then
                    begin
                      if COMPTYPES ( REALPTR , LATTR . TYPTR ) and (
                      GATTR . TYPTR = INTPTR ) then
                        begin

              (********)
              (*FLT   *)
              (********)

                          GEN0 ( 10 ) ;
                          GATTR . TYPTR := REALPTR
                        end (* then *) ;
                      if COMPTYPES ( LATTR . TYPTR , GATTR . TYPTR )
                      then
                        begin
                          if DEBUG then
                            begin
                              ASSIGN := TRUE ;
                              CHKBNDS ( LATTR . BTYPE ) ;
                              ASSIGN := FALSE
                            end (* then *) ;
                          case LATTR . TYPTR -> . FORM of
                            SCALAR , SUBRANGE , POINTER :
                              STORE ( LATTR ) ;

              (********)
              (*SMV   *)
              (********)

                            POWER : GEN2 ( 69 , LATTR . TYPTR -> . SIZE
                                           , GATTR . TYPTR -> . SIZE )
                                           ;

              (********)
              (*MOV   *)
              (********)

                            ARRAYS , RECORDS :
                              GEN1 ( 40 , LATTR . TYPTR -> . SIZE ) ;
                            FILES : ERROR ( 146 )
                          end (* case *)
                        end (* then *)
                      else
                        ERROR ( 129 )
                    end (* then *)
                end (* then *)
              else
                ERROR ( 51 ) ;
              LC := LLC ;
            end (* ASSIGNMENT *) ;


         procedure GOTOSTATEMENT ;

            label 10 ;

            var LLP : LBP ;
                TTOP : DISPRANGE ;
                XLABEL : ALPHA ;

            begin (* GOTOSTATEMENT *)
              if SY = INTCONST then
                begin
                  TTOP := LEVEL ;
                  repeat
                    LLP := DISPLAY [ TTOP ] . FLABEL ;
                    while LLP <> NIL do
                      with LLP -> do
                        if LABVAL = VAL . IVAL then
                          begin
                            if TTOP = LEVEL then

              (********)
              (*UJP   *)
              (********)

                              GENUJPFJP ( 57 , LABNAME )
                            else
                              begin
                                if XNO = 0 then

              (*****************************************)
              (*   FIRST DEEP GOTO TO THIS LABEL       *)
              (*****************************************)

                                  begin
                                    XLABNO := XLABNO + 1 ;
                                    XNO := XLABNO
                                  end (* then *) ;
                                XLABEL := '############' ;
                                MKNAME ( XLABEL , XNO , FALSE ) ;
                                if PRCODE then
                                  WRITELN ( PRR , MN [ 73 ] , ' ' ,
                                            XLABEL : EXTNAMSZ ) ;
                              end (* else *) ;
                            CTREMIT ( CTRGOTO , 0 , LINECNT , 0 ,
                                      LINECNT ) ;
                            goto 10
                          end (* then *)
                        else
                          LLP := NEXTLAB ;
                    TTOP := TTOP - 1
                  until TTOP = 0 ;
                  ERROR ( 167 ) ;
                  10 :
                  INSYMBOL
                end (* then *)
              else
                ERROR ( 15 )
            end (* GOTOSTATEMENT *) ;


         procedure COMPOUNDSTATEMENT ;

            begin (* COMPOUNDSTATEMENT *)
              repeat
                repeat
                  STATEMENT ( FSYS + [ SEMICOLON , ENDSY ] , LOOPC ,
                              SUBR ) ;
                until not ( SY in STATBEGSYS ) ;
                TEST := SY <> SEMICOLON ;
                if not TEST then
                  INSYMBOL
              until TEST ;
              if SY = ENDSY then
                INSYMBOL
              else
                ERROR ( 13 )
            end (* COMPOUNDSTATEMENT *) ;


         procedure IFSTATEMENT ;

            var LCIX1 , LCIX2 : LABELRNG ;
                FIRSTLN , MIDLN : INTEGER ;
                CTRNO : CTRRANGE ;

            begin (* IFSTATEMENT *)
              EXPRESSION ( FSYS + [ THENSY ] ) ;
              GENLABEL ( LCIX1 ) ;
              GENFJP ( LCIX1 ) ;
              if SY = THENSY then
                INSYMBOL
              else
                ERROR ( 52 ) ;
              FIRSTLN := LINECNT ;
              CTRNO := CTRGEN ;

              (********************)
              (*** COUNTER HERE ***)
              (********************)

              STATEMENT ( FSYS + [ ELSESY ] , LOOPC , SUBR ) ;
              if SY = ELSESY then
                begin
                  GENLABEL ( LCIX2 ) ;

              (********)
              (*UJP   *)
              (********)

                  GENUJPFJP ( 57 , LCIX2 ) ;
                  PUTLABEL ( LCIX1 ) ;
                  INSYMBOL ;
                  MIDLN := LINECNT ;
                  STATEMENT ( FSYS , LOOPC , SUBR ) ;
                  PUTLABEL ( LCIX2 )
                end (* then *)
              else
                begin
                  PUTLABEL ( LCIX1 ) ;
                  MIDLN := 0 ;
                end (* else *) ;
              CTREMIT ( CTRIF , CTRNO , FIRSTLN , MIDLN , LINECNT )
            end (* IFSTATEMENT *) ;


         procedure CASESTATEMENT ;

            label 1 ;

            type CIP = -> CASEINFO ;
                 CASEINFO = record
                              NEXT : CIP ;
                              CSSTART : LABELRNG ;
                              CSLAB1 , CSLAB2 : INTEGER
                            end ;

            var LSP , LSP1 : STP ;
                FSTPTR , LPT1 , LPT2 , LPT3 : CIP ;
                LVAL , LVAL1 : VALU ;
                LADDR , LCIX , LCIX1 , UBND , LBND , XADDR : LABELRNG ;
                LMIN , LMAX : INTEGER ;
                OTHWC : BOOLEAN ;
                FIRSTLN : INTEGER ;
                TEMPLN : INTEGER ;
                CTRCASES : INTEGER ;
                CTRNO : CTRRANGE ;

            begin (* CASESTATEMENT *)
              EXPRESSION ( FSYS + [ OFSY , COMMA , COLON ] ) ;
              LOAD ;
              LSP := GATTR . TYPTR ;
              if LSP <> NIL then
                if ( LSP -> . FORM <> SCALAR ) or ( LSP = REALPTR )
                then
                  begin
                    ERROR ( 144 ) ;
                    LSP := NIL
                  end (* then *)
                else
                  if not COMPTYPES ( LSP , INTPTR ) then

              (********)
              (*ORD   *)
              (********)

                    GEN0 ( 61 ) ;
              if DEBUG then
                CHKBNDS ( GATTR . TYPTR ) ;
              if SY = OFSY then
                INSYMBOL
              else
                ERROR ( 8 ) ;
              FSTPTR := NIL ;
              GENLABEL ( LBND ) ;
              GENLABEL ( UBND ) ;
              GENLABEL ( LCIX ) ;
              GENLABEL ( LADDR ) ;

              (******************************************)
              (* WE SHOULD HAVE:                        *)
              (* LADDR = LCIX+1 = UBND+2 = LBND+3  HERE *)
              (******************************************)

              GENLABEL ( XADDR ) ;

              (********)
              (*XJP   *)
              (********)

              GENUJPFJP ( 44 , LBND ) ;
              OTHWC := FALSE ;
              FIRSTLN := LINECNT ;
              CTRCASES := 0 ;
              repeat
                LPT3 := NIL ;
                GENLABEL ( LCIX1 ) ;
                if not ( SY in [ SEMICOLON , ENDSY ] ) then
                  begin
                    if SY <> OTHERWISESY then
                      begin
                        repeat
                          CONSTANT ( FSYS + [ COMMA , COLON , DOTDOT ]
                                     , LSP1 , LVAL ) ;
                          if LSP <> NIL then
                            if COMPTYPES ( LSP , LSP1 ) then
                              begin
                                LVAL1 . IVAL := LVAL . IVAL ;
                                if SY = DOTDOT then
                                  begin
                                    INSYMBOL ;
                                    CONSTANT ( FSYS + [ COMMA , COLON ]
                                               , LSP1 , LVAL1 )
                                  end (* then *) ;
                                if COMPTYPES ( LSP , LSP1 ) then
                                  if LVAL . IVAL <= LVAL1 . IVAL then
                                    begin
                                      LPT1 := FSTPTR ;
                                      LPT2 := NIL ;
                                      while LPT1 <> NIL do
                                        with LPT1 -> do
                                          begin
                                            if LVAL1 . IVAL >= CSLAB2
                                            then
                                              begin
                                                if LVAL . IVAL <=
                                                CSLAB2 then
                                                  ERROR ( 156 ) ;
                                                goto 1
                                              end (* then *) ;
                                            LPT2 := LPT1 ;
                                            LPT1 := NEXT
                                          end (* with *) ;
                                      1 :
                                      NEW ( LPT3 ) ;
                                      with LPT3 -> do
                                        begin
                                          NEXT := LPT1 ;
                                          CSLAB1 := LVAL . IVAL ;
                                          CSLAB2 := LVAL1 . IVAL ;
                                          CSSTART := LCIX1
                                        end (* with *) ;
                                      if LPT2 = NIL then
                                        FSTPTR := LPT3
                                      else
                                        LPT2 -> . NEXT := LPT3
                                    end (* then *)
                                  else
                                    ERROR ( 102 )
                                else
                                  ERROR ( 147 ) ;
                              end (* then *)
                            else
                              ERROR ( 147 ) ;
                          TEST := SY <> COMMA ;
                          if not TEST then
                            INSYMBOL
                        until TEST ;
                        if SY = COLON then
                          INSYMBOL
                        else
                          ERROR ( 5 )
                      end (* then *)
                    else

              (********************)
              (* SY = OTHERWISESY *)
              (********************)

                      begin
                        if OTHWC then
                          ERROR ( 156 )
                        else
                          LCIX1 := LADDR ;
                        OTHWC := TRUE ;
                        INSYMBOL ;
                        if SY = COLON then
                          INSYMBOL

              (********************)
              (* IGNORE : FOR NOW *)
              (********************)

                      end (* else *) ;
                    PUTLABEL ( LCIX1 ) ;
                    TEMPLN := LINECNT ;

              (********************)
              (*** COUNTER HERE ***)
              (********************)

                    CTRNO := CTRGEN ;
                    CTRCASES := CTRCASES + 1 ;
                    repeat
                      STATEMENT ( FSYS + [ SEMICOLON ] , LOOPC , SUBR )
                                  ;
                    until not ( SY in STATBEGSYS ) ;

              (********)
              (*UJP   *)
              (********)

                    GENUJPFJP ( 57 , XADDR ) ;
                    CTREMIT ( CTRCASE , CTRNO , TEMPLN , 0 , LINECNT )
                              ;
                  end (* then *) ;
                TEST := SY <> SEMICOLON ;
                if not TEST then
                  INSYMBOL ;
              until TEST ;
              if FSTPTR <> NIL then
                begin
                  LMAX := FSTPTR -> . CSLAB2 ;

              (******************)
              (*REVERSE POINTERS*)
              (******************)

                  LPT1 := FSTPTR ;
                  FSTPTR := NIL ;
                  repeat
                    LPT2 := LPT1 -> . NEXT ;
                    LPT1 -> . NEXT := FSTPTR ;
                    FSTPTR := LPT1 ;
                    LPT1 := LPT2
                  until LPT1 = NIL ;
                  LMIN := FSTPTR -> . CSLAB1 ;
                end (* then *)
              else
                begin
                  LMIN := 1 ;
                  LMAX := 0
                end (* else *) ;
              GENDEF ( LBND , LMIN ) ;
              GENDEF ( UBND , LMAX ) ;
              PUTLABEL ( LCIX ) ;
              if LMAX - LMIN < CIXMAX then
                begin
                  if FSTPTR <> NIL then
                    repeat
                      with FSTPTR -> do
                        begin
                          while CSLAB1 > LMIN do
                            begin

              (********)
              (*UJP   *)
              (********)

                              GENUJPFJP ( 57 , LADDR ) ;
                              LMIN := LMIN + 1
                            end (* while *) ;
                          repeat

              (********)
              (*UJP   *)
              (********)

                            GENUJPFJP ( 57 , CSSTART ) ;
                            LMIN := LMIN + 1 ;
                          until LMIN > CSLAB2 ;
                          FSTPTR := NEXT ;
                        end (* with *)
                    until FSTPTR = NIL ;
                  if not OTHWC then
                    PUTLABEL ( LADDR ) ;
                  PUTLABEL ( XADDR ) ;
                  CTREMIT ( CTRCASE , 0 , FIRSTLN , CTRCASES , LINECNT
                            ) ;
                end (* then *)
              else
                ERROR ( 157 ) ;
              if SY = ENDSY then
                INSYMBOL
              else
                ERROR ( 13 )
            end (* CASESTATEMENT *) ;


         procedure BREAKSTATEMENT ;

            begin (* BREAKSTATEMENT *)
              if LOOPC . LEVEL <= 0 then
                ERROR ( 70 )
              else
                begin
                  GENUJPFJP ( 57 , LOOPC . BREAKLABEL ) ;
                  LOOPC . BREAKUSED := TRUE ;
                end (* else *)
            end (* BREAKSTATEMENT *) ;


         procedure CONTSTATEMENT ;

            begin (* CONTSTATEMENT *)
              if LOOPC . LEVEL <= 0 then
                ERROR ( 71 )
              else
                begin
                  GENUJPFJP ( 57 , LOOPC . CONTLABEL ) ;
                  LOOPC . CONTUSED := TRUE ;
                end (* else *)
            end (* CONTSTATEMENT *) ;


         procedure RETURNSTATEMENT ;

            begin (* RETURNSTATEMENT *)
              GENUJPFJP ( 57 , SUBR . RETURNLABEL ) ;
              SUBR . RETURNUSED := TRUE ;
            end (* RETURNSTATEMENT *) ;


         procedure REPEATSTATEMENT ;

            var LADDR : LABELRNG ;
                LEXIT : LABELRNG ;
                LCONT : LABELRNG ;
                FIRSTLN : INTEGER ;
                CTRNO : CTRRANGE ;
                LOOPR : LOOPCTL ;

            begin (* REPEATSTATEMENT *)
              GENLABEL ( LADDR ) ;
              GENLABEL ( LCONT ) ;
              GENLABEL ( LEXIT ) ;
              PUTLABEL ( LADDR ) ;
              LOOPR . LEVEL := LOOPC . LEVEL + 1 ;
              LOOPR . BREAKLABEL := LEXIT ;
              LOOPR . BREAKUSED := FALSE ;
              LOOPR . CONTLABEL := LCONT ;
              LOOPR . CONTUSED := FALSE ;
              FIRSTLN := LINECNT ;
              CTRNO := CTRGEN ;

              (********************)
              (*** COUNTER HERE ***)
              (********************)

              repeat
                repeat
                  STATEMENT ( FSYS + [ SEMICOLON , UNTILSY ] , LOOPR ,
                              SUBR ) ;
                until not ( SY in STATBEGSYS ) ;
                TEST := SY <> SEMICOLON ;
                if not TEST then
                  INSYMBOL
              until TEST ;
              if SY = UNTILSY then
                begin
                  if LOOPR . CONTUSED then
                    PUTLABEL ( LCONT ) ;
                  INSYMBOL ;
                  EXPRESSION ( FSYS ) ;
                  GENFJP ( LADDR ) ;
                  if LOOPR . BREAKUSED then
                    PUTLABEL ( LEXIT ) ;
                  CTREMIT ( CTRREPEAT , CTRNO , FIRSTLN , 0 , LINECNT )
                end (* then *)
              else
                ERROR ( 53 ) ;
            end (* REPEATSTATEMENT *) ;


         procedure WHILESTATEMENT ;

            var LADDR , LCIX : LABELRNG ;
                FIRSTLN : INTEGER ;
                CTRNO : CTRRANGE ;
                LOOPW : LOOPCTL ;

            begin (* WHILESTATEMENT *)
              GENLABEL ( LADDR ) ;
              GENLABEL ( LCIX ) ;
              LOOPW . LEVEL := LOOPC . LEVEL + 1 ;
              LOOPW . BREAKLABEL := LCIX ;
              LOOPW . BREAKUSED := FALSE ;
              LOOPW . CONTLABEL := LADDR ;
              LOOPW . CONTUSED := FALSE ;
              PUTLABEL ( LADDR ) ;
              EXPRESSION ( FSYS + [ DOSY ] ) ;
              GENFJP ( LCIX ) ;
              if SY = DOSY then
                INSYMBOL
              else
                ERROR ( 54 ) ;
              FIRSTLN := LINECNT ;
              CTRNO := CTRGEN ;

              (********************)
              (*** COUNTER HERE ***)
              (********************)

              STATEMENT ( FSYS , LOOPW , SUBR ) ;

              (********)
              (*UJP   *)
              (********)

              GENUJPFJP ( 57 , LADDR ) ;
              PUTLABEL ( LCIX ) ;
              CTREMIT ( CTRWHILE , CTRNO , FIRSTLN , 0 , LINECNT ) ;
            end (* WHILESTATEMENT *) ;


         procedure FORSTATEMENT ;

            var LATTR : ATTR ;
                LSP : STP ;
                LSY : SYMBOL ;
                LOP : OPRANGE ;
                XT , CV1 , CV2 : INTEGER ;
                CB1 , CB2 : BOOLEAN ;
                LCIX , LADDR , LINCR : LABELRNG ;
                LLC : ADDRRANGE ;
                FIRSTLN : INTEGER ;
                CTRNO : CTRRANGE ;
                LOOPF : LOOPCTL ;

            begin (* FORSTATEMENT *)
              if SY = IDENT then
                begin
                  SEARCHID ( [ VARS ] , LCP ) ;
                  with LCP -> , LATTR do
                    begin
                      TYPTR := IDTYPE ;
                      KIND := VARBL ;
                      BTYPE := TYPTR ;
                      if TYPTR <> NIL then
                        if TYPTR -> . FORM = SUBRANGE then
                          TYPTR := TYPTR -> . RANGETYPE ;
                      if VKIND = ACTUAL then
                        begin
                          ACCESS := DRCT ;
                          VLEVEL := VLEV ;
                          DPLMT := VADDR ;
                        end (* then *)
                      else
                        begin
                          ERROR ( 155 ) ;
                          TYPTR := NIL
                        end (* else *)
                    end (* with *) ;
                  if LATTR . TYPTR <> NIL then
                    if ( LATTR . TYPTR -> . FORM > SUBRANGE ) or (
                    LATTR . TYPTR = REALPTR ) then
                      begin
                        ERROR ( 143 ) ;
                        LATTR . TYPTR := NIL
                      end (* then *) ;
                  INSYMBOL
                end (* then *)
              else
                begin
                  ERROR ( 2 ) ;
                  LATTR . TYPTR := NIL ;
                  SKIP ( FSYS + [ BECOMES , TOSY , DOWNTOSY , DOSY ] )
                end (* else *) ;
              if SY = BECOMES then
                begin
                  INSYMBOL ;
                  EXPRESSION ( FSYS + [ TOSY , DOWNTOSY , DOSY ] ) ;
                  if GATTR . TYPTR <> NIL then
                    if GATTR . TYPTR -> . FORM <> SCALAR then
                      ERROR ( 144 )
                    else
                      if COMPTYPES ( LATTR . TYPTR , GATTR . TYPTR )
                      then
                        begin
                          if GATTR . KIND = CST then
                            begin
                              CB1 := TRUE ;
                              CV1 := GATTR . CVAL . IVAL
                            end (* then *)
                          else
                            CB1 := FALSE ;
                          LOAD ;
                          STORE ( LATTR ) ;
                        end (* then *)
                      else
                        ERROR ( 145 )
                end (* then *)
              else
                begin
                  ERROR ( 51 ) ;
                  SKIP ( FSYS + [ TOSY , DOWNTOSY , DOSY ] )
                end (* else *) ;
              if ( SY = TOSY ) or ( SY = DOWNTOSY ) then
                begin
                  LSY := SY ;
                  INSYMBOL ;
                  EXPRESSION ( FSYS + [ DOSY ] ) ;
                  if GATTR . TYPTR <> NIL then
                    if GATTR . TYPTR -> . FORM <> SCALAR then
                      ERROR ( 144 )
                    else
                      if COMPTYPES ( LATTR . TYPTR , GATTR . TYPTR )
                      then
                        begin
                          if GATTR . KIND = CST then
                            begin
                              CB2 := TRUE ;
                              LLC := LC ;
                              CV2 := GATTR . CVAL . IVAL
                            end (* then *)
                          else
                            begin
                              CB2 := FALSE ;
                              LOAD ;
                              ALIGN ( LC , INTSIZE ) ;
                              LLC := LC ;
                              if GATTR . TYPTR <> INTPTR then

              (********)
              (*ORD   *)
              (********)

                                GEN0 ( 61 ) ;

              (********)
              (*STR   *)
              (********)

                              GEN3 ( 56 , ORD ( 'I' ) , LEVEL , LLC ) ;
                              LC := LC + INTSIZE ;
                              if LC > LCMAX then
                                LCMAX := LC ;
                            end (* else *) ;
                          if CB1 and CB2 then
                            begin
                              XT := 1 ;
                              if LSY = TOSY then
                                if CV1 > CV2 then
                                  XT := 0
                                else

                              else
                                if CV1 < CV2 then
                                  XT := 0 ;

              (********)
              (*LDC   *)
              (********)

                              GEN2 ( 51 , 3 , XT ) ;
                            end (* then *)
                          else
                            begin
                              if CB1 then

              (********)
              (*LDC   *)
              (********)

                                GEN2 ( 51 , 1 , CV1 )
                              else
                                begin
                                  GATTR := LATTR ;
                                  LOAD ;
                                  if GATTR . TYPTR <> INTPTR then

              (********)
              (*ORD   *)
              (********)

                                    GEN0 ( 61 ) ;
                                end (* else *) ;
                              if CB2 then

              (********)
              (*LDC   *)
              (********)

                                GEN2 ( 51 , 1 , CV2 )
                              else

              (********)
              (*LOD   *)
              (********)

                                GEN3 ( 54 , ORD ( 'I' ) , LEVEL , LLC )
                                       ;
                              if LSY = TOSY then
                                LOP := 52
                              else
                                LOP := 48 ;
                              GEN2 ( LOP , ORD ( 'I' ) , 1 ) ;
                            end (* else *) ;
                        end (* then *)
                      else
                        ERROR ( 145 )
                end (* then *)
              else
                begin
                  ERROR ( 55 ) ;
                  SKIP ( FSYS + [ DOSY ] )
                end (* else *) ;
              GENLABEL ( LADDR ) ;
              GENLABEL ( LINCR ) ;
              GENLABEL ( LCIX ) ;
              LOOPF . LEVEL := LOOPC . LEVEL + 1 ;
              LOOPF . BREAKLABEL := LCIX ;
              LOOPF . BREAKUSED := FALSE ;
              LOOPF . CONTLABEL := LINCR ;
              LOOPF . CONTUSED := FALSE ;

              (********)
              (*FJP   *)
              (********)

              GENUJPFJP ( 33 , LCIX ) ;
              PUTLABEL ( LADDR ) ;

              (***********************************)
              (*   BEGINNING OF THE FOR 'LOOP'   *)
              (***********************************)

              if SY = DOSY then
                INSYMBOL
              else
                ERROR ( 54 ) ;
              FIRSTLN := LINECNT ;
              CTRNO := CTRGEN ;

              (********************)
              (*** COUNTER HERE ***)
              (********************)

              STATEMENT ( FSYS , LOOPF , SUBR ) ;
              if LOOPF . CONTUSED then
                PUTLABEL ( LINCR ) ;
              GATTR := LATTR ;
              LOAD ;
              if GATTR . TYPTR <> INTPTR then

              (********)
              (*ORD   *)
              (********)

                GEN0 ( 61 ) ;
              if CB2 then

              (********)
              (*LDC   *)
              (********)

                GEN2 ( 51 , 1 , CV2 )
              else

              (********)
              (*LOD   *)
              (********)

                GEN3 ( 54 , ORD ( 'I' ) , LEVEL , LLC ) ;

              (********)
              (*NEQ   *)
              (********)

              GEN2 ( 55 , ORD ( 'I' ) , 1 ) ;

              (********)
              (*FJP   *)
              (********)

              GENUJPFJP ( 33 , LCIX ) ;
              GATTR := LATTR ;
              LOAD ;
              LOP := 23 ;

              (********)
              (*INC   *)
              (********)

              if LSY <> TOSY then
                LOP := 22 ;

              (********)
              (*DEC   *)
              (********)

              GEN2 ( LOP , GETTYPE ( GATTR . TYPTR ) , 1 ) ;
              if DEBUG then
                CHKBNDS ( LATTR . TYPTR ) ;
              STORE ( LATTR ) ;

              (********)
              (*UJP   *)
              (********)

              GENUJPFJP ( 57 , LADDR ) ;
              PUTLABEL ( LCIX ) ;
              LC := LLC ;
              CTREMIT ( CTRFOR , CTRNO , FIRSTLN , 0 , LINECNT ) ;
            end (* FORSTATEMENT *) ;


         procedure WITHSTATEMENT ;

            var LCP : CTP ;
                LCNT : DISPRANGE ;
                LLC : ADDRRANGE ;
                OLD_LEV : - 1 .. DISPLIMIT ;
                REC_STR : STP ;

            begin (* WITHSTATEMENT *)
              LLC := LC ;
              if GET_STAT then
                WS_CNT := WS_CNT + 1 ;
              if SY = IDENT then
                begin
                  SEARCHID ( [ VARS , FIELD ] , LCP ) ;
                  INSYMBOL
                end (* then *)
              else
                begin
                  ERROR ( 2 ) ;
                  LCP := UVARPTR
                end (* else *) ;
              SELECTOR ( FSYS + [ COMMA , DOSY ] , LCP ) ;
              REC_STR := GATTR . TYPTR ;
              if GATTR . TYPTR <> NIL then
                if GATTR . TYPTR -> . FORM = RECORDS then
                  if TOP < DISPLIMIT then
                    begin
                      TOP := TOP + 1 ;
                      with DISPLAY [ TOP ] do
                        begin
                          OLD_LEV := REC_STR -> . FLD_DISP_LEV ;
                          REC_STR -> . FLD_DISP_LEV := TOP ;
                          if GATTR . ACCESS = DRCT then
                            begin
                              OCCUR := CREC ;
                              CLEV := GATTR . VLEVEL ;
                              CDSPL := GATTR . DPLMT
                            end (* then *)
                          else
                            begin
                              LOADADDRESS ;
                              ALIGN ( LC , PTRSIZE ) ;

              (********)
              (*STR   *)
              (********)

                              GEN3 ( 56 , ORD ( 'A' ) , LEVEL , LC ) ;
                              OCCUR := VREC ;
                              VDSPL := LC ;
                              LC := LC + PTRSIZE ;
                              if LC > LCMAX then
                                LCMAX := LC
                            end (* else *)
                        end (* with *)
                    end (* then *)
                  else
                    FATALERROR ( 250 )
                else
                  begin
                    ERROR ( 140 ) ;
                    REC_STR := NIL
                  end (* else *) ;
              OPEN_RECORD := REC_STR ;
              if SY = COMMA then
                begin
                  INSYMBOL ;
                  WITHSTATEMENT
                end (* then *)
              else
                begin
                  if SY = DOSY then
                    INSYMBOL
                  else
                    ERROR ( 54 ) ;
                  STATEMENT ( FSYS , LOOPC , SUBR ) ;
                end (* else *) ;
              if REC_STR <> NIL then
                REC_STR -> . FLD_DISP_LEV := OLD_LEV ;
              TOP := TOP - 1 ;
              LC := LLC ;
              OPEN_RECORD := NIL ;
            end (* WITHSTATEMENT *) ;


         begin (* STATEMENT *)
           if SY = INTCONST then

           (********)
           (*LABEL *)
           (********)

             begin
               LLP := DISPLAY [ LEVEL ] . FLABEL ;
               while LLP <> NIL do
                 with LLP -> do
                   if LABVAL = VAL . IVAL then
                     begin
                       if DEFINED then
                         ERROR ( 165 ) ;
                       if XNO > 0 then

           (***********************************)
           (* LABEL IS AN EXTERNAL ENTRY PT.  *)
           (***********************************)

                         begin
                           XLABEL := '############' ;
                           MKNAME ( XLABEL , XNO , FALSE ) ;
                           if PRCODE then
                             WRITELN ( PRR , XLABEL : EXTNAMSZ , MN [
                                       74 ] ) ;
                           XNO := 0 ;

           (***************************)
           (* IN CASE OF REDEFINITION *)
           (***************************)

                         end (* then *) ;
                       PUTLABEL ( LABNAME ) ;
                       DEFINED := TRUE ;
                       CTRNO := CTRGEN ;
                       CTREMIT ( CTRLBL , CTRNO , LINECNT , 0 , LINECNT
                                 ) ;

           (********************)
           (*** COUNTER HERE ***)
           (********************)

                       goto 1
                     end (* then *)
                   else
                     LLP := NEXTLAB ;
               ERROR ( 167 ) ;
               1 :
               INSYMBOL ;
               if SY = COLON then
                 INSYMBOL
               else
                 ERROR ( 5 )
             end (* then *) ;
           if not ( SY in FSYS + [ IDENT ] ) then
             begin
               ERROR ( 6 ) ;
               SKIP ( FSYS )
             end (* then *) ;
           if SY in STATBEGSYS + [ IDENT ] then
             begin
               case SY of
                 IDENT : begin
                           SEARCHID ( [ VARS , FIELD , FUNC , PROC ] ,
                                      LCP ) ;
                           INSYMBOL ;
                           if LCP -> . KLASS = PROC then
                             CALL ( FSYS , LCP )
                           else
                             ASSIGNMENT ( LCP )
                         end (* tag/ca *) ;
                 BEGINSY :
                   begin
                     STMTNEST := STMTNEST + 1 ;
                     INSYMBOL ;
                     COMPOUNDSTATEMENT ;
                     STMTNEST := STMTNEST - 1 ;
                   end (* tag/ca *) ;
                 GOTOSY :
                   begin
                     INSYMBOL ;
                     GOTOSTATEMENT
                   end (* tag/ca *) ;
                 IFSY : begin
                          INSYMBOL ;
                          IFSTATEMENT
                        end (* tag/ca *) ;
                 CASESY :
                   begin
                     STMTNEST := STMTNEST + 1 ;
                     INSYMBOL ;
                     CASESTATEMENT ;
                     STMTNEST := STMTNEST - 1
                   end (* tag/ca *) ;
                 WHILESY :
                   begin
                     INSYMBOL ;
                     WHILESTATEMENT
                   end (* tag/ca *) ;
                 REPEATSY :
                   begin
                     STMTNEST := STMTNEST + 1 ;
                     INSYMBOL ;
                     REPEATSTATEMENT ;
                     STMTNEST := STMTNEST - 1
                   end (* tag/ca *) ;
                 FORSY : begin
                           INSYMBOL ;
                           FORSTATEMENT
                         end (* tag/ca *) ;
                 BREAKSY :
                   begin
                     INSYMBOL ;
                     BREAKSTATEMENT
                   end (* tag/ca *) ;
                 CONTINUESY :
                   begin
                     INSYMBOL ;
                     CONTSTATEMENT
                   end (* tag/ca *) ;
                 RETURNSY :
                   begin
                     INSYMBOL ;
                     RETURNSTATEMENT
                   end (* tag/ca *) ;
                 WITHSY :
                   begin
                     INSYMBOL ;
                     WITHSTATEMENT
                   end (* tag/ca *)
               end (* case *) ;
               if not ( SY in [ SEMICOLON , ENDSY , ELSESY , UNTILSY ]
               ) then
                 begin
                   ERROR ( 6 ) ;
                   SKIP ( FSYS )
                 end (* then *)
             end (* then *)
         end (* STATEMENT *) ;


      procedure FRTPARMS ;

      (*********************************)
      (* THIS BORING PROCEDURE         *)
      (* GENERATES DUMMY ROUTINES      *)
      (* TO REPLACE FORTRAN ROUTINES   *)
      (* PASSED AS PROC. PARAMETERS    *)
      (*********************************)


         var PT , LOCPAR : INTEGER ;
             LLC , LCM : ADDRRANGE ;
             LCP1 : CTP ;
             FNAME : ALPHA ;

         begin (* FRTPARMS *)
           LEVEL := LEVEL + 1 ;
           OLDIC := IC ;
           while FRTPARHD <> NIL do
             with FRTPARHD -> do
               begin
                 IC := 0 ;
                 FRTRN := FALSE ;
                 PT := PROCTYPE ( FRTPARHD ) ;
                 FNAME := NAME ;
                 MKNAME ( FNAME , PFNAME , FALSE ) ;

           (********)
           (*ENT   *)
           (********)

                 WRITELN ( PRR , FNAME : 8 , MN [ 32 ] , CHR ( PT ) : 2
                           , ',' , LEVEL : 1 , ',L' , SEGSIZE : 1 ,
                           NAME : 14 , ',' , SAVEREGS : 1 , ',' ,
                           ASSEMBLE : 1 , ',' , GET_STAT : 1 , ',' ,
                           ASMVERB : 1 , ',' , DEBUG_LEV : 1 , ',' ,
                           PFNAME : 1 ) ;
                 WRITELN ( QRR , '#BGN    ' , NAME , LEVEL : 4 ) ;
                 LCP1 := PRMPTR ;
                 LC := LCAFTMST + FPSAVEAREA ;
                 while LCP1 <> NIL do
                   with LCP1 -> do
                     begin
                       if KLASS = VARS then
                         if IDTYPE <> NIL then
                           begin
                             if VKIND = FORMAL then
                               LCM := VADDR + PTRSIZE
                             else
                               LCM := VADDR + IDTYPE -> . SIZE ;
                             if LCM > LC then
                               LC := LCM ;
                           end (* then *) ;
                       LCP1 := NEXT
                     end (* with *) ;
                 ALIGN ( LC , PTRSIZE ) ;
                 LLC := LC ;
                 LCP1 := PRMPTR ;
                 while LCP1 <> NIL do
                   with LCP1 -> do
                     begin
                       if KLASS = VARS then
                         if IDTYPE <> NIL then
                           begin
                             if VKIND = FORMAL then

           (********)
           (*LOD   *)
           (********)

                               GEN3 ( 54 , ORD ( 'A' ) , LEVEL , VADDR
                                      )
                             else

           (********)
           (*LDA   *)
           (********)

                               GEN2 ( 50 , LEVEL , VADDR ) ;

           (********)
           (*STR   *)
           (********)

                             GEN3 ( 56 , ORD ( 'A' ) , LEVEL , LLC ) ;
                             LLC := LLC + PTRSIZE ;
                           end (* then *) ;
                       LCP1 := NEXT ;
                     end (* with *) ;
                 FRTRN := TRUE ;
                 LOCPAR := ( LLC - LC ) DIV 2 + 1 ;
                 PUTIC ;

           (********)
           (*CUP   *)
           (********)

                 WRITELN ( PRR , MN [ 46 ] , CHR ( PROCTYPE ( FRTPARHD
                           ) ) : 2 , ',' , LOCPAR : 1 , ',' , EXTNAME ,
                           ',' , LC : 1 ) ;
                 if KLASS = FUNC then

           (********)
           (*STR   *)
           (********)

                   GEN3 ( 56 , PT , LEVEL , FNCRSLT ) ;

           (********)
           (*RET   *)
           (********)

                 GEN1 ( 42 , PT ) ;
                 GENDEF ( SEGSIZE , LLC ) ;
                 WRITELN ( QRR , '#PROC   ' , NAME : IDLNGTH , ' ' ,
                           PFNAME : 1 , ' ' , FALSE : 1 , IC : 6 , LLC
                           : 8 , ' ' , FALSE : 1 , ' REF/MOD RATIO:' ,
                           0 : 4 , 0 : 6 , 0.0 : 10 ) ;
                 WRITELN ( QRR , '#END' ) ;
                 OLDIC := OLDIC + IC ;
                 FRTPARHD := NXTFWRD ;
               end (* with *) ;
           LEVEL := LEVEL - 1 ;
           IC := OLDIC ;
         end (* FRTPARMS *) ;


      begin (* BODY *)
        STMTNEST := 1 ;
        LISTTAG := 'N' ;
        PUTIC ;
        if FPROCP = MAINPROG then

        (********)
        (*BGN   *)
        (********)

          WRITELN ( PRR , MN [ 72 ] , ' ' , PROGNAME , ' ' , TIME : 8 ,
                    ' ' , DATE ) ;

        (********)
        (*ENT   *)
        (********)

        WRITELN ( PRR , FPROCP -> . EXTNAME , MN [ 32 ] , CHR (
                  PROCTYPE ( FPROCP ) ) : 2 , ',' , LEVEL : 1 , ',L' ,
                  SEGSIZE : 1 , FPROCP -> . NAME : 14 , ',' , SAVEREGS
                  : 1 , ',' , ASSEMBLE : 1 , ',' , GET_STAT : 1 , ',' ,
                  ASMVERB : 1 , ',' , DEBUG_LEV : 1 , ',' : 1 , FPROCP
                  -> . PFNAME : 1 ) ;
        IC := IC + 1 ;
        STIC := 0 ;

        (******************************)
        (* LENGTH OF STRING CONSTANTS *)
        (******************************)

        LOCAL_CALL := FALSE ;
        VAR_REF := 0 ;
        VAR_MOD := 0 ;
        WRITELN ( QRR , '#BGN    ' , FPROCP -> . NAME , LEVEL : 4 ) ;
        if FPROCP = MAINPROG then

        (***********************)
        (* ENTERING MAIN BLOCK *)
        (***********************)

          begin
            while FILEHEAD <> NIL do
              begin
                with FILEHEAD -> do
                  begin
                    with FILIDPTR -> do
                      begin

        (********)
        (*LDA   *)
        (********)

                        GEN2 ( 50 , 1 , VADDR ) ;

        (*************)
        (* CSP - SIO *)
        (*************)

                        GEN1 ( 30 , 31 ) ;
                        if VADDR >= FIRSTGVAR then

        (**********************)
        (* USER DEFINED FILES *)
        (**********************)

                          begin
                            NEW ( CNSTPTR , STRG ) ;
                            CNSTPTR -> . SLNGTH := 8

        (****************)
        (*OS NAME LENGTH*)
        (****************)


                                                   ;
                            for I := 1 to 8 do
                              CNSTPTR -> . SVAL [ I ] := NAME [ I ] ;

        (********)
        (*LCA   *)
        (********)

                            GEN1 ( 37 , 0 ) ;
                            LLC1 := 0 ;

        (*******************************)
        (* LENGTH CODE FOR A TEXT FILE *)
        (*******************************)

                            if not COMPTYPES ( IDTYPE , TEXTPTR ) then
                              if IDTYPE <> NIL then
                                if IDTYPE -> . FILTYPE <> NIL then
                                  LLC1 := IDTYPE -> . FILTYPE -> . SIZE
                                          ;

        (********)
        (*LDC   *)
        (********)

                            GEN2 ( 51 , 1 , LLC1 ) ;

        (*******************)
        (* FILE COMP. SIZE *)
        (*******************)

                            GEN1 ( 30 , 30 ) ;

        (*************)
        (* CSP - FDF *)
        (*************)

                          end (* then *)
                        else

        (******************************)
        (* I.E. IF VADDR < FIRSTUSERF *)
        (******************************)

                          begin
                            I := 3 ;

        (******************)
        (* CODE FOR RESET *)
        (******************)

                            if FILIDPTR = OUTPUTPTR then
                              I := 4

        (***********)
        (* REWRITE *)
        (***********)

                            else
                              if NAME [ 3 ] = 'R' then
                                I := 4

        (***********)
        (* REWRITE *)
        (***********)


                                     ;

        (*****************)
        (* CSP - RES/REW *)
        (*****************)

                            GEN1 ( 30 , I )
                          end (* else *) ;

        (*************)
        (* CSP - EIO *)
        (*************)

                        GEN1 ( 30 , 32 ) ;
                      end (* with *) ;
                  end (* with *) ;
                FILEHEAD := FILEHEAD -> . NEXTFILE
              end (* while *) ;
            if CTROPTION then
              begin
                GENLABEL ( CTRCNTLBL ) ;

        (********)
        (*CTS   *)
        (********)

                GENUJPFJP ( 38 , CTRCNTLBL ) ;
              end (* then *) ;
          end (* then *) ;

        (*************************)
        (* PROCESSING MAIN BLOCK *)
        (*************************)

        FIRSTLN := LINECNT ;
        CTRNO := CTRGEN ;

        (********************)
        (*** COUNTER HERE ***)
        (********************)

        LCMAX := LC ;
        LOOP0 . LEVEL := 0 ;
        LOOP0 . BREAKLABEL := 0 ;
        LOOP0 . BREAKUSED := FALSE ;
        LOOP0 . CONTLABEL := 0 ;
        LOOP0 . CONTUSED := FALSE ;
        GENLABEL ( LRETURN ) ;
        SUBR . RETURNLABEL := LRETURN ;
        SUBR . RETURNUSED := FALSE ;

        (***************************************************)
        (* COMPILE THE STATEMENTS WITHIN THIS BLOCK (BODY) *)
        (***************************************************)

        repeat
          repeat
            STATEMENT ( FSYS + [ SEMICOLON , ENDSY ] , LOOP0 , SUBR ) ;
          until not ( SY in STATBEGSYS ) ;
          TEST := SY <> SEMICOLON ;
          if not TEST then
            INSYMBOL
        until TEST ;
        if SY = ENDSY then
          INSYMBOL
        else
          ERROR ( 13 ) ;
        if SUBR . RETURNUSED then
          PUTLABEL ( LRETURN ) ;
        STMTNEST := 0 ;
        LISTTAG := ' ' ;
        LLP := DISPLAY [ TOP ] . FLABEL ;

        (*****************************)
        (* TEST FOR UNDEFINED LABELS *)
        (*****************************)

        while LLP <> NIL do
          with LLP -> do
            begin
              if not DEFINED then
                begin
                  PLCNT := PLCNT + 1 ;
                  WRITELN ( OUTPUT , '**** UNDEF. LABEL:' : 23 , LABVAL
                            ) ;
                  ERROR ( 168 ) ;
                end (* then *) ;
              LLP := NEXTLAB
            end (* with *) ;
        CTREMIT ( CTRPROC , CTRNO , FIRSTLN , 0 , LINECNT ) ;
        if FPROCP = MAINPROG then

        (******************)
        (* RESET COUNTERS *)
        (******************)

          begin
            CTREMIT ( CTRPROC , 0 , 0 , 0 , 0 ) ;

        (*************************)
        (* EOF FOR COUNTER TABLE *)
        (*************************)

            if ODD ( CTRCNT ) then
              CTRCNT := CTRCNT + 1 ;
            if CTROPTION then
              GENDEF ( CTRCNTLBL , CTRCNT ) ;
          end (* then *) ;

        (********)
        (*RET   *)
        (********)

        GEN1 ( 42 , PROCTYPE ( FPROCP ) ) ;
        ALIGN ( LCMAX , MXDATASZE ) ;
        if PRCODE then
          GENDEF ( SEGSIZE , LCMAX ) ;
        CALL_LVL [ LOCAL_CALL ] := CALL_LVL [ LOCAL_CALL ] + 1 ;
        WRITE ( QRR , '#PROC   ' , FPROCP -> . NAME : IDLNGTH , ' ' ,
                FPROCP -> . PFNAME : 1 , ' ' , LOCAL_CALL : 1 , ' ' ,
                IC + ( STIC DIV 4 ) : 1 , ' ' , LCMAX : 1 , ' ' ,
                FLIPDEBUG : 1 , ' REF/MOD RATIO:' , VAR_MOD : 4 ,
                VAR_MOD + VAR_REF : 6 ) ;
        if ( VAR_MOD + VAR_REF ) = 0 then
          WRITELN ( QRR , 0.0 : 10 )
        else
          WRITELN ( QRR , VAR_MOD / ( VAR_MOD + VAR_REF ) : 10 ) ;
        WRITELN ( QRR , '#END' ) ;
        OLDIC := OLDIC + IC ;
        IC := OLDIC ;

        (**************************)
        (* DISPLAY CUMULATIVE IC  *)
        (**************************)

        HP := TRUE ;
        if FRTPARHD <> NIL then
          FRTPARMS ;
        if FPROCP = MAINPROG then

        (********)
        (*STP   *)
        (********)

          GEN0 ( 43 ) ;
      end (* BODY *) ;


   begin (* BLOCK *)
     IC := 0 ;
     GENLABEL ( SEGSIZE ) ;
     CONSTLC := - 1 ;
     FWRDPRCL := NIL ;
     DEC_ORDER := 0 ;
     repeat
       while SY in [ LABELSY , CONSTSY , TYPESY , VARSY ] do
         begin
           LSY := SY ;
           INSYMBOL ;
           case LSY of
             LABELSY :
               begin
                 LABELDECLARATION ;
                 if DEC_ORDER >= 1 then
                   EXTUSED := TRUE ;
                 DEC_ORDER := 1 ;
               end (* tag/ca *) ;
             CONSTSY :
               begin
                 CONSTDECLARATION ;
                 if DEC_ORDER >= 2 then
                   EXTUSED := TRUE ;
                 DEC_ORDER := 2 ;
               end (* tag/ca *) ;
             TYPESY :
               begin
                 TYPEDECLARATION ;
                 if DEC_ORDER >= 3 then
                   EXTUSED := TRUE ;
                 DEC_ORDER := 3 ;
               end (* tag/ca *) ;
             VARSY : begin
                       VARDECLARATION ;
                       if DEC_ORDER >= 4 then
                         EXTUSED := TRUE ;
                       DEC_ORDER := 4 ;
                     end (* tag/ca *) ;
           end (* case *) ;
         end (* while *) ;
       if CONSTLC >= 0 then

     (***********************************)
     (* A CONSTANTS BLOCK WAS GENERATED *)
     (***********************************)

         begin
           CONSTLC := - 1 ;
           WRITELN ( PRR , MN [ 75 ] ) ;
         end (* then *) ;
       if DEBUG_LEV > 0 then
         PRNTSYMBL ( NIL ) ;

     (**************************)
     (* PRINT HEAP TYPE DEFNS. *)
     (**************************)

       while SY in [ PROCSY , FUNCSY ] do
         begin
           LSY := SY ;
           INSYMBOL ;
           PROCDECLARATION ( LSY )
         end (* while *) ;
       if SY <> BEGINSY then
         begin
           ERROR ( 18 ) ;
           SKIP ( FSYS )
         end (* then *)
     until SY in STATBEGSYS ;
     if SY = BEGINSY then
       INSYMBOL
     else
       ERROR ( 17 ) ;
     while FWRDPRCL <> NIL do
       begin
         WRITELN ( '**** MISSING FORWARD DECLARED PROCEDURE:' : 50 ,
                   FWRDPRCL -> . NAME : 14 ) ;
         PLCNT := PLCNT + 1 ;
         FWRDPRCL := FWRDPRCL -> . NXTFWRD
       end (* while *) ;
     repeat
       BODY ( FSYS + [ CASESY ] ) ;
       if SY <> FSY then
         begin
           ERROR ( 6 ) ;
           SKIP ( FSYS + [ FSY ] )
         end (* then *)
     until ( SY = FSY ) or ( SY in BLOCKBEGSYS ) ;
   end (* BLOCK *) ;



procedure PROGRAMME ( FSYS : SETOFSYS ) ;

   var LFPTR : FRECPTR ;
       LCP : CTP ;
       I , J : INTEGER ;

   begin (* PROGRAMME *)
     CALL_LVL [ FALSE ] := 0 ;
     CALL_LVL [ TRUE ] := 0 ;
     if SY = PROGSY then
       begin
         INSYMBOL ;
         if SY <> IDENT then
           ERROR ( 2 ) ;
         PROGNAME := ID ;
         INSYMBOL ;
         if not ( SY in [ LPARENT , SEMICOLON ] ) then
           ERROR ( 14 ) ;
         if SY = LPARENT then
           begin
             PRTERR := FALSE ;

     (**************************)
     (* IGNORE BAD PROG. PARMS *)
     (**************************)

             repeat
               INSYMBOL ;
               if SY = IDENT then
                 begin
                   SEARCHID ( [ VARS ] , LCP ) ;
                   if LCP <> NIL then
                     if LCP -> . IDTYPE = TEXTPTR then
                       begin
                         NEW ( LFPTR ) ;
                         with LFPTR -> do
                           begin
                             FILIDPTR := LCP ;
                             NEXTFILE := FILEHEAD ;
                           end (* with *) ;
                         FILEHEAD := LFPTR ;
                       end (* then *) ;
                   INSYMBOL ;
                   if not ( SY in [ COMMA , RPARENT ] ) then
                     ERROR ( 20 )
                 end (* then *)
               else
                 ERROR ( 2 )
             until SY <> COMMA ;
             if SY <> RPARENT then
               ERROR ( 4 ) ;
             PRTERR := TRUE ;
             INSYMBOL
           end (* then *) ;
         if SY <> SEMICOLON then
           ERROR ( 14 )
         else
           INSYMBOL ;
       end (* then *) ;
     NEW ( MAINPROG , PROC , DECLARED ) ;
     with MAINPROG -> do
       begin
         NAME := '$MAINBLK    ' ;
         EXTNAME := '$MAINBLK' ;
         PFNAME := 0 ;
         IDTYPE := NIL ;
         FWDECL := FALSE ;
         PFLEV := 0 ;
         KLASS := PROC ;
         PFDECKIND := DECLARED ;
         NEXT := NIL ;
         NEXT_IN_BKT := NIL ;
         DECL_LEV := 0 ;
         FRTRN := FALSE ;
         EXTRN := FALSE ;
         if XLINK then
           begin
             EXTRN := TRUE ;
             EXTNAME [ 1 ] := '#'
           end (* then *) ;
       end (* with *) ;
     if DEBUG_LEV > 0 then
       WRITELN ( QRR , '% $MAINBLK  0' ) ;
     repeat
       BLOCK ( FSYS , PERIOD , MAINPROG ) ;
       if SY <> PERIOD then
         ERROR ( 21 )
     until SY = PERIOD ;
     WRITELN ( QRR , '#HLT  CALL_RATIO' , CALL_LVL [ TRUE ] : 4 ,
               CALL_LVL [ FALSE ] : 4 , CALL_LVL [ TRUE ] + CALL_LVL [
               FALSE ] : 4 ) ;
     if ERRINX > 0 then
       PRINTERROR ;
     if GET_STAT then
       begin

     (*********************************)
     (* PRINT SYMBOL TABLE STATISTICS *)
     (*********************************)

         WRITELN ( QRR , '&SYT1 ' , FENT_CNT : 1 , ' ' , SF_CNT : 1 ,
                   ' ' , SF_TOT : 1 , ' ' , WE_CNT : 1 , ' ' , RE_CNT :
                   1 , ' ' , WS_CNT : 1 ) ;
         WRITE ( QRR , '&SYT2' ) ;
         for I := 0 to MAXLEVEL do
           WRITE ( QRR , ' ' , PROC_CNT [ I ] : 1 ) ;
         WRITELN ( QRR ) ;
         WRITE ( QRR , '&SYT3' ) ;
         for I := 0 to MAXLEVEL do
           WRITE ( QRR , ' ' , ENT_CNT [ I ] : 1 ) ;
         for I := 0 to MAXLEVEL do
           begin
             WRITELN ( QRR ) ;
             WRITE ( QRR , '&SYT4' ) ;
             for J := 0 to DISPLIMIT do
               WRITE ( QRR , ' ' , LU_CNT [ I , J ] : 1 ) ;
           end (* for *) ;
         for I := 1 to 10 do
           begin
             WRITELN ( QRR ) ;
             WRITE ( QRR , '&SYT5' ) ;
             for J := 1 to 10 do
               WRITE ( QRR , ' ' , WLU_CNT [ I , J ] : 1 ) ;
           end (* for *) ;
       end (* then *) ;
   end (* PROGRAMME *) ;



procedure ENTERSTDTYPES ;

   const INTTYP : STRUCTURE =
         ( INTSIZE , INTSIZE , SCALAR , STANDARD ) ;
         REALTYPE : STRUCTURE =
         ( REALSIZE , REALSIZE , SCALAR , STANDARD ) ;
         CHARTYPE : STRUCTURE =
         ( CHARSIZE , CHARSIZE , SCALAR , STANDARD ) ;
         BOOLTYPE : STRUCTURE =
         ( BOOLSIZE , BOOLSIZE , SCALAR , DECLARED , NIL ) ;
         NILTYPE : STRUCTURE =
         ( PTRSIZE , PTRSIZE , POINTER , NIL ) ;
         TEXTTYPE : STRUCTURE =
         ( 0 , PTRSIZE , FILES , NIL ) ;
         ALFATYPE : STRUCTURE =
         ( ALFALNGTH , CHARSIZE , ARRAYS , NIL , NIL ) ;
         ALFAINX : STRUCTURE =
         ( INTSIZE , INTSIZE , SUBRANGE , NIL , ( TRUE , 1 ) , ( TRUE ,
           ALFALNGTH ) ) ;
         UTYP : IDENTIFIER =
         ( BLANKID , NIL , NIL , NIL , 0 , TYPES ) ;
         UCST : IDENTIFIER =
         ( BLANKID , NIL , NIL , NIL , 0 , KONST , ( TRUE , 1 ) ) ;
         UVAR : IDENTIFIER =
         ( BLANKID , NIL , NIL , NIL , 0 , VARS , ACTUAL , 0 , 0 ) ;
         UFLD : IDENTIFIER =
         ( BLANKID , NIL , NIL , NIL , 0 , FIELD , 0 , NIL ) ;
         UPF : IDENTIFIER =
         ( BLANKID , NIL , NIL , NIL , 0 , PROC , DECLARED , 0 , 0 ,
           NIL , NIL , ACTUAL , FALSE , FALSE , FALSE , '$UNK_PF ' ) ;
         UREC : STRUCTURE =
         ( 1 , 1 , RECORDS , NIL , NIL , 0 , 0 ) ;

   var SP : STP ;

   begin (* ENTERSTDTYPES *)

     (********************)
     (*****************  *)
     (********************)

     NEW ( INTPTR ) ;
     INTPTR -> := INTTYP ;

     (*********)
     (*INTEGER*)
     (*********)

     NEW ( REALPTR ) ;
     REALPTR -> := REALTYPE ;

     (********)
     (*REAL  *)
     (********)

     NEW ( CHARPTR ) ;
     CHARPTR -> := CHARTYPE ;

     (********)
     (*CHAR  *)
     (********)

     NEW ( BOOLPTR ) ;
     BOOLPTR -> := BOOLTYPE ;

     (*********)
     (*BOOLEAN*)
     (*********)

     NEW ( NILPTR ) ;
     NILPTR -> := NILTYPE ;

     (********)
     (*NIL   *)
     (********)

     NEW ( TEXTPTR ) ;
     TEXTPTR -> := TEXTTYPE ;

     (********)
     (*TEXT  *)
     (********)

     with TEXTPTR -> do
       begin
         FILTYPE := CHARPTR ;
         SIZE := CHARSIZE + FILHDRSIZE
       end (* with *) ;
     NEW ( ALFAPTR ) ;
     ALFAPTR -> := ALFATYPE ;

     (********)
     (*ALFA  *)
     (********)

     with ALFAPTR -> do
       begin
         AELTYPE := CHARPTR ;
         NEW ( INXTYPE ) ;
         INXTYPE -> := ALFAINX ;
       end (* with *) ;
     NEW ( UTYPPTR ) ;
     UTYPPTR -> := UTYP ;
     NEW ( UVARPTR ) ;
     UVARPTR -> := UVAR ;
     NEW ( UFLDPTR ) ;
     UFLDPTR -> := UFLD ;
     NEW ( UPRCPTR ) ;
     UPRCPTR -> := UPF ;
     GENLABEL ( UPRCPTR -> . PFNAME ) ;
     NEW ( UFCTPTR ) ;
     UFCTPTR -> := UPF ;
     GENLABEL ( UFCTPTR -> . PFNAME ) ;
     NEW ( SP ) ;
     SP -> := UREC ;
     UFLDPTR -> . OWNER := SP ;
   end (* ENTERSTDTYPES *) ;



procedure ENTSTDNAMES ;

   var CP , CP1 : CTP ;
       I , J : INTEGER ;

   const NA : array [ 1 .. NPDW ] of ALPHA =
         ( 'FALSE       ' , 'TRUE        ' , '            ' ,
           'PAGE        ' , 'GET         ' , 'PUT         ' ,
           'RESET       ' , 'REWRITE     ' , 'READ        ' ,
           'WRITE       ' , 'PACK        ' , 'UNPACK      ' ,
           'NEW         ' , 'RELEASE     ' , 'READLN      ' ,
           'WRITELN     ' , 'MARK        ' , 'TRAP        ' ,
           'EXIT        ' , 'ABS         ' , 'SQR         ' ,
           'TRUNC       ' , 'ROUND       ' , 'ORD         ' ,
           'CHR         ' , 'PRED        ' , 'SUCC        ' ,
           'CLOCK       ' , 'EOF         ' , 'EOLN        ' ,
           'ODD         ' , 'EOL         ' , 'EOT         ' ,
           'TRACE       ' , '            ' , '            ' ,
           '            ' , '            ' , 'INPUT       ' ,
           'OUTPUT      ' , 'PRD         ' , 'PRR         ' ,
           'QRD         ' , 'QRR         ' , 'DATE        ' ,
           'TIME        ' , 'MESSAGE     ' , 'SKIP        ' ,
           'LINELIMIT   ' , 'CARD        ' , 'EXPO        ' ,
           'SIN         ' , 'COS         ' , 'EXP         ' ,
           'SQRT        ' , 'LN          ' , 'ARCTAN      ' ) ;
         XNA : array [ 52 .. 57 ] of array [ 1 .. EXTNAMSZ ] of CHAR =
         ( 'DSIN    ' , 'DCOS    ' , 'DEXP    ' , 'DSQRT   ' ,
           'DLOG    ' , 'DATAN   ' ) ;

   begin (* ENTSTDNAMES *)

     (****************)
     (******         *)
     (****************)

     NEW ( CP , TYPES ) ;

     (****************)
     (*INTEGER       *)
     (****************)

     with CP -> do
       begin
         NAME := 'INTEGER     ' ;
         IDTYPE := INTPTR ;
         KLASS := TYPES
       end (* with *) ;
     ENTERID ( CP ) ;
     NEW ( CP , TYPES ) ;

     (****************)
     (*REAL          *)
     (****************)

     with CP -> do
       begin
         NAME := 'REAL        ' ;
         IDTYPE := REALPTR ;
         KLASS := TYPES
       end (* with *) ;
     ENTERID ( CP ) ;
     NEW ( CP , TYPES ) ;

     (****************)
     (*CHAR          *)
     (****************)

     with CP -> do
       begin
         NAME := 'CHAR        ' ;
         IDTYPE := CHARPTR ;
         KLASS := TYPES
       end (* with *) ;
     ENTERID ( CP ) ;
     NEW ( CP , TYPES ) ;

     (****************)
     (*BOOLEAN       *)
     (****************)

     with CP -> do
       begin
         NAME := 'BOOLEAN     ' ;
         IDTYPE := BOOLPTR ;
         KLASS := TYPES
       end (* with *) ;
     ENTERID ( CP ) ;
     NEW ( CP , TYPES ) ;

     (****************)
     (*CHAR          *)
     (****************)

     with CP -> do
       begin
         NAME := 'TEXT        ' ;
         IDTYPE := TEXTPTR ;
         KLASS := TYPES
       end (* with *) ;
     ENTERID ( CP ) ;
     NEW ( CP , TYPES ) ;

     (****************)
     (*ALFA          *)
     (****************)

     with CP -> do
       begin
         NAME := 'ALFA        ' ;
         IDTYPE := ALFAPTR ;
         KLASS := TYPES
       end (* with *) ;
     ENTERID ( CP ) ;
     NEW ( CP , KONST ) ;

     (****************)
     (*MAXINT        *)
     (****************)

     with CP -> do
       begin
         NAME := 'MAXINT      ' ;
         IDTYPE := INTPTR ;
         KLASS := KONST ;
         VALUES . IVAL := MAXINT ;
       end (* with *) ;
     ENTERID ( CP ) ;
     CP1 := NIL ;
     for I := 1 to 2 do
       begin
         NEW ( CP , KONST ) ;

     (****************)
     (*FALSE,TRUE    *)
     (****************)

         with CP -> do
           begin
             NAME := NA [ I ] ;
             IDTYPE := BOOLPTR ;
             NEXT := CP1 ;
             VALUES . IVAL := I - 1 ;
             KLASS := KONST
           end (* with *) ;
         ENTERID ( CP ) ;
         CP1 := CP
       end (* for *) ;
     BOOLPTR -> . FCONST := CP ;
     NEW ( CP , KONST ) ;

     (***************)
     (*NIL          *)
     (***************)

     with CP -> do
       begin
         NAME := 'NIL         ' ;
         IDTYPE := NILPTR ;
         NEXT := NIL ;
         VALUES . IVAL := 0 ;
         KLASS := KONST
       end (* with *) ;
     ENTERID ( CP ) ;
     for I := 39 to 44 do
       begin
         NEW ( CP , VARS ) ;

     (****************)
     (*INPUT,OUTPUT  *)
     (****************)

         with CP -> do

     (****************)
     (*PRD,PRR       *)
     (****************)

           begin
             NAME := NA [ I ] ;
             IDTYPE := TEXTPTR ;

     (****************)
     (*QRD,QRR       *)
     (****************)

             KLASS := VARS ;
             VKIND := ACTUAL ;
             NEXT := NIL ;
             VLEV := 1 ;
             VADDR := FIRSTFILBUF + ( I - 39 ) * ( FILHDRSIZE + PTRSIZE
                      ) ;
             if I <= 40 then
               if I = 39 then
                 INPUTPTR := CP
               else
                 OUTPUTPTR := CP ;
           end (* with *) ;
         ENTERID ( CP )
       end (* for *) ;
     for I := 45 to 46 do

     (********************)
     (*DATE, TIME        *)
     (********************)

       begin
         NEW ( CP , VARS ) ;
         with CP -> do
           begin
             NAME := NA [ I ] ;
             IDTYPE := ALFAPTR ;
             KLASS := VARS ;
             VKIND := ACTUAL ;
             NEXT := NIL ;
             VLEV := 1 ;
             VADDR := TIMEDATELOC + ( I - 45 ) * ALFALNGTH ;
           end (* with *) ;
         ENTERID ( CP )
       end (* for *) ;
     NEW ( CP , VARS ) ;

     (******************************************************)
     (*OSPARM PTR                                          *)
     (*THE REST OF THIS CODE IS TO DEFINE:                 *)
     (* VAR:  OSPARM: @ RECORD                             *)
     (*                 LENGTH: INTEGER;                   *)
     (*                 STRING: ARRAY[1..64] OF CHAR       *)
     (*                 END;                               *)
     (*                                                    *)
     (******************************************************)

     with CP -> do
       begin
         NAME := 'OSPARM      ' ;
         KLASS := VARS ;
         VKIND := ACTUAL ;
         NEXT := NIL ;
         VLEV := 1 ;
         VADDR := OSPARMLOC ;
         ENTERID ( CP ) ;
         NEW ( IDTYPE , POINTER ) ;
         with IDTYPE -> do
           begin
             SIZE := PTRSIZE ;
             ALN := PTRSIZE ;
             FORM := POINTER ;
             NEW ( ELTYPE , RECORDS ) ;

     (*************************)
     (*TYPE OF THE PARM RECORD*)
     (*************************)

             with ELTYPE -> do
               begin
                 SIZE := INTSIZE + STRGLNGTH * CHARSIZE ;
                 ALN := PTRSIZE ;
                 FORM := RECORDS ;
                 RECVAR := NIL ;
                 FLD_DISP_LEV := - 1 ;
                 NO_FLDS := 2 ;
                 NEW ( FSTFLD , FIELD ) ;
                 with FSTFLD -> do
                   begin
                     NAME := 'LENGTH      ' ;
                     IDTYPE := INTPTR ;
                     FLDADDR := 0 ;
                     KLASS := FIELD ;
                     TOP := TOP + 1 ;

     (**********************************)
     (* FIELDS ENTERED AT HIGHER SCOPE *)
     (**********************************)

                     ENTERID ( FSTFLD ) ;
                     OWNER := CP -> . IDTYPE -> . ELTYPE ;
                     NEW ( NEXT , FIELD ) ;
                     with NEXT -> do
                       begin
                         NAME := 'STRING      ' ;
                         FLDADDR := PTRSIZE ;
                         NEXT := NIL ;
                         KLASS := FIELD ;
                         NEW ( IDTYPE , ARRAYS ) ;
                         with IDTYPE -> do
                           begin
                             SIZE := STRGLNGTH * CHARSIZE ;
                             ALN := CHARSIZE ;
                             FORM := ARRAYS ;
                             AELTYPE := CHARPTR ;
                             NEW ( INXTYPE , SUBRANGE ) ;
                             with INXTYPE -> do
                               begin
                                 FORM := SUBRANGE ;
                                 RANGETYPE := INTPTR ;
                                 MIN . IVAL := 1 ;
                                 MAX . IVAL := STRGLNGTH ;
                               end (* with *) ;
                           end (* with *) ;
                       end (* with *) ;
                     ENTERID ( NEXT ) ;
                     NEXT -> . OWNER := CP -> . IDTYPE -> . ELTYPE ;
                     TOP := TOP - 1 ;
                   end (* with *) ;
               end (* with *) ;
           end (* with *) ;
       end (* with *) ;
     NEW ( CP1 , VARS ) ;

     (***************************************)
     (*PARAMETER OF PREDECLARED FUNCTIONS   *)
     (***************************************)

     with CP1 -> do
       begin
         NAME := BLANKID ;
         IDTYPE := REALPTR ;
         KLASS := VARS ;
         VKIND := ACTUAL ;
         NEXT := NIL ;
         VLEV := 1 ;
         VADDR := LCAFTMST + FPSAVEAREA ;
       end (* with *) ;
     for I := 4 to 34 do

     (****************)
     (*PAGE,GET...TRC*)
     (****************)

       begin
         NEW ( CP , PROC , STANDARD ) ;

     (*******************)
     (*GET,PUT,RESET    *)
     (*******************)

         with CP -> do

     (*******************)
     (*REWRITE,READ     *)
     (*******************)

           begin
             NAME := NA [ I ] ;
             IDTYPE := NIL ;

     (*******************)
     (*WRITE,PACK       *)
     (*******************)

             NEXT := NIL ;
             KEY := I - 4 ;

     (*******************)
     (*UNPACK,PACK      *)
     (*******************)

             if I = 31

     (********)
     (*ODD   *)
     (********)


             then
               KEY := 33 ;
             if I <= 19 then
               KLASS := PROC
             else
               KLASS := FUNC ;
             if I = 34 then
               KLASS := PROC ;
             PFDECKIND := STANDARD ;

     (*******************)
     (*READLN,WRITELN   *)
     (*MARK,RELEASE,TRAP*)
     (*******************)

           end (* with *) ;
         ENTERID ( CP )
       end (* for *) ;
     for I := 52 to 57 do

     (******************************)
     (* SIN,COS,EXP,SQRT,LN,ARCTAN *)
     (******************************)

       begin
         NEW ( CP , FUNC , DECLARED ) ;
         with CP -> do
           begin
             NAME := NA [ I ] ;
             IDTYPE := REALPTR ;
             NEXT := NIL ;
             PRMPTR := CP1 ;
             FWDECL := FALSE ;
             EXTRN := FALSE ;
             FRTRN := TRUE ;
             KLASS := FUNC ;
             PFDECKIND := DECLARED ;
             PFKIND := ACTUAL ;
             PFLEV := 0 ;
             PFNAME := 0 ;
             EXTNAME := XNA [ I ] ;
           end (* with *) ;
         ENTERID ( CP ) ;
       end (* for *) ;
     for I := 47 to 51 do
       begin
         NEW ( CP , PROC , STANDARD ) ;
         with CP -> do
           begin
             NAME := NA [ I ] ;
             IDTYPE := NIL ;
             NEXT := NIL ;
             if I <= 49 then
               KLASS := PROC
             else
               KLASS := FUNC ;
             KEY := I - 12 ;
             PFDECKIND := STANDARD ;
           end (* with *) ;
         ENTERID ( CP ) ;
       end (* for *) ;
     NEW ( CP , PROC , DECLARED ) ;

     (*******************)
     (*SNAPSHOT         *)
     (*******************)

     with CP -> do
       begin
         NAME := 'SNAPSHOT    ' ;
         IDTYPE := NIL ;
         FRTRN := FALSE ;
         FWDECL := FALSE ;
         EXTRN := TRUE ;
         PFLEV := 0 ;
         PFNAME := 0 ;
         KLASS := PROC ;
         PFDECKIND := DECLARED ;
         PFKIND := ACTUAL ;
         EXTNAME := 'SNAPSHOT' ;
         NEXT := NIL ;
       end (* with *) ;
     ENTERID ( CP ) ;
     NEW ( CP -> . PRMPTR , VARS ) ;

     (*******************************)
     (* FIRST PARAMETER OF SNAPSHOT *)
     (*******************************)

     NEW ( CP1 , VARS ) ;

     (********************************)
     (* SECOND PARAMETER OF SNAPSHOT *)
     (********************************)

     with CP1 -> do
       begin
         IDTYPE := INTPTR ;
         KLASS := VARS ;
         VKIND := ACTUAL ;
         NEXT := NIL ;
         VLEV := 1 ;
         VADDR := LCAFTMST + FPSAVEAREA + INTSIZE
       end (* with *) ;
     with CP -> . PRMPTR -> do
       begin
         IDTYPE := INTPTR ;
         KLASS := VARS ;
         VKIND := ACTUAL ;
         NEXT := CP1 ;
         VLEV := 1 ;
         VADDR := LCAFTMST + FPSAVEAREA
       end (* with *) ;
   end (* ENTSTDNAMES *) ;



procedure INITSCALARS ;

   begin (* INITSCALARS *)
     FWPTR := NIL ;
     STMTNEST := 0 ;
     LISTTAG := ' ' ;
     LIST := TRUE ;
     PRCODE := TRUE ;
     PRTERR := TRUE ;
     ERRINX := 0 ;
     CONSTLC := - 1 ;
     HP := FALSE ;
     IC := 0 ;
     INTLABEL := 0 ;
     FILEHEAD := NIL ;
     LC := FIRSTGVAR ;

     (***********************************)
     (*ADR. OF THE FIRST GLOBAL VARIABLE*)
     (* NOTE IN THE ABOVE RESERVATION O *)
     (*F BUFFER STORE FOR TEXT FILES    *)
     (***********************************)

     OLDIC := 0 ;
     IC := 0 ;
     EOL := TRUE ;
     LINECNT := 0 ;
     CH := ' ' ;
     CHCNT := 0 ;
     PAGECNT := 0 ;
     PLCNT := PAGESIZE ;

     (****************************)
     (* GENERATES FIRST HEADLINE *)
     (****************************)

     LMARGIN := 0 ;
     RMARGIN := 80 ;
     BUFEND := 81 ;
     OLDLN := 0 ;
     MWARN := FALSE ;
     LSTOP := '#' ;
     GLOBTESTP := NIL ;
     OPEN_RECORD := NIL ;
     LASTLINELISTED := 0 ;
     PROGNAME := '$MAINBLK    ' ;
     MXINT10 := MAXINT DIV 10 ;
     PROCLAB := 0 ;
     ERRORCNT := 0 ;
     WARNCNT := 0 ;
     ASSEMBLE := FALSE ;
     NESTCOMM := FALSE ;
     ERRKIND := 'E' ;
     SAVEREGS := TRUE ;
     SAVEFPRS := TRUE ;
     DEBUG := TRUE ;
     DEBUG_LEV := 2 ;
     ASSIGN := FALSE ;
     FLIPDEBUG := FALSE ;
     EXTUSED := FALSE ;
     WARNING := TRUE ;
     DOTFLG := FALSE ;
     NOPACKING := FALSE ;
     PACKDATA := FALSE ;
     XLINK := FALSE ;

     (*************************)
     (*GENERATES UNIQUE NAMES *)
     (*************************)

     PRNTTYPHD := NIL ;
     PRNTTYNO := 0 ;
     FRTPARHD := NIL ;
     XLABNO := 0 ;
     GET_STAT := TRUE ;
     ASMVERB := FALSE ;
     CTRCNT := 0 ;
     CTROPTION := FALSE ;
     FENT_CNT := 0 ;
     SF_CNT := 0 ;
     SF_TOT := 0 ;
     WE_CNT := 0 ;
     RE_CNT := 0 ;
     WS_CNT := 0 ;
   end (* INITSCALARS *) ;



procedure INITTABLES ;

   var K : BKT_RNG ;
       I , J : INTEGER ;


   procedure RATORS ;

      var I : INTEGER ;
          CH : CHAR ;

      begin (* RATORS *)
        for CH := ' ' to '9' do
          UPSHIFT [ CH ] := CH ;

        (********)
        (*UPL   *)
        (* NOP  *)
        (*follo *)
        (*wing  *)
        (*stmt, *)
        (* to a *)
        (*void  *)
        (*upshi *)
        (*fting *)
        (* tild *)
        (*e cha *)
        (*r, wh *)
        (*ich   *)
        (*      *)
        (*      *)
        (* "DE" *)
        (*      *)
        (*is in *)
        (* the  *)
        (*range *)
        (* 'a'. *)
        (*.'z': *)
        (* FOR  *)
        (*CH := *)
        (* 'a'  *)
        (*TO 'z *)
        (*' DO  *)
        (*UPSHI *)
        (*FT[CH *)
        (*] :=  *)
        (*CHR(O *)
        (*RD(CH *)
        (*) + 6 *)
        (*4) ;  *)
        (*UPL   *)
        (********)

        for I := 0 to ORDCHMAX do
          SOP [ CHR ( I ) ] := ILLEGCH ;
        for CH := 'A' to 'I' do
          SOP [ CH ] := ATOZCH ;
        for CH := 'J' to 'R' do
          SOP [ CH ] := ATOZCH ;
        for CH := 'S' to 'Z' do
          SOP [ CH ] := ATOZCH ;
        for CH := 'a' to 'i' do
          begin
            SOP [ CH ] := ATOZCH ;
            UPSHIFT [ CH ] := CHR ( ORD ( CH ) + 64 )
          end (* for *) ;

        (********)
        (*UPL   *)
        (********)

        for CH := 'j' to 'r' do
          begin
            SOP [ CH ] := ATOZCH ;
            UPSHIFT [ CH ] := CHR ( ORD ( CH ) + 64 )
          end (* for *) ;

        (********)
        (*UPL   *)
        (********)

        for CH := 's' to 'z' do
          begin
            SOP [ CH ] := ATOZCH ;
            UPSHIFT [ CH ] := CHR ( ORD ( CH ) + 64 )
          end (* for *) ;

        (********)
        (*UPL   *)
        (********)

        for CH := '0' to '9' do
          SOP [ CH ] := NUMCH ;
        SOP [ '"' ] := DQUOTCH ;
        SOP [ CHLBRACE ] := LBRACE ;
        SOP [ '#' ] := SKIPCH ;
        SOP [ '$' ] := DOLLARCH ;
        SOP [ '''' ] := QUOTCH ;
        SOP [ '(' ] := LPARCH ;
        SOP [ ')' ] := RPARCH ;
        SOP [ ',' ] := SPECH ;
        SOP [ '.' ] := DOTCH ;
        SOP [ ':' ] := COLONCH ;
        SOP [ ';' ] := SPECH ;
        SOP [ '@' ] := SPECH ;
        SOP [ '[' ] := SPECH ;
        SOP [ 'Ç' ] := SPECH ;
        SOP [ ']' ] := SPECH ;
        SOP [ '^' ] := SPECH ;
        SOP [ '_' ] := UNDSCH ;
        SOP [ '+' ] := PLUS ;
        SOP [ '-' ] := MINUS ;
        SOP [ '*' ] := MUL ;
        SOP [ '/' ] := RDIV ;
        SOP [ '=' ] := EQOP ;
        SOP [ '<' ] := LTOP ;
        SOP [ '>' ] := GTOP ;
        SOP [ 'Ç' ] := OROP ;
        SOP [ '&' ] := ANDOP ;

        (**************************************************************)
        (* Note: SSY array should be defined as full range of         *)
        (*                                                            *)
        (*         characters, but it's ok as is for now because it i *)
        (*s                                                           *)
        (*         currently indexed only for specific characters.    *)
        (*                                                            *)
        (*         It it were indexed by higher chars (e.g. backslash *)
        (* or                                                         *)
        (*         curly brackets) in the future, its definition woul *)
        (*d                                                           *)
        (*         have to change. Currently, SPECH does not include  *)
        (*any                                                         *)
        (*         of these higher chars. - D.E. 02feb2007            *)
        (**************************************************************)

        SSY [ '+' ] := ADDOP ;
        SSY [ '-' ] := ADDOP ;
        SSY [ '*' ] := MULOP ;
        SSY [ '/' ] := MULOP ;
        SSY [ '(' ] := LPARENT ;
        SSY [ ')' ] := RPARENT ;
        SSY [ CHR ( 173 ) ] := LBRACK ;
        SSY [ CHR ( 189 ) ] := RBRACK ;
        SSY [ ',' ] := COMMA ;
        SSY [ ':' ] := COLON ;
        SSY [ 'Ç' ] := ADDOP ;
        SSY [ '&' ] := MULOP ;
        SSY [ '<' ] := RELOP ;
        SSY [ '>' ] := RELOP ;
        SSY [ '=' ] := RELOP ;
        SSY [ '@' ] := ARROW ;
        SSY [ CHR ( 74 ) ] := ARROW ;
        SSY [ '^' ] := NOTSY ;
        SSY [ ';' ] := SEMICOLON ;
        SSY [ '.' ] := PERIOD ;
      end (* RATORS *) ;


   begin (* INITTABLES *)
     RATORS ;
     for I := 0 to MAXERRLOG do
       ERRLOG [ I ] := [ ] ;

     (*****************)
     (*CLEAR ERROR LOG*)
     (*****************)

     for K := 0 to MAX_BKT do
       BUCKET [ K ] := NIL ;
     for I := 0 to MAXLEVEL do
       begin
         PROC_CNT [ I ] := 0 ;
         ENT_CNT [ I ] := 0 ;
         for J := 0 to DISPLIMIT do
           LU_CNT [ I , J ] := 0 ;
       end (* for *) ;
     for I := 1 to 10 do
       for J := 1 to 10 do
         WLU_CNT [ I , J ] := 0 ;
     PROC_CNT [ 1 ] := 1 ;
   end (* INITTABLES *) ;



begin (* HAUPTPROGRAMM *)

  (************)
  (*INITIALIZE*)
  (************)
  (************)

  INITSCALARS ;
  INITTABLES ;

  (******************************************)
  (*ENTER STANDARD NAMES AND STANDARD TYPES:*)
  (******************************************)
  (******************************************)

  LEVEL := 0 ;
  TOP := 0 ;
  with DISPLAY [ 0 ] do
    begin
      OCCUR := BLCK ;
      FLABEL := NIL ;
    end (* with *) ;
  ENTERSTDTYPES ;
  ENTSTDNAMES ;
  TOP := 1 ;
  LEVEL := 1 ;
  with DISPLAY [ 1 ] do
    begin
      OCCUR := BLCK ;
      FLABEL := NIL ;
    end (* with *) ;
  GET_STAT := FALSE ;

  (*************************************************)
  (*set options passed as parameter to the compiler*)
  (*************************************************)
  (*************************************************)

  if OSPARM <> NIL then
    with OSPARM -> do
      begin
        CH

  "**********"
  "LINEBUF[1]"
  "**********"


        := CHLBRACE ;
        LINEBUF [ 2 ] := '$' ;
        if LENGTH > 64 then
          LENGTH := 64 ;
        for CHCNT := 1 to LENGTH do
          LINEBUF [ CHCNT + 2 ] := STRING [ CHCNT ] ;

  (*********************************************************)
  (*THE REST OF THE LINE DOES NOT HAVE TO BE CLEARED BUT...*)
  (*********************************************************)

        for CHCNT := LENGTH to 77 do
          LINEBUF [ CHCNT + 3 ] := ' ' ;
        LINEBUF [ LENGTH + 3 ] := CHRBRACE ;
        LINEBUF [ LENGTH + 4 ] := '#' ;
        EOL := FALSE ;
        CHCNT := 1 ;
        LASTCOL := LENGTH + 3 ;
      end (* with *) ;

  (**********)
  (*COMPILE:*)
  (**********)
  (**********)

  CTIME := CLOCK ( 0 ) ;

  (*****************************************)
  (* FIRST HEADLINE PRINTED BY 'ENDOFLINE' *)
  (*****************************************)

  INSYMBOL ;
  PROGRAMME ( BLOCKBEGSYS + STATBEGSYS - [ CASESY ] ) ;

  (***********************************)
  (* PRINT POST COMPILATION MESSAGES *)
  (***********************************)

  GOODBYE ;
end (* HAUPTPROGRAMM *) .
++FILE PASCALN.OLDCOMP.SOURCE                       MEMB PCOD1979 EXT PAS HEX -
(*$D-,N+*)
PROGRAM PCODE_TRANSLATOR(INPUT, OUTPUT, PRD, PRR) ;



  (********************************************************************
   *                                                                  *
   *                                                                  *
   *                                                                  *
   *   P_CODE (POST) PROCESSOR                                        *
   *   -----------------------                                        *
   *                                                                  *
   *                                                                  *
   *   COPYRIGHT 1976, STANFORD LINEAR ACCELERATOR CENTER.            *
   *                                                                  *
   *                                                                  *
   *   THIS IS A TRANSLATOR FOR THE MODIFIED  P-CODE  GENERATED  BY   *
   *   THE  SLAC  PASCAL   COMPILER.  THE TRANSLATOR TRANSLATES THE   *
   *   P_CODE INTO IBM/370 ASSEMBLY  LANGUAGE  OR  STANDARD  OS/370   *
   *   OBJECT  MODULE  WHICH  COULD BE RUN ON THE 370 USING A SMALL   *
   *   I/O PACKAGE.  ALSO  THE  IMMEDIATE  TARGET  MACHINE  OF  THE   *
   *   TRANSLATOR  IS  THE 360/370 COMPUTERS, THE MACHINE DEPENDENT   *
   *   MODULES IN THE PROGRAM ARE  RELATIVELY  ISOLATED  SUCH  THAT   *
   *   CONVERSIONS  FOR  OTHER  REGISTER  ORIENTED  TARGET MACHINES   *
   *   SHOULD BE STRAIGHTFORWARD.                                     *
   *                                                                  *
   *   REFER TO THE 'THE PASCAL P COMPILER:  IMPLEMENTATION  NOTES,   *
   *   U.  AMMANN, K.  JENSEN, H.  NAGELI, AND K.  NORI, DEC.  74.'   *
   *   FOR  THE DEFINITION OF THE P_MACHINE AND THE P SUBSET OF THE   *
   *   PROGRAMMING LANGUAGE "PASCAL".                                 *
   *                                                                  *
   *   FOR A MORE DETAILED DESCRIPTION OF  THE  P_MACHINE  AND  ITS   *
   *   INSTRUCTION   SET   REFER   TO   THE   P_INTERPRETER  UNDER:   *
   *   'WYL.CG.PAS.LIB(PINTERP)' (ON THE TRIPLEX SYSTEM AT SLAC)      *
   *                                                                  *
   *   -GLOBAL, PROCEDURE LEVEL, INFORMATION SUCH AS SIZE AND  CALL   *
   *   PATTERNS  ARE  (OPTIONALLY) READ IN PARALLEL WITH THE P_CODE   *
   *   AND MAY BE USED  FOR  MORE  EFFICIENT  PROCEDURE  ENTRY/EXIT   *
   *   IMPLEMENTATION.                                                *
   *                                                                  *
   *   -P_INSTRUCTIONS WITH AN IMPLIED GLOBAL  (DATA)  LEVEL  (I.E.   *
   *   LAO, LDO, SRO) ARE ELIMINATED FROM THE P_MACHINE INSTRUCTION   *
   *   SET.   THESE INSTRUCTIONS ARE REPLACED BY THEIR MORE GENERAL   *
   *   COUNTER-PARTS (I.E.  LDA, LOD, STR) AND THE 'LOCAL'/'GLOBAL'   *
   *   ATTRIBUTE OF THE REFERENCE IS  EASILY  DETERMINED  FROM  THE   *
   *   CONTEXT.                                                       *
   *                                                                  *
   *   -THE NAME, AS WELL AS  COMPILATION  DATE  AND  TIME  OF  THE   *
   *   SOURCE  PROGRAM  ARE  RECORDED  AT  THE  ENTRY  POINT OF THE   *
   *   'MAINBLK' IN  THE  OBJECT  CODE.   THIS  PROVIDES  A  UNIQUE   *
   *   SIGNATURE  FOR  EACH OBJECT MODULE AND SIMPLIFIES MATCHING A   *
   *   SOURCE PROGRAM LISTING AND ITS CORRESPONDING OBJECT CODE.      *
   *                                                                  *
   *                                                                  *
   *   -THE ERROR MESSAGES ISSUED  BY  THE TRANSLATOR  ARE  USUALLY   *
   *   ACCOMPANIED  BY THE  APPROXIMATE LINE  NUMBER  OF THE SOURCE   *
   *   STATEMENT.    THESE NUMBERS APPEAR ON THE LEFT OF THE SOURCE   *
   *   PROGRAM LISTING AND THE ERROR SHOULD BE LOCATED BETWEEN  THE   *
   *   STATEMENT  WITH THE GIVEN NUMBER AND THAT NUMBER+1.    THESE   *
   *   ERROR CODES SHOULD BE INTERPRETED ACCORDING TO THE FOLLOWING   *
   *   TABLE:                                                         *
   *                                                                  *
   *                                                                  *
   *                                                                  *
   *   202- STRING TOO LONG (LOGER THAN 255 CHARACTERS)               *
   *        --> REDUCE THE VALUE FOR 'MAXSTRLEN' IN THE COMPILER.     *
   *                                                                  *
   *   253- PROCEDURE TOO LONG (LARGER THAN 8K BYTES).                *
   *        --> DIVIDE (THE PROCEDURE) AND CONQUER.                   *
   *                                                                  *
   *   254- TOO MANY LONG (STRING) CONSTANTS.                         *
   *        --> RECOMPILE THE POST_PROCESSOR WITH  A  LARGER  VALUE   *
   *        FOR STRCNT.                                               *
   *                                                                  *
   *   256- TOO MANY PROCEDURES/FUNCTIONS REFERENCED IN THIS PROC.    *
   *        --> RECOMPILE THE POST_PROCESSOR WITH  A  LARGER  VALUE   *
   *        FOR PRCCNT.                                               *
   *                                                                  *
   *   259- EXPRESSION TOO COMPLICATED.                               *
   *        -->  SIMPLIFY  THE  EXPRESSION  BY  REARRANGING  AND/OR   *
   *        BREAKING.                                                 *
   *                                                                  *
   *   263- TOO MANY (COMPILER GENERATED) LABELS IN THIS PROCEDURE.   *
   *        --> RECOMPILE THE POST_PROCESSOR WITH  A  LARGER  VALUE   *
   *        FOR LBLCNT.                                               *
   *                                                                  *
   *   281- TOO MANY INTEGER CONSTANTS IN THIS PROCEDURE.             *
   *        --> RECOMPILE THE POST_PROCESSOR WITH  A  LARGER  VALUE   *
   *        FOR INTCNT.                                               *
   *                                                                  *
   *   282- TOO MANY DOUBLE WORD (REAL,SET) CONSTANTS IN THIS PROC.   *
   *        --> RECOMPILE THE POST_PROCESSOR WITH  A  LARGER  VALUE   *
   *        FOR DBLCNT.                                                *
   *                                                                  *
   *   300- DIVIDE BY ZERO (RESULT OF CONSTANT PROPAGATION).          *
   *        --> FIX UP  THE  (CONSTANT)  EXPRESSION  EVALUATING  TO   *
   *        ZERO.                                                     *
   *                                                                  *
   *                                                                  *
   *   501- ILLEGAL/UNDEFINED P_INSTRUCTION.                          *
   *        --> FIX UP THE INPUT TO THE POST_PROCESSOR.               *
   *                                                                  *
   *   502- ILLEGAL/UNDEFINED STANDARD PROCEDURE CALL.                *
   *        --> FIXUP THE INPUT TO THE POST_PROESSOR.                 *
   *                                                                  *
   *   503- THE CONTENTS OF 'INPUT' AND 'PRD' FILES DON'T AGREE.      *
   *        -->  FIX  THE  JCL  AND/OR  THE  'QRR'  OUTPUT  OF  THE   *
   *        COMPILER.                                                 *
   *   504- SIZE OF THE ARRAY ELEMENT TOO LARGE.                      *
   *        --> REORDER THE DIMENSIONS OF THE ARRAY (SO THAT THE      *
   *        THE LARGER DIMENTIONS ARE FIRST) OR REDUCE THE RANGE      *
   *        OF THE LOW ORDER (LAST) INDICES.                          *
   *                                                                  *
   *                                                                  *
   *                                                                  *
   *                                                                  *
   *   THE FOLLOWING ERRORS NORMALLY INDICATE AN  INCNSISTANCY IN     *
   *   THE COMPILER AND OR THE POST_PROCESSOR.                        *
   *                                                                  *
   *                                                                  *
   *   601- TYPE CONFLICT OF OPERANDS IN THE P_PROGRAM.               *
   *                                                                  *
   *   602- OPERAND SHOULD BE OF TYPE 'ADR'.                          *
   *                                                                  *
   *   604- ILLEGAL TYPE FOR RUN TIME CHECKING.                       *
   *                                                                  *
   *   605- OPERAND SHOULD BE OF TYPE 'BOOL'.                         *
   *                                                                  *
   *   606- UNDEFINED P_INSTRUCTION CODE.                             *
   *                                                                  *
   *   607- UNDEFINED STANDARD PROCEDURE NAME.                        *
   *                                                                  *
   *   608- DISPLACEMENT FIELD OUT OF RANGE                           *
   *                                                                  *
   *   609- SMALL PROC IS LARGER THAN 4K, RESET SHRT_PROC = 350       *
   *                                                                  *
   *   611- BAD INTEGER ALIGNMENT.                                    *
   *                                                                  *
   *   612- BAD REAL ALIGNMENT.                                       *
   *                                                                  *
   *   613- BAD REAL CONSTANT.                                        *
   *                                                                  *
   *   614- THE PRE_PASS FILE (PRD) IS INCONSISTANT.                  *
   *                                                                  *
   *                                                                  *
   *   THIS PROGRAM SHOULD NOT BE COMPILED WITH THE 'D+' OPTION.      *
   *                                                                  *
   *                                                                  *
   *                                                                  *
   *                                                                  *
   *                                                                  *
   *                           S. HAZEGHI,                            *
   *                                                                  *
   *                           COMPUTATION RESEARCH GROUP             *
   *                           STANFORD LINEAR ACCELARATOR CENTER     *
   *                           STANFORD, CA. 94305.                   *
   *                                                                  *
   *                                                                  *
   *                                                                  *
   *         DATE OF LAST UPDATES:                                    *
   *                                                                  *
   *             JULY 18, 76.                                         *
   *             NOV. 10, 76.                                         *
   *             JAN. 26, 77.                                         *
   *             APR. 15, 77.                                         *
   *             JUNE 22, 77.                                         *
   *             SEP.  7, 77.                                         *
   *             AUG.  4, 78.                                         *
   *             JULY 11, 79.                                         *
   *                                                                  *
   *                                                                  *
   *                                                                  *
   ********************************************************************)




CONST
      VERSION  = 'Oct.-79.';
      MXADR    =  65535 ;
      SHRTINT  =   4095 ;
      HALFINT  =  32700 ;
      STKDPTH  =     15 ;
      MXLVL    =     16 ;
      IDLNGTH  =     12 ;  (*LENGTH OF IDENTIFIERS                            *)
      RGCNT    =      9 ;  (*REGISTER COUNT                                   *)
      FPCNT    =      6 ;  (*FLOATING POINT REG. COUNT                        *)
      OPCNT    =     70 ;  (* OPCODE COUNT                                    *)
"NH"  SPCNT    =     40 ;  (* STANDARD PROC. CNT.                             *)
      GBR      =     12 ;  (*GLOBAL BASE REGITER                              *)
      LBR      =     13 ;  (*LOCAL    "     "                                 *)
      JREG     =     15 ;  (*JUMP (BRANCH) REGISTER                           *)
      RTREG    =     14 ;  (*RETURN ADDR. REGISTER                            *)
      TRG0     =      0 ;  (*PARAMETER REGISTER                               *)
      FPR0     =      0 ;  (*FLOATING POINT REGISTER 0                        *)
      TRG1     =      1 ;  (*TEMPORARY VALUE/BASE REGISTERS                   *)
      TRG13    =     13 ;  (*SAVE AREA/LOCAL STACK FRAME                      *)
      TRG14    =     14 ;
      TRG15    =     15 ;
      TRG9     =      9 ;
      PBR1     =     10 ;
      PBR2     =     11 ;
      FILADR   =      9 ;  (*FILE ADDRESS REGISTER                            *)
      MXSLNGTH =     72 ;
      HDRLNGTH =     32 ;  (*LENGTH OF PROGRAM HEADING                        *)

      ADRSIZE  =      4 ;  CHARSIZE = 1 ;  BOOLSIZE = 1 ;
      INTSIZE  =      4 ;  REALSIZE = 8 ;  SETSIZE  = 8 ;


                          (* LAYOUT OF THE 'GLOBAL' STACK FRAME:              *)

      NEWPTR   =     72 ; (* NEWPTR , OFFSET FROM BOTTOM OF RUNTIME STACK     *)
      HEAPLMT  =     76 ; (* HEAP LIMIT PTR, OFFSET FROM BOTTOM OF STACK      *)
      DYNRUNC  =      0 ; (* # OF COUNTERS , FIELD OFFSET FROM HEAPLMT        *)
      DYN2LEN  =     16 ; (* LENGTH OF THE DYN. INFO. AREA AT THE END OF HEAP *)
      FNCRSLT  =     72 ; (* FUNCTION RESULT LOCATION, OFFSET FROM MP         *)

      DISPLAY  =     80 ; (* DISPLAY REGS, OFFSET FROM BOTTOM OF RUNTIME STK  *)
      LCAFTMST =     80 ; (* SIZE OF THE PROCEDURE LINKAGE AREA               *)
      FPRSAREA =     80 ; (* FLOATING PT. REGS SAVE AREA, (OPTIONAL SAVE)     *)
      FPSIZE   =     32 ; (* LENGTH OF FPR SAVE AREA                          *)

      FL1      =    120 ; (*GLOBAL LOCATIONS USED FOR FIX-FLOAT CONVERSIONS   *)
      FL2      =    128 ;    "                                       "
      FL3      =    136 ;    "                                       "
      FL4      =    144 ;    "                                       "

      INXCHK   =    152 ; (* ADDRESS OF RUNTIME CHECK ROUTINES                *)
      RNGCHK   =    164 ;
      PRMCHK   =    176 ;
      PTRCHK   =    188 ;
      PTACHK   =    200 ;
      SETCHK   =    212 ;
      STKCHK   =    224 ;
      XXXCHK   =    236 ;

      FILEBUFS =    248 ; (* INPUT, OUTPUT, PRD,.... BUFFERS                  *)
      CLEARBUF =    272 ; (* PRESET BUFER TO ERASE MEMORY WITH ITS CONTENTS   *)
      PASDATE  =    280 ; (* PREDEFINED DATE VARIABLE                         *)
      PASTIME  =    290 ; (* PREDEFINED TIME VARIABLE                         *)
      OSPRM    =    300 ;
      FRSTGVAR =    304 ; (* FIRST GLOBAL VAR, SHOULD BE A MULTIPLE OF 8      *)

                          (* VARIOUS TABLE SIZES AND MISC. CONSTATNTS         *)

      HTSIZE   =    139 ; (* HASH TABLE SIZE                                  *)

      INTCNT   =    200 ; (* # OF DISTINCT INT'S REFERENCED IN A PROC.        *)
      DBLCNT   =    100 ; (* # OF DISTINCT REALS/SETS REF. IN A PROC.         *)
      STRCNT   =    200 ; (* # OF CHAR STRINGS REF. IN A PROC.                *)
      PRCCNT   =     45 ; (* # OF PROC'S REFERENCED IN ONE CSECT              *)
      LBLCNT   =    220 ; (* # OF LABELS IN A CSECT                           *)

      MXCODE   =   4092 ; (* MAX OBJECT CODE SIZE (APPROX. 8K BYTES)          *)
      MXCODE1  =   4093 ;
      MXLNP    =    400 ; (* SIZE OF LINE NUMBER TABLE                        *)
      ENDCODE  =   4500 ; (* MXCODE+MXLN, LINE # TABLE IS NOT A PART OF CODE  *)

      LESCND   =      4 ;         LEQCND = 13 ;  (* CONDITION CODE SYMBOLS    *)
      GRTCND   =      2 ;         GEQCND = 11 ;
      EQUCND   =      8 ;         NEQCND =  7 ;
      ANYCND   =     15 ;         NOCND  =  0 ;
      TRUCND   =      1 ;         FLSCND =  8 ;

      SHRT_PROC=    550 ; (* LIMIT VALUE FOR A PROC. TO BE CONSIDERED SMALL   *)


     (* OPCODE TABLES  (P-OPCODES / P-STANDARD PROCS / 370-OPCODES )          *)

      PCTS =  0 ;           " PLDO =  1 ; "  PCTI =  1 ;
      PLOD =  2 ;           " PSRO =  3 ; "  PSTR =  3 ;
      PLDA =  4 ;           " PLAO =  5 ; "  PLOC =  5 ;
      PSTO =  6 ;             PLDC =  7 ;
      PLAB =  8 ;             PIND =  9 ;
      PINC = 10 ;             PMST = 11 ;
      PCUP = 12 ;             PENT = 13 ;
      PRET = 14 ;             PCSP = 15 ;
      PIXA = 16 ;             PEQU = 17 ;
      PNEQ = 18 ;             PGEQ = 19 ;
      PGRT = 20 ;             PLEQ = 21 ;
      PLES = 22 ;             PUJP = 23 ;
      PFJP = 24 ;             PXJP = 25 ;
      PCHK = 26 ;             PNEW = 27 ;
      PADI = 28 ;             PADR = 29 ;
      PSBI = 30 ;             PSBR = 31 ;
      PSGS = 32 ;             PFLT = 33 ;
      PFLO = 34 ;             PTRC = 35 ;
      PNGI = 36 ;             PNGR = 37 ;
      PSQI = 38 ;             PSQR = 39 ;
      PABI = 40 ;             PABR = 41 ;
      PNOT = 42 ;             PAND = 43 ;
      PIOR = 44 ;             PDIF = 45 ;
      PINT = 46 ;             PUNI = 47 ;
      PINN = 48 ;             PMOD = 49 ;
      PODD = 50 ;             PMPI = 51 ;
      PMPR = 52 ;             PDVI = 53 ;
      PDVR = 54 ;             PMOV = 55 ;
      PLCA = 56 ;             PDEC = 57 ;
      PSTP = 58 ;             PSAV = 59 ;
      PRST = 60 ;             PCHR = 61 ;

      PORD = 62 ;             PDEF = 63 ;
      PRND = 64 ;
"NH"  PCRD = 65 ;             PXPO = 66 ;
"NH"  PBGN = 67 ;             PEND = 68 ;

      PGET =  0 ;             PPUT =  1 ;
      PRES =  2 ;             PRLN =  3 ;
      PREW =  4 ;             PWLN =  5 ;
      PWRS =  6 ;             PELN =  7 ;
      PWRI =  8 ;             PWRR =  9 ;
      PWRC = 10 ;             PRDI = 11 ;
      PRDR = 12 ;             PRDC = 13 ;
      PSIN = 14 ;             PCOS = 15 ;
      PEXP = 16 ;             PLOG = 17 ;
      PSQT = 18 ;             PATN = 19 ;
      PEOF = 20 ;             PXIT = 21 ;
      PRDS = 22 ;             PTRP = 23 ;
      PSIO = 24 ;             PEIO = 25 ;
      PCLK = 26 ;             PFDF = 27 ;
      PPAG = 28 ;             PNUL = 29 ;
      PRDB = 30 ;             PWRB = 31 ;
"NH"  PSKP = 32 ;             PLIM = 33 ;
"NH"  PMSG = 34 ;
      PCTR = 35 ;            (*INTERNALLY GENERATED CSP  TO CLEAR RUN COUNTS*)

                                   XLTR = "0 " 18  ;
      XL   = "1 " 88  ;            XLH  = "2 " 72  ;
      XLD  = "3 " 104 ;            XLR  = "4 " 24  ;
      XLDR = "5 " 40  ;            XIC  = "6 " 67  ;
      XLM  = "7 " 152 ;            XLA  = "8 " 65  ;
      XLPR = "9 " 16  ;            XLCR = "10" 19  ;
      XLPDR= "19" 32  ;            XLCDR= " ?" 35  ;
      XLTDR=      34  ;

      XA   = "11" 90  ;            XAH  = "12" 74  ;
      XAD  = "13" 106 ;            XAR  = "14" 26  ;
      XADR = "15" 42  ;            XSDR = "16" 43  ;
      XMDR = "17" 44  ;            XDDR = "18" 45  ;
      XAW  = "20" 110 ;

      XST  = "21" 80  ;            XSTD = "22" 96  ;
      XSTH = "23" 64  ;            XSTC = "24" 66  ;
      XSTM = "25" 144 ;

      XMVC = "27" 210 ;            XMVCL= "28" 14  ;
      XMVI = "29" 146 ;

      XS   = "31" 91  ;            XSH  = "32" 75  ;
      XSD  = "33" 107 ;            XSR  = "34" 27  ;

      XN   = "35" 84  ;            XNR  = "36" 20  ;
      XO   = "37" 86  ;            XXOR  = "38" 22  ;
      XX   = "39" 87  ;            XXR  = "40" 23  ;

      XM   = "41" 92  ;            XMH  = "42" 76  ;
      XMD  = "43" 108 ;            XMR  = "44" 28  ;

      XD   = "47" 93  ;
      XDD  = "49" 109 ;            XDR  = "50" 29  ;

      XBCR = "51" 7   ;            XBC  = "52" 71  ;
      XBCTR= "53" 6   ;            XBCT = "54" 70  ;
      XBALR= "55" 5   ;            XBAL = "56" 69  ;

      XC   = "57" 89  ;            XCR  = "58" 25  ;
      XTM  = "59" 145 ;
      XCLC = "60" 213 ;            XCLCL= "  "  15 ;

      XSLA = "61" 139 ;            XSLDA= "62" 143 ;
      XSRA = "63" 138 ;            XSRDA= "64" 142 ;
      XSLL = "65" 137 ;            XSLDL= "66" 141 ;
      XCD  = "67" 105 ;            XCDR = "68" 41  ;



"CONST" SMX_HIGHT    = 400;                                               ####
                                                                          ####


TYPE  DATATYPE    = (BOOL,CHRC,ADR,INT,PSET,REEL,PROC,STRG,INX,
                     FORT,FINT,FBOOL,FREAL,NON);
      BETA        = ARRAY[1..3] OF CHAR ;
      STRNG       = PACKED ARRAY [1..MXSLNGTH] OF CHAR ;
      ALFA        = PACKED ARRAY [1..8] OF CHAR ;
      IDTYPE      = PACKED ARRAY [1..IDLNGTH] OF CHAR ;
      ADRRNG      = 0..MXADR ;
      OPRNG       = 0..OPCNT ;    (* OPCODE RANGE                             *)
      SPRNG       = 0..SPCNT ;    (* STANDARD PROCEDURE CODE RANGE            *)
      LVLRNG      = 0..MXLVL ;
      RGRNG       = LVLRNG ;      (* REGISTER NUMBER RANGE                    *)
      SETRNG      = SET OF 0..63 ;
      BYTE        = 0..255 ;
      LINE_NUM    = 0..10000 ;
      STKPTR      = 0..STKDPTH ;  (* POINTER TO THE COMPILE_TIME STACK        *)
      LVLDSP      = RECORD LVL: LVLRNG ; DSPLMT: INTEGER  END ;
      BANK        = (RGS,MEM,NEITHER) ;    (*WHERE ABOUT OF THE OPERAND       *)
      SPTR        = @STRNG;
      ICRNG       = 0..MXCODE1;   (* PROGRAM COUNTER RANGE                    *)
      LBLRNG      = -1..LBLCNT;   (* RANGE OF P_COMPILER GENERATED LABELS     *)
      STRLRNG     = 0..MXSLNGTH;
      POSINT      = 0..214748360 ;

      PLABEL      = RECORD
                    NAM : ALFA ;
                    LEN : 0.. IDLNGTH
                    END ;

      DATUM       = RECORD
                  " STKADR: ADRRNG ;"
                    FPA   : LVLDSP ;
                    PCNST : SETRNG ;
                    RCNST : REAL ;
                    SCNSTL : 0..MXSLNGTH ; SCNST : @STRNG ;
                    DTYPE: DATATYPE ;
                    VRBL, DRCT : BOOLEAN ;

                    CASE VPA: BANK OF

                       RGS: (RGADR: RGRNG) ;
                       MEM: (MEMADR: LVLDSP)

                    END ;


VAR   OPC, OLDOPC:     OPRNG ;     (* CURRENT/OLD INST. OPCODE                *)
      CSP, OLDCSP:     SPRNG ;     (* CURRENT STND. PROC. CODE                *)
      NMCDE, EMPTY:    BETA ;      (* CURRENT (SYMBOLIC) PCODE /CSP NAME      *)
      OP_SP :          BOOLEAN ;   (* P INSTR/SP SWITCH                       *)
      INIT:    BOOLEAN ;           (* INITIALIZATION PHASE FLAG               *)
      CH:      CHAR ;              (* CURRENT INPUT CHARACTER                 *)
      BVAL:    BOOLEAN ;
      CHVAL:   CHAR ;
      IVAL:    INTEGER ;
      RVAL:    REAL ;
      PSVAL:   SETRNG ;
      STRPTR:  SPTR ;
      SVAL :   STRNG ;
      SLNGTH :  0..MXSLNGTH ;
      CURLVL:  LVLRNG ;            (* CURRENT PROC. STATIC LEVEL              *)
      TOP :    STKPTR ;            (* TOP OF EXPRESSION STACK                 *)
      LASTLN,  NXTLNP,
      LASTPC,  LASTPCDIF : INTEGER ;
      LBL1, LBL2, LBL3,
      SEGSZE : PLABEL ;            (* LEFT AND RIGHT LABELS OF INSTRUCTIONS   *)
      OPNDTYPE: DATATYPE ;         (* TYPE OF OPERAND OF INSTRUCTION          *)
      P, Q: INTEGER ;              (* P_Q FIELDS OF INSTRUCTION               *)
      SP     : ADRRNG ;            (* MEMORY STACK POINTER, NOT USED          *)
      LCAFTSAREA : ADRRNG ;        (* FIRST LOC. AFTER PROC. SAVE AREA        *)
      CALSTK : ARRAY[0..4] OF
                         STKPTR ;  (* STACKING OF PARM_LIST WITHIN PARM_LIST  *)
      CSTOP  : 0..4 ;              (* TOP OF ABOVE STACK                      *)
      FILECNT : 0..2 ;             (* COUNT OF ACTIVE FILE ADDRESSES          *)
      NXTRG, TXRG: RGRNG ;         (* AQUIRED REGISTERS                       *)

      ROUNDFLG,                    (* KLUDGE, ROUND/TRUNC FLAG                *)
      FILREGACTIVE,                (* FILE ADDRESS REG. ACTIVE                *)
      CSPREGACTIVE,                (* I/O REGISTERS ACTIVE                    *)
      CLEAR_REG, NEG_CND,          (* CLEAR BEFORE LOADING THE REG.           *)
      SAVERGS, SAVEFPRS,
      DEBUG, OS_STYLE, CASE_FLAG,
      TRACE, NEWLINE, FLIPDEBUG,
      RUNPROFILE,                  (* VARIOUS OPTIONS                         *)
      ASM,                         (* ASSEMBLY/OBJECT CODE FLAG               *)
      ASMVERB,                     (* VERBOSE ASSEMBLY, OUTPUT TABLES         *)
      GET_STAT :  BOOLEAN ;        (* TO COLLECT STACK_DEPTH STATISTICS *)####
      CURLINE : LINE_NUM ;         (* CURRENT SOURCE LINE NUMBER              *)
     "NXTLOC  : ICRNG ;  "         (* CURRENT VAL OF P_INS_CNTR MOD 20        *)
      MDTAG :   OPRNG ;            (* MULTIPLY/DIVIDE TAG                     *)
      HEAPMARK : @INTEGER ;
      ZEROBL :   LVLDSP    ;       (* TO CLEAR BASE ,DISPLACEMENT FIELDS      *)
     "TOTALPCODE,"
      TOTALBYTES,
      ERRORCNT :  INTEGER ;        (* TOTAL ERROR COUNT, ALSO RETURN CODE     *)
      S370CNT :   INTEGER ;        (* COUNT OF 370-ONLY INSTRUCTIONS GENERATED*)

      I_S_R   : RECORD             (* SET <=> INTEGER <=> REAL, 370 IMPL.ONLY *)
                DUMMY : REAL    ;  (* DOUBL WORD ALIGNMENT                    *)
                CASE (*TAG:*) INTEGER OF
                     1:   (I1: INTEGER; I2: INTEGER) ;
                     2:   (S: SETRNG) ;
                     3:   (R: REAL )
                END ;

      TYPCDE: ARRAY ['A'..'Z'"CHAR"] OF DATATYPE ; (* ENCODING OF TYPE FIELD *)
      STK:   ARRAY [STKPTR] OF DATUM ;       (* EXPRESSION STACK              *)
      PTBL: ARRAY [OPRNG] OF BETA ;          (* P_INSTRUCTION TABLE           *)
      CSPTBL: ARRAY [SPRNG] OF BETA ;        (*STND. PROC. TABLE              *)
      AVAIL:   ARRAY [0..RGCNT] OF BOOLEAN ; (*AVAILABLE REGISTERS            *)
      AVAILFP: ARRAY [0..FPCNT] OF BOOLEAN ; (* AVAIL. F.P. REGS              *)

      INVBRM:  ARRAY [PEQU..PLES] OF PEQU..PLES ; (* INV. MAP OF REL. OPCODES *)
      BRMSK:   ARRAY [PEQU..PLES] OF 0..15 ;      (* 370 CONDITION CODES      *)
      BRCND : -1..15 ;                            (* ACTIVE BRANCH MASK       *)
      TIMER : POSINT ;

      HTBL: ARRAY [0..HTSIZE] OF                  (* HASH TABLE, INST./PROCS *)
                RECORD
                NAME: BETA ;

                CASE "KIND:" BOOLEAN OF

                  FALSE: (OPCDE: OPRNG) ;
                  TRUE : (SPCDE: SPRNG)

                END ;

  (* PRE-PASS (PRD FILE) INFORMATION                                          *)

  PROC_SIZE  : ICRNG ;
  DATA_SIZE  : ADRRNG ;
  CALL_CNT   : 0..50 ;
  CALL_HIGHER, LARGE_PROC, LARGE_DFRAME, PRE_PASS : BOOLEAN ;


  (* POINTERS TO LAST ELEMENTS OF 'OBJECT' CODE TABLES                        *)


  NXTINT  : 0..INTCNT;  NXTDBL : 0..DBLCNT;  NXTSTR : 0..STRCNT;
  NXTPRC  : 0..PRCCNT;  NXTSLOC : ICRNG    ;
  PC      : ICRNG ;     (* PROGRAM COUNTER DIV 2                              *)
  MINLBL  : LBLRNG ;    (* STARTING LABEL VALUE FOR CURRENT PROC              *)


  (* DECLARATIONS FOR LITERAL TABLES ...ETC. NEEDED TO GENERATE OBJECT MODULE *)

  CURPNAME : ARRAY[1..12] OF CHAR ;         (*NAME OF THE CURRENT PROC        *)
  CURPNO   : INTEGER ;                      (*CURRENT PROC #                  *)

  CODE     : ARRAY[0..ENDCODE] OF INTEGER ;

  INTTBL   : ARRAY[0..INTCNT] OF  RECORD
                                 VAL    : INTEGER ;
                                 LNK    : INTEGER
                                 END ;

  DBLTBL   : ARRAY[0..DBLCNT] OF  RECORD
                                 VAL : SETRNG ;
                                 LNK : INTEGER
                                 END ;

  STRTBL   : ARRAY[0..STRCNT] OF  RECORD
                                 LNK    : INTEGER ;
                                 LNGTH  : STRLRNG
                                 END ;

  LBLTBL   : ARRAY[0..LBLCNT] OF  RECORD
                                 DEFINED : BOOLEAN ;
                                 LNK     : INTEGER
                                 END ;

  PRCTBL   : ARRAY[0..PRCCNT] OF  RECORD
                                 NAME : ALFA ;
                                 LNK  : INTEGER
                                 END ;

  PROGHDR  : ARRAY[1..HDRLNGTH] OF CHAR;     (*PROGRAM HEADER/DATE/TIME     *)

  XTBL: ARRAY [XBALR..XCLC] OF
               ARRAY [0..3] OF CHAR ;        (*370 SYMBOLIC OPCODES          *)

"""EBCDIC   : ARRAY[CHAR] OF  0..255  ;      (*INTERNAL CODE TO EBCDIC CONV.*)"


(*+####                                                                   ####

"VAR "  N_E_CNT, INSTRCNT :  0..MXADR ;                                   ####
      S_AREA, S_LIFE, SMX_DEPTH, OLDTOP :  0..SMX_HIGHT ;                 ####
      T_SAV_DEPTH  : REAL ;                                               ####
      SD_HIST, SMXD_HIST, SAVD_HIST, SAREA_HIST, SLIFE_HIST               ####
                   : ARRAY[0..SMX_HIGHT] OF 0..MXADR ;                    ####
"""   STATFILE     : FILE OF CHAR ;   "                                   ####
      DOING_IO , STAT_DEBUG ,PSEUDO_OP : BOOLEAN ;  DOING_CALL : 0..10 ;  ####
(*_________________________________________________________________           *)


                                                                          ####
PROCEDURE RECORD_STAT ;                                                   ####
                                                                          ####
VAR  AV_DEPTH : REAL ;  LTOP : 0..SMX_HIGHT ;                             ####
                                                                          ####
BEGIN                                                                     ####
IF OPC = PCSP THEN  IF CSP = PSIO THEN  DOING_IO := TRUE                  ####
                   ELSE IF CSP = PEIO THEN DOING_IO := FALSE ;            ####
"IF OPC = PMST THEN  DOING_CALL := DOING_CALL+1 ;                         ####
IF OPC = PCUP THEN  DOING_CALL := DOING_CALL-1 ;  "                       ####
LTOP := TOP-1 ;  IF DOING_IO THEN LTOP := LTOP-1 ;                        ####
IF STAT_DEBUG THEN                                                        ####
  WRITELN(OUTPUT, ' TOP, LTOP, OLDTOP=' ,TOP , LTOP, OLDTOP:6) ;          ####
IF PSEUDO_OP THEN PSEUDO_OP := FALSE ELSE                                 ####
IF OPC < 64 THEN                                                          ####
IF DOING_CALL = 0 THEN                                                    ####
IF NOT(OPC IN [PLAB,PDEF,PLOC]) THEN   (*EXCLUDE PSEUDO OPS *)            ####
BEGIN                                                                     ####
IF LTOP > 0 THEN   (* NON EMPTY STACK *)                                  ####
  IF OLDTOP = 0 THEN                                                      ####
    BEGIN  N_E_CNT := N_E_CNT+1 ;                                         ####
    S_AREA := LTOP ;  S_LIFE := 1 ;  SMX_DEPTH := LTOP                    ####
    END                                                                   ####
  ELSE                                                                    ####
    BEGIN  S_AREA := S_AREA+(LTOP) ;  S_LIFE := S_LIFE+1 ;                ####
    IF (LTOP) > SMX_DEPTH THEN  SMX_DEPTH := LTOP                         ####
    END                                                                   ####
ELSE                                                                      ####
   IF OLDTOP > 0 THEN                                                     ####
      BEGIN  S_LIFE := S_LIFE+1 ;  S_AREA := S_AREA+ (OLDTOP) ;           ####
      SMXD_HIST[SMX_DEPTH] :=SMXD_HIST[SMX_DEPTH]+1 ;                     ####
      SAREA_HIST[S_AREA] := SAREA_HIST[S_AREA] + 1 ;                      ####
      SLIFE_HIST[S_LIFE] := SLIFE_HIST[S_LIFE]+1 ;                        ####
      AV_DEPTH := 10 * S_AREA / S_LIFE ;                                  ####
      SAVD_HIST [ TRUNC(AV_DEPTH) ] := SAVD_HIST[ TRUNC(AV_DEPTH) ]+1 ;   ####
      T_SAV_DEPTH := T_SAV_DEPTH+AV_DEPTH ;                               ####
      END ;                                                               ####
SD_HIST[LTOP] := SD_HIST[LTOP]+1 ;                                        ####
OLDTOP := LTOP ;  INSTRCNT := INSTRCNT+1 ;                                ####
END (* IF NOT OPC IN [LAB,DEF,LOC] *)                                     ####
END (* RECORD_STAT *) ;                                                   ####
                                                                          ####
                                                                          ####
PROCEDURE INIT_STAT  ;                                                    ####
                                                                          ####
VAR  I :  0..SMX_HIGHT  ;                                                 ####
                                                                          ####
BEGIN                                                                     ####
FOR I := 0 TO SMX_HIGHT DO                                                ####
   BEGIN                                                                  ####
   SAREA_HIST[I] := 0 ;                                                   ####
   SMXD_HIST[I] := 0 ;                                                    ####
   SD_HIST[I] := 0 ;                                                      ####
   SLIFE_HIST[I] := 0 ;                                                   ####
   SAVD_HIST[I] := 0 ;                                                    ####
   END ;                                                                  ####
   DOING_CALL := 0 ;   STAT_DEBUG := FALSE ;   PSEUDO_OP := FALSE ;       ####
N_E_CNT := 0 ;   T_SAV_DEPTH := 0.0 ;  OLDTOP := 0 ;  INSTRCNT := 0 ;     ####
END (* INIT_STAT *) ;                                                     ####
                                                                          ####
PROCEDURE PRINT_STAT  ;                                                   ####
                                                                          ####
VAR I : 0..SMX_HIGHT ;                                                    ####
                                                                          ####
BEGIN"""REWRITE(STATFILE) ;                                               ####
WRITELN(STATFILE, '    HISTOGRAMS' ) ;                                    ####
WRITELN(STATFILE, '    ++++++++++') ;                                     ####
WRITELN(STATFILE) ;  WRITELN(STATFILE) ;                                  ####
WRITELN(STATFILE,                                                         ####
    '     STACK_DEPTH, MAX_DEPTH, AVE_DEPTH, STACK_AREA, STACK_LIFE ') ;  ####
WRITELN(STATFILE) ;                                                       ####
FOR I := 0 TO SMX_HIGHT DO                                                ####
WRITELN(STATFILE, I:6, ')', SD_HIST[I]:5, SMXD_HIST[I]:5, SAVD_HIST[I]:5, ####
                  SAREA_HIST[I]:5, SLIFE_HIST[I]:5 ) ;                    ####
WRITELN(STATFILE) ;                                                       ####
WRITELN(STATFILE,'   NON EMPTY STACK CASES, AVER_DEPTH, INSTR COUNT:' ,   ####
                 N_E_CNT:6, T_SAV_DEPTH/(10*N_E_CNT):11, INSTRCNT:6) ;""" ####
END (* PRINT_STAT *)  ;                                                  ####+*)
(*_________________________________________________________________*)

PROCEDURE ERROR(ERRCDE: INTEGER) ;

  BEGIN
  IF ASM THEN
    BEGIN  WRITELN(PRR,'*') ;  WRITELN(PRR,' PERROR', ERRCDE:5) ;  END
  ELSE
    BEGIN
    WRITELN(OUTPUT,'     ****  PERROR',ERRCDE:8, '  ( NEAR LINE',
            LASTLN:6, '  OF PROCEDURE:', CURPNAME:14, ' )') ;
    IF ERRCDE = 253 THEN  WRITELN(' ': 12 , 'PROCEDURE TOO LARGE.') ;
    END ;
  ERRORCNT := ERRORCNT+1 ;
  END ;


PROCEDURE ENTERLOOKUP (*ITEM: BETA; OP_SP: BOOLEAN*) ;

  VAR H: 0..HTSIZE ;

  BEGIN
  H := (ORD(NMCDE[1])*64+ORD(NMCDE[2])*4096+ORD(NMCDE[3])) MOD HTSIZE ;

  IF HTBL[H].NAME <> NMCDE THEN
    WHILE (HTBL[H].NAME <> EMPTY) AND (HTBL[H].NAME <> NMCDE)  DO
""""    BEGIN"WRITELN(' ENTL >',NMCDE, OPC, H) ;" H := (H+2) MOD HTSIZE ; END ;
  (*NO CHECK FOR CYCLES IS MADE HERE*)

  WITH HTBL[H] DO

    IF NAME = NMCDE THEN (*LOOKUP*)

      IF OP_SP THEN OPC := OPCDE  (*OPCODE FOUND*)
      ELSE CSP := SPCDE   (*STANDARD PROC. FOUND *)

    ELSE

      IF INIT THEN
        BEGIN (*ENTER THE ITEM*)
        NAME := NMCDE ;
        IF OP_SP THEN OPCDE := OPC
        ELSE SPCDE := CSP ;
        END
      ELSE IF OP_SP THEN  OPC := OPCNT  ELSE CSP := SPCNT ;
  END (*ENTERLOOKUP*) ;


FUNCTION FLDW(NUM : INTEGER) : INTEGER ;

  VAR FW : INTEGER ;

  BEGIN
    FW := 0 ;
    IF NUM < 0 THEN  BEGIN  FW := 1 ;  NUM := ABS(NUM) ;  END ;
    REPEAT
      NUM := NUM DIV 10 ;  FW := FW+1 ;
    UNTIL NUM = 0 ;
    FLDW := FW
  END (*FLDW*);


"PROCEDURE SET_TO_INT(PSVAL : SETRNG; VAR PS1, PS0 : INTEGER) ;
  (*RETURNS  TWO INTEGERS HAVING THE SAME INTERNAL REPRESENTAION OF PSVAL*)

  VAR I : 0..63 ;

  FUNCTION TWO_TO_I(I : INTEGER): INTEGER ;
    (*COMPUTES 2**I FOR NON NEGATIVE I *)
    BEGIN
    IF I <= 0 THEN TWO_TO_I := 1
    ELSE IF I = 1 THEN  TWO_TO_I := 2
         ELSE TWO_TO_I := TWO_TO_I(I DIV 2)*TWO_TO_I(I-(I DIV 2)) ;
    END (*TWO_TO_I*) ;


  BEGIN  PS0 := 0 ;  PS1 := 0 ;
  FOR I := 0 TO 63 DO
    BEGIN
    IF I IN PSVAL THEN
      IF I < 32 THEN  PS0 := PS0+TWO_TO_I(I)
      ELSE PS1 := PS1+TWO_TO_I(I-32) ;
    END ;
  END (*SET_TO_INT*) ; (*REPLACED BY THE 'SET_TO..' IN THE 370 IMPLEMENTAION*) "


PROCEDURE DUMPSTK(STP1, STP2: STKPTR) ;

  VAR I : STKPTR ;

  BEGIN
  FOR I := STP1 TO STP2 DO
    WITH STK[I] DO
      BEGIN WRITE(PRR,' +++ DEPTH =',I:3,'  FPA =',FPA.LVL:3, FPA.DSPLMT:6) ;
      IF VRBL THEN
      BEGIN
        IF VPA = RGS THEN WRITE(PRR,'  VPA-REG =',RGADR:3)
        ELSE  WRITE(PRR,'  VPA-MEM =',MEMADR.LVL:3,MEMADR.DSPLMT:6) ;
        IF DRCT THEN WRITE(PRR,'  DIRECT ACC.')
          ELSE WRITE(PRR,'  INDIRECT ACC.') ;
        END ;
      IF DTYPE = ADR THEN WRITELN(PRR,'   (ADR)')
      ELSE IF DTYPE = INT THEN WRITELN(PRR,'   (INT)')
           ELSE IF DTYPE = CHRC THEN WRITELN(PRR,'   (CHR)')
                ELSE IF DTYPE = BOOL THEN WRITELN(PRR,'   (BOL)')
                     ELSE WRITELN(PRR,'   (ETC)') ;
      END (*WITH*) ;
  END (*DUMPSTK*) ;
(*_________________________________________________________________*)


PROCEDURE READNXTINST ;

(* TO READ AND DECODE NEXT P_INSTRUCTION *)
(* ------------------------------------- *)

  CONST
         SL16 = 65536 ;

  VAR    I, J, K: INTEGER ;   DUMMYCH, CH1: CHAR ;
         TEMPLBL: ARRAY [1..12] OF CHAR ;

  PROCEDURE READLBL(VAR LBL: PLABEL) ;

    (* SKIPS LEADING BLANKS AND READS THE NEXT CHARACTER SEQUENCE AS A LABEL *)
    (* --------------------------------------------------------------------- *)

    BEGIN
    WITH LBL DO
      BEGIN
      NAM := '        ' ;  LEN := 0 ;

      WHILE INPUT@ = ' ' DO  GET(INPUT) ;

        REPEAT
        READ(INPUT, CH) ;  LEN := LEN+1 ;  NAM[LEN] := CH ;
        UNTIL (INPUT@ = ' ') OR (LEN = 8)  ;

      END (* WITH *) ;
    END (*READLBL*) ;


  PROCEDURE PRINTSRC ;

    (* TO PRINT THE PSOURCE P_INSTRUCTIONS *)
    (* ----------------------------------- *)

    BEGIN
    WRITE(PRR,'*') ;
    IF OPC IN [PDEF,PENT,PLAB] THEN  WRITE(PRR,LBL1.NAM) ;
    WRITE(PRR, NMCDE:5) ;
    IF OPC IN [PCUP,PINC,PDEC,PEQU,PNEQ,PGEQ,PGRT,PLEQ,PLES,PIND,PLDC,"PLDO,"
          PCHK,PLOD,PRET,"PSRO,"PSTO,PSTR,PENT] THEN   (*OPERAND TYPE FIELD*)
      WRITE(PRR,CH1:3) ;

    IF OPC IN [PCUP,PENT,PLDA,PLOD,PMST,PSTR,PCHK] THEN
      WRITE(PRR,P:5) ;

    IF (OPC IN [PCHK,PINC,PDEC,PIND,PIXA,"PLAO,"PLDA,"LDO,"PLOD,PLOC,
                "PSRO,"PSTR,PMOV,PNEW,PDEF,PCTI])
      OR ((OPC IN [PEQU,PLES,PGRT,PNEQ,PLEQ,PGEQ]) AND (OPNDTYPE = STRG)) THEN
      WRITE(PRR,Q:8) ;

    IF OPC IN [PCUP,PFJP,PUJP,PXJP,PCTS] THEN
      WRITE(PRR, LBL2.NAM:10)  ;

    IF OPC = PENT THEN  WRITE(PRR, CURPNAME:14) ;

    IF OPC = PLDC THEN

      CASE OPNDTYPE OF

      BOOL: WRITE(PRR,IVAL:3) ;
      CHRC: WRITE(PRR,' ',CHR(IVAL):2) ;
      INT:  WRITE(PRR,IVAL:10) ;
      ADR:  WRITE(PRR, 'N':3);
      REEL: WRITE(PRR,STRPTR@:SLNGTH) ;
      PSET:
        BEGIN  I_S_R.S := PSVAL ;
        WRITE(PRR,I_S_R.I1:11,' ,',I_S_R.I2:11)
        END (*PSET*)

      END (*CASE*) ;

    IF OPC = PLCA THEN  WRITE(PRR,' ''',SVAL:SLNGTH,'''') ;
    WRITELN(PRR) ;
    "WRITELN(' OPC=',OPC:3,' TYPE,P,Q,IVAL ',CH1:3,P:4,Q:8,IVAL:8,LBL1,LBL2);"
    END (*PRINTSRC*) ;


    BEGIN (*READNXTINST*)

    IF INPUT@ <> ' ' THEN  READLBL(LBL1) ;
    REPEAT  GET(INPUT)  UNTIL INPUT@ <> ' ' ;
    READ(INPUT, NMCDE (* READS NMCDE[1]..NMCDE[3] *) )  ;
(*+#IF STAT_DEBUG THEN  WRITE(OUTPUT,NXTLOC,NMCDE:6) ;                    ####*)
    ENTERLOOKUP(*NMCDE,TRUE*) ; (*LOOK UP THE OPCDE*)
""" WRITELN(' OPCED LOOKED UP >',NMCDE, OPC, PTBL[OPC]:5) ;"
(*+#IF OPC = PMST THEN DOING_CALL := DOING_CALL+1                         ####*)
(*+#ELSE IF OPC = PCUP THEN DOING_CALL := DOING_CALL-1 ;                  ####*)

    IF OPC >= 64 THEN    (*FILTER OUT THOSE THAT CANNOT BE TESTED BY "IN" OP.*)

    BEGIN
    IF OPC = PBGN  THEN
      BEGIN    (*READ AND SET VARIOUS ASSEMBLY / RUNTIME OPTIONS*)
      READLN(INPUT, ASM, CH, GET_STAT, CH, ASMVERB, CH, PROGHDR);
      END
    ELSE
      IF OPC = OPCNT THEN
        BEGIN  WRITE(OUTPUT, ' -->', NMCDE) ; ERROR(606);  READLN(INPUT) END
      ELSE
        BEGIN
        IF ASM THEN  WRITELN(PRR, '*', NMCDE:4);
        READLN(INPUT);
        END
      END (* IF OPC >= 64 *)

    ELSE (* I.E. OPC < 64 *)

      BEGIN
      OPNDTYPE := INT ;  P := CURLVL ;  Q := 0 ;  (*DEFAULT VALUES*)

      IF OPC IN ([PADI,PADR,PSBI,PSBR,PSGS,PFLT,PFLO,PTRC,PNGI,PNGR,PSQI,PSQR]+
                 [PABI,PABR,PNOT,PAND,PIOR,PDIF,PINT,PUNI,PINN,PMOD,PODD,PMPI,
                  PMPR,PDVI,PDVR,PSTP])  (*ZERO ADDRESS OPCODES*)
        THEN  READLN(INPUT)

      ELSE  (*OTHER INSTRUCTIONS*)

        BEGIN

        IF OPC IN [PCUP,PINC,PDEC,PEQU,PNEQ,PGEQ,PGRT,PLEQ,PLES,PIND,PLDC,
                   PLOD,PRET,PSTO,PSTR,PENT,PCHK] THEN    (*OPERAND TYPE FIELD*)
          BEGIN    REPEAT  READ(INPUT, CH1) ;  UNTIL CH1 <> ' ' ;
"NH"      OPNDTYPE := TYPCDE[CH1];  IF INPUT@=',' THEN GET(INPUT);
          END (* OPC IN [PCUP,PINC,PDEC... *) ;

"NH"    IF OPC IN [PCUP,PENT,PLDA,PLOD,PMST,PSTR,PCHK] THEN
"NH"      BEGIN READ(INPUT, P);  IF INPUT@=',' THEN GET(INPUT);  END;

        IF (OPC IN [PCHK,PINC,PDEC,PIND,PIXA,PLDA,PLOD,PLOC,
                    PSTR,PMOV,PNEW,PDEF,PCHK,PCTI]) THEN  READ(INPUT, Q)
        ELSE

          IF OPC IN [PCUP,PFJP,PUJP,PXJP,PCTS] THEN  READLBL(LBL2)
          ELSE

            BEGIN  (* PENT, PCSP, PLCA, PLDC, PEQU, PNEQU .... *)
            IF OPNDTYPE = STRG THEN
              IF OPC IN [PEQU,PLES,PGRT,PNEQ,PLEQ,PGEQ] THEN  READ(INPUT, Q) ;


            IF OPC = PENT THEN
              BEGIN  READLBL(SEGSZE) ;
              REPEAT  GET(INPUT)  UNTIL INPUT@ <> ' ' ;
              READ(INPUT, CURPNAME, CH, SAVERGS, CH, SAVEFPRS, CH, DEBUG, CH,
                          CURPNO) ;
              SAVEFPRS := SAVEFPRS AND (OPNDTYPE = REEL) ;
              CALL_HIGHER := TRUE;  PROC_SIZE := MXCODE1;  DATA_SIZE := MXADR;

              IF PRE_PASS THEN
                BEGIN
                   REPEAT
                   READLN(PRD);  READ(PRD, LBL2.NAM);
                   UNTIL LBL2.NAM = '#PROC   ';
                (* POSITION TO NEXT PROC. INFO. *)
                READ(PRD, TEMPLBL) ;
                IF TEMPLBL <> CURPNAME THEN ERROR(614)
                ELSE
                  BEGIN
                  READLN(PRD, CALL_HIGHER, PROC_SIZE, DATA_SIZE, FLIPDEBUG);
                  END ;
                LARGE_PROC := PROC_SIZE > SHRT_PROC ;
               "WRITELN(' ***',LBL2.NAM:10,TEMPLBL:10,CALL_HIGHER,PROC_SIZE,
                        DATA_SIZE);"
                END (* IF PRE_PASS*) ;

              END (* OPC = ENT *) ;

            IF OPC = PLDC THEN

              CASE OPNDTYPE OF

              BOOL: READ(INPUT, IVAL) ;
              CHRC: BEGIN  READ(INPUT, CH,CH);  IVAL :=" EBCDIC["ORD(CH)"]" END;
              INT:  READ(INPUT, IVAL) ;
              REEL:
"NH"            BEGIN NEW(STRPTR);  SLNGTH := 0;
"NH"              REPEAT READ(INPUT, CH);  SLNGTH := SLNGTH + 1;
"NH"                STRPTR@[SLNGTH] := CH;
"NH"              UNTIL INPUT@ = ' ';
                END ;
              PSET:
                BEGIN
                READ(INPUT, CH, Q, CH, I, CH) ;  I_S_R.I1 := Q*SL16 + I ;
                READ(INPUT, Q, CH, I) ;  I_S_R.I2 := Q*SL16 + I ;
                PSVAL := I_S_R.S ;
                END
              END (*CASE*)


            ELSE  IF OPC IN [PCSP, PLCA] THEN

              BEGIN   REPEAT  GET(INPUT)  UNTIL INPUT@ <> ' ' ;

              IF OPC = PCSP THEN
                BEGIN
                READ(INPUT, NMCDE) ;
                OP_SP := FALSE ;  (* INDICATES A CSP LOOKUP *)
                ENTERLOOKUP(*NMCDE,FALSE "CSP" LOOKUP*) ;
                OP_SP := TRUE ;
                END
              ELSE  (* I.E. IF OPC = PLCA THEN *)
"NH"            BEGIN  SLNGTH := 0;

                  REPEAT
"NH"              READ(INPUT, CH);

                    REPEAT  (*READ INPUT UP TO AND INCLUDING THE FIRST QUOTE*)
                    READ(INPUT, CH);  SLNGTH := SLNGTH+1;  SVAL[SLNGTH] := CH;
                    UNTIL  CH = '''' ;

"NH"              IF INPUT@ = '''' THEN
                    BEGIN
                    IF ASM THEN SLNGTH := SLNGTH+1; SVAL[SLNGTH] := ''''
                    END
                  ELSE  SLNGTH := SLNGTH-1 ;
"NH"              UNTIL INPUT@ <> '''';

                END (*LCA*) ;
              END (* OPC IN [PCSP, PLCA] *);

            END  (* PENT, PCSP, PLCA, PLDC, PEQU, PNEQU .... *) ;
"NH"
"NH"    READLN(INPUT);
        END (*ELSE OTHER INSTRUCTIONS*) ;

      END (* ELSE I.E. OPC < 64 *);

    IF ASM THEN PRINTSRC ;

    END (*READNXTINST*) ;


  PROCEDURE ASMNXTINST ;

  (* TO TRANSLATE THE NEXT P_INSTRUCTION INTO 370 ASSEMBLY/OBJECT CODE *)
  (* ----------------------------------------------------------------- *)


  CONST  SL8     = 256        ;  (* SHIFT LEFT 8 BITS  *)
         SL12    = 4096       ;  (*            12      *)
         SL16    = 65536      ;  (*           16       *)
         SL24    = 16777216   ;  (*           24       *)


  VAR    OP : BYTE ;   P1, P2, B1, B2 : LVLRNG ;   Q1, Q2 : ADRRNG ;
         I,J: INTEGER;   LEFTDEC, NEGATE: BOOLEAN;   POWER10: REAL;
         OPPTR: STKPTR;


    (* THE FOLLOWING PROCEDURES ARE FOR OBJECT CODE GENERATION ONLY  *)
    (* ------------------------------------------------------------- *)


    FUNCTION NEXTPC(PCINCR: ICRNG): ICRNG ;

      BEGIN
      IF PC >= NXTSLOC THEN
        BEGIN  ERROR(253) ;  EXIT(253)  END ;
      NEXTPC := PC+PCINCR ;
      END (*NEXTPC*) ;


    FUNCTION BASE_DSPLMT(PC : ICRNG) : INTEGER ;

      (* CONVERTS PROGRAM COUNTER VALUES TO 370 BASE/DISPLACEMENT HALF WORDS *)
      (* ------------------------------------------------------------------- *)

      BEGIN PC := 2*PC ;
      IF PC < 4096 THEN BASE_DSPLMT := PBR1*SL12+PC
      ELSE IF PC <= 8188 THEN  BASE_DSPLMT := PBR2*SL12+PC-4092
        ELSE  ERROR(253)
      END (*BASE_DSPLMT*) ;


    PROCEDURE UPD_INTTBL(PC: ICRNG; D: INTEGER; TAG :INTEGER) ;

    (* TO ADD HALF/FULL INTEGERS TO THE LITERAL POOL *)
    (* --------------------------------------------- *)

    VAR I : 0..INTCNT;

      BEGIN
      INTTBL[NXTINT].VAL := D ;  I := 0 ;
      WHILE INTTBL[I].VAL <> D DO I := I+1 ;
      CODE[PC] := INTTBL[I].LNK ;  INTTBL[I].LNK := PC ;
      IF I = NXTINT THEN
        IF NXTINT = INTCNT THEN ERROR(261)
        ELSE  BEGIN  NXTINT := NXTINT+1 ;  INTTBL[NXTINT].LNK := 0  END ;
      IF TAG < 0 THEN CODE[PC-1] := -CODE[PC-1] ;
      END (* UPD_INTTBL *) ;


    PROCEDURE UPD_DBLTBL(PC : ICRNG ; S: SETRNG) ;

    (* TO ADD DOUBLE (REALS/SETS) VALUSE TO 'DOUBLE' POOL *)
    (* -------------------------------------------------- *)

    VAR I : 0..DBLCNT;

      BEGIN
      DBLTBL[NXTDBL].VAL := S ;  I := 0 ;
      WHILE DBLTBL[I].VAL <> S DO I := I+1 ;
      CODE[PC] := DBLTBL[I].LNK ;  DBLTBL[I].LNK := PC ;
      IF I = NXTDBL THEN
        IF NXTDBL >= DBLCNT THEN  ERROR(282)
        ELSE  BEGIN  NXTDBL := NXTDBL+1 ;  DBLTBL[NXTDBL].LNK := 0  END
    END (* UPD_DBLTBL *) ;


    PROCEDURE UPD_PRCTBL(PC : ICRNG ; PRC_NAME : ALFA) ;

      (* TO UPDATE EXTERNAL REFERENCE TABLE *)
      (* ---------------------------------- *)

      VAR I : 0..PRCCNT;

      BEGIN
      PRCTBL[NXTPRC].NAME := PRC_NAME ;  I := 0 ;
      WHILE PRCTBL[I].NAME <> PRC_NAME DO I := I+1 ;
      CODE[PC] := PRCTBL[I].LNK ;  PRCTBL[I].LNK := PC ;
      IF I = NXTPRC THEN
        IF NXTPRC >= PRCCNT THEN ERROR(256)
        ELSE
          BEGIN  NXTPRC := NXTPRC+1 ;  PRCTBL[NXTPRC].LNK := 0  END
    END (* UPD_PRCTBL *) ;


    (* UPD_STRTBL IS DONE DIRECTLY BY THE P_INSTRUCTION 'PLCA' *)


    FUNCTION LBLMAP(ALFLBL: ALFA) : LBLRNG ;

    VAR  I : 2..8 ;  J : LBLRNG ;

      BEGIN  (* TRANSLATE GENERATED LABELS TO CONSECUTIVE INTEGERS *)
      I := 2 ;  J := 0 ;
        REPEAT J := J*10+ORD(ALFLBL[I])-ORD('0') ;  I := I+1
        UNTIL ALFLBL[I] = ' ' ;
      LBLMAP := J ;
      END (* LBLMAP *) ;


    PROCEDURE UPD_LBLTBL( PC: ICRNG; INTLBL: LBLRNG; NEWLBL: BOOLEAN) ;

    (* TO 'DEFINE' LABELS AND/OR RESOLVE FORWARD REFERENCES *)
    (* ---------------------------------------------------- *)

    VAR I : LBLRNG ;  TPC, QPC : INTEGER ;

      BEGIN  (* NO PROTECTION AGAINST REDEFINITIONS HERE *)
      IF INTLBL > LBLCNT THEN
        BEGIN WRITELN(' **** INTLBL ',INTLBL) ;  ERROR(263) ;  EXIT(263)   END
      ELSE
        WITH LBLTBL[INTLBL] DO
          IF DEFINED THEN     (* BACKWARD REFERENCE *)

            IF CASE_FLAG THEN  CODE[PC] := LNK*2 (* THIS IS  A HALF WORD ADR. *)
            ELSE  CODE[PC] := BASE_DSPLMT(LNK)   (* BASE/DSPLMT HALF WORD     *)

          ELSE

            IF NEWLBL THEN    (* LABEL DEFINITION *)
              BEGIN
              DEFINED := TRUE ;  TPC := LNK ;
              LNK := PC ;  (* SET LABEL VALUE *)
              WHILE TPC <> 0 DO
                BEGIN
                QPC := TPC ; TPC := CODE[QPC] ;
                IF TPC < 0 THEN
                  BEGIN  CODE[QPC] := PC*2 ;  TPC := ABS(TPC)  END
                ELSE  CODE[QPC] := BASE_DSPLMT(PC) ;
                END
              END
            ELSE   (* NOT NEWLBL I.E. FORWARD REFERENCE, TO BE RESOLVED LATER *)
              BEGIN
              IF CASE_FLAG THEN  CODE[PC] := -LNK  ELSE  CODE[PC] := LNK ;
              LNK := PC
              END ;

      END (* UPD_LBLTBL *) ;


    (* 370 FORMAT CODE GENERATOR (ASSEMBLY/OBJECT CODE) *)
    (* ------------------------------------------------ *)


    PROCEDURE GENRR(OP: BYTE; R1,R2: OPRNG) ;

      BEGIN
      IF ASM THEN
        WRITELN(PRR,XTBL[OP]:5, R1:3,',',R2:FLDW(R2) )
      ELSE  BEGIN  CODE[PC] := OP*SL8  +R1*16+R2 ;  PC := NEXTPC(1)  END
      END (*GENRR*) ;


    PROCEDURE GENRXLIT(OP: BYTE; R: RGRNG; D: INTEGER ; TAG: INTEGER) ;FORWARD ;


    PROCEDURE GENRX(OP:BYTE; R: RGRNG ; D: ADRRNG; X,B: RGRNG) ;

      BEGIN

      IF (D < 0) OR (D > SHRTINT) THEN
        BEGIN  ERROR(608 (*THIS SHOULD NOT BE THE CASE NOW*)) ;

        IF B = TXRG THEN GENRXLIT(XA,TXRG,D,0)
        ELSE
          BEGIN  GENRXLIT(XL,TXRG,D,0) ;
          IF B = 0 THEN B := TXRG
          ELSE
            IF X = 0 THEN X := TXRG
            ELSE  BEGIN GENRR(XAR,TXRG,B) ;  B := TXRG  END ;
          END ;

        D := 0
        END ;

      IF ASM THEN
        BEGIN  WRITE(PRR,XTBL[OP]:5,R:3,',',D: FLDW(D),'(', X: FLDW(X) ) ;
        IF B > 0 THEN WRITE(PRR,',',B: FLDW(B) ) ;
        WRITELN(PRR,')') ;
        END
      ELSE
        BEGIN
        CODE[PC] := OP*SL8  +R*16+X ;  CODE[PC+1] := SL12*B+D ;  PC := NEXTPC(2)
        END
      END (*GENRX*) ;

    PROCEDURE GENRXLIT ;
      VAR SMALL: BOOLEAN ;

      BEGIN
      SMALL := (D >= 0) AND (D <= SHRTINT) ;

      IF SMALL AND (OP = XL) THEN GENRX(XLA,R,D,0,0)
      ELSE

        IF (TAG < 0) AND ((D > 32767) OR (D < -32767)) THEN  ERROR(504)
        ELSE

          IF ASM THEN
            BEGIN   WRITE(PRR,XTBL[OP]:5,R:3) ;
            IF TAG < 0 THEN  WRITELN(PRR,',=H''',D:FLDW(D),'''')
            ELSE  WRITELN(PRR,',=A(',D:FLDW(D),')')
            END
          ELSE   (* ASM *)
            BEGIN  CODE[PC] := OP*SL8  +R*16 ;
            UPD_INTTBL(PC+1,D,TAG) ;  PC := NEXTPC(2) ;
            END

    END (*GENRXLIT*) ;


    PROCEDURE GENRXDLIT(OP: BYTE; R: RGRNG; STR: SPTR; STRL: STRLRNG; VAL:REAL);

    VAR I: INTEGER;
    BEGIN
      IF ASM THEN
      BEGIN
       WRITELN(PRR, XTBL[OP]:5, R:3,',=D''', STR@:STRL, '''');
      "FOR I := 1 TO STRL DO
          WRITE(PRR,STR@[I]:1);
       WRITELN(PRR,'''') "
      END
    ELSE
      BEGIN  CODE[PC] := OP*SL8+ R*16+ 00 ;  PC := NEXTPC(2)  ;
      I_S_R.R := VAL ;  UPD_DBLTBL(PC-1,I_S_R.S) ;
      END ;
    END (* GENRXDLIT *);


    PROCEDURE GENRS(OP: BYTE; R1,R2: RGRNG; D: ADRRNG; B: RGRNG ) ;

      BEGIN

      IF (D < 0) OR (D > SHRTINT) THEN
        BEGIN  IF B <> TXRG THEN   GENRR(XLR,TXRG,B); (*GENRX(XLR,TXRG,B,0,0);*)
        GENRXLIT(XA,TXRG,D,0) ;   D := 0 ;   B := TXRG
        END ;

      IF ASM THEN
      WRITELN(PRR,XTBL[OP]:5,R1:3,',',R2:FLDW(R2),',',
                  D:FLDW(D),'(',B:FLDW(B),')')
      ELSE
        BEGIN
        CODE[PC] := OP*SL8 +R1*16 +R2 ; CODE[PC+1] := B*SL12 +D; PC := NEXTPC(2)
        END
      END (*GENRS*) ;


    PROCEDURE GENRSLIT( OP: BYTE; R1,R2: RGRNG; VAL: SETRNG ) ;

      BEGIN
      IF ASM THEN
        BEGIN  I_S_R.S := VAL ;
        WRITELN(PRR, XTBL[OP]:5, R1:3,',', R2:FLDW(R2), ',=F''',
                     I_S_R.I1: FLDW(I_S_R.I1),',',I_S_R.I2:FLDW(I_S_R.I2),'''')
        END
      ELSE
        BEGIN
        CODE[PC] := OP*SL8  +R1*16+R2 ;  UPD_DBLTBL(PC+1,VAL) ;  PC := NEXTPC(2)
        END
      END (*GENRSLIT*) ;


    PROCEDURE GENSS(OP,LNGTH: BYTE; D1: ADRRNG; B1: RGRNG; D2:ADRRNG;B2:RGRNG) ;

      BEGIN
      IF ASM THEN
        WRITELN(PRR,XTBL[OP]:5,D1:6,'(',LNGTH:FLDW(LNGTH),',',B1:FLDW(B1), '),',
                     D2:FLDW(D2),'(',B2:FLDW(B2),')' )
      ELSE
        BEGIN  CODE[PC] := OP*SL8  +(LNGTH-1) ;
        CODE[PC+1] := B1*SL12+D1 ;  CODE[PC+2] := B2*SL12+D2 ;  PC := NEXTPC(3)
        END
      END (*GENSS*) ;


    PROCEDURE GENSI(OP: BYTE; D: ADRRNG; B: RGRNG; I: BYTE) ;

      BEGIN
      IF ASM THEN
        WRITELN(PRR,XTBL[OP]:5,D:8,'(',B:FLDW(B),'),',I:FLDW(I))
      ELSE
        BEGIN
        CODE[PC] := OP*SL8  +I ; CODE[PC+1] := B*SL12+D ; PC := NEXTPC(2)
        END
      END (*GENSI*) ;


    PROCEDURE GENRXLAB(OP: BYTE; R: RGRNG; LAB: PLABEL; TAG:INTEGER) ;

      BEGIN
      IF ASM THEN
        BEGIN
        WRITE(PRR,XTBL[OP]:5, R:3,',') ;
        IF TAG >= 0 THEN  WRITE(PRR,LAB.NAM:LAB.LEN,'(',TAG:FLDW(TAG))
        ELSE  BEGIN  IF TAG = -3 THEN  WRITE(PRR,'=V(')
                     ELSE  (* TAG = -1 *)  WRITE(PRR,'=A(') ;
              WRITE(PRR, LAB.NAM: LAB.LEN) ;
              END ;
        WRITELN(PRR,')') ;
        END
      ELSE

        IF CASE_FLAG THEN
          BEGIN
          UPD_LBLTBL(PC,LBLMAP(LAB.NAM),FALSE(*LAB REF*) ) ;  PC := NEXTPC(1) ;
          END
        ELSE
          BEGIN
          IF TAG >= -1 THEN  (*GENERATED LABEL*)
            UPD_LBLTBL(PC+1,LBLMAP(LAB.NAM),FALSE (*LABEL REFERENCE*))
          ELSE  (*PROC. ID.*)  UPD_PRCTBL(PC+1,LAB.NAM) ;
          IF TAG < 0 THEN TAG := 0 ;
          CODE[PC] := OP*SL8  +R*16+TAG ;  PC := NEXTPC(2)
          END
        END (*GENRXLAB*) ;


    PROCEDURE  FINDRG ;  (*TO FIND A GP REGISTER*)

      VAR I :RGRNG ;

      BEGIN   I := 1 ;

      REPEAT  I := I+1  UNTIL  (AVAIL[I] OR (I = RGCNT)) ;

      IF NOT AVAIL[I] THEN ERROR(259) ;
      AVAIL[I] := FALSE ;  NXTRG := I ;
      END (*FINDRG*) ;


    PROCEDURE  FINDRP ;  (*FIND REGISTER PAIR*)

      VAR  I: RGRNG ;

      BEGIN   I := RGCNT+1  ;

      REPEAT  I := I-2  UNTIL (I < 4) OR (AVAIL[I] AND AVAIL[I+1]) ;

      IF  NOT (AVAIL[I] AND AVAIL[I+1])  THEN ERROR(259) ;
      AVAIL[I] := FALSE ;  AVAIL[I+1] := FALSE ;  NXTRG := I
      END (*FINDRP*) ;


    PROCEDURE FINDFP ; (*FIND A FLOATING POINT REGISTER*)

      VAR I : INTEGER ;

      BEGIN  I := 0 ;

      REPEAT  I := I+2  UNTIL AVAILFP[I] OR (I = FPCNT) ;

      IF NOT AVAILFP[I] THEN ERROR(259)  ;
      AVAILFP[I] := FALSE ;  NXTRG := I
      END (*FINDFP*) ;


    PROCEDURE FREEREG(VAR STE : DATUM) ;

      BEGIN
      WITH STE DO
        IF VRBL AND (VPA = RGS) THEN
        BEGIN
          IF DTYPE=REEL THEN
            AVAILFP[RGADR] := TRUE
          ELSE  (* DTYPE <> REEL *)
            AVAIL[RGADR] := TRUE ;
          IF DTYPE = PSET THEN
            AVAIL[RGADR + 1] := TRUE
        END  (* IF VRBL *)
      END (*FREEREG*) ;


    FUNCTION ALIGN( Q, P: INTEGER): INTEGER ;

      VAR I : INTEGER ;

      BEGIN
      ALIGN := Q ;  I := Q MOD P ;
      IF I <> 0 THEN ALIGN := Q+(P-I) ;
      END (*ALIGN*) ;


   FUNCTION  POWER2(I : INTEGER) : INTEGER ;

   (* IF I > 0 IS A POWER OF TWO, RETURN 'THAT' POWER, ELSE RETURN NEGATIVE *)
   (* --------------------------------------------------------------------- *)

     BEGIN   (* TEMPORARRY     POWER2 := -999 ; *)
     IF I = 1 THEN  POWER2 := 0
     ELSE IF ODD(I) OR (I <= 0) THEN  POWER2 := -999
       ELSE IF I = 2 THEN  POWER2 := 1
         ELSE IF I = 4 THEN  POWER2 := 2
           ELSE IF I = 8 THEN  POWER2 := 3
             ELSE IF I =16 THEN  POWER2 := 4
               ELSE IF I = 32 THEN  POWER2 := 5
                 ELSE  POWER2 := 1+POWER2(I DIV 2) ;
     END (*POWER2*) ;


    PROCEDURE BASE(VAR Q: ADRRNG;VAR P,B: LVLRNG ) ;
    (* TO TRANSLATE A 'LEVEL/OFFSET' P/Q ADDRESS TO 'BASE/INDEX/DISPLACEMENT' *)
    (* ---------------------------------------------------------------------- *)

      BEGIN  B := 0  ;

      IF P > 0 THEN
        BEGIN
        IF P = CURLVL THEN  BEGIN  B := LBR ;  P := 0  END
        ELSE IF P = 1 THEN  BEGIN  B := GBR ;  P := 0  END
             ELSE
               BEGIN
               GENRX(XL,TXRG,DISPLAY+4*P,GBR,0) ;  P := TXRG ;
               END
        END ;

      IF (Q < 0) OR (Q > SHRTINT) THEN
        BEGIN
        IF P > 0 THEN GENRXLIT(XA,P,Q,0)
        ELSE  BEGIN  GENRXLIT(XL,TXRG,Q,0) ;  P := TXRG  END ;
        Q := 0
        END

      END (*BASE*) ;


  PROCEDURE GETADR( STE: DATUM; VAR Q: ADRRNG; VAR P, B: RGRNG) ;  FORWARD ;


  PROCEDURE LOAD(VAR STE: DATUM) ;

    (* LOADS AN STACK ELEMENT INTO A REGISTER, IF NOT ALREADY THERE *)
    (* ------------------------------------------------------------ *)


    VAR P: LVLRNG; Q: ADRRNG; B, R: RGRNG ; OP: BYTE ;


    PROCEDURE FINDMDRG ;

      (*TO FIND A MULTIPLY/DEVIDE REGISTER*)

      BEGIN
      IF MDTAG = PDVI THEN
        BEGIN  FINDRP ;  AVAIL[NXTRG+1] := TRUE  END
      ELSE IF MDTAG = PMPI THEN
             BEGIN  FINDRP ;  AVAIL[NXTRG] := TRUE ;  NXTRG := NXTRG+1 END
           ELSE FINDRG ;
      END (*FINDMDRG*) ;


    BEGIN  (*LOAD*)

    WITH STE DO
      BEGIN
      IF VRBL THEN (* LOAD THE VARIABLE POINTED TO BY STP*)

        IF DRCT THEN (*DIRECTLY ACCESIBLE VARIABLE*)

          CASE DTYPE OF

          ADR,INT,BOOL,CHRC:
            BEGIN

              IF VPA = MEM THEN
                BEGIN  FINDMDRG ;
                P := MEMADR.LVL ;   Q := MEMADR.DSPLMT ;
                BASE(Q,P,B) ;

                IF (DTYPE = CHRC) OR (DTYPE = BOOL) THEN
                  BEGIN
                  IF CLEAR_REG " AND (FPA.DSPLMT = 0) " THEN
                    GENRR(XSR,NXTRG,NXTRG) ;
                  GENRX(XIC,NXTRG,Q,B,P) ;
                  END
                ELSE  GENRX(XL,NXTRG,Q,B,P) ;

                VPA := RGS ;  RGADR := NXTRG ;
                END ;

              P := FPA.LVL ;  Q := FPA.DSPLMT ;
              FPA := ZEROBL ;

              IF Q <> 0 THEN
                IF P > 0 THEN
                  BEGIN  BASE(Q,P,B) ;
                  IF P <= 0 THEN P := B
                  ELSE IF B > 0 THEN GENRR(XAR,P,B) ;
                  IF Q = 0 THEN GENRR(XAR,RGADR,P)
                  ELSE GENRX(XLA,RGADR,Q,P,RGADR) ;
                  END
                ELSE IF Q = -1 THEN GENRR(XBCTR,RGADR,0)
                     ELSE GENRXLIT(XA,RGADR,Q,0) ;

            END (*ADR,INT,BOOL,CHRC*) ;

          REEL:
             IF VPA = MEM THEN
             BEGIN
                FINDFP;
                P := MEMADR.LVL;
                Q := MEMADR.DSPLMT;
                BASE(Q,P,B);
                GENRX(XLD,NXTRG,Q,B,P);
                VPA := RGS;
                RGADR := NXTRG;
             END (* REEL *);

          PSET:
            IF VPA = MEM THEN  (* LOAD POWERSET *)
              BEGIN   P := MEMADR.LVL ;   Q := MEMADR.DSPLMT ;
              BASE( Q, P, B) ;   FINDRP ;

              IF B > 0 THEN IF P > 0 THEN  GENRR(XAR,P,B)  ELSE  P := B ;
              GENRS(XLM,NXTRG,NXTRG+1,Q,P) ;
              VPA := RGS ;  RGADR := NXTRG ;
              END (*PSET*)

          END (* CASE DTYPE_ END OF DIRECT VARIABLE LOAD *)

        ELSE (* IF NOT DRCT *)

          BEGIN
          GETADR(STE, Q, P, B) ;   FPA := ZEROBL ;

            CASE DTYPE OF

            ADR, INT :
              BEGIN   IF VPA = RGS THEN  AVAIL[RGADR] := TRUE ;
              FINDMDRG ;  GENRX(XL, NXTRG, Q, B, P) ;
              END ;

            BOOL, CHRC:
              BEGIN  FINDMDRG ;
              IF CLEAR_REG THEN  GENRR(XSR,NXTRG,NXTRG) ;
              GENRX(XIC, NXTRG, Q, B, P) ;
              IF VPA = RGS THEN  AVAIL[RGADR] := TRUE ;
              END ;

            REEL:
              BEGIN
              FINDFP;
              GENRX(XLD,NXTRG,Q,B,P) ;
              IF VPA = RGS THEN  AVAIL[RGADR] := TRUE ;
              END (* REEL *);

            PSET:
              BEGIN
              IF VPA = RGS THEN  AVAIL[RGADR] := TRUE ;
              IF P > 0 THEN  BEGIN  IF B > 0 THEN  GENRR(XAR,P,B)  END
              ELSE  P := B ;
              FINDRP ;  GENRS(XLM, NXTRG, NXTRG+1, Q, P) ;
              END

            END (* CASE DTYPE *) ;

          VPA := RGS ;   RGADR := NXTRG ;  DRCT := TRUE ;
          END (* LOAD INDRCT *)


      ELSE (* IF NOT VRBL, I.E. LOAD CONSTANT *)


          BEGIN

            CASE DTYPE OF

            ADR:
              BEGIN  P := FPA.LVL ;  Q := FPA.DSPLMT ;
              FINDRG ;
              IF P > 0 THEN  BEGIN  BASE(Q,P,B) ;  GENRX(XLA,NXTRG,Q,B,P) END
              ELSE IF P < 0 THEN
                      BEGIN   GENRX(XLA, NXTRG, 0, 0, 0);
                      CODE[PC-1] := STRTBL[Q].LNK;  STRTBL[Q].LNK := PC-1;
                      END
              ELSE  GENRXLIT(XL,NXTRG,FPA.DSPLMT,0) ; (*NIL VALUE*)
              FPA := ZEROBL ;
              END ;

            INT,BOOL,CHRC:
              BEGIN  FINDMDRG ;
              IF FPA.DSPLMT = 0 THEN GENRR(XSR,NXTRG,NXTRG)
              ELSE GENRXLIT(XL,NXTRG,FPA.DSPLMT,0) ;
              FPA := ZEROBL ;
              END ;

            REEL:
               BEGIN
                  FINDFP;
                  GENRXDLIT(XLD,NXTRG,SCNST,SCNSTL,RCNST)
               END (* REEL *);

            PSET:
              BEGIN  FINDRP ;
              GENRSLIT(XLM,NXTRG,NXTRG+1,PCNST) ;
              END

            END (* CASE DTYPE *) ;

          VRBL := TRUE ;  VPA := RGS ;  RGADR := NXTRG ;  DRCT := TRUE ;
          END (* LOAD CONSTANT *) ;

      IF MDTAG = PMPI THEN
        BEGIN
        IF NOT ODD(RGADR) OR NOT AVAIL[RGADR-1] THEN
          BEGIN  AVAIL[RGADR] := TRUE ;
          FINDRP ;  GENRR(XLR,NXTRG+1,RGADR) ;
          RGADR := NXTRG+1 ;
          END ;
        RGADR := RGADR-1 ;
        AVAIL[RGADR] := FALSE
        END
      ELSE
       IF MDTAG = PDVI THEN
         BEGIN
         IF ODD(RGADR) OR NOT AVAIL[RGADR+1] THEN
           BEGIN  AVAIL[RGADR] := TRUE ;
           FINDRP ;  GENRR(XLR,NXTRG,RGADR) ;
           RGADR := NXTRG ;
           END ;
         AVAIL[RGADR+1] := FALSE ;
         IF ASM THEN  GENRR(XSRDA,RGADR,32)  ELSE  GENRS(XSRDA,RGADR,0,32,0) ;
         END

       END (*WITH STE DO*) ;

    END (* LOAD *) ;


  PROCEDURE GETADR ;


     (* IF PASSED THE ADR. OF AN ITEM , THIS ROUTINE RETURNS A <Q,B,P> ADR. *)
     (* INDIRECTIONS ARE NOT DEREFERENCED HERE.                             *)
     (* ------------------------------------------------------------------- *)

     VAR R: RGRNG ;

     BEGIN  R := 0 ;
     WITH STE DO
       BEGIN  IF DRCT AND (DTYPE <> ADR) THEN  ERROR(602) ;
       IF VRBL THEN

           IF VPA = RGS THEN  R := RGADR

           ELSE  (*IF VPA = MEM THEN*)
                 BEGIN  P := MEMADR.LVL ;  Q := MEMADR.DSPLMT ;
                 BASE(Q, P, B) ;
                 GENRX(XL, TXRG, Q, B, P) ;   R := TXRG
                 END ;

       (* NOW THE VARIABLE PORTION OF THE ADR., IF ANY, IS IN TXRG *)

       Q := FPA.DSPLMT ;  P := FPA.LVL ;
       IF R > 0 THEN
         BEGIN
         IF (Q < 0) OR (Q > SHRTINT) THEN
           BEGIN  GENRXLIT(XA,R,Q,0) ;  Q := 0  END ;
         B := 0 ;
         IF P = CURLVL THEN  B := LBR
         ELSE IF P = 1 THEN  B := GBR
         ELSE IF P > 0 THEN  GENRX(XA,R,DISPLAY+4*P,GBR,0) ;
         P := R ;
         END
       ELSE (* NO INDEX OR VPA *)
         BASE(Q,P,B) ;

       END (*WITH STE*)
     END (*GETADR*) ;


  PROCEDURE GETOPERAND(VAR STE: DATUM; VAR Q1 : ADRRNG; VAR P1, B1: RGRNG) ;

   (* IF PASSED AN ITEM, THIS ROUTINE RETURNS ITS <Q,B,P> ADDRESS *)
   (* ----------------------------------------------------------- *)

    BEGIN
    WITH STE DO
      IF VRBL THEN

        IF DRCT THEN
          IF FPA.DSPLMT <> 0 THEN LOAD(STE)
          ELSE
            BEGIN  IF VPA = MEM THEN
                     BEGIN  Q1 := MEMADR.DSPLMT ;  P1 := MEMADR.LVL ;
                     BASE(Q1,P1,B1) ;
                     END
            (* THE VPA=REG NOT HANDLED HERE *)
            END
        ELSE (*NOT DIRCT*)
          BEGIN
          GETADR(STE,Q1,P1,B1) ;
          IF VPA = RGS THEN  AVAIL[RGADR] := TRUE ;
          END

      ELSE (*^ VRBL*)  (*MAY NOT HAVE ANY FUNCTION ANY MORE*)
        BEGIN  IF DTYPE <> ADR THEN ERROR(602) ;
        Q1 := FPA.DSPLMT ;  P1 := FPA.LVL ;
        BASE(Q1,P1,B1) ;
        END ;
    END (*GETOPERAND*) ;


  PROCEDURE STORE(STP: STKPTR; INDRCT: BOOLEAN) ;

    (* STORE THE STACK ELEMENT IN THE LOCATION DENOTED BY : *)
    (* IF INDRCT  THEN  2_ND TOP STACK ELEMENT              *)
    (* ELSE P_Q FIELDS OF THE CURRENT INSTRUCTION           *)
    (* ---------------------------------------------------- *)

    VAR B : RGRNG ;

    BEGIN
    (* LOADS THE ELEMENT INTO A REGISTER *)
    CLEAR_REG := STK[STP].DTYPE <> OPNDTYPE ;
    LOAD(STK[STP]) ;  CLEAR_REG := TRUE ;

    IF INDRCT THEN
      BEGIN  IF NOT STK[STP-1].DRCT THEN LOAD(STK[STP-1]) ;
      GETADR(STK[STP-1],Q,P,B) ;
      FREEREG(STK[STP-1]) ;
      END
    ELSE  BASE(Q,P,B) ;

    WITH STK[STP] DO
      BEGIN
      IF VRBL THEN
        IF (NOT DRCT) OR (VPA = MEM) THEN
          IF DTYPE <> OPNDTYPE THEN ERROR(601) ;

        CASE OPNDTYPE OF

        ADR,INT:   BEGIN  GENRX(XST,RGADR,Q,B,P) ;  AVAIL[RGADR] := TRUE END ;

        BOOL,CHRC: BEGIN  GENRX(XSTC,RGADR,Q,B,P) ;  AVAIL[RGADR] := TRUE END ;

        REEL:
          BEGIN
            GENRX(XSTD,RGADR,Q,B,P) ;
            AVAILFP[RGADR] := TRUE
          END  (* REEL *) ;

        PSET:      BEGIN
                   IF B > 0 THEN  IF P > 0 THEN GENRR(XAR,P,B) ELSE P := B ;
                   GENRS(XSTM,RGADR,RGADR+1,Q,P) ;
                   AVAIL[RGADR] := TRUE ;  AVAIL[RGADR+1] := TRUE ;
                   END

        END (* CASE OPNDTYPE *)

      END (* WITH STK... *)

    END (* STORE *) ;


" PROCEDURE PUTLNM(Q : LINE_NUM) ;

    BEGIN  (* TO OUTPUT THE SOURCE PROGRAM LINE NUMBER *)
    IF RUNPROFILE AND NEWLINE THEN
      BEGIN  WRITELN(PRR,'LNM':4,Q:6) ;
      CURLINE := Q ;  NEWLINE := FALSE ;
      END ;
    END (*PUTLNM*) ;  "


  PROCEDURE CALLSUB(FPARM, LPARM : STKPTR) ;

  (* TO 'UNLOAD' REGISTER STACK ONTO ALLOCATION STACK PRIOR TO A CALL *)
  (* ---------------------------------------------------------------- *)

    VAR  I : STKPTR ;  PRMOFST : ADRRNG ;
"NH"   FPR : 0 .. FPCNT ;

    BEGIN  (* WE CAN LOAD EVERYTING STACKED SO FAR TO AVOID POSSIBLE SIDE EFFECT
              DUE TO CURRENT CALL MODIFYING THE PRECEDING PARAMETERS          *)
    (* PUT THE SUBROUTINE PARAMETERS ON THE STACK *) ;
    IF DATA_SIZE < 4096 THEN  GENRX(XLA,TRG1,DATA_SIZE,LBR,0)
    ELSE
      BEGIN  GENRR(XLR,TRG1,LBR); GENRXLAB(XA,TRG1,SEGSZE,-1) END;

    PRMOFST := LCAFTMST ;  CLEAR_REG := FALSE ;
    IF ODD(P) THEN
      IF NOT(OPNDTYPE IN [FORT,FBOOL,FINT,FREAL]) THEN
        PRMOFST := LCAFTMST+FPSIZE ;  (* REAL FUNC SAVE FPRS *)
    FOR I := FPARM TO LPARM DO
      BEGIN  LOAD(STK[I]) ;
        WITH STK[I] DO
        CASE DTYPE OF

          BOOL, CHRC: BEGIN  GENRX(XSTC,RGADR,PRMOFST,TRG1,0) ;
                      PRMOFST := PRMOFST+"INTSIZE" BOOLSIZE ;
                      END ;

          INT, ADR:   BEGIN  PRMOFST := ALIGN(PRMOFST,INTSIZE) ;
                      GENRX(XST,RGADR,PRMOFST,TRG1,0) ;
                      PRMOFST := PRMOFST+INTSIZE ;
                      END ;

          REEL :      BEGIN   PRMOFST := ALIGN(PRMOFST, REALSIZE) ;
                      GENRX(XSTD,RGADR,PRMOFST,TRG1,0) ;
                      PRMOFST := PRMOFST+REALSIZE ;
                      END ;

          PSET :      BEGIN   PRMOFST := ALIGN(PRMOFST, INTSIZE) ;
                      GENRS(XSTM,RGADR,RGADR+1,PRMOFST,TRG1) ;
                      PRMOFST := PRMOFST+SETSIZE ;
                      END

        END (* CASE DTAYPE OF ...,  WITH STK[I]...  *) ;
      FREEREG(STK[I]) ;
      END (* FOR I := FPARM.. *) ;

    IF OPNDTYPE IN [FORT,FBOOL,FINT,FREAL] THEN
      BEGIN
      GENSI(XMVI,PRMOFST-ADRSIZE,TRG1,128) ;
      (* THIS FLAGS THE END OF PARAMETER ADDRESS LIST TO FORTRAN *)
      GENRX(XST, TRG13, 4, TRG1, 0) ;        (* SAVE R13 *)
"NH"  GENRX(XST,TRG1,8,TRG13,0);  GENRR(XLR,TRG13,TRG1);
"NH"  FPR := 0;  PRMOFST := ALIGN(PRMOFST,REALSIZE);
"NH"  REPEAT  FPR := FPR + 2;
"NH"     IF NOT AVAILFP[FPR] THEN BEGIN
"NH"        GENRX(XSTD,FPR,PRMOFST,TRG13,0);  PRMOFST := PRMOFST+REALSIZE;
"NH"     END;
"NH"  UNTIL FPR = FPCNT;
      GENRX(XLA, TRG1, LCAFTMST, TRG1, 0) ;  (* R1 POINTS TO PARM LIST NOW *)
      END ;

    GENRXLAB(XL,JREG,LBL2,-3) ;   (* BRANCH TO THE CALLED ROUTINE *)
    GENRR(XBALR,RTREG,JREG) ;

    IF OPNDTYPE IN [FORT,FBOOL,FINT,FREAL] THEN
"NH"  BEGIN
"NH"     REPEAT
"NH"        IF NOT AVAILFP[FPR] THEN BEGIN
"NH"           PRMOFST := PRMOFST-REALSIZE; GENRX(XLD,FPR,PRMOFST,TRG13,0);
"NH"        END;
"NH"        FPR := FPR - 2;
"NH"     UNTIL FPR = 0;
"NH"     GENRX(XL,TRG13,4,TRG13,0);
"NH"  END ;

    CLEAR_REG := TRUE ;
    END ;


    PROCEDURE GOTOCSP ;
      BEGIN
      IF NOT CSPREGACTIVE THEN        (* (RE)LOAD PROCADR AND FUNC NUMBER *)
        BEGIN
        LBL3.NAM := '$PASCSP ' ;  LBL3.LEN := 7 ;
        GENRXLAB(XL,TRG15,LBL3,-3) ;
        END ;
      IF CSP <> OLDCSP THEN  GENRX(XLA,TRG1,CSP*4,0,0) ;

      IF NOT FILREGACTIVE THEN
        IF CSP IN [PRES,PREW,PGET,PPUT,PELN,PEOF,PRLN,PWLN,PPAG,
"NH"               PSKP,PLIM,PRDB,PWRB,
                   PRDC,PWRC,PRDI,PWRI,PRDS,PWRS,PRDR,PWRR,PFDF]  THEN
          WITH STK[TOP-1] DO
            BEGIN
            "IF DTYPE <> ADR THEN ERROR(602) ;  (* TEST PHASE ONLY *) "
            IF VRBL THEN  BEGIN  Q1 := MEMADR.DSPLMT ;  P1 := MEMADR.LVL  END
            ELSE          BEGIN  Q1 := FPA.DSPLMT ;  P1 := FPA.LVL  END ;
            BASE(Q1,P1,B1) ;
            IF VRBL THEN  GENRX(XL,FILADR,Q1,B1,P1)
            ELSE          GENRX(XLA,FILADR,Q1,B1,P1) ;
            (* ALTERNATE:  IF NOT VRBL: GENRX(XLA,FILADR,FPA.DSPLMT,0,0) *)
            FILREGACTIVE := TRUE ;
            END ;
      GENRR(XBALR,TRG14,TRG15) ;
      CSPREGACTIVE := TRUE ;  OLDCSP := CSP ;
      END (*GOTOCSP*) ;


  PROCEDURE CALLSTNDRD ;

  (* TO CALL A STANDARD PROCEDURE *)
  (* ---------------------------- *)

    VAR  Q1,P1,B1 : ADRRNG ;



    PROCEDURE FILESETUP(PRMCNT: RGRNG) ;

    (* TO SET UP PARAMETERS FOR THE FILE I/O AND CALL THE I/O ROUTINE *)
    (* -------------------------------------------------------------- *)


      VAR  I : RGRNG ;
           STP: STKPTR;

      BEGIN
      STP := TOP-PRMCNT+1 ;
      TOP := STP ;           (* POINTING TO NEXT AVAILABLE STACK ELEMENT *)
      IF PRMCNT >= 2 THEN  (*POTENTIAL REGISTER CONFLICT*)
        WITH STK[STP+1] DO
          IF VRBL AND (VPA = RGS) AND (RGADR = 2) THEN
            BEGIN  FINDRG ;  GENRR(XLR,NXTRG,2) ;
            AVAIL[NXTRG] := FALSE ;  AVAIL[2] := TRUE ;  RGADR := NXTRG ;
            END ;

      FOR I := 2 TO PRMCNT+1 DO
        BEGIN
        LOAD( STK[STP]) ;
        WITH STK[STP] DO
          IF DTYPE <> REEL THEN

            BEGIN (*THE COMMON CASE*)
            IF RGADR <> I THEN
                IF AVAIL[I]  THEN
                  BEGIN
                  GENRR(XLR,I,RGADR) ;
                  AVAIL[RGADR] := TRUE ;  AVAIL[I] := FALSE ;  RGADR := I ;
                  END
                ELSE  ERROR(259)
            END

          ELSE (*DTYPE = REEL, I.E. WRR*)

            BEGIN
            IF RGADR <> I THEN
              IF AVAILFP[I] THEN  GENRR(XLDR,I,RGADR)
              ELSE  ERROR(259) ;
            AVAILFP[RGADR] := TRUE ;  AVAIL[I] := FALSE ;
            RGADR := I ;  (*KLUDGE TO RELEASE THE FIX. REG. LATER*)
            END ;
        STP := STP+1 ;
        END (* FOR I...*) ;

      GOTOCSP ;
      FOR I := 2 TO PRMCNT+1 DO
        BEGIN  STP := STP-1 ;  AVAIL[STK[STP].RGADR] := TRUE  END ;
      END (*FILESETUP*) ;


    BEGIN (*CALLSTNDRD*)   TOP := TOP-1 ;
    (* -------------- *)

    IF CSP = SPCNT THEN  BEGIN WRITE(' --> ',NMCDE) ;  ERROR(607)  END ;

     CASE CSP OF

      PATN,PEXP,PSIN,PCOS,PLOG,PSQT :
        BEGIN  WRITE(' --> ',NMCDE);  ERROR(607)  END;
¯"""
"NH"  PATN,PEXP,PSIN,PCOS,PLOG,PSQT :
"NH"    WITH STK[TOP] DO
"NH"    BEGIN
"NH"       IF VRBL THEN GETOPERAND( STK[TOP], Q1, P1, B1 )
"NH"       ELSE LOAD( STK[TOP] );
"NH"       IF DATA_SIZE < 4096 THEN
"NH"          GENRX(XLA,TRG1,DATA_SIZE,LBR,0)
"NH"       ELSE BEGIN
"NH"          GENRR(XLR,TRG1,LBR);
"NH"          GENRXLAB(XA,TRG1,SEGSZE,-1);
"NH"       END;
"NH"       GENRX(XST,TRG13,4,TRG1,0);
"NH"       GENRX(XST,TRG1,8,TRG13,0);
"NH"       IF (VPA = RGS) AND DRCT THEN
"NH"          BEGIN
"NH"             GENRX(XSTD,RGADR,LCAFTMST,TRG1,0);
"NH"             GENRX(XLA,TRG0,LCAFTMST,TRG1,0);
"NH"             Q1 := LCAFTMST + REALSIZE;
"NH"          END
"NH"       ELSE BEGIN
"NH"             FINDFP;
"NH"             RGADR := NXTRG;
"NH"             VPA := RGS;  DRCT := TRUE;  DTYPE := REEL;
"NH"             GENRX(XLA,0,Q1,P1,B1);
"NH"             Q1 := LCAFTMST;
"NH"          END;
"NH"       GENRR(XLR,TRG13,TRG1);
"NH"       GENRX(XST,TRG0,Q1,TRG13,0);
"NH"       GENSI(XMVI,Q1,TRG13,128);
"NH"       GENRX(XLA,TRG1,Q1,TRG13,0);
"NH"       B1 := 2;
"NH"       REPEAT   (*  SAVE ALL ACTIVE F.P. REGS  *)
"NH"          IF B1 <> RGADR THEN IF NOT AVAILFP[B1] THEN
"NH"          BEGIN
"NH"             Q1 := Q1 + REALSIZE;  GENRX(XSTD,B1,Q1,TRG13,0);
"NH"          END;
"NH"          B1 := B1 + 2;
"NH"       UNTIL B1 > FPCNT;
"NH"       WITH LBL2 DO
"NH"          IF CSP = PATN THEN
"NH"             BEGIN  NAM := 'DATAN   ';  LEN := 5;  END
"NH"          ELSE IF CSP = PSQT THEN
"NH"             BEGIN  NAM := 'DSQRT   ';  LEN := 5;  END
"NH"          ELSE BEGIN
"NH"             NAM := 'D       ';  LEN := 4;
"NH"             FOR B1 := 1 TO 3 DO
"NH"                NAM[B1+1] := CSPTBL[CSP,B1];
"NH"          END;
"NH"       GENRXLAB(XL,JREG,LBL2,-3);
"NH"       GENRR(XBALR,RTREG,JREG);
"NH"       B1 := FPCNT;
"NH"       REPEAT   (* RELOAD ACTIVE FP REGS  *)
"NH"          IF B1 <> RGADR THEN IF NOT AVAILFP[B1] THEN
"NH"          BEGIN
"NH"             GENRX(XLD,B1,Q1,TRG13,0);  Q1 := Q1 - REALSIZE;
"NH"          END;
"NH"          B1 := B1 - 2;
"NH"       UNTIL B1 = 0;
"NH"       GENRX(XL,TRG13,4,TRG13,0);
"NH"       GENRR(XLDR,RGADR,0);
           FPA := ZEROBL;  VPA := RGS;  DRCT := TRUE;
"NH"       TOP := TOP + 1;  OLDCSP := PSIO;
"NH"       CSPREGACTIVE := FALSE;
"NH"    END (* PATN,PEXP,... *) ;
"""
"NH"  PCLK :
"NH"    WITH STK[TOP] DO
"NH"    BEGIN
"NH"       LOAD(STK[TOP]);
"NH"       GENRR(XLR,0,RGADR);
"NH"       GOTOCSP;
"NH"       GENRR(XLR,RGADR,0);
"NH"       TOP := TOP + 1;  OLDCSP := PSIO;
"NH"    END (* PCLK *) ;
"NH"
"NH"  PMSG :
"NH"    BEGIN
"NH"       LOAD( STK[TOP-1] );
"NH"       WITH STK[TOP-1] DO
"NH"       BEGIN
"NH"          IF RGADR <> 2 THEN
                 IF AVAIL[2] THEN
                    BEGIN  GENRR(XLR,2,RGADR);
                    AVAIL[RGADR] := TRUE;  AVAIL[2] := FALSE;
                    RGADR := 2;
                    END
                 ELSE  ERROR(259);   (* ASSUMING THE CURRENT SIMPLE FORMAT *)
"NH"       END;
"NH"       LOAD( STK[TOP] );
"NH"       WITH STK[TOP] DO
"NH"       BEGIN
"NH"          IF RGADR <> 3 THEN
                 IF AVAIL[3] THEN
                    BEGIN  GENRR(XLR,3,RGADR);
                    AVAIL[RGADR] := TRUE;  AVAIL[3] := FALSE;
                    RGADR := 3;
                    END
                 ELSE  ERROR(259);
"NH"       END;
"NH"       GOTOCSP;
"NH"       AVAIL[2] := TRUE;  AVAIL[3] := TRUE;
           TOP := TOP-1;
"NH"    END (* PMSG *) ;

      PXIT :
        WITH STK[TOP] DO
          BEGIN  LOAD(STK[TOP]) ;  AVAIL[RGADR] := TRUE ;
          IF RGADR <> 2 THEN GENRR(XLR,2,RGADR) ;
          GOTOCSP ;
          END (*PXIT*) ;

      PTRP :
        BEGIN
        WITH STK[TOP] DO
          IF (NOT DRCT) OR (DTYPE <> ADR) THEN ERROR(602)
          ELSE
            BEGIN  GETOPERAND(STK[TOP],Q1,P1,B1)  ;
            IF VRBL THEN
              IF VPA = MEM THEN  GENRX(XL,1,Q1,B1,P1)
              ELSE  BEGIN  GENRR(XLR,1,RGADR) ; AVAIL[RGADR] := TRUE END
            ELSE  GENRX(XLA,1,Q1,B1,P1) ;
            END ;
        TOP := TOP-1 ;
        WITH STK[TOP] DO
          IF NOT DRCT THEN ERROR(602)
          ELSE
            IF NOT VRBL THEN GENRXLIT(XL,0,FPA.DSPLMT,0)
            ELSE
              BEGIN  GETOPERAND(STK[TOP],Q1,P1,B1) ;
              IF VPA = MEM THEN  GENRX(XL,0,Q1,B1,P1)
              ELSE  BEGIN GENRR(XLR,0,RGADR) ;  AVAIL[RGADR] := TRUE ; END ;
              END ;
        LBL3.NAM := '$PASTRAP' ;  LBL3.LEN := 8 ;  GENRXLAB(XL,JREG,LBL3,-3) ;
        GENRR(XBALR,RTREG,JREG) ;
        END (*PTRP*) ;

      PSIO :
          BEGIN
          IF NOT AVAIL[FILADR] THEN  IF FILECNT = 0 THEN  ERROR(259) ;
          AVAIL[FILADR] := FALSE ;
          FILREGACTIVE := FALSE ;  FILECNT := FILECNT+1 ;
          OLDCSP := PSIO ;
          TOP := TOP+1 ;    (* TO CANCEL OUT PREVIOUS SUBTRACT OPERATION *)
          END (*PSIO*) ;

      PEIO :
        BEGIN    (* RELEASE FILE ADR REG ETC. *)
        FILECNT := FILECNT-1 ;
        IF FILECNT = 0 THEN AVAIL[FILADR] := TRUE ;
        FILREGACTIVE := FALSE ;  OLDCSP := PEIO ;
        (* TOP := TOP-1 IS DONE AT ENTRY TO CALLSTNDRD  *)
        END (*PEIO*) ;

      PELN,PEOF :
        BEGIN  FILESETUP(0) ;
        FINDRG ;  GENRR(XLR,NXTRG,TRG0) ; (*LOAD THE RETURNED VALUE*)
        WITH STK[TOP-1] DO   (* RETURNED VALUE REPACES THE FILA ADR ENTRY *)
          BEGIN   DTYPE := BOOL ;  VRBL := TRUE ;  DRCT := TRUE ;
          FPA := ZEROBL ;  VPA := RGS ;  RGADR := NXTRG ;
          TOP := TOP+1 ;     (* THIS WILL BE CORRECTED BY THE PENDING 'EIO' *)
          END
        END (*PELN.PEOF*) ;

      PGET,PPUT,PRLN,PWLN,PRES,PREW,PPAG :
        BEGIN
        FILESETUP(0) ;
        END ;

      PRDC,PRDI,PRDR,PFDF,PSKP,PLIM,PRDB :
        BEGIN
        FILESETUP(1) ;
        END ;

      PRDS,PWRC,PWRI,PWRB :
        BEGIN
        FILESETUP(2) ;
        END ;

      PWRS,PWRR :
        BEGIN
        FILESETUP(3) ;
        END

      END (*CASE CSP...*) ;

    END (*CALLSTNDRD*) ;


    PROCEDURE COPERATION ;

    (* CONTROL AND BRANCH INSTRUCTIONS *)
    (* ------------------------------- *)


    PROCEDURE MKLBL(VAR LBL: PLABEL; Q: ADRRNG) ;

      (* ASSUMES     0 <= Q <= 9999999 *)
      VAR  I :  1..8 ;

      BEGIN
      I  := FLDW(Q)+1 ;
      LBL.NAM := 'L       ' ;  LBL.LEN := I ;
        REPEAT
        LBL.NAM[I] := CHR( (Q MOD 10) + ORD('0') ) ;  Q := Q DIV 10 ;
        I := I-1 ;
        UNTIL Q = 0 ;
      END (* MKLBL *) ;

    PROCEDURE ADDLNP(PCDIF : INTEGER) ;

    (* TO ADD A (SOURCE) LINE POINTER TO THE POINTER TABLE *)
    (* --------------------------------------------------- *)

    BEGIN
    IF NXTLNP < MXLNP THEN
      IF LASTPCDIF >= 0 THEN
        BEGIN  CODE[MXCODE+NXTLNP] := LASTPCDIF*SL8 + PCDIF ;
        NXTLNP := NXTLNP+1 ;
        LASTPCDIF := -1 ;
        END
      ELSE  LASTPCDIF := PCDIF ;
    END (*ADDLNP*) ;


    PROCEDURE UPDLNTBL(PCDIF : ICRNG) ;

    (* TO UPDATE LINE POINTER TABLE FOR THE RUN TIME DEBUG OPTION *)
    (* ---------------------------------------------------------- *)

      BEGIN
      IF PCDIF >= 250 THEN (* ENTER ESCAPE MODE *)
        BEGIN
        ADDLNP(254 (*ESCAPE CHAR*) ) ;
        ADDLNP(PCDIF DIV 256) ;   ADDLNP(PCDIF MOD 256) ;
        END
      ELSE
        ADDLNP(PCDIF) ;
      END ;



    PROCEDURE INIT_CSECT ;

    (* TO INITIALIZE OBJECT CODE TABLES AND POINTERS *)
    (* --------------------------------------------- *)

    VAR  I : LBLRNG ;   J : INTEGER ;

      BEGIN

      FOR I := 0 TO LBLCNT DO
        WITH LBLTBL[I] DO
          BEGIN  DEFINED := FALSE ;  LNK := 0  END ;

      INTTBL[0].LNK := 0 ;  NXTINT := 0 ;
      DBLTBL[0].LNK := 0 ;  NXTDBL := 0 ;
      PRCTBL[0].NAME := LBL1.NAM ;  PRCTBL[0].LNK := 0 ; PRCTBL[1].LNK := 0 ;
      NXTPRC := 1 ;  NXTSTR := 0 ;
      PC := 0 ;  NXTSLOC := MXCODE ;  MINLBL := LBLMAP(SEGSZE.NAM);
      LASTPC := 0 ;  LASTPCDIF := -1 ;
      J := 0 ;
      IF CURLVL = 1 THEN (*MAINBLK*)  J := HDRLNGTH ;
      GENRX(XBC,ANYCND,12+J,0,JREG) ;          (* SKIP AROUND CSECT NAME *)
      PC := 6+(J DIV 2) ;  (* PRECEEDING 'GENRX' USES THE VALUE OF 'PC' *)
      CODE[2] := (7+J)*SL8 + "EBCDIC["ORD(CURPNAME[1])"]" ;  (*ID LENGTH FIELD*)

      FOR I := 1 TO 3 DO
        CODE[I+2] := "EBCDIC[" ORD(CURPNAME[I*2]) "]" * SL8 +
                     "EBCDIC[" ORD(CURPNAME[2*I+1]) "]" ;
      (*CODE[5] := 0 ;     PROC SIZE FIELD SET BY THE EPILOG IF NEEDED *)

      FOR I := 1 TO J DIV 2 DO
        CODE[5+I] := ORD(PROGHDR[I*2-1]) * SL8 + ORD(PROGHDR[I*2]) ;

      CODE[MXCODE] := CURPNO;  (* UNIQUE PROC NO *)
      IF DEBUG THEN
        BEGIN
        CODE[MXCODE+1] := LASTLN ;
        FOR I := 2 TO 7 DO
          CODE[MXCODE+I] := "EBCDIC[" ORD(CURPNAME[I*2-3]) "]"*SL8 +
                            "EBCDIC[" ORD(CURPNAME[I*2-2]) "]" ;
        NXTLNP := 8 ;
        END
      ELSE NXTLNP := 0 ;

      END (*INIT_CSECT*) ;


    PROCEDURE GEN_CSECT ;

    (* TO MERGE LITERAL POOLS AND GENERATE ONE OBJECT MODULE FOR THIS PROC *)
    (* ------------------------------------------------------------------- *)

      CONST  XESD    = 46523076   ;  (*EBCDIC FOR  2Ý'ESD' *)
             XTXT    = 48490467   ;  (*               TXT  *)
             XRLD    = 47829956   ;  (*               RLD  *)
             XEND    = 46519748   ;  (*               END  *)

             BLNK1   = 64         ;  (* EBCDIC FOR ' '     *)
             BLNK2   = 16448      ;  (*            '  '    *)
             BLNK3   = 4210752    ;  (*            '   '   *)
             BLNK4   = 1077952576 ;  (*            '    '  *)

      VAR  I, J      : -1000..1000 ;
           TPC, QPC, OBJEND : INTEGER ;
           LNGTH     : STRLRNG  ;
           VSL16     : INTEGER ;

           BLNK80    : ARRAY[1..80] OF CHAR ;

           CARD      : RECORD  CASE DUMMY : INTEGER OF
                       1: (C : ARRAY[1..80] OF CHAR) ;   (*CHAR CARD IMAGE*)
                       2: (I : ARRAY[1..20] OF INTEGER)  (*INT. CARD IMAGE*)
                       END ;


      BEGIN  (*GEN_CSECT*)

      (* PROCESS REAL/SET POOL *)



      TPC := PC ;  IF ODD(TPC) THEN  TPC := TPC+1 ;  (* WORD ALIGNMENT *)
      IF NXTDBL > 0 THEN
        IF (TPC MOD 4) <> 0 THEN  TPC := TPC+2 ;     (* DOUBLE WORD ALIGNMENT *)
      FOR QPC := PC TO TPC-1 DO  CODE[QPC] := 0 ;
      PC := TPC ;

      FOR I := 0 TO NXTDBL-1 DO
        WITH DBLTBL[I] DO
          BEGIN   TPC := LNK ;  LNK := BASE_DSPLMT(PC) ;
          REPEAT  QPC := CODE[TPC] ;  CODE[TPC] := LNK ;  TPC := QPC
          UNTIL TPC = 0 ;
          I_S_R.S := VAL ;
          CODE[PC] := I_S_R.I1 DIV SL16 ;  CODE[PC+1] := I_S_R.I1 MOD SL16 ;
          CODE[PC+2] := I_S_R.I2 DIV SL16 ;  CODE[PC+3] := I_S_R.I2 MOD SL16 ;
          PC := NEXTPC(4) ;
          END (* FOR..., WITH... *) ;

      (* PROCESS EXTERNAL REFERENCES  *)


      FOR I := 0 TO NXTPRC-1 DO
        WITH PRCTBL[I] DO
          IF LNK > 0 THEN
            BEGIN   TPC := LNK ;  LNK := BASE_DSPLMT(PC) ;
              REPEAT
              QPC := CODE[TPC] ;  CODE[TPC] := LNK ;  TPC := QPC ;
              UNTIL TPC = 0 ;
            LNK := PC ;  " WRITELN(' *** ADCON#, ADDR.',I:3,PC*2) ; "
            CODE[PC] := 0 ;  CODE[PC+1] := 0 ;  PC := NEXTPC(2) ;
            END (* FOR..., IF...,  WITH... *) ;

      (* PROCESS INTEGER (FULL/HALF) POOL *)


      IF LBLTBL[MINLBL].LNK <> 0 THEN
        WITH INTTBL[NXTINT] DO
          BEGIN    (* 'Q' IS THE SIZE OF THE CURRENT ROUTINE'S DATA AREA *)
          VAL := Q ;  LNK := LBLTBL[MINLBL].LNK ;  NXTINT := NXTINT+1
          END ;

      FOR I := 0 TO NXTINT-1 DO
        WITH INTTBL[I] DO
          BEGIN  TPC := LNK ;  LNK := BASE_DSPLMT(PC) ;
         "  WRITELN(' *** I, PC*2, INTTBL[I].VAL, .LNK',I,PC*2,VAL,TPC);"
            REPEAT  " WRITELN(' *** TPC,QPC',TPC,QPC) ;   "
            QPC := CODE[TPC] ; CODE[TPC] := LNK ;
            IF CODE[TPC-1] < 0 THEN
              BEGIN  CODE[TPC] := LNK+2 ;  CODE[TPC-1] := -CODE[TPC-1]  END ;
            TPC := QPC
            UNTIL TPC = 0 ;

          CODE[PC] := VAL DIV SL16 ;  CODE[PC+1] := VAL MOD SL16 ;
          PC := NEXTPC(2) ;
          END (* FOR..., WITH... *) ;

      (* PROCESS STRING POOL *) ;


      TPC := PC ;
      IF DEBUG THEN    (* WORD ALIGN THE CSECT *)
        BEGIN

        IF ODD(NXTSLOC) THEN
          BEGIN  NXTSLOC := NXTSLOC-1 ;
          CODE[NXTSLOC] := 0 ;  TPC := TPC+1
          END ;

        CODE[5] := (PC+MXCODE-NXTSLOC)*2 ;  (* PROC SIZE FIELD *)
        ADDLNP(255) ; ADDLNP(255) ;         (* COMPLETE LN TABLE *)
        CODE[MXCODE+NXTLNP] := 0 ;
        END ;

      IF  NOT LARGE_PROC  THEN
        IF PC+MXCODE-NXTSLOC > (MXCODE DIV 2) THEN
          ERROR(609 (*SHORT PROC TOO LONG*) ) ;

      IF PC > NXTSLOC THEN  BEGIN  ERROR(253) ;  EXIT(253)  END ;
        FOR I := NXTSTR-1 DOWNTO 0 DO
          WITH STRTBL[I] DO
            BEGIN
            CODE[LNK] := BASE_DSPLMT(TPC) ;  TPC := TPC+(LNGTH+1) DIV 2
            END ;
      (* STRING POOL IS NOW CODE[NXTSLOC]..CODE[MXCODE-1] *)

   (*  WRITELN(' ***',PC:5,NXTSLOC:6,NXTINT:4,NXTDBL:4,NXTSTR:4,
                      NXTPRC:4,MINLBL:8) ;  *)

      (* OUTPUT THE OBJECT CODE   *)


      FOR I := 1 TO 80 DO  BLNK80[I] := CHR(BLNK1) ;

      (* OUTPUT THE 'ESD' ENTRIES *)

      CARD.C := BLNK80 ;
      CARD.I[1] := XESD ;  CARD.I[4] := BLNK2*SL16+ 01 ;  (*FIRST ESDID*)
      I := 0 ;  LNGTH := 0 ;
"NH"  IF CURLVL = 1 THEN  (* IF $MAINBLK, ADD $PASENT TO ESD ITEMS *)
"NH"     BEGIN  PRCTBL[NXTPRC].NAME := '$PASENT ';
"NH"            NXTPRC := NXTPRC + 1;                 END;

        REPEAT  (* SCAN OVER ALL ENTRIES (OF PROCEDURES) *)

        WITH PRCTBL[I] DO
          FOR J := 1 TO 8  DO CARD.C[16+LNGTH+J] := "CHR(EBCDIC["NAME[J]"])" ;

        I := I+1 ;                       (*THIS IS NOW THE ESDID*)
        CARD.I[LNGTH DIV 4 +7] := 0 ;     (*TYPE-ADDRESS (SD) FIELD*)
        IF I = 1 THEN  CARD.I[8] := BLNK1*SL24+ 00   (*CSECT LNGTH ON END CARD*)
        ELSE
          BEGIN
          CARD.C[25+LNGTH] := CHR(2);  CARD.I[8+(LNGTH DIV 4)] := BLNK4 (* ER *)
          END ;
        LNGTH := LNGTH+16 ;

        IF (LNGTH >= 48) OR (I >= NXTPRC) THEN     (*TIME TO OUPUT THE BUFFER*)
          BEGIN
          CARD.I[3] := BLNK2*SL16 +LNGTH ;
          FOR J := (LNGTH DIV 4)+5 TO 16 DO  CARD.I[J] := BLNK4 ;
          WRITE(PRR,CARD.C) ;
          CARD.I[4] := BLNK2*SL16+ I+1  (*NEXT ESDID*) ;  LNGTH := 0 ;
          END ;

        UNTIL I >= NXTPRC ;

"NH"  IF CURLVL = 1 THEN NXTPRC := NXTPRC - 1;  (* UNDO EARLIER ADDITION *)

      (* OUTPUT THE 'TXT' CARDS   *)

      CARD.I[1] := XTXT ;  I := 0 ;  TPC := 0 ;  QPC := 0 ;
      OBJEND := MXCODE+NXTLNP ;

      CARD.I[4] := BLNK2*SL16 +01  ;        (*ESDID OF CURRENT CSECT *)
      LNGTH := 0 ;

        REPEAT
        CARD.I[LNGTH+5] := CODE[TPC]*SL16 + CODE[TPC+1] MOD SL16  ;
        LNGTH := LNGTH+1 ;  TPC := TPC+2 ;
        IF TPC = PC THEN TPC := NXTSLOC ;   (*STRING POOL FOLLOWS*)

        IF (LNGTH >= 14) OR (TPC >= OBJEND) THEN
          BEGIN
          CARD.I[2] := BLNK1*SL24 +QPC ;      (*FIRST BYTE ADDRESS*)
          CARD.I[3] := BLNK2*SL16 +LNGTH*4 ;    (* # OF TXT DATA BYTES*)
          FOR J := LNGTH+5 TO 18 DO  CARD.I[J] := BLNK4 ;
          WRITE(PRR,CARD.C) ;
          QPC := QPC+LNGTH*4 ;  LNGTH := 0 ;
          END (* IF... *) ;

        UNTIL TPC >= OBJEND ;

      (* OUTPUT THE 'RLD' ENTRIES *)


      CARD.C := BLNK80 ;  CARD.I[1] := XRLD ;  I := 0 ;  LNGTH := 0 ;

        REPEAT         (* SCAN OVER ALL EXTERNAL REFERENCES *)

        WITH PRCTBL[I] DO
          BEGIN   I := I+1 ;  (* I NOW BECOMES ESDID FOR THE CURRENT ENTRY *)
          IF LNK > 0 THEN     (* IMPLIES RECURSIVE CALL *)
            BEGIN  "WRITELN(' *** ADCON#, ADDRESS:',I:3,LNK*2) ; "
            CARD.I[LNGTH+5] := I*SL16+01 ;      (* 'P#', 'R#' FIELDS  *)
            CARD.I[LNGTH+6] := 28*SL24+LNK*2 ;  (* ADCON DISPLACEMENT *)
            LNGTH := LNGTH+2 ;
            IF (LNGTH >= 14) OR (I >= NXTPRC) THEN      (* OUTPUT THE BUFFER *)
              BEGIN  CARD.I[3] := BLNK2*SL16 +LNGTH*4 ; (* # OF RLD DATA BYTES*)
              FOR J := LNGTH TO 14 DO  CARD.I[LNGTH+5] := BLNK4 ;
              WRITE(PRR,CARD.C) ;  LNGTH := 0 ;
              END (* IF(LNGTH >... *) ;
            END (* IF LNK > 0 *) ;

          END (* WITH PRCTBL... *)

        UNTIL  I >= NXTPRC ;

      (* OUTPUT 'END' CARD WITH CSECT LENGTH *)


      CARD.C := BLNK80 ;
      CARD.I[1] := XEND ;  CARD.I[8] := QPC ;

"NH"  IF CURLVL = 1 THEN BEGIN  (* PUT ENTRY POINT ON END CARD *)
"NH"     CARD.I[2] := BLNK1*SL24;
"NH"     CARD.I[4] := BLNK2*SL16 + NXTPRC + 1;  END;
"NH"  WRITE(PRR,CARD.C);
      IF ASMVERB THEN
"NH"  WRITELN('0','****  PROC: ':16,PRCTBL[0].NAME,'  LEN:':6,PROC_SIZE:4,QPC:5,
              ' (P_STMTS, BYTES), EXT. REFS:',NXTPRC-1:3,', DOUBLES:',NXTDBL:3,
              ', INTS:',NXTINT:4, ', STRINGS:',NXTSTR:3,
              ', CHARS:',(MXCODE-NXTSLOC)*2:4 ) ;
      TOTALBYTES := TOTALBYTES+QPC ;
      END (*GEN_CSECT*) ;
      (*_________________________________________________________________*)


      BEGIN   (*COPERATION*)

        CASE OPC OF

        (* P_MACHINE PSEUDO OPS *)

        PLAB :
          BEGIN  "NEWLINE := TRUE ;"
          CASE_FLAG := FALSE ;   (* END OF BRANCH TABLE *)
          IF ASM THEN  WRITELN(PRR,LBL1.NAM,' DS 0H')
          ELSE  UPD_LBLTBL(PC, LBLMAP(LBL1.NAM), TRUE (*LABEL DEFINITION*)) ;

          CASE_FLAG := OLDOPC = PDEF ;   (* START BRANCH TABLE *)
          CSPREGACTIVE := FALSE ;
          END (*PLAB*) ;

        PLOC :
          BEGIN
          IF CURPNO >= 0 THEN
            BEGIN
            IF ASM THEN
              BEGIN  (* DO NOT PUT LINE # IN DANGAROUS PLACES *)
              IF NOT CASE_FLAG THEN
                 IF OLDOPC <> PDEF THEN WRITELN(PRR,' LOC', Q:7)
              END
            ELSE
              IF DEBUG THEN  (*FILL THE ENTRIES OF LINE PTR TABLE*)
              " CODE[NXTLOC] := PC*2 ; "
                FOR I := LASTLN TO Q-1 DO
                  BEGIN
                  UPDLNTBL(PC-LASTPC) ;
                  LASTPC := PC ;
                  END ;

         "  NXTLOC := NXTLOC+1 ; "
            END ;
          LASTLN := Q ;
          OPC := OLDOPC ;   (* TO TREAT THIS AS A NOOP *)
(*+####   PSEUDO_OP := TRUE ;                                            ####+*)
          END (*PLOC*) ;

        PDEF :
          BEGIN
          IF ASM THEN
            BEGIN  WRITELN(PRR, LBL1.NAM, ' DEF', Q:7) ;
            IF OLDOPC = PRET THEN  WRITELN(PRR,' PEND') ;
            END
          ELSE
            IF OLDOPC = PRET THEN
              BEGIN  GEN_CSECT ;  CURPNO := -1 ; END
            ELSE (* CTR/CASE EXPRESSION RANGE, PUT BOUNDS IN 'CONSTANT' TABLE *)
              UPD_INTTBL(LBLTBL[LBLMAP(LBL1.NAM)].LNK,Q,0) ;
          END (*DEF*) ;

        PCHK :
            WITH STK[TOP-1] DO
            IF VRBL THEN   (* GENERATE CODE FOR RUN TIME CHECK *)
              BEGIN
              IF NOT AVAIL[2] THEN
                IF NOT ((VPA = RGS) AND (RGADR = 2)) THEN
                  BEGIN   J := 0 ;  (* CLEAR GPR 2 *)

                  FOR I := TOP-2 DOWNTO 1 DO
                    WITH STK[I] DO
                      IF VRBL THEN
                        IF (NOT DRCT) OR (DTYPE <> REEL) THEN
                          IF (VPA = RGS) AND (RGADR = 2) THEN  J := I ;

                  IF J = 0 THEN  ERROR(259)
                  ELSE
                    WITH STK[J]  DO
                      BEGIN   FINDRG ;  (* TRADE GPR2 FOR ANOTHER ONE *)
                      IF DTYPE = PSET THEN  IF DRCT THEN  ERROR(259) ;
                      GENRR(XLR,NXTRG,2) ;  (* THIS FREES REG 2 *)
                      RGADR := NXTRG ;  AVAIL[2] := TRUE ;
                      END ;
                  END ;

              LOAD(STK[TOP-1]) ;
              IF NOT (DTYPE IN [INT,ADR,CHRC,BOOL]) THEN  ERROR(604) ;
              IF RGADR <> 2 THEN  (* LOAD RVALUE IN GPR 2 *)
                BEGIN
                IF NOT AVAIL[2] THEN ERROR(259) ;
                GENRR(XLR,2,RGADR) ;  AVAIL[RGADR] := TRUE ;
                RGADR := 2 ;  AVAIL[2] := FALSE ;
                END ;

              I_S_R.I1 := P ;  I_S_R.I2 := Q ;

                CASE OPNDTYPE OF

                INT :
                       BEGIN  GENRSLIT(XLM,TRG0,TRG1,I_S_R.S) ;  (*LOAD BOUNDS*)
                       GENRX(XBAL,RTREG,RNGCHK,GBR,0)
                       END ;
                INX :
                       BEGIN  GENRSLIT(XLM,TRG0,TRG1,I_S_R.S) ;  (*LOAD BOUNDS*)
                       GENRX(XBAL,RTREG,INXCHK,GBR,0) ;
                       END ;

                ADR :  IF P < 0 THEN GENRX(XBAL,14,PTACHK,GBR,0)
                       ELSE  GENRX(XBAL,14,PTRCHK,GBR,0) ;

                PSET : GENRX(XBAL,RTREG,SETCHK,GBR,0) ;

                PROC : BEGIN  GENRSLIT(XLM,TRG0,TRG1,I_S_R.S) ;
                       GENRX(XBAL,RTREG,PRMCHK,GBR,0) ;
                       END

                END (* CASE OPNDTYPE OF .. *)  ;
              CSPREGACTIVE := FALSE ; OLDCSP := PSIO ;
              (* INDICATE LOSS OF R1,R15 *)
              END (* IF VRBL *)

            ELSE (* ^ VAR,  I.E. CHECK A CONSTANT EXPRESSION *)

              BEGIN
              IF (FPA.DSPLMT < P) OR (FPA.DSPLMT > Q) THEN
                BEGIN
                ERROR(302) ;
                WRITELN(OUTPUT, '****':9, FPA.DSPLMT:9,
                                ' IS NOT IN THE RANGE:', P:9, Q:10 ) ;
                END ;
              END (*PCHK*) ;


        (* BRANCH/CONTROL INSTRUCTIONS *)

        PUJP :
          GENRXLAB(XBC,15,LBL2,0) ;

        PFJP :
          BEGIN  TOP := TOP-1 ;
          IF (BRCND >= 0) AND (NOT NEG_CND) THEN   (* COND. CODE IS ALIVE *)
            BRCND := 15-BRCND   "BRMSK[OLDOPC]"
          ELSE
          WITH STK[TOP] DO
            BEGIN  "IF DTYPE <> BOOL THEN  ERROR(605) ; "
            IF VRBL THEN
              BEGIN

              IF DRCT AND (VPA = MEM) THEN
                BEGIN  GETOPERAND(STK[TOP],Q1,P1,B1) ;
                IF B1 > 0 THEN  IF P1 > 0 THEN  GENRR(XAR,P1,B1)
                                ELSE  P1 := B1 ;
                GENSI(XTM,Q1,P1,1) ;
                BRCND := 8 (* BZ *) ;  IF NEG_CND THEN BRCND := 1 (* BO *) ;
                END
              ELSE
                BEGIN  LOAD(STK[TOP]) ;
                GENRR(XLTR,RGADR,RGADR) ;
                BRCND := EQUCND ;  IF NEG_CND THEN BRCND := NEQCND ;
                END ;

              FREEREG(STK[TOP]) ;
              END
            ELSE (*NOT VRBL*)
              IF FPA.DSPLMT = 0 THEN BRCND := ANYCND (*TAKE THE BRANCH*)
              ELSE  BRCND := NOCND ; (*DO NOT BRANCH*) ;
            IF VRBL AND (VPA = RGS) THEN AVAIL[RGADR] := TRUE ;
            END (*WITH STK...*) ;

          GENRXLAB(XBC,BRCND,LBL2,0) ; "NEWLINE := TRUE ;"
          BRCND := -1 ;  NEG_CND := FALSE ;  (* CLEAR C.C./ NEGATE FLAGS *)
          END (*PFJP*) ;

        PXJP :
          (* LBL2   = LOWER BOUND, CASE EXPRESSION       *)
          (* LBL2+1 = UPPER BOUND,                       *)
          (* LBL2+2 = BRANCH TABLE LABEL                 *)
          (* LBL2+3 = CASE EXIT LABEL                    *)

          BEGIN  TOP := TOP-1 ;  LOAD(STK[TOP]) ;
          WITH STK[TOP] DO
            BEGIN
            Q := LBLMAP(LBL2.NAM) ;
            MKLBL(LBL1,Q+1) ;  MKLBL(LBL3,Q+3) ;
            GENRXLAB(XC,RGADR,LBL1,-1) ;   (* CHECK AGAINST UPPER BOUND *)
            GENRXLAB(XBC,GRTCND,LBL3,0) ;  (* GO TO CASE_EXIT IF OUT OF RANGE *)
            GENRXLAB(XS,RGADR,LBL2,-1) ;   (* OTHERWISE SUBTRACT LOWER BOUND *)
            GENRXLAB(XBC,LESCND,LBL3,0) ;  (* CASE_EXIT IF OUT OF RANGE *)
            MKLBL(LBL3,Q+2) ;

            IF ASM THEN
              BEGIN
              GENRR(XSLA,RGADR,2) ;  GENRXLAB(XBC,ANYCND,LBL3,RGADR) ;
              END
            ELSE
              BEGIN
              GENRR(XAR,RGADR,RGADR) ;  (* CONV. INDEX TO TABLE OFFSET *)
              GENRXLAB(XLH,JREG,LBL3,RGADR) ;  GENRX(XBC,ANYCND,0,JREG,PBR1) ;
              END ;

            AVAIL[RGADR] := TRUE ;
            END (* WITH STK[TOP] DO *) ;
          END (*PXJP*) ;

        PMST :
          BEGIN   CSTOP := CSTOP+1 ;  CALSTK[CSTOP] :=  TOP ;
          END ;

        PCUP :
          BEGIN
          CALLSUB(CALSTK[CSTOP], TOP-1) ;  (* SET UP CALL PARAMETERS *)
          TOP := CALSTK[CSTOP] ;

          IF OPNDTYPE <> PROC THEN (*ADJUST STACK TOP*)
            IF OPNDTYPE <> FORT THEN

            WITH STK[TOP] DO
              BEGIN   VRBL := TRUE  ; DRCT := TRUE ;
              FPA := ZEROBL ; VPA := RGS ;

              CASE OPNDTYPE OF

              ADR,INT :
                BEGIN  FINDRG ;
                GENRX(XL,NXTRG,FNCRSLT,TRG1,0)
                END ;

              BOOL,CHRC :
                BEGIN  FINDRG ;
                GENRR(XSR,NXTRG,NXTRG) ;
                GENRX(XIC,NXTRG,FNCRSLT,TRG1,0) ;
                END ;

              PSET :
                BEGIN  FINDRP ;
                GENRS(XLM,NXTRG,NXTRG+1,FNCRSLT,TRG1) ;
                END ;

              REEL :
                BEGIN  FINDFP ;  GENRX(XLD,NXTRG,FNCRSLT,TRG1,0)  END;

              FBOOL:
                BEGIN  FINDRG ;  OPNDTYPE := BOOL ;
                GENRR(XLR,NXTRG,0)    (*COPY RESULT FROM REGISTER ZERO*)
                END;

              FINT :
                BEGIN  FINDRG ;  OPNDTYPE := INT ;
                GENRR(XLR,NXTRG,0)    (*COPY RESULT FROM REGISTER ZERO*)
                END ;

              FREAL:
                BEGIN  FINDFP ;  OPNDTYPE := REEL ;
                GENRR(XLDR,NXTRG,0)    (*COPY RESULT FROM REGISTER ZERO*)
                END ;

              END (*CASE OPNDTYPE*) ;

            RGADR := NXTRG ;  DTYPE := OPNDTYPE ;  TOP := TOP+1 ;
            END (*WITH STK...*) ;

          CSTOP := CSTOP-1 ;  CSPREGACTIVE := FALSE ;  OLDCSP := PSIO ;
          END (* CUP*) ;

        PENT :
          BEGIN  (* ON ENTRY TRG1 POINTS TO DATA AREA FOR THE CALLED ROUTINE *)
          CURLVL := P ;
          IF ASM  THEN
            BEGIN  WRITELN(PRR,'  PBGN ', CURPNAME, PROGHDR:HDRLNGTH+2) ;
            WRITELN(PRR,LBL1.NAM,' CSECT') ;  WRITELN(PRR,' USING *,',JREG:2) ;
            WRITELN(PRR,' B *+12') ;   (* IN FACT GENRX(XB,15,... *)
            WRITELN(PRR, ' DC AL1(7),CL7''' ,CURPNAME:7, '''') ;
            END (*IF ASM*)
          ELSE   INIT_CSECT ;     (*INITIALIZE NEW CSECT PARAMETERS*)

          IF CALL_HIGHER THEN
          GENRX(XL,TRG0,DISPLAY+4*CURLVL,GBR,0) ; (* TO SAVE DISPLAY[CURLVL] *)

          IF SAVERGS OR (OPNDTYPE <> PROC) THEN
            BEGIN

            IF OS_STYLE THEN
              BEGIN
              GENRS(XSTM,14,12,12,TRG1) ;(*SAVE OLD DISPLAY[CURLVL] & REGS*)
              GENRX(XST,TRG1,8,LBR,0) ; (*FORWARD CHAIN OF SAVE AREAS*)
              GENRX(XST,LBR,4,TRG1,0) ; (*DYNAMIC LINK, ALSO SAVE AREA CHAIN*)
              END
            ELSE  GENRS(XSTM,13,12,8,TRG1) ;  (* SAVE DYNAMIC LINK + REGS *);

            END
          ELSE (*JUST SAVE RETURN ADR. & PROGRAM BASE REGS*)
            BEGIN
            GENRX(XST,LBR,4,TRG1,0) ;   (* SET DYNAMIC LINK *)
            IF CALL_HIGHER THEN  GENRX(XST,TRG0,20,TRG1,0)  ;
            GENRX(XST,RTREG,12,TRG1,0) ; GENRX(XST,PBR1,60,TRG1,0) ;
            IF LARGE_PROC THEN  GENRX(XST,PBR2,64,TRG1,0) ;
            END ;

          IF SAVEFPRS OR (OPNDTYPE = REEL) THEN
            FOR I := 1 TO 3 DO
              GENRX(XSTD,2*I,FPRSAREA+I*8,TRG1,0) ;

          GENRR(XLR,LBR,TRG1) ;     (*UPDATE THE 'MP'*)
          IF CALL_HIGHER THEN
          GENRX(XST,LBR,DISPLAY+4*CURLVL,GBR,0) ; (*UPDATE DISPLAY[CURLVL]*)
          GENRR(XLR,PBR1,JREG) ;  (* SET UP PROGRAM BASE REGISTERS *)
          IF LARGE_PROC THEN  GENRX(XLA,PBR2,4092,PBR1,0) ;

          IF ASM THEN
            BEGIN
            WRITELN(PRR, ' USING ', LBL1.NAM:LBL1.LEN, ',', PBR1:2) ;
            WRITELN(PRR, ' USING 4092+', LBL1.NAM:LBL1.LEN, ',', PBR2:2) ;
            WRITELN(PRR,' DROP',JREG:3) ;
            "NEWLINE := TRUE ;"
            END ;

          IF DEBUG THEN
            BEGIN
            GENRR(XLR,RTREG,JREG) ;   (* SAVE CURR. LOC. FOR ERROR ROUTINE *)
            IF DATA_SIZE < 4096 THEN  GENRX(XLA,TRG1,DATA_SIZE,TRG1,0)
            ELSE  GENRXLAB(XA,TRG1,SEGSZE,-1) ;
            GENRX(XC,TRG1,NEWPTR,GBR,0) ;    (* COMPARE 'SP' AND 'NP' *)
            GENRX(XBC,GEQCND,STKCHK,GBR,0) ; (* BRANCH TO ERROR ? *)
            IF CURLVL = 1 THEN   (*ENTERING MAINBLK, CLEAR STACK/HEAP AREA*)
               BEGIN
               GENRX(XLD, FPR0, CLEARBUF, GBR, 0);   (*GET THE "CLEAR" PATTERN*)
               GENRX(XL, TRG14, NEWPTR, GBR, 0);     (*END OF HEAP*)
               GENRX(XLA, TRG1, FRSTGVAR, GBR, 0);
               GENRR(XSR, TRG14, TRG1);              (*TRG14 <-- BYTE COUNT*)
               IF ASM THEN GENRR(XSRA, TRG14, 3)     (*TRG14 <-- DOUBLE WD CNT*)
               ELSE GENRS(XSRA, TRG14, 0, 3, 0);
               GENRX(XSTD, FPR0, 0, TRG1, 0);
               GENRX(XLA, TRG1, 8, TRG1, 0);
               IF ASM THEN  WRITELN(PRR, ' BCT ', TRG14:2, ',*-8')
               ELSE GENRX(XBCT, TRG14, PC*2-8, PBR1, 0);
               END;
            END ;

          CSPREGACTIVE := FALSE ;

          END (*PENT*) ;

        PRET :  (* FOR FUNCTIONS, WE COULD LOAD THE RESULT IN A REG *)
          BEGIN (*RESTORES DISPLAY[CURLVL] AND MP, THEN RETURNS*)
          IF SAVEFPRS OR (OPNDTYPE = REEL) THEN
            FOR I := 1 TO 3 DO
              GENRX(XLD,2*I,FPRSAREA+I*8,LBR,0) ;

          IF DEBUG AND (CURLVL > 1) AND (DATA_SIZE >80) THEN
            (* CLEAR THE STACK FRAME  *)
            BEGIN
            GENRX(XLD, TRG0, CLEARBUF, GBR, 0) ;  (* THE PATTERN TO CLEAR MEM *)

            IF DATA_SIZE < (4096*8) THEN
              GENRX(XLA, TRG1, (DATA_SIZE-LCAFTMST) DIV 8, 0, 0)
            ELSE
              BEGIN
              GENRXLAB(XL, TRG1, SEGSZE, -1) ;
              GENRXLIT(XS, TRG1, LCAFTMST-REALSIZE, 0) ;
              IF ASM THEN  GENRR(XSRA, TRG1, 3)   (* DIVIDE BY 8 *)
              ELSE  GENRS(XSRA, TRG1, 0, 3, 0)
              END ;

            (* TRG1 HOLDS THE # OF DOUBLE WORDS TO BE CLEARED *)

            GENRR(XSR, TRG15, TRG15) ;          (* ADDRESS/INCREMENT POINTER *)
            GENRR(XBALR, TRG14, 0) ;            (* BEGINING OF CLEAR LOOP *)
            GENRX(XSTD, FPR0, LCAFTMST, LBR, TRG15) ;
            GENRX(XLA, TRG15, REALSIZE, TRG15, 0) ;   (* POINT TO NEXT D_WORD *)
            GENRR(XBCTR, TRG1, TRG14) ;         (* REPEAT UNTIL DONE *)
            END (* IF DEBUG *) ;

          IF SAVERGS OR (OPNDTYPE <> PROC) THEN
            IF OS_STYLE THEN
              BEGIN   GENRS(XLM,14,12,12,LBR) ;   GENRX(XL,LBR,4,LBR,0)  END
            ELSE GENRS(XLM,13,12,8,LBR)    (* UPDATE ALL INCL. LOCAL BASE REG *)
          ELSE  (*RESTORE BASE REGS AND RETURN ADR. ONLY*)
            BEGIN
            IF OPNDTYPE <> PROC THEN GENRR(XLR,TRG1,LBR) ; (* FOR FUNC. RSLT. *)
            IF CALL_HIGHER THEN  GENRX(XL,TRG0,20,LBR,0)  ;
            GENRX(XL,RTREG,12,LBR,0) ;
            GENRX(XL,PBR1,60,LBR,0) ;
            IF LARGE_PROC THEN  GENRX(XL,PBR2,64,LBR,0) ;
            GENRX(XL,LBR,4,LBR,0) ;    (* RESET LOCAL PTR TO PREV ACTIV. REC. *)
            END ;

          IF CALL_HIGHER THEN  GENRX(XST,TRG0,DISPLAY+4*CURLVL,GBR,0) ;
          IF DEBUG AND (CURLVL > 1) THEN        (* CLEAR THE SAVE AREA *)
            BEGIN  I := 80 ;   IF OPNDTYPE <> PROC THEN I := 72 ;
            GENSS(XMVC, I, 0, TRG1, 80, TRG1) ;
            END ;
          GENRR(XBCR,ANYCND,RTREG) ;  RELEASE(HEAPMARK) ;
          END (*PRET*) ;

        PCSP : CALLSTNDRD ;

        PSTP :
"NH"      IF ASM THEN  BEGIN  (* GENERATE ASSEMBLER END CARD *)
"NH"         WRITELN(PRR,' EXTRN $PASENT');
"NH"         WRITELN(PRR,' END   $PASENT');     END

        END (*CASE OPC OF*) ;
      END (*COPERATION*) ;


    PROCEDURE UOPERATION ;

    (* UNARY OPERATIONS *)

      BEGIN

        CASE OPC OF

        PSGS :
          WITH STK[TOP-1] DO
            IF VRBL THEN
            BEGIN  LOAD(STK[TOP-1]) ;
              FINDRP ;
              GENRX(XLA,NXTRG+1,1,0,0) ;  GENRR(XSR,NXTRG,NXTRG) ;
              IF ASM THEN GENRX(XSLDL,NXTRG,0,RGADR,0)
              ELSE  GENRS(XSLDL,NXTRG,0,0,RGADR) ;  AVAIL[RGADR] := TRUE ;
              DTYPE := PSET ;  RGADR := NXTRG ;
              END
            ELSE  (*GENERATE A SET OUT OF THE CONSTANT*)
              BEGIN
              PCNST := [FPA.DSPLMT] ;
              DTYPE := PSET ;
              END (*PSGS*) ;

        PFLT,PFLO :
          BEGIN
            IF OPC = PFLT THEN OPPTR := TOP - 1
              ELSE OPPTR := TOP - 2 ;
            WITH STK[OPPTR] DO
               IF VRBL THEN
               BEGIN
                  LOAD(STK[OPPTR]) ;
                  FINDFP ;
                  GENRX(XX,RGADR,FL2+4,GBR,0) ;  GENRX(XST,RGADR,FL1+4,GBR,0) ;
                  GENRX(XLD,NXTRG,FL1,GBR,0) ;  GENRX(XSD,NXTRG,FL2,GBR,0) ;
                  AVAIL[RGADR] := TRUE ;  DTYPE := REEL ;
                  RGADR := NXTRG ;
               END  (* VRBL *)
               ELSE  (* CONSTANT*)
               BEGIN
                  DTYPE := REEL ;
                  RCNST := FPA.DSPLMT ;
                  J := MXSLNGTH ;
                  SCNSTL := 1 ;
                  NEW(STRPTR) ;

                  IF FPA.DSPLMT < 0 THEN
                     BEGIN  FPA.DSPLMT := -FPA.DSPLMT ;
                     STRPTR@[1] := '-' ;
                     END
                  ELSE  STRPTR@[1] := '+' ;

                  REPEAT
                     STRPTR@[J] := CHR((FPA.DSPLMT MOD 10) + ORD('0')) ;
                     J := J - 1 ;
                     SCNSTL := SCNSTL + 1 ;
                     FPA.DSPLMT := FPA.DSPLMT DIV 10 ;
                  UNTIL ( J < 2 ) OR ( FPA.DSPLMT = 0 ) ;
                  FOR I := 2 TO SCNSTL DO
                     STRPTR@[I] := STRPTR@[I+J-1] ;
                  SCNST := STRPTR
               END  (* CONSTANT -- WITH *)
          END  (* PFLT,PFLO *) ;

"NH"    PTRC, PRND :
          BEGIN
            LOAD(STK[ TOP-1 ]) ;
            FINDRG ;
            WITH STK[ TOP-1 ] DO
            BEGIN
            (*GENRX(XAW,RGADR,FL2,GBR,0) ;  GENRX(XSTD,RGADR,FL3,GBR,0) ;
              GENRX(XL,NXTRG,FL3+4,GBR,0) ;  GENRX(XX,NXTRG,FL2+4,GBR,0) ; *)

"NH"          IF OPC = PRND THEN
                BEGIN   NEW(STRPTR) ;
                (* TO ROUND ADD +/-0.5 AND THEN TRUNCATE *)
                STRPTR@[1] := '0' ;   STRPTR@[2] := '.' ;   STRPTR@[3] := '5' ;
                GENRXDLIT(XLD, TRG0, STRPTR, 3(*STRL*), 0.5) ;  (*TRG0 <-- 0.5*)
                GENRR(XLTDR, RGADR, RGADR) ;         (*SEE IF NEGATIVE OPERAND*)
                IF ASM THEN  WRITELN(PRR, ' BNL *+6')
                ELSE
                  BEGIN   Q := BASE_DSPLMT(PC+3) ;
                  GENRX(XBC, GEQCND, Q MOD SL12, Q DIV SL12, 0) ;
                  END ;
                GENRR(XLCDR, TRG0, TRG0) ;         (* TRG0 <-- -0.5 *)
                GENRR(XADR, RGADR, TRG0) ;
"NH"            END (* OPC = PRND *) ;

              GENRX(XAD,RGADR,FL4,GBR,0) ;  GENRX(XSTD,RGADR,FL3,GBR,0) ;
              GENRX(XL,NXTRG,FL3+4,GBR,0) ;
              AVAILFP[ RGADR ] := TRUE ;
              DTYPE := INT ;
              RGADR := NXTRG
            END (* WITH *)
          END  (* PTRC *) ;

        PNGR :
          WITH STK[ TOP-1 ] DO

            IF VRBL THEN
              BEGIN
              LOAD(STK[TOP-1]) ;  GENRR(XLCDR,RGADR,RGADR)
              "  GETOPERAND(STK[TOP-1],Q1,P1,B1) ;
                 IF (VPA = RGS) AND DRCT THEN
                 BEGIN
                    GENRR(XLDR,0,RGADR) ;
                    GENRR(XSDR,RGADR,RGADR) ;
                    GENRR(XSDR,RGADR,0);
                 END  (* VPA = RGS AND DRCT *)
                 ELSE  (* VPA = MEM OR NOT DRCT *)
                 BEGIN
                    FINDFP ;
                    GENRR(XSDR,NXTRG,NXTRG) ;
                    GENRX(XSD,NXTRG,Q1,B1,P1) ;
                    VPA := RGS ;  RGADR := NXTRG ;
                 END  (* VPA = MEM OR NOT DRCT *)   "
              END  (* VRBL *)
            ELSE  (* CONSTANT *)
              BEGIN
              IF SCNST@[1] = '-' THEN
                BEGIN
                FOR I := 1 TO SCNSTL DO
                  SCNST@[I] := SCNST@[I+1] ;
                SCNSTL := SCNSTL - 1
                END
              ELSE  (* POSITIVE NUMBER *)
                BEGIN
                FOR I := SCNSTL DOWNTO 1 DO
                  SCNST@[I+1] := SCNST@[I] ;
                SCNST@[1] := '-' ;
                SCNSTL := SCNSTL + 1
                END ;
              RCNST := -RCNST ;
              END  (* CONSTANT *)
          (* END  PNGR *) ;

        PNGI :
          WITH STK[TOP-1] DO
            IF VRBL THEN
              BEGIN  LOAD(STK[TOP-1]) ;
              GENRR(XLCR,RGADR,RGADR) ;
              END
            ELSE  FPA.DSPLMT := -FPA.DSPLMT ;

        PABI :
          WITH STK[TOP-1] DO
            IF VRBL THEN
              BEGIN  LOAD(STK[TOP-1]) ;
              GENRR(XLPR,RGADR,RGADR) ;
              END
            ELSE  FPA.DSPLMT := ABS(FPA.DSPLMT) ;

        PABR:
           WITH STK[TOP-1] DO
           BEGIN
              LOAD(STK[TOP-1]) ;
              GENRR(XLPDR,RGADR,RGADR)
           END  (* PABR *) ;

        PSQI :
          WITH STK[TOP-1] DO
          BEGIN  MDTAG := PMPI ;  LOAD(STK[TOP-1]) ;  MDTAG := PBGN ;
          GENRR(XMR,RGADR,RGADR+1) ;  AVAIL[RGADR] := TRUE ;
          RGADR := RGADR+1 ;
          END (*PSQI*) ;

        PSQR :
           WITH STK[TOP-1] DO
           BEGIN
              LOAD(STK[TOP-1]) ;
              GENRR(XMDR,RGADR,RGADR)
           END  (* PSQR *) ;
"NH"
"NH"    PCRD :
"NH"      WITH STK[TOP-1] DO
"NH"      BEGIN
"NH"        LOAD( STK[TOP-1] );
"NH"        GENRR(XSR,1,1);  GENRR(XLR,0,RGADR);  GENRR(XNR,RGADR,0);
"NH"        IF ASM THEN WRITELN(PRR,' BZ *+12')
"NH"        ELSE BEGIN
"NH"           Q := BASE_DSPLMT(PC+6);
"NH"           GENRX(XBC,EQUCND,Q MOD SL12, Q DIV SL12, 0);
"NH"        END;
"NH"        GENRR(XLR,0,RGADR);  GENRR(XBCTR,0,0);
"NH"        IF ASM THEN WRITELN(PRR,' BCT 1,*-10')
"NH"       ELSE BEGIN
"NH"           Q := BASE_DSPLMT(PC-5);
"NH"           GENRX(XBCT,1,Q MOD SL12, Q DIV SL12, 0);
"NH"        END;
"NH"        GENRR(XLTR,RGADR,RGADR+1);
"NH"        GENRX(XLA,RGADR+1,0,0,0);
"NH"        IF ASM THEN WRITELN(PRR,' BNZ *-22')
"NH"        ELSE BEGIN
"NH"           Q := BASE_DSPLMT(PC-11);
"NH"           GENRX(XBC,NEQCND,Q MOD SL12, Q DIV SL12, 0);
"NH"        END;
"NH"        GENRR(XLPR,RGADR,1);
"NH"        AVAIL[RGADR+1] := TRUE;  DTYPE := INT;
"NH"      END (* PCRD *) ;
"NH"
"NH"    PXPO :
"NH"      WITH STK[TOP-1] DO
"NH"      BEGIN
"NH"        FINDRG;
"NH"        IF VRBL THEN GETOPERAND(STK[TOP-1],Q1,P1,B1)
"NH"        ELSE LOAD(STK[TOP-1]);
"NH"        IF (VPA = RGS) AND DRCT THEN
"NH"          BEGIN
"NH"             GENRX(XSTD,RGADR,FL3,GBR,0);
"NH"             GENRX(XIC,NXTRG,FL3,GBR,0);
"NH"             AVAILFP[RGADR] := TRUE;
"NH"          END
"NH"        ELSE
"NH"          BEGIN
"NH"            GENRX(XIC,NXTRG,Q1,P1,B1);
"NH"            VPA := RGS;  DRCT := TRUE;
"NH"          END;
"NH"        GENRX(XLA,0,127,0,0);  GENRR(XNR,NXTRG,0);
"NH"        GENRX(XLA,0,64,0,0);   GENRR(XSR,NXTRG,0);
"NH"        RGADR := NXTRG;  DTYPE := INT;
"NH"      END (* PXPO *) ;
"NH"

        PNOT :
          WITH STK[TOP-1] DO
            IF BRCND >= 0 THEN
              IF NEG_CND THEN   (* CLEAR NEGATE FLAG *)
                BEGIN  NEG_CND := FALSE ;  BRCND := -1 ;  END
              ELSE  BRCND := 15-BRCND
            ELSE (* NEGATING A BOOLEAN VLUE *)
              IF VRBL THEN  BEGIN  NEG_CND := TRUE ;  BRCND := 0  END
              ELSE
                IF  FPA.DSPLMT = 0 THEN FPA.DSPLMT := 1 ELSE FPA.DSPLMT := 0 ;

         "WITH STK[TOP-1] DO
            IF VRBL THEN  (*NEEDS FURTHER REFINEMENT*)
              IF BRCND >= 0 THEN  BRCND := 15-BRCND
              ELSE
                BEGIN  LOAD(STK[TOP-1]) ;  GENRXLIT(XX,RGADR,1,0)  END
            ELSE
              IF  FPA.DSPLMT = 0 THEN FPA.DSPLMT := 1 ELSE FPA.DSPLMT := 0 ;"
        PODD :
          WITH STK[TOP-1] DO
          BEGIN
            IF VRBL THEN

              IF DRCT AND (VPA = MEM) THEN
                BEGIN  GETOPERAND(STK[TOP-1],Q1,P1,B1) ;
                IF B1 > 0 THEN  IF P1 > 0 THEN  GENRR(XAR,P1,B1)
                                ELSE  P1 := B1 ;
                GENSI(XTM,Q1+3,P1,1) ;  (* RIGHT MOST BYTE IS BEING TESTED *)
                BRCND := 1 (* B0 *) ;
                END

              ELSE
              BEGIN  LOAD(STK[TOP-1]) ;  GENRXLIT(XN,RGADR,1,0)  END
            ELSE
              IF ODD(FPA.DSPLMT) THEN FPA.DSPLMT := 1 ELSE FPA.DSPLMT := 0  ;
            DTYPE := BOOL
            END (*WITH, PODD*) ;

        PINC,PDEC :
          WITH STK[TOP-1] DO
            BEGIN  IF OPC = PDEC THEN Q := -Q ;
            IF NOT DRCT THEN LOAD(STK[TOP-1]) ;
            FPA.DSPLMT := FPA.DSPLMT+Q ;
            END ;

        PCHR :
          WITH STK[TOP-1] DO
            IF DTYPE > CHRC THEN
              BEGIN  IF VRBL THEN  LOAD(STK[TOP-1]) ;  DTYPE := CHRC  END ;

        PORD :
          WITH STK[TOP-1] DO
            IF DTYPE <= CHRC THEN
              BEGIN  IF VRBL THEN  LOAD(STK[TOP-1]) ;  DTYPE := INT  END ;

        PNEW :
          BEGIN  TOP := TOP-1 ;
          GENRX(XL,TRG0,NEWPTR,GBR,0) ;  GENRXLIT(XS,TRG0,Q,0) ;
          GENRX(XST,TRG0,NEWPTR,GBR,0) ;
          IF NOT STK[TOP].DRCT THEN  LOAD(STK[TOP]) ;
          GETADR(STK[TOP],Q1,P1,B1) ;  GENRX(XST,TRG0,Q1,B1,P1) ;
          FREEREG(STK[TOP]) ;

          IF DEBUG THEN   (* CHECK FOR STACK-HEAP INTERFERENCE *)
            BEGIN
            GENRXLAB(XS,TRG0,SEGSZE,-1) ;
            GENRR(XCR,TRG0,LBR) ;
            GENRR(XBALR,RTREG,0) ;  GENRX(XBC,LEQCND,STKCHK,GBR,0) ;
            END ;

          END (*PNEW*) ;

        PSAV :
          BEGIN  TOP := TOP-1 ;
          GENRX(XL,TRG0,NEWPTR,GBR,0) ;
          IF NOT STK[TOP].DRCT THEN  LOAD(STK[TOP]) ;
          GETADR(STK[TOP],Q1,P1,B1) ;  GENRX(XST,TRG0,Q1,B1,P1) ;
          FREEREG(STK[TOP]) ;
          END (*PSAV*) ;

        PRST :
          BEGIN  TOP := TOP-1 ;
          WITH STK[TOP] DO
            BEGIN  LOAD(STK[TOP]) ;

            IF DEBUG THEN   (* SEE IF NEW HEAP POINTER VALID *)
              BEGIN
              IF RGADR <> 2 THEN
                BEGIN  IF NOT AVAIL[2] THEN ERROR(259) ;
                GENRR(XLR,2,RGADR) ;
                END ;
              GENRX(XBAL,RTREG,PTRCHK,GBR,0) ;
              END ;

            (* CODE FOR CLEARING THE RELEASE HEAP AREA SHOULD GO HERE *)
            (* SEE RETURN SEQUENCE 'PRET' AS AN EXAMPLE.              *)
            GENRX(XST,RGADR,NEWPTR,GBR,0) ;  AVAIL[RGADR] := TRUE ;
            END ;
          END (*PRST*) ;

        PCTS :
          BEGIN   (* SET/INITIALIZE RUN TIME COUNTERS *)
(*
          GENRXLAB(XL, TRG15, LBL2, -1) ;
          GENRX(XL, TRG1, HEAPLMT, GBR, 0) ;
          GENRX(XST, TRG15, DYNRUNC, TRG1, 0) ;   (* SET THE # OF COUNTERS *)
          IF ASM THEN  GENRR(XSLA, TRG15, 2)      (* CONVERT COUNT TO      *)
          ELSE  GENRS(XSLA, TRG15, 0, 2, 0) ;     (* TO # OF WORDS NEEDED  *)
          GENRR(XLR, TRG14,TRG1) ;       (* TRG1 POINTS TO CURRENT HEAP LIMIT *)
          GENRR(XSR, TRG14, TRG15) ;     (* TRG14 POINTS TO NEW HEAP LMT *)
          GENRX(XST, TRG14, NEWPTR, GBR, 0) ;       (* UPDATE THE 'HEAP_PTR' *)
          GENRX(XST, TRG14, HEAPLMT, GBR, 0) ;      (* AND HEAP_LIMIT_PTR    *)
          GENSS(XMVC, DYN2LEN, 0, TRG14, 0, TRG1) ; (* MOVE HEAP LIMIT AREA *)
          IF ASM THEN  GENRR(XSRA, TRG15, 2)        (* CONVERT BYTE COUNT TO *)
          ELSE  GENRS(XSRA, TRG15, 0, 2, 0) ;       (* TO WORD COUNT         *)
          GENRR(XSR, TRG0, TRG0) ;                  (* TRG0 <-- '0' *)
          GENRX(XST, TRG0, DYN2LEN, TRG14, 0) ;     (* CLEAR COUNTERS *)
          GENRX(XLA, TRG14, 4, TRG14, 0) ;          (* POINT TO NEXT COUNTER *)

          IF ASM THEN  WRITELN(PRR, ' BCT ', TRG15:2, ',*-8')
          ELSE GENRX(XBCT, TRG15, PC*2-8, PBR1,0) ; (* REPEAT AS NEEDED *)

          CSPREGACTIVE := FALSE ;
*)
          GENRXLAB(XL, 2, LBL2, -1) ;
          CSP := PCTR;
          GOTOCSP;
         END (*PCTS*) ;

        PCTI :
          BEGIN   (* INCREMENT THE COUNT OF COUNTER # 'Q' *)
          GENRX(XL, TRG1, HEAPLMT, GBR, 0) ;
          GENRX(XLA, TRG14, 1, 0, 0) ;
          Q := 4*Q+DYN2LEN ;

          IF Q > SHRTINT THEN
            BEGIN
            GENRXLIT(XA, TRG1, Q, 0) ;   Q := 0 ;
            END ;

          GENRX(XA, TRG14, Q, TRG1, 0) ;
          GENRX(XST, TRG14, Q, TRG1, 0) ;
          END (*PCTI*) ;

        END (*CASE OPC OF*) ;


      END (*UOPERATION*) ;


    PROCEDURE SOPERATION(VAR L, R: DATUM);
      (* SET UP FOR STRING MOVE/COMPARE OPERATIONS *)
      VAR  P1, B1, P2, B2: LVLRNG;  Q1, Q2: ADRRNG;  XOPC: BYTE;

      BEGIN
      GETADR(L,Q1,P1,B1) ;
      IF NOT L.DRCT THEN
        BEGIN  GENRX(XL,TXRG,Q1,B1,P1) ;
        Q1 := 0 ;  B1 := 0 ;  P1 := TXRG ;
        END ;
      TXRG := TRG1 ;  (*TO AVOID REASSINMENT OF THE SAME BASE REG*)
      OLDCSP := PSIO; (*INDICATES LOSS OF TRG1*)
      GETADR(R,Q2,P2,B2) ;
      IF NOT R.DRCT THEN
        BEGIN  GENRX(XL,TXRG,Q2,B2,P2) ;
        Q2 := 0 ;  B2 := 0 ;  P2 := TXRG ;
        END ;
      TXRG := TRG14  ; (*RESTORE THE OLD MIDLEVEL BASE REG*)

      IF P1 < 0 THEN  BEGIN  B1 := P1;  P1 := 0;  END;
      IF P2 < 0 THEN  BEGIN  B2 := P2;  P2 := 0;  END;

      IF Q <= 256 THEN
        BEGIN (*SHORT MOVE*)
         IF B1 > 0 THEN IF P1 > 0 THEN GENRR(XAR,P1,B1)
                        ELSE P1 := B1 ;
         IF B2 > 0 THEN IF P2 > 0 THEN GENRR(XAR,P2,B2)
                        ELSE P2 := B2 ;
         XOPC := XMVC;  IF OPC <> PMOV THEN  XOPC := XCLC;
         GENSS(XOPC,Q,Q1,P1,Q2,P2) ;
         IF B1 < 0 THEN
            BEGIN  CODE[PC-2] := STRTBL[Q1].LNK;  STRTBL[Q1].LNK := PC-2;  END;
         IF B2 < 0 THEN
            BEGIN  CODE[PC-1] := STRTBL[Q2].LNK;  STRTBL[Q2].LNK := PC-1;  END;
         END (*SHORT STRING*)
      ELSE
        BEGIN

        (* THIS IS ONLY VALID FOR THE 370,    FOR THE 360 THE 'CLCL'    *)
        (* INSTR. SHOULD BE REPLACED BY AN APPROPRIATE NUMBER OF 'CLC'S *)

        FINDRP ;  GENRX(XLA,NXTRG,Q1,B1,P1) ;  P1 := NXTRG ; B1 := NXTRG+1 ;
        FINDRP ;  GENRX(XLA,NXTRG,Q2,B2,P2) ;  P2 := NXTRG ; B2 := NXTRG+1 ;
        IF (B1 < 0) OR (B2 < 0) THEN  ERROR(202);
        GENRXLIT(XL,B1,Q,0) ;  GENRR(XLR,B2,B1) ;
        XOPC := XMVCL;  IF OPC <> PMOV THEN XOPC := XCLCL;
        GENRR(XOPC,P1,P2) ;
        AVAIL[P1] := TRUE ;  AVAIL[B1] := TRUE ;
        AVAIL[P2] := TRUE ;  AVAIL[B2] := TRUE ;
        S370CNT := S370CNT+1;
        END ;

      FREEREG(L) ;  FREEREG(R) ;
      END (*SOPERATION*);


  PROCEDURE BOPERATION ;
    (* BINARY OPERATIONS *)

    VAR  L, R :     DATUM ;  (*LEFT AND RIGHT OPERANDS*)
         LOP, ROP : STKPTR ; (*STACK INDEX OF LEFT AND RIGHT OPERANDS*)
         LRG :      RGRNG ;  (*REGISTER HOLDING LEFT OPERAND*)
         OP1, OP2 : BYTE ;
         LR :       BOOLEAN ; (*LEFT/RIGHT INTERCHANGE FLAG*)
        Q1, Q2 : ADRRNG ;  P1, P2, B1: LVLRNG ;

    BEGIN  (*ADI,SUBI,MPI, COULD BE FURTHER OPTIMIZED*)
    (*DETERMINE WHICH OPERAND SHOULD BE USED AS LEFT HAND OPERAND ...*)
    LR := (OPC IN [PSBR,PDVR,PDVI,PMOD,PDIF,PINN])
       OR (STK[TOP-1].VRBL AND STK[TOP].DRCT)
       OR (NOT STK[TOP-1].DRCT) OR (NOT STK[TOP].VRBL) ;

    IF LR THEN BEGIN  LOP := TOP-1 ;  ROP := TOP  END
    ELSE BEGIN LOP := TOP ;  ROP := TOP-1  END ;
    L := STK[LOP] ;  R := STK[ROP] ;

    CASE OPC OF

    PADI,PSBI :
      BEGIN
      IF NOT L.DRCT THEN LOAD(L) ;
      IF R.DRCT THEN
        IF OPC = PADI THEN
          BEGIN L.FPA.DSPLMT := L.FPA.DSPLMT+R.FPA.DSPLMT; R.FPA.DSPLMT := 0 END
        ELSE
          BEGIN L.FPA.DSPLMT := L.FPA.DSPLMT-R.FPA.DSPLMT; R.FPA.DSPLMT :=0 END;
      (*CONST<OPR>CONST AND VRBL<OPR>CONST CASES ARE COMPLETED NOW *)

      OP1 := XAR ;  OP2 := XA ;
      IF OPC = PSBI THEN  BEGIN OP1 := XSR ;  OP2 := XS  END ;
      IF R.VRBL THEN
        BEGIN  Q := L.FPA.DSPLMT ; L.FPA.DSPLMT := 0 ;  (*SAVE FPA*)
        LOAD(L) ;  IF R.DTYPE <> INT THEN  LOAD(R) ;
        IF R.DRCT THEN
          IF R.VPA = RGS THEN
            BEGIN  GENRR(OP1,L.RGADR,R.RGADR) ;  AVAIL[R.RGADR] := TRUE  END
          ELSE (*VPA=MEM*)
            BEGIN  Q1 := R.MEMADR.DSPLMT ; P1 := R.MEMADR.LVL ;
            BASE(Q1,P1,B1) ;  GENRX(OP2,L.RGADR,Q1,B1,P1) ;
            END
        ELSE (*NOT R.DRCT*)
          BEGIN  GETOPERAND(R,Q1,P1,B1) ;
          GENRX(OP2, L.RGADR,Q1,B1,P1) ;
          END ;
        L.FPA.DSPLMT := Q ;  (*RESTORE FPA*)
        END (*IF R.VRBL*) ;

        IF NOT LR AND (OPC = PSBI) THEN  (*THIS DOES NOT SEEM TO BE COMPLETE*)
          BEGIN  Q := -L.FPA.DSPLMT ;  L.FPA.DSPLMT := 0 ;
          IF L.VRBL THEN
            BEGIN  LOAD(L) ;
            GENRR(XLCR,L.RGADR,L.RGADR) ;
            END ;
          L.FPA.DSPLMT := Q ;
          END ;
      END (*ADI,SBI*) ;

   PMPI :
      BEGIN
      IF R.VRBL THEN
        BEGIN
        MDTAG := PMPI ;  LOAD(L) ;  MDTAG := PBGN ;
        IF R.DTYPE <> INT THEN LOAD(R) ELSE GETOPERAND(R,Q1,P1,B1) ;
        IF (NOT R.DRCT) OR (R.VPA = MEM) THEN  GENRX(XM,L.RGADR,Q1,P1,B1)
        ELSE  BEGIN GENRR(XMR,L.RGADR,R.RGADR) ;  AVAIL[R.RGADR] := TRUE ; END
        END
      ELSE (*NOT R.VRBL*)

        BEGIN  Q := 0 ;
        IF (L.DRCT) THEN
          BEGIN  Q := L.FPA.DSPLMT*R.FPA.DSPLMT ;  L.FPA.DSPLMT := 0  END
        ELSE  LOAD(L) ;

        IF L.VRBL THEN
          BEGIN
          MDTAG := PMPI ;  LOAD(L) ;  MDTAG := PBGN ;
          P := POWER2(R.FPA.DSPLMT) ;
          IF P <> 0 THEN   (* MULTIPLY BY UNITY CAN BE SKIPPED *)
             IF P >= 0 THEN
                IF ASM THEN  GENRR(XSLL,L.RGADR+1,P)
                ELSE   GENRS(XSLL,L.RGADR+1,0,P,0)
                          (* NOTE LOGICAL SHIFT *)
             ELSE  GENRXLIT(XM,L.RGADR,R.FPA.DSPLMT,0) ;
          END (*IF L.VRBL*);

        L.FPA.DSPLMT := Q ;
        END (*ELSE ...*);

      IF L.VRBL THEN
        AVAIL[L.RGADR] := TRUE ;  L.RGADR := L.RGADR+1 ;
      END (*PMPI*) ;

    PDVI,PMOD :
      IF NOT L.VRBL AND NOT R.VRBL THEN  (* BOTH CONSTANTS*)
        IF R.FPA.DSPLMT = 0 THEN  ERROR(300)  (* DIVISION BY ZERO*)
        ELSE
          IF OPC = PDVI THEN
            L.FPA.DSPLMT := L.FPA.DSPLMT DIV R.FPA.DSPLMT
          ELSE  L.FPA.DSPLMT := L.FPA.DSPLMT MOD R.FPA.DSPLMT
      ELSE (* MORE COMMON CASES *)
        BEGIN  MDTAG := PDVI ;  LOAD(L) ;  MDTAG := PBGN ;
        IF R.VRBL THEN
          BEGIN
          IF R.DTYPE <> INT THEN LOAD(R) ELSE GETOPERAND(R,Q1,P1,B1) ;
          IF NOT R.DRCT OR (R.VPA = MEM) THEN GENRX(XD,L.RGADR,Q1,B1,P1)
          ELSE  BEGIN GENRR(XDR,L.RGADR,R.RGADR) ; AVAIL[R.RGADR] := TRUE END
          END (*R.VRBL*)
        ELSE  (*^R.VRBL*)

        (*BEGIN  P := POWER2(R.FPA.DSPLMT) ;                                  *)
        (*IF (P < 0) OR (OPC = PMOD) THEN  GENRXLIT(XD,L.RGADR,R.FPA.DSPLMT,0)*)
        (*ELSE  IF ASM THEN  GENRR(XSRA,L.RGADR+1,P)                          *)
        (*      ELSE  GENRS(XSRA,L.RGADR+1,0,P,0)  ;                          *)
        (*END ;                                                               *)
        (*                                                                    *)
        (*--DIVISION BY A POWER OF 2 IS NOT THE SAME AS ARITHMETIC            *)
        (*--RIGHT SHIFT ACCORDING TO THE 370, SO INSTEAD OF THE ABOVE :       *)

          GENRXLIT(XD,L.RGADR,R.FPA.DSPLMT,0) ;

        IF OPC = PDVI THEN
          BEGIN AVAIL[L.RGADR] := TRUE ;  L.RGADR := L.RGADR+1  END
        ELSE AVAIL[L.RGADR+1] := TRUE ;
        END (* ELSE , PDVI *) ;

    PEQU,PNEQ,PGRT,PLEQ,PLES,PGEQ :
      BEGIN   IF NOT LR THEN OPC := INVBRM[OPC] ;

        CASE OPNDTYPE OF

        ADR,INT,BOOL,CHRC:
          WITH R DO
            BEGIN
            LOAD(L) ;

            IF VRBL THEN
              BEGIN
              IF NOT(DTYPE IN [ADR,INT]) THEN  LOAD(R)
              ELSE  GETOPERAND(R,Q1,P1,B1) ;
              IF (NOT DRCT) OR (VPA = MEM) THEN  GENRX(XC,L.RGADR,Q1,B1,P1)
              ELSE
                BEGIN  GENRR(XCR,L.RGADR,RGADR) ;  AVAIL[RGADR] := TRUE  END
              END


            ELSE (*IF NOT VRBL (I.E.CONST)*)

              IF FPA.DSPLMT = 0 THEN GENRR(XLTR,L.RGADR,L.RGADR)
              ELSE
                IF (OPNDTYPE = ADR) AND (NOT FLIPDEBUG) THEN
                  BEGIN   (* CONSTANT OF TYPE ADR = NIL ! *)
                  (* FOLLOWING VALID ONLY IF $D- IS USED *)
                  GENRR(XLTR, L.RGADR, L.RGADR) ;
                  IF OPC = PEQU THEN  OPC := PLES
                  ELSE  (* OPC = PNEQ *) OPC := PGEQ ;
                  END
                ELSE  GENRXLIT(XC,L.RGADR,FPA.DSPLMT,0) ;

            AVAIL[L.RGADR] := TRUE ;
            END (*WITH R---ADR,INT,...*) ;

        REEL :
          WITH R DO
          BEGIN
            LOAD(L) ;
            IF VRBL THEN
            BEGIN
              GETOPERAND(R,Q1,P1,B1) ;
              IF (VPA = RGS) AND DRCT THEN
              BEGIN
                GENRR(XCDR,L.RGADR,R.RGADR) ;
                AVAILFP [RGADR] := TRUE
              END  (* IF VPA = RGS *)
              ELSE  (* VPA = MEM OR NOT DRCT *)
                GENRX(XCD,L.RGADR,Q1,B1,P1)
            END  (* VRBL *)
            ELSE  (* CONSTANT *)
              GENRXDLIT(XCD,L.RGADR,SCNST,SCNSTL,RCNST) ;
            AVAILFP[L.RGADR] := TRUE ;
          END  (* WITH -- REEL *) ;

        PSET :
          BEGIN
          LOAD(L) ;  LOAD(R) ;
          IF OPC IN [PLES,PLEQ] THEN
            BEGIN
            GENRR(XNR,R.RGADR,L.RGADR) ;  GENRR(XNR,R.RGADR+1,L.RGADR+1) ;
            END
          ELSE IF OPC IN [PGRT,PGEQ] THEN
            BEGIN
            GENRR(XNR,L.RGADR,R.RGADR) ;  GENRR(XNR,L.RGADR+1,R.RGADR+1) ;
            END ;
          GENRR(XXR,L.RGADR,R.RGADR) ;  GENRR(XXR,L.RGADR+1,R.RGADR+1) ;
          GENRR(XXOR,L.RGADR,L.RGADR+1) ;
          FREEREG(L) ;  FREEREG(R) ;
          IF OPC <> PNEQ THEN  OPC := PEQU ;
          END (*PSET*) ;


        STRG :
          BEGIN
"""       GETADR(L,Q1,P1,B1) ;
          IF NOT L.DRCT THEN
            BEGIN  GENRX(XL,TXRG,Q1,B1,P1) ;
            Q1 := 0 ;  B1 := 0 ;  P1 := TXRG ;
            END ;
          TXRG := TRG1 ;  (*TO AVOID REASSINMENT OF THE SAME BASE REG*)
          GETADR(R,Q2,P2,B2) ;
          IF NOT R.DRCT THEN
            BEGIN  GENRX(XL,TXRG,Q2,B2,P2) ;
            Q2 := 0 ;  B2 := 0 ;  P2 := TXRG ;
            END ;
          TXRG := TRG14  ; (*RESTORE THE OLD MIDLEVEL BASE REG*)

          IF Q <= 256 THEN
            BEGIN (*SHORT MOVE*)
             IF B1 > 0 THEN IF P1 > 0 THEN GENRR(XAR,P1,B1)
                            ELSE P1 := B1 ;
             IF B2 > 0 THEN IF P2 > 0 THEN GENRR(XAR,P2,B2)
                            ELSE P2 := B2 ;
             GENSS(XCLC,Q,Q1,P1,Q2,P2) ;
             END (*SHORT COMPARE*)
          ELSE
            BEGIN

            (* THIS IS ONLY VALID FOR THE 370,    FOR THE 360 THE 'CLCL'    *)
            (* INSTR. SHOULD BE REPLACED BY AN APPROPRIATE NUMBER OF 'CLC'S *)

            FINDRP ;  GENRX(XLA,NXTRG,Q1,B1,P1) ;  P1 := NXTRG ; B1 := NXTRG+1 ;
            FINDRP ;  GENRX(XLA,NXTRG,Q2,B2,P2) ;  P2 := NXTRG ; B2 := NXTRG+1 ;
            GENRXLIT(XL,B1,Q,0) ;  GENRR(XLR,B2,B1) ;
            GENRR(XCLCL,P1,P2) ;
            AVAIL[P1] := TRUE ;  AVAIL[B1] := TRUE ;
            AVAIL[P2] := TRUE ;  AVAIL[B2] := TRUE ;
            END ;

          FREEREG(L) ;  FREEREG(R) ;   """
          SOPERATION(L, R);
          OLDCSP := PSIO ;
          END (*STRG*)

        END (*CASE OPNDTYE OF*) ;

      BRCND := BRMSK[OPC] ;
      END (*PEQU,PNEQ,...*) ;

    PAND, PIOR :
      WITH R DO
        BEGIN  OP1 := XNR ;
        IF OPC = PIOR THEN OP1 := XXOR ;
        LOAD(L) ;  LOAD(R)  ;
        (*THIS CAN BE IMPROVED BY USING THE CONDITION CODE AS THE TOP ELEMENT *)
        GENRR(OP1,L.RGADR,RGADR) ;
        AVAIL[RGADR] := TRUE ;
        END (*WITH...,PAND,PIOR*) ;

    PINN :
      WITH R DO
        BEGIN   LOAD(R) ;

        IF L.VRBL THEN
          BEGIN   LOAD(L) ;
          GENRR(XLCR,L.RGADR,L.RGADR) ;
          IF ASM THEN GENRX(XSLDL,RGADR,63,L.RGADR,0)
          ELSE  GENRS(XSLDL,RGADR,0,63,L.RGADR) ;
          AVAIL[L.RGADR] := TRUE ;
          END
        ELSE  (* ^ L.VRBL *)
          IF ASM THEN GENRR(XSLDL,RGADR,63-L.FPA.DSPLMT)
          ELSE  GENRS(XSLDL,RGADR,0,63-L.FPA.DSPLMT,0) ;

        GENRR(XLTR,RGADR,RGADR) ;
        AVAIL[RGADR] := TRUE ;
        AVAIL[RGADR+1] := TRUE ;
        "OPC := PLES ;"  BRCND := LESCND ;
        END (*WITH R...,PINN*) ;

    PUNI :
      WITH R DO
        IF L.VRBL THEN
          BEGIN  LOAD(L) ;  IF NOT DRCT THEN  LOAD(R) ;
          IF R.VRBL THEN
            IF VPA = MEM THEN
              BEGIN
              P1 := MEMADR.LVL ;  Q1 := MEMADR.DSPLMT ;
              BASE(Q1,P1,B1) ;
              GENRX(XO,L.RGADR,Q1,B1,P1) ; GENRX(XO,L.RGADR+1,Q1+4,B1,P1) ;
              END
            ELSE (*I.E. VPA = RGS*)
              BEGIN
              GENRR(XXOR,L.RGADR,RGADR) ;
              GENRR(XXOR,L.RGADR+1,RGADR+1) ;
              FREEREG(R) ;
              END  (*IF VPA = MEM*)
          ELSE (*I.E. ^R.VRBL*)
            BEGIN  I_S_R.S := PCNST  ;
            GENRXLIT(XO,L.RGADR,I_S_R.I1,0) ;
            GENRXLIT(XO,L.RGADR+1,I_S_R.I2,0) ;
            END ;
          END (*IF L.VRBL*)
        ELSE (*BOTH OPERANDS CONSTANT*)
          L.PCNST := L.PCNST+PCNST
      (*END WITH R...,PUNI*) ;

    PINT :
      WITH R DO
        IF L.VRBL THEN
          BEGIN  LOAD(L) ;  IF NOT DRCT THEN  LOAD(R) ;
          IF R.VRBL THEN
            IF VPA = MEM THEN
              BEGIN
              P1 := MEMADR.LVL ;  Q1 := MEMADR.DSPLMT ;
              BASE(Q1,P1,B1) ;
              GENRX(XN,L.RGADR,Q1,B1,P1) ;  GENRX(XN,L.RGADR+1,Q1+4,B1,P1) ;
              END
            ELSE (*I.E. VPA = RGS*)
              BEGIN
              GENRR(XNR,L.RGADR,RGADR) ;  GENRR(XNR,L.RGADR+1,RGADR+1) ;
              FREEREG(R) ;
              END  (*IF VPA = MEM*)
          ELSE (*I.E. ^R.VRBL*)
            BEGIN  I_S_R.S := PCNST ;
            GENRXLIT(XN,L.RGADR,I_S_R.I1,0) ;
            GENRXLIT(XN,L.RGADR+1,I_S_R.I2,0) ;
            END ;
          END (*IF L.VRBL*)
        ELSE (*BOTH OPERANDS CONSTANT*)
          L.PCNST := L.PCNST*PCNST
        (*END WITH R...,PINT*) ;

    PDIF :
      WITH R DO
        IF L.VRBL OR R.VRBL THEN
          BEGIN  LOAD(L) ;   IF NOT DRCT THEN   LOAD(R) ;
          (* NOW BOTH OPERANDS ARE IN REGS, ONLY THAT CASE TO BE CONSIDERED *)
          IF R.VRBL THEN
            IF VPA = MEM THEN
              BEGIN
              P1 := MEMADR.LVL ;  Q1 := MEMADR.DSPLMT ;
              BASE(Q1,P1,B1) ;
              GENRX(XX,L.RGADR,Q1,B1,P1) ;  GENRX(XX,L.RGADR+1,Q1+4,B1,P1) ;
              END
            ELSE (*I.E. VPA = RGS*)
              BEGIN
              GENRR(XXOR,L.RGADR,RGADR) ;
              GENRR(XXOR,L.RGADR+1,RGADR+1) ;
              GENRR(XXR,L.RGADR,RGADR) ;  GENRR(XXR,L.RGADR+1,RGADR+1) ;
              FREEREG(R) ;
              END  (*IF VPA = MEM*)
          ELSE (*I.E.^R.VRBL*)
            BEGIN  I_S_R.S := PCNST ;
            GENRXLIT(XX,L.RGADR,I_S_R.I1,0) ;
            GENRXLIT(XX,L.RGADR+1,I_S_R.I2,0) ;
            END ;
          END (*IF L.VRBL*)
        ELSE (*BOTH OPERANDS CONSTANT*)
          L.PCNST := L.PCNST-PCNST
        (*END WITH R...,PDIF*) ;


    PADR,PSBR :
       BEGIN
          OP1 := XADR;   OP2 := XAD;
          IF OPC = PSBR THEN
          BEGIN OP1 := XSDR;   OP2 := XSD   END;
          LOAD(L);
          IF R.VRBL THEN
          BEGIN
             GETOPERAND(R,Q1,P1,B1) ;
             IF (R.VPA = RGS) AND R.DRCT THEN
             BEGIN
                GENRR(OP1,L.RGADR,R.RGADR);
                AVAILFP[R.RGADR] := TRUE
             END
             ELSE  (* VPA = MEM OR NOT DRCT *)
                GENRX(OP2,L.RGADR,Q1,B1,P1)
          END  (* IF R.VRBL *)
          ELSE  (* CONSTANT *)
          GENRXDLIT(OP2,L.RGADR,R.SCNST,R.SCNSTL,R.RCNST)
       END  (* PADR,PSBR *) ;

     PDVR,PMPR:
       BEGIN
         LOAD(L) ;
         OP1 := XDDR ;   OP2 := XDD ;
         IF OPC=PMPR THEN
         BEGIN OP1 := XMDR ;   OP2 := XMD    END ;
         IF R.VRBL THEN
         BEGIN
           GETOPERAND(R,Q1,P1,B1) ;
           IF (R.VPA = RGS) AND R.DRCT THEN
           BEGIN
             GENRR(OP1,L.RGADR,R.RGADR) ;
             AVAILFP [R.RGADR] := TRUE
           END  (* R.VPA = RGS *)
           ELSE  (* R.VPA = MEM OR NOT DRCT *)
             GENRX(OP2,L.RGADR,Q1,B1,P1)
         END  (*  R.VRBL  *)
         ELSE  (*  CONSTANT  *)
           GENRXDLIT(OP2,L.RGADR,R.SCNST,R.SCNSTL,R.RCNST)
       END  (* PDVR,PMDR *)   ;

    END (*CASE OPC OF*) ;

  STK[TOP-1] := L ;
  END (*BOPERATION*) ;



    (* LOAD_STOR_MOVE IOPERATIONS *)
    (* -------------------------- *)


    BEGIN (*ASMNXTINST*)

    IF BRCND >= 0 THEN
      IF NOT (OPC IN [PFJP,PNOT,PLOC]) THEN   (* XLATE COND CODE TO BOOL. VAL *)
        WITH STK[TOP-1] DO
          BEGIN

          IF NEG_CND THEN   (* JUST NEGATE TOP OF STACK *)
            BEGIN  LOAD(STK[TOP-1]) ;  GENRXLIT(XX,RGADR,1,0)  END
          ELSE  (* OTHERWISE TRANSLATE CC TO BOOLEAN *)

            BEGIN  FINDRG ;
            GENRX(XLA,NXTRG,1,0,0) ;  (*ASSUME TRUE*)
            IF ASM THEN
              WRITELN(PRR,' BC',BRCND:4,',*+6')
            ELSE
              BEGIN
              GENRX(XBC,BRCND,0,0,0) ;
              CODE[PC-1] := BASE_DSPLMT(PC+1) ;
              END ;
            GENRR(XSR,NXTRG,NXTRG) ;  (* THEN CHANGE TO FALSE IF NEEDED*)

              BEGIN  DTYPE := BOOL ;
              VRBL := TRUE ; DRCT := TRUE ;
              VPA := RGS ;  RGADR := NXTRG ;
              FPA := ZEROBL ;
              END (*WITH STK...*) ;

            END (* TRANSLATE CC *) ;

          BRCND := -1 ;  NEG_CND := FALSE ; (* RESET C.C. FLAG TO INACTIVE *)
          END (*WITH STK[..., IF NOT (OPC IN [PFJP,... *) ;


    CASE OPC OF


    PLOD ",PLDO" :
      WITH STK[TOP] DO
        BEGIN
        IF OPNDTYPE IN [ADR,INT,PSET] THEN
          IF (Q MOD INTSIZE) <> 0 THEN  ERROR(611) ;
        IF OPNDTYPE = REEL THEN
          IF (Q MOD REALSIZE) <> 0 THEN  ERROR(612) ;
        DTYPE := OPNDTYPE ;  VRBL := TRUE ;  DRCT := TRUE ;
        FPA := ZEROBL ;  VPA := MEM ;
        MEMADR.LVL := "CURLVL-" P ;  MEMADR.DSPLMT := Q ;
        TOP := TOP+1 ;
        END (*LOD,LDO*) ;

    PSTR ",PSRO" :
      BEGIN " P := CURLVL-P ;"  TOP := TOP-1 ;
      IF OPNDTYPE IN [ADR,INT,PSET] THEN
        IF (Q MOD INTSIZE) <> 0 THEN  ERROR(611) ;
      IF OPNDTYPE = REEL THEN
        IF (Q MOD REALSIZE) <> 0 THEN  ERROR(612) ;
      STORE(TOP,FALSE(*DIRECT*) ) ;
      END ;

    PSTO:
      BEGIN  STORE(TOP-1,TRUE(*INDIRECT*)) ;  TOP := TOP-2  END ;

    PLDA ",PLAO" :
      WITH STK[TOP] DO
      BEGIN  DTYPE := ADR ;  VRBL := FALSE ;  DRCT := TRUE ;
      FPA.LVL := "CURLVL-"P ;  FPA.DSPLMT := Q ;
      TOP := TOP+1 ;
      END ;

    PLDC :
      WITH STK[TOP] DO
      BEGIN  DTYPE := OPNDTYPE ;  VRBL := FALSE ;  FPA := ZEROBL ;
      DRCT := TRUE ;

        CASE OPNDTYPE OF

        ADR:
          FPA.DSPLMT := -1 ; (*LDC NIL*)

        BOOL,CHRC,INT :
          FPA.DSPLMT :=  IVAL ;

        REEL :
           BEGIN
              SCNST := STRPTR;
              SCNSTL := SLNGTH;
              RCNST := 0 ;  I := 1 ;  NEGATE := FALSE ;
              IF STRPTR@[I] = '-' THEN  BEGIN  NEGATE := TRUE ;  I := I+1 END
              ELSE  IF STRPTR@[I] = '+' THEN I := I+1 ;

              REPEAT
                RCNST := RCNST*10 + (ORD(STRPTR@[I])-ORD('0')) ;
                I := I+1 ;
              UNTIL (STRPTR@[I] < '0') OR (STRPTR@[I] > '9') ;


              IF STRPTR@[I]= '.' THEN
                BEGIN
                I := I+1 ;   POWER10 := 10 ;
                  REPEAT
                  RCNST := RCNST+(ORD(STRPTR@[I])-ORD('0')) / POWER10 ;
                  I := I+1 ;   POWER10 := POWER10 * 10
                  UNTIL (I > SLNGTH) OR (STRPTR@[I] < '0')OR(STRPTR@[I] > '9');
                END ;

              IF NEGATE THEN RCNST := -RCNST  ;

              IF I < SLNGTH THEN   (* SCIENTIFIC NOTATION FOR REAL *)
                IF STRPTR@[I] <> 'E' THEN ERROR(613)
                  ELSE
                    BEGIN   I := I+1 ;   NEGATE := FALSE ;

                    IF STRPTR@[I] = '-' THEN
                      BEGIN  NEGATE := TRUE ;  I := I+1   END
                    ELSE  IF STRPTR@[I] = '+' THEN I := I+1 ;

                    J := 0 ;
                    FOR I := I TO SLNGTH DO
                      J := J*10 + (ORD(STRPTR@[I])-ORD('0')) ;

                    IF  J > 100 THEN ERROR(613)
                    ELSE
                      FOR I := 1 TO J DO
                        IF NEGATE THEN RCNST := RCNST / 10
                        ELSE  RCNST := RCNST * 10 ;
                    END  ;

           END  (* REEL *);

        PSET :
          PCNST := PSVAL

        END (*CASE OPNDTYPE*) ;

      TOP := TOP+1 ;
      END (*LDC*) ;

    PIND :
      WITH STK[TOP-1] DO
      BEGIN  IF DTYPE <> ADR THEN  ERROR(602) ;
      IF VRBL THEN
        BEGIN  IF NOT DRCT THEN  LOAD(STK[TOP-1]) ;
        FPA.DSPLMT := FPA.DSPLMT+Q ;  DRCT := FALSE ;
        END
      ELSE
        BEGIN
        MEMADR := FPA ;  MEMADR.DSPLMT := MEMADR.DSPLMT+Q ;  FPA := ZEROBL ;
        VRBL := TRUE ;  VPA := MEM ;  DRCT := TRUE ;
        END ;

      DTYPE  := OPNDTYPE ;
      END (*PIND*) ;

    PLCA :
      WITH STK[TOP] DO
        BEGIN  DTYPE := ADR;
        IF ASM THEN
           BEGIN  FINDRG;
           VRBL := TRUE ;  DRCT := TRUE ;  FPA := ZEROBL ;
           VPA := RGS ;  RGADR := NXTRG ;
           WRITELN(PRR,' LSA ',NXTRG:FLDW(NXTRG),',''',SVAL:SLNGTH,'''')
           END
        ELSE

          IF NXTSLOC < (PC+SLNGTH) THEN  ERROR(253)  (* CSECT OVERFLOW *)
          ELSE
            BEGIN   (* STRINGS ARE CURRENTLY ALINGED ON 2-BYTE BOUNDARY *)
            FOR I := (SLNGTH+1) DIV 2 DOWNTO 1 DO
              BEGIN
              NXTSLOC := NXTSLOC-1 ;
              CODE[NXTSLOC] := "EBCDIC["ORD(SVAL[I*2-1])"]"*SL8  +
                               "EBCDIC["ORD(SVAL[I*2])"]" ;
              END ;

          (*GENRX(XLA,NXTRG,0,0,0) ;  CODE[PC-1] := NXTSLOC ;               *)
          (*STRTBL[NXTSTR].LNK := PC-1 ;  STRTBL[NXTSTR].LNGTH := SLNGTH ;  *)
          (*   TO DELAY ISSUING THE EXTRA 'LA' INSTRUCTION:                 *)
            STRTBL[NXTSTR].LNK := NXTSLOC;  STRTBL[NXTSTR].LNGTH := SLNGTH;
          (*VRBL := TRUE ;  DRCT := TRUE ;                 FPA := ZEROBL ;  *)
          (*VPA := RGS ;  RGADR := NXTRG ;                                  *)
            VRBL := FALSE;  DRCT := TRUE;
            FPA.DSPLMT := NXTSTR;  FPA.LVL := -1;
            IF NXTSTR < STRCNT THEN  NXTSTR := NXTSTR+1
            ELSE  ERROR(254) ;
            END  (* STRING_POOL FIXUP *) ;

        TOP := TOP+1;
        END (*PLCA*) ;

    PIXA :
      BEGIN  TOP := TOP-1  ;
      WITH STK[TOP] DO
        BEGIN  IF NOT DRCT THEN  LOAD(STK[TOP]) ;
        IF NOT (DTYPE IN [ADR,INT,BOOL,CHRC]) THEN  ERROR(601) ;
        FPA.DSPLMT := FPA.DSPLMT*Q ;

        IF VRBL THEN

          BEGIN
          IF VPA = MEM THEN
            BEGIN  FINDRG ;
            P1 := MEMADR.LVL ;  Q1 := MEMADR.DSPLMT ;
            BASE(Q1,P1,B1) ;
            IF DTYPE IN [CHRC,BOOL] THEN
              BEGIN  GENRR(XSR,NXTRG,NXTRG) ;
              GENRX(XIC,NXTRG,Q1,B1,P1) ;
              END
            ELSE (*INT,ADR*)  GENRX(XL,NXTRG,Q1,B1,P1) ;
            VPA := RGS ;  RGADR := NXTRG ;
            END ;
          (* VPA IS IN A REG. NOW*)
          IF Q > HALFINT THEN  ERROR(504) ;    (* TOO LARGE FOR A HALF WORD *)
          Q2 := POWER2(Q) ;
          IF Q2 > 0 THEN

            IF ASM THEN  GENRR(XSLA,RGADR,Q2)
            ELSE  GENRS(XSLA,RGADR,0,Q2,0)

          ELSE  IF Q2 < 0 THEN  GENRXLIT(XMH,RGADR,Q,-2 (*=H'Q'*) ) ;
          END ;

        (* NOW ADD THE TOP TO THE SECOND TOP *)

        WITH STK[TOP-1] DO
           BEGIN
           IF NOT VRBL THEN
              IF FPA.LVL < 0 THEN  (*I.E. INDEXING THROUGH A CONSTANT STRING*)
                 LOAD(STK[TOP-1]);
           IF NOT DRCT THEN LOAD(STK[TOP-1]) ;
           END (*with stk[top-1*);

        STK[TOP-1].FPA.DSPLMT := STK[TOP-1].FPA.DSPLMT+FPA.DSPLMT ;
        FPA.DSPLMT := 0 ;

        IF VRBL AND STK[TOP-1].VRBL THEN
          IF VPA = RGS THEN
            IF STK[TOP-1].VPA = RGS THEN  (*BOTH OPERANDWS IN REGS*)
              BEGIN
              GENRR(XAR,STK[TOP-1].RGADR,RGADR) ;  AVAIL[RGADR] := TRUE
              END
            ELSE   (*TOP IN REG., 2_ND TOP IN MEMORY.*)
              BEGIN
              Q1 := STK[TOP-1].MEMADR.DSPLMT ;  P1 := STK[TOP-1].MEMADR.LVL ;
              BASE(Q1,P1,B1) ;
              GENRX(XA,RGADR,Q1,B1,P1) ;
              STK[TOP-1].VPA := RGS ;
              STK[TOP-1].RGADR := RGADR ;
              END
          ELSE (*VPA = MEM*)
            BEGIN  IF STK[TOP-1].VPA <> RGS THEN  LOAD(STK[TOP-1]) ;
            Q1 := MEMADR.DSPLMT ;  P1 := MEMADR.LVL ;
            BASE(Q1,P1,B1) ;
            GENRX(XA,STK[TOP-1].RGADR,Q1,B1,P1) ;
            END

        ELSE (*NOT (VRBL AND STK[TOP-1].VRBL) *)

          IF VRBL THEN
            BEGIN  FPA.LVL := STK[TOP-1].FPA.LVL ;
            FPA.DSPLMT := STK[TOP-1].FPA.DSPLMT ;
            DTYPE := ADR ;
            STK[TOP-1] := STK[TOP] ;
            END
        END (*WITH STK...*) ;

      END (*PIXA*) ;

    PMOV :
      BEGIN  TOP := TOP-2 ;
      IF Q > 0 THEN (*FORWARD MOVE*)  SOPERATION(STK[TOP], STK[TOP+1])
      ELSE
         BEGIN  (*BACKWARD MOVE*)
         Q := ABS(Q);   SOPERATION(STK[TOP+1], STK[TOP]);
         END;
      END (*PMOV*) ;


    (* CONTROL/BRANCH OPERATIONS *)

    PUJP,PFJP,PXJP,PMST,PCUP,PENT,PLOC,
    PRET,PCSP,PSTP,PLAB,PDEF,PCHK :  COPERATION ;


    (* UNARY OPERATIONS *)

    PABI,PABR,PNGI,PNGR,PINC,PDEC,
    PNOT,PODD,PCHR,PORD,PFLO,PFLT,
    PTRC,PSGS,PNEW,PSAV,PRST,PSQI,
"NH" PSQR,PCTS,PCTI,PCRD,PXPO,PRND:  UOPERATION ;


    (* BINARY OPERATIONS *)

    PEQU,PNEQ,PLES,PLEQ,PGRT,PGEQ,
    PADI,PSBI,PMPI,PDVI,PMOD,PAND,
    PIOR,PADR,PSBR,PMPR,PDVR,PINN,
    PINT,PUNI,PDIF :
      BEGIN  TOP := TOP-1 ;  BOPERATION  END


    END (*CASE OPC OF*) ;

  OLDOPC := OPC ;
  END (*ASMNXTINST*) ;


PROCEDURE SETUP ;
(* INITIALIZE GLOBAL VARIABLE/SET FLAGS ETC. *)
(* ----------------------------------------- *)

  VAR  I: INTEGER ;

  BEGIN
"NH" EMPTY := '   ';
"NH" FOR I := 0 TO OPCNT DO PTBL[I] := EMPTY;
"NH" FOR I := 0 TO SPCNT DO CSPTBL[I] := EMPTY;

  PTBL[PLOD]  :='LOD'    ;  " PTBL[PLDO]  :='LDO'    ;" PTBL[PCTS]  :='CTS'  ;
  PTBL[PSTR]  :='STR'    ;  " PTBL[PSRO]  :='SRO'    ;" PTBL[PLOC]   := 'LOC'  ;
  PTBL[PLDA]  :='LDA'    ;  " PTBL[PLAO]  :='LAO'    ;" PTBL[PCTI]  :='CTI'   ;
  PTBL[PSTO]  :='STO'    ;    PTBL[PLDC]  :='LDC'    ;
  PTBL[PLAB]  :='LAB'    ;    PTBL[PIND]  :='IND'    ;
  PTBL[PINC]  :='INC'    ;    PTBL[PMST]  :='MST'    ;
  PTBL[PCUP]  :='CUP'    ;    PTBL[PENT]  :='ENT'    ;
  PTBL[PRET]  :='RET'    ;    PTBL[PCSP]  :='CSP'    ;
  PTBL[PIXA]  :='IXA'    ;    PTBL[PEQU]  :='EQU'    ;
  PTBL[PNEQ]  :='NEQ'    ;    PTBL[PGEQ]  :='GEQ'    ;
  PTBL[PGRT]  :='GRT'    ;    PTBL[PLEQ]  :='LEQ'    ;
  PTBL[PLES]  :='LES'    ;    PTBL[PUJP]  :='UJP'    ;
  PTBL[PFJP]  :='FJP'    ;    PTBL[PXJP]  :='XJP'    ;
  PTBL[PCHK]  :='CHK'    ;    PTBL[PNEW]  :='NEW'    ;
  PTBL[PADI]  :='ADI'    ;    PTBL[PADR]  :='ADR'    ;
  PTBL[PSBI]  :='SBI'    ;    PTBL[PSBR]  :='SBR'    ;
  PTBL[PSGS]  :='SGS'    ;    PTBL[PFLT]  :='FLT'    ;
  PTBL[PFLO]  :='FLO'    ;    PTBL[PTRC]  :='TRC'    ;
  PTBL[PNGI]  :='NGI'    ;    PTBL[PNGR]  :='NGR'    ;
  PTBL[PSQI]  :='SQI'    ;    PTBL[PSQR]  :='SQR'    ;
  PTBL[PABI]  :='ABI'    ;    PTBL[PABR]  :='ABR'    ;
  PTBL[PNOT]  :='NOT'    ;    PTBL[PAND]  :='AND'    ;
  PTBL[PIOR]  :='IOR'    ;    PTBL[PDIF]  :='DIF'    ;
  PTBL[PINT]  :='INT'    ;    PTBL[PUNI]  :='UNI'    ;
  PTBL[PINN]  :='INN'    ;    PTBL[PMOD]  :='MOD'    ;
  PTBL[PODD]  :='ODD'    ;    PTBL[PMPI]  :='MPI'    ;
  PTBL[PMPR]  :='MPR'    ;    PTBL[PDVI]  :='DVI'    ;
  PTBL[PDVR]  :='DVR'    ;    PTBL[PMOV]  :='MOV'    ;
  PTBL[PLCA]  :='LCA'    ;    PTBL[PDEC]  :='DEC'    ;
  PTBL[PSTP]  :='STP'    ;    PTBL[PSAV]  :='SAV'    ;
  PTBL[PRST]  :='RST'    ;    PTBL[PORD]  :='ORD'    ;
  PTBL[PCHR]  :='CHR'    ;    PTBL[PEND]  :='END'    ;
  PTBL[PBGN]  :='BGN'    ;    PTBL[PDEF]  :='DEF'    ;
  PTBL[PRND]  :='RND'    ;
"NH" PTBL[PCRD]:='CRD'    ;    PTBL[PXPO]:='XPO'    ;


  CSPTBL[PGET]  :='GET'  ;    CSPTBL[PPUT]  :='PUT'  ;
  CSPTBL[PRES]  :='RES'  ;    CSPTBL[PRLN]  :='RLN'  ;
  CSPTBL[PREW]  :='REW'  ;    CSPTBL[PWLN]  :='WLN'  ;
  CSPTBL[PWRS]  :='WRS'  ;    CSPTBL[PELN]  :='ELN'  ;
  CSPTBL[PWRI]  :='WRI'  ;    CSPTBL[PWRR]  :='WRR'  ;
  CSPTBL[PWRC]  :='WRC'  ;    CSPTBL[PRDI]  :='RDI'  ;
  CSPTBL[PRDR]  :='RDR'  ;    CSPTBL[PRDC]  :='RDC'  ;
  CSPTBL[PSIN]  :='SIN'  ;    CSPTBL[PCOS]  :='COS'  ;
  CSPTBL[PEXP]  :='EXP'  ;    CSPTBL[PLOG]  :='LOG'  ;
  CSPTBL[PSQT]  :='SQT'  ;    CSPTBL[PATN]  :='ATN'  ;
  CSPTBL[PEOF]  :='EOF'  ;    CSPTBL[PXIT]  :='XIT'  ;
  CSPTBL[PRDS]  :='RDS'  ;    CSPTBL[PTRP]  :='TRP'  ;
  CSPTBL[PSIO]  :='SIO'  ;    CSPTBL[PEIO]  :='EIO'  ;
  CSPTBL[PCLK]  :='CLK'  ;    CSPTBL[PFDF]  :='FDF'  ;
  CSPTBL[PPAG]  :='PAG'  ;    CSPTBL[PNUL]  := EMPTY ;
  CSPTBL[PRDB]  :='RDB'  ;    CSPTBL[PWRB]  :='WRB'  ;
"NH" CSPTBL[PSKP]:='SKP'  ;    CSPTBL[PLIM]:='LIM'  ;
"NH" CSPTBL[PMSG]:='MSG'  ;


                              XTBL[XLTR ]:='LTR '    ;
  XTBL[XL   ]:='L   '    ;    XTBL[XLH  ]:='LH  '    ;
  XTBL[XLD  ]:='LD  '    ;    XTBL[XLR  ]:='LR  '    ;
  XTBL[XLDR ]:='LDR '    ;    XTBL[XIC  ]:='IC  '    ;
  XTBL[XLM  ]:='LM  '    ;    XTBL[XLA  ]:='LA  '    ;
  XTBL[XLPR ]:='LPR '    ;    XTBL[XLCR ]:='LCR '    ;
  XTBL[XLPDR]:='LPDR'    ;    XTBL[XLCDR]:='LCDR'    ;
  XTBL[XLTDR]:='LTDR'    ;

  XTBL[XA   ]:='A   '    ;    XTBL[XAH  ]:='AH  '    ;
  XTBL[XAD  ]:='AD  '    ;    XTBL[XAR  ]:='AR  '    ;
  XTBL[XADR ]:='ADR '    ;    XTBL[XSDR ]:='SDR '    ;
  XTBL[XMDR ]:='MDR '    ;    XTBL[XDDR ]:='DDR '    ;
  XTBL[XAW  ]:='AW  '    ;

  XTBL[XST  ]:='ST  '    ;    XTBL[XSTD ]:='STD '    ;
  XTBL[XSTH ]:='STH '    ;    XTBL[XSTC ]:='STC '    ;
  XTBL[XSTM ]:='STM '    ;

  XTBL[XMVC ]:='MVC '    ;    XTBL[XMVCL]:='MVCL'    ;
  XTBL[XMVI ]:='MVI '    ;

  XTBL[XS   ]:='S   '    ;    XTBL[XSH  ]:='SH  '    ;
  XTBL[XSD  ]:='SD  '    ;    XTBL[XSR  ]:='SR  '    ;

  XTBL[XN   ]:='N   '    ;    XTBL[XNR  ]:='NR  '    ;
  XTBL[XO   ]:='O   '    ;    XTBL[XXOR  ]:='OR  '    ;
  XTBL[XX   ]:='X   '    ;    XTBL[XXR  ]:='XR  '    ;

  XTBL[XM   ]:='M   '    ;    XTBL[XMH  ]:='MH  '    ;
  XTBL[XMD  ]:='MD  '    ;    XTBL[XMR  ]:='MR  '    ;

  XTBL[XD   ]:='D   '    ;
  XTBL[XDD  ]:='DD  '    ;    XTBL[XDR  ]:='DR  '    ;

  XTBL[XBCR ]:='BCR '    ;    XTBL[XBC  ]:='BC  '    ;
  XTBL[XBCTR]:='BCTR'    ;    XTBL[XBCT ]:='BCT '    ;
  XTBL[XBALR]:='BALR'    ;    XTBL[XBAL ]:='BAL '    ;

  XTBL[XC   ]:='C   '    ;    XTBL[XCR  ]:='CR  '    ;
  XTBL[XTM  ]:='TM  '    ;
  XTBL[XCLC ]:='CLC '    ;    XTBL[XCLCL]:='CLCL'    ;

  XTBL[XSLA ]:='SLA '    ;    XTBL[XSLDA]:='SLDA'    ;
  XTBL[XSRA ]:='SRA '    ;    XTBL[XSRDA]:='SRDA'    ;
  XTBL[XSLL ]:='SLL '    ;    XTBL[XSLDL]:='SLDL'    ;
  XTBL[XCD ] :='CD  '    ;    XTBL[XCDR ]:='CDR '    ;

  BRMSK[PEQU] :=  8      ;    BRMSK[PNEQ] :=  7      ;
  BRMSK[PGEQ] := 11      ;    BRMSK[PGRT] :=  2      ;
  BRMSK[PLEQ] := 13      ;    BRMSK[PLES] :=  4      ;

  INVBRM[PEQU]:= PEQU    ;    INVBRM[PNEQ]:= PNEQ    ;
  INVBRM[PGEQ]:= PLEQ    ;    INVBRM[PGRT]:= PLES    ;
  INVBRM[PLEQ]:= PGEQ    ;    INVBRM[PLES]:= PGRT    ;


  FOR I := 0 TO HTSIZE DO  HTBL[I].NAME := EMPTY ;

  OP_SP := TRUE ;
"NH"  FOR OPC := 0 TO OPCNT DO
"NH"  BEGIN NMCDE := PTBL[OPC]; IF NMCDE <> EMPTY THEN ENTERLOOKUP  END;

  OP_SP := FALSE ;
"NH"  FOR CSP := 0 TO SPCNT DO
"NH"  BEGIN NMCDE := CSPTBL[CSP]; IF NMCDE <> EMPTY THEN
"NH"                                    ENTERLOOKUP  END;

  OP_SP := TRUE ;               (*TO PREPARE FOR OPCODE LOOKUP*)

  FOR NXTRG := 0 TO RGCNT DO AVAIL[NXTRG] := TRUE ;

  FOR NXTRG := 0 TO FPCNT DO AVAILFP[NXTRG] := TRUE ;

  FOR CH := 'A' TO 'Z' DO TYPCDE[CH] := NON ;

  TYPCDE['A'] := ADR ;  TYPCDE['B'] := BOOL ;
  TYPCDE['C'] := CHRC;  TYPCDE['I'] := INT ;
  TYPCDE['M'] := STRG;  TYPCDE['S'] := PSET;
  TYPCDE['P'] := PROC;  TYPCDE['R'] := REEL;
  TYPCDE['N'] := ADR ;  TYPCDE['J'] := INX ;
  TYPCDE['F'] := FORT;  TYPCDE['X'] := FBOOL;
  TYPCDE['Y'] := FINT;  TYPCDE['Z'] := FREAL;

  TOP := 1 ;  CURLVL := 1 ;  BRCND := -1 ;  NEG_CND := FALSE ;  TRACE := FALSE ;
  OLDOPC := PBGN ;  OLDCSP := PSIO ;  MDTAG := PBGN ;
  TXRG := TRG14 ; CSTOP := 0 ; " NXTLOC := 0 ; "
  ZEROBL.LVL := 0 ;  ZEROBL.DSPLMT := 0 ;  ERRORCNT := 0 ;  S370CNT := 0 ;
  LCAFTSAREA := LCAFTMST ;  SAVERGS := TRUE ; SAVEFPRS := FALSE ;
  CLEAR_REG := TRUE ;  PRE_PASS := TRUE ; OS_STYLE := TRUE ;
 "TOTALPCODE := 0 ;"   TOTALBYTES := 0 ;   CASE_FLAG := FALSE ;
 "CSPREGACTIVE := FALSE ;  FILREGACTIVE := FALSE ; "
  FILECNT      := 0 ;      ROUNDFLG     := FALSE ;
  ASM := FALSE ;      (*ASSEMBLY/OBJECT CODE SWITCH*)
  ASMVERB := FALSE ;  (*OUTPUT PROC. INFO. SWITCH*)
  CURPNO  := -1 ;  (* TO FLAG INITIALIZATION OF LINE # PTR TABLE *)
(*#DOING_IO := FALSE ;                                                    ####*)
(*#GET_STAT := FALSE ;                                                    ####*)
  MARK(HEAPMARK) ;

(*FOR CH := 'A' TO 'I' DO  EBCDIC[CH] := 192+ORD(CH) ;
  FOR CH := 'J' TO 'R' DO  EBCDIC[CH] := 199+ORD(CH) ;
  FOR CH := 'S' TO 'Z' DO  EBCDIC[CH] := 207+ORD(CH) ;
  FOR CH := '0' TO '9' DO  EBCDIC[CH] := 213+ORD(CH) ;
  EBCDIC[' ']  :=  64 ;
  EBCDIC['!']  :=  90 ;
  EBCDIC['"']  := 127 ;
  EBCDIC['#']  := 123 ;
  EBCDIC['$']  :=  91 ;
  EBCDIC['%']  := 108 ;
  EBCDIC['&']  :=  80 ;
  EBCDIC[''''] := 125 ;
  EBCDIC['(']  :=  77 ;
  EBCDIC[')']  :=  93 ;
  EBCDIC['*']  :=  92 ;
  EBCDIC['+']  :=  78 ;
  EBCDIC[',']  :=  107;
  EBCDIC['-']  :=  96 ;
  EBCDIC['.']  :=  75 ;
  EBCDIC['/']  :=  97 ;
  EBCDIC[':']  := 122 ;
  EBCDIC[';']  :=  94 ;
  EBCDIC['<']  :=  76 ;
  EBCDIC['=']  := 126 ;
  EBCDIC['>']  := 110 ;
  EBCDIC['?']  := 111 ;
  EBCDIC['@']  := 124 ;
  EBCDIC['[']  := 173 ;
  EBCDIC['Ý']  := 106 ;
  EBCDIC[']']  := 189 ;
  EBCDIC['^']  :=  95 ;
  EBCDIC['_']  := 109 ;  *)
  "CODE[MXCODE1] := 0 ;  CODE[MXCODE] := 0 ; "(* TO AVOID OVERFLOW *)

  END (*SETUP*) ;



BEGIN (*PCODE_TRANSLATOR*)

INIT := TRUE ;  SETUP ;  INIT := FALSE ;  (*INITIALIZE*)
TIMER := CLOCK(1) ;
(*+#IF GET_STAT THEN  INIT_STAT ;                                        ####+*)

WRITE(OUTPUT,'****':9, '      STANFORD PASCAL POST-PROCESSOR, VERSION OF ',
                       VERSION);
WRITELN(OUTPUT);

REPEAT
  READNXTINST ;
  ASMNXTINST ;
  IF TRACE THEN  DUMPSTK(1,TOP-1) ;
(*+#IF GET_STAT THEN  RECORD_STAT ;                                      ####+*)
 "IF NOT(OPC IN [PLOC, PLAB, PBGN, PEND]) THEN TOTALPCODE := TOTALPCODE+1 ;"
UNTIL OPC = PSTP ;

"NH" TIMER := CLOCK(1) - TIMER ;
WRITELN(OUTPUT) ;  WRITE(OUTPUT,'****':9) ;
IF ERRORCNT > 0 THEN WRITE(OUTPUT,ERRORCNT:8)
ELSE WRITE(OUTPUT, 'NO':8) ;
WRITELN(OUTPUT, ' ASSEMBLY ERROR(S) DETECTED.') ;
WRITELN(OUTPUT);
WRITELN(OUTPUT, '****':9,"TOTALPCODE:8, ' P_INSTRUCTIONS READ,',"TOTALBYTES:8,
                ' BYTES OF CODE GENERATED,', TIMER*0.001:6:2,
                ' SECONDS IN POST_PROCESSING.');

IF S370CNT > 0 THEN
  WRITELN(OUTPUT, '****':9, S370CNT:8,
                  ' "370"-ONLY INSTRUCTION(S) ISSUED.');

(*+#IF GET_STAT THEN   PRINT_STAT ;                                      ####+*)

EXIT(ERRORCNT) ;


END.
++FILE PASCALN.OLDCOMP.SOURCE                       MEMB PCOD1982 EXT PAS HEX -
(*$D-,N+*)
PROGRAM PCODE_TRANSLATOR(INPUT, OUTPUT, PRD, PRR) ;

  (********************************************************************
   *                                                                  *
   *                                                                  *
   *                                                                  *
   *   P_CODE (POST) PROCESSOR                                        *
   *   -----------------------                                        *
   *                                                                  *
   *                                                                  *
   *   COPYRIGHT 1976, STANFORD LINEAR ACCELERATOR CENTER.            *
   *                                                                  *
   *                                                                  *
   *   THIS IS A TRANSLATOR FOR THE MODIFIED  P-CODE  GENERATED  BY   *
   *   THE  SLAC  PASCAL   COMPILER.  THE TRANSLATOR TRANSLATES THE   *
   *   P_CODE INTO IBM/370 ASSEMBLY  LANGUAGE  OR  STANDARD  OS/370   *
   *   OBJECT  MODULE  WHICH  COULD BE RUN ON THE 370 USING A SMALL   *
   *   I/O PACKAGE.  ALSO  THE  IMMEDIATE  TARGET  MACHINE  OF  THE   *
   *   TRANSLATOR  IS  THE 360/370 COMPUTERS, THE MACHINE DEPENDENT   *
   *   MODULES IN THE PROGRAM ARE  RELATIVELY  ISOLATED  SUCH  THAT   *
   *   CONVERSIONS  FOR  OTHER  REGISTER  ORIENTED  TARGET MACHINES   *
   *   SHOULD BE STRAIGHTFORWARD.                                     *
   *                                                                  *
   *   REFER TO THE 'THE PASCAL P COMPILER:  IMPLEMENTATION  NOTES,   *
   *   U.  AMMANN, K.  JENSEN, H.  NAGELI, AND K.  NORI, DEC.  74.'   *
   *   FOR  THE DEFINITION OF THE P_MACHINE AND THE P SUBSET OF THE   *
   *   PROGRAMMING LANGUAGE "PASCAL".                                 *
   *                                                                  *
   *                                                                  *
   *                                                                  *
   *   -THE ERROR MESSAGES ISSUED  BY  THE TRANSLATOR  ARE  USUALLY   *
   *   ACCOMPANIED  BY THE  APPROXIMATE LINE  NUMBER  OF THE SOURCE   *
   *   STATEMENT.    THESE NUMBERS APPEAR ON THE LEFT OF THE SOURCE   *
   *   PROGRAM LISTING AND THE ERROR SHOULD BE LOCATED BETWEEN  THE   *
   *   STATEMENT  WITH THE GIVEN NUMBER AND THAT NUMBER+1.    THESE   *
   *   ERROR CODES SHOULD BE INTERPRETED ACCORDING TO THE FOLLOWING   *
   *   TABLE:                                                         *
   *                                                                  *
   *   253- PROCEDURE TOO LONG (LARGER THAN 8K BYTES).                *
   *        --> SUBDIVIDE THE PROCEDURE.                              *
   *   256- TOO MANY PROCEDURES/FUNCTIONS REFERENCED IN THIS PROC.    *
   *        --> RECOMPILE THE POST_PROCESSOR WITH  A  LARGER  VALUE   *
   *        FOR PRCCNT.                                               *
   *   259- EXPRESSION TOO COMPLICATED.                               *
   *        -->  SIMPLIFY  THE  EXPRESSION  BY  REARRANGING  AND/OR   *
   *        BREAKING.                                                 *
   *   263- TOO MANY (COMPILER GENERATED) LABELS IN THIS PROCEDURE.   *
   *        --> RECOMPILE THE POST_PROCESSOR WITH  A  LARGER  VALUE   *
   *        FOR LBLCNT.                                               *
   *   300- DIVIDE BY ZERO (RESULT OF CONSTANT PROPAGATION).          *
   *        --> FIX UP THE (CONSTANT) EXPRESSION EVALUATING TO ZERO.  *
   *   301- RANGE ERROR IN STRUCTURED CONSTANT.                       *
   *        --> CORRECT INITIAL VALUE FOR FIELD/ELEMENT OF CONSTANT.  *
   *   302- SUBSCRIPTRANGE ERROR (RESULT OF CONSTANT PROPAGATION).    *
   *        --> FIX UP THE CONSTANT SUBSCRIPT EXPRESSION.             *
   *   303- CONSTANT SET TOO LARGE FOR TARGET VARIABLE IN AN ASSMT.   *
   *        --> CORRECT DECLARATION FOR VARIABLE.                     *
   *                                                                  *
   *   504- SIZE OF ARRAY ELEMENT TOO LARGE.                          *
   *        --> REORDER THE DIMENSIONS OF THE ARRAY (SO THAT THE      *
   *        THE LARGER DIMENSIONS ARE FIRST) OR REDUCE THE RANGE      *
   *        OF THE LOW ORDER (LAST) INDICES.                          *
   *                                                                  *
   *   THE FOLLOWING ERRORS NORMALLY INDICATE AN INCONSISTENCY IN     *
   *   THE COMPILER AND OR THE POST_PROCESSOR.                        *
   *                                                                  *
   *   601- TYPE CONFLICT OF OPERANDS IN THE P_PROGRAM.               *
   *   602- OPERAND SHOULD BE OF TYPE 'ADR'.                          *
   *   604- ILLEGAL TYPE FOR RUN TIME CHECKING.                       *
   *   605- OPERAND SHOULD BE OF TYPE 'BOOL'.                         *
   *   606- UNDEFINED P_INSTRUCTION CODE.                             *
   *   607- UNDEFINED STANDARD PROCEDURE NAME.                        *
   *   608- DISPLACEMENT FIELD OUT OF RANGE                           *
   *   609- SMALL PROC IS LARGER THAN 4K, RESET SHRT_PROC = 350       *
   *   610- BAD HALFWORD INTEGER ALIGNMENT                            *
   *   611- BAD INTEGER ALIGNMENT.                                    *
   *   612- BAD REAL ALIGNMENT.                                       *
   *   614- THE PRE_PASS FILE (PRD) IS INCONSISTENT.                  *
   *   615- OPERAND SHOULD BE OF TYPE 'SET'.                          *
   *   616- CONSISTENCY CHECK ON 'SET' OPS FAILED.                    *
   *   617- BAD DISPLACEMENT FOR STRUCTURED CONSTANT.                 *
   *   618- UNEXPECTED END-OF-FILE WHEN READING P-CODE.               *
   *   619- BAD OPERANDS FOR PACK/UNPACK PROCEDURE.                   *
   *                                                                  *
   *   THIS PROGRAM SHOULD NOT BE COMPILED WITH THE 'D+' OPTION.      *
   *                                                                  *
   *                                                                  *
   *                                                                  *
   *                           S. HAZEGHI,                            *
   *                                                                  *
   *                           COMPUTATION RESEARCH GROUP             *
   *                           STANFORD LINEAR ACCELARATOR CENTER     *
   *                           STANFORD, CA. 94305.                   *
   *                                                                  *
   *                                                                  *
   *   EXTENSIVE MODIFICATIONS MADE BY:                               *
   *                                                                  *
   *                           R. NIGEL HORSPOOL                      *
   *                                                                  *
   *                           SCHOOL OF COMPUTER SCIENCE             *
   *                           MCGILL UNIVERSITY                      *
   *                           805 SHERBROOKE STREET WEST             *
   *                           MONTREAL                               *
   *                           QUEBEC  H3A 2K6   CANADA               *
   *                                                                  *
   *                                                                  *
   ********************************************************************)




CONST
      VERSION  = 'MAY -82';
      MXADR    =  65535 ;
      SHRTINT  =   4095 ;
      HALFINT  =  32700 ;
      STKDPTH  =     15 ;
      MXLVL    =     16 ;
      IDLNGTH  =     12 ;  (*LENGTH OF IDENTIFIERS                            *)
      RGCNT    =      9 ;  (*REGISTER COUNT                                   *)
      FPCNT    =      6 ;  (*FLOATING POINT REG. COUNT                        *)
      GBR      =     12 ;  (*GLOBAL BASE REGITER                              *)
      LBR      =     13 ;  (*LOCAL    "     "                                 *)
      JREG     =     15 ;  (*JUMP (BRANCH) REGISTER                           *)
      RTREG    =     14 ;  (*RETURN ADDR. REGISTER                            *)
      TRG0     =      0 ;  (*PARAMETER REGISTER                               *)
      FPR0     =      0 ;  (*FLOATING POINT REGISTER 0                        *)
      TRG1     =      1 ;  (*TEMPORARY VALUE/BASE REGISTERS                   *)
      TRG13    =     13 ;  (*SAVE AREA/LOCAL STACK FRAME                      *)
      TRG14    =     14 ;
      TRG15    =     15 ;
      TRG9     =      9 ;
      PBR1     =     10 ;
      PBR2     =     11 ;
      FILADR   =      9 ;  (*FILE ADDRESS REGISTER                            *)
      MXSLNGTH =     72 ;
"**"  MXPLNGTH =     32 ;  (*MAX NO. OF BYTES IN A POWER SET                  *)
"**"  MXSETINX =      4 ;  (* = MXPLNGTH DIV 8                                *)
"**"  MXSETIXI =      8 ;  (* = MXPLNGTH DIV 4                                *)
      HDRLNGTH =     32 ;  (*LENGTH OF PROGRAM HEADING                        *)
"@@"  EOFDPLMT =      0 ;  (*POSN OF EOF FLAG WITHIN FILE HEADER             *)
"@@"  EOLDPLMT =      4 ;  (*POSN OF EOL FLAG WITHIN HEADER FOR TEXT FILES   *)
"&&"  FILHDRSZ =      8 ;  (*OFFSET OF FILE COMPONENT WITHIN FILE VAR.       *)

      ADRSIZE  =      4 ;  CHARSIZE = 1 ;  BOOLSIZE = 1 ;
"&&"  INTSIZE  =      4 ;  HINTSIZE = 2 ;  REALSIZE = 8 ;


                          (* LAYOUT OF THE 'GLOBAL' STACK FRAME:              *)

      NEWPTR   =     72 ; (* NEWPTR , OFFSET FROM BOTTOM OF RUNTIME STACK     *)
      HEAPLMT  =     76 ; (* HEAP LIMIT PTR, OFFSET FROM BOTTOM OF STACK      *)
      DYNRUNC  =      0 ; (* # OF COUNTERS , FIELD OFFSET FROM HEAPLMT        *)
"&&"  DYN2LEN  =      8 ; (* LENGTH OF THE DYN. INFO. AREA AT THE END OF HEAP *)
      FNCRSLT  =     72 ; (* FUNCTION RESULT LOCATION, OFFSET FROM MP         *)

      DISPLAY  =     80 ; (* DISPLAY REGS, OFFSET FROM BOTTOM OF RUNTIME STK  *)
"&&"  DISPAREA =     40 ; (* SIZE OF DISPLAY TABLE                            *)
      LCAFTMST =     80 ; (* SIZE OF THE PROCEDURE LINKAGE AREA               *)
      FPRSAREA =     80 ; (* FLOATING PT. REGS SAVE AREA, (OPTIONAL SAVE)     *)
      FPSIZE   =     32 ; (* LENGTH OF FPR SAVE AREA                          *)

      FL1      =    120 ; (*GLOBAL LOCATIONS USED FOR FIX-FLOAT CONVERSIONS   *)
      FL2      =    128 ;    "                                       "
      FL3      =    136 ;    "                                       "
      FL4      =    144 ;    "                                       "

      INXCHK   =    152 ; (* ADDRESS OF RUNTIME CHECK ROUTINES                *)
      RNGCHK   =    164 ;
      PRMCHK   =    176 ;
      PTRCHK   =    188 ;
      PTACHK   =    200 ;
      SETCHK   =    212 ;
      STKCHK   =    224 ;
"&&"  TRACER   =    236 ; (* CONTROL FLOW TRACE ROUTINE                       *)

      FILEBUFS =    248 ; (* INPUT, OUTPUT, PRD,.... BUFFERS                  *)
"@@"  CLEARBUF =    320 ; (* PRESET BUFER TO ERASE MEMORY WITH ITS CONTENTS   *)
"@@"  PASDATE  =    328 ; (* PREDEFINED DATE VARIABLE                         *)
"@@"  PASTIME  =    338 ; (* PREDEFINED TIME VARIABLE                         *)
"@@"  OSPRM    =    348 ; (* POINTER TO O.S. PARMS RECORD                     *)
"@@"  FRSTGVAR =    352 ; (* FIRST GLOBAL VAR, SHOULD BE A MULTIPLE OF 8      *)

                          (* VARIOUS TABLE SIZES AND MISC. CONSTATNTS         *)

"&&"  HTSIZE   =    200 ; (* HASH TABLE SIZE (MUST EXCEED # OPS + # CSP OPS)  *)

      DBLCNT   =    200 ; (* SIZE OF LITERAL POOL - IN DOUBLE-WORDS           *)
"&&"  DBLDANGER =   190 ; (* SAFE LIMIT FOR NXTDBL                            *)
"**"  INTCNT   =    400 ; (*   = DBLCNT*2                                     *)
"**"  HWCNT    =    800 ; (*   = DBLCNT*4                                     *)
"&&"  CHCNT    =   1600 ; (*   = DBLCNT*8                                     *)
"&&"  LITCNT   =    400 ; (* # OF NUMERIC LITERALS IN A PROC.                 *)
"&&"  LITDANGER =   395 ; (* SAFE LIMIT FOR NXTLIT                            *)
"&&"  PRCCNT   =     50 ; (* # OF PROC'S OR ENTRY PT.S IN ONE CSECT           *)
      LBLCNT   =    220 ; (* # OF LABELS IN A CSECT                           *)
"&&"  MAXCALDPTH =    4 ; (* MAX NESTING OF FUNCTION CALLS IN A STMT.         *)

      MXCODE   =   4092 ; (* MAX OBJECT CODE SIZE (APPROX. 8K BYTES)          *)
      MXCODE1  =   4093 ;
"&&"  MXLNP    =    800 ; (* SIZE OF LINE NUMBER TABLE IN BYTES               *)
      ENDCODE  =   4500 ; (* MXCODE+MXLN DIV 2, LINE NO.S NOT A PART OF CODE  *)
"&&"  TXTCHUNK =     56 ; (* MAX. BYTES PER TXT CARD IN 360 OBJECT DECK       *)

      LESCND   =      4 ;         LEQCND = 13 ;  (* CONDITION CODE SYMBOLS    *)
      GRTCND   =      2 ;         GEQCND = 11 ;
      EQUCND   =      8 ;         NEQCND =  7 ;
      ANYCND   =     15 ;         NOCND  =  0 ;
      TRUCND   =      1 ;         FLSCND =  8 ;

      SHRT_PROC=    550 ; (* LIMIT VALUE FOR A PROC. TO BE CONSIDERED SMALL   *)


     (* OPCODE TABLES  (P-OPCODES / P-STANDARD PROCS / 370-OPCODES )          *)

                                   XLTR = "0 " 18  ;
      XL   = "1 " 88  ;            XLH  = "2 " 72  ;
      XLD  = "3 " 104 ;            XLR  = "4 " 24  ;
      XLDR = "5 " 40  ;            XIC  = "6 " 67  ;
      XLM  = "7 " 152 ;            XLA  = "8 " 65  ;
      XLPR = "9 " 16  ;            XLCR = "10" 19  ;
      XLPDR= "19" 32  ;            XLCDR= " ?" 35  ;
      XLTDR=      34  ;

      XA   = "11" 90  ;            XAH  = "12" 74  ;
      XAD  = "13" 106 ;            XAR  = "14" 26  ;
      XADR = "15" 42  ;            XSDR = "16" 43  ;
      XMDR = "17" 44  ;            XDDR = "18" 45  ;
      XAW  = "20" 110 ;

      XST  = "21" 80  ;            XSTD = "22" 96  ;
      XSTH = "23" 64  ;            XSTC = "24" 66  ;
      XSTM = "25" 144 ;

      XMVC = "27" 210 ;            XMVCL= "28" 14  ;
      XMVI = "29" 146 ;

      XS   = "31" 91  ;            XSH  = "32" 75  ;
      XSD  = "33" 107 ;            XSR  = "34" 27  ;

      XN   = "35" 84  ;            XNR  = "36" 20  ;
"**"  XNC  =      212 ;
      XO   = "37" 86  ;            XXOR  = "38" 22  ;
"**"  XOC  =      214 ;
      XX   = "39" 87  ;            XXR  = "40" 23  ;
"**"  XXC  =      215 ;

      XM   = "41" 92  ;            XMH  = "42" 76  ;
      XMD  = "43" 108 ;            XMR  = "44" 28  ;

      XD   = "47" 93  ;
      XDD  = "49" 109 ;            XDR  = "50" 29  ;

      XBCR = "51" 7   ;            XBC  = "52" 71  ;
      XBCTR= "53" 6   ;            XBCT = "54" 70  ;
      XBALR= "55" 5   ;            XBAL = "56" 69  ;

      XC   = "57" 89  ;            XCR  = "58" 25  ;
"&&"  XCH  =      73  ;
"**"  XCL  =     85  ;             XCLR  =      21 ;
"**"  XTM  = "59" 145 ;            XCLI =      149 ;
      XCLC = "60" 213 ;            XCLCL= "  "  15 ;

      XSLA = "61" 139 ;            XSLDA= "62" 143 ;
      XSRA = "63" 138 ;            XSRDA= "64" 142 ;
      XSLL = "65" 137 ;            XSLDL= "66" 141 ;
"**"  XSRL =     136 ;             XSRDL=      140 ;
      XCD  = "67" 105 ;            XCDR = "68" 41  ;

"**"  XEX  =      68 ;



TYPE

"&&"  OPTYPE      = (PCTS, PCTI, PLOD, PSTR, PLDA, PLOC, PSTO, PLDC,
"&&"                 PLAB, PIND, PINC, PPOP, PCUP, PENT, PRET, PCSP,
"&&"                 PIXA, PEQU, PNEQ, PGEQ, PGRT, PLEQ, PLES, PUJP,
"&&"                 PFJP, PXJP, PCHK, PNEW, PADI, PADR, PSBI, PSBR,
"&&"                 PSCL, PFLT, PFLO, PTRC, PNGI, PNGR, PSQI, PSQR,
"&&"                 PABI, PABR, PNOT, PAND, PIOR, PDIF, PINT, PUNI,
"&&"                 PINN, PMOD, PODD, PMPI, PMPR, PDVI, PDVR, PMOV,
"&&"                 PLCA, PDEC, PSTP, PSAV, PRST, PCHR, PORD, PDEF,
"&&"                 PRND, PCRD, PXPO, PBGN, PEND, PASE, PSLD, PSMV,
"&&"                 PMST, PUXJ, PXLB, PCST, PDFC, PPAK, UNDEF_OP );
"&&"  CSPTYPE     = (PGET, PPUT, PRES, PRLN, PREW, PWLN, PWRS, PELN,
"&&"                 PWRI, PWRR, PWRC, PRDI, PRDR, PRDC, PRDH, PRDY,
"&&"                 PRDD, PWRD, PWRE, PEOL, PEOF, PXIT, PRDS, PTRP,
"&&"                 PSIO, PEIO, PCLK, PFDF, PPAG, PNUL, PRDB, PWRB,
"&&"                 PSKP, PLIM, PMSG, PEOT, PCTR, PTRA, UNDEF_CSP );
"&&"  DATATYPE    = (BOOL,CHRC,ADR,HINT,INT,PSET,REEL,PROC,STRG,INX,
                     FORT,FINT,FBOOL,FREAL,NON);
      BETA        = ARRAY[1..3] OF CHAR ;
"&&"  DUMMYRNG    = 0 .. 1;
"&&"  HINTEGER    = -32768 .. 32767 ;
      STRNG       = PACKED ARRAY [1..MXSLNGTH] OF CHAR ;
      ALFA        = PACKED ARRAY [1..8] OF CHAR ;
      IDTYPE      = PACKED ARRAY [1..IDLNGTH] OF CHAR ;
      ADRRNG      = 0..MXADR ;
"&&"  LVLRNG      = -2..MXLVL ;
      RGRNG       = LVLRNG ;      (* REGISTER NUMBER RANGE                    *)
"**"  SSETRNG     = SET OF 0..63 ;
"**"  SETINX      = 1 .. MXSETINX ;
"**"  SETRNG      = ARRAY[SETINX] OF SSETRNG ;
      BYTE        = 0..255 ;
      LINE_NUM    = 0..10000 ;
      STKPTR      = 0..STKDPTH ;  (* POINTER TO THE COMPILE_TIME STACK        *)
      LVLDSP      = RECORD DSPLMT: INTEGER; LVL: LVLRNG  END ;
      BANK        = (RGS,MEM,ONSTK,NEITHER) ;    (*WHERE ABOUT OF THE OPERAND *)
      SPTR        = @STRNG;
      ICRNG       = 0..MXCODE1;   (* PROGRAM COUNTER RANGE                    *)
      LBLRNG      = -1..LBLCNT;   (* RANGE OF P_COMPILER GENERATED LABELS     *)
      STRLRNG     = 0..MXSLNGTH;
"&&"  PLNRNG      = 0..MXPLNGTH;
      POSINT      = 0..214748360 ;
"&&"  HEX4        = ARRAY[1..4] OF CHAR;

"**"  SET_S_I   = RECORD
"**"              CASE INTEGER OF
"**"              1: (S: SETRNG);
"**"              2: (I: ARRAY[1..MXSETIXI] OF INTEGER);
"**"              3: (C: ARRAY[1..MXPLNGTH] OF CHAR);
"**"              4: (R: ARRAY[1..MXSETINX] OF REAL)
"**"              END ;

"**"  MNEM_TABLE = ARRAY[0..255] OF ARRAY[1..4] OF CHAR;


      PLABEL      = RECORD
                    NAM : ALFA ;
                    LEN : 0.. IDLNGTH
                    END ;

      DATUM       = RECORD
                    RCNST : REAL ;
                    PCNST : @SETRNG ;
                    STKADR: ADRRNG ;
                    FPA   : LVLDSP ;
"&&"                PLEN: PLNRNG;
"&&"                SCNSTNO: 0..LITCNT;
                    DTYPE: DATATYPE ;
                    VRBL, DRCT : BOOLEAN ;

                    CASE VPA: BANK OF
                       RGS: (RGADR: RGRNG) ;
                       MEM: (MEMADR: LVLDSP)
                    END ;


VAR   OPC, OLDOPC:     OPTYPE;     (* CURRENT/OLD INST. OPCODE                *)
      CSP, OLDCSP:     CSPTYPE;    (* CURRENT STND. PROC. CODE                *)
      NMCDE, EMPTY:    BETA ;      (* CURRENT (SYMBOLIC) PCODE /CSP NAME      *)
      OP_SP :          BOOLEAN ;   (* P INSTR/SP SWITCH                       *)
      INIT:    BOOLEAN ;           (* INITIALIZATION PHASE FLAG               *)
      CH:      CHAR ;              (* CURRENT INPUT CHARACTER                 *)
      BVAL:    BOOLEAN ;
      CHVAL:   CHAR ;
      IVAL:    INTEGER ;
      RVAL:    REAL ;
"**"  PSVAL:   SET_S_I ;
      STRPTR:  SPTR ;
"**"  PSLNGTH: 0 .. MXPLNGTH ;
      SVAL :   STRNG ;
      SLNGTH :  0..MXSLNGTH ;
      CURLVL:  LVLRNG ;            (* CURRENT PROC. STATIC LEVEL              *)
      TOP :    STKPTR ;            (* TOP OF EXPRESSION STACK                 *)
"&&"  CALDPTH : 0 .. MAXCALDPTH ;  (* PROC. CALL NESTING                      *)
      LASTLN,  NXTLNP,
      LASTPC,  LASTPCDIF : INTEGER ;
      LBL1, LBL2, LBL3,
      SEGSZE : PLABEL ;            (* LEFT AND RIGHT LABELS OF INSTRUCTIONS   *)
      OPNDTYPE: DATATYPE ;         (* TYPE OF OPERAND OF INSTRUCTION          *)
"&&"  P, Q, R: INTEGER ;           (* P_Q FIELDS OF INSTRUCTION               *)
"&&"  CADDR,                       (* LOC. OF STRUCT. CONSTANT ITEM           *)
      SP     : ADRRNG ;            (* MEMORY STACK POINTER, NOT USED          *)
      LCAFTSAREA : ADRRNG ;        (* FIRST LOC. AFTER PROC. SAVE AREA        *)
      FILECNT : 0..2 ;             (* COUNT OF ACTIVE FILE ADDRESSES          *)
"&&"  DEBUG_LEV : 0..9 ;           (* DEBUG CHECK LEVEL                       *)
      NXTRG, TXRG: RGRNG ;         (* AQUIRED REGISTERS                       *)

"&&"  DBLALN, OPT_FLG,             (* DWRD ALIGNMENT NEEDED, OPT. IN EFFECT   *)
      FILREGACTIVE,                (* FILE ADDRESS REG. ACTIVE                *)
      CSPREGACTIVE,                (* I/O REGISTERS ACTIVE                    *)
"&&"  CSTBLK, MUSIC,               (* STRUCT. CONST. BLOCK?, MUSIC O.S.?      *)
      CLEAR_REG, NEG_CND,          (* CLEAR BEFORE LOADING THE REG.           *)
      SAVERGS, SAVEFPRS,
      DEBUG, OS_STYLE, CASE_FLAG,
      TRACE, NEWLINE, FLIPDEBUG,
"**"  RUNPROFILE, CKMODE,          (* VARIOUS OPTIONS                         *)
      ASM, FLOW_TRACE,             (* OBJ LISTING, FLOW-TRACING FLAGS         *)
      ASMVERB,                     (* VERBOSE ASSEMBLY                        *)
      GET_STAT :  BOOLEAN ;        (* CURRENTLY UNUSED                        *)
      CURLINE : LINE_NUM ;         (* CURRENT SOURCE LINE NUMBER              *)
"&&"  POOL_SIZE : ICRNG ;          (* LITERAL POOL SIZE FOR STATISTICS ONLY   *)
"&&"  NUMLITS : INTEGER ;          (* NUMBER OF LITERALS, FOR STATISTICS      *)
"&&"  PCAFTLIT: ICRNG ;            (* PC AFTER LITERAL DUMP                   *)
      MDTAG :   OPTYPE;            (* MULTIPLY/DIVIDE TAG                     *)
      HEAPMARK : @INTEGER ;
"**"  TESTCNT  : INTEGER ;
      ZEROBL :   LVLDSP    ;       (* TO CLEAR BASE ,DISPLACEMENT FIELDS      *)
      TOTALBYTES,
      ERRORCNT :  INTEGER ;        (* TOTAL ERROR COUNT, ALSO RETURN CODE     *)
      S370CNT :   INTEGER ;        (* COUNT OF 370-ONLY INSTRUCTIONS GENERATED*)

      I_S_R   : RECORD             (* SET <=> INTEGER <=> REAL, 370 IMPL.ONLY *)
                CASE (*TAG:*) INTEGER OF
                     1:   (I1: INTEGER; I2: INTEGER) ;
"**"                 2:   (S: SSETRNG) ;
                     3:   (R: REAL ) ;
"**"                 4:   (C1, C2, C3, C4: CHAR ) ;
                END ;

      TYPCDE: ARRAY ['A'..'Z'"CHAR"] OF DATATYPE ; (* ENCODING OF TYPE FIELD *)
      STK:   ARRAY [STKPTR] OF DATUM ;       (* EXPRESSION STACK              *)
      AVAIL:   ARRAY [0..RGCNT] OF BOOLEAN ; (*AVAILABLE REGISTERS            *)
      AVAILFP: ARRAY [0..FPCNT] OF BOOLEAN ; (* AVAIL. F.P. REGS              *)

      INVBRM:  ARRAY [PEQU..PLES] OF PEQU..PLES ; (* INV. MAP OF REL. OPCODES *)
      BRMSK:   ARRAY [PEQU..PLES] OF 0..15 ;      (* 370 CONDITION CODES      *)
      BRCND : -1..15 ;                            (* ACTIVE BRANCH MASK       *)
      TIMER : POSINT ;
"**"  XTBL  : @ MNEM_TABLE ;
"&&"  HEXCHARS: ARRAY[0..15] OF CHAR;

      HTBL: ARRAY [0..HTSIZE] OF                  (* HASH TABLE, INST./PROCS *)
                RECORD
                NAME: BETA ;
                CASE "KIND:" BOOLEAN OF
                  FALSE: (OPCDE: OPTYPE) ;
                  TRUE : (SPCDE: CSPTYPE)
                END ;

"&&"  LAST_CC: RECORD   (* REMEMBERS USEFUL COND-CODE MEANINGS *)
"&&"              LPC: ICRNG;  LOP: BYTE;  LR: RGRNG
"&&"           END;

"&&"  TXR_CONTENTS: RECORD   (* REMEMBERS CONTENTS OF REG 14 *)
"&&"                   VALID: BOOLEAN;  LEVEL: LVLRNG;
"&&"                   OFFSET, DISP: ADRRNG;  BASE: RGRNG
"&&"                END;

"&&"  LAST_STR:     RECORD   (* REMEMBERS OPNDS OF LAST STR INSTR. *)
"&&"                   STOPND: LVLDSP;  STRG: RGRNG;
"&&"                   LPC: ICRNG;  STDT: DATATYPE;
"&&"                END;
"&&"
"&&"  LAST_FILE:    RECORD   (* REMEMBERS LAST FILE USED *)
"&&"                   LPC: ICRNG;  LFOPND: LVLDSP;  LFV: BOOLEAN
"&&"                END;
"&&"
"&&"  LAST_MVC:     RECORD   (* REMEMBERS LAST MVC INSTRUCTION *)
"&&"                   LPC: ICRNG;  LLEN: BYTE;
"&&"                END;

  (* PRE-PASS (PRD FILE) INFORMATION                                          *)

      PROC_SIZE  : ICRNG ;
      DATA_SIZE  : ADRRNG ;
      CALL_CNT   : 0..50 ;
      CALL_HIGHER, LARGE_PROC, LARGE_DFRAME, PRE_PASS : BOOLEAN ;


  (* POINTERS TO LAST ELEMENTS OF 'OBJECT' CODE TABLES                        *)


"&&" NXTINT  : 0..INTCNT;  NXTDBL : 0..DBLCNT;  NXTCH : 0..CHCNT;
"&&" NXTPRC, NXTEP  : 0..PRCCNT;
     PC      : ICRNG ;     (* PROGRAM COUNTER DIV 2                          *)
"&&" CPC,                  (* PC FOR CONSTANT BLOCK                           *)
"&&" CSEGSTRT,             (* START FOR CPC IN CURRENT SEGMENT                *)
"&&" CSEGLIMIT : HINTEGER; (* END FOR CPC IN CURRENT SEGMENT                  *)
     MINLBL  : LBLRNG ;    (* STARTING LABEL VALUE FOR CURRENT PROC          *)


  (* DECLARATIONS FOR LITERAL TABLES ...ETC. NEEDED TO GENERATE OBJECT MODULE *)

     CURPNAME : ARRAY[1..12] OF CHAR ;     (*NAME OF THE CURRENT PROC        *)
     CURPNO   : INTEGER ;                  (*CURRENT PROC #                  *)
"&&" NXTLIT: -1 .. LITCNT ;
"**" HW_GAP: -1..HWCNT ;                    (*SPARE HALFWORD SLOT IN TABLE   *)
"**" INT_GAP, IHCONF: -1..INTCNT ;            (*SPARE INTEGER SLOT, CONFLICT  *)
"**" RICONF, RHCONF: -1..DBLCNT ;           (*CONFLICTS WITH REAL TABLE      **)

"&&" CODE     : RECORD CASE INTEGER OF
"&&"            1: (H: ARRAY(/0..ENDCODE/) OF HINTEGER);
"&&"            2: (I: ARRAY(/DUMMYRNG/)   OF  INTEGER);
"&&"            3: (R: ARRAY(/DUMMYRNG/)   OF     REAL);
"&&"            4: (C: ARRAY(/DUMMYRNG/)   OF     CHAR);
"&&"            5: (TXTCARD: ARRAY(/DUMMYRNG/) OF
"&&"                         ARRAY(/1..TXTCHUNK/) OF CHAR);
"&&"            END;

"**" IDP_POOL : RECORD CASE INTEGER OF
"**"              1: ( R: ARRAY[0..DBLCNT] OF REAL );
"**"              2: ( I: ARRAY[0..INTCNT] OF INTEGER );
"&&"              3: ( H: ARRAY[0..HWCNT ] OF HINTEGER );
"**"              4: (S: ARRAY[0..DBLCNT] OF SSETRNG );
"&&"              5: (C: ARRAY[0..CHCNT] OF CHAR );
"**"            END;

"&&" LITTBL : ARRAY[1..LITCNT] OF RECORD LNK: ICRNG END ;

     LBLTBL : ARRAY[0..LBLCNT] OF  RECORD
                                   DEFINED : BOOLEAN ;
"&&"                               LNK     : ICRNG
                                   END ;

     PRCTBL : ARRAY[0..PRCCNT] OF  RECORD
                                   NAME : ALFA ;
"&&"                               LNK  : ICRNG
                                   END ;

"&&" CALSTK : ARRAY[1..MAXCALDPTH] OF RECORD
"&&"                               PFLEV: INTEGER;  DISPSAV: ADRRNG
"&&"                               END;

     PROGHDR: ARRAY[1..HDRLNGTH] OF CHAR;     (*PROGRAM HEADER/DATE/TIME    *)

(*_________________________________________________________________*)

PROCEDURE ERROR(ERRCDE: INTEGER) ;
  BEGIN
  ERRORCNT := ERRORCNT+1 ;
  WRITELN('****  PERROR':17, ERRCDE:8, '( NEAR LINE':13,
       LASTLN:6, 'OF PROCEDURE:':15, CURPNAME:14, ')':2 );
  IF ERRCDE = 253 THEN WRITELN('- PROCEDURE TOO LARGE.':33);
  IF ERRCDE = 256 THEN WRITELN('- TOO MANY PROC/FUNC CALLS IN THIS PROC.':51);
  IF ERRCDE = 259 THEN WRITELN('- EXPRESSION TOO COMPLICATED.':40);
  IF ERRCDE = 263 THEN WRITELN('- TOO MANY CONTROL JUMPS IN THIS PROC.':49);
  IF ERRCDE = 300 THEN WRITELN('- IMPLIED DIVISION BY ZERO.':38);
  IF ERRCDE = 301 THEN WRITELN('- RANGE ERROR IN STRUCTURED CONST.':45);
  IF ERRCDE = 302 THEN WRITELN('- IMPLIED SUBSCRIPTRANGE ERROR.':42);
  IF ERRCDE = 303 THEN WRITELN('- ILLEGAL CONSTANT SET ASSMT.':40);
  IF ERRCDE = 504 THEN WRITELN('- ARRAY COMPONENT TOO LARGE (>32K).':47);
  IF ERRCDE = 618 THEN WRITELN('- UNEXPECTED EOF IN P-CODE INPUT':45);
  END ;

"**" PROCEDURE CHECKFREEREGS;
"**"    (* TO BE INVOKED WHEN COMPILATION STACK IS EMPTY,
"**"       CHECKS THAT ALL REGS HAVE BEEN MARKED AS AVAILABLE *)
"**"  VAR LIST: ARRAY[1..12] OF
"**"              RECORD  RGNO: RGRNG;  KIND: CHAR  END;
"**"      LP:   0..12;   I: RGRNG;
"**"  BEGIN
"&&"    IF TOP <> 1 THEN
"&&"      BEGIN  WRITELN('0    ****  WARNING: STACK HEIGHT =', TOP:3 );
"&&"             TOP := 1
"&&"      END;
"**"    I := 1;  LP := 0;
"**"    REPEAT  I := I + 1;
"**"      IF NOT AVAIL[I] THEN
"**"        BEGIN  LP := LP + 1;
"**"          LIST[LP].RGNO := I;  LIST[LP].KIND := 'G';
"**"          AVAIL[I] := TRUE;
"**"        END;
"**"    UNTIL I >= RGCNT;
"**"    I := 0;
"**"    REPEAT  I := I + 2;
"**"      IF NOT AVAILFP[I] THEN
"**"        BEGIN  LP := LP + 1;
"**"          LIST[LP].RGNO := I;  LIST[LP].KIND := 'F';
"**"          AVAILFP[I] := TRUE;
"**"        END;
"**"    UNTIL I >= FPCNT;
"**"    IF LP > 0 THEN
"**"      BEGIN  WRITELN('0    ****  WARNING: REGISTERS NOT FREED ');
"**"        FOR I := 1 TO LP DO
"&&"          WRITE( LIST[I].KIND:8, 'PR', LIST[I].RGNO:3 );
"**"        WRITELN;  WRITELN( '( NEAR LINE':34, LASTLN:6,
"**"                   'OF PROCEDURE:':15, CURPNAME:14, ')':2 );
"**"      END;
"**"  END  (* CHECKFREEREGS *) ;


PROCEDURE ENTERLOOKUP;
"&&" LABEL 10;
"&&" CONST STEP = 17;  (* MUST BE COPRIME TO HTSIZE *)
     VAR H: 0..HTSIZE ;
  BEGIN
     H := (ORD(NMCDE[1])*64+ORD(NMCDE[2])*4096+ORD(NMCDE[3])) MOD HTSIZE ;
10:  WITH HTBL(/H/) DO
       IF NAME <> NMCDE THEN
         IF NAME <> EMPTY THEN
"&&"        BEGIN  H := H + STEP;  IF H >= HTSIZE THEN H := H - HTSIZE;
"&&"              GOTO 10;  (* NO CHECK FOR CYCLES! *)  END
"&&"      ELSE IF INIT THEN
"&&"             BEGIN  (* ENTER THE ITEM *)
"&&"               NAME := NMCDE;
"&&"               IF OP_SP THEN OPCDE := OPC ELSE SPCDE := CSP
"&&"             END
"&&"           ELSE
"&&"             IF OP_SP THEN OPC := UNDEF_OP ELSE CSP := UNDEF_CSP
"&&"    ELSE
"&&"      IF OP_SP THEN OPC := OPCDE ELSE CSP := SPCDE;
  END (*ENTERLOOKUP*) ;


FUNCTION FLDW(NUM : INTEGER) : INTEGER ;
  VAR FW : INTEGER ;
  BEGIN
    FW := 0 ;
    IF NUM < 0 THEN  BEGIN  FW := 1 ;  NUM := ABS(NUM) ;  END ;
    REPEAT
      NUM := NUM DIV 10 ;  FW := FW+1 ;
    UNTIL NUM = 0 ;
    FLDW := FW
  END (*FLDW*);


PROCEDURE DUMPSTK(STP1, STP2: STKPTR) ;
"&&" CONST TYPNAME: ARRAY(/BOOL..STRG/) OF ARRAY(/1..4/) OF CHAR
"&&"       = ('BOOL', 'CHR ', 'ADR ', 'HINT', 'INT ', 'SET ',
"&&"          'REAL', 'PROC', 'STRG');
  VAR I : STKPTR ;
  BEGIN
  FOR I := STP1 TO STP2 DO
    WITH STK[I] DO
      BEGIN WRITE(OUTPUT,' +++ DEPTH =',I:3,'  FPA =',FPA.LVL:3, FPA.DSPLMT:6) ;
      IF VRBL THEN
      BEGIN
        IF VPA = RGS THEN WRITE(OUTPUT,'  VPA-REG =',RGADR:3)
        ELSE  WRITE(OUTPUT,'  VPA-MEM =',MEMADR.LVL:3,MEMADR.DSPLMT:6) ;
        IF DRCT THEN WRITE(OUTPUT,'  DIRECT ACC.')
          ELSE WRITE(OUTPUT,'  INDIRECT ACC.') ;
        END ;
"&&"  IF DTYPE <= STRG THEN
"&&"    WRITELN(OUTPUT,'(':3,TYPNAME(/DTYPE/),')')
"&&"  ELSE WRITELN(OUTPUT,'(ETC.)':9);
      END (*WITH*) ;
  END (*DUMPSTK*) ;


"&&" PROCEDURE HEXHW( HW: HINTEGER; VAR HEX: HEX4 );
"&&"   (* CONVERTS HALFWORD TO 4 HEXADECIMAL CHARACTERS *)
"&&"   VAR  C: INTEGER;  N: 1..4;
"&&"   BEGIN
"&&"     C := 65536 + HW;  (* ELIMINATES HW<0 CASE *)
"&&"     FOR N := 4 DOWNTO 1 DO
"&&"       BEGIN  HEX[N] := HEXCHARS[ C MOD 16 ];
"&&"              C := C DIV 16
"&&"       END;
"&&"   END (*HEXHW*) ;


PROCEDURE READNXTINST ;
(* TO READ AND DECODE NEXT P_INSTRUCTION *)
(* ------------------------------------- *)
"**" LABEL 10 ;
"**" CONST SL16 = 65536;
"**"  VAR  I, J, K: INTEGER ;   DUMMYCH, CH1: CHAR ;  PREV_ASM: BOOLEAN;
"&&"     TEMPLBL: ARRAY [1..12] OF CHAR ;  HLOC: HEX4;

  PROCEDURE READLBL(VAR LBL: PLABEL) ;
    (* SKIPS LEADING BLANKS AND READS THE NEXT CHARACTER SEQUENCE AS A LABEL *)
    (* --------------------------------------------------------------------- *)
"&&" VAR  I: INTEGER;  CH: CHAR;
    BEGIN
    WITH LBL DO
      BEGIN
        NAM := '        ' ;  LEN := 0 ;
"&&"    IF EOL(INPUT) THEN ERROR(618);
        REPEAT
          READ(INPUT, CH) ;  LEN := LEN+1 ;  NAM[LEN] := CH ;
        UNTIL (INPUT@ = ' ') OR (LEN = 8)  ;
"&&"    IF NAM[1] IN ['0'..'9'] THEN
"&&"      BEGIN  CADDR := 0;  I := 1;  CH := NAM[1];
"&&"        REPEAT  CADDR := CADDR*10 + ORD(CH) - ORD('0');
"&&"                I := I + 1;  CH := NAM[I];
"&&"        UNTIL NOT (CH IN ['0'..'9'] );
"&&"      END;
        END (* WITH *) ;
    END (*READLBL*) ;

"**" PROCEDURE SKIPBLANKS;
"**"   BEGIN
"&&"     GET(INPUT);
"&&"     IF EOL(INPUT) THEN ERROR(618);
"&&"   END;


    BEGIN (*READNXTINST*)

"**" P := 0;  Q := 0;  LBL1.LEN := 0;
"**" IF INPUT@ <> ' ' THEN  READLBL(LBL1) ;
"**" GET(INPUT);  IF INPUT@ = ' ' THEN SKIPBLANKS;
"**" READ(INPUT,NMCDE);
"**" IF ASM THEN
"&&"   BEGIN  HEXHW( 2*PC, HLOC );
"&&"     WRITE(OUTPUT, HLOC:9, ':  ', LBL1.NAM:LBL1.LEN,
"&&"             ' ':6-LBL1.LEN, NMCDE:4);
"&&"   END;
"**" ENTERLOOKUP;

"**" CASE OPC OF

"**" PADI,PADR,PSBI,PSBR,PFLT,PFLO,PTRC,PRND,PNGI,PNGR,PSQI,
"**" PSQR,PABI,PABR,PNOT,PAND,PIOR,PMOD,PODD,PMPI,PMPR,PDVI,
"**" PDVR,PSTP,PUNI,PINT,PDIF,PINN,PCRD,PLAB,PSAV,PRST,PCHR,
"&&" PORD,PXPO,PPOP,PXLB,PEND :
"**"    BEGIN   (* NO OPERANDS *)
"**"       READLN(INPUT);
"**"       IF ASM THEN WRITELN(OUTPUT);
"**"    END;

"&&" PDEF,PCTI,PLOC,PIXA,PASE,PMOV :
"**"    BEGIN   (* INTEGER OPERAND *)
"**"       READLN(INPUT,Q);
"**"       IF ASM THEN WRITELN(OUTPUT,Q:5);
"**"    END;

"**" PINC,PDEC,PIND :
"**"    BEGIN   (* TYPE-CODE AND INTEGER OPERANDS *)
"&&"       SKIPBLANKS;  OPNDTYPE := TYPCDE[INPUT@];
"**"       READLN(INPUT,CH1,CH,Q);
"**"       IF ASM THEN WRITELN(OUTPUT,CH1:3,Q:5);
"**"    END;

"&&" PNEW,PLDA,PSMV,PSLD,PSCL,PMST :
"**"    BEGIN   (* TWO INTEGER OPERANDS *)
"**"       READLN(INPUT,P,CH,Q);
"**"       IF ASM THEN WRITELN(OUTPUT,' ':2,P:1,' ',Q:1);
"**"    END;

"**" PLOD,PSTR :
"**"   BEGIN   (* TYPE-CODE AND TWO INTEGER OPERANDS *)
"&&"      SKIPBLANKS;  OPNDTYPE := TYPCDE[INPUT@];
"**"      READLN(INPUT,CH1,CH,P,CH,Q);
"**"      IF ASM THEN WRITELN(OUTPUT,CH1:3,P:4,Q:7);
"**"   END;

"&&" PPAK :
"&&"   BEGIN   (* THREE INTEGER OPERANDS *)
"&&"      READLN(INPUT, IVAL, CH, P, CH, Q );
"&&"      IF ASM THEN WRITELN(OUTPUT, ' ':2, IVAL:1, ',', P:1, ',', Q:1 );
"&&"   END;

"&&" PCHK :
"&&"   BEGIN   (* TYPE-CODE AND TWO INTEGER OPERANDS *)
"&&"      SKIPBLANKS;  OPNDTYPE := TYPCDE[INPUT@];
"&&"      READLN(INPUT,CH1,CH,P,CH,Q);
"&&"      IF ASM THEN WRITELN(OUTPUT,CH1:3,' ',P:1,' ',Q:1);
"&&"   END;

"**" PEQU,PNEQ,PLES,PGRT,PLEQ,PGEQ,PSTO,PRET :
"**"    BEGIN   (* TYPE-CODE AND POSSIBLY AN INTEGER OPERAND *)
"**"       SKIPBLANKS;  OPNDTYPE := TYPCDE[INPUT@];
"**"       IF OPNDTYPE = STRG THEN
"**"         BEGIN  READLN(INPUT,CH1,CH,Q);
"**"                IF ASM THEN WRITELN(OUTPUT,CH1:3,Q:5);
"**"         END
"**"       ELSE BEGIN  READLN(INPUT,CH1);
"**"                   IF ASM THEN WRITELN(OUTPUT,CH1:3);
"**"            END;
"**"    END;

"&&" PFJP,PUJP,PXJP,PCTS,PUXJ :
"**"    BEGIN   (* LABEL-NAME OPERAND *)
"**"       READLBL(LBL2);  READLN(INPUT);
"**"       IF ASM THEN WRITELN(OUTPUT,' ',LBL2.NAM:LBL2.LEN);
"**"    END;
"&&"
"&&" PCST :
"&&"    BEGIN   (* PROCEDURE NAME & NUMBER OPERANDS *)
"&&"      PREV_ASM := ASM;
"&&"      READLN(INPUT,CH1,CURPNAME,CURPNO,CH,ASM,CH,GET_STAT,CH,ASMVERB);
"&&"      IF ASM OR PREV_ASM THEN
"&&"        BEGIN  IF NOT PREV_ASM THEN WRITELN(OUTPUT, '0000:   ':12,
"&&"                 LBL1.NAM:LBL1.LEN, ' ':6-LBL1.LEN, NMCDE:4 );
"&&"               WRITELN(OUTPUT,CURPNAME:14,CURPNO:4,',',ASM:1,',',
"&&"                 GET_STAT:1,',',ASMVERB:1);
"&&"        END;
"&&"    END;

"**" PCUP :
"**"    BEGIN   (* TYPE-CODE,LEXIC-LEVEL,LABEL-NAME,INTEGER OPERANDS *)
"**"       SKIPBLANKS;  OPNDTYPE := TYPCDE[INPUT@];
"**"       READ(INPUT,CH1,CH,P,CH);  READLBL(LBL2);
"**"       IF INPUT@=' ' THEN SKIPBLANKS;
"**"       READLN(INPUT,CH,Q);
"**"       IF ASM THEN WRITELN(OUTPUT,CH1:3,P:4,' ',LBL2.NAM:LBL2.LEN,Q:5);
"**"    END;

"**" PBGN :
"&&"    BEGIN   (* STRING OPERAND *)
"&&"       READLN(INPUT,CH,PROGHDR);
"&&"       IF ASM THEN WRITELN(OUTPUT, ' ', PROGHDR);
"**"    END;

"**" PENT :
"**"    BEGIN   (* TYPE-CODE,LEXIC-LEVEL,LABEL,THREE FLAGS,INTEGER OPERANDS*)
"&&"       SKIPBLANKS;  OPNDTYPE := TYPCDE[INPUT@];  PREV_ASM := ASM;
"**"       READ(INPUT,CH1,CH,P,CH);  READLBL(SEGSZE);
"**"       IF INPUT@ = ' ' THEN SKIPBLANKS;
"&&"       READLN(INPUT,CURPNAME,CH,SAVERGS,CH,ASM,CH,GET_STAT,CH,
"&&"              ASMVERB,CH,DEBUG_LEV,CH,CURPNO);
"&&"       DEBUG := DEBUG_LEV >= 2;  FLOW_TRACE := DEBUG_LEV >= 3;
"&&"       IF ASM OR PREV_ASM THEN
"&&"         BEGIN  IF NOT PREV_ASM THEN
"&&"                BEGIN  WRITELN(OUTPUT);  HEXHW(2*PC,HLOC);
"&&"                  WRITE(OUTPUT,HLOC:9,':  ',LBL1.NAM:LBL1.LEN,
"&&"                   ' ':6-LBL1.LEN,NMCDE:4);  END;
"**"           WRITELN(OUTPUT,CH1:3,P:4,SEGSZE.NAM:10,CURPNAME:14,
"&&"             ',',SAVERGS:1,',',ASM:1,',',GET_STAT:1,',',
"&&"             ASMVERB:1,',',DEBUG_LEV:1,',',CURPNO:5);
"&&"           END;
           REPEAT
             READLN(PRD);  READ(PRD, LBL2.NAM);
"&&"         IF EOF(PRD) THEN BEGIN  ERROR(614);  EXIT(614)  END;
           UNTIL LBL2.NAM = '#PROC   ';
             (* POSITION TO NEXT PROC. INFO. *)
           READ(PRD, TEMPLBL) ;
"&&"       IF TEMPLBL <> CURPNAME THEN IVAL := -1
           ELSE  READLN(PRD,IVAL,CALL_HIGHER,PROC_SIZE,DATA_SIZE,FLIPDEBUG);
"&&"       IF IVAL <> CURPNO THEN ERROR(614);
"&&"       LARGE_PROC := (PROC_SIZE > SHRT_PROC) OR DEBUG ;
"**"    END;

"**" PLDC,PLCA,PDFC :
"**"    BEGIN   (* TYPE-CODE,CONSTANT OPERANDS *)
"**"       SKIPBLANKS;  OPNDTYPE := TYPCDE[INPUT@];
"**"       READ(INPUT,CH1);
"**"       CASE OPNDTYPE OF
"&&"       HINT,
"**"       BOOL,INT: BEGIN READLN(INPUT,CH,IVAL);
"**"                       IF ASM THEN WRITELN(OUTPUT,CH1:3,IVAL:10);
"**"                 END;
"**"       CHRC:     BEGIN  READLN(INPUT,CH,CH,CH);
"**"                        IVAL := ORD(CH);
"**"                        IF ASM THEN WRITELN(OUTPUT,'C,''':5,CH,'''');
"**"                 END;
"**"       REEL:     BEGIN  READLN(INPUT,CH,RVAL);
"**"                        IF ASM THEN WRITELN(OUTPUT,'R,':4,RVAL);
"**"                 END;
"&&"       ADR:      BEGIN  READLN(INPUT);  IVAL := -1;
"**"                        IF ASM THEN WRITELN(OUTPUT,'NIL':4);
"**"                 END;
"**"       PSET:     BEGIN  I := 0;
"&&"                 READ(INPUT,CH,CH);
"**"                 IF INPUT@ <> ')' THEN
"**"                   REPEAT
"**"                     I := I + 1;
"**"                     READ(INPUT,P,CH,Q,CH);
"**"                     PSVAL.I[I] := P*SL16 + Q;
"**"                   UNTIL CH = ')' ;
"**"                 PSLNGTH := I * 4;
"**"                 READLN(INPUT);
"**"                 IF ASM THEN BEGIN
"**"                    WRITE(OUTPUT,'S,(':5);
"**"                    FOR Q := 1 TO I DO WRITE(OUTPUT,' ',PSVAL.I[Q]:1);
"**"                    WRITELN(OUTPUT,' )');  END
"**"                 END;
"&&"       PROC:     BEGIN
"&&"                 READ(INPUT,CH);  READLBL(LBL2);  READLN(INPUT);
"&&"                 IF ASM THEN WRITELN(OUTPUT,'P,':4,LBL2.NAM:LBL2.LEN);
"&&"                 END;
"**"       STRG:     BEGIN
"**"                 READLN(INPUT,CH,CH,SVAL);
"**"                 IF ASM THEN
"**"                 BEGIN
"**"                    SLNGTH := MXSLNGTH - 1;
"**"                    WHILE SVAL[SLNGTH+1] <> '''' DO
"**"                       SLNGTH := SLNGTH - 1;
"**"                    WRITELN(OUTPUT,'M,''':5,SVAL:SLNGTH,'''');
"**"                 END;
"**"                 SLNGTH := 0;  I := 0;
"**"                 REPEAT  I := I + 1;
"**"                    IF SVAL[I] = '''' THEN
"**"                      IF SVAL[I+1] <> '''' THEN
"**"                        GOTO 10
"**"                      ELSE I := I + 1;
"**"                    SLNGTH := SLNGTH + 1;
"**"                    IF SLNGTH <> I THEN
"**"                      SVAL[SLNGTH] := SVAL[I];
"**"                 UNTIL FALSE;
"**"    10:        END (*STRG*) ;
"**"       END  (* CASE OPNDTYPE.. *)
"**"    END;

"**" PCSP :
"**"    BEGIN   (* SUBMONITOR OPERATION NAME OPERAND *)
"**"       SKIPBLANKS;  READLN(INPUT,NMCDE);
"**"       OP_SP := FALSE;  ENTERLOOKUP;  OP_SP := TRUE;
"**"       IF ASM THEN WRITELN(OUTPUT,NMCDE:5);
"**"    END;

"&&" OTHERWISE
"**"    BEGIN    (* OPCODE NOT FOUND IN TABLE *)
"&&"       IF NOT ASM THEN WRITE(OUTPUT,LBL1.NAM:LBL1.LEN,' ':6-LBL1.LEN,
"&&"           ' "',NMCDE,'" ');
"&&"       WHILE NOT EOLN DO
"&&"         BEGIN  WRITE(OUTPUT,INPUT@);  GET(INPUT)  END;
"&&"       WRITELN(OUTPUT);  READLN(INPUT);  ERROR(606);
"**"    END;
"**"
"**" END  (* CASE OPC OF .. *)
"**" END  (*READNXTINST*) ;


  PROCEDURE ASMNXTINST ;

  (* TO TRANSLATE THE NEXT P_INSTRUCTION INTO 370 ASSEMBLY/OBJECT CODE *)
  (* ----------------------------------------------------------------- *)

"&&" LABEL 10,20;
  CONST  SL8     = 256        ;  (* SHIFT LEFT 8 BITS  *)
         SL12    = 4096       ;  (*            12      *)
         SL16    = 65536      ;  (*           16       *)
         SL24    = 16777216   ;  (*           24       *)


  VAR    OP : BYTE ;   P1, P2, B1, B2 : LVLRNG ;   Q1, Q2 : ADRRNG ;
         I,J: INTEGER;   LEFTDEC, NEGATE: BOOLEAN;   POWER10: REAL;
         OPPTR: STKPTR;


    (* THE FOLLOWING PROCEDURES ARE FOR OBJECT CODE GENERATION ONLY  *)
    (* ------------------------------------------------------------- *)


    FUNCTION NEXTPC(PCINCR: ICRNG): ICRNG ;
      BEGIN
"&&"  IF PC >= MXCODE THEN
        BEGIN  ERROR(253) ;  EXIT(253)  END ;
      NEXTPC := PC+PCINCR ;
      END (*NEXTPC*) ;


    FUNCTION BASE_DSPLMT(PC : ICRNG) : INTEGER ;
      (* CONVERTS PROGRAM COUNTER VALUES TO 370 BASE/DISPLACEMENT HALF WORDS *)
      (* ------------------------------------------------------------------- *)
      BEGIN PC := 2*PC ;
      IF PC < 4096 THEN BASE_DSPLMT := PBR1*SL12+PC
      ELSE IF PC <= 8188 THEN  BASE_DSPLMT := PBR2*SL12+PC-4092
        ELSE  ERROR(253)
      END (*BASE_DSPLMT*) ;


"**" PROCEDURE UPD_DBLTBL( PC: ICRNG; R: REAL );
"**" VAR I:INTEGER;
"**"     S_I: RECORD CASE INTEGER OF
"**"          1: ( R: REAL );
"**"          2: ( S: SSETRNG );
"**"          END;
"**" BEGIN
"**"   DBLALN := TRUE; (* INDICATE ALIGNMENT FOR LITERAL POOL *)
"**"   IDP_POOL.R[NXTDBL] := R;  I := 0;
"**"   S_I.R := R;
"**"   WHILE IDP_POOL.S[I] <> S_I.S DO I := I + 1;
"**"   IF I = RICONF THEN   (* AN AMAZING COINCIDENCE HAS OCCURRED *)
"**"     BEGIN  RICONF := -1;  INT_GAP := -1  END;
"**"   IF I = RHCONF THEN   (* DITTO *)
"**"     BEGIN  RHCONF := -1;  HW_GAP := -1  END;
"&&"  NXTLIT := NXTLIT + 1;
"&&"  LITTBL[NXTLIT].LNK := PC;
"**"  IF I = NXTDBL THEN
"**"    NXTDBL := NXTDBL + 1;
"&&"    I := I*8;
"&&"    IF I >= NXTCH THEN NXTCH := I + 8;
"&&"    CODE.H(/PC/) := I;
"**" END  (*UPD_DBLTBL*) ;
"**"
"**" PROCEDURE UPD_HWTBL( PC: ICRNG; H: HINTEGER );
"**" VAR  I, NXTHW: 0..HWCNT;
"**" BEGIN
"**"   IF HW_GAP >= 0 THEN   (* PREVENT MATCH WITH EMPTY SLOT *)
"&&"     IF H = 0 THEN IDP_POOL.H(/HW_GAP/) := -1
"&&"     ELSE IDP_POOL.H[HW_GAP] := 0;
"**"   IF INT_GAP >= 0 THEN  (* PREVENT MATCH WITH EMPTY SLOT *)
"**"     IF H = 0 THEN
"**"       IDP_POOL.I[INT_GAP] := -1
"**"     ELSE IDP_POOL.I[INT_GAP] := 0;
"&&"   NXTHW := NXTDBL*4;  IDP_POOL.H[NXTHW] := H;  I := 0;
"**"   WHILE IDP_POOL.H[I] <> H DO I := I + 1;
"**"   IF I = NXTHW THEN
"**"     IF HW_GAP >= 0 THEN  (* NOW USE EMPTY SLOT *)
"**"       BEGIN  I := HW_GAP;  IDP_POOL.H[I] := H;
"**"              HW_GAP := -1;  IHCONF := -1;  RHCONF := -1
"**"       END
"**"     ELSE
"**"       IF INT_GAP >= 0 THEN (* SPLIT EMPTY INTEGER SLOT *)
"**"         BEGIN  HW_GAP := 2*INT_GAP + 1;  I := HW_GAP - 1;
"**"                IDP_POOL.H[I] := H;
"&&"                IHCONF := INT_GAP;  RHCONF := IHCONF DIV 2;
"&&"                RICONF := -1;  IDP_POOL.H[HW_GAP] := 0;
"**"                INT_GAP := -1
"**"         END
"**"       ELSE
"**"         BEGIN  HW_GAP := NXTHW + 1;  INT_GAP := NXTDBL*2 + 1;
"&&"                RICONF := NXTDBL;  RHCONF := NXTDBL;
"&&"                IHCONF := INT_GAP - 1;
"**"                NXTDBL := NXTDBL + 1;
"**"                IDP_POOL.I[INT_GAP] := 0;
"**"                IDP_POOL.H[HW_GAP]  := 0;
"**"         END;
"&&"  I := I*2;  CODE.H[PC] := I;
"&&"  IF I >= NXTCH THEN NXTCH := I + 2;
"&&"  NXTLIT := NXTLIT + 1;
"&&"  LITTBL[NXTLIT].LNK := PC;
"**" END  (*UPD_HWTBL*) ;
"**"
"**" PROCEDURE UPD_INTTBL( PC: ICRNG; D: INTEGER );
"**" VAR  I, NXTINT: 0..INTCNT;
"**" BEGIN
"**"   IF INT_GAP >= 0 THEN  (* PREVENT MATCH WITH EMPTY SLOT *)
"**"     IF D = 0 THEN
"**"       IDP_POOL.I[INT_GAP] := -1
"**"     ELSE IDP_POOL.I[INT_GAP] := 0;
"**"   NXTINT := NXTDBL*2;  IDP_POOL.I[NXTINT] := D;  I := 0;
"**"     WHILE IDP_POOL.I[I] <> D DO I := I + 1;
"**"     IF I = IHCONF THEN  (* CHECK FOR A COINCIDENCE *)
"**"       BEGIN  HW_GAP := -1;  IHCONF := -1;  RHCONF := -1  END;
"**"     IF I = NXTINT THEN
"**"       IF INT_GAP >= 0 THEN  (* USE EMPTY SLOT INSTEAD *)
"**"         BEGIN  I := INT_GAP;  INT_GAP := -1;  RICONF := -1;
"**"                IDP_POOL.I[I] := D;
"**"         END
"**"       ELSE
"**"         BEGIN  INT_GAP := NXTINT + 1;  RICONF := INT_GAP DIV 2;
"**"                NXTDBL := NXTDBL + 1;
"**"                IDP_POOL.I[INT_GAP] := 0;
"**"         END;
"&&"  I := I*4;  CODE.H[PC] := I;
"&&"  IF I >= NXTCH THEN NXTCH := I + 4;
"&&"  NXTLIT := NXTLIT + 1;
"&&"  LITTBL[NXTLIT].LNK := PC;
"**" END  (*UPD_INTTBL*) ;
"**"
"**" PROCEDURE UPD_SETTBL( PC: ICRNG; PS: SETRNG; L: INTEGER );
"**" VAR   S_I: SET_S_I;  I, J, LD4: INTEGER;
"**" BEGIN  S_I.S := PS;
"**"   IF L = 0 THEN ERROR(616)
"**"   ELSE IF L <= 4 THEN UPD_INTTBL( PC, S_I.I[1] )
"**"   ELSE IF L <= 8 THEN UPD_DBLTBL( PC, S_I.R[1] )
"**"   ELSE BEGIN
"**"     WHILE (L MOD INTSIZE) <> 0 DO  L := L + 1;
"**"     LD4 := L DIV 4;
"**"     I := 2 * NXTDBL;
"**"     IF INT_GAP >= 0 THEN
"**"       IF INT_GAP = I - 1 THEN
"**"         BEGIN  I := I - 1;  INT_GAP := -1;  RICONF := -1  END;
"&&"     CODE.H[PC] := I*4;
"&&"     NXTLIT := NXTLIT + 1;
"&&"     LITTBL[NXTLIT].LNK := PC;
"**"     FOR J := 1 TO LD4 DO
"**"       BEGIN  IDP_POOL.I[I] := S_I.I[J];
"**"              I := I + 1;
"**"       END;
"&&"     IF I*4 > NXTCH THEN NXTCH := I*4;
"**"     IF I > NXTDBL*2 THEN
"**"       BEGIN  NXTDBL := I DIV 2;
"**"         IF ODD(I) THEN
"**"           BEGIN  RICONF := NXTDBL;  NXTDBL := NXTDBL + 1;
"**"                  INT_GAP := I;  IDP_POOL.I[I] := 0;
"**"           END;
"**"       END
"**"   END
"**" END  (*UPD_SETTBL*) ;


    PROCEDURE UPD_PRCTBL(PC : ICRNG ; PRC_NAME : ALFA) ;
      (* TO UPDATE EXTERNAL REFERENCE TABLE *)
      (* ---------------------------------- *)
      VAR I : 0..PRCCNT;
      BEGIN
      PRCTBL[NXTPRC].NAME := PRC_NAME ;  I := 0 ;
      WHILE PRCTBL[I].NAME <> PRC_NAME DO I := I+1 ;
      CODE.H[PC] := PRCTBL[I].LNK ;  PRCTBL[I].LNK := PC ;
      IF I = NXTPRC THEN
"&&"    IF NXTPRC >= NXTEP THEN ERROR(256)
        ELSE
          BEGIN  NXTPRC := NXTPRC+1 ;  PRCTBL[NXTPRC].LNK := 0  END
    END (* UPD_PRCTBL *) ;


    FUNCTION LBLMAP(ALFLBL: ALFA) : LBLRNG ;
    VAR  I : 2..8 ;  J : LBLRNG ;
      BEGIN  (* TRANSLATE GENERATED LABELS TO CONSECUTIVE INTEGERS *)
      I := 2 ;  J := 0 ;
        REPEAT J := J*10+ORD(ALFLBL[I])-ORD('0') ;  I := I+1
        UNTIL ALFLBL[I] = ' ' ;
      LBLMAP := J ;
      END (* LBLMAP *) ;


    PROCEDURE UPD_LBLTBL( PC: ICRNG; INTLBL: LBLRNG; NEWLBL: BOOLEAN) ;
    (* TO 'DEFINE' LABELS AND/OR RESOLVE FORWARD REFERENCES *)
    (* ---------------------------------------------------- *)
    VAR I : LBLRNG ;  TPC, QPC : INTEGER ;
    BEGIN  (* NO PROTECTION AGAINST REDEFINITIONS HERE *)
      IF INTLBL > LBLCNT THEN
        BEGIN  WRITELN(' **** INTLBL ':17,INTLBL);  ERROR(263);  EXIT(263)   END
      ELSE
        WITH LBLTBL[INTLBL] DO
          IF DEFINED THEN     (* BACKWARD REFERENCE *)
            IF CASE_FLAG THEN  CODE.H[PC] := LNK*2 (*HALFWORD ADDR.*)
            ELSE  CODE.H[PC] := BASE_DSPLMT(LNK)   (* BASE/DSPLMT HALF WORD   *)
          ELSE
            IF NEWLBL THEN    (* LABEL DEFINITION *)
              BEGIN
              DEFINED := TRUE ;  TPC := LNK ;
              LNK := PC ;  (* SET LABEL VALUE *)
"&&"          WHILE TPC > 1 DO
                BEGIN
                QPC := TPC ; TPC := CODE.H[QPC] ;
                IF TPC < 0 THEN
                  BEGIN  CODE.H[QPC] := PC*2 ;  TPC := ABS(TPC)  END
                ELSE  CODE.H[QPC] := BASE_DSPLMT(PC) ;
                END
              END
            ELSE   (* NOT NEWLBL I.E. FORWARD REFERENCE, TO BE RESOLVED LATER *)
              BEGIN
              IF CASE_FLAG THEN  CODE.H[PC] := -LNK  ELSE  CODE.H[PC] := LNK ;
              LNK := PC
              END ;
      END (* UPD_LBLTBL *) ;


    (* 370 FORMAT CODE GENERATOR (ASSEMBLY/OBJECT CODE) *)
    (* ------------------------------------------------ *)


    PROCEDURE GENRR(OP: BYTE; R1,R2: RGRNG) ;
"&&"  LABEL 10;
      BEGIN
"&&"  IF R1 = TRG14 THEN TXR_CONTENTS.VALID := FALSE;
"&&"  IF OPT_FLG THEN
"&&"   IF (OP=XLTR) OR (OP=XLTDR) THEN
"&&"     WITH LAST_CC DO
"&&"       IF PC = LPC THEN  (* NO INTERVENING INSTRUCTIONS *)
"&&"         IF R1 = R2 THEN
"&&"           IF LR = R1 THEN
"&&"             IF OP = XLTDR THEN
"&&"               IF LOP IN [XAD,XSD,XLCDR,XLPDR,XADR,XSDR,XAD,XSD] THEN
"&&"                 GOTO 10
"&&"               ELSE
"&&"             ELSE (* OP = XLTR *)
"&&"               IF LOP IN [XLPR,XLCR,XNR,XXOR,
                              XXR,XAR,XSR,XAH,XSH,XO,XX,
"&&"                           XN,XSLA,XSRA,XA,XS] THEN GOTO 10;
        (* IF ASM THEN
          WRITELN(OUTPUT,XTBL@[OP]:5, R1:3,',',R2:1 )
        ELSE *)  CODE.H[PC] := OP*SL8 + R1*16 + R2;
"&&"    PC := NEXTPC(1);
"&&"    WITH LAST_CC DO
"&&"      BEGIN  LPC := PC;  LR := R1;  LOP := OP  END;
"&&" 10:
      END (*GENRR*) ;


    PROCEDURE GENRXLIT(OP: BYTE; R: RGRNG; D: INTEGER ; TAG: INTEGER) ;FORWARD ;


    PROCEDURE GENRX(OP:BYTE; R: RGRNG ; D: ADRRNG; X,B: RGRNG) ;
"&&"  LABEL 10;
      BEGIN
"&&"    IF R = TRG14 THEN TXR_CONTENTS.VALID := FALSE;
      IF (D < 0) OR (D > SHRTINT) THEN
        BEGIN  ERROR(608 (*THIS SHOULD NOT BE THE CASE NOW*)) ;
"&&"    TXR_CONTENTS.VALID := FALSE;
        IF B = TXRG THEN GENRXLIT(XA,TXRG,D,0)
        ELSE
          BEGIN  GENRXLIT(XL,TXRG,D,0) ;
          IF B = 0 THEN B := TXRG
          ELSE
            IF X = 0 THEN X := TXRG
            ELSE  BEGIN GENRR(XAR,TXRG,B) ;  B := TXRG  END ;
          END ;
        D := 0
        END ;
      (* IF ASM THEN
        BEGIN  WRITE(OUTPUT,XTBL@[OP]:5,R:3,',',D: 1,'(', X: 1 ) ;
        IF B > 0 THEN WRITE(OUTPUT,',',B: 1 ) ;
        WRITELN(OUTPUT,')') ;
        END
      ELSE *)
        BEGIN
"&&"      CODE.H[PC] := OP*SL8  +R*16+X ;  CODE.H[PC+1] := SL12*B+D ;
        END;
"&&"  PC := NEXTPC(2);
"&&"  WITH LAST_CC DO
"&&"    BEGIN  LPC := PC;  LR := R;  LOP := OP  END;
"&&" 10:
      END (*GENRX*) ;

    PROCEDURE GENRXLIT ;
"**"  LABEL 10;
      BEGIN
"&&"  IF R = TRG14 THEN TXR_CONTENTS.VALID := FALSE;
"**"  IF TAG >= 0 THEN
"**"    IF (OP >= XL) AND (OP <= XS) THEN
"**"      IF (D >= -32768) AND (D <= 32767) THEN
"**"        BEGIN  OP := OP - 16;  (* USE HALFWORD INSTR. *)
"**"               TAG := -1;
"**"        END;
"**"    IF OP = XLH THEN
"**"      IF (D >= 0) AND (D <= SHRTINT) THEN
"**"        BEGIN  GENRX( XLA, R, D, 0, 0 );  GOTO 10  END;
"**"    IF OP = XAH THEN
"**"      IF D = -1 THEN
"**"        BEGIN  GENRR( XBCTR, R, 0 );  GOTO 10  END;
"**"    IF OP = XSH THEN
"**"      IF D = 1 THEN
"**"        BEGIN  GENRR( XBCTR, R, 0 );  GOTO 10  END;

      (* IF ASM THEN
        BEGIN   WRITE(OUTPUT,XTBL@[OP]:5,R:3) ;
        IF TAG < 0 THEN  WRITELN(OUTPUT,',=H''',D:1,'''')
        ELSE  WRITELN(OUTPUT,',=A(',D:1,')')
        END
      ELSE *)   (* ^ASM *)
        BEGIN  CODE.H[PC] := OP*SL8  +R*16 ;
"**"    IF TAG<0 THEN UPD_HWTBL( PC+1, D )
"**"             ELSE UPD_INTTBL( PC+1, D );
        END;
"&&" PC := NEXTPC(2);
"&&" WITH LAST_CC DO
"&&"   BEGIN  LPC := PC;  LR := R;  LOP := OP  END;
10:  END (*GENRXLIT*) ;


"&&" PROCEDURE GENRXDLIT(OP: BYTE; R: RGRNG; VAL: REAL);
"&&" LABEL 10;
     VAR I: INTEGER;
     BEGIN
"&&"   IF OP = XLD THEN
"&&"     IF VAL = 0.0 THEN
"&&"       BEGIN  GENRR( XSDR, R, R );  GOTO 10  END;
    (* IF ASM THEN
       WRITELN(OUTPUT, XTBL@[OP]:5, R:3,',=D''', VAL, '''')
      ELSE *)
      BEGIN  CODE.H[PC] := OP*SL8+ R*16+ 00 ;
"**"  UPD_DBLTBL( PC+1, VAL );
      END ;
"&&"  PC := NEXTPC(2);
"&&"  WITH LAST_CC DO
"&&"    BEGIN  LPC := PC;  LR := R;  LOP := OP  END;
"&&" 10:
    END (* GENRXDLIT *);


    PROCEDURE GENRS(OP: BYTE; R1,R2: RGRNG; D: ADRRNG; B: RGRNG ) ;
      BEGIN
"&&"  IF R1 = TRG14 THEN TXR_CONTENTS.VALID := FALSE;
      IF (D < 0) OR (D > SHRTINT) THEN
        BEGIN  IF B <> TXRG THEN   GENRR(XLR,TXRG,B);
          GENRXLIT(XA,TXRG,D,0) ;   D := 0 ;   B := TXRG;
        END ;
      (* IF ASM THEN
"**"    IF (OP <= XSLDA) AND (OP >= XSRL) THEN
"**"      WRITELN(OUTPUT,XTBL@[OP]:5,R1:3,',',D:1,'(',B:1,')')
"**"    ELSE
"**"     WRITELN(OUTPUT,XTBL@[OP]:5,R1:3,',',R2:1,',',D:1,'(',B:1,')')
      ELSE *)
        BEGIN
"&&"    CODE.H[PC] := OP*SL8 +R1*16 +R2 ; CODE.H[PC+1] := B*SL12 +D;
        END;
"&&"  PC := NEXTPC(2);
      END (*GENRS*) ;


"**" PROCEDURE GENRSLIT(OP: BYTE; R1,R2: RGRNG; S: SSETRNG);
"**" BEGIN  I_S_R.S := S;
"&&"   IF R1 = TRG14 THEN TXR_CONTENTS.VALID := FALSE;
"**" (* IF ASM THEN
"**"     WRITELN(OUTPUT,XTBL@[OP]:5,R1:3,',',R2:1,',=F''',
"**"          I_S_R.I1:1,',',I_S_R.I2:1,'''')
"**"   ELSE *)  BEGIN
"**"     CODE.H[PC] := OP*SL8 + R1*16 + R2;  PC := NEXTPC(2);
"**"     UPD_DBLTBL( PC-1, I_S_R.R );
"**"   END;
"**" END  (*GENRSLIT*) ;


    PROCEDURE GENSS(OP,LNGTH: BYTE; D1: ADRRNG; B1: RGRNG; D2:ADRRNG;B2:RGRNG) ;
      BEGIN
      (* IF ASM THEN
        WRITELN(OUTPUT,XTBL@[OP]:5,D1:6,'(',LNGTH:1,',',B1:1, '),',
                     D2:1,'(',B2:1,')' )
      ELSE *)
        BEGIN  CODE.H[PC] := OP*SL8  +(LNGTH-1) ;
"&&"    CODE.H[PC+1] := B1*SL12+D1 ;  CODE.H[PC+2] := B2*SL12+D2 ;
        END;
"&&"  PC := NEXTPC(3);
      END (*GENSS*) ;


    PROCEDURE GENSI(OP: BYTE; D: ADRRNG; B: RGRNG; I: BYTE) ;
      BEGIN
      (* IF ASM THEN
        WRITELN(OUTPUT,XTBL@[OP]:5,D:8,'(',B:1,'),',I:1)
      ELSE *)
        BEGIN
"&&"      CODE.H[PC] := OP*SL8  +I ; CODE.H[PC+1] := B*SL12+D ;
        END;
"&&"  PC := NEXTPC(2);
      END (*GENSI*) ;


"**" (* PROCEDURE PRINT_SET( S: SETRNG; LNGTH: BYTE; COL: INTEGER );
"**"   VAR  I, INDNT: INTEGER;  DELIM: CHAR;
"**" BEGIN
"**"       PSVAL.S := S;  DELIM := '''';  WRITE(OUTPUT,'=F');
"**"       COL := COL + 2;
"**"       FOR I := 1 TO (LNGTH+3) DIV 4 DO
"**"         BEGIN  INDNT := FLDW(PSVAL.I[I]) + 1;
"**"           IF (COL+INDNT) < 72 THEN
"**"             WRITE(OUTPUT,DELIM,PSVAL.I[I]:1)
"**"           ELSE BEGIN
"**"             WRITELN(OUTPUT,DELIM,'X':73-COL);
"**"             WRITE(OUTPUT,' ':15,PSVAL.I[I]:1);
"**"             COL := 15;
"**"           END;
"**"           DELIM := ',';  COL := COL + INDNT;
"**"         END;
"**"       WRITELN(OUTPUT,'''');
"**" END (*PRINT_SET*) ;  *)

"**" PROCEDURE GENSSLIT( OP,LNGTH: BYTE; D1: ADRRNG; B1: RGRNG; S: SETRNG );
"**"   VAR COL: INTEGER;
"**" BEGIN
"**"   IF LNGTH = 1 THEN  (* SUBSTITUTE AN IMMEDIATE INST. *)
"**"     BEGIN  I_S_R.S := S[1];
"**"       GENSI( OP-XMVC+XMVI, D1, B1, ORD(I_S_R.C1) );
"**"     END
"**"   ELSE IF LNGTH > 1 THEN
"&&"   BEGIN
"**"     (* IF ASM THEN
"**"       BEGIN
"**"         COL := FLDW(LNGTH) + FLDW(B1) + 16;
"**"         WRITE(OUTPUT,XTBL@[OP]:5,D1:6,'(',LNGTH:1,',',B1:1,'),');
"**"         PRINT_SET(S,LNGTH,COL);
"**"       END
"**"     ELSE *)   BEGIN
"**"       CODE.H[PC] := OP*SL8 + (LNGTH-1);
"**"       CODE.H[PC+1] := B1*SL12 + D1;
"**"       UPD_SETTBL( PC+2, S, LNGTH );
"**"     END;
"&&"     PC := NEXTPC(3);
"&&"     END;
"**" END (*GENSSLIT*) ;


    PROCEDURE GENRXLAB(OP: BYTE; R: RGRNG; LAB: PLABEL; TAG:INTEGER) ;
      BEGIN
"&&"  IF R = TRG14 THEN TXR_CONTENTS.VALID := FALSE;
      (* IF ASM THEN
"&&"       IF CASE_FLAG THEN WRITELN(OUTPUT,' DC AL2(',LAB.NAM:LAB.LEN,
"&&"           '-',PRCTBL[0].NAME,')')
"&&"       ELSE
        BEGIN
        WRITE(OUTPUT,XTBL@[OP]:5, R:3,',') ;
        IF TAG >= 0 THEN  WRITE(OUTPUT,LAB.NAM:LAB.LEN,'(',TAG:1)
        ELSE  BEGIN  IF TAG = -3 THEN  WRITE(OUTPUT,'=V(')
                     ELSE  (* TAG = -1 *)  WRITE(OUTPUT,'=A(') ;
              WRITE(OUTPUT, LAB.NAM: LAB.LEN) ;
              END ;
        WRITELN(OUTPUT,')') ;  PC := NEXTPC(2);
        END
      ELSE *)
        IF CASE_FLAG THEN
          BEGIN
          UPD_LBLTBL(PC,LBLMAP(LAB.NAM),FALSE(*LAB REF*) ) ;  PC := NEXTPC(1) ;
          END
        ELSE
          BEGIN
          IF TAG >= -1 THEN  (*GENERATED LABEL*)
            UPD_LBLTBL(PC+1,LBLMAP(LAB.NAM),FALSE (*LABEL REFERENCE*))
          ELSE  (*PROC. ID.*)  UPD_PRCTBL(PC+1,LAB.NAM) ;
          IF TAG < 0 THEN TAG := 0 ;
          CODE.H[PC] := OP*SL8  +R*16+TAG ;  PC := NEXTPC(2)
          END
        END (*GENRXLAB*) ;


"&&" PROCEDURE GENRELRX( OP: BYTE; R: RGRNG; OFFSET: HINTEGER );
"&&"   (* OPERAND OF RX INST. IS "*+2*OFFSET"  *)
"&&"   BEGIN
"&&"  (* IF ASM THEN WRITELN(OUTPUT, XTBL@[OP]:5, R:3,
"&&"                   ',*+',2*OFFSET:1) ELSE *)
"&&"        BEGIN  GENRX( OP, R, 0, 0, 0 );
"&&"               CODE.H[PC-1] := BASE_DSPLMT( PC+OFFSET-2 );
"&&"        END;
"&&"   END (*GENRELRX*) ;


"&&" PROCEDURE BRANCH_CHAIN( LPC: ICRNG );
"&&"   LABEL 10;
"&&"   CONST X47F0 = 18416;  X4700 = 18176;  X4000 = 16384;
"&&"         XC000 = 19152;  MAXCNT = 5;
"&&"   VAR   BC15, TI, DI:  RECORD CASE INTEGER OF
"&&"                        1: ( I: INTEGER );
"&&"                        2: ( S: SET OF 0..31 );
"&&"                        END;
"&&"         TPC, DPC: ICRNG;  CNT: 0..MAXCNT;  TIOP: INTEGER;
"&&"   BEGIN
"&&"     BC15.I := X47F0;  TPC := PCAFTLIT;
"&&"     REPEAT
"&&"       TI.I := CODE.H[TPC];
"&&"       IF TI.I > X4700 THEN
"&&"         IF TI.S <= BC15.S THEN  (* MUST BE UNINDEXED BC INSTR. *)
"&&"           BEGIN  CNT := 0;
"&&"             REPEAT
"&&"               TIOP := CODE.H[TPC+1];
"&&"               IF TIOP < 0 THEN TIOP := TIOP + 65536;
"&&"               DPC := (TIOP MOD SL12) DIV 2;
"&&"               TIOP := TIOP DIV SL12 - PBR1;
"&&"               IF TIOP < 0 THEN GOTO 10;
"&&"               IF TIOP > 0 THEN
"&&"                 IF TIOP > 1 THEN GOTO 10
"&&"                 ELSE DPC := DPC + 2046;
"&&"               IF DPC >= LPC THEN GOTO 10;
"&&"               DI.I := CODE.H[DPC];
"&&"               IF DI.I <= X4700 THEN GOTO 10;
"&&"               IF DI.I > X47F0 THEN GOTO 10;
"&&"               IF NOT ( TI.S <= DI.S ) THEN GOTO 10;
"&&"               TIOP := CODE.H[DPC+1];
"&&"               CODE.H[TPC+1] := TIOP;
"&&"               CNT := CNT + 1;
"&&"             UNTIL CNT > MAXCNT;
"&&"        10:END;
"&&"       IF TI.I < 0 THEN TI.I := TI.I + 65536;
"&&"       IF TI.I < X4000 THEN TPC := TPC + 1  (* RR *)
"&&"       ELSE IF TI.I < XC000 THEN TPC := TPC + 2  (* RX *)
"&&"            ELSE TPC := TPC + 3;                 (* SS *)
"&&"     UNTIL TPC >= LPC;
"&&"   END  (* BRANCH_CHAIN *) ;


"&&" PROCEDURE DUMP_LITERALS;
"&&"    (* PROCEDURE TO EMPTY LITERAL POOL INTO CODE ARRAY *)
"&&" VAR  I: INTEGER;  QPC, TPC: ICRNG;
"&&" BEGIN
"&&"   IF OPT_FLG THEN IF NOT DEBUG THEN BRANCH_CHAIN( PC );
"&&"   IF ODD(PC) THEN GENRR( XBCR, 0, 0 );
"&&"   IF DBLALN THEN
"&&"     IF (PC MOD 4) <> 0 THEN GENRX( XBC, 0, 0, 0, 0 );
"&&"   IF NXTLIT > 0 THEN
"&&"     IF (NXTDBL*4+PC) <= 4095 THEN
"&&"       BEGIN
"&&"         FOR I := 1 TO NXTLIT DO
"&&"           BEGIN  TPC := LITTBL[I].LNK;
"&&"             IF TPC > 0 THEN  (* USUAL CASE *)
"&&"               BEGIN  QPC := CODE.H[TPC];
"&&"                 CODE.H[TPC] := BASE_DSPLMT( QPC DIV 2 + PC );
"&&"                 IF ODD(QPC) THEN CODE.H[TPC] := CODE.H[TPC] + 1;
"&&"               END
"&&"             ELSE IF TPC < 0 THEN  (* STRING CONST. NOT YET USED *)
"&&"               WITH STK[-TPC-1] DO
"&&"                 BEGIN  QPC := FPA.DSPLMT;
"&&"                   FPA.LVL := -2;  (* FLAG TO CODE GENERATORS *)
"&&"                   FPA.DSPLMT := BASE_DSPLMT( QPC DIV 2 + PC );
"&&"                   IF ODD(QPC) THEN FPA.DSPLMT := FPA.DSPLMT + 1;
"&&"                 END;
"&&"           END;
"&&"         TPC := NXTDBL*2 - 1;
"&&"         IF INT_GAP = TPC THEN TPC := TPC - 1;
"&&"         POOL_SIZE := POOL_SIZE + TPC*2;
"&&"         NUMLITS   := NUMLITS + NXTLIT;  QPC := PC DIV 2;
"&&"         FOR I := 0 TO TPC DO
"&&"           BEGIN
"&&"             CODE.I(/QPC/) := IDP_POOL.I(/I/);
"&&"             QPC := QPC + 1;
"&&"           END;
"&&"           PC := QPC*2;
"&&"       END
"&&"     ELSE ERROR(253);
"&&"   NXTLIT := 0;  NXTDBL := 0;  IHCONF := -1;  RICONF := -1;
"&&"   RHCONF := -1; INT_GAP := -1; HW_GAP := -1; DBLALN := FALSE;
"&&"   PCAFTLIT := PC;  NXTCH := 0;
"&&" END (* DUMP_LITERALS *) ;


    PROCEDURE  FINDRG ;  (*TO FIND A GP REGISTER*)
      VAR I :RGRNG ;
      BEGIN   I := 1 ;
        REPEAT  I := I+1  UNTIL  (AVAIL[I] OR (I = RGCNT)) ;
        IF NOT AVAIL[I] THEN ERROR(259) ;
        AVAIL[I] := FALSE ;  NXTRG := I ;
      END (*FINDRG*) ;


    PROCEDURE  FINDRP ;  (*FIND REGISTER PAIR*)
      VAR  I: RGRNG ;
      BEGIN   I := RGCNT+1  ;
        REPEAT  I := I-2  UNTIL (I < 4) OR (AVAIL[I] AND AVAIL[I+1]) ;
        IF  NOT (AVAIL[I] AND AVAIL[I+1])  THEN ERROR(259) ;
        AVAIL[I] := FALSE ;  AVAIL[I+1] := FALSE ;  NXTRG := I
      END (*FINDRP*) ;


    PROCEDURE FINDFP ; (*FIND A FLOATING POINT REGISTER*)
      VAR I : INTEGER ;
      BEGIN  I := 0 ;
        REPEAT  I := I+2  UNTIL AVAILFP[I] OR (I = FPCNT) ;
        IF NOT AVAILFP[I] THEN ERROR(259)  ;
        AVAILFP[I] := FALSE ;  NXTRG := I
      END (*FINDFP*) ;


    PROCEDURE FREEREG(VAR STE : DATUM) ;
      BEGIN
        WITH STE DO
          IF VRBL AND (VPA = RGS) THEN
          BEGIN
            IF DTYPE=REEL THEN
              AVAILFP[RGADR] := TRUE
            ELSE  (* DTYPE <> REEL *)
              AVAIL[RGADR] := TRUE ;
"&&"        IF DRCT AND (DTYPE = PSET) THEN
"&&"          IF PLEN > 4 THEN  (* REG. PAIR IN USE *)
                AVAIL[RGADR + 1] := TRUE
          END  (* IF VRBL *)
      END (*FREEREG*) ;


    FUNCTION ALIGN( Q, P: INTEGER): INTEGER ;
      VAR I : INTEGER ;
      BEGIN
        ALIGN := Q ;  I := Q MOD P ;
        IF I <> 0 THEN ALIGN := Q+(P-I) ;
      END (*ALIGN*) ;


   FUNCTION  POWER2(I : INTEGER) : INTEGER ;
   (* IF I > 0 IS A POWER OF TWO, RETURN 'THAT' POWER, ELSE RETURN NEGATIVE *)
   (* --------------------------------------------------------------------- *)
"**" VAR  K: INTEGER;
"**" BEGIN
"**"    POWER2 := -999;
"**"    IF I > 0 THEN BEGIN
"**"      K := 0;
"**"      WHILE NOT ODD(I) DO
"**"         BEGIN  I := I DIV 2;  K := K + 1;  END;
"**"      IF I = 1 THEN POWER2 := K;   END;
     END (*POWER2*) ;


    PROCEDURE BASE(VAR Q: ADRRNG;VAR P,B: LVLRNG ) ;
    (* TO TRANSLATE A 'LEVEL/OFFSET' P/Q ADDRESS TO 'BASE/INDEX/DISPLACEMENT' *)
    (* ---------------------------------------------------------------------- *)
"&&"  LABEL 10;
"@@"  CONST  MAXDISP  = 4088;
"@@"         SHRTINT2 = 8183;  (* SHRTINT + MAXDISP *)
"&&"  VAR    T, TQ: ADRRNG;  TP: LVLRNG;
      BEGIN  B := 0  ;
"&&"    IF P < 0 THEN GOTO 10;   (* STRING CONSTANT *)
"&&"    TQ := Q;  TP := P;
"&&"    IF OPT_FLG THEN WITH TXR_CONTENTS DO
"&&"      IF TP = LEVEL THEN
"&&"        IF VALID THEN
"&&"          IF TXRG = TRG14 THEN
"&&"            BEGIN  T := TQ - OFFSET + DISP;
"&&"              IF (T>=0) AND (T<=MAXDISP) THEN
"&&"                BEGIN  Q := T;  P := TRG14;
"&&"                       B := BASE;  GOTO 10  END;
"&&"            END;
        IF P > 0 THEN
        IF P = CURLVL THEN  BEGIN  B := LBR ;  P := 0  END
        ELSE IF P = 1 THEN  BEGIN  B := GBR ;  P := 0  END
             ELSE
               BEGIN
               GENRX(XL,TXRG,DISPLAY+4*P,GBR,0) ;  P := TXRG ;
               END;
"@@"    IF (Q < 0) OR (Q > SHRTINT2) THEN
"&&"      BEGIN  Q := Q - 2048;
          IF P > 0 THEN GENRXLIT(XA,P,Q,0)
          ELSE  BEGIN  GENRXLIT(XL,TXRG,Q,0) ;  P := TXRG  END ;
"&&"      Q := 2048
          END
"&&"    ELSE IF Q > SHRTINT THEN
"@@"      BEGIN  GENRX(XLA,TXRG,MAXDISP,B,P);
"@@"             Q := Q - MAXDISP;  P := TXRG;  B := 0;
"@@"      END;
"&&"    IF P = TRG14 THEN
"&&"      WITH TXR_CONTENTS DO
"&&"       BEGIN  VALID := TRUE;  LEVEL := TP;  OFFSET := TQ;
"&&"              DISP := Q;  BASE := B;
"&&"       END;
"&&" 10:
      END (*BASE*) ;


"@@" PROCEDURE CHECKDISP( VAR Q: ADRRNG; VAR P,B: LVLRNG );
"@@"(*  TO ELIMINATE THE RESULT Q=4092 THAT MAY BE GENERATED BY BASE
"@@"    AND WHICH CAUSES TROUBLE FOR OPERATIONS ON SETS             *)
"@@" BEGIN
"@@"   IF Q > (SHRTINT-4) THEN
"@@"     BEGIN
"@@"       GENRX(XLA,TXRG,SHRTINT-4,B,P);
"@@"       Q := Q - (SHRTINT-4);  P := TXRG;  B := 0
"@@"     END
"@@" END;


  PROCEDURE GETADR( STE: DATUM; VAR Q: ADRRNG; VAR P, B: RGRNG) ;  FORWARD ;


  PROCEDURE LOAD(VAR STE: DATUM) ;
    (* LOADS AN STACK ELEMENT INTO A REGISTER, IF NOT ALREADY THERE *)
    (* ------------------------------------------------------------ *)
    VAR P: LVLRNG; Q: ADRRNG; B, R: RGRNG ; OP: BYTE ;

    PROCEDURE FINDMDRG ;
      (*TO FIND A MULTIPLY/DIVIDE REGISTER*)
      BEGIN
      IF MDTAG = PDVI THEN
        BEGIN  FINDRP ;  AVAIL[NXTRG+1] := TRUE  END
      ELSE IF MDTAG = PMPI THEN
             BEGIN  FINDRP ;  AVAIL[NXTRG] := TRUE ;  NXTRG := NXTRG+1 END
           ELSE FINDRG ;
      END (*FINDMDRG*) ;

    BEGIN  (*LOAD*)

    WITH STE DO
      BEGIN
      IF VRBL THEN (* LOAD THE VARIABLE POINTED TO BY STP*)
        IF DRCT THEN (*DIRECTLY ACCESSIBLE VARIABLE*)
          CASE DTYPE OF

"&&"      ADR,HINT,INT,BOOL,CHRC:
            BEGIN
              IF VPA = MEM THEN
                BEGIN  FINDMDRG ;
                P := MEMADR.LVL ;   Q := MEMADR.DSPLMT ;
                BASE(Q,P,B) ;
"&&"            CASE DTYPE OF
"&&"  CHRC,BOOL:  BEGIN
                  IF CLEAR_REG THEN
                    GENRR(XSR,NXTRG,NXTRG) ;
                  GENRX(XIC,NXTRG,Q,B,P) ;
                  END;
"&&"  INT,ADR:    GENRX(XL,NXTRG,Q,B,P) ;
"&&"  HINT:       BEGIN  GENRX(XLH,NXTRG,Q,B,P);  DTYPE := INT  END;
"&&"            END;
                VPA := RGS ;  RGADR := NXTRG ;
                END ;
              P := FPA.LVL ;  Q := FPA.DSPLMT ;
              FPA := ZEROBL ;
              IF Q <> 0 THEN
                IF P > 0 THEN
                  BEGIN  BASE(Q,P,B) ;
                  IF P <= 0 THEN P := B ELSE
                    IF B > 0 THEN GENRR(XAR,P,B) ;
                  IF Q = 0 THEN GENRR(XAR,RGADR,P) ELSE
                    GENRX(XLA,RGADR,Q,P,RGADR) ;
                  END
                ELSE IF Q = -1 THEN GENRR(XBCTR,RGADR,0)
                     ELSE GENRXLIT(XA,RGADR,Q,0) ;
            END (*ADR,INT,BOOL,CHRC*) ;

          REEL:
             IF VPA = MEM THEN
             BEGIN
                FINDFP;
                P := MEMADR.LVL;
                Q := MEMADR.DSPLMT;
                BASE(Q,P,B);
                GENRX(XLD,NXTRG,Q,B,P);
                VPA := RGS;
                RGADR := NXTRG;
             END (* REEL *);

          PSET:
"**"        IF VPA <> RGS THEN
"**"        BEGIN
"**"          IF VPA = MEM THEN
"**"            BEGIN  P := MEMADR.LVL;  Q := MEMADR.DSPLMT  END
"**"          ELSE BEGIN  P := CURLVL;  Q := STKADR  END;
"**"          BASE( Q, P, B );
"**"          IF PLEN <= 8 THEN
"&&"            IF PLEN > 4 THEN
"**"              BEGIN  FINDRP;
"**"                IF B > 0 THEN IF P > 0 THEN GENRR(XAR,P,B) ELSE P:=B;
"**"                GENRS(XLM,NXTRG,NXTRG+1,Q,P);
"**"              END
"**"            ELSE IF PLEN > 0 THEN
"**"              BEGIN  FINDRG;
"**"                GENRX(XL,NXTRG,Q,P,B);
"**"              END;
"**"          VPA := RGS;  RGADR := NXTRG;
"**"        END  (*PSET*) ;

          END (* CASE DTYPE_ END OF DIRECT VARIABLE LOAD *)

        ELSE (* IF NOT DRCT *)

          BEGIN
          GETADR(STE, Q, P, B) ;   FPA := ZEROBL ;

            CASE DTYPE OF

            ADR, HINT, INT :
              BEGIN   IF VPA = RGS THEN  AVAIL[RGADR] := TRUE ;
              FINDMDRG ;
"&&"          IF DTYPE <> HINT THEN
"&&"            GENRX(XL, NXTRG, Q, B, P)
"&&"          ELSE
"&&"            BEGIN  GENRX(XLH, NXTRG, Q, B, P);  DTYPE := INT  END;
              END ;

            BOOL, CHRC:
              BEGIN  FINDMDRG ;
              IF CLEAR_REG THEN  GENRR(XSR,NXTRG,NXTRG) ;
              GENRX(XIC, NXTRG, Q, B, P) ;
              IF VPA = RGS THEN  AVAIL[RGADR] := TRUE ;
              END ;

            REEL:
              BEGIN
              FINDFP;
              GENRX(XLD,NXTRG,Q,B,P) ;
              IF VPA = RGS THEN  AVAIL[RGADR] := TRUE ;
              END (* REEL *);

            PSET:
              BEGIN
              IF VPA = RGS THEN  AVAIL[RGADR] := TRUE ;
"**"          IF PLEN <= 8 THEN
"&&"            IF PLEN > 4 THEN
"**"              BEGIN  FINDRP;
"**"                IF B>0 THEN IF P>0 THEN GENRR(XAR,P,B) ELSE P:=B;
"**"                GENRS(XLM,NXTRG,NXTRG+1,Q,P);
"**"              END
"**"            ELSE IF PLEN > 0 THEN
"**"              BEGIN FINDRG;
"**"                GENRX(XL,NXTRG,Q,P,B);
"**"              END;
              END

            END (* CASE DTYPE *) ;

          VPA := RGS ;   RGADR := NXTRG ;  DRCT := TRUE ;
          END (* LOAD INDRCT *)

      ELSE (* IF NOT VRBL, I.E. LOAD CONSTANT *)


          BEGIN

            CASE DTYPE OF

            ADR:
              BEGIN  P := FPA.LVL ;  Q := FPA.DSPLMT ;
              FINDRG ;
              IF P > 0 THEN  BEGIN  BASE(Q,P,B) ;  GENRX(XLA,NXTRG,Q,B,P) END
              ELSE IF P < 0 THEN
"&&"            BEGIN  GENRX( XLA, NXTRG, 0, 0, 0 );
"&&"              IF P = -1 THEN LITTBL[SCNSTNO].LNK := PC-1            ;
"&&"              CODE.H[PC-1] := Q;
"&&"            END
              ELSE  GENRXLIT(XL,NXTRG,FPA.DSPLMT,0) ; (*NIL VALUE*)
              FPA := ZEROBL ;
              END ;

            HINT,INT,BOOL,CHRC:
              BEGIN  FINDMDRG ;
              IF FPA.DSPLMT = 0 THEN GENRR(XSR,NXTRG,NXTRG)
              ELSE GENRXLIT(XL,NXTRG,FPA.DSPLMT,0) ;
              FPA := ZEROBL ;
              END ;

            REEL:
               BEGIN
                  FINDFP;
"&&"              GENRXDLIT(XLD,NXTRG,RCNST)
               END (* REEL *);

            PSET:
"**"          IF PLEN <= 8 THEN
"&&"            IF PLEN > 4 THEN
"**"              BEGIN  FINDRP;
"**"                GENRSLIT(XLM,NXTRG,NXTRG+1,PCNST@[1]);
"**"              END
"**"            ELSE IF PLEN > 0 THEN
"**"              BEGIN  FINDRG;  I_S_R.S := PCNST@[1];
"**"                GENRXLIT(XL,NXTRG,I_S_R.I1,0);
"**"              END
"**"            ELSE  (* PLEN = 0 *)
"**"              BEGIN  FINDRG;  PLEN := 4;
"**"                GENRR( XSR, NXTRG, NXTRG );
"**"              END;

            END (* CASE DTYPE *) ;

          VRBL := TRUE ;  VPA := RGS ;  RGADR := NXTRG ;  DRCT := TRUE ;
          END (* LOAD CONSTANT *) ;

      IF MDTAG = PMPI THEN
        BEGIN
        IF NOT ODD(RGADR) OR NOT AVAIL[RGADR-1] THEN
          BEGIN  AVAIL[RGADR] := TRUE ;
          FINDRP ;  GENRR(XLR,NXTRG+1,RGADR) ;
          RGADR := NXTRG+1 ;
          END ;
        RGADR := RGADR-1 ;
        AVAIL[RGADR] := FALSE
        END
      ELSE
       IF MDTAG = PDVI THEN
         BEGIN
         IF ODD(RGADR) OR NOT AVAIL[RGADR+1] THEN
           BEGIN  AVAIL[RGADR] := TRUE ;
           FINDRP ;  GENRR(XLR,NXTRG,RGADR) ;
           RGADR := NXTRG ;
           END ;
         AVAIL[RGADR+1] := FALSE ;
         GENRS(XSRDA,RGADR,0,32,0);
         END

       END (*WITH STE DO*) ;

    END (* LOAD *) ;


  PROCEDURE GETADR ;
     (* IF PASSED THE ADR. OF AN ITEM , THIS ROUTINE RETURNS A <Q,B,P> ADR. *)
     (* INDIRECTIONS ARE NOT DEREFERENCED HERE.                             *)
     (* ------------------------------------------------------------------- *)
     VAR R: RGRNG ;

     BEGIN  R := 0 ;
     WITH STE DO
       BEGIN  IF DRCT AND (DTYPE <> ADR) THEN  ERROR(602) ;
       IF VRBL THEN
           IF VPA = RGS THEN  R := RGADR
           ELSE  (*VPA = MEM OR VPA = ONSTK *)
"**"             BEGIN
"**"             IF VPA = MEM THEN
"**"               BEGIN  P := MEMADR.LVL;  Q := MEMADR.DSPLMT  END
"**"             ELSE ERROR( 616 );
                 BASE(Q, P, B) ;
                 GENRX(XL, TXRG, Q, B, P) ;   R := TXRG
                 END ;

       (* NOW THE VARIABLE PORTION OF THE ADR., IF ANY, IS IN TXRG *)

       Q := FPA.DSPLMT ;  P := FPA.LVL ;
       IF R > 0 THEN
         BEGIN
         IF (Q < 0) OR (Q > SHRTINT) THEN
           BEGIN  GENRXLIT(XA,R,Q,0) ;  Q := 0  END ;
         B := 0 ;
         IF P = CURLVL THEN  B := LBR
         ELSE IF P = 1 THEN  B := GBR
         ELSE IF P > 0 THEN  GENRX(XA,R,DISPLAY+4*P,GBR,0) ;
         P := R ;
         END
       ELSE (* NO INDEX OR VPA *)
         BASE(Q,P,B) ;

       END (*WITH STE*)
     END (*GETADR*) ;


  PROCEDURE GETOPERAND(VAR STE: DATUM; VAR Q1 : ADRRNG; VAR P1, B1: RGRNG) ;
   (* IF PASSED AN ITEM, THIS ROUTINE RETURNS ITS <Q,B,P> ADDRESS *)
   (* WARNING ON USAGE OF THIS PROCEDURE!!!
      IT IS UNSAFE TO CALL FINDRG (AND THEREFORE ALSO FINDRP, LOAD, ...)
      AFTER GETOPERAND AND BEFORE THE P1 REGISTER HAS BEEN USED       *)
    BEGIN
    WITH STE DO
      IF VRBL THEN
        IF DRCT THEN
          IF FPA.DSPLMT <> 0 THEN LOAD(STE)
          ELSE
            BEGIN  IF VPA = MEM THEN
                     BEGIN  Q1 := MEMADR.DSPLMT ;  P1 := MEMADR.LVL ;
                     BASE(Q1,P1,B1) ;
                     END
"**"               ELSE IF VPA = ONSTK THEN
"**"                 BEGIN  P1 := CURLVL;  Q1 := STKADR;
"**"                   BASE(Q1,P1,B1);
"**"                 END
            (* THE VPA=REG CASE NOT HANDLED HERE *)
            END
        ELSE (*NOT DIRCT*)
          BEGIN
          GETADR(STE,Q1,P1,B1) ;
          IF VPA = RGS THEN  AVAIL[RGADR] := TRUE ;
          END

      ELSE (*^ VRBL*)  (*MAY NOT HAVE ANY FUNCTION ANY MORE*)
        BEGIN  IF DTYPE <> ADR THEN ERROR(602) ;
        Q1 := FPA.DSPLMT ;  P1 := FPA.LVL ;
        BASE(Q1,P1,B1) ;
        END ;
    END (*GETOPERAND*) ;


"**" PROCEDURE GETQB( VAR STE: DATUM;  VAR Q: ADRRNG;
"**"                        VAR P: RGRNG;  L:INTEGER );
"**"   (* GETS BASE-DISPLACEMENT ADDRESS SUCH THAT THE
"**"      DISPLACEMENT < 4096-L                        *)
"**"    VAR  B: RGRNG;
"**" BEGIN
"**"   IF L < 0 THEN L := 0;
"**"   GETOPERAND( STE, Q, P, B );
"**"   IF B > 0 THEN
"**"     IF P > 0 THEN
"**"       IF Q >= (4096-L) THEN
"**"         BEGIN  GENRX( XLA, TXRG, Q, P, B );
"**"                Q := 0;  P := TXRG;  B := 0;
"**"         END
"**"       ELSE GENRR( XAR, P, B )
"**"     ELSE P := B;
"**"   IF Q >= (4096-L) THEN
"**"     BEGIN  GENRX( XLA, TXRG, Q, P, 0 );
"**"            P := TXRG;  Q := 0;
"**"     END;
"**" END  (*GETQB*) ;


  PROCEDURE STORE(STP: STKPTR; INDRCT: BOOLEAN) ;
    (* STORE THE STACK ELEMENT IN THE LOCATION DENOTED BY : *)
    (* IF INDRCT  THEN  2_ND TOP STACK ELEMENT              *)
    (* ELSE P_Q FIELDS OF THE CURRENT INSTRUCTION           *)
    (* ---------------------------------------------------- *)
"&&"  VAR B: RGRNG;  P1: RGRNG;
    BEGIN
    (* LOADS THE ELEMENT INTO A REGISTER *)
     CLEAR_REG := STK[STP].DTYPE <> OPNDTYPE ;
"&&" IF (OPNDTYPE > CHRC) OR STK[STP].VRBL THEN LOAD( STK[STP] );
"&&" CLEAR_REG := TRUE;
"&&" P1 := P;
    IF INDRCT THEN
      BEGIN  IF NOT STK[STP-1].DRCT THEN LOAD(STK[STP-1]) ;
"&&"    GETADR(STK[STP-1],Q,P1,B) ;
        FREEREG(STK[STP-1]) ;
      END
"&&"ELSE  BASE(Q,P1,B) ;

    WITH STK[STP] DO
      BEGIN
      IF VRBL THEN
        IF (NOT DRCT) OR (VPA = MEM) THEN
          IF DTYPE <> OPNDTYPE THEN
"&&"        IF (DTYPE <> INT) OR (OPNDTYPE <> HINT) THEN ERROR(601);

        CASE OPNDTYPE OF

        ADR,INT:   BEGIN  GENRX(XST,RGADR,Q,B,P1) ;  AVAIL[RGADR] := TRUE END ;

"&&"    HINT:      BEGIN  GENRX(XSTH,RGADR,Q,B,P1);
"&&"                      AVAIL[RGADR] := TRUE
"&&"               END;

"&&"    BOOL,CHRC: IF VRBL THEN
"&&"                 BEGIN  AVAIL[RGADR] := TRUE;
"&&"                        GENRX(XSTC,RGADR,Q,B,P1);
"&&"                 END
"&&"               ELSE  (* STORING A CONSTANT *)
"&&"                 BEGIN
"&&"                   IF (FPA.DSPLMT<0) OR (FPA.DSPLMT>255) THEN
"&&"                     BEGIN  ERROR(302);  FPA.DSPLMT := 0  END;
"&&"                   IF B > 0 THEN
"&&"                     IF P1 > 0 THEN GENRR(XAR,P1,B)
"&&"                     ELSE P1 := B;
"&&"                   GENSI(XMVI,Q,P1,FPA.DSPLMT);
"&&"                 END;

        REEL:
          BEGIN
            GENRX(XSTD,RGADR,Q,B,P1) ;
            AVAILFP[RGADR] := TRUE
          END  (* REEL *) ;

        PSET:      ERROR( 616 );

        END (* CASE OPNDTYPE *)

      END (* WITH STK... *)

    END (* STORE *) ;


"**" PROCEDURE CALLSUB;
"**"   VAR  K: INTEGER;
"&&"        DSREG,P1,B1,FPR: RGRNG;  Q1: ADRRNG;  PPCALL: BOOLEAN;
"**" BEGIN   (* Q = STACK DISPLACEMENT OF NEW ACTIV. RECORD *)
"**"   IF ODD(P) THEN  (* SAVEFPRS FOR THIS CALL *)
"**"     BEGIN
"**"       P := P - 1;  SAVEFPRS := TRUE;
"**"       FPR := 0;  K := FPRSAREA;
"**"       REPEAT  FPR := FPR+2;  K := K + REALSIZE;
"**"               IF NOT AVAILFP[FPR] THEN
"**"                 GENRX( XSTD, FPR, K, LBR, 0 );
"**"       UNTIL FPR >= FPCNT;
"**"     END
"**"     ELSE  SAVEFPRS := FALSE;
"&&"     WITH CALSTK[CALDPTH] DO
"&&"       IF DISPSAV > 0 THEN  (* CALL ON PARAMETRIC PROCEDURE *)
"&&"         BEGIN  FINDRG;
"&&"           GENRR( XLR, NXTRG, LBR );  DSREG := NXTRG;
"&&"           IF DISPSAV > 4095 THEN
"&&"             BEGIN  GENRXLIT( XA, DSREG, DISPSAV, 0 );
"&&"                    DISPSAV := 0
"&&"             END;
"&&"           GENSS( XMVC, DISPAREA, DISPSAV, DSREG, DISPLAY, GBR );
"&&"           PPCALL := TRUE;
"&&"           Q1 := PFLEV DIV 10;  P1 := PFLEV MOD 10;
"&&"           BASE( Q1, P1, B1 );
"&&"           IF P1 <= 0 THEN P1 := B1 ELSE
"&&"             IF B1 > 0 THEN GENRR( XAR, P1, B1 );
"&&"           GENSS( XMVC, DISPAREA-4, DISPLAY+4, GBR, Q1+4, P1 );
"&&"           GENRX( XL, TRG15, Q1, P1, 0 );  (* LOAD PROC. ADDR. *)
"&&"         END
"&&"       ELSE PPCALL := FALSE;
"**"   IF Q <= 4095 THEN GENRX( XLA, TRG1, Q, LBR, 0 )
"**"   ELSE BEGIN
"**"     GENRR( XLR, TRG1, LBR );
"**"     GENRXLIT( XA, TRG1, Q, 0 );
"**"   END;
"**"   IF OPNDTYPE IN [FORT,FBOOL,FINT,FREAL] THEN
"**"     BEGIN
"**"       K := P * 2;  (* K = LENGTH OF PARM LIST *)
"**"       IF K > 0 THEN GENSI( XMVI, K-4, TRG1, 128 );
"**"       K := ALIGN( K, REALSIZE );
"**"       GENRX( XST, TRG13, K+4, TRG1, 0 );  (* S/A CHAINING *)
"**"       GENRR( XLR, TRG14, TRG13 );
"**"       GENRX( XLA, TRG13, K, TRG1, 0 );
"**"       GENRX( XST, TRG13, 8, TRG14, 0 );
"&&"     END;
"&&"   IF NOT FLOW_TRACE THEN
"&&"     BEGIN
"&&"       IF NOT PPCALL THEN GENRXLAB( XL, TRG15, LBL2, -3 );
"**"       GENRR( XBALR, TRG14, TRG15 );
"&&"     END
"&&"   ELSE  (* GENERATE SPECIAL CALL CODE *)
"&&"     BEGIN
"&&"       IF PPCALL THEN
"&&"         BEGIN  IF ODD(PC) THEN GENRR(XBCR,NOCND,0);  (* ALIGN TO WORD *)
"&&"           GENRELRX( XST, TRG15, 4 );     (* ST 15,*+8  *)
"&&"           GENRELRX( XBC, ANYCND, 4 );    (* B  *+8     *)
"&&"           CODE.I(/PC DIV 2/) := 0;  PC := NEXTPC(2);
"&&"           GENRX( XBAL, TRG14, TRACER, GBR, 0 );
"&&"           CODE.H[PC] := 2*PC - 8;        (* DC AL2( *-8 )  *)
"&&"         END
"&&"       ELSE
"&&"         BEGIN
"&&"           GENRX( XBAL, TRG14, TRACER, GBR, 0 );
"&&"           UPD_PRCTBL( PC, LBL2.NAM );
"&&"         END;
"&&"       PC := NEXTPC(1);
"&&"     END;
"&&"   IF PPCALL THEN  (* RESTORE DISPLAY *)
"&&"     BEGIN
"&&"       GENSS( XMVC, DISPAREA, DISPLAY, GBR,
"&&"              CALSTK[CALDPTH].DISPSAV, DSREG );
"&&"       AVAIL[DSREG] := TRUE;
"&&"     END;
"&&"   CALDPTH := CALDPTH - 1;
"&&"   IF OPNDTYPE IN [FORT,FBOOL,FINT,FREAL] THEN
"**"       GENRX( XL, TRG13, 4, TRG13, 0 );
"**"   IF SAVEFPRS THEN
"**"     BEGIN  FPR := 0;  K := FPRSAREA;
"**"            REPEAT  FPR := FPR + 2;  K := K + REALSIZE;
"**"                    IF NOT AVAILFP[FPR] THEN
"**"                      GENRX( XLD, FPR, K, LBR, 0 );
"**"            UNTIL  FPR >= FPCNT;
"**"     END;
"**"   CLEAR_REG := TRUE;
"**"   CSPREGACTIVE := FALSE;  OLDCSP := PSIO;  (* R1,R15 USED *)
"**" END (*CALLSUB*) ;


    PROCEDURE GOTOCSP ;
"&&"  VAR  OPC: BYTE;
      BEGIN
      IF NOT CSPREGACTIVE THEN        (* (RE)LOAD PROCADR AND FUNC NUMBER *)
        BEGIN
        LBL3.NAM := '$PASCSP ' ;  LBL3.LEN := 7 ;
        GENRXLAB(XL,TRG15,LBL3,-3) ;
        END ;
      IF CSP <> OLDCSP THEN  GENRX(XLA,TRG1,ORD(CSP)*4,0,0) ;

      IF NOT FILREGACTIVE THEN
        IF CSP IN [PRES,PREW,PGET,PPUT,PRLN,PWLN,PPAG,
"&&"               PSKP,PLIM,PRDB,PWRB,PRDH,PRDY,PEOL,PEOT,
                   PRDC,PWRC,PRDI,PWRI,PRDS,PWRS,PRDR,PWRR,PFDF]  THEN
          WITH STK[TOP-1] DO
            BEGIN
            IF VRBL THEN
"&&"          BEGIN  OPC := XL;  Q1 := MEMADR.DSPLMT;  P1 := MEMADR.LVL  END
"&&"        ELSE
"&&"          BEGIN  OPC := XLA;  Q1 := FPA.DSPLMT;  P1 := FPA.LVL  END;
"&&"        WITH LAST_FILE DO
"&&"          BEGIN  LFOPND.DSPLMT := Q1;  LFOPND.LVL := P1;
"&&"                 LFV := VRBL;
"&&"          END;
            BASE(Q1,P1,B1) ;
"&&"      GENRX( OPC, FILADR, Q1, B1, P1 );
            FILREGACTIVE := TRUE ;
            END ;
      GENRR(XBALR,TRG14,TRG15) ;
"&&"  CSPREGACTIVE := TRUE;  OLDCSP := CSP;  LAST_FILE.LPC := PC;
      END (*GOTOCSP*) ;


  PROCEDURE CALLSTNDRD ;
  (* TO CALL A STANDARD PROCEDURE *)
  (* ---------------------------- *)
"&&"  VAR  Q1,LEN: ADRRNG;  P1,B1: RGRNG;  OPC: BYTE;


    PROCEDURE FILESETUP(PRMCNT: RGRNG) ;
    (* TO SET UP PARAMETERS FOR THE FILE I/O AND CALL THE I/O ROUTINE *)
    (* -------------------------------------------------------------- *)
"&&"  LABEL 10;
      VAR  I : RGRNG ;
"&&"       STP: STKPTR;  CPARM3: INTEGER;
      BEGIN
      STP := TOP-PRMCNT+1 ;
      TOP := STP ;           (* POINTING TO NEXT AVAILABLE STACK ELEMENT *)
      IF PRMCNT >= 2 THEN  (*POTENTIAL REGISTER CONFLICT*)
        WITH STK[STP+1] DO
          IF VRBL AND (VPA = RGS) AND (RGADR = 2) THEN
            BEGIN  FINDRG ;  GENRR(XLR,NXTRG,2) ;
            AVAIL[NXTRG] := FALSE ;  AVAIL[2] := TRUE ;  RGADR := NXTRG ;
            END ;
"&&"  CPARM3 := -1;
      FOR I := 2 TO PRMCNT+1 DO
"&&"    WITH STK[STP] DO
"&&"      BEGIN
"&&"        IF NOT VRBL THEN
"&&"          IF I = 3 THEN CPARM3 := FPA.DSPLMT
"&&"          ELSE IF I = 4 THEN
"&&"            IF CPARM3 = FPA.DSPLMT THEN
"&&"              BEGIN  RGADR := 3;  GOTO 10  END;
"&&"        LOAD( STK[STP] );
"&&"   10:  IF DTYPE <> REEL THEN
              BEGIN (*THE COMMON CASE*)
              IF RGADR <> I THEN
                  IF AVAIL[I]  THEN
                    BEGIN
                    GENRR(XLR,I,RGADR) ;
"&&"                IF RGADR > I THEN AVAIL[RGADR] := TRUE;
                    AVAIL[I] := FALSE ;  RGADR := I ;
                    END
                  ELSE  ERROR(259)
              END
            ELSE (*DTYPE = REEL, I.E. WRR*)
              BEGIN
              IF RGADR <> I THEN
                IF AVAILFP[I] THEN  GENRR(XLDR,I,RGADR)
                ELSE  ERROR(259) ;
              AVAILFP[RGADR] := TRUE ;  AVAIL[I] := FALSE ;
              RGADR := I ;  (*KLUDGE TO RELEASE THE FIX. REG. LATER*)
              END ;
        STP := STP+1 ;
        END (* FOR I...*) ;
      GOTOCSP ;
      FOR I := 2 TO PRMCNT+1 DO
        BEGIN  STP := STP-1 ;  AVAIL[STK[STP].RGADR] := TRUE  END ;
      END (*FILESETUP*) ;


    BEGIN (*CALLSTNDRD*)
     TOP := TOP - 1;
     CASE CSP OF

"NH"  PCLK :
"NH"    WITH STK[TOP] DO
"NH"    BEGIN
"NH"       LOAD(STK[TOP]);
"NH"       GENRR(XLR,0,RGADR);
"NH"       GOTOCSP;
"NH"       GENRR(XLR,RGADR,0);
"NH"       TOP := TOP + 1;  OLDCSP := PSIO;
"NH"    END (* PCLK *) ;
"NH"
"NH"  PMSG :
"NH"    BEGIN
"NH"       LOAD( STK[TOP-1] );
"NH"       WITH STK[TOP-1] DO
"NH"       BEGIN
"NH"          IF RGADR <> 2 THEN
                 IF AVAIL[2] THEN
                    BEGIN  GENRR(XLR,2,RGADR);
                    AVAIL[RGADR] := TRUE;  AVAIL[2] := FALSE;
                    RGADR := 2;
                    END
                 ELSE  ERROR(259);   (* ASSUMING THE CURRENT SIMPLE FORMAT *)
"NH"       END;
"NH"       LOAD( STK[TOP] );
"NH"       WITH STK[TOP] DO
"NH"       BEGIN
"NH"          IF RGADR <> 3 THEN
                 IF AVAIL[3] THEN
                    BEGIN  GENRR(XLR,3,RGADR);
                    AVAIL[RGADR] := TRUE;  AVAIL[3] := FALSE;
                    RGADR := 3;
                    END
                 ELSE  ERROR(259);
"NH"       END;
"NH"       GOTOCSP;  OLDCSP := PSIO;
"NH"       AVAIL[2] := TRUE;  AVAIL[3] := TRUE;
           TOP := TOP-1;
"NH"    END (* PMSG *) ;

"&&"  PXIT, PTRA :
        WITH STK[TOP] DO
          BEGIN  LOAD(STK[TOP]) ;  AVAIL[RGADR] := TRUE ;
          IF RGADR <> 2 THEN GENRR(XLR,2,RGADR) ;
          GOTOCSP ;
          END (*PXIT*) ;

      PTRP :
        BEGIN
        WITH STK[TOP] DO
          IF (NOT DRCT) OR (DTYPE <> ADR) THEN ERROR(602)
          ELSE
            BEGIN  GETOPERAND(STK[TOP],Q1,P1,B1)  ;
            IF VRBL THEN
              IF VPA = MEM THEN  GENRX(XL,1,Q1,B1,P1)
              ELSE  BEGIN  GENRR(XLR,1,RGADR) ; AVAIL[RGADR] := TRUE END
            ELSE  GENRX(XLA,1,Q1,B1,P1) ;
            END ;
        TOP := TOP-1 ;
        WITH STK[TOP] DO
          IF NOT DRCT THEN ERROR(602)
          ELSE
            IF NOT VRBL THEN GENRXLIT(XL,0,FPA.DSPLMT,0)
            ELSE
              BEGIN  GETOPERAND(STK[TOP],Q1,P1,B1) ;
              IF VPA = MEM THEN  GENRX(XL,0,Q1,B1,P1)
              ELSE  BEGIN GENRR(XLR,0,RGADR) ;  AVAIL[RGADR] := TRUE ; END ;
              END ;
        LBL3.NAM := '$PASTRAP' ;  LBL3.LEN := 8 ;
"&&"    IF NOT FLOW_TRACE THEN
"&&"      BEGIN  GENRXLAB( XL, JREG, LBL3, -3 );
"&&"             GENRR( XBALR, RTREG, JREG );
"&&"      END
"&&"    ELSE  (* SPECIAL CALL CODE *)
"&&"      BEGIN  GENRX( XBAL, TRG14, TRACER, GBR, 0 );
"&&"         (*  IF ASM THEN WRITELN(OUTPUT,' DC AL2(',
"&&"                PRCTBL[0].NAME,'-=V($PASTRAP))') ELSE *)
"&&"             UPD_PRCTBL( PC, LBL3.NAM );
"&&"             PC := NEXTPC(1);
"&&"      END;
        END (*PTRP*) ;

      PSIO :
          BEGIN
          IF NOT AVAIL[FILADR] THEN  IF FILECNT = 0 THEN  ERROR(259) ;
          AVAIL[FILADR] := FALSE ;
          FILREGACTIVE := FALSE ;  FILECNT := FILECNT+1 ;
"&&"      WITH LAST_FILE DO
"&&"        IF LPC = PC THEN
"&&"          WITH STK[TOP] DO
"&&"            IF VRBL THEN
"&&"              FILREGACTIVE := LFV AND (LFOPND = MEMADR)
"&&"            ELSE
"&&"              FILREGACTIVE := (NOT LFV) AND (LFOPND = FPA);
          OLDCSP := PSIO ;
          TOP := TOP+1 ;    (* TO CANCEL OUT PREVIOUS SUBTRACT OPERATION *)
          END (*PSIO*) ;

      PEIO :
        BEGIN    (* RELEASE FILE ADR REG ETC. *)
        FILECNT := FILECNT-1 ;
        IF FILECNT = 0 THEN AVAIL[FILADR] := TRUE ;
        FILREGACTIVE := FALSE ;  OLDCSP := PEIO ;
"&&"    LAST_FILE.LPC := PC;
        (* TOP := TOP-1 IS DONE AT ENTRY TO CALLSTNDRD  *)
        END (*PEIO*) ;

      PELN,PEOF :
"@@"    BEGIN
"@@"    WITH STK[TOP] DO
"@@"      BEGIN
"@@"        IF VRBL THEN
"@@"        BEGIN
"@@"          LOAD( STK[TOP] );
"@@"          DRCT := FALSE;  FPA.LVL := -1;
"@@"          IF CSP = PEOF THEN FPA.DSPLMT := EOFDPLMT
"@@"                        ELSE FPA.DSPLMT := EOLDPLMT;
"@@"        END
"@@"        ELSE BEGIN
"@@"          VPA := MEM;  VRBL := TRUE;
"@@"          MEMADR.LVL := FPA.LVL;
"@@"          IF CSP = PEOF THEN MEMADR.DSPLMT := FPA.DSPLMT+EOFDPLMT
"@@"                        ELSE MEMADR.DSPLMT := FPA.DSPLMT+EOLDPLMT;
"@@"          FPA := ZEROBL;
"@@"        END;
"@@"        DTYPE := BOOL
"@@"      END;
"@@"      TOP := TOP + 2;  (*TO BE CORRECTED BY PENDING EIO*)
        END (*PELN.PEOF*) ;

"&&"   PEOL,PEOT :
"&&"    BEGIN
"&&"    FILESETUP(0);
"&&"    WITH STK[TOP-1] DO
"&&"      BEGIN  FINDRG;
"&&"        GENRR( XLR, NXTRG, FILADR );
"&&"        VRBL := TRUE;  DRCT := FALSE;  VPA := RGS;
"&&"        RGADR := NXTRG;  FPA.LVL := -1;
"&&"        IF CSP = PEOL THEN FPA.DSPLMT := EOLDPLMT
"&&"                      ELSE FPA.DSPLMT := EOFDPLMT;
"&&"        DTYPE := BOOL;
"&&"      END;
"&&"    TOP := TOP + 1;
"&&"    END (*PEOL,PEOT*) ;

"&&"   PRDD :
"&&"    BEGIN
"&&"    TOP := TOP - 2;
"&&"    CSP := PGET;
"&&"    FILESETUP(0);
"&&"    GETADR( STK[TOP], Q1, P1, B1 );
"&&"    IF NOT STK[TOP].DRCT THEN
"&&"      BEGIN  GENRX( XL, TXRG, Q1, B1, P1 );
"&&"             Q1 := 0;  B1 := 0;  P1 := TXRG
"&&"      END;
"&&"    FREEREG( STK(/TOP/) );
"&&"    LEN := STK[TOP+1].FPA.DSPLMT;
"&&"    IF LEN <= 256 THEN
"&&"      BEGIN
"&&"        IF B1 > 0 THEN IF P1 > 0 THEN GENRR( XAR, P1, B1 )
"&&"                       ELSE P1 := B1;
"&&"        GENSS( XMVC, LEN, Q1, P1, FILHDRSZ, FILADR );
"&&"      END
"&&"    ELSE
"&&"      BEGIN  FINDRP;
"&&"        GENRX( XLA, NXTRG, Q1, B1, P1 );
"&&"        GENRXLIT( XL, NXTRG+1, LEN, 0 );
"&&"        P1 := NXTRG;  FINDRP;
"&&"        GENRX( XLA, NXTRG, FILHDRSZ, FILADR, 0 );
"&&"        GENRR( XLR, NXTRG+1, P1+1 );
"&&"        GENRR( XMVCL, P1, NXTRG );
"&&"        S370CNT := S370CNT + 1;
"&&"        AVAIL[P1]   := TRUE;  AVAIL[NXTRG]   := TRUE;
"&&"        AVAIL[P1+1] := TRUE;  AVAIL[NXTRG+1] := TRUE;
"&&"      END
"&&"    END (*RDD*);
"&&"
"&&"   PWRD, PWRE :
"&&"    BEGIN
"&L"    LEN := STK[TOP].FPA.DSPLMT;
"&&"    IF NOT FILREGACTIVE THEN
"&&"      WITH STK[TOP-2] DO
"&&"        BEGIN
"&&"          IF VRBL THEN
"&&"            BEGIN  OPC := XL;  P1 := MEMADR.LVL;  Q1 := MEMADR.DSPLMT  END
"&&"          ELSE
"&&"            BEGIN  OPC := XLA;  P1 := FPA.LVL;  Q1 := FPA.DSPLMT  END;
"&&"          BASE( Q1, P1, B1 );
"&&"          GENRX( OPC, FILADR, Q1, B1, P1 );
"&&"          FILREGACTIVE := TRUE;
"&&"        END;
"&&"      WITH STK[TOP-1] DO
"&&"        IF CSP = PWRE THEN
"&&"          BEGIN  LOAD( STK[TOP-1] );
"&&"            IF DTYPE = REEL THEN
"&&"              BEGIN  OPC := XSTD;  AVAILFP[RGADR] := TRUE  END
"&&"            ELSE
"&&"              BEGIN  AVAIL[RGADR] := TRUE;
"&&"                IF LEN = 2 THEN OPC := XSTH ELSE
"&&"                  IF LEN = 1 THEN OPC := XSTC ELSE
"&&"                    OPC := XST;
"&&"              END;
"&&"            GENRX( OPC, RGADR, FILHDRSZ, FILADR, 0 );
"&&"          END
"&&"        ELSE
"&&"          BEGIN  (* CSP = PWRD *)
"&&"            GETADR( STK[TOP-1], Q1, P1, B1 );
"&&"            IF NOT DRCT THEN
"&&"              BEGIN  GENRX( XL, TXRG, Q1, B1, P1 );
"&&"                     Q1 := 0;  B1 := 0;  P1 := TXRG
"&&"              END;
"&&"            FREEREG( STK(/TOP-1/) );
"&&"            IF LEN <= 256 THEN
"&&"              BEGIN
"&&"                IF B1 > 0 THEN IF P1 > 0 THEN GENRR( XAR, P1, B1 )
"&&"                               ELSE P1 := B1;
"&&"                GENSS( XMVC, LEN, FILHDRSZ, FILADR, Q1, P1 );
"&&"              END
"&&"            ELSE
"&&"              BEGIN  FINDRP;
"&&"                GENRX( XLA, NXTRG, Q1, B1, P1 );
"&&"                GENRXLIT( XL, NXTRG+1, LEN, 0 );
"&&"                P1 := NXTRG;  FINDRP;
"&&"                GENRX( XLA, NXTRG, FILHDRSZ, FILADR, 0 );
"&&"                GENRR( XLR, NXTRG+1, P1+1 );
"&&"                GENRR( XMVCL, NXTRG, P1 );
"&&"                S370CNT := S370CNT + 1;
"&&"                AVAIL[P1]    := TRUE;  AVAIL[P1+1] := TRUE;
"&&"                AVAIL[NXTRG] := TRUE;  AVAIL[NXTRG+1] := TRUE;
"&&"              END;
"&&"          END;
"&&"      TOP := TOP - 2;
"&&"      CSP := PPUT;
"&&"      FILESETUP( 0 );
"&&"      END (*PWRD,PWRE*);

      PGET,PPUT,PRLN,PWLN,PRES,PREW,PPAG :
        FILESETUP(0) ;

"&&"  PRDC,PRDI,PRDR,PSKP,PLIM,PRDB,PRDH,PRDY:
        FILESETUP(1) ;

"@@"  PRDS,PWRC,PWRI,PWRB,PFDF :
        FILESETUP(2) ;

      PWRS,PWRR :
        FILESETUP(3) ;
"&&"
"&&" OTHERWISE  BEGIN  WRITE(' -->', NMCDE);  ERROR(607)  END;

      END (*CASE CSP...*) ;

    END (*CALLSTNDRD*) ;

"@@" PROCEDURE CHKOPERATION ;
"&&" VAR  RTA: ADRRNG;  BPC: ICRNG;
"@@" BEGIN
       WITH STK[TOP-1] DO
         IF VRBL THEN   (* GENERATE CODE FOR RUN TIME CHECK *)
"&&"       IF OPNDTYPE = ADR THEN  (* POINTER CHECK *)
             BEGIN
             IF NOT AVAIL[2] THEN
               IF NOT ((VPA = RGS) AND (RGADR = 2)) THEN
                 BEGIN   J := 0 ;  (* CLEAR GPR 2 *)
                 FOR I := TOP-2 DOWNTO 1 DO
                   WITH STK[I] DO
                     IF VRBL THEN
                       IF (NOT DRCT) OR (DTYPE <> REEL) THEN
                         IF (VPA = RGS) AND (RGADR = 2) THEN  J := I;
                 IF J = 0 THEN  ERROR(259)
                 ELSE
                   WITH STK[J]  DO
                   BEGIN   FINDRG ;  (* TRADE GPR2 FOR ANOTHER ONE *)
                     GENRR(XLR,NXTRG,2) ;  (* THIS FREES REG 2 *)
                     RGADR := NXTRG ;
                   END;
                 END ;
"&&"        AVAIL[2] := TRUE;  (* IN CASE *)
"&&"        LOAD( STK[TOP-1] );
"&&"        AVAIL(/2/) := FALSE;
"&&"        IF RGADR <> 2 THEN  (* VALUE IS IN WRONG REG. *)
"&&"          BEGIN  AVAIL(/RGADR/) := TRUE;
"&&"                 GENRR( XLR, 2, RGADR );
"&&"                 RGADR := 2
"&&"          END;
"&&"        RTA := PTRCHK;
"&&"        IF P < 0 THEN RTA := PTACHK;
"&&"        GENRX( XBAL, RTREG, RTA, GBR, 0 );
"&&"        CSPREGACTIVE := FALSE;  OLDCSP := PSIO;  (* R1,R15 DESTROYED *)
"&&"      END
"&&"    ELSE  (* OPNDTYPE <> ADR *)
"&&"      BEGIN
"&&"        IF NOT DRCT THEN LOAD( STK(/TOP-1/) );
"&&"        FPA.DSPLMT := FPA.DSPLMT - P;
"&&"        LOAD( STK(/TOP-1/) );
"&&"        I_S_R.I1 := Q-P;  I_S_R.I2 := P;
"&&"        GENRXDLIT( XCL, RGADR, I_S_R.R );  (*CHEATING WITH DATATYPES*)
"&&"        GENRX( XBC, LEQCND, 0, 0, 0 );
"&&"        BPC := PC;  (* REMEMBER WHERE BRANCH FIX-UP NEEDED *)
"&&"        IF RGADR <> 2 THEN GENRR( XLR, 2, RGADR );
"&&"        IF OPNDTYPE = PROC THEN    RTA := PRMCHK
"&&"        ELSE IF OPNDTYPE = INX THEN RTA := INXCHK
"&&"        ELSE (* HINT OR INT *)      RTA := RNGCHK;
"&&"        GENRX( XBAL, RTREG, RTA, GBR, 0 );
"&&"        UPD_DBLTBL( PC, I_S_R.R );
"&&"        PC := NEXTPC( 1 );  FPA.DSPLMT := P;
"&&"        CODE.H(/BPC-1/) := BASE_DSPLMT( PC );
"&&"      END
         ELSE (* ^ VAR,  I.E. CHECK A CONSTANT EXPRESSION *)
           IF (FPA.DSPLMT < P) OR (FPA.DSPLMT > Q) THEN
             BEGIN
             ERROR(302) ;
             WRITELN(OUTPUT, '****':9, FPA.DSPLMT:9,
"&&"                     ' IS NOT IN THE RANGE:', P:9, Q:10 );
             END ;
"@@"   END (*CHKOPERATION*) ;

"**" PROCEDURE FORCESTK( VAR STE: DATUM );
"**"   (* FORCES A SET INTO RUN-STACK MEMORY *)
"**" VAR  Q1, Q2: ADRRNG;  P1, P2, B1, R: RGRNG;
"**" BEGIN
"**"   WITH STE DO
"**"     IF NOT( DRCT AND VRBL AND (VPA=ONSTK)) THEN
"**"       IF DRCT AND VRBL AND (VPA=RGS) THEN
"**"         BEGIN
"**"           R := RGADR;  VPA := ONSTK;
"**"           IF PLEN = 8 THEN
"**"             BEGIN
"**"               GETQB( STE, Q1, P1, 0 );
"**"               GENRS( XSTM, R, R+1, Q1, P1 );
"**"               AVAIL[R+1] := TRUE;
"**"             END
"**"           ELSE  (* PLEN = 4 *)
"**"             BEGIN
"**"               GETOPERAND( STE, Q1, P1, B1 );
"**"               GENRX( XST, R, Q1, P1, B1 );
"**"             END;
"**"           AVAIL[R] := TRUE;
"**"         END
"**"       ELSE
"**"         IF DRCT AND NOT VRBL THEN
"**"           BEGIN  (* TRANSFER A CONSTANT ONTO RUNSTACK *)
"**"             VPA := ONSTK;  VRBL := TRUE;
"**"             GETQB( STE, Q1, P1, 0 );
"**"             GENSSLIT( XMVC, PLEN, Q1, P1, PCNST@ );
"**"           END
"**"         ELSE  (* SET IS SOMEWHERE IN MEMORY *)
"**"           BEGIN
"**"             GETQB( STE, Q2, P2, 0 );
"**"             TXRG := TRG1;  DRCT := TRUE;  VRBL := TRUE;
"**"             VPA := ONSTK;
"**"             GETQB( STE, Q1, P1, 0 );
"**"             TXRG := TRG14;
"**"             GENSS( XMVC, PLEN, Q1, P1, Q2, P2 );
"**"           END;
"**"   OLDCSP := PSIO;  (* INDICATE LOSS OF REG 1 *)
"**" END  (* FORCESTK *) ;
"**"
"**" PROCEDURE BSETOPS;
"**"   (* BINARY SET OPERATIONS *)
"**" VAR  L, R: DATUM;
"**"      Q1, Q2: ADRRNG;
"**"      P1, P2, B1, B2: RGRNG;
"&&"      I, J, K, MIN, STKADR: INTEGER;  LEN: PLNRNG;
"&&"      LR: BOOLEAN;  OP: BYTE;
"&&"      RNG: ARRAY[1..6] OF ADRRNG;
"**"
"**"   PROCEDURE MINCONSTSET;
"**"     LABEL 10;  VAR I, J: INTEGER;
"**"   BEGIN
"**"     J := MXSETINX * 8;
"**"     IF L.PLEN > 0 THEN
"**"       FOR I := MXSETINX DOWNTO 1 DO
"**"         BEGIN
"**"           I_S_R.S := L.PCNST@[I];
"**"           IF I_S_R.I2 = 0 THEN J := J - 4
"**"                           ELSE GOTO 10;
"**"           IF I_S_R.I1 = 0 THEN J := J - 4
"**"                           ELSE GOTO 10;
"**"         END
"**"     ELSE J := 0;
"**"   10: L.PLEN := J;
"**"     IF J = 0 THEN L.PCNST := NIL;
"**"   END (* MINCONSTSET *) ;
"**"
"&&"   PROCEDURE COMPACT( VAR S: SETRNG;  VAR LEN: PLNRNG;
"&&"                        VAR OFFSET: INTEGER; TAG: CHAR );
"**"   VAR  S_C: RECORD CASE INTEGER OF
"**"               1: ( S: SETRNG );
"**"               2: ( C: ARRAY[1..MXPLNGTH] OF CHAR );
"**"             END;
"&&"        I:   PLNRNG;
"**"   BEGIN
"**"     S_C.S := S;
"**"     WHILE (LEN>0) AND (S_C.C[LEN] = TAG) DO
"**"       LEN := LEN - 1;
"**"     OFFSET := 0;
"**"     WHILE (S_C.C[OFFSET+1] = TAG) AND (OFFSET < LEN) DO
"**"       OFFSET := OFFSET + 1;
"**"     IF OFFSET > 0 THEN
"&&"       BEGIN  LEN := LEN - OFFSET;
"&&"         FOR I := 1 TO LEN DO
"**"           S_C.C[I] := S_C.C[I+OFFSET];
"&&"         FOR I := LEN+1 TO MXPLNGTH DO
"**"           S_C.C[I] := TAG;
"**"         S := S_C.S;
"**"       END;
"**"   END  (*COMPACT*) ;
"**"
"&&"   PROCEDURE INN_OP;
"&&"   LABEL 10;
"&&"   VAR  LN, TOO_MANY: BOOLEAN;  I, J, K: INTEGER;
"&&"   BEGIN
"&&"     IF L.DTYPE <> INT THEN IF L.DTYPE <> HINT THEN ERROR( 601 );
"**"     IF R.DTYPE <> PSET THEN ERROR(615);
"**"     IF NOT L.VRBL THEN
"&&"       IF (R.PLEN*8<=L.FPA.DSPLMT) OR (L.FPA.DSPLMT < 0) THEN
"**"         BEGIN
"**"                L.FPA.LVL := 0;  L.FPA.DSPLMT := 0;
"**"         END
"**"       ELSE
"**"         IF NOT R.VRBL THEN
"**"           BEGIN  (* BOTH OPERANDS ARE CONSTANTS *)
"**"             I := L.FPA.DSPLMT MOD 64;  J := L.FPA.DSPLMT DIV 64;
"**"             L.FPA.DSPLMT := ORD(I IN R.PCNST@[J+1]);
"**"           END
"**"         ELSE
"**"           IF NOT ( R.DRCT AND (R.VPA = RGS )) THEN
"**"             BEGIN  (* LEFT OPND IS CONST, RIGHT OPND IN MEMORY *)
"**"               P1 := L.FPA.DSPLMT MOD 8;  Q1 := L.FPA.DSPLMT DIV 8;
"**"               GETQB( R, Q2, P2, Q1 );
"**"               J := 1;
"**"               FOR I := 6 DOWNTO P1 DO  J := J * 2;
"**"               GENSI( XTM, Q2+Q1, P2, J );
"&&"               BRCND := TRUCND;  L.VRBL := TRUE;
"**"             END
"**"           ELSE
"**"             BEGIN  (* LEFT OPND IS CONST, RIGHT OPND IN REGS *)
"&&"               IF R.PLEN > 4 THEN
"**"                 GENRS( XSLDL, R.RGADR, 0, L.FPA.DSPLMT, 0 )
"**"               ELSE GENRS( XSLL, R.RGADR, 0, L.FPA.DSPLMT, 0 );
"**"               GENRR( XLTR, R.RGADR, R.RGADR );
"**"               BRCND := LESCND;  L.VRBL := TRUE;
"**"             END
"**"     ELSE  (* L.VRBL *)
"**"       IF R.PLEN <= 0 THEN
"**"         BEGIN  FREEREG( L );  L.VRBL := FALSE;
"**"                L.FPA.LVL := 0;  L.FPA.DSPLMT := 0;
"**"         END
"**"       ELSE  (* R.PLEN > 0 *)
"&&"           IF NOT R.VRBL THEN
"&&"             BEGIN   (* TRY FOR BETTER CODE SEQUENCE *)
"&&"               IF NOT L.DRCT THEN LOAD(L);
"&&"               K := R.PLEN*8;  J := 0;  LN := TRUE;  TOO_MANY := FALSE;
"&&"               FOR I := 0 TO K DO
"&&"                 IF ((I MOD 64) IN R.PCNST@[I DIV 64 + 1]) AND (I < K) THEN
"&&"                   IF LN THEN
"&&"                     BEGIN  J := J + 1;
"&&"                       IF J>6 THEN BEGIN  J:=5; TOO_MANY := TRUE  END;
"&&"                            RNG[J] := I;  LN := FALSE;
"&&"                     END
"&&"                   ELSE
"&&"                 ELSE
"&&"                   IF NOT LN THEN
"&&"                     BEGIN  J := J + 1;
"&&"                            RNG[J] := I-1;  LN := TRUE;
"&&"                     END;
"&&"               IF J > 2 THEN
"&&"                 IF ((RNG[J]-RNG[1])<=50) OR TOO_MANY THEN
"&&"                   BEGIN
"&&"                     COMPACT( R.PCNST@, R.PLEN, I, CHR(0) );
"&&"                     L.FPA.DSPLMT := L.FPA.DSPLMT - I*8;
"&&"                     GOTO 10
"&&"                   END;
"&&"               K := RNG[1];
"&&"               L.FPA.DSPLMT := L.FPA.DSPLMT - K;
"&&"               LOAD(L);
"&&"               I := 1;
"&&"               WHILE I < J DO
"&&"                 BEGIN
"&&"                   IF RNG[I] > K THEN
"&&"                     GENRXLIT( XSH, L.RGADR, RNG[I]-K, -1 );
"&&"                   GENRXLIT( XCL, L.RGADR, RNG[I+1]-RNG[I], 0 );
"&&"                   K := RNG[I];  RNG[I] := PC+1;
"&&"                   I := I + 2;
"&&"                   IF I < J THEN
"&&"                 (*  IF ASM THEN WRITELN(OUTPUT,' BNH T',TESTCNT+1:1)
"&&"                     ELSE *)  GENRX( XBC, LEQCND, 0, 0, 0 );
"&&"                 END;
"&&"          (* IF ASM THEN BEGIN  TESTCNT := TESTCNT + 1;
"&&"                 WRITELN(OUTPUT,'T',TESTCNT:1,' DS 0H'); END ELSE *)
"&&"             BEGIN
"&&"               K := BASE_DSPLMT( PC );
"&&"               WHILE I > 2 DO
"&&"                 BEGIN  I := I - 2;
"&&"                        CODE.H[ RNG[I] ] := K;
"&&"                 END;
"&&"             END;
"&&"             BRCND := LEQCND;
"&&"           END  (* NOT R.VRBL *)
"&&"         ELSE
"&&"  10:      BEGIN  (* R.VRBL OR UNOPTIMIZED CASE OF ABOVE *)
"&&"             LOAD( L );
"**"         IF R.PLEN <= 8 THEN
"**"           BEGIN  (* OPERATE ON RIGHT OPND IN REGS *)
"&&"             LOAD( R );
"**"             GENRX( XLA, 0, R.PLEN*8, 0, 0 );
"**"             GENRR( XCLR, L.RGADR, 0 );
"**"             GENRELRX( XBC, GEQCND, 5 );  (* BNL *+10 *)
"&&"             IF R.PLEN > 4 THEN
"**"               BEGIN  AVAIL[R.RGADR+1] := TRUE;
"**"                 GENRS( XSLDL, R.RGADR, 0, 0, L.RGADR );
"**"               END
"**"             ELSE GENRS( XSLL, R.RGADR, 0, 0, L.RGADR );
"**"             GENRR( XLTR, R.RGADR, R.RGADR );
"**"             BRCND := LESCND;
"**"           END
"**"         ELSE
"**"           BEGIN  (* RIGHT OPERAND IN MEMORY *)
"&&"             IF R.VRBL THEN GETQB( R, Q2, P2, 0 )
"&&"             ELSE           BEGIN  P2 := 0;  Q2 := 0  END;
"**"             GENRXLIT( XCL, L.RGADR, R.PLEN*8-1, 0 );
"**"          (* IF ASM THEN
"**"               BEGIN  TESTCNT := TESTCNT + 1;
"**"                      WRITELN(OUTPUT, ' BH T',TESTCNT:1 );
"**"                   END
"**"             ELSE *)
"**"               GENRELRX( XBC, GRTCND, 12 );  (* BH *+24 *)
"**"             GENRX( XLA, TRG1, 7, 0, 0 );
"**"             GENRR( XNR, TRG1, L.RGADR );
"**"             GENRS( XSRA, L.RGADR, 0, 3, 0 );
"**"          (* IF ASM AND (NOT R.VRBL) THEN BEGIN
"**"               WRITE(OUTPUT,' LA 15,');  PRINT_SET(R.PCNST@,R.PLEN,7);
"**"               GENRX( XIC, L.RGADR, 0, L.RGADR, 15 );
"**"               CSPREGACTIVE := FALSE;
"**"             END
"**"             ELSE *)   BEGIN
"**"               GENRX( XIC, L.RGADR, Q2, L.RGADR, P2 );
"**"               IF NOT R.VRBL THEN
"**"                 UPD_SETTBL( PC-1, R.PCNST@, R.PLEN );
"**"             END;
"**"             GENRS( XSLL, L.RGADR, 0, 24, TRG1 );
"**"             GENRR( XLTR, L.RGADR, L.RGADR );
"**"          (* IF ASM THEN WRITELN(PRR,'T',TESTCNT:1,' DS 0H');  *)
"**"             BRCND := LESCND;
"**"           END;
"&&"       END (* L.VRBL *) ;
"**"     FREEREG( L );  FREEREG( R );
"**"     L.DTYPE := BOOL;
"**"   END  (* INN_OP *) ;

"**"   PROCEDURE ASE_OP ;
"**"   BEGIN
"**"     IF Q < 0 THEN  (* OPERANDS ARE IN REVERSE ORDER *)
"**"       BEGIN  L := STK[TOP];  R := STK[TOP-1];  Q := -Q  END;
"**"     IF L.DTYPE <> PSET THEN ERROR(615);
"&&"     IF R.DTYPE <> INT THEN IF R.DTYPE <> HINT THEN ERROR( 602 );
"**"     LOAD(R);
"**"     IF DEBUG THEN
"**"       BEGIN  (* CHECK THAT ELEMENT IS IN RANGE *)
"**"         GENRR( XBALR, TRG14, 0 );
"**"         GENRX( XLA, TRG1, L.PLEN*8-1, 0, 0 );
"**"         GENRR( XCLR, R.RGADR, TRG1 );
"**"         GENRX( XBC, GRTCND, SETCHK, GBR, 0 );
"**"       END;
"**"     IF L.PLEN <= 8 THEN
"**"       BEGIN  (* PRODUCE THE RESULT IN REGS *)
"**"         LOAD(L);
"**"         GENRX( XLA, TRG1, 1, 0, 0 );
"**"         GENRR( XLCR, R.RGADR, R.RGADR );
"&&"         IF L.PLEN > 4 THEN
"**"           BEGIN  GENRR( XSR, TRG0, TRG0 );
"**"             GENRS( XSLDL, TRG0, 0, 63, R.RGADR );
"**"             GENRR( XXOR, L.RGADR, TRG0 );
"**"             GENRR( XXOR, L.RGADR+1, TRG1 );
"**"           END
"**"         ELSE
"**"           BEGIN
"**"             GENRS( XSLL, TRG1, 0, 31, R.RGADR );
"**"             GENRR( XXOR, L.RGADR, TRG1 );
"**"           END;
"**"       END
"**"     ELSE
"**"       BEGIN  (* OPERATE ON SET IN MEMORY *)
"**"         FORCESTK(L);
"**"         GETQB( L, Q1, P1, 0 );
"**"         GENRX( XLA, TRG15, 7, 0, 0 );
"**"         GENRR( XNR, TRG15, R.RGADR );
"**"         GENRS( XSRL, R.RGADR, 0, 3, 0 );
"**"         GENRX( XLA, TRG1, Q1, P1, R.RGADR );
"**"         GENRX( XLA, R.RGADR, 128, 0, 0 );
"**"         GENRS( XSRL, R.RGADR, 0, 0, TRG15 );
"**"         GENRXLIT( XEX, R.RGADR,
"**"            -1778380800 (* OI 0(1),0 *), 0 );
"**"         CSPREGACTIVE := FALSE;  (* INDICATE LOSS OF REG 15 *)
"**"       END;
"**"     AVAIL[R.RGADR] := TRUE;
"**"   END  (* ASE_OP *) ;
"**"
"**" BEGIN
"**"   L := STK[TOP-1];  R := STK[TOP];
"**"   CASE OPC OF
"**"
"**"   PUNI: BEGIN
"**"     IF L.DTYPE <> PSET THEN ERROR(615);
"**"     IF R.DTYPE <> PSET THEN ERROR(615);
"**"     STKADR := L.STKADR;  LEN := L.PLEN;
"**"     IF LEN < R.PLEN THEN LEN := R.PLEN;
"**"     IF R.PLEN > 0 THEN
"**"       IF L.PLEN <= 0 THEN
"**"         IF (R.STKADR<>STKADR) AND R.VRBL AND R.DRCT
"**"             AND (R.VPA=ONSTK) THEN
"**"           BEGIN  L.VRBL := TRUE;  L.DRCT := TRUE;  L.VPA := ONSTK;
"**"             GETQB( L, Q1, P1, 0 );  TXRG := TRG1;
"**"             GETQB( R, Q2, P2, 0 );  TXRG := TRG14;
"**"             GENSS( XMVC, LEN, Q1, P1, Q2, P2 );
"**"           END
"**"         ELSE
"**"           L := R
"**"       ELSE  (* BOTH OPERANDS ARE NON-NULL *)
"**"         IF NOT L.VRBL AND NOT R.VRBL THEN  (* FOLD CONSTANTS *)
"**"           BEGIN
"**"             FOR I := 1 TO MXSETINX DO
"**"               L.PCNST@[I] := L.PCNST@[I] + R.PCNST@[I];
"**"             MINCONSTSET;
"**"           END
"**"         ELSE
"**"           IF LEN <= 8 THEN  (* PRODUCE RESULT IN REGISTERS *)
"**"             BEGIN  LR := TRUE;
"**"               IF L.PLEN < R.PLEN THEN
"**"                 BEGIN  LOAD(R);  LR := FALSE  END
"**"               ELSE IF L.PLEN > R.PLEN THEN
"**"                 LOAD(L)
"**"               ELSE  (* EQUAL LENGTH *)
"**"                 IF NOT(L.VRBL AND L.DRCT AND (L.VPA=RGS)) THEN
"**"                   IF R.VRBL AND R.DRCT AND (R.VPA=RGS) THEN
"**"                     LR := FALSE
"**"                   ELSE LOAD(L);
"**"               IF NOT LR THEN  (* INTERCHANGE OPERANDS *)
"**"                 BEGIN  L := R;  R := STK[TOP-1]  END;
"**"               IF R.VRBL THEN
"**"                 IF R.DRCT AND (R.VPA=RGS) THEN
"**"                   BEGIN  (* BOTH OPERANDS IN REGISTERS *)
"**"                     GENRR( XXOR, L.RGADR, R.RGADR );
"**"                     AVAIL[R.RGADR] := TRUE;
"&&"                     IF R.PLEN > 4 THEN
"**"                       BEGIN  GENRR( XXOR, L.RGADR+1, R.RGADR+1 );
"**"                              AVAIL[R.RGADR+1] := TRUE
"**"                       END
"**"                   END
"**"                 ELSE  (* SECOND OPERAND IN MEMORY *)
"**"                   BEGIN  GETOPERAND( R, Q2, P2, B2 );
"**"                     GENRX( XO, L.RGADR, Q2, P2, B2 );
"&&"                     IF R.PLEN > 4 THEN
"**"                       BEGIN  CHECKDISP( Q2, P2, B2 );
"**"                              GENRX( XO, L.RGADR+1, Q2+4, P2, B2 );
"**"                       END
"**"                   END
"**"               ELSE  (* SECOND OPERAND IS A CONSTANT SET *)
"**"                 BEGIN  I_S_R.S := R.PCNST@[1];
"**"                   IF I_S_R.I1 <> 0 THEN
"**"                     GENRXLIT( XO, L.RGADR, I_S_R.I1, 0 );
"&&"                   IF R.PLEN > 4 THEN
"**"                     IF I_S_R.I2 <> 0 THEN
"**"                       GENRXLIT( XO, L.RGADR+1, I_S_R.I2, 0 )
"**"                 END
"**"             END
"**"           ELSE  (* LENGTH > 8 *)
"**"             BEGIN  FORCESTK(L);
"**"               IF R.VRBL THEN
"**"                 IF R.DRCT AND (R.VPA=RGS) THEN
"**"                   BEGIN  GETQB( L, Q1, P1, 4 );
"**"                     GENRX( XO, R.RGADR, Q1, P1, 0 );
"**"                     AVAIL[R.RGADR] := TRUE;
"&&"                     IF R.PLEN > 4 THEN
"**"                       BEGIN  GENRX( XO, R.RGADR+1, Q1+4, P1, 0 );
"**"                              GENRS( XSTM, R.RGADR, R.RGADR+1, Q1, P1 );
"**"                              AVAIL[R.RGADR+1] := TRUE
"**"                       END
"**"                     ELSE GENRX( XST, R.RGADR, Q1, P1, 0 )
"**"                   END
"**"                 ELSE  (* BOTH OPERANDS IN MEMORY *)
"**"                   BEGIN  MIN := L.PLEN;
"**"                     IF MIN > R.PLEN THEN MIN := R.PLEN;
"**"                     GETQB( L, Q1, P1, MIN );
"**"                     TXRG := TRG1;  GETQB( R, Q2, P2, MIN );
"**"                     TXRG := TRG14;
"**"                     GENSS( XOC, MIN, Q1, P1, Q2, P2 );
"**"                     IF R.PLEN > L.PLEN THEN
"**"                       GENSS( XMVC, R.PLEN-L.PLEN, Q1+MIN, P1,
"**"                                     Q2+MIN, P2 )
"**"                   END
"**"               ELSE  (* SECOND OPERAND IS A CONSTANT SET *)
"**"                 BEGIN  PSVAL.S := R.PCNST@;
"&&"                   MIN := L.PLEN;  IF MIN>R.PLEN THEN MIN := R.PLEN;
"**"                   COMPACT( R.PCNST@, R.PLEN, J, CHR(0) );
"**"                   GETQB( L, Q1, P1, MIN );
"**"                   IF MIN >= J THEN
"**"                     GENSSLIT( XOC, MIN-J, Q1+J, P1, R.PCNST@ );
"**"                   IF LEN > L.PLEN THEN
"**"                     BEGIN
"**"                       FOR I := 1 TO LEN-L.PLEN DO
"**"                         PSVAL.C[I] := PSVAL.C[I+L.PLEN];
"**"                       GENSSLIT( XMVC, LEN-L.PLEN,
"**"                                  Q1+MIN, P1, PSVAL.S );
"**"                     END
"**"                 END ;
"**"             END ;
"**"     L.STKADR := STKADR;  L.PLEN := LEN;  L.DTYPE := PSET;
"**"   END  (* PUNI *) ;
"**"
"**"   PINT: BEGIN
"**"     IF L.DTYPE <> PSET THEN ERROR(615);
"**"     IF R.DTYPE <> PSET THEN ERROR(615);
"**"     STKADR := L.STKADR;  LEN := L.PLEN;
"**"     IF LEN > R.PLEN THEN LEN := R.PLEN;
"**"     IF LEN <= 0 THEN  (* ONE OR BOTH OPERANDS NULL *)
"**"       IF R.PLEN <= 0 THEN
"**"         BEGIN  FREEREG(L);  L := R  END
"**"       ELSE
"**"         FREEREG(R)
"**"     ELSE  (* BOTH OPERANDS ARE NON-NULL *)
"**"       IF NOT L.VRBL AND NOT R.VRBL THEN  (* FOLD CONSTANTS *)
"**"         BEGIN
"**"          FOR I := 1 TO MXSETINX DO
"**"            L.PCNST@[I] := L.PCNST@[I] * R.PCNST@[I];
"**"          MINCONSTSET;
"**"         END
"**"       ELSE
"**"         IF LEN <= 8 THEN  (* GENERATE RESULT IN REGISTERS *)
"**"           BEGIN  LR := TRUE;
"**"             IF L.PLEN > R.PLEN THEN
"**"               BEGIN  LOAD(R);  LR := FALSE  END
"**"             ELSE IF L.PLEN < R.PLEN THEN
"**"               LOAD(L)
"**"             ELSE  (* EQUAL LENGTH OPERANDS *)
"**"               IF NOT ( L.VRBL AND L.DRCT AND (L.VPA=RGS) ) THEN
"**"                 IF R.VRBL AND R.DRCT AND (R.VPA=RGS) THEN
"**"                   LR := FALSE
"**"                 ELSE
"**"                   LOAD(L);
"**"             IF NOT LR THEN  (* INTERCHANGE OPERANDS *)
"**"               BEGIN  L := R;  R := STK[TOP-1]  END;
"**"             IF R.VRBL THEN
"**"               IF R.DRCT AND (R.VPA=RGS) THEN
"**"                 BEGIN  (* BOTH OPERANDS ARE IN REGS *)
"**"                   GENRR( XNR, L.RGADR, R.RGADR );
"**"                   AVAIL[R.RGADR] := TRUE;
"&&"                   IF L.PLEN > 4 THEN GENRR( XNR, L.RGADR+1, R.RGADR+1 );
"&&"                   IF R.PLEN > 4 THEN AVAIL[R.RGADR+1] := TRUE;
"**"                 END
"**"               ELSE
"**"                 BEGIN  (* LEFT OPND IN REGS, RIGHT OPND IN MEMORY *)
"**"                   GETOPERAND( R, Q2, P2, B2 );
"**"                   GENRX( XN, L.RGADR, Q2, P2, B2 );
"&&"                   IF L.PLEN > 4 THEN
"**"                     BEGIN  CHECKDISP( Q2, P2, B2 );
"**"                            GENRX( XN, L.RGADR+1, Q2+4, P2, B2 )
"**"                     END
"**"                 END
"**"             ELSE
"**"               BEGIN  (* LEFT OPND IN REGS, RIGHT OPND IS CONST *)
"**"                 I_S_R.S := R.PCNST@[1];
"**"                 IF I_S_R.I1 <> -1 THEN
"**"                   IF I_S_R.I1 <> 0 THEN
"**"                      GENRXLIT( XN, L.RGADR, I_S_R.I1, 0 )
"**"                   ELSE GENRR( XSR, L.RGADR, L.RGADR );
"&&"                 IF LEN > 4 THEN GENRXLIT( XN, L.RGADR+1, I_S_R.I2, 0 )
"&&"                 ELSE IF L.PLEN > 4 THEN AVAIL[L.RGADR+1] := TRUE;
"**"               END
"**"           END
"**"       ELSE
"**"         BEGIN  (* LEN > 8 *)
"**"           FORCESTK( L );
"**"           IF R.VRBL THEN
"**"             BEGIN  (* BOTH OPERANDS IN MEMORY *)
"**"               GETQB( L, Q1, P1, 0 );
"**"               TXRG := TRG1;
"**"               GETQB( R, Q2, P2, 0 );
"**"               TXRG := TRG14;
"**"               GENSS( XNC, LEN, Q1, P1, Q2, P2 );
"**"             END
"**"           ELSE
"**"             BEGIN  (* LEFT OPND IN MEM, RIGHT OPND IS CONST *)
"**"               COMPACT( R.PCNST@, LEN, J, CHR(255) );
"**"               GETQB( L, Q1, P1, J );
"**"               LEN := ALIGN( LEN, INTSIZE );
"**"               IF LEN >= J THEN
"**"                 GENSSLIT( XNC, LEN-J, Q1+J, P1, R.PCNST@ );
"**"             END;
"**"         END;
"**"     L.STKADR := STKADR;  L.PLEN := LEN;
"**"   END  (* PINT *) ;
"**"
"**"   PDIF: BEGIN
"**"     IF L.DTYPE <> PSET THEN ERROR(615);
"**"     IF R.DTYPE <> PSET THEN ERROR(615);
"**"     IF R.PLEN > 0 THEN
"**"       IF L.PLEN <= 0 THEN
"**"         FREEREG( R )
"**"       ELSE
"**"         IF NOT L.VRBL AND NOT R.VRBL THEN  (* FOLD CONSTANTS *)
"**"           BEGIN
"**"            FOR I := 1 TO MXSETINX DO
"**"              L.PCNST@[I] := L.PCNST@[I] - R.PCNST@[I];
"**"            MINCONSTSET;
"**"          END
"**"         ELSE
"**"           IF L.PLEN <= 8 THEN
"**"             BEGIN  (* GENERATE RESULT IN REGS *)
"**"               LOAD( L );
"**"               IF R.VRBL THEN
"**"                 BEGIN
"**"                   IF NOT ( R.DRCT AND (R.VPA = RGS) ) THEN
"**"                     BEGIN  (* FORCE R INTO REGISTERS *)
"**"                       IF R.PLEN > L.PLEN THEN R.PLEN := L.PLEN;
"**"                       LOAD( R );
"**"                     END;
"**"                   GENRR( XXOR, L.RGADR, R.RGADR );
"**"                   GENRR( XXR, L.RGADR, R.RGADR );
"**"                   AVAIL[R.RGADR] := TRUE;
"&&"                   IF R.PLEN > 4 THEN
"**"                     BEGIN
"&&"                       IF L.PLEN > 4 THEN
"**"                         BEGIN
"**"                           GENRR( XXOR, L.RGADR+1, R.RGADR+1 );
"**"                           GENRR( XXR, L.RGADR+1, R.RGADR+1 );
"**"                         END;
"**"                       AVAIL[R.RGADR+1] := TRUE;
"**"                     END
"**"                 END
"**"               ELSE
"**"                 BEGIN  (* LEFT OPND IN REGS, RIGHT OPND IS CNST *)
"**"                   I_S_R.S := [0..63] - R.PCNST@[1];
"**"                   IF I_S_R.I1 <> -1 THEN
"**"                     IF I_S_R.I1 <> 0 THEN
"**"                     GENRXLIT( XN, L.RGADR, I_S_R.I1, 0 )
"**"                   ELSE GENRR( XSR, L.RGADR, L.RGADR );
"&&"                   IF (L.PLEN > 4) AND (R.PLEN > 4) THEN
"&&"                     IF I_S_R.I2 <> 0 THEN
"**"                       GENRXLIT( XN, L.RGADR+1, I_S_R.I2, 0 )
"&&"                     ELSE BEGIN  L.PLEN := 4;
"&&"                                 AVAIL(/L.RGADR+1/) := TRUE  END;
"**"                 END
"**"             END
"**"           ELSE
"**"             BEGIN  (* L.PLEN > 8 *)
"&&"               LEN := L.PLEN;  IF LEN>R.PLEN THEN LEN := R.PLEN;
"**"               IF R.VRBL THEN
"**"                 BEGIN
"**"                   FORCESTK( L );
"**"                   IF NOT( R.VRBL AND R.DRCT AND (R.VPA=MEM)) THEN
"**"                       FORCESTK( R );
"**"                   GETQB( L, Q1, P1, 0 );
"**"                   TXRG := TRG1;
"**"                   GETQB( R, Q2, P2, 0 );
"**"                   TXRG := TRG14;
"&&"                   GENSS( XOC, LEN, Q1, P1, Q2, P2 );
"&&"                   GENSS( XXC, LEN, Q1, P1, Q2, P2 );
"**"                 END
"**"               ELSE
"**"                 BEGIN  (* RIGHT OPND IS CONST *)
"**"                   FORCESTK( L );
"**"                   FOR I := 1 TO MXSETINX DO
"**"                     R.PCNST@[I] := [0..63] - R.PCNST@[I];
"&&"                   COMPACT( R.PCNST@, LEN, J, CHR(255) );
"**"                   GETQB( L, Q1, P1, J );
"&&"                   IF LEN > J THEN
"&&"                     GENSSLIT( XNC, LEN-J, Q1+J, P1, R.PCNST@ );
"**"                 END
"**"             END ;
"**"   END  (* PDIF *) ;
"**"
"&&"   PINN: INN_OP;
"**"
"**"   PASE: ASE_OP ;
"**"
"**"   END  (* CASE OPC .. *) ;
"**"   STK[TOP-1] := L;
"**"   OLDCSP := PSIO;  (* INDICATE POSSIBLE LOSS OF REG 1 *)
"**"
"**" END (* BSETOPS *) ;
"**"
"**" PROCEDURE CSETOPS;
"**"   (* CONTROL AND MISCELLANEOUS OPERATIONS ON SETS *)
"**" VAR  Q1, Q2: ADRRNG;
"**"      P1, P2, B1: RGRNG;
"**"      L, R:   DATUM;
"**"      K:      INTEGER;
"**"
"**"   PROCEDURE FORCESET( VAR STE: DATUM; LEN: INTEGER );
"**"     (* CONVERTS A SET ADDR INTO SET ON RUN STACK *)
"**"   BEGIN
"**"     WITH STE DO
"**"       IF DTYPE = ADR THEN
"**"         BEGIN
"**"           IF VRBL THEN
"**"             BEGIN
"**"               LOAD( STE );  DRCT := FALSE;
"**"             END
"**"           ELSE
"**"             BEGIN
"**"               MEMADR := FPA;  FPA := ZEROBL;
"**"               DRCT := TRUE;  VRBL := TRUE;  VPA := MEM;
"**"             END;
"**"           DTYPE := PSET;  PLEN := LEN;
"**"           STKADR := 0;  (* TO BE SET LATER *)
"**"         END
"**"       ELSE
"**"         IF DTYPE <> PSET THEN ERROR( 615 );
"**"   END  (* FORCESET *) ;
"**"
"**" BEGIN
"**"   CASE OPC OF
"**"
"**" PSLD: WITH STK[TOP-1] DO
"**"   BEGIN
"**"     FORCESET( STK[TOP-1], P );
"**"     STKADR := Q;
"**"   END (* PSLD *);
"**"
"**" PSCL: WITH STK[TOP] DO
"**"   BEGIN
"**"     DTYPE := PSET;  PLEN := P;  STKADR := Q;
"**"     VRBL := TRUE;   DRCT := TRUE;  FPA := ZEROBL;
"**"     IF PLEN = 0 THEN
"**"       BEGIN  (* THIS CASE NEVER OCCURS IN PRACTICE *)
"**"         VRBL := FALSE;  VPA := NEITHER;
"**"       END
"**"     ELSE
"**"       IF P <= 8 THEN
"**"         BEGIN  (* CLEAR REG(S) *)
"**"           VPA := RGS;
"**"           IF P = 4 THEN FINDRG ELSE FINDRP;
"**"           RGADR := NXTRG;
"**"           GENRR( XSR, RGADR, RGADR );
"&&"           IF P > 4 THEN GENRR( XSR, RGADR+1, RGADR+1 );
"**"         END
"**"       ELSE
"**"         BEGIN  (* CLEAR MEMORY ON RUN-STACK *)
"**"           VPA := ONSTK;
"**"           GETQB( STK[TOP], Q1, P1, 0 );
"**"           GENSS( XXC, PLEN, Q1, P1, Q1, P1 );
"**"         END;
"**"     TOP := TOP + 1;
"**"    END (* PSCL *) ;
"**"
"**" PCRD: WITH STK[TOP-1] DO
"**"   BEGIN
"**"     IF PLEN <= 4 THEN LOAD( STK[TOP-1] )
"**"     ELSE IF NOT VRBL OR (DRCT AND (VPA=RGS)) THEN
"**"       FORCESTK( STK[TOP-1] );
"**"     (* OPERAND = SINGLE REG. OR A MEMORY AREA *)
"**"     FINDRG;  (* REGISTER FOR RESULT *)
"**"     GENRR( XSR, NXTRG, NXTRG );
"**"     IF PLEN > 4 THEN
"**"       BEGIN  (* MEMORY OPERAND *)
"**"         GETOPERAND( STK[TOP-1], Q1, P1, B1 );
"**"         IF P1 <> TRG14 THEN  (* WE NEED AN INDEX REG. *)
"**"           BEGIN  GENRX( XLA, TRG14, Q1, P1, B1 );
"**"                  P1 := TRG14;  Q1 := 0;  B1 := 0;
"**"           END;
"**"         GENRX( XLA, TRG1, PLEN DIV 4, 0, 0 );
"**"         GENRX( XL, 0, Q1, P1, B1 );
"**"         P2 := 0;
"**"       END
"**"     ELSE
"**"       P2 := RGADR;
"**"     GENRR( XLTR, 15, P2 );
"**"     GENRELRX( XBC, EQUCND, 6 );  (* BZ *+12 *)
"**"     GENRR( XBCTR, P2, 0 );  GENRR( XNR, P2, 15 );
"**"     GENRELRX( XBCT, NXTRG, -5 );  (* BCT NXTRG,*-10 *)
"**"     IF PLEN > 4 THEN
"**"       BEGIN
"**"         GENRX( XLA, P1, 4, P1, 0 );
"**"         GENRELRX( XBCT, TRG1, -11 );  (* BCT R1,*-22 *)
"**"       END
"**"     ELSE
"**"       AVAIL[RGADR] := TRUE;
"**"     GENRR( XLPR, NXTRG, NXTRG );
"**"     DTYPE := BOOL;  DRCT := TRUE;  VRBL := TRUE;
"**"     VPA := RGS;     RGADR := NXTRG;
"**"     CSPREGACTIVE := FALSE;  (* INDICATE LOSS OF REG 15 *)
"**"   END  (* PCRD *) ;
"**"
"**" PSMV: BEGIN
"**"   TOP := TOP - 2;
"**"   IF P < 0 THEN  (* REVERSED OPERANDS *)
"**"     BEGIN  L := STK[TOP+1];  R := STK[TOP];  P := -P  END
"**"   ELSE
"**"     BEGIN  L := STK[TOP];  R := STK[TOP+1]  END;
"**"   FORCESET( R, Q );
"**"   FORCESET( L, P );
"**"   (* L = DESTINATION SET, R = SOURCE SET *)
"**"   IF R.VRBL THEN
"**"     BEGIN
"**"       IF (R.PLEN <= 8) AND (P=4) AND DEBUG THEN LOAD( R );
"**"       IF R.DRCT AND (R.VPA = RGS) THEN
"**"         IF P < R.PLEN THEN  (* R.PLEN=8, P=4 *)
"**"           BEGIN
"**"             IF DEBUG THEN
"**"               BEGIN
"**"                 GENRR( XBALR, TRG14, 0 );
"**"                 GENRR( XLTR, R.RGADR+1, R.RGADR+1 );
"**"                 GENRX( XBC, NEQCND, SETCHK, GBR, 0 );
"**"               END;
"**"             AVAIL[R.RGADR+1] := TRUE;
"**"             R.PLEN := P;
"**"           END
"**"         ELSE  (* NOTHING *)
"**"       ELSE  (* R IS IN MEMORY *)
"**"         BEGIN  TXRG := TRG1;  K := 0;
"**"           IF P < R.PLEN THEN IF DEBUG THEN K := P;
"**"           GETQB( R, Q2, P2, K );
"**"           TXRG := TRG14;
"**"           IF P < R.PLEN THEN
"**"              BEGIN
"**"                IF DEBUG THEN
"**"                  BEGIN
"**"                    GENRR( XBALR, TRG14, 0 );
"**"                    GENSS( XNC, R.PLEN-P, Q2+P, P2, Q2+P, P2 );
"**"                    GENRX( XBC, NEQCND, SETCHK, GBR, 0 );
"**"                  END;
"**"                R.PLEN := P;
"**"              END
"**"         END
"**"     END
"**"   ELSE  (* R IS A CONSTANT *)
"**"     IF R.PLEN > P THEN
"**"       BEGIN  ERROR(303);  R.PLEN := P;  END;
"**"   IF P > R.PLEN THEN
"**"     BEGIN  (* CLEAR EXCESS BYTES IN DESTINATION *)
"**"       GETQB( L, Q1, P1, R.PLEN );
"**"       GENSS( XXC, P-R.PLEN, Q1+R.PLEN, P1, Q1+R.PLEN, P1 );
"**"     END
"**"   ELSE  GETQB( L, Q1, P1, 0 );
"**"   IF R.VRBL THEN
"**"     IF R.DRCT AND (R.VPA=RGS) THEN
"&&"       IF R.PLEN > 4 THEN
"**"           GENRS( XSTM, R.RGADR, R.RGADR+1, Q1, P1 )
"**"       ELSE  (* R.PLEN = 4 *)
"**"         GENRX( XST, R.RGADR, Q1, P1, 0 )
"**"     ELSE  (* R IS IN MEMORY *)
"**"       GENSS( XMVC, R.PLEN, Q1, P1, Q2, P2 )
"**"   ELSE  (* R IS A CONSTANT SET *)
"**"     IF R.PLEN > 0 THEN
"**"       GENSSLIT( XMVC, R.PLEN, Q1, P1, R.PCNST@ );
"**"     FREEREG( L );  FREEREG( R );
"**"   END  (* PSMV *) ;
"**"
"**"   END  (* CASE OPC OF .. *) ;
"**"   OLDCSP := PSIO;  (* INDICATE LOSS OF REG 1 *)
"**" END (* CSETOPS *) ;
"**"
"**" PROCEDURE SETCOMPARE( VAR L,R: DATUM );
"**"   (* GENERATE CODE FOR SET COMPARISONS *)
"**"   VAR   Q1, Q2, FIXUPLOC: ADRRNG;
"**"         P1, P2: LVLRNG;
"**"         EQ, INTCHG, CONSTSET, TEST_PENDING: BOOLEAN;
"**"         I,MIN:  INTEGER;
"**"
"**"   PROCEDURE TESTNULL( VAR STE: DATUM;  VAR Q: ADRRNG;
"**"                       VAR P: LVLRNG;   LEN: ADRRNG   );
"**"   BEGIN
"**"     IF LEN < STE.PLEN THEN
"**"       BEGIN
"**"         GETQB( STE, Q, P, LEN );
"**"         GENSS( XNC, STE.PLEN-LEN, Q+LEN, P, Q+LEN, P );
"**"         TEST_PENDING := TRUE;
"**"         STE.PLEN := LEN;
"**"       END
"**"     ELSE
"**"       GETQB( STE, Q, P, 0 );
"**"   END  (* TESTNULL *) ;
"**"
"**"   PROCEDURE GENBRANCH;
"**"     (* GENERATES INTERMEDIATE TEST BRANCHES *)
"**"   BEGIN
"**"     IF TEST_PENDING THEN
"**"       BEGIN
"**"         TESTCNT := TESTCNT + 1;
"**"      (* IF ASM THEN
"**"           BEGIN  FIXUPLOC := 0;  WRITELN(PRR,' BNZ T',TESTCNT:1);  END
"**"         ELSE *)
"**"           BEGIN  GENRX( XBC, NEQCND, 0, 0, 0 );
"**"                  FIXUPLOC := PC - 1;
"**"           END;
"**"       END
"**"   END  (* GENBRANCH *) ;
"**"
"**"   PROCEDURE SETCONSTBOOL( B: BOOLEAN );
"**"   BEGIN  FREEREG( L );
"**"          L.FPA.LVL := 0;  L.FPA.DSPLMT := ORD(B);
"**"          L.VRBL := FALSE;  L.DRCT := TRUE;  L.VPA := NEITHER;
"**"          CONSTSET := TRUE;
"**"   END;
"**"
"**" BEGIN
"**"   CONSTSET := FALSE;  INTCHG := FALSE;  TEST_PENDING := FALSE;
"**"   FIXUPLOC := -1;
"**"   IF (OPC = PEQU) OR (OPC = PNEQ) THEN
"**"     BEGIN
"**"
"**"     REPEAT
"**"       IF INTCHG THEN
"**"         BEGIN  L := STK[TOP];  R := STK[TOP-1];  END
"**"       ELSE
"**"         BEGIN  L := STK[TOP-1];  R := STK[TOP];  END;
"**"       INTCHG := FALSE;
"**"       IF L.PLEN <= 0 THEN  (* NULL LEFT OPERAND *)
"**"         IF R.PLEN <= 0 THEN  (* NULL RIGHT OPERAND *)
"**"           SETCONSTBOOL( OPC = PEQU )
"**"         ELSE
"**"           IF R.VRBL THEN
"**"             IF R.DRCT AND (R.VPA=RGS) THEN
"**"               IF R.PLEN = 4 THEN
"**"                 GENRR( XLTR, R.RGADR, R.RGADR )
"**"               ELSE
"**"                 GENRR( XXOR, R.RGADR, R.RGADR+1 )
"**"             ELSE  (* R IS IN MEMORY *)
"**"               TESTNULL( R, Q2, P2, 0 )
"**"           ELSE  (* R IS CONSTANT *)
"**"             SETCONSTBOOL( OPC <> PEQU )
"**"       ELSE
"**"         IF L.VRBL THEN
"**"           IF L.DRCT AND (L.VPA=RGS) THEN
"**"             IF R.PLEN <= 0 THEN
"**"               INTCHG := TRUE
"**"             ELSE
"**"               IF R.VRBL THEN
"**"                 IF R.DRCT AND (R.VPA=RGS) THEN
"**"                   BEGIN
"**"                     GENRR( XXR, L.RGADR, R.RGADR );
"**"                     IF L.PLEN < R.PLEN THEN
"**"                       GENRR( XXOR, L.RGADR, R.RGADR+1 )
"**"                     ELSE
"&&"                       IF L.PLEN > 4 THEN
"**"                         BEGIN
"&&"                           IF R.PLEN > 4 THEN
"**"                             GENRR( XXR, L.RGADR+1, R.RGADR+1 );
"**"                           GENRR( XXOR, L.RGADR, L.RGADR+1 );
"**"                         END;
"**"                   END
"**"                 ELSE  (* R IS IN MEMORY *)
"**"                   BEGIN
"**"                     TESTNULL( R, Q2, P2, L.PLEN );
"**"                     GENBRANCH;
"**"                     GENRX( XX, L.RGADR, Q2, P2, 0 );
"&&"                     IF L.PLEN > 4 THEN
"**"                       BEGIN
"**"                         IF R.PLEN >= 8 THEN
"**"                           GENRX( XX, L.RGADR+1, Q2+4, P2, 0 );
"**"                         GENRR( XXOR, L.RGADR, L.RGADR+1 );
"**"                       END
"**"                   END
"**"               ELSE  (* R IS CONSTANT *)
"**"                 IF R.PLEN > L.PLEN THEN
"**"                   SETCONSTBOOL( OPC <> PEQU )
"**"                 ELSE
"**"                   BEGIN  I_S_R.S := R.PCNST@[1];
"**"                     IF I_S_R.I1 <> 0 THEN
"**"                       GENRXLIT( XX, L.RGADR, I_S_R.I1, 0 );
"&&"                     IF L.PLEN > 4 THEN
"**"                       BEGIN
"**"                         IF R.PLEN >= 8 THEN
"**"                           GENRXLIT( XX, L.RGADR+1, I_S_R.I2, 0 );
"**"                         GENRR( XXOR, L.RGADR, L.RGADR+1 );
"**"                       END
"**"                   END
"**"             ELSE  (* L IS IN MEMORY *)
"**"               IF (R.PLEN=0) OR (R.VRBL AND R.DRCT AND
"**"                                 (R.VPA=RGS)) THEN
"**"                 INTCHG := TRUE
"**"               ELSE
"**"                 IF R.VRBL THEN  (* R IS IN MEMORY *)
"**"                   BEGIN
"**"                     TESTNULL( L, Q1, P1, R.PLEN );
"**"                     TXRG := TRG1;
"**"                     TESTNULL( R, Q2, P2, L.PLEN );
"**"                     TXRG := TRG14;
"**"                     GENBRANCH;
"**"                     MIN := L.PLEN;  IF MIN>R.PLEN THEN MIN:=R.PLEN;
"**"                     GENSS( XCLC, MIN, Q1, P1, Q2, P2 );
"**"                   END
"**"                 ELSE  (* R IS CONSTANT *)
"**"                   IF L.PLEN < R.PLEN THEN
"**"                     SETCONSTBOOL( OPC <> PEQU )
"**"                   ELSE
"**"                     BEGIN
"**"                       TESTNULL( L, Q1, P1, R.PLEN );
"**"                       GENBRANCH;
"**"                       GENSSLIT( XCLC, R.PLEN, Q1, P1, R.PCNST@ );
"**"                     END
"**"          ELSE  (* L IS CONSTANT *)
"**"            IF (R.PLEN=0) OR R.VRBL THEN
"**"              INTCHG := TRUE
"**"            ELSE
"**"              BEGIN  EQ := TRUE;
"**"                FOR I := 1 TO MXSETINX DO
"**"                  IF L.PCNST@[I] <> R.PCNST@[I] THEN
"**"                    EQ := FALSE;
"**"                  SETCONSTBOOL( (OPC=PEQU) = EQ );
"**"              END;
"**"     UNTIL NOT INTCHG;
"**"   END  (* IF OPC IS PEQU OR PNEQ *)
"**"   ELSE
"**"     BEGIN  (* OPC IS PGEQ OR PLEQ *)
"**"       IF OPC = PGEQ THEN
"**"         BEGIN  L := STK[TOP];  R := STK[TOP-1]  END
"**"       ELSE
"**"         BEGIN  L := STK[TOP-1];  R := STK[TOP]  END;
"**"       OPC := PEQU;
"**"       IF L.PLEN <= 4 THEN
"**"         BEGIN  LOAD(L);
"**"           IF R.PLEN = 0 THEN
"**"             GENRR( XLTR, L.RGADR, L.RGADR )
"**"           ELSE
"**"             IF R.VRBL THEN
"**"               IF R.DRCT AND (R.VPA=RGS) THEN
"**"                 BEGIN  GENRR( XXOR, L.RGADR, R.RGADR );
"**"                        GENRR( XXR, L.RGADR, R.RGADR );
"**"                 END
"**"               ELSE
"**"                 BEGIN  GETOPERAND( R, Q1, P1, B1 );
"**"                        GENRX( XO, L.RGADR, Q1, P1, B1 );
"**"                        GENRX( XX, L.RGADR, Q1, P1, B1 );
"**"                 END
"**"             ELSE  (* R IS CONSTANT *)
"**"               BEGIN  I_S_R.S := R.PCNST@[1];
"**"                      GENRXLIT( XO, L.RGADR, I_S_R.I1, 0 );
"**"                      GENRXLIT( XX, L.RGADR, I_S_R.I1, 0 );
"**"               END
"**"         END
"**"       ELSE
"**"         BEGIN  FORCESTK( L );
"**"           TESTNULL( L, Q1, P1, R.PLEN );
"**"           IF R.PLEN > 0 THEN
"**"             BEGIN  GENBRANCH;
"**"               IF R.VRBL THEN
"**"                 IF R.DRCT AND (R.VPA=RGS) THEN
"**"                   BEGIN
"**"                     GENRX( XN, R.RGADR, Q1, P1, 0 );
"**"                     GENRX( XX, R.RGADR, Q1, P1, 0 );
"&&"                     IF R.PLEN > 4 THEN
"**"                       BEGIN
"**"                         GENRX( XN, R.RGADR+1, Q1+4, P1, 0 );
"**"                         GENRX( XX, R.RGADR+1, Q1+4, P1, 0 );
"**"                         GENRR( XXOR, R.RGADR, R.RGADR+1 );
"**"                       END
"**"                   END
"**"                 ELSE
"**"                   BEGIN  TXRG := TRG1;
"**"                     GETQB( R, Q2, P2, 0 );
"**"                     TXRG := TRG14;
"**"                     GENSS( XOC, L.PLEN, Q1, P1, Q2, P2 );
"**"                     GENSS( XXC, L.PLEN, Q1, P1, Q2, P2 );
"**"                   END
"**"             ELSE
"**"               BEGIN  (* R IS CONSTANT *)
"**"                 GENSSLIT( XOC, L.PLEN, Q1, P1, R.PCNST@ );
"**"              (* IF ASM THEN
"**"                   GENSSLIT( XXC, L.PLEN, Q1, P1, R.PCNST@ )
"**"                 ELSE *)   BEGIN  (*KLUDGE TO RE-USE SAME CONSTANT*)
"**"                    GENSS( XXC, L.PLEN, Q1, P1, 0, 0 );
"&&"                    CODE.H[PC-1] := CODE.H[PC-4];
"&&"                    NXTLIT := NXTLIT + 1;
"&&"                    LITTBL[NXTLIT].LNK := PC-1;
"**"                 END;
"**"               END
"**"         END
"**"     END
"**"   END  (* OF CODE FOR >= AND <= *);
"**"
"**"       FREEREG(L);  FREEREG(R);
"**"       L.DTYPE := BOOL;
"**"       IF NOT CONSTSET THEN
"**"         BRCND := BRMSK[OPC];
"**"       IF FIXUPLOC >= 0 THEN
"**"      (* IF ASM THEN WRITELN(OUTPUT,'T',TESTCNT:1,' DS 0H')
"**"         ELSE *)   CODE.H[FIXUPLOC] := BASE_DSPLMT( PC );
"**"   OLDCSP := PSIO;  (* INDICATE LOSS OF REG 1 *)
"&&"   TXR_CONTENTS.VALID := FALSE;
"**"
"**" END  (* SETCOMPARE *) ;


    PROCEDURE COPERATION ;

    (* CONTROL AND BRANCH INSTRUCTIONS *)
    (* ------------------------------- *)


    PROCEDURE MKLBL(VAR LBL: PLABEL; Q: ADRRNG) ;
      (* ASSUMES     0 <= Q <= 9999999 *)
      VAR  I :  1..8 ;
      BEGIN
      I  := FLDW(Q)+1 ;
      LBL.NAM := 'L       ' ;  LBL.LEN := I ;
        REPEAT
        LBL.NAM[I] := CHR( (Q MOD 10) + ORD('0') ) ;  Q := Q DIV 10 ;
        I := I-1 ;
        UNTIL Q = 0 ;
      END (* MKLBL *) ;

    PROCEDURE ADDLNP(PCDIF: BYTE);
    (* TO ADD A (SOURCE) LINE POINTER TO THE POINTER TABLE *)
    (* --------------------------------------------------- *)
    BEGIN
    IF NXTLNP < MXLNP THEN
"&&"  BEGIN  CODE.C(/MXCODE*2+NXTLNP/) := CHR(PCDIF);
             NXTLNP := NXTLNP+1 ;
      END
    END (*ADDLNP*) ;


    PROCEDURE UPDLNTBL(PCDIF : ICRNG) ;
    (* TO UPDATE LINE POINTER TABLE FOR THE RUN TIME DEBUG OPTION *)
    (* ---------------------------------------------------------- *)
      BEGIN
      IF PCDIF >= 250 THEN (* ENTER ESCAPE MODE *)
        BEGIN
        ADDLNP(254 (*ESCAPE CHAR*) ) ;
        ADDLNP(PCDIF DIV 256) ;   ADDLNP(PCDIF MOD 256) ;
        END
      ELSE
        ADDLNP(PCDIF) ;
      END ;


    PROCEDURE INIT_CSECT ;
    (* TO INITIALIZE OBJECT CODE TABLES AND POINTERS *)
    (* --------------------------------------------- *)
    VAR  I : LBLRNG ;   J : INTEGER ;
      BEGIN
      FOR I := 0 TO LBLCNT DO
        WITH LBLTBL[I] DO
"&&"      BEGIN  DEFINED := FALSE ;  LNK := 1  END ;
"&&"  NXTLIT := 0;  NXTDBL := 0;  NXTCH := 0;
"**"  IHCONF := -1;  RICONF := -1;  RHCONF := -1;
"**"  INT_GAP := -1;  HW_GAP := -1;
"&&"  POOL_SIZE := 0;  NUMLITS := 0;
"**"  DBLALN := FALSE;
"&&"  LAST_CC.LPC := 0;  TXR_CONTENTS.VALID := FALSE;
"&&"  LAST_STR.LPC := 0;  LAST_MVC.LPC := 0;
"&&"  LAST_FILE.LPC := 0;
      PRCTBL[0].NAME := LBL1.NAM ;  PRCTBL[0].LNK := 0 ; PRCTBL[1].LNK := 0 ;
"&&"  NXTPRC := 1 ;  NXTEP := PRCCNT;  CALDPTH := 0;
      PC := 0 ;  MINLBL := LBLMAP(SEGSZE.NAM);
      LASTPC := 0 ;
      J := 0 ;
      IF CURLVL = 1 THEN (*MAINBLK*)  J := HDRLNGTH ;
      GENRX(XBC,ANYCND,12+J,0,JREG) ;          (* SKIP AROUND CSECT NAME *)
      PC := 6+(J DIV 2) ;  (* PRECEEDING 'GENRX' USES THE VALUE OF 'PC' *)
"&&"  PCAFTLIT := PC;
"&&"  CODE.C(/4/) := CHR(7+J);
"&&"  FOR I := 1 TO 7 DO
"&&"    CODE.C(/I+4/) := CURPNAME(/I/);
"&&"  FOR I := 1 TO J  DO
"&&"    CODE.C(/I+11/) := PROGHDR(/I/);

      CODE.H[MXCODE] := CURPNO;  (* UNIQUE PROC NO *)
"&&"  IF DEBUG_LEV > 0 THEN
        BEGIN
          CODE.H[MXCODE+1] := LASTLN ;
"&&"      FOR I := 1 TO 12 DO
"&&"        CODE.C(/MXCODE*2+3+I/) := CURPNAME(/I/);
"&&"      NXTLNP := 16 ;
        END
      ELSE NXTLNP := 0 ;

      END (*INIT_CSECT*) ;


    PROCEDURE GEN_CSECT ;
    (* TO MERGE LITERAL POOLS AND GENERATE ONE OBJECT MODULE FOR THIS PROC *)
    (* ------------------------------------------------------------------- *)
"**"  LABEL 10;
      CONST  XESD    = 46523076   ;  (*EBCDIC FOR  2Ç'ESD' *)
             XTXT    = 48490467   ;  (*               TXT  *)
             XRLD    = 47829956   ;  (*               RLD  *)
             XEND    = 46519748   ;  (*               END  *)

             BLNK1   = 64         ;  (* EBCDIC FOR ' '     *)
             BLNK2   = 16448      ;  (*            '  '    *)
             BLNK3   = 4210752    ;  (*            '   '   *)
             BLNK4   = 1077952576 ;  (*            '    '  *)

"&&"  VAR  I, J, K   : INTEGER ;
           TPC, QPC, OBJEND : INTEGER ;
           LNGTH     : STRLRNG  ;
           VSL16     : INTEGER ;
           BLNK80    : ARRAY[1..80] OF CHAR ;
"&&"       BLNK64    : ARRAY[1..64] OF CHAR ;
           CARD      : RECORD  CASE  INTEGER OF
                       1: (C : ARRAY[1..80] OF CHAR) ;   (*CHAR CARD IMAGE*)
                       2: (I : ARRAY[1..20] OF INTEGER); (*INT. CARD IMAGE*)
"&&"                   3: (H: ARRAY(/1..40/) OF HINTEGER)  (*HALFWORD IMAGE   *)
                       END ;

"&&"       ESD_CARD  : RECORD  CASE INTEGER OF
"&&"                   1:( C16: ARRAY[1..16] OF CHAR;
"&&"                       C64: ARRAY[1..64] OF CHAR );
"&&"                   2:( I4: ARRAY[1..4] OF INTEGER;
"&&"                       ITEM: ARRAY[1..3] OF RECORD
"&&"                             XNAME: ALFA;  F1,F2: INTEGER  END );
"&&"                   3:( C80: ARRAY[1..80] OF CHAR )
"&&"                   END;
"&&"
"&&"  PROCEDURE PRNT_CSECT( LPC1: ICRNG );
"&&"    LABEL 10;
"&&"    VAR   LPC, CON1, CON2: HEX4;
"&&"          APC, APC1: ICRNG;  I, K: 0 .. 9999;
"&&"    BEGIN  (*PRNT_CSECT*)
"&&"      WRITELN(OUTPUT);
"&&"      WRITELN(OUTPUT,' OBJECT CODE FOR CSECT', PRCTBL[0].NAME:9,
"&&"        '(PROCEDURE ':13, CURPNAME, ')');
"&&"      APC := 0;  APC1 := 0;
"&&"      REPEAT
"&&"        WRITELN(OUTPUT);
"&&"        HEXHW( 2*APC, LPC );  WRITE(OUTPUT, LPC:5, ': ');
"&&"        FOR I := 0 TO 7 DO  (* 32 BYTES PER LINE *)
"&&"          BEGIN
"&&"            IF I = 4 THEN WRITE(OUTPUT,'  ');
"&&"            HEXHW( CODE.H[APC1], CON1 );  HEXHW( CODE.H[APC1+1], CON2 );
"&&"            WRITE(OUTPUT,' ',CON1,CON2);
"&&"            APC := APC + 2;  APC1 := APC1 + 2;
"&&"            IF APC1 >= LPC1 THEN GOTO 10;
"&&"          END;
"&&"      UNTIL FALSE;
"&&" 10:  K := 0;
"&&"      IF (NXTPRC > 1) OR (NXTEP < PRCCNT) THEN
"&&"        BEGIN  WRITELN(OUTPUT);  WRITELN(OUTPUT);
"&&"        WRITELN(OUTPUT,' EXTERNAL REFERENCES AND LABEL DEFINITIONS:');
"&&"        FOR I := 0 TO PRCCNT DO
"&&"          IF (I < NXTPRC) OR (I > NXTEP) THEN
"&&"            WITH PRCTBL[I] DO
"&&"              IF LNK > 0 THEN
"&&"                BEGIN  IF (K MOD 3) = 0 THEN WRITELN(OUTPUT);
"&&"                  K := K + 1;
"&&"                  HEXHW( LNK*2, CON1 );
"&&"                  WRITE(OUTPUT,CON1:5,':',NAME:9);
"&&"                  IF I < NXTPRC THEN WRITE(OUTPUT,' (ER);    ')
"&&"                  ELSE               WRITE(OUTPUT,' (LD);    ');
"&&"                END;
"&&"          WRITELN(OUTPUT);
"&&"        END
"&&"      ELSE WRITELN(OUTPUT);
"&&"      WRITELN(OUTPUT);
"&&"    END (*PRNT_CSECT*) ;
"&&"


      BEGIN  (*GEN_CSECT*)

"**"  QPC := LBLTBL[MINLBL].LNK;
"&&"  WHILE QPC > 1 DO
"**"    BEGIN  TPC := CODE.H[QPC];
"**"           UPD_INTTBL( QPC, Q );
"**"           QPC := TPC;
"**"    END;
"&&"  DUMP_LITERALS;

      (* PROCESS EXTERNAL REFERENCES  *)

      FOR I := 0 TO NXTPRC-1 DO
        WITH PRCTBL[I] DO
          IF LNK > 0 THEN
"&&"        BEGIN   TPC := LNK;
"&&"          IF FLOW_TRACE AND (NAME(/1/) <> '$') THEN LNK := -PC*2
"&&"          ELSE LNK := BASE_DSPLMT(PC);
              REPEAT
              QPC := CODE.H[TPC] ;  CODE.H[TPC] := LNK ;  TPC := QPC ;
              UNTIL TPC = 0 ;
            LNK := PC ;
"&&"        CODE.I(/PC DIV 2/) := 0;  PC := NEXTPC(2);
            END (* FOR..., IF...,  WITH... *) ;

      TPC := PC;
"&&"  IF DEBUG_LEV > 0 THEN
        BEGIN
"&&"      CODE.H[5] := PC*2;  (* PROC SIZE FIELD *)
"&&"      REPEAT ADDLNP(255) UNTIL NXTLNP MOD 4 = 0;
        END ;

      IF  NOT LARGE_PROC  THEN
"&&"    IF PC > 4096 THEN
          ERROR(609 (*SHORT PROC TOO LONG*) ) ;


      (* OUTPUT THE OBJECT CODE   *)

"&&"  FOR I := 1 TO 20 DO  CARD.I[I] := BLNK4;
"&&"  BLNK80 := CARD.C;
"&&"  PACK( BLNK80, 1, BLNK64 );

      (* OUTPUT THE 'ESD' ENTRIES *)

"&&"  IF CURLVL = 1 THEN IF NOT MUSIC THEN
"&&"    BEGIN  PRCTBL[NXTPRC].NAME := '$PASENT ';
"&&"           NXTPRC := NXTPRC + 1
"&&"    END;
"&&"  WITH ESD_CARD DO
"&&"    BEGIN  I4[1] := XESD;  I4[2] := BLNK4;  C64 := BLNK64;
"&&"      I := 0;  J := 0;  K := BLNK2*SL16 + 1;
"&&"      REPEAT   J := J + 1;
"&&"        WITH ITEM[J], PRCTBL[I] DO
"&&"          BEGIN  XNAME := NAME;
"&&"            IF I < NXTPRC THEN
"&&"              IF I = 0 THEN  (* NAME OF THIS CSECT *)
"&&"                BEGIN  F1 := 0;
"&&"                       F2 := BLNK1*SL24 + PC*2 + NXTLNP;  (*CSECT SIZE*)
"&&"                END
"&&"              ELSE           (* EXTERNAL REFERENCE *)
"&&"                BEGIN  F1 := 2*SL24;
"&&"                       F2 := BLNK4;
"&&"                END
"&&"            ELSE             (* LABEL DEFINITION *)
"&&"                BEGIN  F1 := 1*SL24 + LNK*2;
"&&"                       F2 := BLNK1*SL24 + 1;
"&&"                END
"&&"          END;
"&&"        I := I + 1;
"&&"        IF I = NXTPRC THEN I := NXTEP + 1;
"&&"        IF (J = 3) OR (I > PRCCNT) THEN
"&&"          BEGIN  I4[3] := BLNK2*SL16 + J*16;
"&&"                 I4[4] := K;
"&&"                 WRITE(PRR,C80);
"&&"                 IF I < NXTPRC THEN K := K + 3 ELSE K := BLNK4;
"&&"                 C64 := BLNK64;  J := 0
"&&"          END;
"&&"      UNTIL I > PRCCNT;
"&&"    END (* WITH ESD_CARD *) ;
"&&"  IF CURLVL = 1  THEN IF NOT MUSIC THEN NXTPRC := NXTPRC - 1;

      (* OUTPUT THE 'TXT' CARDS   *)

      CARD.I[1] := XTXT ;
"&&"  CARD.I(/2/) := BLNK1*SL24 + 0;
"&&"  CARD.I(/3/) := BLNK2*SL16 + TXTCHUNK;
"&&"  CARD.I(/4/) := BLNK2*SL16 + 01;
"&&"  TPC := MXCODE;  QPC := TPC + NXTLNP DIV 2;
"&&"  WHILE TPC < QPC DO
"&&"    BEGIN  CODE.H(/PC/) := CODE.H(/TPC/);
"&&"           PC := PC + 1;  TPC := TPC + 1;
"&&"    END;
"&&"  TPC := 0;  I := 0;  QPC := PC*2;  LNGTH := TXTCHUNK;
"&&"  WHILE TPC < QPC DO
"&&"    BEGIN
"&&"      IF (QPC - TPC) < TXTCHUNK THEN
"&&"        BEGIN  LNGTH := QPC - TPC;  CARD.H(/6/) := LNGTH;  END;
"&&"      CARD.H(/4/) := TPC;
"&&"      WRITE(PRR, CARD.C:16, CODE.TXTCARD(/I/):LNGTH, ' ':64-LNGTH);
"&&"      I := I + 1;  TPC := TPC + TXTCHUNK;
"&&"    END;

      (* OUTPUT THE 'RLD' ENTRIES *)

      CARD.C := BLNK80 ;  CARD.I[1] := XRLD ;  I := 0 ;  LNGTH := 0 ;
      REPEAT         (* SCAN OVER ALL EXTERNAL REFERENCES *)
        WITH PRCTBL[I] DO
          BEGIN   I := I+1 ;  (* I NOW BECOMES ESDID FOR THE CURRENT ENTRY *)
          IF LNK > 0 THEN     (* IMPLIES RECURSIVE CALL *)
            BEGIN
            CARD.I[LNGTH+5] := I*SL16+01 ;      (* 'P#', 'R#' FIELDS  *)
            CARD.I[LNGTH+6] := 28*SL24+LNK*2 ;  (* ADCON DISPLACEMENT *)
            LNGTH := LNGTH+2 ;
            IF (LNGTH >= 14) OR (I >= NXTPRC) THEN      (* OUTPUT THE BUFFER *)
              BEGIN  CARD.H(/6/) := LNGTH*4;  (* # OF RLD DATA BYTES *)
              WHILE LNGTH < 14 DO
"&&"            BEGIN  CARD.I(/LNGTH+5/) := BLNK4;  LNGTH := LNGTH+1  END;
              WRITE(PRR,CARD.C) ;  LNGTH := 0 ;
              END (* IF(LNGTH >... *) ;
            END (* IF LNK > 0 *) ;
          END (* WITH PRCTBL... *)
      UNTIL  I >= NXTPRC ;

      (* OUTPUT 'END' CARD *)

      CARD.C := BLNK80 ;
      CARD.I[1] := XEND ;
"&&"  IF CURLVL = 1 THEN IF NOT MUSIC THEN
"&&"     BEGIN  CARD.I(/2/) := BLNK1*SL24;  CARD.H(/8/) := NXTPRC+1  END;
"&&"  WRITE(PRR,CARD.C:32,'PASCAL:':7,DATE:11,' ':30);
"&&"  IF ASM THEN PRNT_CSECT(PC);
"&&"  IF ASMVERB THEN BEGIN
"&&"  WRITELN('****  PROC: ':17,PRCTBL[0].NAME,'; ',PROC_SIZE:1,' P-STMTS, ',
"&&"    PC*2:1,' BYTES, ',NXTPRC-1:1,' EXT. REFS., ',NUMLITS:1,' CONSTANTS, ',
"&&"    POOL_SIZE:1,' BYTES OF CONSTANTS.');  WRITELN;  END;
      TOTALBYTES := TOTALBYTES+QPC ;
10:   END (*GEN_CSECT*) ;
"&&"
"&&"  PROCEDURE DUMPCONSTBLK( CLOSE: BOOLEAN );
"&&"  VAR  CPC1, LEN, I, J: HINTEGER;  TXTNUM: 0..150;
"&&"  BEGIN
"&&"    IF CSEGSTRT = 0 THEN  (* FIRST CALL *)
"&&"      BEGIN  (* PUT OUT ESD CARD TO BEGIN CSECT *)
"&&"        WRITE(PRR, CHR(02), 'ESD      ', CHR(0), CHR(16), '  ',
"&&"              CHR(0), CHR(1), PRCTBL(/0/).NAME, CHR(0), CHR(0),
"&&"              CHR(0), CHR(0), ' ', CHR(0), CHR(0), CHR(0), ' ':48);
"&&"      END;
"&&"    CPC1 := CSEGSTRT;  TXTNUM := 0;  LEN := TXTCHUNK;
"&&"    WHILE CPC1 < CPC DO
"&&"      BEGIN
"&&"        IF (CPC-CPC1) < TXTCHUNK THEN LEN := CPC-CPC1;
"&&"        IF (LEN = TXTCHUNK) OR CLOSE THEN
"&&"          WRITE(PRR, CHR(02), 'TXT ', CHR(0), CHR(CPC1 DIV 256),
"&&"              CHR(CPC1 MOD 256), '  ', CHR(0), CHR(LEN), '  ',
"&&"              CHR(0), CHR(1), CODE.TXTCARD(/TXTNUM/):LEN, ' ':64-LEN);
"&&"        TXTNUM := TXTNUM + 1;  CPC1 := CPC1 + LEN;
"&&"      END;
"&&"    IF CLOSE THEN  (* LAST CALL, PUT OUT END CARD *)
"&&"      BEGIN
"&&"        WRITE(PRR, CHR(02), 'END', ' ':24, CHR(0), CHR(0),
"&&"              CHR(CPC1 DIV 256), CHR(CPC1 MOD 256), ' ':48);
"&&"        IF ASMVERB THEN
"&&"          BEGIN  WRITELN('****  CONSTS: ':20, PRCTBL(/0/).NAME, '; ',
"&&"                         CPC1:1, ' BYTES.');  WRITELN;
"&&"          END;
"&&"      END
"&&"    ELSE
"&&"      BEGIN
"&&"        J := CPC1 - LEN - CSEGSTRT;  CSEGSTRT := CPC1 - LEN;  I := 0;
"&&"        WHILE I < LEN DO
"&&"          BEGIN  CODE.C(/I/) := CODE.C(/J+I/);  I := I+1  END;
"&&"        CSEGLIMIT := CSEGSTRT + TXTCHUNK*145;
"&&"      END;
"&&"  END  (* DUMPCONSTBLK *) ;

"&&" PROCEDURE ENT_RET;
"&&"   BEGIN
"&&"     IF OPC = PENT THEN
          BEGIN  (* ON ENTRY TRG1 POINTS TO DATA AREA FOR THE CALLED ROUTINE *)
          CURLVL := P ;
       (* IF ASM  THEN
            BEGIN  WRITELN(OUTPUT,'  PBGN ', CURPNAME, PROGHDR:HDRLNGTH+2) ;
            WRITELN(OUTPUT,LBL1.NAM,' CSECT') ;  WRITELN(OUTPUT,' USING *,',JREG
            WRITELN(OUTPUT,' B *+12') ;   (* IN FACT GENRX(XB,15,... *)
            WRITELN(OUTPUT, ' DC AL1(7),CL7''' ,CURPNAME:7, '''') ;
            END (*IF ASM*)
          ELSE *)   INIT_CSECT ;     (*INITIALIZE NEW CSECT PARAMETERS*)

          IF CALL_HIGHER THEN
          GENRX(XL,TRG0,DISPLAY+4*CURLVL,GBR,0) ; (* TO SAVE DISPLAY[CURLVL] *)

          IF SAVERGS OR (OPNDTYPE <> PROC) THEN
            BEGIN

            IF OS_STYLE THEN
              BEGIN
              GENRS(XSTM,14,12,12,TRG1) ;(*SAVE OLD DISPLAY[CURLVL] & REGS*)
              GENRX(XST,TRG1,8,LBR,0) ; (*FORWARD CHAIN OF SAVE AREAS*)
              GENRX(XST,LBR,4,TRG1,0) ; (*DYNAMIC LINK, ALSO SAVE AREA CHAIN*)
              END
            ELSE  GENRS(XSTM,13,12,8,TRG1) ;  (* SAVE DYNAMIC LINK + REGS *);

            END
          ELSE (*JUST SAVE RETURN ADR. & PROGRAM BASE REGS*)
            BEGIN
            GENRX(XST,LBR,4,TRG1,0) ;   (* SET DYNAMIC LINK *)
            IF CALL_HIGHER THEN  GENRX(XST,TRG0,20,TRG1,0)  ;
            GENRX(XST,RTREG,12,TRG1,0) ; GENRX(XST,PBR1,60,TRG1,0) ;
            IF LARGE_PROC THEN  GENRX(XST,PBR2,64,TRG1,0) ;
            END ;

          GENRR(XLR,LBR,TRG1) ;     (*UPDATE THE 'MP'*)
          IF CALL_HIGHER THEN
          GENRX(XST,LBR,DISPLAY+4*CURLVL,GBR,0) ; (*UPDATE DISPLAY[CURLVL]*)
          GENRR(XLR,PBR1,JREG) ;  (* SET UP PROGRAM BASE REGISTERS *)
          IF LARGE_PROC THEN  GENRX(XLA,PBR2,4092,PBR1,0) ;

       (* IF ASM THEN
            BEGIN
            WRITELN(OUTPUT, ' USING ', LBL1.NAM:LBL1.LEN, ',', PBR1:2) ;
            WRITELN(OUTPUT, ' USING 4092+', LBL1.NAM:LBL1.LEN, ',', PBR2:2) ;
            WRITELN(OUTPUT,' DROP',JREG:3) ;
            END ; *)

"&&"      IF DEBUG OR MUSIC THEN
            BEGIN
            GENRR(XLR,RTREG,JREG) ;   (* SAVE CURR. LOC. FOR ERROR ROUTINE *)
            IF DATA_SIZE < 4096 THEN  GENRX(XLA,TRG1,DATA_SIZE,TRG1,0)
            ELSE  GENRXLAB(XA,TRG1,SEGSZE,-1) ;
            GENRX(XC,TRG1,NEWPTR,GBR,0) ;    (* COMPARE 'SP' AND 'NP' *)
            GENRX(XBC,GEQCND,STKCHK,GBR,0) ; (* BRANCH TO ERROR ? *)
"&&"        IF DEBUG THEN
            IF CURLVL = 1 THEN   (*ENTERING MAINBLK, CLEAR STACK/HEAP AREA*)
               BEGIN
               GENRX(XLD, FPR0, CLEARBUF, GBR, 0);   (*GET THE "CLEAR" PATTERN*)
               GENRX(XL, TRG15, NEWPTR, GBR, 0);     (*END OF HEAP*)
               GENRX(XLA, TRG1, FRSTGVAR, GBR, 0);
               GENRR(XSR, TRG15, TRG1);              (*TRG14 <-- BYTE COUNT*)
"**"           GENRS(XSRA, TRG15, 0, 3, 0);
"&&"           GENRR( XBALR, TRG14, 0 );
               GENRX(XSTD, FPR0, 0, TRG1, 0);
               GENRX(XLA, TRG1, 8, TRG1, 0);
"&&"           GENRR( XBCTR, TRG15, TRG14 );
               END;
            END ;

          CSPREGACTIVE := FALSE ;

          END
"&&"     ELSE  (* OPC = PRET *)
          BEGIN (*RESTORES DISPLAY[CURLVL] AND MP, THEN RETURNS*)
          IF DEBUG AND (CURLVL > 1) AND (DATA_SIZE >80) THEN
            (* CLEAR THE STACK FRAME  *)
            BEGIN
            GENRX(XLD, TRG0, CLEARBUF, GBR, 0) ;  (* THE PATTERN TO CLEAR MEM *)

            IF DATA_SIZE < (4096*8) THEN
              GENRX(XLA, TRG1, (DATA_SIZE-LCAFTMST) DIV 8, 0, 0)
            ELSE
              BEGIN
              GENRXLAB(XL, TRG1, SEGSZE, -1) ;
              GENRXLIT(XS, TRG1, LCAFTMST-REALSIZE, 0) ;
"**"          GENRS(XSRA, TRG1, 0, 3, 0)  (* DIVIDE BY 8 *)
              END ;

            (* TRG1 HOLDS THE # OF DOUBLE WORDS TO BE CLEARED *)

            GENRR(XSR, TRG15, TRG15) ;          (* ADDRESS/INCREMENT POINTER *)
            GENRR(XBALR, TRG14, 0) ;            (* BEGINING OF CLEAR LOOP *)
            GENRX(XSTD, FPR0, LCAFTMST, LBR, TRG15) ;
            GENRX(XLA, TRG15, REALSIZE, TRG15, 0) ;   (* POINT TO NEXT D_WORD *)
            GENRR(XBCTR, TRG1, TRG14) ;         (* REPEAT UNTIL DONE *)
            END (* IF DEBUG *) ;

          IF SAVERGS OR (OPNDTYPE <> PROC) THEN
            IF OS_STYLE THEN
              BEGIN   GENRS(XLM,14,12,12,LBR) ;   GENRX(XL,LBR,4,LBR,0)  END
            ELSE GENRS(XLM,13,12,8,LBR)    (* UPDATE ALL INCL. LOCAL BASE REG *)
          ELSE  (*RESTORE BASE REGS AND RETURN ADR. ONLY*)
            BEGIN
            IF OPNDTYPE <> PROC THEN GENRR(XLR,TRG1,LBR) ; (* FOR FUNC. RSLT. *)
            IF CALL_HIGHER THEN  GENRX(XL,TRG0,20,LBR,0)  ;
            GENRX(XL,RTREG,12,LBR,0) ;
            GENRX(XL,PBR1,60,LBR,0) ;
            IF LARGE_PROC THEN  GENRX(XL,PBR2,64,LBR,0) ;
            GENRX(XL,LBR,4,LBR,0) ;    (* RESET LOCAL PTR TO PREV ACTIV. REC. *)
            END ;

          IF CALL_HIGHER THEN  GENRX(XST,TRG0,DISPLAY+4*CURLVL,GBR,0) ;
          IF DEBUG AND (CURLVL > 1) THEN        (* CLEAR THE SAVE AREA *)
            BEGIN  I := 80 ;   IF OPNDTYPE <> PROC THEN I := 72 ;
            GENSS(XMVC, I, 0, TRG1, 80, TRG1) ;
            END ;
"&&"      IF FLOW_TRACE THEN
"&&"        BEGIN  GENRR( XLR, 0, RTREG );
"&&"          GENRX( XBAL, RTREG, TRACER, GBR, 0 );
"&&"       (* IF ASM THEN WRITELN(OUTPUT,' DC AL2(0)') ELSE *)
"&&"          CODE.H[PC] := 0;  PC := NEXTPC(1);
"&&"        END
"&&"      ELSE GENRR(XBCR,ANYCND,RTREG) ;  RELEASE(HEAPMARK) ;
"**"      IF CKMODE THEN CHECKFREEREGS;
          END
"&&"    END (* ENT_RET *) ;

      (*_________________________________________________________________*)


      BEGIN   (*COPERATION*)

        CASE OPC OF

        (* P_MACHINE PSEUDO OPS *)

"&&"    PXLB :
"&&"      BEGIN
"&&"      GENRELRX( XBC, ANYCND, 14 );  (* B *+28, SKIP OVER ENTRY CODE *)
"&&"      WITH PRCTBL[NXTEP] DO
"&&"        BEGIN  NAME := LBL1.NAM;  LNK := PC  END;
"&&"      IF NXTEP > NXTPRC THEN NXTEP := NXTEP - 1
"&&"      ELSE ERROR( 256 );  (* COLLISION OF TWO LISTS *)
"&&"      GENRR( XBALR, RTREG, 0 );  (* FORCE A BASE REG. FOR NEXT INST. *)
"&&"      GENRX( XBAL, PBR1, 6, RTREG, 0 );
"&&"      CODE.H[PC] := PC*2;  PC := NEXTPC(1);
"&&"      GENRX( XLA, PBR1, 4, RTREG, 0 );  (* CLEAR HIGH BYTE *)
"&&"      GENRX( XSH, PBR1, 4, RTREG, 0 );
"&&"      IF LARGE_PROC THEN GENRX( XLA, PBR2, 4092, PBR1, 0 )
"&&"                    ELSE GENRX( XBC, NOCND, 0, 0, 0 );
"&&"      GENRX( XL, LBR, DISPLAY+4*CURLVL, GBR, 0 );
"&&"      (* PLAB INSTR. IS NEXT ==> NO NEED TO RESET ANY FLAGS *)
"&&"      END;

        PLAB :
          BEGIN
          CASE_FLAG := FALSE ;   (* END OF BRANCH TABLE *)
       (* IF ASM THEN  WRITELN(OUTPUT,LBL1.NAM,' DS 0H')
          ELSE *)  UPD_LBLTBL(PC, LBLMAP(LBL1.NAM), TRUE (*LABEL DEFINITION*));

          CASE_FLAG := OLDOPC = PDEF ;   (* START BRANCH TABLE *)
          CSPREGACTIVE := FALSE ;
"&&"      TXR_CONTENTS.VALID := FALSE;  LAST_CC.LPC := 0;
"&&"      LAST_STR.LPC := 0;  LAST_FILE.LPC := 0;
"&&"      LAST_MVC.LPC := 0;
"**"      IF CKMODE THEN CHECKFREEREGS;
          END (*PLAB*) ;

        PLOC :
          BEGIN
          IF CURPNO >= 0 THEN
            BEGIN
         (* IF ASM THEN
              BEGIN  (* DO NOT PUT LINE # IN DANGAROUS PLACES *)
              IF NOT CASE_FLAG THEN
                 IF OLDOPC <> PDEF THEN WRITELN(OUTPUT,' LOC', Q:7)
              END
            ELSE *)
"&&"          IF DEBUG_LEV > 0 THEN  (*FILL THE ENTRIES OF LINE PTR TABLE*)
                FOR I := LASTLN TO Q-1 DO
                  BEGIN
                  UPDLNTBL(PC-LASTPC) ;
                  LASTPC := PC ;
                  END ;
            END ;
          LASTLN := Q ;
          OPC := OLDOPC ;   (* TO TREAT THIS AS A NOOP *)
          END (*PLOC*) ;

        PDEF :
          BEGIN
       (* IF ASM THEN
            BEGIN  WRITELN(OUTPUT, LBL1.NAM, ' DEF', Q:7) ;
            IF OLDOPC = PRET THEN  WRITELN(OUTPUT,' PEND') ;
            END
          ELSE *)
            IF OLDOPC = PRET THEN
"&&"          BEGIN  GEN_CSECT;  CURPNO := -1;  PC := 0  END
            ELSE (* CTR/CASE EXPRESSION RANGE, PUT BOUNDS IN 'CONSTANT' TABLE *)
"**"          UPD_INTTBL(LBLTBL[LBLMAP(LBL1.NAM)].LNK,Q) ;
          END (*DEF*) ;


        (* BRANCH/CONTROL INSTRUCTIONS *)

        PUJP :
"&&"      BEGIN
"&&"        IF FLOW_TRACE AND NOT CASE_FLAG THEN
"&&"          BEGIN  GENRX(XBAL,RTREG,TRACER,GBR,0);
"&&"            CASE_FLAG := TRUE;
"&&"         (* IF ASM THEN WRITELN(OUTPUT,' DC AL2(',LBL2.NAM:LBL2.LEN,
"&&"                         '-',PRCTBL[0].NAME,')')
"&&"            ELSE *)  UPD_LBLTBL(PC, LBLMAP(LBL2.NAM), FALSE);
"&&"            CASE_FLAG := FALSE;
"&&"            PC := NEXTPC(1);
"&&"          END
"&&"        ELSE  GENRXLAB( XBC, 15, LBL2, 0 );
"&&"      END;

"&&"    PUXJ :
"&&"      BEGIN
"&&"        IF CALL_HIGHER THEN
"&&"          BEGIN  GENRX( XL, TRG0, 20, LBR, 0 );
"&&"                 GENRX( XST, TRG0, DISPLAY+4*CURLVL, GBR, 0 );
"&&"          END;
"&&"        IF FLOW_TRACE THEN
"&&"          BEGIN  GENRXLAB( XL, TRG0, LBL2, -3 );
"&&"                 GENRX( XBAL, RTREG, TRACER, GBR, 0 );
"&&"                 CODE.H[PC] := 0;  PC := NEXTPC(1);
"&&"          END
"&&"        ELSE
"&&"          BEGIN  GENRXLAB( XL, RTREG, LBL2, -3 );
"&&"                 GENRR( XBCR, ANYCND, RTREG );
"&&"          END;
"&&"        OPC := PUJP;
"&&"      END;

        PFJP :
          BEGIN  TOP := TOP-1 ;
          IF (BRCND >= 0) AND (NOT NEG_CND) THEN   (* COND. CODE IS ALIVE *)
            BRCND := 15-BRCND
          ELSE
          WITH STK[TOP] DO
            BEGIN
            IF VRBL THEN
              BEGIN

              IF DRCT AND (VPA = MEM) THEN
                BEGIN  GETOPERAND(STK[TOP],Q1,P1,B1) ;
                IF B1 > 0 THEN  IF P1 > 0 THEN  GENRR(XAR,P1,B1)
                                ELSE  P1 := B1 ;
                GENSI(XTM,Q1,P1,1) ;
                BRCND := 8 (* BZ *) ;  IF NEG_CND THEN BRCND := 1 (* BO *) ;
                END
"@@"          ELSE IF NOT DRCT THEN
"@@"            BEGIN  GETADR(STK[TOP],Q1,P1,B1);
"@@"            IF B1>0 THEN IF P1>0 THEN GENRR(XAR,P1,B1)
"@@"                                 ELSE P1 := B1;
"@@"            GENSI(XTM,Q1,P1,1);
"@@"            BRCND := 8;  IF NEG_CND THEN BRCND := 1;
"@@"            END
              ELSE
                BEGIN  LOAD(STK[TOP]) ;
                GENRR(XLTR,RGADR,RGADR) ;
                BRCND := EQUCND ;  IF NEG_CND THEN BRCND := NEQCND ;
                END ;

              FREEREG(STK[TOP]) ;
              END
            ELSE (*NOT VRBL*)
"&&"          IF FPA.DSPLMT = 0 THEN
"&&"            BEGIN  BRCND := ANYCND;  OPC := PUJP  END
              ELSE  BRCND := NOCND ; (*DO NOT BRANCH*) ;
            IF VRBL THEN IF (VPA = RGS) THEN AVAIL[RGADR] := TRUE ;
            END (*WITH STK...*) ;

"&&"      IF BRCND <> NOCND THEN
"&&"      IF FLOW_TRACE THEN
"&&"        BEGIN  BRCND := 15 - BRCND;
"&&"          IF BRCND > 0 THEN
"&&"            GENRELRX( XBC, BRCND, 5 );  (* BC BRCND,*+10 *)
"&&"          GENRX(XBAL,RTREG,TRACER,GBR,0);
"&&"          CASE_FLAG := TRUE;
"&&"       (* IF ASM THEN
"&&"            WRITELN(OUTPUT,' DC AL2(',LBL2.NAM:LBL2.LEN,
"&&"                     '-',PRCTBL[0].NAME,')') ELSE *)
"&&"          UPD_LBLTBL( PC, LBLMAP(LBL2.NAM), FALSE );
"&&"          CASE_FLAG := FALSE;  PC := NEXTPC(1);
"&&"        END
"&&"      ELSE GENRXLAB(XBC,BRCND,LBL2,0) ;
          BRCND := -1 ;  NEG_CND := FALSE ;  (* CLEAR C.C./ NEGATE FLAGS *)
          END (*PFJP*) ;

        PXJP :
          (* LBL2   = LOWER BOUND, CASE EXPRESSION       *)
          (* LBL2+1 = UPPER BOUND,                       *)
          (* LBL2+2 = BRANCH TABLE LABEL                 *)
          (* LBL2+3 = CASE EXIT LABEL                    *)

          BEGIN  TOP := TOP-1 ;  LOAD(STK[TOP]) ;
          WITH STK[TOP] DO
            BEGIN
            Q := LBLMAP(LBL2.NAM) ;
            MKLBL(LBL1,Q+1) ;  MKLBL(LBL3,Q+3) ;
"&&"        IF FLOW_TRACE THEN
"&&"          BEGIN
"&&"            GENRXLAB( XLA, JREG, LBL3, -1 );
"&&"            GENRR( XSR, JREG, PBR1 );
"&&"            GENRXLAB( XC,RGADR,LBL1,-1);
"&&"            GENRELRX( XBC, GRTCND, 9 );  (* BH *+18 *)
"&&"            GENRXLAB( XS, RGADR, LBL2, -1 );
"&&"            GENRELRX( XBC, LESCND, 5 );  (* BM *+10 *)
"&&"            GENRR( XAR, RGADR, RGADR );
"&&"            MKLBL(LBL3,Q+2);
"&&"            GENRXLAB( XLH, JREG, LBL3, RGADR );
"&&"            GENRELRX( XSTH, JREG, 4 );  (* STH JREG,*+8 *)
"&&"            GENRX( XBAL, RTREG, TRACER, GBR, 0 );
"&&"            CODE.H[PC] := 0;  PC := NEXTPC(1);
"&&"          END
"&&"        ELSE
"&&"          BEGIN
               GENRXLAB(XC,RGADR,LBL1,-1) ;   (* CHECK AGAINST UPPER BOUND *)
               GENRXLAB(XBC,GRTCND,LBL3,0) ;  (* GO TO EXIT IF OUT OF RANGE*)
               GENRXLAB(XS,RGADR,LBL2,-1) ;   (* ELSE SUBTRACT LOWER BOUND *)
               GENRXLAB(XBC,LESCND,LBL3,0) ;  (* CASE_EXIT IF OUT OF RANGE *)
               MKLBL(LBL3,Q+2) ;
               GENRR(XAR,RGADR,RGADR) ;  (* CONV. INDEX TO TABLE OFFSET *)
               GENRXLAB(XLH,JREG,LBL3,RGADR);  GENRX(XBC,ANYCND,0,JREG,PBR1);
"&&"           END;

            AVAIL[RGADR] := TRUE ;
            END (* WITH STK[TOP] DO *) ;
          END (*PXJP*) ;

        PPOP :
          BEGIN   TOP := TOP - 1;
"&&"        FREEREG( STK[TOP] );
          END ;

"&&"    PMST :
"&&"      IF CALDPTH < MAXCALDPTH THEN
"&&"        BEGIN  CALDPTH := CALDPTH + 1;
"&&"          WITH CALSTK[CALDPTH] DO
"&&"            BEGIN  PFLEV := P;  DISPSAV := Q  END;
"&&"        END
"&&"      ELSE ERROR( 259 );

        PCUP :
          BEGIN
          CALLSUB ;
"**"      IF (OPNDTYPE <> PROC) AND (OPNDTYPE <> FORT) THEN

            WITH STK[TOP] DO
              BEGIN   VRBL := TRUE  ; DRCT := TRUE ;
              FPA := ZEROBL ; VPA := RGS ;

              CASE OPNDTYPE OF

              ADR,INT :
                BEGIN  FINDRG ;
                GENRX(XL,NXTRG,FNCRSLT,TRG1,0)
                END ;

"&&"          HINT :
"&&"            BEGIN  FINDRG;
"&&"              GENRX(XLH,NXTRG,FNCRSLT,TRG1,0);
"&&"            END;

              BOOL,CHRC :
                BEGIN  FINDRG ;
                GENRR(XSR,NXTRG,NXTRG) ;
                GENRX(XIC,NXTRG,FNCRSLT,TRG1,0) ;
                END ;

              PSET :
                ERROR(616);

              REEL :
                BEGIN  FINDFP ;  GENRX(XLD,NXTRG,FNCRSLT,TRG1,0)  END;

              FBOOL:
                BEGIN  FINDRG ;  OPNDTYPE := BOOL ;
                GENRR(XLR,NXTRG,0)    (*COPY RESULT FROM REGISTER ZERO*)
                END;

              FINT :
                BEGIN  FINDRG ;  OPNDTYPE := INT ;
                GENRR(XLR,NXTRG,0)    (*COPY RESULT FROM REGISTER ZERO*)
                END ;

              FREAL:
                BEGIN  FINDFP ;  OPNDTYPE := REEL ;
                GENRR(XLDR,NXTRG,0)    (*COPY RESULT FROM REGISTER ZERO*)
                END ;

              END (*CASE OPNDTYPE*) ;

            RGADR := NXTRG ;  DTYPE := OPNDTYPE ;  TOP := TOP+1 ;
            END (*WITH STK...*)
"**"      ELSE
"**"        IF CKMODE THEN CHECKFREEREGS;

          CSPREGACTIVE := FALSE ;  OLDCSP := PSIO ;
          END (* CUP*) ;

"&&"    PENT, PRET:  ENT_RET;

        PCSP : CALLSTNDRD ;

"&&"    PCST :   (* BEGINNING OF A CSECT OF STRUCTURED CONSTANTS *)
"&&"      BEGIN
"&&"        PRCTBL[0].NAME := LBL1.NAM;  PRCTBL[0].LNK := 0;
"&&"        FOR CPC := 0 TO 7 DO
"&&"          CODE.C(/CPC/) := LBL1.NAM(/CPC+1/);
"&&"        CPC := 8;  PC := CPC;  CSTBLK := TRUE;  CSEGSTRT := 0;
"&&"        CSEGLIMIT := TXTCHUNK*145;
"&&"      END;
"&&"
"&&"    PDFC:   (* A SIMPLE CONSTANT IN THE CONSTANTS CSECT *)
"&&"      IF CSTBLK THEN
"&&"        IF CADDR <= 32767 THEN
"&&"          BEGIN
"&&"            IF CPC > CADDR THEN ERROR(617);
"&&"            WHILE CPC < CADDR DO
"&&"              BEGIN
"&&"                IF CPC = CSEGLIMIT THEN DUMPCONSTBLK( FALSE );
"&&"                CODE.C(/CPC-CSEGSTRT/) := CHR(0);
"&&"                CPC := CPC + 1;
"&&"              END;
"&&"            PC := CADDR;  Q := PC - CSEGSTRT;
"&&"            CASE OPNDTYPE OF
"&&"
"&&"   BOOL,CHRC: BEGIN
"&&"                IF NOT (IVAL IN [0..255]) THEN ERROR(301);
"&&"                CODE.C(/Q/) := CHR(IVAL);  CPC := CPC + 1;
"&&"              END;
"&&"   HINT:      BEGIN
"&&"                IF (IVAL < -32768) OR (IVAL > 32767) THEN ERROR(301);
"&&"                IF ODD(Q) THEN ERROR(610);
"&&"                CODE.H(/Q DIV 2/) := IVAL;  CPC := CPC + 2;
"&&"              END;
"&&"   INT,ADR:   BEGIN
"&&"                IF Q MOD 4 <> 0 THEN ERROR(611);
"&&"                CODE.I(/Q DIV 4/) := IVAL; CPC := CPC + 4;
"&&"              END;
"&&"   PSET:      BEGIN  IF Q MOD 4 <> 0 THEN ERROR(611);
"&&"                Q := Q DIV 4;
"&&"                FOR P := 1 TO PSLNGTH DIV 4 DO
"&&"                  BEGIN
"&&"                    CODE.I(/Q/) := PSVAL.I(/P/);  Q := Q + 1;
"&&"                  END;
"&&"                CPC := CADDR + PSLNGTH;
"&&"              END;
"&&"   STRG:      BEGIN
"&&"                FOR P := 1 TO SLNGTH DO
"&&"                  BEGIN
"&&"                    CODE.C(/Q/) := SVAL(/P/);  Q := Q + 1;
"&&"                  END;
"&&"                CPC := CADDR + SLNGTH;
"&&"              END;
"&&"   REEL:      BEGIN
"&&"                IF Q MOD 8 <> 0 THEN ERROR(612);
"&&"                CODE.R(/Q DIV 8/) := RVAL;  CPC := CPC + 8;
"&&"              END;
"&&"            END  (*CASE*) ;
"&&"          END
"&&"        ELSE ERROR(251);
"&&"
"&&"   PEND:
"&&"     IF CSTBLK THEN
"&&"       BEGIN  IF CPC > 8 THEN DUMPCONSTBLK( TRUE );
"&&"         TOTALBYTES := TOTALBYTES + CPC;
"&&"         CSTBLK := FALSE;
"&&"       END;

        PSTP :
"NH"   (* IF ASM THEN  BEGIN  (* GENERATE ASSEMBLER END CARD *)
"NH"         WRITELN(OUTPUT,' EXTRN $PASENT');
"NH"         WRITELN(OUTPUT,' END   $PASENT');     END*) ;

        END (*CASE OPC OF*) ;
      END (*COPERATION*) ;


    PROCEDURE UOPERATION ;

    (* UNARY OPERATIONS *)

      BEGIN

        CASE OPC OF

        PFLT,PFLO :
          BEGIN
            IF OPC = PFLT THEN OPPTR := TOP - 1
              ELSE OPPTR := TOP - 2 ;
            WITH STK[OPPTR] DO
               IF VRBL THEN
               BEGIN
                  LOAD(STK[OPPTR]) ;
                  FINDFP ;
                  GENRX(XX,RGADR,FL2+4,GBR,0) ;  GENRX(XST,RGADR,FL1+4,GBR,0) ;
                  GENRX(XLD,NXTRG,FL1,GBR,0) ;  GENRX(XSD,NXTRG,FL2,GBR,0) ;
                  AVAIL[RGADR] := TRUE ;  DTYPE := REEL ;
                  RGADR := NXTRG ;
               END  (* VRBL *)
               ELSE  (* CONSTANT*)
               BEGIN
                  DTYPE := REEL ;
                  RCNST := FPA.DSPLMT ;
               END  (* CONSTANT -- WITH *)
          END  (* PFLT,PFLO *) ;

"NH"    PTRC, PRND :
          BEGIN
            LOAD(STK[ TOP-1 ]) ;
            FINDRG ;
            WITH STK[ TOP-1 ] DO
            BEGIN
"NH"          IF OPC = PRND THEN
                BEGIN
                (* TO ROUND ADD +/-0.5 AND THEN TRUNCATE *)
                GENRR( XLTDR, RGADR, RGADR );
                GENRXDLIT(XLD, TRG0, 0.5) ;  (*TRG0 <-- 0.5*)
"&&"            GENRELRX( XBC, GEQCND, 3 );  (* BNL *+6 *)
                GENRR(XLCDR, TRG0, TRG0) ;         (* TRG0 <-- -0.5 *)
                GENRR(XADR, RGADR, TRG0) ;
"NH"            END (* OPC = PRND *) ;

              GENRX(XAD,RGADR,FL4,GBR,0) ;  GENRX(XSTD,RGADR,FL3,GBR,0) ;
              GENRX(XL,NXTRG,FL3+4,GBR,0) ;
              AVAILFP[ RGADR ] := TRUE ;
"&&"          DTYPE := INT ;  FPA := ZEROBL;
              RGADR := NXTRG
            END (* WITH *)
          END  (* PTRC *) ;

        PNGR :
          WITH STK[ TOP-1 ] DO

            IF VRBL THEN
              BEGIN
              LOAD(STK[TOP-1]) ;  GENRR(XLCDR,RGADR,RGADR)
              END  (* VRBL *)
            ELSE  (* CONSTANT *)
              RCNST := -RCNST ;

        PNGI :
          WITH STK[TOP-1] DO
            IF VRBL THEN
              BEGIN  LOAD(STK[TOP-1]) ;
              GENRR(XLCR,RGADR,RGADR) ;
              END
            ELSE  FPA.DSPLMT := -FPA.DSPLMT ;

        PABI :
          WITH STK[TOP-1] DO
            IF VRBL THEN
              BEGIN  LOAD(STK[TOP-1]) ;
              GENRR(XLPR,RGADR,RGADR) ;
              END
            ELSE  FPA.DSPLMT := ABS(FPA.DSPLMT) ;

        PABR:
           WITH STK[TOP-1] DO
           BEGIN
              LOAD(STK[TOP-1]) ;
              GENRR(XLPDR,RGADR,RGADR)
           END  (* PABR *) ;

        PSQI :
          WITH STK[TOP-1] DO
          BEGIN  MDTAG := PMPI ;  LOAD(STK[TOP-1]) ;  MDTAG := PBGN ;
          GENRR(XMR,RGADR,RGADR+1) ;  AVAIL[RGADR] := TRUE ;
          RGADR := RGADR+1 ;
          END (*PSQI*) ;

        PSQR :
           WITH STK[TOP-1] DO
           BEGIN
              LOAD(STK[TOP-1]) ;
              GENRR(XMDR,RGADR,RGADR)
           END  (* PSQR *) ;

"NH"    PXPO :
"NH"      WITH STK[TOP-1] DO
"NH"      BEGIN
"NH"        FINDRG;
"NH"        IF VRBL THEN GETOPERAND(STK[TOP-1],Q1,P1,B1)
"NH"        ELSE LOAD(STK[TOP-1]);
"NH"        IF (VPA = RGS) AND DRCT THEN
"NH"          BEGIN
"NH"             GENRX(XSTD,RGADR,FL3,GBR,0);
"NH"             GENRX(XIC,NXTRG,FL3,GBR,0);
"NH"             AVAILFP[RGADR] := TRUE;
"NH"          END
"NH"        ELSE
"NH"          BEGIN
"NH"            GENRX(XIC,NXTRG,Q1,P1,B1);
"NH"            VPA := RGS;  DRCT := TRUE;
"NH"          END;
"NH"        GENRX(XLA,0,127,0,0);  GENRR(XNR,NXTRG,0);
"NH"        GENRX(XLA,0,64,0,0);   GENRR(XSR,NXTRG,0);
"NH"        RGADR := NXTRG;  DTYPE := INT;
"NH"      END (* PXPO *) ;

        PNOT :
          WITH STK[TOP-1] DO
            IF BRCND >= 0 THEN
              IF NEG_CND THEN   (* CLEAR NEGATE FLAG *)
                BEGIN  NEG_CND := FALSE ;  BRCND := -1 ;  END
              ELSE  BRCND := 15-BRCND
            ELSE (* NEGATING A BOOLEAN VLUE *)
              IF VRBL THEN  BEGIN  NEG_CND := TRUE ;  BRCND := 0  END
              ELSE
                IF  FPA.DSPLMT = 0 THEN FPA.DSPLMT := 1 ELSE FPA.DSPLMT := 0 ;

        PODD :
          WITH STK[TOP-1] DO
          BEGIN
            IF VRBL THEN
              IF DRCT AND (VPA = MEM) THEN
"&&"            BEGIN
"&&"              IF ODD(FPA.DSPLMT) THEN Q := 14 ELSE Q := 1;
"&&"              FPA.DSPLMT := 0;
                  GETOPERAND(STK[TOP-1],Q1,P1,B1) ;
                  IF B1 > 0 THEN  IF P1 > 0 THEN  GENRR(XAR,P1,B1)
                                  ELSE  P1 := B1 ;
"&&"              IF DTYPE = HINT THEN Q1 := Q1 + 1 ELSE Q1 := Q1 + 3;
                  GENSI(XTM,Q1,P1,1) ;  (* RIGHT MOST BYTE IS BEING TESTED *)
"&&"              BRCND := Q (* BO OR BNO *) ;
                END
              ELSE
              BEGIN  LOAD(STK[TOP-1]) ;  GENRXLIT(XN,RGADR,1,0)  END
            ELSE
              IF ODD(FPA.DSPLMT) THEN FPA.DSPLMT := 1 ELSE FPA.DSPLMT := 0  ;
            DTYPE := BOOL
            END (*WITH, PODD*) ;

        PINC,PDEC :
          WITH STK[TOP-1] DO
            BEGIN  IF OPC = PDEC THEN Q := -Q ;
            IF NOT DRCT THEN LOAD(STK[TOP-1]) ;
            FPA.DSPLMT := FPA.DSPLMT+Q ;
            END ;

        PCHR :
          WITH STK[TOP-1] DO
            IF DTYPE > CHRC THEN
              BEGIN  IF VRBL THEN  LOAD(STK[TOP-1]) ;  DTYPE := CHRC  END ;

        PORD :
          WITH STK[TOP-1] DO
            IF DTYPE <= CHRC THEN
              BEGIN  IF VRBL THEN  LOAD(STK[TOP-1]) ;  DTYPE := INT  END ;

        PNEW :
          BEGIN  TOP := TOP-1 ;
"&&"      GENRX(XL,TRG0,NEWPTR,GBR,0) ;  GENRXLIT(XS,TRG0,P,0) ;
"&&"      IF Q <> 4 THEN  (* MUST ALIGN TO DOUBLEWORD *)
"&&"        GENRXLIT( XN, TRG0, -8, 0 );
          GENRX(XST,TRG0,NEWPTR,GBR,0) ;
          IF NOT STK[TOP].DRCT THEN  LOAD(STK[TOP]) ;
          GETADR(STK[TOP],Q1,P1,B1) ;  GENRX(XST,TRG0,Q1,B1,P1) ;
          FREEREG(STK[TOP]) ;
"&&"      IF DEBUG OR MUSIC THEN   (* CHECK FOR STACK-HEAP INTERFERENCE *)
            BEGIN
            GENRXLAB(XS,TRG0,SEGSZE,-1) ;
            GENRR(XCR,TRG0,LBR) ;
            GENRR(XBALR,RTREG,0) ;  GENRX(XBC,LEQCND,STKCHK,GBR,0) ;
            END ;
          END (*PNEW*) ;

        PSAV :
          BEGIN  TOP := TOP-1 ;
          GENRX(XL,TRG0,NEWPTR,GBR,0) ;
          IF NOT STK[TOP].DRCT THEN  LOAD(STK[TOP]) ;
          GETADR(STK[TOP],Q1,P1,B1) ;  GENRX(XST,TRG0,Q1,B1,P1) ;
          FREEREG(STK[TOP]) ;
          END (*PSAV*) ;

        PRST :
          BEGIN  TOP := TOP-1 ;
          WITH STK[TOP] DO
            BEGIN  LOAD(STK[TOP]) ;
            IF DEBUG THEN   (* SEE IF NEW HEAP POINTER VALID *)
              BEGIN
              IF RGADR <> 2 THEN
                BEGIN  IF NOT AVAIL[2] THEN ERROR(259) ;
                GENRR(XLR,2,RGADR) ;
                END ;
              GENRX(XBAL,RTREG,PTRCHK,GBR,0) ;
              END ;
            (* CODE FOR CLEARING THE RELEASE HEAP AREA SHOULD GO HERE *)
            (* SEE RETURN SEQUENCE 'PRET' AS AN EXAMPLE.              *)
            GENRX(XST,RGADR,NEWPTR,GBR,0) ;  AVAIL[RGADR] := TRUE ;
            END ;
          END (*PRST*) ;

        PCTS :
          BEGIN   (* SET/INITIALIZE RUN TIME COUNTERS *)
          GENRXLAB(XL, 2, LBL2, -1) ;
          CSP := PCTR;
          GOTOCSP;
         END (*PCTS*) ;

        PCTI :
          BEGIN   (* INCREMENT THE COUNT OF COUNTER # 'Q' *)
          GENRX(XL, TRG1, HEAPLMT, GBR, 0) ;
          GENRX(XLA, TRG14, 1, 0, 0) ;
          Q := 4*Q+DYN2LEN ;
          IF Q > SHRTINT THEN
            BEGIN
            GENRXLIT(XA, TRG1, Q, 0) ;   Q := 0 ;
            END ;
          GENRX(XA, TRG14, Q, TRG1, 0) ;
          GENRX(XST, TRG14, Q, TRG1, 0) ;
          END (*PCTI*) ;

        END (*CASE OPC OF*) ;


      END (*UOPERATION*) ;


"&&" PROCEDURE PACK_UNPACK(VAR L,R: DATUM);
"&&"   VAR  XOPC: BYTE;
"&&"   BEGIN
"&&"     LOAD( L );  (* LOAD SOURCE ADDRESS *)
"&&"     LOAD( R );  (* LOAD DESTINATION ADDRESS *)
"&&"     IF P = 1 THEN GENRR( XSR, TRG0, TRG0 );  (*FOR BYTE INSERTIONS*)
"&&"     IF IVAL <= 0 THEN BEGIN  ERROR(619);  IVAL := 1  END;
"&&"     FINDRG;  (* REGISTER FOR LOOP COUNT *)
"&&"     GENRXLIT( XL, NXTRG, IVAL, 0 );
"&&"     GENRR( XBALR, TRG1, 0 );  OLDCSP := PSIO;
"&&"     IF P = 1 THEN XOPC := XIC
"&&"     ELSE IF P = 2 THEN XOPC := XLH
"&&"     ELSE BEGIN  XOPC := XL;  IF P<>4 THEN ERROR(619)  END;
"&&"     GENRX( XOPC, TRG0, 0, 0, L.RGADR );
"&&"     IF Q = 1 THEN XOPC := XSTC
"&&"     ELSE IF Q = 2 THEN XOPC := XSTH
"&&"     ELSE BEGIN  XOPC := XST;  IF Q<>4 THEN ERROR(619)  END;
"&&"     GENRX( XOPC, TRG0, 0, 0, R.RGADR );
"&&"     GENRX( XLA, L.RGADR, P, 0, L.RGADR );
"&&"     GENRX( XLA, R.RGADR, Q, 0, R.RGADR );
"&&"     GENRR( XBCTR, NXTRG, TRG1 );
"&&"     AVAIL(/NXTRG/) := TRUE;  AVAIL(/L.RGADR/) := TRUE;
"&&"     AVAIL(/R.RGADR/) := TRUE;
"&&"   END;

    PROCEDURE SOPERATION(VAR L, R: DATUM);
      (* SET UP FOR STRING MOVE/COMPARE OPERATIONS *)
      VAR  P1, B1, P2, B2: LVLRNG;  Q1, Q2: ADRRNG;  XOPC: BYTE;

      BEGIN
      GETADR(L,Q1,P1,B1) ;
      IF NOT L.DRCT THEN
        BEGIN  GENRX(XL,TXRG,Q1,B1,P1) ;
        Q1 := 0 ;  B1 := 0 ;  P1 := TXRG ;
        END ;
      TXRG := TRG1 ;  (*TO AVOID REASSINMENT OF THE SAME BASE REG*)
      OLDCSP := PSIO; (*INDICATES LOSS OF TRG1*)
      GETADR(R,Q2,P2,B2) ;
      IF NOT R.DRCT THEN
        BEGIN  GENRX(XL,TXRG,Q2,B2,P2) ;
        Q2 := 0 ;  B2 := 0 ;  P2 := TXRG ;
        END ;
      TXRG := TRG14  ; (*RESTORE THE OLD MIDLEVEL BASE REG*)

      IF P1 < 0 THEN  BEGIN  B1 := P1;  P1 := 0;  END;
      IF P2 < 0 THEN  BEGIN  B2 := P2;  P2 := 0;  END;

      IF Q <= 256 THEN
        BEGIN (*SHORT MOVE*)
         IF B1 > 0 THEN IF P1 > 0 THEN GENRR(XAR,P1,B1)
                        ELSE P1 := B1 ;
         IF B2 > 0 THEN IF P2 > 0 THEN GENRR(XAR,P2,B2)
                        ELSE P2 := B2 ;
         XOPC := XMVC;  IF OPC <> PMOV THEN  XOPC := XCLC;
         GENSS(XOPC,Q,Q1,P1,Q2,P2) ;
         IF B1 < 0 THEN
"&&"        BEGIN
"&&"          IF B1 = -1 THEN LITTBL[L.SCNSTNO].LNK := PC-2;
"&&"          CODE.H[PC-2] := Q1;
"&&"        END;
         IF B2 < 0 THEN
"&&"        BEGIN
"&&"          IF B2 = -1 THEN LITTBL[R.SCNSTNO].LNK := PC-1;
"&&"          CODE.H[PC-1] := Q2;
"&&"        END;
"&&"      IF OPT_FLG THEN IF XOPC = XMVC THEN
"&&"        WITH LAST_MVC DO
"&&"          BEGIN
"&&"            IF PC = (LPC+3) THEN  (* CONSECUTIVE MVC INSTS *)
"&&"              IF (CODE.H[LPC-2]+LLEN) = CODE.H[PC-2] THEN
"&&"                IF (CODE.H[LPC-1]+LLEN) = CODE.H[PC-1] THEN
"&&"                  IF (LLEN+Q) <= 256 THEN
"&&"                    BEGIN
"&&"                      CODE.H[LPC-3] :=CODE.H[LPC-3] + Q;
"&&"                      Q := Q + LLEN;  PC := LPC;
"&&"                      IF B2 = -1 THEN
"&&"                        IF R.SCNSTNO = NXTLIT-1 THEN
"&&"                           NXTLIT := NXTLIT - 1
"&&"                        ELSE
"&&"                          LITTBL[R.SCNSTNO].LNK := 0;
"&&"                    END;
"&&"             LPC := PC;  LLEN := Q;
"&&"           END  (* WITH LAST_MVC *) ;
         END (*SHORT STRING*)
      ELSE
        BEGIN

        (* THIS IS ONLY VALID FOR THE 370,    FOR THE 360 THE 'CLCL'    *)
        (* INSTR. SHOULD BE REPLACED BY AN APPROPRIATE NUMBER OF 'CLC'S *)

        IF (B1 < 0) OR (B2 < 0) THEN  ERROR(202);
        FINDRP ;  GENRX(XLA,NXTRG,Q1,B1,P1) ;  P1 := NXTRG ; B1 := NXTRG+1 ;
        FINDRP ;  GENRX(XLA,NXTRG,Q2,B2,P2) ;  P2 := NXTRG ; B2 := NXTRG+1 ;
        GENRXLIT(XL,B1,Q,0) ;  GENRR(XLR,B2,B1) ;
        XOPC := XMVCL;  IF OPC <> PMOV THEN XOPC := XCLCL;
        GENRR(XOPC,P1,P2) ;
        AVAIL[P1] := TRUE ;  AVAIL[B1] := TRUE ;
        AVAIL[P2] := TRUE ;  AVAIL[B2] := TRUE ;
        S370CNT := S370CNT+1;
        END ;

      FREEREG(L) ;  FREEREG(R) ;
      END (*SOPERATION*);


  PROCEDURE BOPERATION ;
    (* BINARY OPERATIONS *)
"&&" LABEL 10, 20, 30;
    VAR  L, R :     DATUM ;  (*LEFT AND RIGHT OPERANDS*)
         LOP, ROP : STKPTR ; (*STACK INDEX OF LEFT AND RIGHT OPERANDS*)
         LRG :      RGRNG ;  (*REGISTER HOLDING LEFT OPERAND*)
         OP1, OP2 : BYTE ;
         LR :       BOOLEAN ; (*LEFT/RIGHT INTERCHANGE FLAG*)
        Q1, Q2 : ADRRNG ;  P1, P2, B1: LVLRNG ;

    BEGIN  (*ADI,SUBI,MPI, COULD BE FURTHER OPTIMIZED*)
    (*DETERMINE WHICH OPERAND SHOULD BE USED AS LEFT HAND OPERAND ...*)
    LR := (OPC IN [PSBR,PDVR,PDVI,PMOD,PDIF,PINN])
       OR (STK[TOP-1].VRBL AND STK[TOP].DRCT)
       OR (NOT STK[TOP-1].DRCT) OR (NOT STK[TOP].VRBL) ;

10: IF LR THEN BEGIN  LOP := TOP-1 ;  ROP := TOP  END
    ELSE BEGIN LOP := TOP ;  ROP := TOP-1  END ;
    L := STK[LOP] ;  R := STK[ROP] ;

    CASE OPC OF

    PADI,PSBI :
      BEGIN
      IF NOT L.DRCT THEN LOAD(L) ;
      IF R.DRCT THEN
        IF OPC = PADI THEN
          BEGIN L.FPA.DSPLMT := L.FPA.DSPLMT+R.FPA.DSPLMT; R.FPA.DSPLMT := 0 END
        ELSE
          BEGIN L.FPA.DSPLMT := L.FPA.DSPLMT-R.FPA.DSPLMT; R.FPA.DSPLMT :=0 END;
      (*CONST<OPR>CONST AND VRBL<OPR>CONST CASES ARE COMPLETED NOW *)

      OP1 := XAR ;  OP2 := XA ;
      IF OPC = PSBI THEN  BEGIN OP1 := XSR ;  OP2 := XS  END ;
      IF R.VRBL THEN
        BEGIN  Q := L.FPA.DSPLMT ; L.FPA.DSPLMT := 0 ;  (*SAVE FPA*)
        LOAD(L);
"&&"    IF R.DTYPE <> INT THEN
"&&"      IF R.DTYPE = HINT THEN
"&&"        OP2 := OP2 - 16  (* SWITCH TO HALFWORD INSTRUCTION *)
"&&"      ELSE
"&&"        LOAD(R);
        IF R.DRCT THEN
          IF R.VPA = RGS THEN
            BEGIN  GENRR(OP1,L.RGADR,R.RGADR) ;  AVAIL[R.RGADR] := TRUE  END
          ELSE (*VPA=MEM*)
            BEGIN  Q1 := R.MEMADR.DSPLMT ; P1 := R.MEMADR.LVL ;
            BASE(Q1,P1,B1) ;  GENRX(OP2,L.RGADR,Q1,B1,P1) ;
            END
        ELSE (*NOT R.DRCT*)
          BEGIN  GETOPERAND(R,Q1,P1,B1) ;
          GENRX(OP2, L.RGADR,Q1,B1,P1) ;
          END ;
        L.FPA.DSPLMT := Q ;  (*RESTORE FPA*)
        END (*IF R.VRBL*) ;

        IF NOT LR AND (OPC = PSBI) THEN  (*THIS DOES NOT SEEM TO BE COMPLETE*)
          BEGIN  Q := -L.FPA.DSPLMT ;  L.FPA.DSPLMT := 0 ;
          IF L.VRBL THEN
            BEGIN  LOAD(L) ;
            GENRR(XLCR,L.RGADR,L.RGADR) ;
            END ;
          L.FPA.DSPLMT := Q ;
          END ;
      END (*ADI,SBI*) ;

   PMPI :
      BEGIN
      IF R.VRBL THEN
        BEGIN
"&&"      IF R.DTYPE = HINT THEN
"&&"        BEGIN
"&&"          IF (NOT R.DRCT) OR (R.VPA = MEM) THEN
"&&"            BEGIN  LOAD(L);  GETOPERAND( R, Q1, P1, B1 );
"&&"              GENRX( XMH, L.RGADR, Q1, P1, B1 );
"&&"                   GOTO 30;
"&&"            END;
"&&"        END;
          MDTAG := PMPI ;  LOAD(L) ;  MDTAG := PBGN ;
          IF R.DTYPE <> INT THEN LOAD(R) ELSE GETOPERAND(R,Q1,P1,B1) ;
          IF (NOT R.DRCT) OR (R.VPA = MEM) THEN  GENRX(XM,L.RGADR,Q1,P1,B1)
          ELSE  BEGIN GENRR(XMR,L.RGADR,R.RGADR) ;  AVAIL[R.RGADR] := TRUE ; END
        END
      ELSE (*NOT R.VRBL*)
        BEGIN  Q := 0 ;
          IF (L.DRCT) THEN
            BEGIN  Q := L.FPA.DSPLMT*R.FPA.DSPLMT ;  L.FPA.DSPLMT := 0  END
          ELSE  LOAD(L) ;
          IF L.VRBL THEN
            BEGIN
"&&"          IF (R.FPA.DSPLMT>=-32768) AND (R.FPA.DSPLMT<=32767) THEN
"&&"            R.DTYPE := HINT;
"&&"          P := POWER2(R.FPA.DSPLMT);
"&&"          IF (P<0) AND (R.DTYPE<>HINT) THEN MDTAG := PMPI;
"&&"          LOAD(L);  MDTAG := PBGN;  L.FPA.DSPLMT := Q;
"&&"          IF P < 0 THEN
"&&"            IF R.DTYPE <> HINT THEN
"&&"              GENRXLIT( XM, L.RGADR, R.FPA.DSPLMT, 0 )
"&&"            ELSE
"&&"              BEGIN
"&&"                GENRXLIT( XMH, L.RGADR, R.FPA.DSPLMT, -1 );
"&&"                GOTO 30;
"&&"              END
"&&"          ELSE
"&&"            BEGIN
"&&"              IF P > 1 THEN
"&&"                GENRS( XSLL, L.RGADR, 0, P, 0 )
"&&"              ELSE IF P > 0 THEN
"&&"                GENRR( XAR, L.RGADR, L.RGADR );
"&&"              GOTO 30;
"&&"            END;
          END (*IF L.VRBL*);
        L.FPA.DSPLMT := Q ;
        END (*ELSE ...*);

      IF L.VRBL THEN
        AVAIL[L.RGADR] := TRUE ;  L.RGADR := L.RGADR+1 ;
  30: END (*PMPI*) ;

    PDVI,PMOD :
      IF NOT L.VRBL AND NOT R.VRBL THEN  (* BOTH CONSTANTS*)
        IF R.FPA.DSPLMT = 0 THEN  ERROR(300)  (* DIVISION BY ZERO*)
        ELSE
          IF OPC = PDVI THEN
            L.FPA.DSPLMT := L.FPA.DSPLMT DIV R.FPA.DSPLMT
          ELSE  L.FPA.DSPLMT := L.FPA.DSPLMT MOD R.FPA.DSPLMT
      ELSE (* MORE COMMON CASES *)
        BEGIN  MDTAG := PDVI ;  LOAD(L) ;  MDTAG := PBGN ;
        IF R.VRBL THEN
          BEGIN
          IF R.DTYPE <> INT THEN LOAD(R) ELSE GETOPERAND(R,Q1,P1,B1) ;
          IF NOT R.DRCT OR (R.VPA = MEM) THEN GENRX(XD,L.RGADR,Q1,B1,P1)
          ELSE  BEGIN GENRR(XDR,L.RGADR,R.RGADR) ; AVAIL[R.RGADR] := TRUE END
          END (*R.VRBL*)
        ELSE  (*^R.VRBL*)
          GENRXLIT(XD,L.RGADR,R.FPA.DSPLMT,0) ;
        IF OPC = PDVI THEN
          BEGIN AVAIL[L.RGADR] := TRUE ;  L.RGADR := L.RGADR+1  END
        ELSE AVAIL[L.RGADR+1] := TRUE ;
        END (* ELSE , PDVI *) ;

    PEQU,PNEQ,PGRT,PLEQ,PLES,PGEQ :
"**"  IF OPNDTYPE = PSET THEN
"**"    SETCOMPARE(L,R)
"**"  ELSE
      BEGIN   IF NOT LR THEN OPC := INVBRM[OPC] ;

        CASE OPNDTYPE OF

"&&"    ADR,INT,HINT:
          WITH R DO
            BEGIN
            LOAD(L) ;

            IF VRBL THEN
              BEGIN
"**"          GETOPERAND(R,Q1,P1,B1) ;
"&&"          IF (NOT DRCT) OR (VPA = MEM) THEN
"&&"            IF DTYPE = HINT THEN GENRX(XCH,L.RGADR,Q1,B1,P1)
"&&"            ELSE GENRX(XC,L.RGADR,Q1,B1,P1)
              ELSE
                BEGIN  GENRR(XCR,L.RGADR,RGADR) ;  AVAIL[RGADR] := TRUE  END
              END
            ELSE (*IF NOT VRBL (I.E.CONST)*)
"&&"         BEGIN
"&&"           IF FPA.DSPLMT = 1 THEN
"&&"             IF OPC = PLES THEN  (* COMPARISON AGAINST 0 IS BETTER *)
"&&"               BEGIN  FPA.DSPLMT := 0;  OPC := PLEQ  END
"&&"             ELSE IF OPC = PGEQ THEN
"&&"               BEGIN  FPA.DSPLMT := 0;  OPC := PGRT  END;
                IF FPA.DSPLMT = 0 THEN GENRR(XLTR,L.RGADR,L.RGADR)
                ELSE
                  IF (OPNDTYPE = ADR) AND (NOT FLIPDEBUG) THEN
                    BEGIN   (* CONSTANT OF TYPE ADR = NIL ! *)
                    (* FOLLOWING VALID ONLY IF $D- IS USED *)
                    GENRR(XLTR, L.RGADR, L.RGADR) ;
                    IF OPC = PEQU THEN  OPC := PLES
                    ELSE  (* OPC = PNEQ *) OPC := PGEQ ;
                    END
                  ELSE  GENRXLIT(XC,L.RGADR,FPA.DSPLMT,0) ;
"&&"        END;

            AVAIL[L.RGADR] := TRUE ;
            END (*WITH R---ADR,INT,...*) ;

"**"    BOOL, CHRC :
"**"      WITH R DO
"**" 20:    IF L.VRBL THEN
"**"          IF (L.VPA=RGS) AND L.DRCT THEN
"**"            BEGIN
"**"              IF VRBL THEN
"**"                IF (VPA=RGS) AND DRCT THEN
"**"                  BEGIN  GENRR( XCR, L.RGADR, RGADR );
"**"                         AVAIL[RGADR] := TRUE;
"**"                  END
"**"                ELSE  BEGIN
"**"                         GETQB( R, Q1, B1, 0 );
"**"                         Q := XCLI*SL24 + B1*SL12 + Q1;
"**"                         GENRXLIT( XEX, L.RGADR, Q, 0 );
"**"                         OPC := INVBRM[OPC];
"**"                      END
"**"              ELSE
"**"                IF FPA.DSPLMT = 0 THEN
"**"                  GENRR( XLTR, L.RGADR, L.RGADR )
"**"                ELSE
"**"                  BEGIN  LOAD(R);  GOTO 20  END;
"**"            AVAIL[L.RGADR] := TRUE;
"**"          END
"**"        ELSE  (* L IS IN MEMORY *)
"**"          IF VRBL THEN
"**"            BEGIN  CLEAR_REG := FALSE;
"**"                   LOAD( STK[ROP] );
"**"                   CLEAR_REG := TRUE;
"**"                   LR := NOT LR;  GOTO 10;
"**"            END
"**"          ELSE BEGIN
"**"                 GETQB( L, Q1, B1, 0 );
"**"                 GENSI( XCLI, Q1, B1, FPA.DSPLMT );
"**"               END
"**"      ELSE  (* L IS A CONSTANT *)
"**"        IF VRBL THEN
"**"          BEGIN  LR := NOT LR;  GOTO 10  END
"**"        ELSE
"**"          BEGIN  LOAD( STK(/ROP/) );  GOTO 10  END;

        REEL :
          WITH R DO
          BEGIN
            LOAD(L) ;
            IF VRBL THEN
            BEGIN
              GETOPERAND(R,Q1,P1,B1) ;
              IF (VPA = RGS) AND DRCT THEN
              BEGIN
                GENRR(XCDR,L.RGADR,R.RGADR) ;
                AVAILFP [RGADR] := TRUE
              END  (* IF VPA = RGS *)
              ELSE  (* VPA = MEM OR NOT DRCT *)
                GENRX(XCD,L.RGADR,Q1,B1,P1)
            END  (* VRBL *)
            ELSE  (* CONSTANT *)
"&&"          IF RCNST = 0.0 THEN GENRR( XLTDR, L.RGADR, L.RGADR )
"&&"          ELSE GENRXDLIT(XCD,L.RGADR,RCNST);
            AVAILFP[L.RGADR] := TRUE ;
          END  (* WITH -- REEL *) ;

        STRG :
          BEGIN
            SOPERATION(L, R);
            OLDCSP := PSIO ;
          END (*STRG*)

        END (*CASE OPNDTYE OF*) ;

      BRCND := BRMSK[OPC] ;
      END (*PEQU,PNEQ,...*) ;

    PAND, PIOR :
      WITH R DO
        BEGIN  OP1 := XNR ;
        IF OPC = PIOR THEN OP1 := XXOR ;
        LOAD(L) ;  LOAD(R)  ;
        (*THIS CAN BE IMPROVED BY USING THE CONDITION CODE AS THE TOP ELEMENT *)
        GENRR(OP1,L.RGADR,RGADR) ;
        AVAIL[RGADR] := TRUE ;
        END (*WITH...,PAND,PIOR*) ;

    PADR,PSBR :
       BEGIN
          OP1 := XADR;   OP2 := XAD;
          IF OPC = PSBR THEN
          BEGIN OP1 := XSDR;   OP2 := XSD   END;
          LOAD(L);
          IF R.VRBL THEN
          BEGIN
             GETOPERAND(R,Q1,P1,B1) ;
             IF (R.VPA = RGS) AND R.DRCT THEN
             BEGIN
                GENRR(OP1,L.RGADR,R.RGADR);
                AVAILFP[R.RGADR] := TRUE
             END
             ELSE  (* VPA = MEM OR NOT DRCT *)
                GENRX(OP2,L.RGADR,Q1,B1,P1)
          END  (* IF R.VRBL *)
          ELSE  (* CONSTANT *)
"&&"      GENRXDLIT(OP2,L.RGADR,R.RCNST)
       END  (* PADR,PSBR *) ;

     PDVR,PMPR:
       BEGIN
         LOAD(L) ;
         OP1 := XDDR ;   OP2 := XDD ;
         IF OPC=PMPR THEN
         BEGIN OP1 := XMDR ;   OP2 := XMD    END ;
         IF R.VRBL THEN
         BEGIN
           GETOPERAND(R,Q1,P1,B1) ;
           IF (R.VPA = RGS) AND R.DRCT THEN
           BEGIN
             GENRR(OP1,L.RGADR,R.RGADR) ;
             AVAILFP [R.RGADR] := TRUE
           END  (* R.VPA = RGS *)
           ELSE  (* R.VPA = MEM OR NOT DRCT *)
             GENRX(OP2,L.RGADR,Q1,B1,P1)
         END  (*  R.VRBL  *)
         ELSE  (*  CONSTANT  *)
"&&"       GENRXDLIT(OP2,L.RGADR,R.RCNST)
       END  (* PDVR,PMDR *)   ;

    END (*CASE OPC OF*) ;

  STK[TOP-1] := L ;
  END (*BOPERATION*) ;



    (* LOAD_STOR_MOVE IOPERATIONS *)
    (* -------------------------- *)


    BEGIN (*ASMNXTINST*)

"&&" IF OLDOPC = PUJP THEN
"&&"   IF NOT CASE_FLAG THEN   (* IGNORE INACCESSIBLE INSTRUCTIONS *)
"&&"     IF NOT (OPC IN [PXLB,PEND,PCST,PLAB,PLOC,PDEF,PRET,PSTP,PENT,PCTS])
"&&"       THEN GOTO 10;
    IF BRCND >= 0 THEN
      IF NOT (OPC IN [PFJP,PNOT,PLOC]) THEN   (* XLATE COND CODE TO BOOL. VAL *)
        WITH STK[TOP-1] DO
          BEGIN
            IF NEG_CND THEN   (* JUST NEGATE TOP OF STACK *)
              BEGIN  LOAD(STK[TOP-1]) ;
"&&"            IF OPC = PAND THEN GENRR( XBCTR, RGADR, 0 )
"&&"                          ELSE GENRXLIT( XX, RGADR, 1, 0 );
"&&"          END
            ELSE  (* OTHERWISE TRANSLATE CC TO BOOLEAN *)
              BEGIN  FINDRG ;
                GENRX(XLA,NXTRG,1,0,0) ;  (*ASSUME TRUE*)
"&&"            GENRELRX( XBC, BRCND, 3 );  (* BC BRCND,*+3 *)
                GENRR(XSR,NXTRG,NXTRG) ;  (* THEN CHANGE TO FALSE IF NEEDED*)
"&&"            LAST_CC.LPC := 0;  (* THIS C.C. HAS NO MEANING *)
                 DTYPE := BOOL ;
              VRBL := TRUE ; DRCT := TRUE ;
              VPA := RGS ;  RGADR := NXTRG ;
              FPA := ZEROBL ;
              END (* TRANSLATE CC *) ;
          BRCND := -1 ;  NEG_CND := FALSE ; (* RESET C.C. FLAG TO INACTIVE *)
          END (*WITH STK[..., IF NOT (OPC IN [PFJP,... *) ;

"&&" IF NOT CASE_FLAG THEN
"&&"   IF (NXTLIT >= LITDANGER) OR (NXTDBL >= DBLDANGER) THEN
"&&"     BEGIN  (* EMPTY THE LITERAL POOL NOW *)
"&&"       GENRX( XBC, ANYCND, 0, 0, 0 );
"&&"       I := PC - 1;
"&&"       DUMP_LITERALS;
"&&"       CODE.H[I] := BASE_DSPLMT( PC );
"&&"     END;

    CASE OPC OF

    PLOD  :
      WITH STK[TOP] DO
        BEGIN
        IF OPNDTYPE IN [ADR,INT,PSET] THEN
          BEGIN  IF (Q MOD INTSIZE) <> 0 THEN  ERROR(611) ;  END
        ELSE IF OPNDTYPE = REEL THEN
          BEGIN  IF (Q MOD REALSIZE) <> 0 THEN  ERROR(612) ;  END
"&&"      ELSE IF OPNDTYPE = HINT THEN
"&&"        BEGIN  IF ODD(Q) THEN ERROR(610)  END;
        DTYPE := OPNDTYPE ;  VRBL := TRUE ;  DRCT := TRUE ;
        FPA := ZEROBL ;  VPA := MEM ;
        MEMADR.LVL :=  P ;  MEMADR.DSPLMT := Q ;
"&&"    WITH LAST_STR DO
"&&"      IF LPC = PC THEN  (* TRY TO OPTIMIZE STR/LOD PAIR *)
"&&"        IF MEMADR = STOPND THEN
"&&"          IF OPNDTYPE = STDT THEN  (* IN CASE OF VARIANT RECORDS *)
"&&"            BEGIN  VPA := RGS;  RGADR := STRG;
"&&"              IF OPNDTYPE <> REEL THEN
"&&"                BEGIN
"&&"                  IF NOT AVAIL[RGADR] THEN
"&&"                    BEGIN  FINDRG;  GENRR( XLR, NXTRG, RGADR );
"&&"                           RGADR := NXTRG;
"&&"                    END;
"&&"                  AVAIL[RGADR] := FALSE;
"&&"                END
"&&"              ELSE
"&&"                BEGIN
"&&"                  IF NOT AVAILFP[RGADR] THEN
"&&"                    BEGIN  FINDFP;  GENRR( XLDR, NXTRG, RGADR );
"&&"                           RGADR := NXTRG;
"&&"                    END;
"&&"                  AVAILFP[RGADR] := FALSE;
"&&"                END;
"&&"            END;
        TOP := TOP+1 ;
        END (*LOD,LDO*) ;

    PSTR  :
      BEGIN  TOP := TOP - 1;
      IF OPNDTYPE IN [ADR,INT,PSET] THEN
        BEGIN IF (Q MOD INTSIZE) <> 0 THEN  ERROR(611) ;  END
      ELSE IF OPNDTYPE = REEL THEN
        BEGIN  IF (Q MOD REALSIZE) <> 0 THEN  ERROR(612) ;  END
"&&"      ELSE IF OPNDTYPE = HINT THEN
"&&"        BEGIN  IF ODD(Q) THEN ERROR(610);  END;
"&&"  WITH LAST_STR DO  (* SAVE INFO ABOUT STORED VARIABLE *)
"&&"    BEGIN  STOPND.LVL := P;  STOPND.DSPLMT := Q;
"&&"           STDT := OPNDTYPE;
"&&"           STORE(TOP,FALSE);
"&&"           IF OPNDTYPE <= CHRC THEN
"&&"             LPC := 0
"&&"           ELSE
"&&"             LPC := PC;
"&&"           STRG := STK[TOP].RGADR;
"&&"    END;
      END ;

    PSTO:
      BEGIN  STORE(TOP-1,TRUE(*INDIRECT*)) ;  TOP := TOP-2  END ;

    PLDA  :
      WITH STK[TOP] DO
      BEGIN  DTYPE := ADR ;  VRBL := FALSE ;  DRCT := TRUE ;
      FPA.LVL := P ;  FPA.DSPLMT := Q ;
      TOP := TOP+1 ;
      END ;

    PLDC :
      WITH STK[TOP] DO
      BEGIN  DTYPE := OPNDTYPE ;  VRBL := FALSE ;  FPA := ZEROBL ;
      DRCT := TRUE ;

        CASE OPNDTYPE OF

        ADR:
          FPA.DSPLMT := -1 ; (*LDC NIL*)

        BOOL,CHRC,HINT,INT :
          FPA.DSPLMT :=  IVAL ;

        REEL :
"&&"       RCNST := RVAL;

        PSET :
"**"      ERROR(616);

        END (*CASE OPNDTYPE*) ;

      TOP := TOP+1 ;
      END (*LDC*) ;

    PIND :
      WITH STK[TOP-1] DO
      BEGIN  IF DTYPE <> ADR THEN  ERROR(602) ;
      IF VRBL THEN
        BEGIN  IF NOT DRCT THEN  LOAD(STK[TOP-1]) ;
        FPA.DSPLMT := FPA.DSPLMT+Q ;  DRCT := FALSE ;
        END
      ELSE
        BEGIN
        MEMADR := FPA ;  MEMADR.DSPLMT := MEMADR.DSPLMT+Q ;  FPA := ZEROBL ;
        VRBL := TRUE ;  VPA := MEM ;  DRCT := TRUE ;
        END ;

      DTYPE  := OPNDTYPE ;
      END (*PIND*) ;

    PLCA :
      WITH STK[TOP] DO
        BEGIN  DTYPE := ADR;
"**"      IF OPNDTYPE = PSET THEN
"**"        BEGIN  VRBL := FALSE;  DRCT := TRUE;  VPA := NEITHER;
"**"          FPA := ZEROBL;  STKADR := 0;  PLEN := PSLNGTH;
"**"          IF PLEN > 0 THEN
"**"            BEGIN  NEW(PCNST);  PCNST@ := PSVAL.S  END
"**"          ELSE PCNST := NIL;
"**"          DTYPE := PSET ;
"**"        END
"&&"      ELSE IF OPNDTYPE = PROC THEN
"&&"        BEGIN  FINDRG;  VRBL := TRUE;  DRCT := TRUE;  VPA := RGS;
"&&"          FPA := ZEROBL;  RGADR := NXTRG;
"&&"          GENRXLAB( XL, RGADR, LBL2, -3 );
"&&"        END
"&&"      ELSE  (* OPNDTYPE IS STRG *)
     (* IF ASM THEN
           BEGIN  FINDRG;
           VRBL := TRUE ;  DRCT := TRUE ;  FPA := ZEROBL ;
           VPA := RGS ;  RGADR := NXTRG ;
           WRITELN(OUTPUT,' LA ',NXTRG:1,',=C''',SVAL:SLNGTH,'''')
           END
        ELSE *)
"&&"      BEGIN
"&&"          IF NXTCH <= HW_GAP*2 THEN
"&&"            BEGIN  HW_GAP := -1;  RHCONF := -1;  IHCONF := -1  END;
"&&"          IF NXTCH <= INT_GAP*4 THEN
"&&"            BEGIN  INT_GAP := -1;  RICONF := -1  END;
"&&"  20:     NXTLIT := NXTLIT + 1;
"&&"          LITTBL[NXTLIT].LNK := -TOP-1;  (* REF. TO EXP. STACK *)
"&&"          SCNSTNO := NXTLIT;  FPA.LVL := -1;
"&&"          FPA.DSPLMT := NXTCH;  VRBL := FALSE;  DRCT := TRUE;
"&&"          FOR I := 1 TO SLNGTH DO
"&&"            BEGIN  IDP_POOL.C[NXTCH] := SVAL[I];
"&&"                   NXTCH := NXTCH + 1;
"&&"            END;
"&&"          I := NXTDBL*8 - NXTCH;
"&&"          WHILE I < 0 DO
"&&"            BEGIN  NXTDBL := NXTDBL + 1;  I := I + 8;  END;
"&&"          NXTINT := NXTDBL * 2;
"&&"          IF I >= 4 THEN
"&&"            BEGIN  I := I - 4;
"&&"              IF INT_GAP < 0 THEN
"&&"                BEGIN  INT_GAP := NXTINT - 1;  NXTINT := INT_GAP;
"&&"                       RICONF := NXTDBL - 1;
"&&"                END;
"&&"            END;
"&&"          IF I >= 2 THEN
"&&"            IF HW_GAP < 0 THEN
"&&"              BEGIN  HW_GAP := 2*NXTINT - 1;  RHCONF := NXTDBL - 1;
"&&"                     IHCONF := NXTINT - 1;
"&&"              END;
"&&"        END;
        TOP := TOP+1;
        END (*PLCA*) ;

    PIXA :
      BEGIN  TOP := TOP-1  ;
      WITH STK[TOP] DO
        BEGIN  IF NOT DRCT THEN  LOAD(STK[TOP]) ;
        IF NOT (DTYPE IN [ADR,HINT,INT,BOOL,CHRC]) THEN  ERROR(601) ;
        FPA.DSPLMT := FPA.DSPLMT*Q ;

        IF VRBL THEN
          BEGIN
          IF VPA = MEM THEN
            BEGIN  FINDRG ;
            P1 := MEMADR.LVL ;  Q1 := MEMADR.DSPLMT ;
            BASE(Q1,P1,B1) ;
            IF DTYPE IN [CHRC,BOOL] THEN
              BEGIN  GENRR(XSR,NXTRG,NXTRG) ;
              GENRX(XIC,NXTRG,Q1,B1,P1) ;
              END
"&&"        ELSE IF DTYPE = HINT THEN
"&&"          GENRX( XLH, NXTRG, Q1, B1, P1 )
            ELSE (*INT,ADR*)  GENRX(XL,NXTRG,Q1,B1,P1) ;
            VPA := RGS ;  RGADR := NXTRG ;
            END ;
          (* VPA IS IN A REG. NOW*)
          IF Q > HALFINT THEN  ERROR(504) ;    (* TOO LARGE FOR A HALF WORD *)
          Q2 := POWER2(Q) ;
"@@"      IF Q2 = 1 THEN GENRR(XAR,RGADR,RGADR)
"@@"      ELSE IF Q2 > 0 THEN
"**"        GENRS(XSLA,RGADR,0,Q2,0)
          ELSE  IF Q2 < 0 THEN  GENRXLIT(XMH,RGADR,Q,-2 (*=H'Q'*) ) ;
          END ;

        (* NOW ADD THE TOP TO THE SECOND TOP *)

        WITH STK[TOP-1] DO
           BEGIN
           IF NOT VRBL THEN
              IF FPA.LVL < 0 THEN  (*I.E. INDEXING THROUGH A CONSTANT STRING*)
                 LOAD(STK[TOP-1]);
           IF NOT DRCT THEN LOAD(STK[TOP-1]) ;
           END (*with stk[top-1*);

        STK[TOP-1].FPA.DSPLMT := STK[TOP-1].FPA.DSPLMT+FPA.DSPLMT ;
        FPA.DSPLMT := 0 ;

        IF VRBL AND STK[TOP-1].VRBL THEN
          IF VPA = RGS THEN
            IF STK[TOP-1].VPA = RGS THEN  (*BOTH OPERANDWS IN REGS*)
              BEGIN
              GENRR(XAR,STK[TOP-1].RGADR,RGADR) ;  AVAIL[RGADR] := TRUE
              END
            ELSE   (*TOP IN REG., 2_ND TOP IN MEMORY.*)
              BEGIN
              Q1 := STK[TOP-1].MEMADR.DSPLMT ;  P1 := STK[TOP-1].MEMADR.LVL ;
              BASE(Q1,P1,B1) ;
              GENRX(XA,RGADR,Q1,B1,P1) ;
              STK[TOP-1].VPA := RGS ;
              STK[TOP-1].RGADR := RGADR ;
              END
          ELSE (*VPA = MEM*)
            BEGIN  IF STK[TOP-1].VPA <> RGS THEN  LOAD(STK[TOP-1]) ;
            Q1 := MEMADR.DSPLMT ;  P1 := MEMADR.LVL ;
            BASE(Q1,P1,B1) ;
            GENRX(XA,STK[TOP-1].RGADR,Q1,B1,P1) ;
            END

        ELSE (*NOT (VRBL AND STK[TOP-1].VRBL) *)

          IF VRBL THEN
            BEGIN  FPA.LVL := STK[TOP-1].FPA.LVL ;
            FPA.DSPLMT := STK[TOP-1].FPA.DSPLMT ;
            DTYPE := ADR ;
            STK[TOP-1] := STK[TOP] ;
            END
        END (*WITH STK...*) ;

      END (*PIXA*) ;

"&&" PPAK :
"&&"   BEGIN  TOP := TOP - 2;
"&&"          PACK_UNPACK( STK(/TOP/), STK(/TOP+1/) );
"&&"   END;

    PMOV :
      BEGIN  TOP := TOP-2 ;
      IF Q > 0 THEN (*FORWARD MOVE*)  SOPERATION(STK[TOP], STK[TOP+1])
      ELSE
         BEGIN  (*BACKWARD MOVE*)
         Q := ABS(Q);   SOPERATION(STK[TOP+1], STK[TOP]);
         END;
      END (*PMOV*) ;


    (* CONTROL/BRANCH OPERATIONS *)

"&&" PUJP,PFJP,PXJP,PPOP,PCUP,PENT,PLOC,PXLB,PUXJ,PMST,
"&&" PRET,PCSP,PSTP,PLAB,PDEF,PDFC,PCST,PEND :  COPERATION ;

"@@" PCHK :                                     CHKOPERATION ;


    (* UNARY OPERATIONS *)

    PABI,PABR,PNGI,PNGR,PINC,PDEC,
    PNOT,PODD,PCHR,PORD,PFLO,PFLT,
    PTRC,PNEW,PSAV,PRST,PSQI,
"NH" PSQR,PCTS,PCTI,PXPO,PRND:       UOPERATION ;


    (* BINARY OPERATIONS *)

    PEQU,PNEQ,PLES,PLEQ,PGRT,PGEQ,
    PADI,PSBI,PMPI,PDVI,PMOD,PAND,
    PIOR,PADR,PSBR,PMPR,PDVR:
      BEGIN  TOP := TOP - 1;   BOPERATION  END;


"**" (* SET OPERATIONS *)
"**"
"**" PINN,PINT,PUNI,PDIF,PASE :
"**"   BEGIN  TOP := TOP - 1;  BSETOPS  END;
"**"
"**" PSCL,PCRD,PSMV,PSLD :  CSETOPS;


    END (*CASE OPC OF*) ;

  OLDOPC := OPC ;
10:  END (*ASMNXTINST*) ;


PROCEDURE SETUP ;
(* INITIALIZE GLOBAL VARIABLE/SET FLAGS ETC. *)
(* ----------------------------------------- *)

"**" (* TYPE  BLOCK_MNEM = ARRAY[0..15] OF ARRAY[1..64] OF CHAR; *)
     VAR  I: INTEGER ;
"**"    (* M:  RECORD  CASE  BOOLEAN  OF
"**"          FALSE: ( X: @MNEM_TABLE );
"**"          TRUE:  ( B: @BLOCK_MNEM );
"**"        END; *)
"&&" CONST
"&&"    PTBL: ARRAY[OPTYPE] OF BETA =
"&&"          ('CTS', 'CTI', 'LOD', 'STR', 'LDA', 'LOC', 'STO', 'LDC',
"&&"           'LAB', 'IND', 'INC', 'POP', 'CUP', 'ENT', 'RET', 'CSP',
"&&"           'IXA', 'EQU', 'NEQ', 'GEQ', 'GRT', 'LEQ', 'LES', 'UJP',
"&&"           'FJP', 'XJP', 'CHK', 'NEW', 'ADI', 'ADR', 'SBI', 'SBR',
"&&"           'SCL', 'FLT', 'FLO', 'TRC', 'NGI', 'NGR', 'SQI', 'SQR',
"&&"           'ABI', 'ABR', 'NOT', 'AND', 'IOR', 'DIF', 'INT', 'UNI',
"&&"           'INN', 'MOD', 'ODD', 'MPI', 'MPR', 'DVI', 'DVR', 'MOV',
"&&"           'LCA', 'DEC', 'STP', 'SAV', 'RST', 'CHR', 'ORD', 'DEF',
"&&"           'RND', 'CRD', 'XPO', 'BGN', 'END', 'ASE', 'SLD', 'SMV',
"&&"           'MST', 'UXJ', 'XLB', 'CST', 'DFC', 'PAK', '???' );
"&&"    CSPTBL: ARRAY[CSPTYPE] OF BETA =
"&&"         ( 'GET', 'PUT', 'RES', 'RLN', 'REW', 'WLN', 'WRS', 'ELN',
"&&"           'WRI', 'WRR', 'WRC', 'RDI', 'RDR', 'RDC', 'RDH', 'RDY',
"&&"           'RDD', 'WRD', 'WRE', 'EOL', 'EOF', 'XIT', 'RDS', 'TRP',
"&&"           'SIO', 'EIO', 'CLK', 'FDF', 'PAG', 'NUL', 'RDB', 'WRB',
"&&"           'SKP', 'LIM', 'MSG', 'EOT', 'CTR', 'TRA', '???' );

  BEGIN
"NH" EMPTY := '   ';
(*
"**"  NEW( M.B );   XTBL := M.X;
M.B@[0] :='(00)(01)(02)(03)SPM BALRBCTRBCR SSK ISK SVC (0B)(0C)(0D)MVCLCLCL';
M.B@[1] :='LPR LNR LTR LCR NR  CLR OR  XR  LR  CR  AR  SR  MR  DR  ALR SLR ';
M.B@[2] :='LPDRLNDRLTDRLCDRHDR LRDRMXR MXDRLDR CDR ADR SDR MDR DDR AWR SWR ';
M.B@[3] :='LPERLNERLTERLCERHER LRERAXR SXR LER CER AER SER MER DER AUR SUR ';
M.B@[4] :='STH LA  STC IC  EX  BAL BCT BC  LH  CH  AH  SH  MH  (4D)CVD CVB ';
M.B@[5] :='ST  (51)(52)(53)N   CL  O   X   L   C   A   S   M   D   AL  SL  ';
M.B@[6] :='STD (61)(62)(63)(64)(65)(66)MXD LD  CD  AD  SD  MD  DD  AW  SW  ';
M.B@[7] :='STE (71)(72)(73)(74)(75)(76)(77)LE  CE  AE  SE  ME  DE  AU  SU  ';
M.B@[8] :='SSM (81)LPSWDIAGWRD RDD BXH BXLESRL SLL SRA SLA SRDLSLDLSRDASLDA';
M.B@[9] :='STM TM  MVI TS  NI  CLI OI  XI  LM  (99)(9A)(9B)SIO TIO HIO TCH ';
M.B@[11]:='(B0)LRA STCK(B3)(B4)(B5)STCTLCTL(B8)(B9)(BA)(BB)(BC)CLM STCMICM ';
M.B@[13]:='(D0)MVN MVC MVZ NC  CLC OC  XC  (D8)(D9)(DA)(DB)TR  TRT ED  EDMK';
M.B@[15]:='SRP MVO PACKUNPK(F4)(F5)(F6)(F7)ZAP CP  AP  SP  MP  DP  (FE)(FF)';
*)

  BRMSK[PEQU] :=  8      ;    BRMSK[PNEQ] :=  7      ;
  BRMSK[PGEQ] := 11      ;    BRMSK[PGRT] :=  2      ;
  BRMSK[PLEQ] := 13      ;    BRMSK[PLES] :=  4      ;

  INVBRM[PEQU]:= PEQU    ;    INVBRM[PNEQ]:= PNEQ    ;
  INVBRM[PGEQ]:= PLEQ    ;    INVBRM[PGRT]:= PLES    ;
  INVBRM[PLEQ]:= PGEQ    ;    INVBRM[PLES]:= PGRT    ;


  FOR I := 0 TO HTSIZE DO  HTBL[I].NAME := EMPTY ;

  OP_SP := TRUE ;
"&&"  FOR OPC := PCTS TO PRED(UNDEF_OP) DO
"&&"    BEGIN NMCDE := PTBL[OPC]; ENTERLOOKUP  END;
      OP_SP := FALSE ;
"&&"  FOR CSP := PGET TO PRED(UNDEF_CSP) DO
"&&"    BEGIN NMCDE := CSPTBL[CSP];  ENTERLOOKUP  END;
      OP_SP := TRUE ;               (*TO PREPARE FOR OPCODE LOOKUP*)

  FOR NXTRG := 0 TO RGCNT DO AVAIL[NXTRG] := TRUE ;

  FOR NXTRG := 0 TO FPCNT DO AVAILFP[NXTRG] := TRUE ;

  FOR CH := 'A' TO 'Z' DO TYPCDE[CH] := NON ;

  TYPCDE['A'] := ADR ;  TYPCDE['B'] := BOOL ;
  TYPCDE['C'] := CHRC;  TYPCDE['I'] := INT ;
"&&"                    TYPCDE['H'] := HINT ;
  TYPCDE['M'] := STRG;  TYPCDE['S'] := PSET;
  TYPCDE['P'] := PROC;  TYPCDE['R'] := REEL;
  TYPCDE['N'] := ADR ;  TYPCDE['J'] := INX ;
  TYPCDE['F'] := FORT;  TYPCDE['X'] := FBOOL;
  TYPCDE['Y'] := FINT;  TYPCDE['Z'] := FREAL;

  TOP := 1 ;  CURLVL := 1 ;  BRCND := -1 ;  NEG_CND := FALSE ;  TRACE := FALSE ;
  OLDOPC := PBGN ;  OLDCSP := PSIO ;  MDTAG := PBGN ;
"&&" TXRG := TRG14 ;  MUSIC := FALSE;
  ZEROBL.LVL := 0 ;  ZEROBL.DSPLMT := 0 ;  ERRORCNT := 0 ;  S370CNT := 0 ;
  LCAFTSAREA := LCAFTMST ;  SAVERGS := TRUE ; SAVEFPRS := TRUE ;
  CLEAR_REG := TRUE ;  PRE_PASS := TRUE ; OS_STYLE := TRUE ;
  TOTALBYTES := 0 ;   CASE_FLAG := FALSE ;
  FILECNT      := 0 ;     CKMODE := FALSE ;
  ASM := FALSE;  ASMVERB := FALSE;  DEBUG := TRUE;
  FLOW_TRACE := FALSE;  CURPNO := -1;
  NXTLIT := 0; NXTDBL := 0;
"&&" LAST_CC.LPC := 0;  TXR_CONTENTS.VALID := FALSE;
"&&" LAST_MVC.LPC := 0;  LAST_STR.LPC := 0;
"&&" LAST_STR.STOPND := ZEROBL;  OPT_FLG := TRUE;
"&&" HEXCHARS := '0123456789ABCDEF';
"**" TESTCNT := 0;
  MARK(HEAPMARK) ;
  END (*SETUP*) ;



BEGIN (*PCODE_TRANSLATOR*)

RESET (INPUT);  (*opp*)

INIT := TRUE ;  SETUP ;  INIT := FALSE ;  (*INITIALIZE*)
"**" IF OSPARM <> NIL THEN
"**"   WITH OSPARM@ DO
"**"     IF LENGTH >= 2 THEN
"**"       FOR Q := 1 TO LENGTH-1 DO
"**"         IF (STRING[Q]='T') AND (STRING[Q+1]='R') THEN
"**"           TRACE := TRUE
"**"         ELSE IF (STRING[Q]='C') AND (STRING[Q+1]='K') THEN
"**"           CKMODE := TRUE
"&&"         ELSE IF (STRING(/Q/)='M') AND (STRING(/Q+1/)='U') THEN
"&&"           MUSIC := TRUE;
TIMER := CLOCK(0) ;

WRITE(OUTPUT,'****':9, 'STANFORD PASCAL POST-PROCESSOR, MCGILL VERSION OF ':56,
                       VERSION);
"&&" IF NOT MUSIC THEN WRITELN(OUTPUT);

REPEAT
  READNXTINST ;
  ASMNXTINST ;
  IF TRACE THEN  DUMPSTK(1,TOP-1) ;
UNTIL OPC = PSTP ;

"NH" TIMER := CLOCK(0) - TIMER ;
"&&" IF NOT MUSIC THEN WRITELN(OUTPUT);
     WRITE(OUTPUT,'****':9);
IF ERRORCNT > 0 THEN WRITE(OUTPUT,ERRORCNT:8)
ELSE WRITE(OUTPUT, 'NO':8) ;
WRITELN(OUTPUT, ' ASSEMBLY ERROR(S) DETECTED.') ;
"&&" IF NOT MUSIC THEN WRITELN(OUTPUT);
WRITELN(OUTPUT, '****':9, TOTALBYTES:8,
                ' BYTES OF CODE GENERATED,', TIMER*0.001:6:2,
                ' SECONDS IN POST_PROCESSING.');

IF S370CNT > 0 THEN
  WRITELN(OUTPUT, '****':9, S370CNT:8,
                  ' "370"-ONLY INSTRUCTION(S) ISSUED.');


EXIT(ERRORCNT) ;


END.
++FILE PASCALN.OLDCOMP.SOURCE                       MEMB PROMPTER EXT ASS HEX -
         TITLE 'PASCALL - PASCAL COMPILE, ASMPCODE, AND GO INTERFACE'   00001000
         SPACE                                                          00002000
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 00003000
*                                                                     * 00004000
*        THIS MODULE PROVIDES THE USER A COMMAND INTERFACE FOR        * 00005000
*        PERFORMING ANY COMBINATION OF THE COMPILE, ASMPCODE, AND GO  * 00006000
*        STEPS IN THE PASCAL ENVIRONMENT UNDER CMS.  IT USES A LIBRARY* 00007000
*        OF MACROS FROM WATERLOO CALL THE INTERFACE MACRO LIBRARY,    * 00008000
*        WHICH IS USEFUL FOR WRITING ROUTINES SUCH AS THIS ONE.  MOST * 00009000
*        OF THIS PROGRAM IS DEDICATED TO ISSUING INTERNAL FILEDEFS AND* 00010000
*        COMMANDS TO SET UP THE CORRECT ENVIRONMENT.  THE REST SCANS  * 00011000
*        THE COMMAND LINE, INTERPRETS OPTIONS, AND CALLS THE VARIOUS  * 00012000
*        PROCESSORS.                                                  * 00013000
*                                                                     * 00014000
*        PLEASE NOTE THAT THIS IS A PRELIMINARY VERSION.  IT DOES NOT * 00015000
*        CONTAIN MANY OF THE OPTIONS AND FILE HANDLING FACILITIES     * 00016000
*        THAT ARE ANTICIPATED FOR THE FUTURE.  HOWEVER, IT DOES PRO-  * 00017000
*        VIDE THE FRAMEWORK FOR A FULL FLEDGED INTERFACE.             * 00018000
*                                                                     * 00019000
*        DAVID J. ROSSETTI                                            * 00020000
*        STANFORD LINEAR ACCELERATOR CENTER                           * 00021000
*        OCTOBER 31, 1979                                             * 00022000
*                                                                     * 00023000
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 00024000
         SPACE 3                                                        00025000
         MACRO                                                          00026000
         $SYSTEM &NAME=,&PATHLEN=0,&PARM=$NULL,&DIRTNAM=16,&COMPSWT=ON,*00027000
               &ERROR=*+4                                               00028000
         GBLB  &$CALL                                                   00029000
         AIF   ('&NAME' EQ '').MNOTE01                                  00030000
&$CALL   SETB  (1)                                                      00031000
         AIF   ('&NAME' NE '$OPND').DOBAL                               00032000
         MVC   $SYS&SYSNDX.(8),$OPND                                    00033000
.DOBAL   CNOP  0,4                                                      00034000
         BAL   R8,$CALLSYS                                              00035000
$SYS&SYSNDX DC    CL8'&NAME'                                            00036000
         DC    A(&PATHLEN)                                              00037000
         DC    A(&PARM)                                                 00038000
         DC    A(&DIRTNAM-16)                                           00039000
         AIF   ('&COMPSWT' EQ 'ON').SKIP01                              00040000
         DC    H'0'                                                     00041000
         AGO   .SKIP02                                                  00042000
.SKIP01  DC    H'-1'                                                    00043000
.SKIP02  ANOP                                                           00044000
         B     &ERROR                                                   00045000
         MEXIT                                                          00046000
.*                                                                      00047000
.MNOTE01 MNOTE 8,'$SYSTEM      NAME PARAMETER OMITTED'                  00048000
         MEXIT                                                          00049000
         MEND                                                           00050000
         MACRO                                                          00051000
&LAB     $SETFID  &FILEDEF,&LIST                                        00052000
         AIF   (K'&LAB EQ 0).SKPNULL                                    00053000
&LAB     $NULL                                                          00054000
.SKPNULL $SET     &FILEDEF,NAME,&LIST(1)                                00055000
         $SET     &FILEDEF,TYPE,&LIST(2)                                00056000
         $SET     &FILEDEF,MODELET,&LIST(3)                             00057000
         AIF      (N'&LIST LE 3).DONE                                   00058000
         MNOTE    4,'EXTRA OPERANDS (>3) IGNORED'                       00059000
.DONE    MEND                                                           00060000
*                                                                       00061000
*  DETERMINE THE INITIAL OPTION FLAG SETTINGS BASED ON THE FILETYPES    00062000
*  FOUND WITH MATTCHING FILENAME ON TTHE DISK THAT A MATCH FOR          00063000
*  <FILENAME> * * OCCURRED.                                             00064000
*                                                                       00065000
*        IF     PASCAL THEN COMPILE, ASMP, GO                           00066000
*        ELSEIF PCODE  THEN ASMP, GO                                    00067000
*        ELSEIF TEXT   THEN GO                                          00068000
*                                                                       00069000
PASCALL  $START   QUERY=TYPEINFO                                        00070000
         $OPND    END=NOINPUT                                           00071000
         $SETFID  INPUT,($OPND,'PASCAL','*')                            00072000
         $STATE   INPUT,ERROR=TRYPCODE                                  00073000
         $OPTINIT 1,#COMPILE+#ASMP+#GO                                  00074000
         $GOTO    HAVEINPT                                              00075000
         SPACE                                                          00076000
TRYPCODE $NULL                                                          00077000
         $STATE   INPUT,FTYPE=PCODE,ERROR=TRYTEXT                       00078000
         $OPTINIT 1,#ASMP+#GO                                           00079000
         $GOTO    HAVEINPT                                              00080000
         SPACE                                                          00081000
TRYTEXT  $NULL                                                          00082000
         $STATE   INPUT,FTYPE=TEXT,ERROR=NOTFOUND                       00083000
         $OPTINIT 1,#GO                                                 00084000
         SPACE                                                          00085000
HAVEINPT $NULL                                                          00086000
         USING FSTSECT,R7                                               00087000
         MVC   SAVEMODE(1),FSTM    SAVE FILEMODE OF INPUT               00088000
         $OPTIONS TABLE=OPTABLE                                         00089000
*                                                                       00090000
*  FORMAT THE "OPTIONS USED ..." LINE AND LET THE USER KNOW WHAT'S      00091000
*  GOING ON.                                                            00092000
*                                                                       00093000
         SR    R4,R4               R4 = INDEX - SET TO ZERO             00094000
         LA    R8,10               INCREMENT - OPTNAMES ENTRY SIZE      00095000
         SR    R9,R9                                                    00096000
         IC    R9,OPTNSIZE         COMPARAND - STOPS BXLE LOOP          00097000
         LA    R0,BLANK            INITIALIZE NEXT FOR TACKON ROUTINE   00098000
         ST    R0,NEXT                                                  00099000
         ICM   R6,B'0001',$UFLAGS  R6 = OPTION FLAGS BYTES              00100000
         SR    R7,R7               R7 WILL TEST BITS, ONE AT A TIME     00101000
TACKLOOP EQU   *                                                        00102000
         LA    R1,OPTNAMES+1(R4)   R1 -> OPTION NAE FOR THIS BIT4)      00103000
         SR    R2,R2                                                    00104000
         IC    R2,OPTNAMES(R4)     R2 = LENGTH OF OPTION STRING         00105000
         SRDL  R6,1                NOW R7'S SIGN BIT IS THE OPTION BIT  00106000
         LTR   R7,R7               IS R7 >= 0?  (I.E. BIT IS OFF)       00107000
         BNM   PICKUP              YES - BRANCH TO MOVE "NOXXXX"        00108000
         LA    R1,2(,R1)           CHOP OFF THE "NO"                    00109000
         BCTR  R2,0                AND SHORTEN THE LENGTH               00110000
         BCTR  R2,0                BY TWO BYTES                         00111000
PICKUP   BAL   R14,TACKON          LET TACKON MOVE IT                   00112000
         BXLE  R4,R8,TACKLOOP      LOOP UNTIL ALL OPTIONS PRINTED       00113000
         SPACE                                                          00114000
         MVI   BLANK,C' '          CLEAN UP FIRST ERRONEOUS COMMA       00115000
         L     R0,NEXT             R0 = NEXT - A(PRINTLINE)             00116000
         S     R0,=A(OPTMSG)                                            00117000
         WRTERM  OPTMSG,(R0)       WRITE IT OUT                         00118000
*                                                                       00119000
*  INITIALIZE THE OS STORAGE MANAGEMENT FREE LIST FOR CMS SIMULATION    00120000
*                                                                       00121000
         STRINIT  TYPCALL=SVC                                           00122000
*                                                                       00123000
*  SET UP FOR AND EXECUTE THE PASCAL COMPILER.  THE COMPILE OPTION      00124000
*  WAS SET, EITHER EXPLICITLY OR BY ASSUMPTION BECAUSE A FN PASCAL FM   00125000
*  FILE WAS FOUND.                                                      00126000
*                                                                       00127000
         $IFOPT   1,OFF,#COMPILE,CHKASMP                                00128000
         $SETFID  PRD,('PRD','PASCUTIL','A')                            00129000
         $SETFID  QRR,($OPND,'PTABLES',SAVEMODE)                        00130000
         $SETFID  PRR,($OPND,'PCODE',SAVEMODE)                          00131000
         $SETFID  OUTPUT,($OPND,'LISTING',SAVEMODE)                     00132000
         SPACE                                                          00133000
         $FILEDEF INPUT,ERROR=FDERR                                     00134000
         $FILEDEF PRD,ERROR=FDERR                                       00135000
         $FILEDEF QRR,ERROR=FDERR                                       00136000
         $FILEDEF PRR,ERROR=FDERR                                       00137000
         $FILEDEF OUTPUT,ERROR=FDERR                                    00138000
         SPACE                                                          00139000
         $IFOPT   1,OFF,#DEBUG,CALLPASC                                 00140000
         $TYPE    'Summary of filedefs for PASCAL step:'                00141000
         $EXEC    FILIST                                                00142000
CALLPASC $NULL                                                          00143000
         WRTERM 'Compile: ',EDIT=NO                                     00144000
         $SYSTEM   NAME=PASCAL,PATHLEN=48*4096                          00145000
         LINEDIT   TEXT='Compile Return Code = ....',SUB=(DEC,(R15))    00146000
         LTR   R15,R15             IS RET CODE ZERO?                    00147000
         BZ    CHKASMP             ZERO - GO DO NEXT STEP               00148000
         $RC   (R15)               NOPE - STOP RIGHT HERE               00149000
         SPACE                                                          00150000
*                                                                       00151000
*  SET UP FOR AND EXECUTE ASMPCODE.  RE-ISSUE ALL FILEDEFS FOR NEEDED   00152000
*  FILES, WITH THE "CHANGE" OPTION IN CASE THEY ALREADY EXIST.          00153000
*                                                                       00154000
CHKASMP  $NULL                                                          00155000
         $IFOPT   1,OFF,#ASMP,CHKGO                                     00156000
         $SETFID  INPUT,($OPND,'PCODE',SAVEMODE)                        00157000
         $SETFID  PRD,($OPND,'PTABLES',SAVEMODE)                        00158000
         $SETFID  PRR,($OPND,'TEXT',SAVEMODE)                           00159000
         SPACE                                                          00160000
         $FILEDEF INPUT,ERROR=FDERR                                     00161000
         $FILEDEF PRD,ERROR=FDERR                                       00162000
         $FILEDEF PRR,ERROR=FDERR                                       00163000
         $FILEDEF TOUTPUT,ERROR=FDERR                                   00164000
         SPACE                                                          00165000
         $IFOPT   1,OFF,#DEBUG,CALLASMP                                 00166000
         $TYPE    'Summary of filedefs for ASMP step:'                  00167000
         $EXEC    FILIST                                                00168000
CALLASMP $NULL                                                          00169000
         WRTERM 'Asmp: ',EDIT=NO                                        00170000
         $SYSTEM   NAME=ASMPCODE,PATHLEN=64*4096                        00171000
         LINEDIT   TEXT='Asmp Return Code = ....',SUB=(DEC,(R15))       00172000
         LTR   R15,R15             IS RETURN CODE ZERO?                 00173000
         BZ    CHKGO               YES - NOW TO THE GO STEP             00174000
         $RC   (R15)               NO - STOP AT THIS POINT              00175000
         SPACE                                                          00176000
*                                                                       00177000
*  SET UP FOR AND EXECUTE THE OBJECT PROGRAM.  THE ONLY FILEDEFS        00178000
*  PROVIDED BY DEFAULT ARE FOR:                                         00179000
*        INPUT    (FN DATA *)                                           00180000
*        OUTPUT   (TERMINAL)                                            00181000
*        QRD      (FN PTABLES FM)                                       00182000
*        FT06F001 (TERMINAL)                                            00183000
*                                                                       00184000
CHKGO    $NULL                                                          00185000
         $IFOPT   1,OFF,#GO,FINISH                                      00186000
         $SETFID  INPUT,($OPND,'DATA','*')                              00187000
         $SETFID  QRD,($OPND,'PTABLES',SAVEMODE)                        00188000
         $SET     FT06F001,DEVICE,'TERMINAL'                            00189000
         $FILEDEF INPUT,ERROR=FDERR                                     00190000
         $FILEDEF TOUTPUT,ERROR=FDERR                                   00191000
         $FILEDEF QRD,ERROR=FDERR                                       00192000
         $FILEDEF FT06F001,ERROR=FDERR                                  00193000
         SPACE                                                          00194000
         $IFOPT   1,OFF,#DEBUG,CALLGO                                   00195000
         $TYPE    'Summary of filedefs for GO step:'                    00196000
         $EXEC     FILIST                                               00197000
CALLGO   $NULL                                                          00198000
         $EXEC     CLEARCOR                                             00199000
         STRINIT  TYPCALL=SVC                                           00200000
         $SYSTEM   NAME=$OPND,PATHLEN=64*4096,COMPSWT=OFF               00201000
         LINEDIT   TEXT='Go Return Code = ....',SUB=(DEC,(R15))         00202000
         $RC   (R15)               SUPPLY THE GO RETURN CODE            00203000
         SPACE                                                          00204000
FINISH   $NULL                                                          00205000
         $RC      0                                                     00206000
*                                                                       00207000
*  TACKON - SUBROUTINE TO TACK ", <STRING>" ONTO THE END OF A LINE.     00208000
*  USES A VARIABLE "NEXT" AS THE DESTINATION POINTER, AND UPDATES IT    00209000
*  TO BE USED FOR THE NEXT CALL.  REGISTERS ON ENTRY:                   00210000
*        R1 = ADDRESS OF THE INPUT STRING                               00211000
*        R2 = LENGTH OF INPUT STRING                                    00212000
*        R14 = RETURN ADDRESS                                           00213000
*                                                                       00214000
TACKON   EQU   *                                                        00215000
         L     R3,NEXT             R3 -> WHERE TO PUT THE INPUT STRING  00216000
         MVI   0(R3),C','          PUT A COMMA IN TO SEPARATE           00217000
         EX    R2,OPTMOVER         NOTE: R2 HAS LENGTH - 1              00218000
         LA    R3,3(R2,R3)         R3 -> NEW DESTINATION BYTE           00219000
         ST    R3,NEXT                                                  00220000
         BR    R14                 RETURN                               00221000
OPTMOVER MVC   2(*-*,R3),0(R1)     OFFSET LEAVES ROOM FOR COMMA         00222000
         SPACE                                                          00223000
*                                                                       00224000
*  DATA AREAS FOLLOW                                                    00225000
*                                                                       00226000
NEXT     DS    A                   POINTER FOR DESTINATION IN TACKON    00227000
OPTNSIZE DC    AL1(OPTEND-*-2)                                          00228000
OPTNAMES DC    AL1(8),CL9'NOCOMPILE'   AL1 IS LENGTH-1 FOR EXECUTED MVC 00229000
         DC    AL1(5),CL9'NOASMP'                                       00230000
         DC    AL1(3),CL9'NOGO'                                         00231000
         DC    AL1(6),CL9'NODEBUG'                                      00232000
OPTEND   EQU   *                                                        00233000
         SPACE                                                          00234000
OPTMSG   DC    CL120' '                                                 00235000
         ORG   OPTMSG                                                   00236000
         DC    C'Options used:'                                         00237000
BLANK    DC    CL2'  '                                                  00238000
OPTSTART DS    C                                                        00239000
         ORG                                                            00240000
         SPACE                                                          00241000
SAVEMODE DS    CL1            HOLDS INPUT FILE MODE FOR LIFE OF PROGRAM 00242000
FILIST   $PLIST   FILEDEF                                               00243000
CLEARCOR DS    0D                                                       00244000
         DC    CL8'LOAD',CL8'IEFBR14',CL8'(',CL8'ORIGIN',CL8'21FF8'     00245000
         DC    8X'FF'                                                   00246000
         SPACE                                                          00247000
TYPEINFO $NULL                                                          00248000
         $TYPE    'Pascall Command Prototype:'                          00249000
         $TYPE   'PASCALL <filename> (Compile  Asmp    Go   <-Defaults' 00250000
         $TYPE   '                    NOComp   NOAsmp  NOGo'            00251000
         $TYPE   'Note:  Many options imply others; later options take *00252000
               precedence.'                                             00253000
         BR       R14                                                   00254000
         SPACE                                                          00255000
NOINPUT  $ERROR   'No file name given.  Type "PASCALL ?" for help.',   X00256000
               RC=1                                                     00257000
NOTFOUND $ERROR   'INPUT FILE NOT FOUND',RC=1                           00258000
FDERR    $ERROR   'ERROR IN FILEDEF',RC=2                               00259000
         SPACE                                                          00260000
         $OPTSW   (#COMPILE,#ASMP,#GO,#DEBUG)                           00261000
OPTABLE  $OPTDEF  (C,CO,COM,COMP,COMPI,COMPIL,COMPILE),                X00262000
               (,#COMPILE+#ASMP,,#GO),                                 X00263000
               (A,AS,ASM,ASMP),(,#ASMP,,#COMPILE+#GO),                 X00264000
               (G,GO),(,#GO,,#COMPILE+#ASMP),                          X00265000
               (NOC,NOCO,NOCOM,NOCOMP,NOCOMPI,NOCOMPIL),               X00266000
               (,#GO,,#COMPILE+#ASMP),                                 X00267000
               (NOA,NOAS,NOASM,NOASMP),(,,,#ASMP+#GO),                 X00268000
               (NOG,NOGO),(,,,#GO),                                    X00269000
               (D,DE,DEB,DEBU,DEBUG),(,#DEBUG)                          00270000
         $END                                                           00271000
INPUT    $FILE    DDNAME=INPUT,TYPE=DISK,FILEID=(*,*,*),XTENT=50,      X00272000
               CHANGE=YES,RECFM=FB,LRECL=80,BLOCK=800                   00273000
PRD      $FILE    DDNAME=PRD,TYPE=DISK,FILEID=(*,*,*),XTENT=50,        X00274000
               CHANGE=YES,RECFM=F                                       00275000
QRR      $FILE    DDNAME=QRR,TYPE=DISK,FILEID=(*,*,*),XTENT=50,        X00276000
               CHANGE=YES,RECFM=FB,LRECL=80,BLOCK=800                   00277000
PRR      $FILE    DDNAME=PRR,TYPE=DISK,FILEID=(*,*,*),XTENT=50,        X00278000
               CHANGE=YES,RECFM=FB,LRECL=80,BLOCK=800                   00279000
OUTPUT   $FILE    DDNAME=OUTPUT,TYPE=DISK,FILEID=(*,*,*),XTENT=50,     X00280000
               CHANGE=YES,RECFM=FBA,LRECL=112,BLOCK=2240                00281000
TOUTPUT  $FILE    DDNAME=OUTPUT,TYPE=TERMINAL,CHANGE=YES,RECFM=F,      X00282000
               LRECL=80,BLOCK=80                                        00283000
QRD      $FILE    DDNAME=QRD,TYPE=DISK,FILEID=(*,*,*),XTENT=50,        X00284000
               CHANGE=YES,RECFM=F                                       00285000
FT06F001 $FILE    DDNAME=FT06F001,TYPE=TERMINAL,RECFM=F,LRECL=80,      X00286000
               BLOCK=80                                                 00287000
         SPACE                                                          00288000
         FSTB                                                           00289000
         END                                                            00290000
********************************************************************************
*********************************************************************** ********
***** THIS SET UP IS PROVIDED AS A GUIDELINE FOR A 'CMS' INTERFACE **** ********
***** AND IS NOT INTENDED TO BE USED AS A FINAL VERSION.           **** ********
***** THE CURRENT VERSION OF THE RUN TIME SYSTEM 'PMONSRC' SHOULD  **** ********
***** BE SUBSTITUTED FOR THIS MODULE IN THE FINAL INTERFACE.       **** ********
*********************************************************************** ********
*********************************************************************** ********
         TITLE 'PASCSP, PASCAL RUNTIME SUPPORT AND STANDARD PROCS'      00001000
*********************************************************************** 00002000
*                                                                       00003000
*                                                                       00004000
*                                                                       00005000
*     PASCAL ENVIRONMENT AND ENTRY SETUP                                00006000
*     ------------------------------------                              00007000
*                                                                       00008000
*                                                                       00009000
*     COPYRIGHT 1976, STANFORD LINEAR ACCELERATOR CENTER.               00010000
*                                                                       00011000
*                                                                       00012000
*     THE FOLLOWING PROGRAMS CREATE  THE  RUN-TIME  ENVIRONMENT  AND    00013000
*     PROVIDE THE I/O INTERFACE FOR THE SLAC 'PASCAL' COMPILER.         00014000
*                                                                       00015000
*     EXCEPT FOR THE FEW POINTS EXPLAINED IN THIS BOX, THE INTERNALS    00016000
*     OF THESE ROUTINS SHOULD BE INVISIBLE (AND INCONSEQUENTIAL)  TO    00017000
*     THE 'PASCAL' USER.                                                00018000
*                                                                       00019000
*                                                                       00020000
*                                                                       00021000
*     1) THE USER MAY SPECIFY THE SIZE OF THE RUN  TIME  STACK/HEAP,    00022000
*     THE  SIZE OF THE AREA RETURNED TO THE OPERATING SYSTEM FOR I/O    00023000
*     BUFFERS, THE MAXIMUM COUNT OF RUN  TIME  ERRORS,  THE  RUNNING    00024000
*     TIME  OF  THE  PROGRAM,  REQUEST  AN  OPTIONAL MEMORY DUMP AND    00025000
*     SPECIFY OTHER SPECIAL CONTROL OPTIONS AS FOLLOWS:                 00026000
*                                                                       00027000
*       // EXEC USERPROG,                                               00028000
*       //      PARM='USER PARMS /STACK=XXXK,IOBUF=YYYK,ERRLIM=NNN,     00029000
*                            TIME=TTTS,NOSPIE,NOSNAP,NOCC,DUMP'      #  00030000
*                                                                       00031000
*       'USER PARMS': THE PARAMETER LIST TO BE PASSED TO THE USER       00032000
*                     PROGRAM (IF ANY).                                 00033000
*       'XXX' : STORAGE AREA (IN K BYTES) FOR STACK+HEAP+IOBUFFERS.     00034000
*       'YYY' : STORAGE AREA (IN K BYTES) TO BE RETURNED TO SYSTEM.     00035000
*       'NNN' : NUMBER OF NON FATAL RUN-TIME ERRORS TO BE TOLERATED     00036000
*               BEFORE THE PROGRAM IS TERMINATED.                       00037000
*       'TTT' : PROGRAM RUNNING TIME (IN SECONDS).                      00038000
*       'DUMP': TO GENERATE AN OS STYLE MEMORY DUMP IN CASE OF AN       00039000
*               ABNORMAL PROGRAM TERMINATION.                           00040000
*       'NOSPIE': TO PREVENT INTERCEPTION OF ERROR INTERRUPTS        #  00041000
*       'NOSNAP': TO STOP USE OF SNAPSHOT RT. AFTER AN ERROR         #  00042000
*       'NOCC': TO STOP FIRST CHARACTER ON EACH LINE FROM BEING      #  00043000
*               TAKEN AS A CONTROL CHARACTER                         #  00044000
*       DEFAULT VALUE FOR 'XXXK' IS THE JOB 'REGION' SIZE.              00045000
*       DEFAULT VALUE FOR 'YYYK' IS 32K.                                00046000
*       DEFAULT VALUE FOR 'NNN' IS 1.                                   00047000
*                                                                       00048000
*     2) THE VALUE OF THE RETURN CODE 'RC', IF OTHER  THAN GENERATED    00049000
*     BY  THE  USER  PROGRAM,  MAY  BE  INTERPRETED ACCORDING TO THE    00050000
*     FOLLOWING TABLE.  FOR MORE DETAILED EXPANATION  OF  THE  ERROR    00051000
*     CONDITION,  SEE  THE  CONTENTS OF THE 'OUTPUT' FILE WHICH HAVE    00052000
*     THE APPROPRIATE MESSAGES.  NOTE THAT THIS FILE (OUTPUT) SHOULD    00053000
*     BE INCLUDED IN THE USER PROGRAM IN ORDER TO GET THE  RUN  TIME    00054000
*     DIAGNOSTICS AND RELATED MESSAGES.                                 00055000
*                                                                       00056000
*       RETURN CODE:  IMPLIES:                                          00057000
*                                                                       00058000
*       1001          INDEX VALUE OUT OF RANGE                          00059000
*       1002          SUBRANGE VALUE OUT OF RANGE                       00060000
*       1003          ACTUAL PARAMETER OUT OF RANGE                     00061000
*       1004          SET MEMBER OUT OF RANGE                           00062000
*       1005          POINTER VALUE INVALID                             00063000
*       1006          STACK/HEAP COLLISION                              00064000
*       1007          ILLEGAL INPUT/RESET OPERATION                     00065000
*       1008          ILLEGAL OUTPUT/REWRITE OPERATION                  00066000
*       1009          SYNCHRONOUS I/O ERROR                             00067000
*       1010          PROGRAM EXCEEDED SPECIFIED RUNNING TIME           00068000
*       1011          ILLEGAL FILE DEFINITION (I.E., TOO MANY FILES)    00069000
*       1012          NOT ENOUGH STACK SPACE                            00070000
*       1013          ATTEMPT TO CALL MATH RT. VIA CSP (OBSOLETE)    #  00071000
*       1014          LINELIMIT EXCEEDED FOR A FILE                  #  00072000
*       1020          READ PAST END OF FILE                          #  00073000
*       1021          BAD BOOLEAN INPUT                              #  00074000
*       1022          BAD INTEGER INPUT                              #  00075000
*       1023          BAD REAL INPUT                                 #  00076000
*                                                                       00077000
*       200X          PROGRAM INTERRUPTION CODE 'X'                     00078000
**                                                                      00079000
*       3001          INVALID ARGUMENT TO MATH ROUTINES LOG, SQRT,..    00080000
*                                                                       00081000
*       X1XX          UNABLE TO RUN SNAPSHOT, OTHER DIGITS AS ABOVE     00082000
*                                                                       00083000
*                                                                       00084000
*     3) THE CONDITIONAL ASSEMBLY FLAG &SYSTEM DETERMINES WHETHER    #  00085000
*     CERTAIN SECTIONS OF CODE ARE INCLUDED IN THE PROGRAM.          #  00086000
*     WITH &SYSTEM=1, SOME CHECKING CODE, REAL NUMBER INPUT AND THE  #  00087000
*     FORTRAN INTERFACE IS OMITTED.  THIS RESULTS IN A SMALLER       #  00088000
*     FASTER PROGRAM BUT WHICH CAN ONLY BE USED WITH "SAFE"          #  00089000
*     PROGRAMS THAT DO NOT USE MATHEMATICAL ROUTINES - SUCH AS THE   #  00090000
*     COMPILER AND THE P-ASSEMBLER.                                  #  00091000
*     WITH &SYSTEM=0, THE FULL PROGRAM IS PRODUCED AND THIS IS THE   #  00092000
*     VERSION THAT SHOULD NORMALLY BE COMBINED WITH USER PROGRAMS.   #  00093000
*                                                                       00094000
*                                                                       00095000
*     4) THIS PROGRAM MAY BE ASSEMBLED WITH MOST STANDARD IBM        #  00096000
*     ASSEMBLERS.                                                    #  00097000
*                                                                       00098000
*                                                                       00099000
*     5) IF THE RUN PROFILE SWITCH IS ENABLED IN THE PASCAL  PROGRAM    00100000
*     (I.E.   'K+'),  THE  RUN  TIME SYSTEM WILL 'REWRITE' THE 'RAW'    00101000
*     EXECUTION COUNTS ON THE PREDEFINED 'QRR'  FILE  AFTER  RUNNING    00102000
*     THE  USER  PROGRAM.  IN SUCH CASES THE USER PROGRAM SHOULD NOT    00103000
*     USE THE 'QRR' FILE BUT THE 'DD' STATEMENT FOR THIS FILE SHOULD    00104000
*     BE INCLUDED IN THE 'GO' STEP.                                     00105000
*                                                                       00106000
*                                                                       00107000
*                                                                       00108000
*     THESE PROGRAMS INCLUDE SOME CONTRIBUTIONS BY KEITH RICH,  JOHN    00109000
*     BANNING AND NIGEL HORSPOOL.                                       00110000
*                                                                       00110100
*     SIX LINES WERE ADDED FOR THIS (CMS) VERSION.  THEY ATTEMPT        00110200
*     TO SOLVE THE LOCATE MODE PROBLEM FOR OUTPUT, BUT CAUSE AN         00110300
*     EXTRA LINE TO BE WRITTEN WHEN THE OUTPUT FILE IS CLOSED.          00110400
*     DAVE ROSSETTI,  OCTOBER 31, 1979.                                 00110500
*                                                                       00110600
*                                                                       00111000
*                                                                       00112000
*                                                                       00113000
*                                SASSAN HAZEGHI,                        00114000
*                                                                       00115000
*                                COMPUTATION RESEARCH GROUP             00116000
*                                STANFOR LINEAR ACCELERATOR CENTER      00117000
*                                P. O. BOX 4349                         00118000
*                                STANFORD, CALIFORNIA  94305.           00119000
*                                                                       00120000
*                                                                       00121000
*                                                                       00122000
*                                LAST UPDATE:                           00123000
*                                             MAR.  15, 76.             00124000
*                                             SEPT.  8, 76.             00125000
*                                             JAN.  20, 77.             00126000
*                                             JULY  28, 77.             00127000
*                                             MAY   21, 77.             00128000
*                                             JULY   6, 78.             00129000
*                                             SEPT. 15, 78.             00130000
*                                             NOV.  11, 78.             00131000
*                                                                       00132000
*     FURTHER MODIFICATIONS MADE AT MCGILL UNIVERSITY,               #  00133000
*                                                                    #  00134000
*                                R. NIGEL HORSPOOL                   #  00135000
*                               JULY 1, 1979                         #  00136000
*                                                                       00137000
*********************************************************************** 00138000
         EJECT                                                          00139000
**************************************************************          00140000
*                                                                       00141000
*        I/O (FILE) HANDLING MACROES                                    00142000
*                                                                       00143000
**************************************************************          00144000
*                                                                       00145000
         MACRO ,                                                        00146000
&L       FILADR ,                                                       00147000
.*       TO COMPUTE FILE BUFFER ADDRESS ETC.                            00148000
&L       LR    AE,AD                                                    00149000
         SR    AE,GBR                         AE <-- FILE #             00150000
         SLA   AE,2                           FILE # TO OFFSET          00151000
         L     AE,FILBLK-PASBUFAD*4(AE)       OFFSET TO FILE BLOCK      00152000
         L     AF,FILBUF(AE)       SET I/O BUFFER POINTER            #  00153000
         MEND  ,                                                        00154000
*                                                                       00155000
         MACRO ,                                                     #  00156000
         FILDEF &NAME,&DIRECT,&LENGTH                                #  00157000
.*       DEFINE A FILE  DDNAME,DIRECTION,LRECL                       #  00158000
         LCLC  &NAM                                                  #  00159000
         DS    0D                                                    #  00160000
&NAM     SETC  '&NAME'(1,3)                                          #  00161000
FIL&NAM  DC    A(0)                BUFFER ADDRESS                    #  00162000
         DC    H'0',H'0'            LRECL,CHAR. PTR.                 #  00163000
         DC    H'0'                CHAR. START POS.                  #  00164000
         DC    X'0',X'0'           EOFFLAG, OPENFLAG                 #  00165000
         DC    F'0'                OUTPUT LINES LIMIT                #  00166000
         AIF   ('&DIRECT' NE 'INPUT').OUTPUT                         #  00167000
         DCB   DSORG=PS,DDNAME=&NAME,MACRF=(GL),EODAD=EOD,           # X00168000
               SYNAD=SYNADRT,EXLST=XL&DIRECT,BFTEK=A                 #  00169000
         MEXIT ,                                                     #  00170000
.OUTPUT  AIF   ('&DIRECT' NE 'OUTPUT').INPOUT                        #  00171000
         DCB   DSORG=PS,DDNAME=&NAME,MACRF=(PL),                     # X00172000
               SYNAD=SYNADRT,EXLST=XL&DIRECT,BFTEK=A                 #  00173000
         MEXIT ,                                                     #  00174000
.INPOUT  ANOP  ,                                                     #  00175000
         DCB   DSORG=PS,DDNAME=&NAME,MACRF=(GL,PL),EODAD=EOD,        # X00176000
               SYNAD=SYNADRT,EXLST=XL&DIRECT,BFTEK=A                 #  00177000
         MEND  ,                                                     #  00178000
*                                                                    #  00179000
         EJECT                                                          00180000
         GBLB  &SYSTEM                                               #  00181000
&SYSTEM  SETB  0                  TRUE INDICATES A COMPACT 'CSP'        00182000
*                                                                       00183000
         AIF   (&SYSTEM).SYS1                                           00184000
*        GENERAL SETUP FOR USER PROGRAM(S).                             00185000
         AGO   .USE1                                                    00186000
.SYS1    ANOP                                                           00187000
*        COMPACT SETUP, OMITS FORTRAN INTERFACE & REAL INPUT         #  00188000
.USE1    ANOP                                                           00189000
*                                                                       00190000
*                                                                       00191000
*                                                                       00192000
         EJECT                                                          00193000
***************************************************************         00194000
*                                                                       00195000
*        STACK (AND SAVE AREA) LAYOUT                                   00196000
*                                                                       00197000
***************************************************************         00198000
*                                                                       00199000
*                                                                       00200000
         PRINT NOGEN                                                    00201000
         DCBD  DSORG=PS                                                 00202000
         PRINT GEN                                                      00203000
*                                                                       00204000
DYNSTORE DSECT ,                                                        00205000
         DS    20F                 PASCAL ENVIRONMENT SAVE AREA         00206000
STACK    DS    18F                 BOTTOM OF RUNTIME STACK              00207000
CLOCK    EQU   STACK               CLOCK LOCATION                       00208000
NEWPTR   DS    A                   PASCAL 'NEW' POINTER                 00209000
HEAPLIM  DS    A                   UPPER LIMIT OF HEAP ( +1 )           00210000
*                                  ALSO POINTS TO DYN2STOR              00211000
DISPREGS DS    10F                 RUN TIME DISPLAY REGISTERS           00212000
DISPLAY  EQU   DISPREGS,*-DISPREGS                                      00213000
FL1      DS    D                   R/W  FIX/FLOAT CONVERSION HELPS      00214000
FL2      DS    D                   R ONLY                               00215000
FL3      DS    D                   R/W                                  00216000
FL4      DS    D                   R ONLY                               00217000
CHKSUBS  DS    0F                  ENTRY TO RUN TIME CHECK ROUTINES     00218000
INXCHK   DS    3F                  INDEX CHECK                          00219000
RNGCHK   DS    3F                  SUBRANGE CHECK                       00220000
PRMCHK   DS    3F                  PARAMETER VALUE CHECK                00221000
PTRCHK   DS    3F                  POINTER CHECK                        00222000
PTACHK   DS    3F                  SET MEMBER CHECK                     00223000
SETCHK   DS    3F                                                       00224000
STKCHK   DS    3F                                                       00225000
ZZZCHK   DS    3F                                                       00226000
INPUT    DS    CL1                                                      00227000
OUTPUT   DS    CL1                                                      00228000
PRD      DS    CL1                                                      00229000
PRR      DS    CL1                                                      00230000
QRD      DS    CL1                                                      00231000
QRR      DS    CL1                                                      00232000
F01PAS   DS    CL1                                                      00233000
F02PAS   DS    CL1                                                      00234000
F03PAS   DS    CL1                                                      00235000
F04PAS   DS    CL1                                                      00236000
F05PAS   DS    CL1                                                      00237000
F06PAS   DS    CL1                                                      00238000
F07PAS   DS    CL1                                                      00239000
F08PAS   DS    CL1                                                      00240000
F09PAS   DS    CL1                                                      00241000
F10PAS   DS    CL1                                                      00242000
F11PAS   DS    CL1                                                      00243000
F12PAS   DS    CL1                                                      00244000
F13PAS   DS    CL1                                                      00245000
F14PAS   DS    CL1                                                      00246000
F15PAS   DS    CL1                                                      00247000
F16PAS   DS    CL1                                                      00248000
F17PAS   DS    CL1                                                      00249000
F18PAS   DS    CL1                                                      00250000
**F19PAS   DS    CL1                                                    00251000
**F20PAS   DS    CL1                                                    00252000
CLEARBUF DS    XL8                  BUFFER TO CLEAR ACTIVATION RECORDS  00253000
PASDATE  DS    CL10                 PREDEFINED VARIABLE DATE            00254000
PASTIME  DS    CL10                 PREDEFINED VARIABLE TIME            00255000
OSPRMPTR DS    A                    POINTER TO O.S. PARM STRING      #  00256000
*FPRSAVE  DS    4D                  FLT. PT. REGS SAVE AREA (OPTIONAL)  00257000
*                                                                       00258000
*       DYNAMIC STORAGE AREA POINTED TO BY HEAPLIM                      00259000
*                                                                       00260000
DYN2STOR DSECT     ,                                                    00261000
DYNRUNC  DS        F         # OF RUN TIME FREQUENCY COUNTERS           00262000
DYNERRL  DS        F         LIMIT OF ERROR BEFORE TERMINATING          00263000
DYNERRC  DS        F         ERROR COUNTER                              00264000
DYNABEND DS        X         X'FF' => ABEND ON ERROR TERMINATION        00265000
         DS        0D                                                   00266000
DYNCOUNT DS        0F                                                   00267000
         AIF       (&SYSTEM).SYS3                                       00268000
DYN2LEN  EQU       128       EXTRA MARGIN FOR PATHOLOGICAL CALL PARMS   00269000
         AGO       .USE3                                                00270000
.SYS3    ANOP                                                           00271000
DYN2LEN  EQU       *-DYN2STOR                                           00272000
.USE3    ANOP                                                           00273000
*                                                                       00274000
         EJECT                                                          00275000
**************************************************************          00276000
*                                                                       00277000
*        PASCAL ENTRY POINT AND PROGRAM PROLOGUE                        00278000
*                                                                       00279000
**************************************************************          00280000
*                                                                       00281000
*                                                                       00282000
$PASENT  CSECT ,                                                        00283000
         ENTRY $PASENT,$PASCSP,$PASINT                               #  00284000
*                                                                       00285000
*                                                                       00286000
         USING *,15                                                     00287000
         SAVE  (14,12),,*                                               00288000
         LR    R10,R15                                                  00289000
         DROP  R15                                                      00290000
         USING $PASENT,R10                                              00291000
         ST    R1,OSPARMS          SAVE ADDRESS OF O.S. PARMS        #  00292000
         L     R1,0(R1)                                                 00293000
         SPACE                                                          00294000
*                                                                       00295000
*        R1 POINTS TO THE PARAMETER LIST THE FIRST HALF WORD OF         00296000
*        WHICH GIVES THE LENGTH OF THE LIST                             00297000
*                                                                       00298000
         LH    R2,0(R1)                                                 00299000
         LTR   R2,R2                                                    00300000
         BNH   NOPARM             NO PARAMETER LIST SPECIFIED           00301000
         LA    R0,256              SET MAX STRING LENGTH             #  00302000
         CR    R2,R0                                                 #  00303000
         BNH   *+6                 JUMP IF LENGTH OK                 #  00304000
         LR    R2,R0               ENFORCE THE LIMIT                 #  00305000
         LA    R8,1                INCREMENT FOR BXLE & BXH          #  00306000
         LA    R9,1(R1,R2)         LIMIT FOR BXLE & BXH              #  00307000
         LA    R1,2(,R1)           POINT AT FIRST CHAR               #  00308000
         ST    R1,OSPARMAD         SAVE ADDRESS FOR LATER            #  00309000
*                                                                       00310000
PARMRTRY CLI   0(R1),C'/'                                               00311000
         BE    PARMSLSH            SEPARATOR FOUND ?                 #  00312000
         BXLE  R1,R8,PARMRTRY                                        #  00313000
*                                                                       00314000
PARMSLSH LR    R3,R1                                                 #  00315000
         SL    R3,OSPARMAD         COMPUTE STRING LENGTH             #  00316000
         STH   R3,OSPARML          SAVE IT FOR LATER                 #  00317000
         BXH   R1,R8,NOPARM        JUMP IF STRING END                #  00318000
*                                                                       00319000
GOTPARM  CLC   0(3,R1),=C'STACK'  PROGRAM DATA AREA SPECIFIED ?         00320000
         BNE   TESTBUF                                                  00321000
*                                                                       00322000
SETREG   BAL   R7,GETNUM          SET STACK REGION SIZE                 00323000
         LTR   R4,R4                                                    00324000
         BNP   NXTPARM                                                  00325000
         SLA   R4,10              CONVERT TO 'K' BYTES                  00326000
         ST    R4,REQSTORE        RESET REGION SIZE                     00327000
         ST    R4,REQSTORE+4      ALSO SET MAX STORE TO THE SAME VALUE  00328000
         B     NXTPARM                                                  00329000
*                                                                       00330000
TESTBUF  CLC   0(3,R1),=C'IOBUF' I/O BUFFER SIZE SPECIFIED ?            00331000
         BNE   TESTABND                                                 00332000
*                                                                       00333000
SETBUF   BAL   R7,GETNUM                                                00334000
         LTR   R4,R4                                                    00335000
         BNP   NXTPARM                                                  00336000
         SLA   R4,10                                                    00337000
         ST    R4,BUFSTORE        RESET I/O BUFFER SIZE                 00338000
         B     NXTPARM                                                  00339000
*                                                                       00340000
TESTABND CLC       0(4,R1),=C'DUMP'    ABEND ON ERROR ?                 00341000
         BNE       TESTLIM        IF NOT, SKIP                          00342000
         MVI       DUMPFLAG,X'FF' SET_FLAG                              00343000
*        LA        R1,4(R1)       ADVANCE POINTER AND                #  00344000
         B         NXTPARM        CONTINUE                              00345000
*                                                                       00346000
TESTLIM  CLC       0(6,R1),=C'ERRLIM'  LIMIT ON NUMBER OF ERRORS        00347000
         BNE       TESTTIME       IF NOT, SKIP                          00348000
         BAL       R7,GETNUM      GET ERROR LIMIT                       00349000
         LTR       R4,R4                                                00350000
         BNP       NXTPARM        IGNORE NUMBER IF BAD                  00351000
         ST        R4,ERRLIMIT    ELSE SET LIMIT                        00352000
         B         NXTPARM                                              00353000
*                                                                       00354000
TESTTIME CLC   0(4,R1),=C'TIME'                                         00355000
         BNE   TESTCC             SEE IF EXEC TIME SPECIFIED         #  00356000
         BAL   R7,GETNUM                                                00357000
         LTR   R5,R4                                                    00358000
         BNP   NXTPARM            IF TIME PARM NO GOOD, SKIP            00359000
         M     R4,=F'38400'       CONVERT SECONDS TO CPU TIMER UNITS    00360000
         ST    R5,EXECTIME                                              00361000
         B     NXTPARM                                                  00362000
*                                                                       00363000
TESTCC   CLC   0(4,R1),=C'NOCC'    SEE IF CONTROL CHARS CANCELLED    #  00364000
         BNE   TESTSPIE            JUMP IF NOT                       #  00365000
         L     R15,=A(CCFLAG)      FLAG IS NOT DIRECTLY ADDRESSABLE  #  00366000
         MVI   0(R15),X'FF'        SET THE FLAG                      #  00367000
*        LA    R1,4(,R1)                                             #  00368000
         B     NXTPARM                                               #  00369000
*                                                                    #  00370000
TESTSPIE CLC   0(6,R1),=C'NOSPIE'  CANCEL SPIE TRAP?                 #  00371000
         BNE   TESTSNAP                                              #  00372000
         MVI   SPIEFLAG,X'FF'      SET THE CANCEL SPIE FLAG          #  00373000
*        LA    R1,6(,R1)           ADVANCE POINTER                   #  00374000
         B     NXTPARM                                               #  00375000
*                                                                       00376000
TESTSNAP CLC   0(6,R1),=C'NOSNAP'  CANCEL SNAPSHOT                   #  00377000
         BNE   NXTPARM                                               #  00378000
         MVI   SNAPFLAG,X'FF'      SET FLAG                          #  00379000
*        LA    R1,6(,R1)                                             #  00380000
*        B     NXTPARM                                               #  00381000
*                                                                       00382000
*                                                                       00383000
*                                                                       00384000
*                                                                       00385000
NXTPARM  BXLE  R1,R8,GOTPARM       STEP TO NEXT CHAR                 #  00386000
*                                                                    #  00387000
*                                                                    #  00388000
*        DDNAME-LIST PARAMETER PROCESSING                            #  00389000
*                                                                    #  00390000
NOPARM   EQU   *                                                     #  00391000
         L     R1,OSPARMS                                            #  00392000
         TM    0(R1),X'80'         TEST IF DDNAME LIST PROVIDED      #  00393000
         BO    NODDPARM                                              #  00394000
         L     R1,4(,R1)           ADDRESS OF DDNAME LIST PARM       #  00395000
         LH    R2,0(,R1)           LENGTH OF LIST IN BYTES           #  00396000
         L     AD,=A(FILBLK)       POINTER TO FIRST ENTRY IN FILE TAB#  00397000
         LA    R3,6                MAX NUMBER OF DDNAMES ALLOWED     #  00398000
DDLOOP   SH    R2,=H'8'            CHECK FOR END OF DDNAME LIST      #  00399000
         BM    NODDPARM                                              #  00400000
         NC    2(8,R1),2(R1)       CHECK FOR BINARY ZEROS            #  00401000
         BZ    DDDFLT              IF SO, DONT CHANGE DDNAME         #  00402000
         L     AE,0(,AD)           ADDRESS OF FILE CONTROL BLOCK     #  00403000
         USING IHADCB-FILDCB,AE                                      #  00404000
         MVC   DCBDDNAM(8),2(R1)   MOVE NEW DDNAME INTO DCB          #  00405000
DDDFLT   LA    R1,8(,R1)           ADVANCE THROUGH LIST              #  00406000
         LA    AD,4(,AD)           ADVANCE THROUGH FILE TABLE        #  00407000
         BCT   R3,DDLOOP           REPEAT FOR NEXT FILE              #  00408000
NODDPARM EQU   *                                                     #  00409000
*                                                                       00410000
*                                                                       00411000
*        GET SPACE FOR THE RUN TIME STACK                               00412000
*                                                                       00413000
         GETMAIN VU,LA=REQSTORE,A=ALOSTORE                              00414000
         SPACE ,                                                        00415000
*                                                                       00416000
         L     R1,ALOSTORE         GET ADDRESS OF ALLOCATED AREA        00417000
         LR    R12,R1                                                   00418000
         A     R1,ALOSTORE+4       ADD SIZE OF THE AREA                 00419000
         S     R1,BUFSTORE         BEGINNIG (ENDING !) OF THE HEAP      00420000
         S     R1,=A(8)            NAME FIELD OF THE HEAP               00421000
         AIF   (&SYSTEM).SYS32                                          00422000
*                                                                       00423000
         LR    R2,R1                                                    00424000
         SR    R2,R12              R2 <-- SIZE OF THE USABLE AREA       00425000
         BNH   NOCLR               SKIP IF NOT LARGE ENOUGH             00426000
         LD    FPR0,=XL8'8181818181818181'                              00427000
         SRA   R2,3                CONVERT BYTE COUNT TO D_WORD COUNT   00428000
         LR    R3,R12                                                   00429000
         STD   FPR0,0(R3)                                               00430000
         LA    R3,8(R3)                                                 00431000
         BCT   R2,*-8                                                   00432000
*                                                                       00433000
.SYS32   ANOP                                                           00434000
NOCLR    ST    R13,4(R12)          BACK LINK OF NEW SAVE AREA           00435000
         ST    R12,8(R13)          FRWRD LINK OF OLD SAVE AREA          00436000
         LR    R13,R12             RESET SAVE AREA POINTER              00437000
*                                                                       00438000
         USING DYNSTORE,GBR                                             00439000
         MVC   STACK-8(8),=CL8'   STACK'                                00440000
         MVC   0(8,R1),=CL8'HEAP    '                                   00441000
         LA    R12,STACK           GLOBAL (STACK BOTTOM) POINTER        00442000
         USING STACK,R12                                                00443000
         ST    R1,NEWPTR           SET PASCAL 'NEW' PONTER              00444000
*                                                                       00445000
*        CLEAR DISPLAY PSEUDO REGISTERS                                 00446000
*                                                                       00447000
         MVI   DISPLAY,X'FF'       SET DISP REGS TO '-1'                00448000
         MVC   DISPLAY+1(L'DISPLAY-1),DISPLAY                           00449000
         SPACE ,                                                        00450000
         L     R0,BUFSTORE         SIZE OF THE AREA TO BE RETURNED      00451000
         LA    R1,8(R1)            ADDRESS OF THE AREA TO BE RETURNED   00452000
         LR    R2,R1                                                    00453000
         SR    R2,R12              RSPACE LEFT FOR THE STACK            00454000
         C     R2,USESTORE                                              00455000
         LA    R2,SPCERR           ERROR CODE FOR LACK OF SPACE         00456000
         BL    QUIT1                                                    00457000
*                                                                       00458000
*        FREE SOME SPACE FOR O/S FILE BUFFERS (4K/FILE !)               00459000
*                                                                       00460000
         FREEMAIN R,LV=(R0),A=(R1)                                      00461000
         L     R1,ALOSTORE+4       KEEP TRACK OF HOW MUCH CORE       #  00462000
         S     R1,BUFSTORE         TO RETURN TO THE O.S.             #  00463000
         ST    R1,ALOSTORE+4       AT END OF EXECUTION               #  00464000
         SPACE ,                                                        00465000
*                                                                       00466000
*        INITIALIZE FORTRAN ENVIRONMENT (IF THERE ARE FORTRAN        #  00467000
*        ROUTINES IN THE LOAD MODULE)                                #  00468000
*                                                                       00469000
         AIF   (&SYSTEM).SYS325                                      #  00470000
         L     R15,=V(IBCOM#)                                           00471000
         LTR   R15,R15             TEST IF IBCOM# HAS BEEN           #  00472000
         BZ    *+8                 INCLUDED IN LOAD MODULE           #  00473000
         BAL   R14,64(R15)                                              00474000
.SYS325  ANOP                                                        #  00475000
         SPACE ,                                                        00476000
*                                                                       00477000
*        SET THE 'SPIE' TO TRAP PROGRAM  INTERRUPTS                     00478000
*                                                                       00479000
         CLI   SPIEFLAG,X'00'      TEST IF SPIE TO BE ISSUED         #  00480000
         BNE   NOSPIE                                                #  00481000
         SPIE  $PASINT,((1,7),9,11,12,15)                               00482000
         ST    R1,OLDPICA                                               00483000
NOSPIE   EQU   *                                                     #  00484000
*                                                                       00485000
*        SETUP DYN2STOR AREA                                            00486000
*                                                                       00487000
         L         R1,NEWPTR          TOP OF HEAP                       00488000
         S         R1,=A(DYN2LEN)     LESS SIZE OF DYN2                 00489000
         ST        R1,HEAPLIM         AND LIMIT                         00490000
         USING     DYN2STOR,R1                                          00491000
         MVC       DYNERRL,ERRLIMIT   SET ERROR LIMIT                   00492000
         SR        R0,R0                                                00493000
         ST        R0,DYNRUNC         CLEAR '# OF COUNTERS' FIELD       00494000
         ST        R0,DYNERRC         CLEAR '# OF ERRORS' FIELD         00495000
         MVC       DYNABEND,DUMPFLAG  SET DUMP FLAG                     00496000
         LH    R2,OSPARML                                            #  00497000
         LTR   R2,R2                                                 #  00498000
         BZ    OSPARM1             JUMP IF NO PARM STRING            #  00499000
         SLR   R1,R2                                                 #  00500000
         SL    R1,=F'4'            ALLOCATE PARM STRING RECORD       #  00501000
         SRL   R1,3                FORCE TO DOUBLE-WORD BOUNDARY     #  00502000
         SLL   R1,3                                                  #  00503000
         ST    R2,0(,R1)           PUT STRING LENGTH IN RECORD       #  00504000
         L     R3,OSPARMAD                                           #  00505000
         BCTR  R2,0                                                  #  00506000
         EX    R2,OSPRMMVC         MOVE STRING INTO RECORD           #  00507000
         ST    R1,OSPRMPTR         SET POINTER TO RECORD             #  00508000
         B     OSPARM2                                               #  00509000
OSPRMMVC MVC   4(0,R1),0(R3)                                         #  00510000
OSPARM1  BCTR  R2,0                SET POINTER TO NIL                #  00511000
         ST    R2,OSPRMPTR                                           #  00512000
OSPARM2  ST    R1,NEWPTR                                             #  00513000
         DROP  R1                                                    #  00514000
*                                                                       00515000
*                                                                       00516000
*                                                                       00517000
*        DISABLE INTEGER OVERFLOW, EXPONENT UNDERFLOW AND               00518000
*        SIGNIFICANCE INTERRUPTS.                                       00519000
*                                                                       00520000
         BALR  R6,0                                                     00521000
         N     R6,=XL4'F0FFFFFF'   DISABLE MASKABLE INTERRUPT           00522000
         SPM   R6                                                       00523000
         SPACE ,                                                        00524000
         MVC   FL1,=X'4E00000000000000'  INITIALIZE FIX-FLOAT-FIX       00525000
         MVC   FL2,=X'4E00000080000000'  CONVERSION VALUES              00526000
         MVC   FL3,=X'0000000000000000'                                 00527000
         MVC   FL4,=X'4F08000000000000'                                 00528000
         SPACE ,                                                        00529000
         MVC   CHKSUBS(L'CALLSUBS),CALLSUBS  INIT. RUN TIME CHECK AREA  00530000
         SPACE                                                          00531000
         MVC   CLOCK,EXECTIME            SET THE ALARM CLOCK            00532000
         STIMER  TASK,$TIMEOUT,TUINTVL=CLOCK                            00533000
*                                                                       00534000
*        INITIALIZE DATE/TIME PREDEFINED VARIABLES                      00535000
*                                                                       00536000
         TIME  DEC                 GET TOD IN TU                        00537000
         ST    R1,DATESAV               PUT DATE IN WORK AREA           00538000
         CP    DATESAV+2(2),=PL2'59'                                    00539000
         BNH   LY                                                       00540000
         TM    DATESAV+1,1              LEAP YEAR?                      00541000
         BNZ   NLY                      NO                              00542000
         TM    DATESAV+1,X'12'          LEAP YEAR?                      00543000
         BNM   LY                       YES                             00544000
NLY      AP    DATESAV+2(2),=P'1'                                       00545000
LY       LA    R4,JAN                                                   00546000
         LA    R3,12                                                    00547000
         ZAP   MONTH(3),=P'0'                                           00548000
MDLP     AP    MONTH(3),=P'1000'       BUMP MONTH                       00549000
         CP    DATESAV+2(2),0(2,R4)    THIS MONTH?                      00550000
         BNH   MDEND                    BR IF SO                        00551000
         SP    DATESAV+2(2),0(2,R4)    TRY NEXT                         00552000
         LA    R4,2(R4)                                                 00553000
         BCT   R3,MDLP                                                  00554000
MDEND    L     R3,DATESAV                                               00555000
         N     R3,=X'00FF0000'          GET YEAR                        00556000
         O     R3,MONTH-2               INSERT MONTH                    00557000
         L     R4,DATESAV               GET DAY                         00558000
         SRL   R4,4                                                     00559000
         N     R4,=X'000000FF'                                          00560000
         OR    R3,R4                                                    00561000
         ST    R3,DATESAV               PREPARE TO REFORMAT DATE        00562000
         UNPK  DATESAV(9),DATESAV(5)                                    00563000
         MVC   PASDATE(2),DATESAV+4    FIRST MOVE MONTH                 00564000
         MVC   PASDATE+3(2),DATESAV+6  THEN THE DAY                     00565000
         MVC   PASDATE+6(4),DATESAV    FOLLOWED BY YEAR                 00566000
         MVI   PASDATE+2,C'-'                                           00567000
         MVI   PASDATE+5,C'-'                                           00568000
*                                                                       00569000
*        FIX TIME OF DAY STRING                                         00570000
*                                                                       00571000
         ST    R0,DATESAV                                               00572000
         UNPK  DATESAV(7),DATESAV(4)     CONVERT TO EBCDIC              00573000
         MVC   PASTIME+6(2),DATESAV+4    MOVE SECONDS                   00574000
         MVC   PASTIME+3(2),DATESAV+2    THEN MINUTES                   00575000
         MVC   PASTIME(2),DATESAV        AND HOURS                      00576000
         MVI   PASTIME+2,C':'                                           00577000
         MVI   PASTIME+5,C':'            AND FORMAT THE STRING          00578000
         MVC   PASTIME+8(2),=C'  '       PAD WITH BLANKS                00579000
*                                                                       00580000
*        FINALLY CALL THE USER PROGRAM                                  00581000
*                                                                       00582000
         LA    1,STACK                                                  00583000
         L     LINK,=A($MAINBLK)                                        00584000
         BALR  RET,LINK                                                 00585000
*                                                                       00586000
*        CLOSE THE OPEN FILES AND RETURN TO OS                          00587000
*                                                                       00588000
         SR    R2,R2               RETURN CODE = ZERO  !                00589000
QUIT1    LA    R1,PXIT             CLOSE OPEN FILES / RETURN TO OS      00590000
         L     LINK,=A($PASCSP)                                         00591000
         BR    LINK               EXIT PASCAL PROGRAM                   00592000
*                                                                       00593000
*                                                                       00594000
*        GET THE NEXT INTEGER IN THE PARAMETER LIST                     00595000
*                                                                       00596000
GETNUM   BXH   R1,R8,NOPARM        QUIT IF NO MORE CHARS             #  00597000
         CLI   0(R1),C'='                                               00598000
         BNE   GETNUM             SKIP UNTIL THE FIRST '='              00599000
*                                                                       00600000
         SR    R3,R3                                                    00601000
         SR    R4,R4              CLEAR ACCUMULATOR                     00602000
*                                                                       00603000
NXTDIG   BXH   R1,R8,0(R7)         RETURN IF NO MORE CHARS           #  00604000
         CLI   0(R1),C'9'                                               00605000
         BHR   R7                 OR IF A NON DIGIT                     00606000
         IC    R3,0(R1)                                                 00607000
         SH    R3,=Y(C'0')                                              00608000
         BLR   R7                 IS ENCOUNTERED                        00609000
         MH    R4,=H'10'                                                00610000
         AR    R4,R3              OTHERWISE KEEP ACCUMULATING           00611000
         B     NXTDIG                                                   00612000
*                                                                       00613000
         EJECT                                                          00614000
****************************************************************        00615000
*                                                                       00616000
*        TABLE OF CALLS FOR RUN TIME CHECK ROUTINES. TO BE COPIED       00617000
*        ,EXACTLY AS IS, ONTO THE RUN TIME STACK.                       00618000
*                                                                       00619000
****************************************************************        00620000
*                                                                       00621000
CALSUB   DS    0F                                                       00622000
CALLINX  L     R15,INXCHK+8                                             00623000
         BR    R15                                                      00624000
         DC    A($INXCHK)                                               00625000
*                                                                       00626000
CALLRNG  L     R15,RNGCHK+8                                             00627000
         BR    R15                                                      00628000
         DC    A($RNGCHK)                                               00629000
*                                                                       00630000
CALLPRM  L     R15,PRMCHK+8                                             00631000
         BR    R15                                                      00632000
         DC    A($PRMCHK)                                               00633000
*                                                                       00634000
CALLPTR  L     R15,PTRCHK+8                                             00635000
         BR    R15                                                      00636000
         DC    A($PTRCHK)                                               00637000
*                                                                       00638000
CALLPTA  L     R15,PTACHK+8                                             00639000
         BR    R15                                                      00640000
         DC    A($PTACHK)                                               00641000
*                                                                       00642000
CALLSET  L     R15,SETCHK+8                                             00643000
         BR    R15                                                      00644000
         DC    A($SETCHK)                                               00645000
*                                                                       00646000
CALLSTK  L     R15,STKCHK+8                                             00647000
         BR    R15                                                      00648000
         DC    A($STKCHK)                                               00649000
*                                                                       00650000
CALLSUBS EQU   CALSUB,*-CALSUB                                          00651000
*                                                                       00652000
         DROP  R10                                                      00653000
         EJECT                                                          00654000
*                                                                       00655000
BUFSTORE DC    A(IOBUFSZE)                                              00656000
REQSTORE DC    A(MINSTORE,MAXSTORE)                                     00657000
ALOSTORE DS    2A                                                       00658000
OSPARMS  DS    A                   ADDRESS OF O.S. PARAMETERS        #  00659000
OSPARMAD DC    A(0)                POINTER TO O.S. STRING            #  00660000
USESTORE DC    A(8000)                                                  00661000
OLDPICA  DC    A(1)                                                  #  00662000
ERRLIMIT DC    F'1'                LIMIT ON NUMBER OF ERRORS            00663000
EXECTIME DC    XL4'7FFFFFFF'       DEFAULT TIME LIMIT                   00664000
OSPARML  DC    H'0'                LENGTH OF PARM STRING             #  00665000
DUMPFLAG DC    X'00'               X'FF' IF DUMP REQUESTED              00666000
SPIEFLAG DC    X'00'               X'FF' IF SPIE NOT TO BE ISSUED    #  00667000
SNAPFLAG DC    X'00'               X'FF' IF SNAPSHOT NOT TO BE CALLED#  00668000
*                                                                       00669000
DATESAV  DS    F         # THESE LOCATIONS TO SUCCEED WITH NO GAP       00670000
         DS    2F        #      UNPACKING BUFFER                        00671000
         DC    X'1900'   #                                              00672000
MONTH    DS    3X        #                                              00673000
JAN      DC    P'31,29,31,30,31,30,31,31,30,31,30,31'                   00674000
*                                                                       00675000
         LTORG ,                                                        00676000
         EJECT                                                          00677000
*********************************************************************** 00678000
*                                                                       00679000
*                                                                       00680000
*        INTERRRUPT PROCCESSING FOR PASCAL PROGRAMS                     00681000
*                                                                       00682000
*        ONLY FIXED/FLOAT DIVISION BY ZERO AND EXPONENT OVERFLOW        00683000
*        INTERRUPTS ARE EXPECTED TO BE CAUGHT HERE, OTHER INTERRUPTS    00684000
*        IN GENERAL ARE CAUSED BY STACK/HEAP OVER FLOW OR A BAD I/O     00685000
*        FILE SPECIFICATION AND OR MISSING APPROPRIATE DD STATEMENTS.   00686000
*                                                                       00687000
*********************************************************************** 00688000
         DS    0H                                                       00689000
         USING *,R15                                                    00690000
$PASINT  B     *+12                                                     00691000
         DC    X'7',C'$PASINT'                                          00692000
         MVC   INTDATA(32),0(R1)   SAVE ALL INTERRUPT DATA FOR       #  00693000
         STM   R3,R13,INTDATA+32   POSSIBLE INCLUSION IN ABEND DUMP  #  00694000
         LA    R0,PASINT1          GO TO PASINT1 VIA THE CONTROL     #  00695000
         ST    R0,8(R1)            PROGRAM TO CANCEL SPIE EXIT       #  00696000
         BR    R14                                                   #  00697000
         DROP  R15                                                   #  00698000
*                                                                       00699000
PASINT1  BALR  R11,0               RE-ESTABLISH ADDRESSABILITY       #  00700000
         USING *,R11                                                 #  00701000
         L     R1,=A(OLDPICA)      CANCEL THE SPIE TRAP              #  00702000
         L     1,0(R1)            THAT IS IN EFFECT                  #  00703000
         SPIE  MF=(E,(1))                                            #  00704000
*                                                                    #  00705000
*        GET INTERRUPT CODE AND POINT TO THE APPROPRIATE ERROR MESSAGE  00706000
*                                                                       00707000
         SR    R4,R4                                                    00708000
         IC    R4,INTDATA+7        GET THE INTERRUPT CODE            #  00709000
         LA    R8,2000(R4)             SET THE RETURN CODE              00710000
         IC    R4,MSGTBL(R4)                                            00711000
         LA    R3,MSGTXT+1(R4)         R3 --> ERROR MESSAGE             00712000
         IC    R4,MSGTXT(R4)           R4 --> MESSAGE LENGTH            00713000
         L     R14,INTDATA+8       GET LOCATION OF INTERRUPT         #  00714000
         CLI   SPUSERSA,X'FF'               SEE IF INTERR. IN SP MODULE 00715000
         BE    NOTINSP                                                  00716000
*                                                                       00717000
*        IF INTERRUPTION OCCURED WITHIN THE '$PASCSP' ROUTINE PATCH UP  00718000
*        A SAVE AREA TO POINT TO CALLERS SAVE AREA FOR A MEANINGFULL    00719000
*        ERROR MESSAGE.                                                 00720000
*                                                                       00721000
         L     R5,=A(SPUSERSA)              GET USER REGS               00722000
         LM    R12,R15,(R12-R1)*4(R5)       GET IMPORTANT VALUES        00723000
         LR    R10,R15                      SET PROC ENTRY POINT ADR    00724000
         ST    R13,FAKESA+4                 SET SAVE AREA CHAIN         00725000
         STM   R14,R15,FAKESA+12            SET RETURN ADR FIELD        00726000
         LA    R13,FAKESA                                               00727000
         L     R14,INTDATA+8       RESET INTERRUPT LOCATION          #  00728000
         B     KNOWNPRC                                                 00729000
*                                                                       00730000
*        SEE IF R10 POINTS TO THE BEGINING OF A PROC.                   00731000
*                                                                       00732000
NOTINSP  L     R12,=A(ALOSTORE)        GET THE STACK ADDRESS            00733000
         L     R12,0(R12)                                               00734000
         LA    R12,STACK-DYNSTORE(R12) POINT TO BASE OF THE STACK       00735000
         LA    R10,0(R10)                                               00736000
*        C     R10,=A($PASCSP)                                       #  00737000
*        BL    FIXENTRY                IF R10 IS OUT OF BOUND, SKIP  #  00738000
*        C     R10,=A($MAINBLK)                                      #  00739000
*        BH    FIXENTRY                                              #  00740000
         LH    R5,0(R10)               R10 IS WITHIN BOUND, SEE IF      00741000
         CH    R5,=XL2'47F0'           IT POINTS TO A PROC ENTRY POINT  00742000
         BNE   FIXENTRY                                                 00743000
         CR    R13,R12                 SEE IF SAVE AREA PTR IS          00744000
         BL    FIXENTRY                WITHIN BOUNDS                    00745000
         C     R13,NEWPTR-STACK(R12)                                    00746000
         BH    FIXENTRY                                                 00747000
         C     R10,16(R13)             CONSISTANCY CHECK                00748000
         BE    KNOWNPRC                THIS IS A USER PROCEDURE ?       00749000
*                                                                       00750000
*        R10 POINTS TO NOWHERE, FAKE A PROCEDURE HEADING                00751000
*                                                                       00752000
FIXENTRY ST    R12,4+FAKESA            CHAIN THE FAKE SAVE AREA         00753000
         L     R5,16(R12)              POINT TO $MAINBLK ENTRY POINT    00754000
         ST    R5,12+FAKESA            SET RET. ADR. FROM FAKE PROC     00755000
         LA    R10,FAKEPROC            POINT TO THE ENTRY OF FAKEPROC   00756000
         AR    R14,R10                 ALSO SET THE ERROR LOCATION ADR  00757000
         LA    R13,FAKESA                                               00758000
*                                                                       00759000
*        THIS IS THE ENTRY TO A FAKE PROC TO BE USED IF                 00760000
*        NO MEANINGFULL PROC IS FOUND AFTER AN INTRRUPT                 00761000
*                                                                       00762000
KNOWNPRC L     R15,=A($CHKMSG0)                                         00763000
         BR    R15                GO TO PRINT ERROR MESSAGE             00764000
*                                                                       00765000
         USING *,R15                                                    00766000
FAKEPROC B     *+12                                                     00767000
         DC    AL1(7),C'UNKNOWN'                                        00768000
*                                                                       00769000
FAKESA   DC    6F'0'                                                    00770000
*                                                                    #  00771000
         DC    CL8'INTDATA'                                          #  00772000
INTDATA  DS    19F                 INTERRUPT DATA                    #  00773000
*                                                                       00774000
MSGTBL   DC    AL1(0,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1)   00775000
         DC    AL1(IMSG2,IMSG1,IMSG2,IMSG3,IMSG1,IMSG1,IMSG2)           00776000
*                                                                       00777000
MSGTXT   DS    0C                                                       00778000
IM1      DC    AL1(L'IMSG1),C' PROGRAM INTERRUPT, SEE RETURN CODE.'     00779000
IMSG1    EQU   IM1-MSGTXT,*-IM1-1                                       00780000
IM2      DC    AL1(L'IMSG2),C' DIVISION BY ZERO '                       00781000
IMSG2    EQU   IM2-MSGTXT,*-IM2-1                                       00782000
IM3      DC    AL1(L'IMSG3),C' EXPONENT OVERFLOW '                      00783000
IMSG3    EQU   IM3-MSGTXT,*-IM3-1                                       00784000
         DC    C'    '                                                  00785000
         DROP  R11                                                      00786000
*                                                                       00787000
***************************************************************         00788000
*                                                                       00789000
*        END OF INTERRUPT HANDLING ROUTINE                              00790000
*                                                                       00791000
***************************************************************         00792000
         SPACE 2                                                        00793000
****************************************************************        00794000
*                                                                       00795000
*                                                                       00796000
*        PASCAL RUN TIME CHECK/ABORT ROUTINES                           00797000
*                                                                       00798000
*                                                                       00799000
*        THE $CHKMSG ROUTINE IS USED BY THE INTERRUPT HANDLER AS        00800000
*        WELL AS OTHER $PASCSP ROUTINES TO PRINT OUT DIAGNOSTIC         00801000
*        MESSAGES ON THE 'OUTPUT' FILE.                                 00802000
*                                                                       00803000
*                                                                       00804000
****************************************************************        00805000
*                                                                       00806000
*                                                                       00807000
*        RANGE CHECK ROUTINE                                            00808000
*                                                                       00809000
$RNGCHK  DS    0H                                                       00810000
         USING *,R15                                                    00811000
         CR    R2,R0    CHECK LOWER BOUND                               00812000
         BL    BADRNG                                                   00813000
         CR    R2,R1    CHECK UPPER BOUND                               00814000
         BNHR  R14      IF WITHIN BOUNDS, RETURN                        00815000
BADRNG   STM   R0,R15,CHKSVALL SAVE IN CASE RETURN                      00816000
         LA    R3,RNGMSG                                                00817000
         LA    R4,L'RNGMSG                                              00818000
         LA    R8,SUBERR    RETURN CODE                                 00819000
         B     $CHKMSG                                                  00820000
*                                                                       00821000
*                                                                       00822000
*        INDEX CHECK ROUTINE                                            00823000
*                                                                       00824000
$INXCHK  DS    0H                                                       00825000
         USING *,R15                                                    00826000
         CR    R2,R0    CHECK LOWER BOUND                               00827000
         BL    BADINX                                                   00828000
         CR    R2,R1    CHECK UPPER BOUND                               00829000
         BNHR  R14      IF WITHIN BOUNDS, RETURN                        00830000
BADINX   STM   R0,R15,CHKSVALL  SAVE IN CASE HAVE TO RETURN             00831000
         LA    R3,INXMSG                                                00832000
         LA    R4,L'INXMSG                                              00833000
         LA    R8,INXERR     SET RETURN CODE                            00834000
         B     $CHKMSG                                                  00835000
*                                                                       00836000
*                                                                       00837000
*        POINTER CHECK ROUTINE                                          00838000
*                                                                       00839000
*                                                                       00840000
$PTACHK  DS    0H                                                       00841000
         USING *,R15                                                    00842000
         SR    R0,R0                                                    00843000
         BCTR  R0,0     R0 <-- '-1'                                     00844000
         CR    R0,R2                                                    00845000
         BER   R14      NIL VALUE BEING ASSIGNED                        00846000
*                                                                       00847000
         BALR  R15,0    GO TO NEXT ROUTINE TO CNTINUE CHECKING          00848000
*                                                                       00849000
$PTRCHK  DS    0H                                                       00850000
         USING *,R15                                                    00851000
         LM    R0,R1,NEWPTR   LOAD POINTER RANGE                        00852000
         CR    R2,R0    CHECK LOWER BOUND                               00853000
         BL    BADPTR                                                   00854000
         CR    R2,R1    CHECK UPPER BOUND                               00855000
         BNHR  R14      IF WITHIN BOUNDS, RETURN                        00856000
BADPTR   STM   R0,R15,CHKSVALL SAVE IN CASE OF RETURN                   00857000
         LA    R3,PTRMSG                                                00858000
         LA    R4,L'PTRMSG                                              00859000
         LA    R8,PTRERR                                                00860000
         B     $CHKMSG                                                  00861000
*                                                                       00862000
*                                                                       00863000
*        PASSED PARAMETER CHECK ROUTINE                                 00864000
*                                                                       00865000
$PRMCHK  DS    0H                                                       00866000
         USING *,R15                                                    00867000
         CR    R2,R0    CHECK LOWER BOUND                               00868000
         BL    BADPRM                                                   00869000
         CR    R2,R1    CHECK UPPER BOUND                               00870000
         BNHR  R14      IF WITHIN BOUNDS, RETURN                        00871000
BADPRM   STM       R0,R15,CHKSVALL SAVE IN CASE OF RETURN               00872000
         LA    R3,PRMMSG                                                00873000
         LA    R4,L'PRMMSG                                              00874000
         LA    R8,PARERR     SET RETURN CODE                            00875000
         B     $CHKMSG                                                  00876000
*                                                                       00877000
*                                                                       00878000
*        SET MEMBER CHECK ROUTINE                                       00879000
*                                                                       00880000
$SETCHK  DS    0H                                                       00881000
         USING *,R15                                                    00882000
         CL    R2,=F'63'                                             #  00883000
         BNHR  R14                IF WITHIN BOUNDS, RETURN              00884000
BADSET   STM       R0,R15,CHKSVALL SAVE IN CASE OF RETURN               00885000
         LA    R3,SETMSG                                                00886000
         LA    R4,L'SETMSG                                              00887000
         LM    R0,R1,=F'0,63'                                           00888000
         LA    R8,SETERR                                                00889000
         B     $CHKMSG                                                  00890000
*                                                                       00891000
*        STACK/HEAP INTERFERENCE ERROR                                  00892000
*                                                                       00893000
$STKCHK  DS    0H                                                       00894000
         USING *,R15                                                    00895000
         LA    R3,STKMSG                                                00896000
         LA    R4,L'STKMSG                                              00897000
         LA    R8,STKERR                                                00898000
         B     $CHKMSG0                                                 00899000
*                                                                       00900000
*        'TIME OUT' ENTRY POINT                                         00901000
*                                                                       00902000
*        ASSUMES THAT R10 POINTS TO THE CURR PROC ENTRY POINT           00903000
*        THIS MAY NOT BE TRUE UNDER MFT OR SOME OTHER VARIANTS          00904000
*        OF THE OPERATING SYSTEM. ( 'STIMER' PECULIARITY )              00905000
*                                                                       00906000
$TIMEOUT DS    0H                 ENTRY TO TIME OUT ERROR               00907000
         BALR  R15,0                                                    00908000
         USING *,R15                                                    00909000
         L     R12,=A(ALOSTORE)   RESTORE STACK POINTER IN CASE !       00910000
         L     R12,0(R12)                                               00911000
         LA    R12,STACK-DYNSTORE(R12)                                  00912000
         LR    R13,R12                                                  00913000
*                                                                       00914000
         CLI   SPUSERSA,X'FF'     SEE IF TIMER WENT OFF IN '$PASCSP'    00915000
         BE    TIMEOUT2                                                 00916000
         LM    R1,R14,SPUSERSA     IF SO, RESTORE REGS ACCORDINGLY      00917000
         B     TIMEOUT4                                                 00918000
*                                                                       00919000
TIMEOUT2 L     R1,16          LOAD CVT ADDR                          #  00920000
         L     R1,0(,R1)      LOAD TCB WORDS ADDR                    #  00921000
         L     R1,4(,R1)      ADDR OF CURRENT TCB                    #  00922000
         L     R1,120(,R1)    ADDR OF TQE                            #  00923000
         L     R1,28(,R1)     ADDR OF RB                             #  00924000
         L     R1,20(,R1)     WORD2 OF OLD PSW (AT LAST)             #  00925000
         LA    R14,0(,R1)     SET ERROR LOC TO THIS ADDRESS          #  00926000
TIMEOUT3 C     R10,16(R13)        GO DOWN THE CALL CHAIN UP TO          00927000
         BE    TIMEOUT4           CURRENT PROC.                         00928000
         L     R13,8(R13)         PROCEED TO NEXT SAVE AREA             00929000
         B     TIMEOUT3                                                 00930000
*                                                                       00931000
TIMEOUT4 DS    0H                                                       00932000
         LA    R3,TIMMSG                                                00933000
         LA    R4,L'TIMMSG                                              00934000
         LA    R8,TIMERR                                                00935000
         B     $CHKMSG0                                                 00936000
*                                                                       00937000
*                                                                       00938000
*                                                                       00939000
*        THIS IS THE ENTRY POINT FOR RUN-TIME ERROR INDICATION          00940000
*        AND THE RELATED MESSAGES.                                      00941000
*                                                                       00942000
*                                                                       00943000
$CHKMSG0 BALR  R11,0              ENTRY POINT FOR FATAL ERRORS          00944000
         USING *,R11                                                    00945000
         MVI   NORETURN,X'FF'                                           00946000
         B     $CHKMSG3                                                 00947000
$CHKMSG  BALR  R11,0              ENTRY FOR (POSSIBLY) REPETABLE ERROR  00948000
         USING *,R11                                                    00949000
         MVI   NORETURN,X'00'                                           00950000
$CHKMSG3 BALR  R11,0                                                    00951000
         DROP  R15                                                      00952000
         USING *,R11                                                    00953000
         LA    R14,0(R14)                                               00954000
         LA    R15,0(R15)         GET RID OF FLAG BITS                  00955000
         STM   R14,R13,CHKSAVE    SAVE RELEVENT REGISTERS               00956000
*                                                                       00957000
         L     R2,SNAPADR                                               00958000
         LTR   R2,R2               IS SNAPSHOT LOADED ?                 00959000
         BZ    NOSNAP                                                   00960000
         L     R2,=A(SNAPFLAG)                                       #  00961000
         CLI   0(R2),X'00'         SNAPSHOT TO BE USED?              #  00962000
         BNE   NOSNAP              NO                                #  00963000
*                                                                       00964000
         ST    R8,CHKSAVE-4        SAVE ERROR CODE                      00965000
         GETMAIN EC,LV=SNAPAREA,A=SNAPLOCS                           #  00966000
         LTR   R15,R15             SUCCESSFUL ?                      #  00967000
         BNZ   NOSNAP              NOT ENOUGH SPACE FOR SNAPSHOT     #  00968000
         L     R1,SNAPLOCS                                           #  00969000
*        R1 POINTS TO THE BASE OF GOTTEN AREA                           00970000
         SR    R2,R2                                                    00971000
         BCTR  R2,0                R2 <-- '-1'                          00972000
         ST    R2,LCAFTMST(R1)     FIRST PARM OF 'SNAPSHOT'             00973000
         LA    R2,CHKSAVE-4        SECOND PARM OF 'SNAPSHOT'            00974000
         ST    R2,LCAFTMST+4(R1)                                        00975000
         L     R15,SNAPADR                                              00976000
         BALR  R14,R15                                                  00977000
         FREEMAIN R,LV=SNAPAREA,A=SNAPLOCS  RETURN THE AREA TO O.S.  #  00978000
         B     SNAPDONE                                                 00979000
*                                                                       00980000
NOSNAP   DS    0H                                                       00981000
         LA    R8,SNPERR(R8)                                            00982000
         L     R15,=A($PASCSP)    PREPARE TO CALL I/O MODULE            00983000
         LA    R9,OUTPUT          PICK THE FILE NAME                    00984000
         LA    R1,PREW            (RE)OPEN THE MESSAGE (OUTPUT) FILE    00985000
         BALR  R14,R15                                                  00986000
         LA    R1,PSKP                                               #  00987000
         LA    R2,2                                                  #  00988000
         BALR  R14,R15            SPACE PROPERLY                        00989000
*                                                                       00990000
         LA    R1,PWRS            THE FUNCTION (WRITE STRING)           00991000
         LA    R2,MSG1                                                  00992000
         LA    R4,L'MSG1                                                00993000
         LA    R3,9(R4)           STRING LENGTH AND FIELD WIDTH         00994000
         BALR  R14,R15                                                  00995000
*                                                                       00996000
         LA    R1,PWRI            WRITE LOCATION OF ERROR               00997000
         L     R2,CHKSAVE                                               00998000
         S     R2,CHKSAVE+(R10+2)*4    RELATIVE ADDRESS OF ERROR        00999000
         LA    R3,11                   LOCATION AND ITS FIELD WIDTH     01000000
         BALR  R14,R15                                                  01001000
*                                                                       01002000
         L     R2,CHKSAVE+4*(R10+2)    POINT TO PROC. ENTRY POINT       01003000
         MVC   MSG2PROC,5(R2)          AND MOVE THE PROC. NAME          01004000
         LA    R1,PWRS                                                  01005000
         LA    R2,MSG2                                                  01006000
         LA    R3,L'MSG2+7                                              01007000
         LR    R4,R3                                                    01008000
         BALR  R14,R15                                                  01009000
*                                                                       01010000
*        INDICATE THE TYPE OF RUN TIME ERROR                            01011000
*                                                                       01012000
         LA    R1,PSKP                                               #  01013000
         LA    R2,2                                                  #  01014000
         BALR  R14,R15                 NEW LINE                         01015000
         LA    R1,PWRS                                                  01016000
         LA    R2,MSG1                 ' **** '                         01017000
         LA    R4,7                                                     01018000
         LA    R3,9(R4)                                                 01019000
         BALR  R14,R15                                                  01020000
         LM    R2,R3,CHKSAVE+4*(R3+2)                                   01021000
         LR    R4,R3                                                    01022000
         BALR  R14,R15                                                  01023000
*                                                                       01024000
*        INDICATE THE STATMNT # OF THE ERROR LOCATION, IF ASKED FOR     01025000
*                                                                       01026000
         BAL   R6,PRNTLOC                                               01027000
         AIF   (&SYSTEM).SYS34                                          01028000
*                                                                       01029000
*        PRINT THE ERRONEOUS VALUE AND THE RANGE                        01030000
*                                                                       01031000
PRNTRNG  L     R0,CHKSAVE+4*(R15-R14)                                   01032000
         C     R0,=A($STKCHK)          THESE ERRORS DO NOT HAVE         01033000
         BNL   CALCHAIN                A RANGE TO BE PRINTED            01034000
*                                                                       01035000
         LA    R1,PWRS                                                  01036000
         LA    R2,MSG4                                                  01037000
         LA    R4,L'MSG4                                                01038000
         LA    R3,9(R4)                                                 01039000
         BALR  R14,R15                                                  01040000
         LA    R1,PWRI                                                  01041000
         L     R2,CHKSAVE+4*(R2+2)                                      01042000
         LA    R3,8                                                     01043000
         BALR  R14,R15                 PRINT THE OUT OF RANGE VALUE     01044000
         LA    R1,PWRS                                                  01045000
         LA    R2,MSG5                                                  01046000
         LA    R4,L'MSG5                                                01047000
         LR    R3,R4                                                    01048000
         BALR  R14,R15                                                  01049000
         LA    R1,PWRI                                                  01050000
         L     R2,CHKSAVE+4*(R0+2)                                      01051000
         LA    R3,8                                                     01052000
         BALR  R14,R15                 PRINT LOWER BOUND (OF THE RANGE) 01053000
         LA    R3,10                                                    01054000
         L     R2,CHKSAVE+4*(R1+2)                                      01055000
         BALR  R14,R15                 AND THE UPPER BOUND              01056000
         LA    R1,PSKP                                               #  01057000
         LA    R2,2                                                  #  01058000
         BALR  R14,R15                                                  01059000
*                                                                       01060000
.SYS34   ANOP                                                           01061000
CALCHAIN LA    R1,PSKP                                               #  01062000
         LA    R2,2                                                  #  01063000
         BALR  R14,R15                                                  01064000
         LA    R7,16                   SET MAX # OF LINKS TO BE TRACED  01065000
NXTLNK   CR    R13,R12                 SEE IF END OF STACK              01066000
         BE    CHAINDON                                                 01067000
         MVC   CALLED(7),5(R10)        MOVE CALLERS NAME                01068000
         L     R5,12(R13)              BACK UP TO THE HIGHER SAVE AREA  01069000
         L     R13,4(R13)                                               01070000
         L     R10,12+(R15-R14)*4(R13) ENTRY POINT OF THE 'CALLER'      01071000
         MVC   CALLER(7),5(R10)        MOVE CALLER'S 'NAME'             01072000
         LA    R2,MSG7                                                  01073000
         LA    R3,L'MSG7                                                01074000
         LR    R4,R3                                                    01075000
         LA    R1,PWRS                                                  01076000
         BALR  R14,R15                                                  01077000
         BAL   R6,PRNTLOC              PRINT WHEREABOUT OF THE CALL     01078000
         BCT   R7,NXTLNK               NEXT LEVEL IF NOT EXHAUSTED      01079000
CHAINDON DS    0H                                                       01080000
*                                                                       01081000
*                                                                       01082000
*        TIME TO EXIT                                                   01083000
*                                                                       01084000
ABORT    LA    R1,PWLN                 TERMINATE LINE BUFFER            01085000
         BALR  R14,R15                                                  01086000
*                                                                       01087000
SNAPDONE DS    0H                                                       01088000
         CLI   NORETURN,X'FF'          IF NO RETURN                     01089000
         BE    ABORT2                  THEN ABORT                       01090000
         L     R1,HEAPLIM                                               01091000
         USING DYN2STOR,R1                                              01092000
         L     R3,DYNERRC                                               01093000
         LA    R3,1(R3)                                                 01094000
         ST    R3,DYNERRC                                               01095000
         C     R3,DYNERRL                                               01096000
         BNL   ABORT2                                                   01097000
         DROP  R1                                                       01098000
         LM    R0,R15,CHKSVALL                                          01099000
         BR    R14                                                      01100000
ABORT2   DS    0H                                                       01101000
         L     R15,=A($PASCSP)                                          01102000
         LA    R9,OUTPUT                                                01103000
         LA    R1,PREW                 CLOSE THE MESSAGE FILE           01104000
         BALR  R14,R15                                                  01105000
         LR    R2,R8                                                    01106000
         LA    R1,PXIT                                                  01107000
         BR    R15                                                      01108000
*                                                                       01109000
*                                                                       01110000
PRNTLOC  DS    0H                                                       01111000
SKIP2    LA    R1,PSKP                                               #  01112000
         LA    R2,2                                                  #  01113000
         BALR  R14,R15                                                  01114000
         BR    R6            RETURN TO CALLER                           01115000
.SYS36   ANOP                                                           01116000
*                                                                       01117000
NORETURN DS    X                   IF X'FF' THEN CAN RETURN             01118000
         DS    0D                                                       01119000
CHKSVALL DS    18F                                                      01120000
CHKSAVE  DS    16F                 ALSO INCLUDES THE PREV. FOUR BYTES   01121000
*                                                                       01122000
SNAPADR  DC    V(SNAPSHOT)                                              01123000
SNAPAREA EQU   2048                APPROX SIZE OF SNAPSHOT LOCAL DATA#  01124000
SNAPLOCS DS    A                   ADDRESS OF TEMP SNAPAREA          #  01125000
*                                                                       01126000
*                                                                       01127000
RNGMSG   DC    C' SUBRANGE VALUE OUT OF RANGE '                         01128000
INXMSG   DC    C' INDEX VALUE OUT OF RANGE '                            01129000
PTRMSG   DC    C' POINTER VALUE OUT OF RANGE '                          01130000
PRMMSG   DC    C' ACTUAL PARAMETER OUT OF RANGE '                       01131000
STKMSG   DC    C' STACK/HEAP OVER/UNDER_FLOW '                          01132000
SETMSG   DC    C' SET MEMBER OUT OF RANGE '                             01133000
TIMMSG   DC    C' RUNNING OUT OF TIME '                                 01134000
ENDMSG   DC    C' '                                                     01135000
*                                                                       01136000
MSG1     DC    C' ****   RUN ERROR AT LOCATION :'                       01137000
*                                                                       01138000
MSG2     DC    C'  OF PROCEDURE :  '                                    01139000
MSG2PROC DS    CL7                                                      01140000
*                                                                       01141000
MSG3     DC    C'  BETWEEN P_STATEMENTS :'                              01142000
*                                                                       01143000
MSG4     DC    C' ****   THE OFFENDING VALUE :'                         01144000
*                                                                       01145000
MSG5     DC    C'  IS NOT IN THE RANGE :'                               01146000
*                                                                       01147000
MS7      DC    C'          ****   '                                     01148000
CALLED   DC    CL7' '                                                   01149000
MSG6     DC    C'  WAS CALLED BY :  '                                   01150000
CALLER   DC    CL7' '                                                   01151000
MSG7     EQU   MS7,*-MS7                                                01152000
*                                                                       01153000
         DROP  R11                                                      01154000
         LTORG                                                          01155000
         EJECT                                                          01156000
******************************************************************      01157000
*                                                                       01158000
*                                                                       01159000
*        PASCAL I/O AND STANDARD PROCEDURE (CSP) INTERFACE              01160000
*                                                                       01161000
*        FOLLOWING CODE INTERCEPTS ERRORS DETECTED BY FORTRAN        #  01162000
*        MATH. ROUTINES.  SUCH ROUTINES ARE PRESENT IF REFERRED      #  01163000
*        TO BY THE PASCAL PROGRAM.                                   #  01164000
*                                                                       01165000
******************************************************************      01166000
         SPACE 2                                                        01167000
         AIF   (&SYSTEM).SYS38                                          01168000
*                                                                       01169000
*        IHCERRM - CALLED BY FORTRAN MATH ROUTINES IN CASE OF ERROR     01170000
*                                                                       01171000
ERRMON   DS    0H                                                    #  01172000
IHCERRM  DS    0H                                                       01173000
IHOERRM  DS    0H                                                       01174000
IHNERRM  DS    0H                                                    #  01175000
         ENTRY IHCERRM,IHOERRM,IHOERRE,IHNERRM,IHNERRE,IHCERRE       #  01176000
         ENTRY  ERRMON                                               #  01177000
         USING IHCERRM,R15                                              01178000
         L     R1,0(R1)            GET 1ST ARG - PTR TO A(LEN),C'MSG'   01179000
         SR    R4,R4                                                    01180000
         IC    R4,3(R1)            GET THE MESSAGE LENGTH               01181000
         LA    R3,4(R1)            POINT TO MESSAGE TEXT                01182000
         NOPR  0                   WARNING - THE LOCATION ERRMON+19  #  01183000
         BC    0,0                 CAN BE OVERWRITTEN BY FORTRAN     #  01184000
         L     R15,=A($CHKMSG0)                                         01185000
         LA    R8,3001             SET RETURN CODE                      01186000
         BR    R15                 GIVE THE ERROR MSG                   01187000
         DROP  R15                                                      01188000
*                                                                       01189000
*        THE FOLLOWING IS FOR THE FORTRAN ERROR MESSAGES                01190000
*                                                                       01191000
IHCERRE  DS    0H                                                    #  01192000
IHNERRE  DS    0H                                                    #  01193000
IHOERRE  BR    R14                 THIS SHOULD NOT BE CALLED            01194000
         LTORG                                                       #  01195000
*                                                                       01196000
         SPACE 2                                                        01197000
.SYS38   ANOP                                                           01198000
         EJECT                                                          01199000
*****************************************************************       01200000
*                                                                       01201000
*                                                                       01202000
*        $PASCSP (PASCAL I/0) ENTRY POINT                               01203000
*                                                                       01204000
*                                                                       01205000
*****************************************************************       01206000
*                                                                       01207000
         DS    0D                                                       01208000
         USING *,15                                                     01209000
$PASCSP  B     *+12                BRANCH AROUND ID                     01210000
         DC    AL1(7),CL7'$PASCSP'                                      01211000
*                                                                       01212000
         STM   R1,R15,SPUSERSA      SAVE ONLY POTENTIALLY USEFULL ONES  01213000
         LA    R13,SPSYSTSA         SET UP SYSTEM SAVE AREA             01214000
         LR    R10,R15                                                  01215000
         LA    R11,2048(,R10)                                        #  01216000
         LA    R11,2048(,R11)      SET UP TWO BASE REGS              #  01217000
         DROP  R15                                                      01218000
         USING $PASCSP,R10,R11                                       #  01219000
         USING IHADCB-FILDCB,AE                                      #  01220000
*        SLA   R1,2                DECODE THE SUBROUTINE NUMBER         01221000
         L     R1,SUBTBL(R1)                                            01222000
         BR    R1                                                       01223000
         DS    0F                                                       01224000
SUBTBL   DC    A(GET,PUT,RES,RLN,REW,WLN,WRS,ELN)                       01225000
         DC    A(WRI,WRR,WRC,RDI,RDR,RDC)                               01226000
         DC    A(SIN,COS,EXP,LOG,SQT,ATN)                               01227000
         DC    A(EOF,XIT,RDS,TRP,SIO,EIO,CLK,FDF,PAG,CLS)               01228000
         DC    A(RDB,WRB,SKP,LIM,MSG)                                #  01229000
SPUSERSA DC    18XL4'FFFFFFFF'                                          01230000
*                                                                       01231000
*                                                                       01232000
*        (GET FETCH) GET A CHAR TO (AD)                                 01233000
*                                                                       01234000
FILGFE   LH    R1,FILPTR(AE)                                         #  01235000
         LA    R1,1(,R1)                                             #  01236000
         CH    R1,FILEND(AE)       TEST FOR END-OF-LINE              #  01237000
         BNL   FILGFE2             IF SO, GO AND PROVIDE A BLANK     #  01238000
         IC    R0,0(R1,AF)         PICK UP INPUT CHARACTER           #  01239000
FILGFE1  STC   R0,0(AD)             AND PUT INTO CALLER'S BUFFER     #  01240000
         STH   R1,FILPTR(AE)                                         #  01241000
         BR    R5                                                    #  01242000
FILGFE2  LA    R0,FILBLA           SET EOL CHARACTER                 #  01243000
         BE    FILGFE1             GO BACK TO RETURN EOL CHAR        #  01244000
*        B     FILGET              NEED TO GET A NEW INPUT RECORD    #  01245000
*                                                                       01246000
*        GET A RECORD TO (AF)                                           01247000
*                                                                       01248000
FILGET   DS    0H                                                       01249000
         TM    FILEOF(AE),1                                             01250000
         BOR   R5                  RETURN IF END-OF-FILE             #  01251000
         AIF   (&SYSTEM).SYS42                                          01252000
         CLI   FILOPN(AE),READOPN                                       01253000
         BNE   BADREAD             IF FILE NOT OPEN FOR READ, COMPLAIN  01254000
.SYS42   ANOP                                                           01255000
FILGET1  MVI   RRFLAG,0            CLEAR REREAD FLAG                 #  01256000
         GET   FILDCB(AE)          READ THE NEXT RECORD              #  01257000
         CLI   RRFLAG,0            TEST IF REREAD ASKED FOR          #  01258000
         BNE   FILGET1             IF SO, GO BACK AND TRY AGAIN      #  01259000
         ST    R1,FILBUF(AE)       STORE ADDRESS OF INPUT RECORD     #  01260000
         LR    AF,R1                                                 #  01261000
         LH    R1,FILBEG(AE)                                         #  01262000
         STH   R1,FILPTR(AE)       RESET CHAR. PTR                   #  01263000
         IC    R0,0(R1,AF)                                           #  01264000
         STC   R0,0(AD)            UPDATE CURRENT FILE ELEMENT       #  01265000
         MVC   FILEND(2,AE),DCBLRECL    RESET BUFFER LENGTH          #  01266000
         BR    R5                                                       01267000
*                                                                       01268000
*        (PUT-STORE) PUT A CHAR FROM (AD)                               01269000
*                                                                       01270000
FILPST   LH    R1,FILPTR(AE)                                            01271000
         CH    R1,FILEND(AE)       TEST IF BUFFER FULL               #  01272000
         BNL   FILPST1             CLEAR IT FIRST                    #  01273000
         IC    R0,0(AD)                                              #  01274000
         STC   R0,0(R1,AF)                                           #  01275000
         LA    R1,1(R1)            INCREMENT CHAR. PTR.              #  01276000
         STH   R1,FILPTR(AE)                                         #  01277000
         BR    R5                                                    #  01278000
FILPST1  ST    R5,FILPSTSV         SAVE RETURN ADDRESS               #  01279000
         BAL   R5,FILPUT           EMPTY THE BUFFER                  #  01280000
         L     R5,FILPSTSV                                           #  01281000
         B     FILPST                                                #  01282000
*                                                                       01283000
*        PUT A RECORD (FROM AF)                                         01284000
*                                                                       01285000
FILPUT   DS    0H                                                       01286000
         AIF   (&SYSTEM).SYS44                                          01287000
         CLI   FILOPN(AE),WRITEOPN                                      01288000
         BNE   BADWRITE            IF NOT OPEN FOR WRITE, THEN COMPLAIN 01289000
.SYS44   ANOP                                                           01290000
         ST    R5,FILPUTSV         SAVE RETURN REG                   #  01291000
         BAL   R5,FILEOLN          COMPLETE THE OUTPUT LINE          #  01292000
         L     R5,FILPUTSV         RESTORE RETURN REG                #  01293000
         LH    R0,FILPTR(AE)       R0 = NEXT CHARACTER POSN             01294000
         PUT   FILDCB(AE)          WRITE THE RECORD                  #  01295000
         ST    R1,FILBUF(AE)       SAVE ADDRESS OF NEXT OUTPUT BUFFER#  01296000
         MVC   FILEND(2,AE),DCBLRECL  RESET BUFFER LENGTH            #  01297000
         LR    AF,R1                                                 #  01298000
         AIF   (&SYSTEM).SYS415                                      #  01299000
         L     R0,FILLIM(AE)       LOAD LINES LIMIT                  #  01300000
         BCT   R0,FILPUT1          DECREMENT                         #  01301000
         ST    R0,FILLIM(AE)       OVERFLOW OF COUNTER               #  01302000
         B     LIMITERR                                              #  01303000
FILPUT1  ST    R0,FILLIM(AE)       PUT DECREMENTED COUNT BACK        #  01304000
.SYS415  ANOP                                                        #  01305000
*        B     FILCLR              I.E., NEXT LINE                   #  01306000
*                                                                    #  01307000
*        CLEAR THE OUTPUT BUFFER TO BLANKS                           #  01308000
*                                                                    #  01309000
FILCLR   LH    R1,FILBEG(AE)                                         #  01310000
         STH   R1,FILPTR(AE)       RESET CHAR. POINTER               #  01311000
         CLI   DCBRECFM,X'80'      JUMP IF F OR U-FORMAT             #  01312000
         BNL   FILCLR1                                               #  01313000
         TM    DCBRECFM,X'06'                                        #  01314000
         BZR   R5                  RETURN IF NO CONTROL CHAR NEEDED  #  01315000
         MVI   4(AF),FILBLA        SET DEFAULT CONTROL CHAR          #  01316000
         TM    DCBRECFM,X'04'                                        #  01317000
         BOR   R5                  RETURN IF ASCII CONTROL CHARS     #  01318000
         MVI   4(AF),X'09'         REPLACE WITH MACHINE CHAR         #  01319000
         BR    R5                                                    #  01320000
FILCLR1  LH    R15,FILEND(AE)      LOAD BUFFER LENGTH                #  01321000
         LA    R14,256                                               #  01322000
         LR    R1,AF               LOAD BUFFER ADDRESS               #  01323000
         MVI   0(AF),FILBLA                                          #  01324000
         SH    R15,=H'2'                                             #  01325000
         B     FILCLR3                                               #  01326000
FILCLR2  MVC   1(256,R1),0(R1)     PROPAGATE BLANKS                  #  01327000
         AR    R1,R14                                                #  01328000
         SR    R15,R14                                               #  01329000
FILCLR3  BMR   R5                                                    #  01330000
         CR    R15,R14                                               #  01331000
         BNL   FILCLR2                                               #  01332000
         EX    R15,CLRBUF          CLEAR REMAINDER OF BUFFER         #  01333000
         TM    DCBRECFM,X'02'                                        #  01334000
         BZR   R5                  RETURN IF NOT MACH CONTROL CHAR   #  01335000
         MVI   0(AF),X'09'                                           #  01336000
         BR    R5                                                    #  01337000
*                                                                    #  01338000
CLRBUF   MVC   1(0,R1),0(R1)       PROPAGATE BLANKS                  #  01339000
*                                                                       01340000
*        'END OF DATA' EXIT, THIS ROUTINE IS ENTERED WHENEVER           01341000
*        A 'GET' IS ISSUED FOR A FILE WHICH HAS REACHED THE             01342000
*        'END OF FILE' MARK. (I.E. NO MORE INPUT)                       01343000
*                                                                       01344000
EOD      DS    0H                                                       01345000
         LA    AG,FILDCB(AE)                                         #  01346000
         CLOSE ((AG))                                                   01347000
         TM    DCBBUFCB+3,1                                          #  01348000
         BO    EOD1                SKIP IF NO BUFFER POOL            #  01349000
         FREEPOOL (AG)                                               #  01350000
EOD1     EQU   *                                                     #  01351000
         OI    FILEOF(AE),1                                             01352000
         MVI   FILOPN(AE),0         CLEAR THE OPEN FLAG                 01353000
         MVI   0(AD),FILBLA        SET EOL CHARACTER                 #  01354000
         SR    AF,AF               INDICATE NO I/O BUFFER            #  01355000
         STH   AF,FILBEG(AE)       RESET VARIOUS POINTERS            #  01356000
         STH   AF,FILEND(AE)                                         #  01357000
         STH   AF,FILPTR(AE)                                         #  01358000
         ST    AF,FILBUF(AE)                                         #  01359000
         BR    R5                                                    #  01360000
*                                                                    #  01361000
*        PREPARE THE OUTPUT BUFFER FOR TRANSMITTING TO O.S.          #  01362000
*                                                                    #  01363000
FILEOLN  DS    0H                                                    #  01364000
         CLI   DCBRECFM,X'80'                                        #  01365000
         BNLR  R5                  RETURN IF F OR U-FORMAT           #  01366000
         LA    R0,6                MIN LENGTH FOR VBA RECORDS        #  01367000
         TM    DCBRECFM,X'06'                                        #  01368000
         BNZ   *+6                 JUMP IF CONTROL CHARS             #  01369000
         BCTR  R0,0                ADJUST MIN LENGTH                 #  01370000
         LH    R1,FILPTR(AE)                                         #  01371000
         CR    R1,R0                                                 #  01372000
         BNL   FILEOLN1            JUMP IF RECORD SIZE OK            #  01373000
         LTR   AF,AF               RETURN IF THE I/O BUFFER IS NOT   #  01374000
         BZR   R5                  ALLOCATED  (FILE NEWLY OPENED)    #  01375000
         LA    R0,FILBLA                                             #  01376000
         STC   R0,0(R1,AF)         PROVIDE 1 CHAR AT LEAST           #  01377000
         LA    R1,1(R1)                                              #  01378000
FILEOLN1 STH   R1,0(AF)            SET RDW FOR V-FORMAT              #  01379000
         BR    R5                                                    #  01380000
*                                                                    #  01381000
*        EXIT ROUTINE CALLED WHEN DCB IS OPENED                      #  01382000
*              IN THIS ROUTINE, WE PROVIDE SOME REASONABLE DEFAULTS  #  01383000
*              FOR THE RECFM, LRECL, BLKSIZE AND BUFNO ATTRIBUTES    #  01384000
*              THIS ROUTINE ALSO SETS THE REREAD FLAG WHEN NEEDED    #  01385000
*              AT THE CHANGE-OVER BETWEEN TWO CONCATENATED           #  01386000
*              INPUT FILES.                                          #  01387000
*                                                                    #  01388000
XLSTRTIN LA    R1,DEFAULTS         ENTRY FOR INPUT AND INOUT FILES   #  01389000
         TM    DCBOFLGS,X'08'      TEST IF CONCAT. FLAG SET          #  01390000
         BZ    XLSTRT1                                               #  01391000
         MVI   RRFLAG,X'FF'        REQUEST A REREAD                  #  01392000
         B     XLSTRT2                                               #  01393000
XLSTRT1  OI    DCBOFLGS,X'08'      REQUEST PROCESSING OF CONCAT FILES#  01394000
XLSTRT2  SR    R0,R0                                                 #  01395000
         CLI   DCBBUFNO,0                                            #  01396000
         BNE   XLSTRT3             JUMP IF BUFNO PROVIDED            #  01397000
         MVC   DCBBUFNO(1),4(R1)                                     #  01398000
XLSTRT3  TM    DCBRECFM,X'FE'                                        #  01399000
         BNE   XLSTRT4             JUMP IF RECFM SPECIFIED           #  01400000
         OC    DCBRECFM(1),5(R1)                                     #  01401000
XLSTRT4  LH    R15,0(R1)           LOAD TARGET BYTES PER RECORD      #  01402000
         CH    R0,DCBLRECL                                           #  01403000
         BNE   XLSTRT5             JUMP IF LRECL SPECIFIED           #  01404000
         TM    DCBRECFM,X'C0'                                        #  01405000
         BO    XLSTRT5             JUMP IF U-FORMAT (LEAVE LRECL=0)  #  01406000
         CLI   DCBRECFM,X'80'                                        #  01407000
         BNL   *+8                 JUMP IF F-FORMAT                  #  01408000
         LA    R15,4(R15)          ALLOW FOR RDW/SDW IN RECORD LENGTH#  01409000
         TM    DCBRECFM,X'06'                                        #  01410000
         BZ    *+8                 JUMP IF NO CONTROL CHAR.          #  01411000
         LA    R15,1(R15)          ADD IN 1 BYTE FOR CONTROL CHAR    #  01412000
         STH   R15,DCBLRECL                                          #  01413000
XLSTRT5  CH    R0,DCBBLKSI                                           #  01414000
         BNER  R14            RETURN IF BLKSIZE SPECIFIED            #  01415000
         LH    R1,2(R1)       LOAD TARGET BLKSIZE                    #  01416000
         CLI   DCBRECFM,X'80'                                        #  01417000
         BNL   XLSTRT6        JUMP IF NOT V-FORMAT                   #  01418000
         LA    R15,4(R15)     LRECL+4 IS MINIMUM BLKSIZE             #  01419000
         B     XLSTRT7                                               #  01420000
XLSTRT6  TM    DCBRECFM,X'C0'                                        #  01421000
         BO    XLSTRT8        JUMP IF RECFM=U                        #  01422000
         DR    R0,R15         THEREFORE, RECFM=F HERE                #  01423000
         MR    R0,R15                                                #  01424000
XLSTRT7  CR    R1,R15                                                #  01425000
         BL    XLSTRT8                                               #  01426000
         LR    R15,R1                                                #  01427000
XLSTRT8  STH   R15,DCBBLKSI                                          #  01428000
         BR    R14                                                   #  01429000
XLSTRTOT LA    R1,DEFAULTS         ENTRY FOR OUTPUT DCB'S            #  01430000
         C     AE,=A(FILOUT)       TEST IF FILE IS "OUTPUT"          #  01431000
         BNE   XLSTRT2             IT USES DIFFERENT DEFAULTS        #  01432000
         LA    R1,OUTDFLTS                                           #  01433000
         B     XLSTRT2                                               #  01434000
*                                                                       01435000
*        RESET AN INPUT FILE                                            01436000
*                                                                       01437000
*                                                                       01438000
         DC    CL4'RES '                                                01439000
RES      DS    0H                                                       01440000
         LA    R0,FILCOUNT+INPUT   LAST+1 FILE ADDRESS                  01441000
         CR    AD,R0                                                    01442000
         BNL   BADREAD             RESETTING A NON EXISTANT FILE ?      01443000
         FILADR ,                                                       01444000
         BAL   R5,FILCLOS          GO AND CLOSE THE FILE             #  01445000
*                                                                       01446000
*        (GET) OPEN A FILE                                              01447000
*                                                                       01448000
FILGOP   MVI   FILOPN(AE),0        CLEAR OPEN FLAG                      01449000
         LA    AG,FILDCB(AE)                                         #  01450000
         OPEN  ((AG),(INPUT))                                           01451000
         TM    DCBOFLGS,X'10'                                           01452000
         BNO   BADREAD                                                  01453000
         LH    R1,DCBLRECL                                              01454000
         TM    DCBRECFM,X'C0'                                        #  01455000
         BNO   *+8                 JUMP IF NOT U-FORMAT              #  01456000
         LH    R1,DCBBLKSI                                           #  01457000
         STH   R1,FILEND(AE)       SET LRECL FOR THE LOCAL BUF          01458000
         NI    FILEOF(AE),255-1    SET FLAGS, PTRS, ETC.                01459000
         MVI   FILOPN(AE),READOPN                                       01460000
         XC    FILBEG(2,AE),FILBEG(AE)  RESET CHAR. START POS.       #  01461000
         CLI   DCBRECFM,X'80'                                        #  01462000
         BNL   FILGOP1             JUMP IF NOT V-FORMAT              #  01463000
         MVI   FILBEG+1(AE),4      ALLOW 4-BYTE RDW/SDW              #  01464000
FILGOP1  TM    DCBRECFM,X'06'                                        #  01465000
         BZ    FILGOP2             JUMP IF NO CONTROL CHARS          #  01466000
         CLI   CCFLAG,0            OR IF CONTROL CHARS ARE NOT       #  01467000
         BE    FILGOP2             TO BE INSERTED                    #  01468000
         OI    FILBEG+1(AE),1      ADD IN 1-BYTE CONTROL CHAR        #  01469000
FILGOP2  EQU   *                                                     #  01470000
         BAL   R5,FILGET                                                01471000
         B     RTN                 RETURN TO PASCAL PROGRAM             01472000
*                                                                       01473000
*                                                                       01474000
*                                                                       01475000
         DC    CL4'GET'                                                 01476000
GET      FILADR ,                                                       01477000
         TM    FILEOF(AE),1                                             01478000
         BO    RTN                                                      01479000
         BAL   R5,FILGFE                                                01480000
         B     RTN                                                      01481000
*                                                                       01482000
*                                                                       01483000
*                                                                       01484000
         DC    CL4'EOF '                                                01485000
EOF      FILADR ,                                                       01486000
         LA    RSLT,TRUE                                                01487000
         TM    FILEOF(AE),1                                             01488000
         BO    RTN                                                      01489000
         AIF   (&SYSTEM).SYS46                                          01490000
         CLI   FILOPN(AE),READOPN                                       01491000
         BNE   BADREAD             COMPLAIN IF 'EOF' ON OUTPUT FILE     01492000
.SYS46   ANOP                                                           01493000
         SR    RSLT,RSLT                                                01494000
         B     RTN                                                      01495000
*                                                                       01496000
*                                                                       01497000
*                                                                       01498000
         DC    CL4'RLN'                                                 01499000
RLN      FILADR ,                                                       01500000
         BAL   R5,FILGET                                                01501000
         B     RTN                                                      01502000
*                                                                       01503000
*                                                                       01504000
*                                                                       01505000
         DC    CL4'ELN '                                                01506000
ELN      FILADR ,                                                       01507000
         LA    RSLT,TRUE                                                01508000
         TM    FILEOF(AE),1                                             01509000
         BO    RTN                                                      01510000
         AIF   (&SYSTEM).SYS48                                          01511000
         CLI   FILOPN(AE),READOPN                                       01512000
         BNE   BADREAD             COMPLAIN IF 'ELN' ON OUTPUT FILE     01513000
.SYS48   ANOP                                                           01514000
         CLC   FILPTR(2,AE),FILEND(AE)  CHECK IF AT END OF LINE      #  01515000
         BE    RTN                                                      01516000
         SR    RSLT,RSLT                                                01517000
         B     RTN                                                      01518000
*                                                                       01519000
*                                                                       01520000
*        RDB, (READ BOOLEAN)   ADR(FILE),ADR(BOOLEAN)                #  01521000
*                                                                       01522000
RDB      FILADR ,                                                    #  01523000
RDB1     CLI   0(AD),FILBLA                                          #  01524000
         BNE   RDB3                SCAN FOR NON-BLANK                #  01525000
RDB2     BAL   R5,FILGFE                                             #  01526000
         TM    FILEOF(AE),1                                          #  01527000
         BO    EOFREAD             ERROR IF END-OF-FILE              #  01528000
         B     RDB1                                                  #  01529000
RDB3     LA    RSLT,TRUE                                             #  01530000
         CLI   0(AD),C'T'          T = TRUE ?                        #  01531000
         BE    RDB4                                                  #  01532000
         CLI   0(AD),C'F'          F = FALSE ?                       #  01533000
         BNE   BADBOOL             NEITHER = AN ERROR                #  01534000
         SR    RSLT,RSLT                                             #  01535000
RDB4     STC   RSLT,0(R2)          STORE THE RESULT                  #  01536000
         BAL   R5,FILGFE           STEP TO FOLLOWING CHAR            #  01537000
         B     RTN                                                   #  01538000
*                                                                       01539000
*                                                                       01540000
         DC    CL4'RDC'                                                 01541000
*                                                                       01542000
*        RDC  ADR(FILE),ADR(CHAR)                                       01543000
*         AD : FILE ADDRESS, R2 : ADDRESS FOR THE 'CHAR'                01544000
RDC      FILADR ,                                                       01545000
         TM    FILEOF(AE),1                                             01546000
         BO    RTN                                                      01547000
         IC    R0,0(AD)                                                 01548000
         STC   R0,0(R2)                                                 01549000
         BAL   R5,FILGFE                                                01550000
         B     RTN                                                      01551000
*                                                                       01552000
*        RDI    AD: ADR(FILE),  R2: ADR(INT)                            01553000
*                                                                       01554000
         DC    CL4'RDI'                                                 01555000
RDI      FILADR ,                                                       01556000
         LR    R4,R2               CLEAR A REGISTER PAIR  (R2,R3)       01557000
         SR    R3,R3                                                    01558000
         MVI   SIGN,1              ASSUME POSITIVE                      01559000
RDI1     CLI   0(AD),FILBLA                                             01560000
         BNE   RDI2                                                     01561000
RDI11    BAL   R5,FILGFE                                                01562000
         TM    FILEOF(AE),1                                          #  01563000
         BO    EOFREAD             ERROR IF END-OF-FILE              #  01564000
         B     RDI1                                                     01565000
RDI2     CLI   0(AD),FILPLU                                             01566000
         BE    RDI23                                                 #  01567000
         CLI   0(AD),FILMIN                                             01568000
         BNE   RDI25                                                    01569000
         MVI   SIGN,0              CHANGE TO NEGATIVE                   01570000
RDI23    BAL   R5,FILGFE                                             #  01571000
RDI25    LA    R15,BADINT          PREPARE ERROR RT ADDRESS          #  01572000
RDI4     SR    R0,R0                                                 #  01573000
         IC    R0,0(AD)            GET DIGIT                         #  01574000
         SH    R0,=AL2(FILZER)                                       #  01575000
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #  01576000
         CH    R0,=AL2(9)                                            #  01577000
         BHR   R15                                                   #  01578000
         M     R2,=F'10'                                             #  01579000
         AR    R3,R0                                                    01580000
         BAL   R5,FILGFE                                                01581000
         BAL   R15,RDI4            LOOP BACK & SET EXIT ADDRESS      #  01582000
RDI5     TM    SIGN,1                                                   01583000
         BO    *+6                                                      01584000
         LCR   R3,R3                                                    01585000
         ST    R3,0(R4)                                                 01586000
         B     RTN                                                      01587000
*                                                                       01588000
*                                                                       01589000
*  RDS, (READ STRING), R2= STRING ADDRESS, R3=STRING LENGTH !           01590000
*                                                                       01591000
         DC    CL4'RDS'                                                 01592000
*                                                                       01593000
RDS      FILADR ,                                                       01594000
         TM    FILEOF(AE),1                                             01595000
         BO    RTN                                                      01596000
         LH    R1,FILPTR(AE)                                            01597000
         IC    R0,0(AD)            START WITH CURRENT CHARACTER      #  01598000
RDSNXTCH STC   R0,0(R2)            COPY CHARS ONE-BY-ONE             #  01599000
         LA    R2,CHR(R2)                                            #  01600000
         LA    R1,1(,R1)                                             #  01601000
         CH    R1,FILEND(AE)       END OF THIS LINE?                 #  01602000
         BL    RDSF1               IF NOT, JUMP                      #  01603000
         LA    R0,FILBLA           END OF LINE CHARACTER             #  01604000
         BE    RDSF2               JUMP IF FIRST CHAR AFTER EOLN     #  01605000
         BAL   R5,FILGET           REFILL THE LINE BUFFER            #  01606000
         LH    R1,FILPTR(AE)                                         #  01607000
RDSF1    IC    R0,0(R1,AF)         LOAD NEXT INPUT CHAR              #  01608000
RDSF2    BCT   R3,RDSNXTCH         REPEAT                            #  01609000
         STC   R0,0(AD)                                                 01610000
         STH   R1,FILPTR(AE)                                            01611000
         CH    R1,FILEND(AE)                                            01612000
         BNH   RTN                                                      01613000
         BAL   R5,FILGET           NEED TO REFIL THE BUFFER             01614000
         B     RTN                                                      01615000
*                                                                       01616000
*                                                                       01617000
*  REW, (REWRITE = REWIND FOR OUTPUT)                                   01618000
*                                                                       01619000
         DC    CL4'REW'                                                 01620000
REW      DS    0H                                                       01621000
         LA    R0,FILCOUNT+INPUT   LAST+1 FILE ADDRESS                  01622000
         CR    AD,R0                                                    01623000
         BNL   BADWRITE            REWRITING A NON EXISTANT FILE ?      01624000
         FILADR ,                                                       01625000
         BAL   R5,FILCLOS          GO AND CLOSE THE FILE             #  01626000
*                                                                       01627000
*        (PUT) OPEN A FILE                                              01628000
*                                                                       01629000
FILPOP   MVI   FILOPN(AE),0        PUT_OPEN THE FILE                    01630000
         LA    AG,FILDCB(AE)                                         #  01631000
         OPEN  ((AG),(OUTPUT))                                          01632000
         TM    DCBOFLGS,X'10'                                           01633000
         BNO   BADWRITE            REPORT ANY PROBLEM                   01634000
         MVI   FILOPN(AE),WRITEOPN SET FLAGS, BUF PTRS ETC.             01635000
         OI    FILEOF(AE),1                                             01636000
         SR    R0,R0                                                 #  01637000
         STH   R0,FILPTR(AE)       CLEAR BOTH LINE POSN PTR          #  01638000
         ST    R0,FILLIM(AE)       AND LINES LIMIT FOR FILE          #  01639000
         ST    R0,FILBUF(AE)       NULLIFY BUFFER POINTER            #  01640000
         LH    R1,DCBLRECL         GET LRECL FROM THE DCB            #  01641000
         TM    DCBRECFM,X'C0'                                        #  01642000
         BNO   *+12                JUMP IF NOT U-FORMAT              #  01643000
         LH    R1,DCBBLKSI                                           #  01644000
         STH   R1,DCBLRECL                                           #  01645000
         STH   R0,FILEND(AE)       NULL BUFFER LENGTH                #  01646000
         STH   R0,FILBEG(AE)       RESET CHAR. START POSITION        #  01647000
         CLI   DCBRECFM,X'80'                                        #  01648000
         BNL   FILPOP1             JUMP IF NOT V-FORMAT              #  01649000
         MVI   FILBEG+1(AE),4      ALLOW 4-BYTE RDW/SDW              #  01650000
FILPOP1  TM    DCBRECFM,X'06'      TEST IF CONTROL CHARS             #  01651000
         BZ    RTN                                                   #  01652000
         CLI   CCFLAG,0            RETURN IF CONTROL CHARS ARE NOT   #  01653000
         BE    RTN                 TO BE INSERTED                    #  01654000
         OI    FILBEG+1(AE),1      ADD 1-BYTE CONTROL CHAR.          #  01655000
         B     RTN                                                      01656000
*                                                                       01657000
*                                                                       01658000
*                                                                       01659000
         DC    CL4'PUT '                                                01660000
PUT      FILADR ,                                                       01661000
         TM    FILEOF(AE),1                                             01662000
         BZ    RTN                                                      01663000
         BAL   R5,FILPST                                                01664000
         B     RTN                                                      01665000
*                                                                       01666000
         DC    CL4'WLN '                                                01667000
WLN      FILADR ,                                                       01668000
*DJR     LH    R1,FILPTR(AE)                                         #  01669000
*DJR     CH    R1,FILEND(AE)       IF BUFFER IS MARKED "OVER-FULL",  #  01670000
*DJR     BNH   *+12                   WE WRITE IT OUT                #  01671000
         BAL   R5,FILPUT                                             #  01672000
*DJR     LH    R1,FILPTR(AE)                                         #  01673000
*DJR     BCTR  R1,0                                                  #  01674000
*DJR     STH   R1,FILEND(AE)       FLAG BUFFER AS "OVER-FULL"        #  01675000
         B     RTN                                                   #  01676000
*                                                                       01677000
*                                                                       01678000
*        WRB (WRITE BOOLEAN):  ADR(FILE),BOOLEAN,FIELD_WIDTH         #  01679000
*                                                                       01680000
WRB      LTR   R2,R2                                                 #  01681000
         BZ    WRB1                JUMP IF "FALSE"                   #  01682000
         LA    R2,=C'TRUE'                                           #  01683000
         LA    R4,4                                                  #  01684000
         B     WRS                                                   #  01685000
WRB1     LA    R2,=C'FALSE'                                          #  01686000
         LA    R4,5                                                  #  01687000
         B     WRS                                                   #  01688000
*                                                                       01689000
*                                                                       01690000
*        WRC   R1: ADR(FILE),  R3: FIELD_WIDTH,  R2: CHAR               01691000
*                                                                       01692000
         DC    CL4'WRC '                                                01693000
WRC      FILADR ,                                                       01694000
         BCTR  R3,0                                                     01695000
         LTR   R3,R3                                                    01696000
         BZ    WRC3                                                     01697000
         BM    RTN                                                      01698000
WRC2     MVI   0(AD),FILBLA                                             01699000
         BAL   R5,FILPST                                                01700000
         BCT   R3,WRC2                                                  01701000
WRC3     STC   R2,0(AD)                                                 01702000
         BAL   R5,FILPST                                                01703000
         B     RTN                                                      01704000
*                                                                       01705000
*     WRS   ADR(FILE): R1, STRLGTH: R4, FIELD_WIDTH:R3 ,R2: ADR(STING)  01706000
*                                                                       01707000
         DC    CL4'WRS '                                                01708000
WRS      FILADR ,                                                       01709000
         AIF   (&SYSTEM).SYS6                                           01710000
         LTR   R3,R3                                                    01711000
         BNP   RTN                 ZERO FIELD WIDTH, RETURN             01712000
.SYS6    ANOP                                                           01713000
         LH    R1,FILPTR(AE)                                            01714000
         LA    R0,FILBLA           FILL CHARACTER                       01715000
WRSB1    CR    R3,R4               COMPARE FLD_LGTH TO STR_LGTH         01716000
         BNH   WRSF2               NO NEED FOR FILL CHARS               01717000
         CH    R1,FILEND(AE)                                         #  01718000
         BL    WRSF1                                                 #  01719000
         BAL   R5,FILPUT           EMPTY THE FULL BUFFER             #  01720000
         LH    R1,FILPTR(AE)                                         #  01721000
         LA    R0,FILBLA                                             #  01722000
WRSF1    STC   R0,0(R1,AF)         PLANT NEXT BLANK IN BUFFER        #  01723000
         LA    R1,1(R1)            AND ADVANCE TO NEXT POSITION      #  01724000
         BCT   R3,WRSB1                                              #  01725000
*    NOW WE HAVE R3 <= R4                                               01726000
WRSF2    DS    0H                                                       01727000
WRSB2    CH    R1,FILEND(AE)                                         #  01728000
         BL    WRSF3                                                 #  01729000
         BAL   R5,FILPUT           EMPTY THE FULL BUFFER             #  01730000
         LH    R1,FILPTR(AE)                                         #  01731000
WRSF3    IC    R0,0(R2)            PICK UP NEXT CHAR IN STRING       #  01732000
         STC   R0,0(R1,AF)         AND PLANT IT IN BUFFER            #  01733000
         LA    R2,CHR(R2)          ADVANCE IN THE STRING             #  01734000
         LA    R1,1(R1)            ADVANCE IN THE BUFFER             #  01735000
         BCT   R3,WRSB2                                              #  01736000
         STH   R1,FILPTR(AE)                                            01737000
         B     RTN                                                      01738000
*                                                                       01739000
*                                                                       01740000
*        WRI ADR(FILE),WIDTH,INT                                        01741000
*                                                                       01742000
         DC    CL4'WRI '                                                01743000
WRI      DS    0H                                                    #  01744000
*        AIF   (&SYSTEM).SYS7                                        #  01745000
*        LTR   R3,R3                                                 #  01746000
*        BNP   RTN                 ZERO FIELD WIDTH - RETURN         #  01747000
*.SYS7   ANOP                                                        #  01748000
         CVD   R2,PINT                                               #  01749000
         MVC   ZINT,=X'402020202020202020202120'                        01750000
         LA    R1,ZINT+11                                               01751000
         EDMK  ZINT,PINT+2                                              01752000
         LTR   R2,R2                                                    01753000
         BNM   *+10                                                     01754000
         BCTR  R1,0                                                     01755000
         MVI   0(R1),C'-'                                               01756000
         LR    R2,R1                                                 #  01757000
         LA    R4,ZINT+L'ZINT                                        #  01758000
         SR    R4,R1                                                 #  01759000
         CR    R4,R3                                                 #  01760000
         BNH   WRS                 PRINT INTEGER AS A STRING         #  01761000
         LR    R3,R4               - BUT INCREASE FIELD WIDTH IF     #  01762000
         B     WRS                 NECESSARY TO PRINT ENTIRE NUMBER  #  01763000
*                                                                       01764000
*                                                                       01765000
*        RDR, READ THE NEXT (REAL) NUMBER INTO (GRG2)                   01766000
*                                                                       01767000
         DC    CL4'RDR'                                                 01768000
RDR      DS    0H                                                       01769000
         AIF   (&SYSTEM).SYS9                                           01770000
         FILADR ,                                                       01771000
         SDR   0,0                                                      01772000
         LA    R3,1                                                     01773000
RDR1     CLI   0(AD),FILBLA                                             01774000
         BNE   RDR2                                                     01775000
         BAL   R5,FILGFE                                                01776000
         TM    FILEOF(AE),1                                          #  01777000
         BO    EOFREAD             ERROR IF END-OF-FILE              #  01778000
         B     RDR1                                                     01779000
RDR2     CLI   0(AD),FILPLU                                             01780000
         BE    RDR3                                                     01781000
         CLI   0(AD),FILMIN                                             01782000
         BNE   RDR4                                                     01783000
         LCR   R3,R3                                                    01784000
RDR3     BAL   R5,FILGFE                                                01785000
RDR4     LA    R15,BADREAL         SET ERROR EXIT ADDRESS            #  01786000
RDR45    SR    R1,R1                                                 #  01787000
         IC    R1,0(AD)            GET CHARACTER                     #  01788000
         SH    R1,=AL2(FILZER)                                       #  01789000
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #  01790000
         CH    R1,=AL2(9)                                            #  01791000
         BHR   R15                                                   #  01792000
         MD    0,=D'10.0'                                            #  01793000
         SLA   R1,3                                                     01794000
         AD    0,DECTBL(R1)                                             01795000
         BAL   R5,FILGFE                                                01796000
         BAL   R15,RDR45           LOOP BACK & SET EXIT ADDRESS      #  01797000
RDR5     SR    R4,R4                                                    01798000
         CLI   0(AD),FILDOT                                             01799000
         BNE   RDR7                                                     01800000
         BAL   R5,FILGFE                                                01801000
RDR6     CLI   0(AD),FILZER                                             01802000
         BL    RDR7                                                     01803000
         CLI   0(AD),FILNIN                                             01804000
         BH    RDR7                                                     01805000
         MD    0,=D'10.0'                                               01806000
         SR    R1,R1                                                    01807000
         IC    R1,0(AD)                                                 01808000
         SH    R1,=AL2(FILZER)                                       #  01809000
         SLA   R1,3                                                     01810000
         AD    0,DECTBL(R1)                                             01811000
         BAL   R5,FILGFE                                                01812000
         BCTR  R4,0                                                     01813000
         B     RDR6                                                     01814000
RDR7     LTR   R3,R3                                                    01815000
         BNM   *+6                                                      01816000
         LCDR  0,0                                                      01817000
         CLI   0(AD),FILEXP                                             01818000
         BNE   RDR13                                                    01819000
         LA    R3,1                                                     01820000
RDR8     BAL   R5,FILGFE                                                01821000
         CLI   0(AD),FILBLA                                             01822000
         BE    RDR8                                                     01823000
         ST    R4,EXPONENT                                              01824000
         SR    R4,R4                                                    01825000
RDR9     CLI   0(AD),FILPLU                                             01826000
         BE    RDR10                                                    01827000
         CLI   0(AD),FILMIN                                             01828000
         BNE   RDR11                                                    01829000
         LCR   R3,R3                                                    01830000
RDR10    BAL   R5,FILGFE                                                01831000
RDR11    LA    R15,BADREAL         SET ERROR EXIT ADDRESS            #  01832000
RDR115   SR    R1,R1                                                 #  01833000
         IC    R1,0(AD)            GET CHARACTER                     #  01834000
         SH    R1,=AL2(FILZER)                                       #  01835000
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #  01836000
         CH    R1,=AL2(9)                                            #  01837000
         BHR   R15                                                   #  01838000
         MH    R4,=H'10'                                                01839000
         AR    R4,R1                                                    01840000
         BAL   R5,FILGFE                                                01841000
         BAL   R15,RDR115          LOOP BACK & SET EXIT ADDRESS      #  01842000
RDR12    LTR   R3,R3                                                    01843000
         BNM   *+6                                                      01844000
         LCR   R4,R4                                                    01845000
         A     R4,EXPONENT                                              01846000
RDR13    LTR   R4,R4                                                    01847000
         BZ    RDR16                                                    01848000
         BP    RDR14                                                    01849000
         LPR   R4,R4                                                    01850000
         B     RDR15                                                    01851000
RDR14    MD    0,=D'10.0'                                               01852000
         BCT   R4,RDR14                                                 01853000
         B     RDR16                                                    01854000
RDR15    DD    0,=D'10.0'                                               01855000
         BCT   R4,RDR15                                                 01856000
RDR16    STD   0,0(R2)             PUT THE RESULT IN PASCAL VARIABLE    01857000
         B     RTN                                                      01858000
.SYS9    ANOP                                                           01859000
*                                                                       01860000
*        WRR, REAL NUMBER IN FPRG2, FIELDWITH IN GRG3                   01861000
*                                                                       01862000
         DC    CL4'WRR'                                                 01863000
WRR      FILADR ,                                                       01864000
         SR    R2,R2         R2 <-- POWER OF 10                         01865000
         LTDR  FPR2,FPR2                                                01866000
         BNZ   WRR20                                                    01867000
*                                                                       01868000
*        PRINT 'ZERO' IN THE PROPER FORMAT                              01869000
*                                                                       01870000
         LTR   R4,R4         'F' FORMAT ?                               01871000
         BP    WRR14                                                    01872000
*        E-FORMAT ZERO                                                  01873000
         MVI   0(AD),FILBLA                                             01874000
         BAL   R5,FILPST                                                01875000
         BAL   R5,FILPST                                                01876000
         SH    R3,=H'4'                                                 01877000
         LR    R4,R3                                                    01878000
         B     WRR16                                                    01879000
*        F-FORMAT                                                       01880000
WRR14    SR    R3,R4                                                    01881000
         SH    R3,=H'2'                                                 01882000
         BNP   WRR16                                                    01883000
         MVI   0(AD),FILBLA                                             01884000
         BAL   R5,FILPST                                                01885000
         BCT   R3,*-4        PRINT LEADING BLANKS                       01886000
*                                                                       01887000
WRR16    MVI   0(AD),FILZER                                             01888000
         BAL   R5,FILPST                                                01889000
         MVI   0(AD),FILDOT                                             01890000
         BAL   R5,FILPST                                                01891000
         MVI   0(AD),FILZER                                             01892000
         BAL   R5,FILPST                                                01893000
*        PRINT TRAILING BLANKS                                          01894000
         SH    R4,=H'1'                                                 01895000
         BNP   RTN                                                      01896000
         MVI   0(AD),FILBLA                                             01897000
         BAL   R5,FILPST                                                01898000
         BCT   R4,*-4                                                   01899000
         B     RTN                                                      01900000
*                                                                       01901000
*        PRINT A NON_ZERO REAL NUMBER                                   01902000
*                                                                       01903000
WRR20    MVI   SIGN,X'00'                                               01904000
         MVI   EFORM,X'00'                                              01905000
         BP    WRR22                                                    01906000
         MVI   SIGN,X'01'    NEGATIVE VALUE, REMEMBER THE SIGN          01907000
         BCTR  R3,0          AND ADJUST FIELD WIDTH                     01908000
         LPDR  FPR2,FPR2                                                01909000
WRR22    LD    FPR0,=D'1.0E-12'                                         01910000
         MDR   FPR0,FPR2                                                01911000
         ADR   FPR2,FPR0                                                01912000
         LDR   FPR0,FPR2     SAVE THE ORIGINAL VALUE                    01913000
*                                                                       01914000
WRR24    CD    FPR2,=D'1.0'                                             01915000
         BNL   WRR26                                                    01916000
         MD    FPR2,=D'10.0'                                            01917000
         BCT   R2,WRR24                                                 01918000
WRR26    CD    FPR2,=D'10.0'                                            01919000
         BL    WRR30                                                    01920000
         DD    FPR2,=D'10.0'                                            01921000
         LA    R2,1(R2)                                                 01922000
         B     WRR26                                                    01923000
*                                                                       01924000
*        NOW WE HAVE  "1.0 <= FPR2 < 10"                                01925000
*        AND "FPR0 = FPR2 * (R2 ** 10)" .                               01926000
*                                                                       01927000
WRR30    LTR   R4,R4         SEE IF F_FORMAT REQUESTED                  01928000
         BP    WRR40                                                    01929000
*        PRINT THE VALUE IN E_FORM                                      01930000
         MVI   EFORM,X'01'   SET E_FORMAT FLAG                          01931000
         ST    R2,EXPONENT   SAVE EXPONENT VALUE                        01932000
         MVI   0(AD),FILBLA                                             01933000
         BAL   R5,FILPST                                                01934000
         LR    R4,R3         R4 <-- FIELD WIDTH (AT LEAST 9)            01935000
         SH    R4,=H'7'                                                 01936000
         TM    SIGN,X'01'                                               01937000
         BNZ   WRR32                                                    01938000
         MVI   0(AD),FILBLA  PRINT UP TO TWO LEADING BLANKS             01939000
         BAL   R5,FILPST                                                01940000
         BCTR  R4,0                                                     01941000
WRR32    LTR   R4,R4                                                    01942000
         BP    *+8                                                      01943000
         LA    R4,1                                                     01944000
         SR    R2,R2         ONLY ONE DIGIT BEFORE DECIMAL POINT        01945000
         B     WRR50                                                    01946000
*                                                                       01947000
*        F_FORMAT OUTPUT                                                01948000
*                                                                       01949000
WRR40    LTR   R2,R2                                                    01950000
         BNM   WRR44         SEE IF NEGATIVE EXPONENT                   01951000
         LDR   FPR2,FPR0     IF SO, USE THE ORIGINAL VALUE              01952000
         SR    R2,R2         ONLY ONE DIGIT BEFORE DECIMAL POINT        01953000
*                                                                       01954000
WRR44    SR    R3,R4         COMPUTE THE # OF LEADING BLANKS            01955000
         SR    R3,R2                                                    01956000
         SH    R3,=H'2'      R3 IS THE # OF LEADING BLANKS              01957000
         BNP   WRR50                                                    01958000
WRR46    MVI   0(AD),FILBLA                                             01959000
         BAL   R5,FILPST                                                01960000
         BCT   R3,*-4                                                   01961000
*                                                                       01962000
*        R2 # OF DIGITS BEFORE DECIMAL POINT                            01963000
*        R4 # OF DIGITS FOLLOWING DECIMAL POINT                         01964000
*                                                                       01965000
WRR50    TM    SIGN,X'01'                                               01966000
         BZ    WRR52                                                    01967000
         MVI   0(AD),FILMIN                                             01968000
         BAL   R5,FILPST                                                01969000
*                                                                       01970000
WRR52    LA    R2,1(R2)                                                 01971000
         BAL   R3,WRRDGTS                                               01972000
         BCT   R2,*-4                                                   01973000
         MVI   0(AD),FILDOT                                             01974000
         BAL   R5,FILPST                                                01975000
         BAL   R3,WRRDGTS                                               01976000
         BCT   R4,*-4                                                   01977000
         TM    EFORM,X'01'                                              01978000
         BZ    RTN                                                      01979000
*                                                                       01980000
*        PRINT THE EXPONENT FOR E_FORMAT OUTPUT                         01981000
*                                                                       01982000
         L     R4,EXPONENT                                              01983000
         MVI   0(AD),FILEXP                                             01984000
         BAL   R5,FILPST                                                01985000
         MVI   0(AD),FILPLU                                             01986000
         LTR   R4,R4                                                    01987000
         BNM   *+8                                                      01988000
         MVI   0(AD),FILMIN                                             01989000
         BAL   R5,FILPST                                                01990000
         LPR   R3,R4                                                    01991000
         SR    R2,R2                                                    01992000
         D     R2,=F'10'                                                01993000
         LA    R3,FILZER(R3)                                            01994000
         STC   R3,0(AD)                                                 01995000
         BAL   R5,FILPST                                                01996000
         LA    R2,FILZER(R2)                                            01997000
         STC   R2,0(AD)                                                 01998000
         BAL   R5,FILPST                                                01999000
         B     RTN                                                      02000000
*                                                                       02001000
*        THIS ROUTINE PRINTS THE NEXT DIGIT OF THE VALUE                02002000
*        IN FPR2, IT USES R3 FOR ITS RETURN ADDRESS                     02003000
*        IT IS ASSUMED THAT "0 <= FPR2 < 10" AND FPR2                   02004000
*        IS UPDATED FOR THE NEXT DIGIT                                  02005000
*                                                                       02006000
WRRDGTS  SR    R1,R1                                                 #  02007000
         LA    R1,1(R1)                                              #  02008000
         SD    FPR2,=D'1.0'                                          #  02009000
         BNM   WRRDGTS+2                                             #  02010000
         AD    FPR2,=D'1.0'                                          #  02011000
         LA    R1,FILZER-1(R1)                                       #  02012000
         STC   R1,0(AD)                                              #  02013000
         BAL   R5,FILPST           WRITE NEXT DIGIT                  #  02014000
         MD    FPR2,=D'10.0'                                         #  02015000
         BR    R3                 RETURN TO CALLER                      02016000
*                                                                       02017000
*                                                                       02018000
*        PAG   SKIP TO NEW PAGE                                         02019000
*                                                                       02020000
         DC    CL4'PAG'                                                 02021000
PAG      SR    R2,R2                                                 #  02022000
         BCT   R2,SKP1             SET R2 = -1, THEN USE SKP ROUTINE #  02023000
*                                                                    #  02024000
*                                                                    #  02025000
*        SKP - SKIP R2 INPUT OR OUTPUT LINES                         #  02026000
*                                                                    #  02027000
         DC    CL4'SKP'                                              #  02028000
SKP      LTR   R2,R2                                                 #  02029000
         BM    RTN                 FORCE NUMBER OF LINES TO BE       #  02030000
SKP1     FILADR ,                                                    #  02031000
         CLI   FILOPN(AE),READOPN                                    #  02032000
         BE    SKP7                JUMP IF AN INPUT FILE             #  02033000
         LA    R0,MAXSKIP                                            #  02034000
         CR    R2,R0                                                 #  02035000
         BL    *+6                 LIMIT NUMBER OF LINES TO "MAXSKIP"#  02036000
         LR    R2,R0                                                 #  02037000
         TM    DCBRECFM,X'06'      JUMP IF FILE DOES NOT HAVE        #  02038000
         BZ    SKP6                CARRIAGE CONTROL CHARS            #  02039000
         LA    R3,3                MAX NO. OF SKIPS PER RECORD       #  02040000
         TM    DCBRECFM,X'04'                                        #  02041000
         BNZ   SKP2                JUMP IF ANS CONTROL CHARS         #  02042000
         LTR   AF,AF               FORCE AN INITIAL PUT OPERATION IF #  02043000
         BNZ   SKP3                  NO I/O BUFFER YET ALLOCATED     #  02044000
SKP2     BAL   R5,FILPUT           CLEAR LINE BUFFER                 #  02045000
SKP3     CR    R2,R3                                                 #  02046000
         LR    R4,R2                                                 #  02047000
         BNH   *+6                                                   #  02048000
         LR    R4,R3               NOW, R4 = MIN( R2, 3 )            #  02049000
         LH    R1,FILBEG(AE)                                         #  02050000
         CLI   CCFLAG,0            DONT BACK UP POINTER              #  02051000
         BE    *+6                 UNLESS NOCC IN EFFECT             #  02052000
         BCTR  R1,0                                                  #  02053000
         TM    DCBRECFM,X'04'                                        #  02054000
         BZ    SKP5                JUMP IF MACHINE CHARS             #  02055000
         IC    R0,SKPASCII(R4)                                       #  02056000
         STC   R0,0(R1,AF)         SET ASCII CONTROL CHAR            #  02057000
         SR    R2,R4                                                 #  02058000
         BP    SKP2                REPEAT IF MORE LINES TO SKIP      #  02059000
         LA    R1,1(R1)                                              #  02060000
         STH   R1,FILPTR(AE)       POINT AT FIRST DATA BYTE          #  02061000
         B     RTN                                                   #  02062000
SKP5     IC    R0,SKPMACH(R4)                                        #  02063000
         STC   R0,0(R1,AF)         SET MACHINE CONTROL CHAR          #  02064000
         BAL   R5,FILPUT           AND SEND TO OUTPUT DEVICE         #  02065000
         SR    R2,R4                                                 #  02066000
         BP    SKP3                REPEAT IF MORE LINES TO SKIP      #  02067000
         B     RTN                                                   #  02068000
SKP6     BAL   R5,FILPUT           NO CONTROL CHARS                  #  02069000
         BCTR  R2,0                BUT GIVE AN APPROPRIATE NUMBER    #  02070000
         LTR   R2,R2               OF EMPTY OUTPUT RECORDS           #  02071000
         BP    SKP6                                                  #  02072000
         B     RTN                                                   #  02073000
SKP7     LTR   R2,R2               REJECT PAGE() ON AN INPUT FILE    #  02074000
         BM    BADWRITE                                              #  02075000
         BNZ   SKP8                JUMP IF > 0 SKIPS                 #  02076000
         LH    R1,FILBEG(AE)                                         #  02077000
         STH   R1,FILPTR(AE)       RESET CHAR PTR. TO REREAD LINE    #  02078000
         IC    R0,0(R1,AF)                                           #  02079000
         STC   R0,0(AD)            RESET CURRENT FILE ELEMENT        #  02080000
         B     RTN                                                   #  02081000
SKP8     BAL   R5,FILGET                                             #  02082000
         BCT   R2,SKP8             STEP THROUGH THE LINES            #  02083000
         B     RTN                                                   #  02084000
*                                                                       02085000
*                                                                       02086000
*        CLOCK FUNCTION                                                 02087000
*                                                                       02088000
         DC    CL4'CLK'                                                 02089000
CLK      TTIMER ,                                                       02090000
         S     R0,CLOCK            SUBTRACT START-UP TIME               02091000
         LCR   R1,R0                                                    02092000
         M     R0,=FS32'0.02604166'                                     02093000
         B     RTN                RETURNS THE RESULT IN R0              02094000
*                                                                       02095000
*        OBSOLETE MATH RT. HANDLING CODE.  ALL CALLS TO FORTRAN      #  02096000
*        ARE NOW DIRECT.  AN OLD PASCAL PROGRAM THAT ATTEMPTS TO     #  02097000
*        CALL THEM VIA THIS PROGRAM CAUSES AN ERROR MESSAGE.         #  02098000
*                                                                       02099000
         DC    CL4'MATH'                                                02100000
SIN      DS    0H                                                    #  02101000
COS      DS    0H                                                    #  02102000
EXP      DS    0H                                                    #  02103000
LOG      DS    0H                                                    #  02104000
SQT      DS    0H                                                    #  02105000
ATN      DS    0H                                                    #  02106000
         B     MATHERR             GO AND PRINT AN ERROR MESSAGE     #  02107000
*                                                                       02108000
*                                                                       02109000
*        MESSAGE PROCEDURE   R2=STRING ADDR,  R3=LENGTH              #  02110000
*                                                                    #  02111000
         DC    CL4'MSG'                                              #  02112000
MSG      LTR   R3,R3                                                 #  02113000
         BNP   RTN                                                   #  02114000
         LA    R0,MAXMSGL          SET MAXIMUM MESSAGE LENGTH        #  02115000
         CR    R3,R0                                                 #  02116000
         BNH   *+6                                                   #  02117000
         LR    R3,R0                                                 #  02118000
         EX    R3,MSGMVC                                             #  02119000
         LA    R3,4(R3)            CONSTRUCT VARIABLE-LENGTH RECORD  #  02120000
         STH   R3,SYNADMSG                                           #  02121000
         LA    R3,SYNADMSG(R3)                                       #  02122000
         MVC   0(4,R3),=X'00000020' SET THE ROUTING CODE             #  02123000
         MVC   SYNADMSG+2(2),=X'8000'                                #  02124000
         LA    R1,SYNADMSG                                           #  02125000
         SVC   35                  ISSUE WTO REQUEST                 #  02126000
         B     RTN                                                   #  02127000
MSGMVC   MVC   SYNADMSG+4(*-*),0(R2)                                 #  02128000
*                                                                    #  02129000
*        LINELIMIT PROCEDURE   AD=FILE,  R2=LIMIT                    #  02130000
*                                                                    #  02131000
         DC    CL4'LIM'                                              #  02132000
LIM      FILADR ,                                                    #  02133000
         ST    R2,FILLIM(AE)       SET THE NEW LIMIT                 #  02134000
         B     RTN                                                   #  02135000
*                                                                       02136000
*                                                                       02137000
*        DEFINE THE FILE NAME                                           02138000
*                                                                       02139000
         DC    CL4'FDF'                                                 02140000
FDF      DS    0H                                                       02141000
         LR    AE,AD                                                    02142000
         SR    AE,GBR              CONVERT FILE ADR TO FILE ID          02143000
         C     AE,=A(INPUT+FILCOUNT-STACK)                              02144000
         BNL   BADFDF                                                   02145000
         SLA   AE,2                                                     02146000
         L     AD,FILBLK-PASBUFAD*4(AE)                                 02147000
         LTR   AD,AD                                                    02148000
         BNZ   RTN                 FILE BLOCK ALREADY ALLOCATED         02149000
*                                                                       02150000
         LA    R3,FILBLK-PASBUFAD*4(AE)                              #  02151000
         GETMAIN EC,LV=L'#FILREC,A=(R3)                              #  02152000
         LTR   R15,R15             TEST IF STORAGE AVAILABLE         #  02153000
         BNZ   BADFDF                                                #  02154000
         L     AE,0(,R3)                                             #  02155000
*        MOVE FILE RECORD TEMPLATE TO THE GETMAINED AREA                02156000
         L     R3,=A(#FILREC)                                           02157000
         MVC   0(L'#FILREC,AE),0(R3)                                 #  02158000
         MVC   DCBDDNAM,0(R2)      MOVE THE FILE NAME TO ITS DCB FIELD  02159000
         B     RTN                                                      02160000
*                                                                    #  02161000
*        GENERAL ROUTINE TO CLOSE A FILE                             #  02162000
*                                                                    #  02163000
FILCLOS  TM    FILOPN(AE),1                                          #  02164000
         BNOR  R5                  RETURN IF FILE NOT OPEN           #  02165000
         CLI   FILOPN(AE),READOPN                                    #  02166000
         BE    FILCLOS1            JUMP IF AN INPUT FILE             #  02167000
         ST    R5,FILCLSSV                                           #  02168000
         BAL   R5,FILEOLN          COMPLETE THE OUTPUT BUFFER        #  02169000
         L     R5,FILCLSSV                                           #  02170000
FILCLOS1 LA    AG,FILDCB(AE)                                         #  02171000
         CLOSE ((AG))                                                #  02172000
         TM    DCBBUFCB+3,1        TEST IF BUFFER POOL THERE         #  02173000
         BOR   R5                  RETURN IF NOT                     #  02174000
         FREEPOOL (AG)             RELEASE THE POOL                  #  02175000
         BR    R5                                                    #  02176000
*                                                                       02177000
*                                                                       02178000
*        EXIT : TO EXIT USER PROGRAM WITH A RETURN CODE                 02179000
*                                                                       02180000
         DC    CL4'XIT'                                                 02181000
XIT      C     R2,=A(1000)         IF ERROR GO TO CLOSE/EXIT ROUTINE    02182000
         BNL   CLS                                                      02183000
         L     R4,HEAPLIM                                               02184000
         USING DYN2STOR,R4                                              02185000
         L     R5,DYNRUNC                                               02186000
         LTR   R5,R5               SEE IF RUN TIME COUNTERS ARE PRESENT 02187000
         BNP   CLS                 IF NOT, QUIT.                        02188000
         LR    R6,R2               SAVE RETURN CODE                     02189000
         LA    AD,QRR              PICK THE COUNTER FILE NAME           02190000
         LA    R1,PREW                                                  02191000
         LA    R15,$PASCSP                                              02192000
         BALR  R14,R15             CALL THE $PASCSP ROUTINES            02193000
*                                                                       02194000
*        THIS CAN BE DONE ONLY IF WE KNOW THAT WE DO NOT NEED           02195000
*        TO GO BACK TO THE PROGRAM WHICH CALLED THE EXIT                02196000
*        ROUTINE.                                                       02197000
*                                                                       02198000
         LA    R1,PWRI             SET THE FUNCTION CODE                02199000
         LA    R3,10               SET THE FIELD_WIDTH                  02200000
NXTCNT   L     R2,DYNCOUNT         PICK THE NEXT COUNT VALUE            02201000
         BALR  R14,R15             OUTPUT IT                            02202000
         LA    R4,4(R4)                                                 02203000
         BCT   R5,NXTCNT           REPEAT UNTIL DONE                    02204000
         DROP  R4                                                       02205000
*                                                                       02206000
         LA    R1,PWLN                                                  02207000
         BALR  R14,R15             OUTPUT THE LAST LINE                 02208000
         LR    R2,R6               RESTORE RETURN CODE                  02209000
*                                                                       02210000
         B     CLS                 GO TO COMPLETE EXIT EPILOGUE.        02211000
*                                                                       02212000
*       CLOSE ALL THE FILES                                             02213000
*                                                                       02214000
         DC    CL4'CLS '                                                02215000
CLS      L     AD,=A(FILBLK)                                         #  02216000
         LA    R3,FILCOUNT         INPUT,OUTPUT,PRD,...........         02217000
CLSB1    L     AE,0(AD)                                                 02218000
         LTR   AE,AE                IS THIS FILE DEFINED ?              02219000
         BZ    CLSF1                IF NOT, SKIP.                       02220000
         L     AF,FILBUF(AE)                                         #  02221000
         BAL   R5,FILCLOS          GO AND DO A FILE CLOSE            #  02222000
         C     AD,=A(FILBLK+6*4)   TEST IF BUILT-IN FILE             #  02223000
         BL    CLSF1               IF SO, JUMP                       #  02224000
         FREEMAIN R,LV=L'#FILREC,A=(AE)  RELEASE FILE BLOCK STORAGE  #  02225000
CLSF1    LA    AD,4(AD)                                                 02226000
         BCT   R3,CLSB1                                                 02227000
*                                                                       02228000
*        TIME TO EXIT                                                   02229000
*                                                                       02230000
         L     R1,=A(OLDPICA)                                           02231000
         TM    3(R1),1             TEST IF SPIE WAS ISSUED           #  02232000
         BO    SKIPSPIE            JUMP IF NOT                       #  02233000
         L     1,0(R1)             RESET OLD PICA ADDRESS               02234000
         SPIE  MF=(E,(1))                                               02235000
SKIPSPIE EQU   *                                                     #  02236000
*                                                                       02237000
*        CHECK FOR ABEND                                                02238000
*                                                                       02239000
         C         R2,=A(1000)     IF RETURN CODE < 1000                02240000
         BL        XIT2              THEN DON'T ABEND                   02241000
         L         R1,HEAPLIM                                           02242000
         USING     DYN2STOR,R1                                          02243000
         CLI       DYNABEND,X'FF'                                       02244000
         DROP      R1                                                   02245000
         BNE       XIT2                                                 02246000
         LR        R1,R2                                                02247000
         N         R1,=A(X'00000FFF')                                   02248000
         A         R1,=A(X'80000000')                                   02249000
         SVC       13                                                   02250000
XIT2     DS        0H                                                   02251000
         C     R2,=A(TIMERR)       SEE IF THIS IS A TIME OUT EXIT       02252000
         BE    XIT3                                                     02253000
         C     R2,=A(TIMERR+SNPERR)                                     02254000
         BNE   XIT4                                                     02255000
*                                                                       02256000
*        THIS ABEND IS BECAUSE THERE IS NO CLEAN AND EASY WAY           02257000
*        TO TERMINATE THE PROGRAM IN CASE OF A TIMER INTERRUPT !        02258000
*                                                                       02259000
XIT3     ABEND (R2)                                                     02260000
*                                                                       02261000
XIT4     LR    R13,R12             POINT TO STACK BASE               #  02262000
         S     R13,=A(STACK-DYNSTORE)                                #  02263000
         L     R13,4(R13)          POINT TO THE SYSTEM SAVE AREA     #  02264000
         FREEMAIN V,A=ALOSTORE     RELEASE STACK STORAGE             #  02265000
         LR    R15,R2              SET THE RETURN CODE               #  02266000
         L     R14,12(R13)         PICK THE RETURN ADDRESS              02267000
         LM    R0,R12,20(R13)      RESTORE OTHER REGS                   02268000
         BR    14                                                       02269000
*                                                                       02270000
*                                                                       02271000
*        UNDEFINED CSP ENTRIES                                          02272000
*                                                                       02273000
TRP      DS    0H                                                       02274000
SIO      DS    0H                                                       02275000
EIO      DS    0H                                                       02276000
*                                                                       02277000
*                                                                       02278000
*                                                                       02279000
*         RETURN TO PASCAL PROGRAM                                      02280000
*                                                                       02281000
RTN      LM    R1,R15,SPUSERSA      'RSLT' REG SHOULD NOT BE RESTORED ! 02282000
         AIF   (&SYSTEM).SYS92                                          02283000
         DROP                                                           02284000
         USING $PASCSP,R15                                              02285000
         MVI   SPUSERSA,X'FF'      CLEAR 'SP' FLAG                      02286000
.SYS92   ANOP                                                           02287000
         BR    14                                                       02288000
*                                                                       02289000
*        I/O ERROR CONDITIONS                                           02290000
*                                                                       02291000
         DROP                                                           02292000
         USING $PASCSP,R10,R11                                       #  02293000
BADFDF   LA    R0,FDFMSG                                             #  02294000
         B     ERRMSGRT                                              #  02295000
MATHERR  LA    R0,MATHMSG                                            #  02296000
         B     ERRMSGRT                                              #  02297000
LIMITERR LA    R0,LIMMSG                                             #  02298000
         B     ERRMSGRT                                              #  02299000
BADREAD  LA    R0,READMSG                                            #  02300000
         B     ERRMSGRT                                              #  02301000
EOFREAD  LA    R0,EOFMSG                                             #  02302000
         B     ERRMSGRT                                              #  02303000
BADBOOL  LA    R0,BOOLMSG                                            #  02304000
         B     ERRMSGRT                                              #  02305000
BADINT   LA    R0,INTMSG                                             #  02306000
         B     ERRMSGRT                                              #  02307000
BADREAL  LA    R0,REALMSG                                            #  02308000
         B     ERRMSGRT                                              #  02309000
*                                                                       02310000
         USING STACK,GBR                                                02311000
BADWRITE LA    R3,OUTPUT           IF BAD FILE IS "OUTPUT" WE HAVE   #  02312000
         CR    AD,R3          TO BY-PASS GENERATION OF ERROR         #  02313000
         BNE   BADWRIT1          MESSAGES  (OTHERWISE INFINITE LOOP) #  02314000
         WTO   'UNABLE TO USE "OUTPUT" FILE',ROUTCDE=11              #  02315000
         LA    R2,OUTERR                                             #  02316000
         B     XIT                                                   #  02317000
BADWRIT1 LA    R0,WRITEMSG                                           #  02318000
         B     ERRMSGRT                                              #  02319000
*                                                                    #  02320000
SYNADRT  EQU   *              GENERATES MESSAGE FOR FILE ERRORS      #  02321000
         LA    R3,OUTPUT                                             #  02322000
         CR    AD,R3          OBVIOUSLY, AN ERROR WITH "OUTPUT" FILE #  02323000
         BER   R14            CANT BE PRINTED, SO CONTINUE ABENDING  #  02324000
         SYNADAF ACSMETH=QSAM GENERATE THE ERROR DESCRIPTION         #  02325000
         MVC   SYNADMSG+1(78),50(R1) AND MOVE IT INTO LOCAL BUFFER   #  02326000
         SYNADRLS ,           NOW RELEASE THE SYSTEM'S BUFFER        #  02327000
         LA    R0,SYNMSG                                             #  02328000
*        B     ERRMSGRT                                              #  02329000
*                                                                       02330000
ERRMSGRT L     R15,=A($CHKMSG0)    RESTORE USER'S REGISTERS          #  02331000
         LM    R1,R14,SPUSERSA                                       #  02332000
         LR    R3,R0                                                 #  02333000
         LH    R8,0(R3)            SET ERROR CODE                    #  02334000
         LH    R4,2(R3)            SET MESSAGE LENGTH                #  02335000
         LA    R3,4(R3)            SET MESSAGE POINTER               #  02336000
         BR    R15                 AND EXIT WITH THE MESSAGE         #  02337000
         DROP  ,                                                        02338000
*                                                                       02339000
*          VARIOUS TABLE AND DCB DEFINITIONS                            02340000
*                                                                       02341000
         DS    0D                                                       02342000
SPSYSTSA DS    18F                                                      02343000
DECTBL   DC    D'0,1,2,3,4,5,6,7,8,9'                                   02344000
PINT     DS    D                   PACKED INTEGER BUFFER                02345000
         DC    20AL1(FILBLA)                                            02346000
ZINT     DS    CL12                ZONED INTEGER BUFFER                 02347000
         DS    0F                                                       02348000
*                                                                    #  02349000
*              DCB EXIT LIST PARAMETERS                              #  02350000
*                                                                    #  02351000
XLINPUT  DC    X'85',AL3(XLSTRTIN)                                   #  02352000
XLINOUT  EQU   XLINPUT                                               #  02353000
XLOUTPUT DC    X'85',AL3(XLSTRTOT)                                   #  02354000
*                                                                    #  02355000
*        DEFAULT AND TARGET VALUES FOR FILES OTHER THAN "OUTPUT"     #  02356000
*                                                                    #  02357000
DEFAULTS DC    H'80'               TARGET DATA BYTES PER RECORD      #  02358000
         DC    H'1600'             TARGET BYTES PER BLOCK            #  02359000
         DC    AL1(3)              DEFAULT BUFNO VALUE               #  02360000
         DC    X'50'               DEFAULT RECFM = VB                #  02361000
*                                                                    #  02362000
*        DEFAULT AND TARGET VALUES FOR "OUTPUT" FILE                 #  02363000
*                                                                    #  02364000
OUTDFLTS DC    H'132'              TARGET DATA BYTES PER RECORD      #  02365000
         DC    H'1600'             TARGET BYTES PER RECORD           #  02366000
         DC    AL1(5)              DEFAULT BUFNO VALUE               #  02367000
         DC    X'54'               DEFAULT RECFM = VBA               #  02368000
*                                                                    #  02369000
MAXSKIP  DC    F'60'               MAXIMUM NUMBER OF LINES TO SKIP   #  02370000
SKPASCII EQU   *+1                 TABLE OF ASCII CONTROL CHARS      #  02371000
         DC    C'1+ 0-'                                              #  02372000
SKPMACH  EQU   *+1                 TABLE OF MACHINE CONTROL CHARS    #  02373000
         DC    X'8901091119'                                         #  02374000
RRFLAG   DC    X'0'                RE-READ FLAG                      #  02375000
FILPSTSV DS    A                                                     #  02376000
FILPUTSV DS    A                                                     #  02377000
FILCLSSV DS    A                                                     #  02378000
EXPONENT DS    F                                                     #  02379000
SIGN     DS    CL1                                                      02380000
EFORM    DS    CL1                                                      02381000
CCFLAG   DC    X'00'               SET BY NOCC O.S. PARM STRING      #  02382000
*                                                                       02383000
READMSG  DC    AL2(INPERR,25),C' INVALID INPUT OPERATION '              02384000
WRITEMSG DC    AL2(OUTERR,26),C' INVALID OUTPUT OPERATION '             02385000
FDFMSG   DC    AL2(FDFERR,25),C' INVALID FILE DEFINITION '              02386000
MATHMSG  DC    AL2(MTHERR,32),C' OBSOLETE MATH. ROUTINE LINKAGE '    #  02387000
LIMMSG   DC    AL2(LIMERR,26),C' LINELIMIT VALUE EXCEEDED '          #  02388000
EOFMSG   DC    AL2(EOFERR,24),C' ILLEGAL READ AFTER EOF '            #  02389000
BOOLMSG  DC    AL2(BOLERR,21),C' BAD BOOLEAN ON INPUT '              #  02390000
INTMSG   DC    AL2(INTERR,21),C' BAD INTEGER ON INPUT '              #  02391000
REALMSG  DC    AL2(RELERR,18),C' BAD REAL ON INPUT '                 #  02392000
SYNMSG   DC    AL2(SYNERR,79)                                        #  02393000
SYNADMSG DC    CL128' '             BUFFER FOR I/O ERROR MESSAGE     #  02394000
*        NOTE: THIS BUFFER IS ALSO USED BY "MESSAGE". ITS LENGTH MUST#  02395000
*        NOT BE LESS THAN MAXMSGL+8.                                 #  02396000
         LTORG ,                                                        02397000
         DS    0D                                                       02398000
*                                                                       02399000
*        FILE  NAME TABLE                                               02400000
*                                                                       02401000
FILBLK   DC    A(FILINP,FILOUT,FILPRD,FILPRR,FILQRD,FILQRR)             02402000
         DC    20F'0'              USER DEFINED FILES !                 02403000
         PRINT NOGEN               TURN OFF DCB EXPANSIONS           #  02404000
*                                                                       02405000
*        FILE CONTROL BLOC AND DCB FOR THE ABOVE FILES                  02406000
*                                                                       02407000
         FILDEF INPUT,INPUT,LINELGTH                                    02408000
         FILDEF OUTPUT,OUTPUT,LINELGTH                                  02409000
         FILDEF PRD,INOUT,LINELGTH                                      02410000
*                                                                       02411000
#FILREC  EQU   FILPRD,*-FILPRD     FILE RECORD TEMPLATE                 02412000
*                                                                       02413000
         FILDEF PRR,INOUT,LINELGTH                                      02414000
         FILDEF QRD,INOUT,LINELGTH                                      02415000
         FILDEF QRR,INOUT,LINELGTH                                      02416000
**************************************************************          02417000
*                                                                       02418000
*        END OF $PASCSP MODULE                                          02419000
*                                                                       02420000
**************************************************************          02421000
         SPACE 3                                                        02422000
*        GLOBAL DEFINITIONS                                             02423000
*                                                                       02424000
*                                                                       02425000
*                                                                       02426000
*                                                                       02427000
*        REGISTER ASSIGNMENTS                                           02428000
*                                                                       02429000
R0       EQU   0                                                        02430000
R1       EQU   1                                                        02431000
R2       EQU   2                                                        02432000
R3       EQU   3                                                        02433000
R4       EQU   4                                                        02434000
R5       EQU   5                                                        02435000
R6       EQU   6                                                        02436000
R7       EQU   7                                                        02437000
R8       EQU   8                                                        02438000
R9       EQU   9                                                        02439000
R10      EQU   10                                                       02440000
R11      EQU   11                                                       02441000
R12      EQU   12                                                       02442000
R13      EQU   13                                                       02443000
R14      EQU   14                                                       02444000
R15      EQU   15                                                       02445000
GBR      EQU   12                                                       02446000
FPR0     EQU   0                   FLOATING REG 0                       02447000
FPR2     EQU   2                                                        02448000
FPR4     EQU   4                                                        02449000
FPR6     EQU   6                                                        02450000
K        EQU   1024                                                     02451000
IOBUFSZE EQU   32*K                SIZE OF AREA RETURNED TO OS FOR I/O  02452000
MINSTORE EQU   IOBUFSZE+6*K        MIN ACCEPTABLE DYNAMIC STORAGE SIZE  02453000
MAXSTORE EQU   4000*K              MAX REQUESTABLE DYNAMIC STORAGE      02454000
PASBUFAD EQU   INPUT-STACK         ADR OF THE FIRST FILE CHAR BUFFER    02455000
LCAFTMST EQU   80                  LOCAL VARIABLE AREA (PASCAL PROCS)   02456000
MAXMSGL  EQU   120                 MAX LENGTH MESSAGE                #  02457000
RET      EQU   14                  RETURN ADDRESS/LOCATION COUNTER      02458000
LINK     EQU   15                  BRANCH REGISTER                      02459000
PBASE2   EQU   11                  PROGRAM BASE REGISTER #2             02460000
PBASE1   EQU   10                  "     "      #1                      02461000
*                                                                       02462000
INXERR   EQU   1001                INDEX ERROR RETURN CODE              02463000
SUBERR   EQU   1002                SUBRANGE ERROR RETURN CODE           02464000
PARERR   EQU   1003                PARAMETER ERROR RETURN CODE          02465000
SETERR   EQU   1004                SET ELEMENT ERROR RETURN CODE        02466000
PTRERR   EQU   1005                POINTER ERROR RETURN CODE            02467000
STKERR   EQU   1006                STACK/HEAP ERROR RETURN CODE         02468000
INPERR   EQU   1007                INPUT OPERATION ERROR RETURN CODE    02469000
OUTERR   EQU   1008                OUTPUT OPERATION ERROR RETURN CODE   02470000
SYNERR   EQU   1009                SYNCHRONOUS I/O ERROR RETURN CODE #  02471000
TIMERR   EQU   1010                TIME OUT ERROR RETURN CODE           02472000
FDFERR   EQU   1011                FILE DEFINITION ERROR RETURN CODE    02473000
SPCERR   EQU   1012                'NO SPACE' ERROR RETURN CODE         02474000
MTHERR   EQU   1013                'MATH ROUTINES NOT LOADED' ERROR  #  02475000
LIMERR   EQU   1014                'LINES LIMIT EXCEEDED' ERROR      #  02476000
EOFERR   EQU   1020                ILLEGAL READ PAST EOF             #  02477000
BOLERR   EQU   1021                BAD BOOLEAN ON INPUT              #  02478000
INTERR   EQU   1022                BAD INTEGER ON INPUT              #  02479000
RELERR   EQU   1023                BAD REAL ON INPUT                 #  02480000
SNPERR   EQU   100                 SNAPSHOT ERROR RETURN CODE           02481000
FILCOUNT EQU   F18PAS-INPUT+1      # OF FILES (AND FILE DCB'S)          02482000
*                                                                       02483000
*                                                                       02484000
*        MISCELANEOUS CONSTANTS                                         02485000
*                                                                       02486000
*                                                                       02487000
*        FILE RELATED SYMBOL DEFINITIONS                                02488000
*                                                                       02489000
         EXTRN $MAINBLK                                                 02490000
         WXTRN SNAPSHOT,IBCOM#                                       #  02491000
*                                                                       02492000
*                                                                       02493000
*        CSP ROUTINE NUMBERS                                            02494000
*                                                                       02495000
PGET     EQU   0*4                                                      02496000
PPUT     EQU   1*4                                                      02497000
PRES     EQU   2*4                                                      02498000
PRLN     EQU   3*4                                                      02499000
PREW     EQU   4*4                                                      02500000
PWLN     EQU   5*4                                                      02501000
PWRS     EQU   6*4                                                      02502000
PWRI     EQU   8*4                                                      02503000
PXIT     EQU   21*4                                                     02504000
PCLS     EQU   29*4                                                     02505000
PSKP     EQU   32*4                                                  #  02506000
*                                                                       02507000
*        FILE BLOCK FIELDS                                              02508000
*                                                                       02509000
FILBUF   EQU   0                                                     #  02510000
FILEND   EQU   4                                                     #  02511000
FILPTR   EQU   6                                                     #  02512000
FILBEG   EQU   8                                                     #  02513000
FILEOF   EQU   10                                                    #  02514000
FILOPN   EQU   11                                                    #  02515000
FILLIM   EQU   12                                                    #  02516000
FILDCB   EQU   16                                                    #  02517000
*                                                                       02518000
*        INTERNAL CHARACTER CODE FOR USEFUL CHARACTERS                  02519000
*                                                                       02520000
FILEOL   EQU   0  ?                                                     02521000
FILEXP   EQU   C'E' 5                                                   02522000
FILZER   EQU   C'0' 27                                                  02523000
FILNIN   EQU   C'9' 36                                                  02524000
FILPLU   EQU   C'+' 37                                                  02525000
FILMIN   EQU   C'-' 38                                                  02526000
FILTIM   EQU   C'*' 39                                                  02527000
FILBLA   EQU   C' ' 45                                                  02528000
FILDOT   EQU   C'.' 47                                                  02529000
*                                                                       02530000
*        READ/WRITE FLAG                                                02531000
*                                                                       02532000
READOPN  EQU   1                                                        02533000
WRITEOPN EQU   3                                                        02534000
*                                                                       02535000
*        AD :  @ PASCAL_FILE_BUFFER    (WITHIN GLOBAL DATA AREA)        02536000
*        AE :  @ CSP_FILE_CTL.BLK      (INDICATING WHICH FILE )         02537000
*        AF :  @ CSP_RECORD_BUFFER     (POINTING TO THE LINE BUF)       02538000
*        AG :  @ CSP_DCB               (POINTER TO FILE DCB)            02539000
*                                                                       02540000
FALSE    EQU   0                                                        02541000
TRUE     EQU   1                                                        02542000
RSLT     EQU   0                                                        02543000
AD       EQU   9                                                        02544000
AE       EQU   8                                                        02545000
AF       EQU   7                                                        02546000
AG       EQU   6                                                        02547000
*                                                                       02548000
*        MISCELLANEOUS CONSTANTS                                        02549000
*                                                                       02550000
CHR      EQU   1                   LENGTH (IN BYTES) OF A CHAR. VALUE   02551000
BOL      EQU   1                   "     "   "     OF A LOGICAL VALUE   02552000
ADR      EQU   4                   "     "   "     OF AN ADDRESS VALUE  02553000
INT      EQU   4                   "     "   "     OF AN INTEGER VALUE  02554000
REL      EQU   8                   "     "   "     OF A REAL VALUE      02555000
SET      EQU   8                   "     "   "     OF A SET VALUE       02556000
CDS      EQU   8                   COMMON DATUM SIZE (LARGEST OF ABOVE) 02557000
*                                                                       02558000
         END   $PASENT                                                  02559000
++FILE PASCALN.OLDCOMP.SOURCE                       MEMB RUNTIME  EXT ASS HEX -
         TITLE 'PASCSP, PASCAL RUNTIME SUPPORT AND STANDARD PROCS'      00010000
*********************************************************************** 00020000
*                                                                       00030000
*                                                                       00040000
*                                                                       00050000
*     PASCAL ENVIRONMENT AND ENTRY SETUP                                00060000
*     ------------------------------------                              00070000
*                                                                       00080000
*                                                                       00090000
*     COPYRIGHT 1976, STANFORD LINEAR ACCELERATOR CENTER.               00100000
*                                                                       00110000
*                                                                       00120000
*     THE FOLLOWING PROGRAMS CREATE  THE  RUN-TIME  ENVIRONMENT  AND    00130000
*     PROVIDE THE I/O INTERFACE FOR THE SLAC 'PASCAL' COMPILER.         00140000
*                                                                       00150000
*     EXCEPT FOR THE FEW POINTS EXPLAINED IN THIS BOX, THE INTERNALS    00160000
*     OF THESE ROUTINS SHOULD BE INVISIBLE (AND INCONSEQUENTIAL)  TO    00170000
*     THE 'PASCAL' USER.                                                00180000
*                                                                       00190000
*                                                                       00200000
*                                                                       00210000
*     1) THE USER MAY SPECIFY THE SIZE OF THE RUN  TIME  STACK/HEAP,    00220000
*     THE  SIZE OF THE AREA RETURNED TO THE OPERATING SYSTEM FOR I/O    00230000
*     BUFFERS, THE MAXIMUM COUNT OF RUN  TIME  ERRORS,  THE  RUNNING    00240000
*     TIME  OF  THE  PROGRAM,  REQUEST  AN  OPTIONAL MEMORY DUMP AND    00250000
*     SPECIFY OTHER SPECIAL CONTROL OPTIONS AS FOLLOWS:                 00260000
*                                                                       00270000
*       // EXEC USERPROG,                                               00280000
*       //      PARM='USER PARMS /STACK=XXXK,IOBUF=YYYK,ERRLIM=NNN,     00290000
*                            TIME=TTTS,NOSPIE,NOSNAP,NOCC,DUMP'      #  00300000
*                                                                       00310000
*       'USER PARMS': THE PARAMETER LIST TO BE PASSED TO THE USER       00320000
*                     PROGRAM (IF ANY).                                 00330000
*       'XXX' : STORAGE AREA (IN K BYTES) FOR STACK+HEAP.               00340000
*       'YYY' : STORAGE AREA (IN K BYTES) TO BE RETURNED TO SYSTEM.     00350000
*       'NNN' : NUMBER OF NON FATAL RUN-TIME ERRORS TO BE TOLERATED     00360000
*               BEFORE TERMINATING THE PROGRAM.                         00370000
*       'TTT' : PROGRAM RUNNING TIME (IN SECONDS).                      00380000
*       'DUMP': TO GENERATE AN OS STYLE MEMORY DUMP IN CASE OF AN       00390000
*               ABNORMAL PROGRAM TERMINATION.                           00400000
*       'NOSPIE': TO PREVENT INTERCEPTION OF ERROR INTERRUPTS        #  00410000
*       'NOSNAP': TO STOP USE OF SNAPSHOT RT. AFTER AN ERROR         #  00420000
*       'NOCC': TO STOP FIRST CHARACTER ON EACH LINE FROM BEING      #  00430000
*               TAKEN AS A CONTROL CHARACTER                         #  00440000
*       DEFAULT VALUE FOR 'XXXK' IS THE JOB 'REGION' SIZE.              00450000
*       DEFAULT VALUE FOR 'YYYK' IS 36K.                                00460000
*       DEFAULT VALUE FOR 'NNN' IS 1.                                   00470000
*                                                                       00480000
*     2) THE VALUE OF THE RETURN CODE 'RC', IF OTHER  THAN GENERATED    00490000
*     BY  THE  USER  PROGRAM,  MAY  BE  INTERPRETED ACCORDING TO THE    00500000
*     FOLLOWING TABLE.  FOR MORE DETAILED EXPANATION  OF  THE  ERROR    00510000
*     CONDITION,  SEE  THE  CONTENTS OF THE 'OUTPUT' FILE WHICH HAVE    00520000
*     THE APPROPRIATE MESSAGES.  NOTE THAT THIS FILE (OUTPUT) SHOULD    00530000
*     BE INCLUDED IN THE USER PROGRAM IN ORDER TO GET THE  RUN  TIME    00540000
*     DIAGNOSTICS AND RELATED MESSAGES.                                 00550000
*                                                                       00560000
*       RETURN CODE:  IMPLIES:                                          00570000
*                                                                       00580000
*       1001          INDEX VALUE OUT OF RANGE                          00590000
*       1002          SUBRANGE VALUE OUT OF RANGE                       00600000
*       1003          ACTUAL PARAMETER OUT OF RANGE                     00610000
*       1004          SET MEMBER OUT OF RANGE                           00620000
*       1005          POINTER VALUE INVALID                             00630000
*       1006          STACK/HEAP COLLISION                              00640000
*       1007          ILLEGAL INPUT/RESET OPERATION                     00650000
*       1008          ILLEGAL OUTPUT/REWRITE OPERATION                  00660000
*       1009          SYNCHRONOUS I/O ERROR                             00670000
*       1010          PROGRAM EXCEEDED SPECIFIED RUNNING TIME           00680000
*       1011          ILLEGAL FILE DEFINITION (I.E., TOO MANY FILES)    00690000
*       1012          NOT ENOUGH STACK SPACE                            00700000
*       1013          UNDEFINED OR OBSOLETE CSP CALL                 #  00710000
*       1014          LINELIMIT EXCEEDED FOR A FILE                  #  00720000
*       1020          READ PAST END OF FILE                          #  00730000
*       1021          BAD BOOLEAN INPUT                              #  00740000
*       1022          BAD INTEGER INPUT                              #  00750000
*       1023          BAD REAL INPUT                                 #  00760000
*                                                                       00770000
*       200X          PROGRAM INTERRUPTION CODE 'X'                     00780000
*                                                                       00790000
*       3001          MISC. EXTERNAL ERROR CONDITIONS.                  00800000
*                                                                       00810000
*       X1XX          UNABLE TO RUN SNAPSHOT, OTHER DIGITS AS ABOVE     00820000
*                                                                       00830000
*                                                                       00840000
*     3) THE CONDITIONAL ASSEMBLY FLAG &SYSTEM DETERMINES WHETHER    #  00850000
*     CERTAIN SECTIONS OF CODE ARE INCLUDED IN THE PROGRAM.          #  00860000
*     WITH &SYSTEM=1, SOME CHECKING CODE, REAL NUMBER INPUT AND THE  #  00870000
*     FORTRAN INTERFACE IS OMITTED.  THIS RESULTS IN A SMALLER       #  00880000
*     FASTER PROGRAM BUT WHICH CAN ONLY BE USED WITH "SAFE"          #  00890000
*     PROGRAMS THAT DO NOT USE MATHEMATICAL ROUTINES - SUCH AS THE   #  00900000
*     COMPILER AND THE P-ASSEMBLER.                                  #  00910000
*     WITH &SYSTEM=0, THE FULL PROGRAM IS PRODUCED AND THIS IS THE   #  00920000
*     VERSION THAT SHOULD NORMALLY BE COMBINED WITH USER PROGRAMS.   #  00930000
*                                                                       00940000
*                                                                       00950000
*     4) THIS PROGRAM MAY BE ASSEMBLED WITH MOST STANDARD IBM        #  00960000
*     ASSEMBLERS.                                                    #  00970000
*                                                                       00980000
*                                                                       00990000
*     5) IF THE RUN PROFILE SWITCH IS ENABLED IN THE PASCAL  PROGRAM    01000000
*     (I.E.   'K+'),  THE  RUN  TIME SYSTEM WILL 'REWRITE' THE 'RAW'    01010000
*     EXECUTION COUNTS ON THE PREDEFINED 'QRR'  FILE  AFTER  RUNNING    01020000
*     THE  USER  PROGRAM.  IN SUCH CASES THE USER PROGRAM SHOULD NOT    01030000
*     USE THE 'QRR' FILE BUT THE 'DD' STATEMENT FOR THIS FILE SHOULD    01040000
*     BE INCLUDED IN THE 'GO' STEP.  THE SUBMONITOR WILL SUBSEQUENTLY   01050000
*     INVOKE THE "PASPROF" LOAD-MODULE TO PRINT THE PROFILE.            01060000
*                                                                       01070000
*                                                                       01080000
*                                                                       01090000
*                                                                       01100000
*     THESE PROGRAMS INCLUDE SOME CONTRIBUTIONS BY KEITH RICH,  JOHN    01110000
*     BANNING AND NIGEL HORSPOOL.                                       01120000
*                                                                       01130000
*                                                                       01140000
*                                                                       01150000
*                                SASSAN HAZEGHI,                        01160000
*                                                                       01170000
*                                COMPUTATION RESEARCH GROUP             01180000
*                                STANFORD LINEAR ACCELERATOR CENTER     01190000
*                                P. O. BOX 4349                         01200000
*                                STANFORD, CALIFORNIA  94305.           01210000
*                                                                       01220000
*                                                                       01230000
*                                                                       01240000
*                                LAST UPDATE:                           01250000
*                                             MAR.  15, 76.             01260000
*                                             SEPT.  8, 76.             01270000
*                                             JAN.  20, 77.             01280000
*                                             JULY  28, 77.             01290000
*                                             MAY   21, 77.             01300000
*                                             JULY   6, 78.             01310000
*                                             SEPT. 15, 78.             01320000
*                                             NOV.  11, 78.             01330000
*                                             AUG.  09, 79.             01340000
*                                                                       01350000
*     FURTHER MODIFICATIONS MADE AT MCGILL UNIVERSITY,               #  01360000
*                                                                    #  01370000
*                                R. NIGEL HORSPOOL                   #  01380000
*                               SEPT. 18, 1979                          01390000
*                                                                       01400000
*********************************************************************** 01410000
         EJECT                                                          01420000
**************************************************************          01430000
*                                                                       01440000
*        I/O (FILE) HANDLING MACROS                                     01450000
*                                                                       01460000
**************************************************************          01470000
*                                                                       01480000
         MACRO ,                                                        01490000
&L       FILADR ,                                                       01500000
.*       TO COMPUTE FILE BUFFER ADDRESS ETC.                            01510000
&L       LR    AE,AD                                                    01520000
         SR    AE,GBR                         AE <-- FILE #             01530000
         SLA   AE,2                           FILE # TO OFFSET          01540000
         L     AE,FILBLK-PASBUFAD*4(AE)       OFFSET TO FILE BLOCK      01550000
         L     AF,FILBUF(AE)       SET I/O BUFFER POINTER            #  01560000
         MEND  ,                                                        01570000
*                                                                       01580000
         MACRO ,                                                     #  01590000
         FILDEF &NAME,&DIRECT,&LENGTH                                #  01600000
.*       DEFINE A FILE  DDNAME,DIRECTION,LRECL                       #  01610000
         LCLC  &NAM                                                  #  01620000
         DS    0D                                                    #  01630000
&NAM     SETC  '&NAME'(1,3)                                          #  01640000
FIL&NAM  DC    A(0)                BUFFER ADDRESS                    #  01650000
         DC    H'0',H'0'            LRECL,CHAR. PTR.                 #  01660000
         DC    H'0'                CHAR. START POS.                  #  01670000
         DC    X'0',X'0'           EOFFLAG, OPENFLAG                 #  01680000
         DC    F'0'                OUTPUT LINES LIMIT                #  01690000
         AIF   ('&DIRECT' NE 'INPUT').OUTPUT                         #  01700000
         DCB   DSORG=PS,DDNAME=&NAME,MACRF=(GL),EODAD=EOD,           # X01710000
               SYNAD=SYNADRT,EXLST=XL&DIRECT,BFTEK=A                 #  01720000
         MEXIT ,                                                     #  01730000
.OUTPUT  AIF   ('&DIRECT' NE 'OUTPUT').INPOUT                        #  01740000
         DCB   DSORG=PS,DDNAME=&NAME,MACRF=(PL),                     # X01750000
               SYNAD=SYNADRT,EXLST=XL&DIRECT,BFTEK=A                 #  01760000
         MEXIT ,                                                     #  01770000
.INPOUT  ANOP  ,                                                     #  01780000
         DCB   DSORG=PS,DDNAME=&NAME,MACRF=(GL,PL),EODAD=EOD,        # X01790000
               SYNAD=SYNADRT,EXLST=XL&DIRECT,BFTEK=A                 #  01800000
         MEND  ,                                                     #  01810000
*                                                                    #  01820000
         EJECT                                                          01830000
         GBLB  &SYSTEM                                               #  01840000
&SYSTEM  SETB  0                  TRUE INDICATES A COMPACT 'CSP'        01850000
*                                                                       01860000
         AIF   (&SYSTEM).SYS1                                           01870000
*        GENERAL SETUP FOR USER PROGRAM(S).                             01880000
         AGO   .USE1                                                    01890000
.SYS1    ANOP                                                           01900000
*        COMPACT SETUP, OMITS FORTRAN INTERFACE & REAL INPUT         #  01910000
.USE1    ANOP                                                           01920000
*                                                                       01930000
*                                                                       01940000
*                                                                       01950000
         EJECT                                                          01960000
***************************************************************         01970000
*                                                                       01980000
*        STACK (AND SAVE AREA) LAYOUT                                   01990000
*                                                                       02000000
***************************************************************         02010000
*                                                                       02020000
*                                                                       02030000
         PRINT NOGEN                                                    02040000
         DCBD  DSORG=PS                                                 02050000
         PRINT GEN                                                      02060000
*                                                                       02070000
DYNSTORE DSECT ,                                                        02080000
         DS    20F                 PASCAL ENVIRONMENT SAVE AREA         02090000
STACK    DS    18F                 BOTTOM OF RUNTIME STACK              02100000
CLOCK    EQU   STACK               CLOCK LOCATION                       02110000
NEWPTR   DS    A                   PASCAL 'NEW' POINTER                 02120000
HEAPLIM  DS    A                   UPPER LIMIT OF HEAP ( +1 )           02130000
*                                  ALSO POINTS TO DYN2STOR              02140000
DISPREGS DS    10F                 RUN TIME DISPLAY REGISTERS           02150000
DISPLAY  EQU   DISPREGS,*-DISPREGS                                      02160000
FL1      DS    D                   R/W  FIX/FLOAT CONVERSION HELPS      02170000
FL2      DS    D                   R ONLY                               02180000
FL3      DS    D                   R/W                                  02190000
FL4      DS    D                   R ONLY                               02200000
CHKSUBS  DS    0F                  ENTRY TO RUN TIME CHECK ROUTINES     02210000
INXCHK   DS    3F                  INDEX CHECK                          02220000
RNGCHK   DS    3F                  SUBRANGE CHECK                       02230000
PRMCHK   DS    3F                  PARAMETER VALUE CHECK                02240000
PTRCHK   DS    3F                  POINTER CHECK                        02250000
PTACHK   DS    3F                  SET MEMBER CHECK                     02260000
SETCHK   DS    3F                                                       02270000
STKCHK   DS    3F                                                       02280000
ZZZCHK   DS    3F                                                       02290000
INPUT    DS    CL1                                                      02300000
OUTPUT   DS    CL1                                                      02310000
PRD      DS    CL1                                                      02320000
PRR      DS    CL1                                                      02330000
QRD      DS    CL1                                                      02340000
QRR      DS    CL1                                                      02350000
F01PAS   DS    CL1                                                      02360000
F02PAS   DS    CL1                                                      02370000
F03PAS   DS    CL1                                                      02380000
F04PAS   DS    CL1                                                      02390000
F05PAS   DS    CL1                                                      02400000
F06PAS   DS    CL1                                                      02410000
F07PAS   DS    CL1                                                      02420000
F08PAS   DS    CL1                                                      02430000
F09PAS   DS    CL1                                                      02440000
F10PAS   DS    CL1                                                      02450000
F11PAS   DS    CL1                                                      02460000
F12PAS   DS    CL1                                                      02470000
F13PAS   DS    CL1                                                      02480000
F14PAS   DS    CL1                                                      02490000
F15PAS   DS    CL1                                                      02500000
F16PAS   DS    CL1                                                      02510000
F17PAS   DS    CL1                                                      02520000
F18PAS   DS    CL1                                                      02530000
CLEARBUF DS    XL8                  BUFFER TO CLEAR ACTIVATION RECORDS  02540000
PASDATE  DS    CL10                 PREDEFINED VARIABLE DATE            02550000
PASTIME  DS    CL10                 PREDEFINED VARIABLE TIME            02560000
OSPRMPTR DS    A                    POINTER TO O.S. PARM STRING      #  02570000
FRSTGVAR DS    0D                  FOR ALIGNMENT PURPOSES               02580000
*                                                                       02590000
*       DYNAMIC STORAGE AREA POINTED TO BY HEAPLIM                      02600000
*                                                                       02610000
DYN2STOR DSECT     ,                                                    02620000
DYNRUNC  DS        F         # OF RUN TIME FREQUENCY COUNTERS           02630000
DYNERRL  DS        F         LIMIT OF ERROR BEFORE TERMINATING          02640000
DYNERRC  DS        F         ERROR COUNTER                              02650000
DYNABEND DS        X         X'FF' => ABEND ON ERROR TERMINATION        02660000
         DS        0D                                                   02670000
DYNCOUNT DS        0F                                                   02680000
         AIF       (&SYSTEM).SYS3                                       02690000
DYN2LEN  EQU       128       EXTRA MARGIN FOR PATHOLOGICAL CALL PARMS   02700000
         AGO       .USE3                                                02710000
.SYS3    ANOP                                                           02720000
DYN2LEN  EQU       *-DYN2STOR                                           02730000
.USE3    ANOP                                                           02740000
*                                                                       02750000
         EJECT                                                          02760000
**************************************************************          02770000
*                                                                       02780000
*        PASCAL ENTRY POINT AND PROGRAM PROLOGUE                        02790000
*                                                                       02800000
**************************************************************          02810000
*                                                                       02820000
*                                                                       02830000
$PASENT  CSECT ,                                                        02840000
         ENTRY $PASENT,$PASCSP,$PASINT                               #  02850000
*                                                                       02860000
*                                                                       02870000
         USING *,15                                                     02880000
         SAVE  (14,12),,*                                               02890000
         LR    R10,R15                                                  02900000
         DROP  R15                                                      02910000
         USING $PASENT,R10                                              02920000
         ST    R1,OSPARMS          SAVE ADDRESS OF O.S. PARMS        #  02930000
         L     R1,0(R1)                                                 02940000
         SPACE                                                          02950000
*                                                                       02960000
*        R1 POINTS TO THE PARAMETER LIST THE FIRST HALF WORD OF         02970000
*        WHICH GIVES THE LENGTH OF THE LIST                             02980000
*                                                                       02990000
         LH    R2,0(R1)                                                 03000000
         LTR   R2,R2                                                    03010000
         BNH   NOPARM             NO PARAMETER LIST SPECIFIED           03020000
         LA    R0,256              SET MAX STRING LENGTH             #  03030000
         CR    R2,R0                                                 #  03040000
         BNH   *+6                 JUMP IF LENGTH OK                 #  03050000
         LR    R2,R0               ENFORCE THE LIMIT                 #  03060000
         LA    R8,1                INCREMENT FOR BXLE & BXH          #  03070000
         LA    R9,1(R1,R2)         LIMIT FOR BXLE & BXH              #  03080000
         LA    R1,2(,R1)           POINT AT FIRST CHAR               #  03090000
         ST    R1,OSPARMAD         SAVE ADDRESS FOR LATER            #  03100000
*                                                                       03110000
PARMRTRY CLI   0(R1),C'/'                                               03120000
         BE    PARMSLSH            SEPARATOR FOUND ?                 #  03130000
         BXLE  R1,R8,PARMRTRY                                        #  03140000
*                                                                       03150000
PARMSLSH LR    R3,R1                                                 #  03160000
         SL    R3,OSPARMAD         COMPUTE STRING LENGTH             #  03170000
         STH   R3,OSPARML          SAVE IT FOR LATER                 #  03180000
         BXH   R1,R8,NOPARM        JUMP IF STRING END                #  03190000
*                                                                       03200000
GOTPARM  CLC   0(3,R1),=C'STACK'  PROGRAM DATA AREA SPECIFIED ?         03210000
         BNE   TESTBUF                                                  03220000
*                                                                       03230000
SETREG   BAL   R7,GETNUM          SET STACK REGION SIZE                 03240000
         LTR   R4,R4                                                    03250000
         BNP   NXTPARM                                                  03260000
         SLA   R4,10              CONVERT TO 'K' BYTES                  03270000
         ST    R4,REQSTORE        RESET REGION SIZE                     03280000
         ST    R4,REQSTORE+4      ALSO SET MAX STORE TO THE SAME VALUE  03290000
         B     NXTPARM                                                  03300000
*                                                                       03310000
TESTBUF  CLC   0(3,R1),=C'IOBUF' I/O BUFFER SIZE SPECIFIED ?            03320000
         BNE   TESTABND                                                 03330000
*                                                                       03340000
SETBUF   BAL   R7,GETNUM                                                03350000
         LTR   R4,R4                                                    03360000
         BNP   NXTPARM                                                  03370000
         SLA   R4,10                                                    03380000
         ST    R4,BUFSTORE         RESET I/O BUFFER SIZE                03390000
         B     NXTPARM                                                  03400000
*                                                                       03410000
TESTABND CLC       0(4,R1),=C'DUMP'    ABEND ON ERROR ?                 03420000
         BNE       TESTLIM        IF NOT, SKIP                          03430000
         MVI       DUMPFLAG,X'FF' SET_FLAG                              03440000
         B         NXTPARM        CONTINUE                              03450000
*                                                                       03460000
TESTLIM  CLC       0(6,R1),=C'ERRLIM'  LIMIT ON NUMBER OF ERRORS        03470000
         BNE       TESTTIME       IF NOT, SKIP                          03480000
         BAL       R7,GETNUM      GET ERROR LIMIT                       03490000
         LTR       R4,R4                                                03500000
         BNP       NXTPARM        IGNORE NUMBER IF BAD                  03510000
         ST        R4,ERRLIMIT    ELSE SET LIMIT                        03520000
         B         NXTPARM                                              03530000
*                                                                       03540000
TESTTIME CLC   0(4,R1),=C'TIME'                                         03550000
         BNE   TESTCC             SEE IF EXEC TIME SPECIFIED         #  03560000
         BAL   R7,GETNUM                                                03570000
         LTR   R5,R4                                                    03580000
         BNP   NXTPARM            IF TIME PARM NO GOOD, SKIP            03590000
         M     R4,=F'38400'       CONVERT SECONDS TO CPU TIMER UNITS    03600000
         ST    R5,EXECTIME                                              03610000
         B     NXTPARM                                                  03620000
*                                                                       03630000
TESTCC   CLC   0(4,R1),=C'NOCC'    SEE IF CONTROL CHARS CANCELLED    #  03640000
         BNE   TESTSPIE            JUMP IF NOT                       #  03650000
         L     R15,=A(CCFLAG)      FLAG IS NOT DIRECTLY ADDRESSABLE  #  03660000
         MVI   0(R15),X'FF'        SET THE FLAG                      #  03670000
*        LA    R1,4(,R1)                                             #  03680000
         B     NXTPARM                                               #  03690000
*                                                                    #  03700000
TESTSPIE CLC   0(6,R1),=C'NOSPIE'  CANCEL SPIE TRAP?                 #  03710000
         BNE   TESTSNAP                                              #  03720000
         MVI   SPIEFLAG,X'FF'      SET THE CANCEL SPIE FLAG          #  03730000
*        LA    R1,6(,R1)           ADVANCE POINTER                   #  03740000
         B     NXTPARM                                               #  03750000
*                                                                       03760000
TESTSNAP CLC   0(6,R1),=C'NOSNAP'  CANCEL SNAPSHOT                   #  03770000
         BNE   NXTPARM                                               #  03780000
         MVI   SNAPFLAG,X'FF'      SET FLAG                          #  03790000
*        LA    R1,6(,R1)                                             #  03800000
*        B     NXTPARM                                               #  03810000
*                                                                       03820000
*                                                                       03830000
*                                                                       03840000
*                                                                       03850000
NXTPARM  BXLE  R1,R8,GOTPARM       STEP TO NEXT CHAR                 #  03860000
*                                                                    #  03870000
*                                                                    #  03880000
*        DDNAME-LIST PARAMETER PROCESSING                            #  03890000
*                                                                    #  03900000
NOPARM   EQU   *                                                     #  03910000
         L     R1,OSPARMS                                            #  03920000
         TM    0(R1),X'80'         TEST IF DDNAME LIST PROVIDED      #  03930000
         BO    NODDPARM                                              #  03940000
         L     R1,4(,R1)           ADDRESS OF DDNAME LIST PARM       #  03950000
         LH    R2,0(,R1)           LENGTH OF LIST IN BYTES           #  03960000
         L     AD,=A(FILBLK)       POINTER TO FIRST ENTRY IN FILE TAB#  03970000
         LA    R3,6                MAX NUMBER OF DDNAMES ALLOWED     #  03980000
DDLOOP   SH    R2,=H'8'            CHECK FOR END OF DDNAME LIST      #  03990000
         BM    NODDPARM                                              #  04000000
         NC    2(8,R1),2(R1)       CHECK FOR BINARY ZEROS            #  04010000
         BZ    DDDFLT              IF SO, DONT CHANGE DDNAME         #  04020000
         L     AE,0(,AD)           ADDRESS OF FILE CONTROL BLOCK     #  04030000
         USING IHADCB-FILDCB,AE                                      #  04040000
         MVC   DCBDDNAM(8),2(R1)   MOVE NEW DDNAME INTO DCB          #  04050000
DDDFLT   LA    R1,8(,R1)           ADVANCE THROUGH LIST              #  04060000
         LA    AD,4(,AD)           ADVANCE THROUGH FILE TABLE        #  04070000
         BCT   R3,DDLOOP           REPEAT FOR NEXT FILE              #  04080000
NODDPARM EQU   *                                                     #  04090000
*                                                                       04100000
*                                                                       04110000
*        GET SPACE FOR THE RUN TIME STACK                               04120000
*                                                                       04130000
         L     R0,BUFSTORE                                              04140000
         A     R0,REQSTORE         COMPUTE THE SIZE OF THE SMALLEST     04150000
         ST    R0,REQSTORE         AREA THAT WILL MEET THE DEMAND       04160000
         C     R0,REQSTORE+4                                            04170000
         BL    *+8                 UPPER BOUND OK ?                     04180000
         ST    R0,REQSTORE+4       ADJUST IT IF NEEDED.                 04190000
*                                                                       04200000
*        GET ENOUGH SPACE FOR STACK+IOBUF NOW                           04210000
*                                                                       04220000
         GETMAIN VU,LA=REQSTORE,A=ALOSTORE                              04230000
         SPACE ,                                                        04240000
*                                                                       04250000
         L     R1,ALOSTORE         GET ADDRESS OF ALLOCATED AREA        04260000
         LR    R12,R1                                                   04270000
         A     R1,ALOSTORE+4       ADD SIZE OF THE AREA                 04280000
         S     R1,BUFSTORE         BEGINNIG (ENDING !) OF THE HEAP      04290000
         S     R1,=A(8)            NAME FIELD OF THE HEAP               04300000
         AIF   (&SYSTEM).SYS32                                          04310000
*                                                                       04320000
         LR    R2,R1                                                    04330000
         SR    R2,R12              R2 <-- SIZE OF THE USABLE AREA       04340000
         CL    R2,=A(FRSTGVAR-STACK)                                    04350000
         BNH   NOCLR               SKIP IF NOT LARGE ENOUGH             04360000
         L     R2,=A(FRSTGVAR-STACK)                                    04370000
         LD    FPR0,=XL8'8181818181818181'                              04380000
         SRA   R2,3                CONVERT BYTE COUNT TO D_WORD COUNT   04390000
         LR    R3,R12                                                   04400000
         STD   FPR0,0(R3)                                               04410000
         LA    R3,8(R3)                                                 04420000
         BCT   R2,*-8                                                   04430000
*                                                                       04440000
.SYS32   ANOP                                                           04450000
NOCLR    ST    R13,4(R12)          BACK LINK OF NEW SAVE AREA           04460000
         ST    R12,8(R13)          FRWRD LINK OF OLD SAVE AREA          04470000
         LR    R13,R12             RESET SAVE AREA POINTER              04480000
*                                                                       04490000
         USING DYNSTORE,GBR                                             04500000
         MVC   STACK-8(8),=CL8'   STACK'                                04510000
         MVC   0(8,R1),=CL8'HEAP    '                                   04520000
         LA    R12,STACK           GLOBAL (STACK BOTTOM) POINTER        04530000
         USING STACK,R12                                                04540000
         ST    R1,NEWPTR           SET PASCAL 'NEW' PONTER              04550000
*                                                                       04560000
*        CLEAR DISPLAY PSEUDO REGISTERS                                 04570000
*                                                                       04580000
         MVI   DISPLAY,X'FF'       SET DISP REGS TO '-1'                04590000
         MVC   DISPLAY+1(L'DISPLAY-1),DISPLAY                           04600000
         SPACE ,                                                        04610000
         L     R0,BUFSTORE         SIZE OF THE AREA TO BE RETURNED      04620000
         LA    R1,8(R1)            ADDRESS OF THE AREA TO BE RETURNED   04630000
         LR    R2,R1                                                    04640000
         SR    R2,R12              R2 <-- SPACE LEFT FOR THE STACK      04650000
         C     R2,USESTORE                                              04660000
         LA    R2,SPCERR           ERROR CODE FOR LACK OF SPACE         04670000
         BL    QUIT1                                                    04680000
*                                                                       04690000
*        FREE SOME SPACE FOR O/S FILE BUFFERS (4K/FILE !)               04700000
*                                                                       04710000
         FREEMAIN R,LV=(R0),A=(R1)                                      04720000
         L     R1,ALOSTORE+4       KEEP TRACK OF HOW MUCH CORE       #  04730000
         S     R1,BUFSTORE         TO RETURN TO THE O.S.             #  04740000
         ST    R1,ALOSTORE+4       AT END OF EXECUTION               #  04750000
         SPACE ,                                                        04760000
*                                                                       04770000
*        INITIALIZE FORTRAN ENVIRONMENT (IF THERE ARE FORTRAN           04780000
*        ROUTINES IN THE LOAD MODULE)                                   04790000
*                                                                       04800000
         AIF   (&SYSTEM).SYS325                                         04810000
         L     R15,=V(IBCOM#)     SEE IF FORTRAN ENVIRONMENT INCLUDED   04820000
         LTR   R15,R15                                                  04830000
         BZ    NOFORT                                                   04840000
         BAL   R14,IBCOMINI(R15)  IF SO CALL IBCOM# INIT ENTRY POINT    04850000
*                                                                       04860000
*        NOTE: THIS CALL SAVES R13 FOR IBCOMXIT, BE SURE TO HAVE        04870000
*        THE SAVE AREA CONSISTENT PRIOR TO CALLING IBCOMXIT             04880000
*                                                                       04890000
.SYS325  ANOP                                                           04900000
*                                                                       04910000
*        SET THE 'SPIE' TO TRAP PROGRAM  INTERRUPTS                     04920000
*                                                                       04930000
NOFORT   CLI   SPIEFLAG,X'00'      TEST IF SPIE TO BE ISSUED         #  04940000
         BNE   NOSPIE                                                #  04950000
         SPIE  MF=(E,PASSPIE)     OTHERWISE TRAP TO $PASINT          #  04960000
         ST    R1,OLDPICA         SAVE PRVIOUS PICA ADDRESS             04970000
NOSPIE   EQU   *                                                        04980000
*                                                                       04990000
*        SETUP DYN2STOR AREA                                            05000000
*                                                                       05010000
         L         R1,NEWPTR          TOP OF HEAP                       05020000
         S         R1,=A(DYN2LEN)     LESS SIZE OF DYN2                 05030000
         ST        R1,HEAPLIM         AND LIMIT                         05040000
         USING     DYN2STOR,R1                                          05050000
         MVC       DYNERRL,ERRLIMIT   SET ERROR LIMIT                   05060000
         SR        R0,R0                                                05070000
         ST        R0,DYNRUNC         CLEAR '# OF COUNTERS' FIELD       05080000
         ST        R0,DYNERRC         CLEAR '# OF ERRORS' FIELD         05090000
         MVC       DYNABEND,DUMPFLAG  SET DUMP FLAG                     05100000
         LH    R2,OSPARML                                            #  05110000
         LTR   R2,R2                                                 #  05120000
         BZ    OSPARM1             JUMP IF NO PARM STRING            #  05130000
         SLR   R1,R2                                                 #  05140000
         SL    R1,=F'4'            ALLOCATE PARM STRING RECORD       #  05150000
         SRL   R1,3                FORCE TO DOUBLE-WORD BOUNDARY     #  05160000
         SLL   R1,3                                                  #  05170000
         ST    R2,0(,R1)           PUT STRING LENGTH IN RECORD       #  05180000
         L     R3,OSPARMAD                                           #  05190000
         BCTR  R2,0                                                  #  05200000
         EX    R2,OSPRMMVC         MOVE STRING INTO RECORD           #  05210000
         ST    R1,OSPRMPTR         SET POINTER TO RECORD             #  05220000
         B     OSPARM2                                               #  05230000
OSPRMMVC MVC   4(0,R1),0(R3)                                         #  05240000
OSPARM1  BCTR  R2,0                SET POINTER TO NIL                #  05250000
         ST    R2,OSPRMPTR                                           #  05260000
OSPARM2  ST    R1,NEWPTR                                             #  05270000
         DROP  R1                                                    #  05280000
*                                                                       05290000
*                                                                       05300000
*                                                                       05310000
*        DISABLE INTEGER OVERFLOW, EXPONENT UNDERFLOW AND               05320000
*        SIGNIFICANCE INTERRUPTS.                                       05330000
*                                                                       05340000
         SR    R6,R6                                                    05350000
         SPM   R6                  DISABLE ALL MASKABLE INTERRUPTS   @  05360000
         SPACE ,                                                        05370000
         MVC   FL1,=X'4E00000000000000'  INITIALIZE FIX-FLOAT-FIX       05380000
         MVC   FL2,=X'4E00000080000000'  CONVERSION VALUES              05390000
         MVC   FL3,=X'0000000000000000'                                 05400000
         MVC   FL4,=X'4F08000000000000'                                 05410000
         SPACE ,                                                        05420000
         MVC   CHKSUBS(L'CALLSUBS),CALLSUBS  INIT. RUN TIME CHECK AREA  05430000
         SPACE                                                          05440000
         MVC   CLOCK,EXECTIME            SET THE ALARM CLOCK            05450000
         STIMER  TASK,$TIMEOUT,TUINTVL=CLOCK                            05460000
*                                                                       05470000
*        INITIALIZE DATE/TIME PREDEFINED VARIABLES                      05480000
*                                                                       05490000
         TIME  DEC                 GET TOD IN TU                        05500000
         ST    R1,DATESAV               PUT DATE IN WORK AREA           05510000
         CP    DATESAV+2(2),=PL2'59'                                    05520000
         BNH   LY                                                       05530000
         TM    DATESAV+1,1              LEAP YEAR?                      05540000
         BNZ   NLY                      NO                              05550000
         TM    DATESAV+1,X'12'          LEAP YEAR?                      05560000
         BNM   LY                       YES                             05570000
NLY      AP    DATESAV+2(2),=P'1'                                       05580000
LY       LA    R4,JAN                                                   05590000
         LA    R3,12                                                    05600000
         ZAP   MONTH(3),=P'0'                                           05610000
MDLP     AP    MONTH(3),=P'1000'       BUMP MONTH                       05620000
         CP    DATESAV+2(2),0(2,R4)    THIS MONTH?                      05630000
         BNH   MDEND                    BR IF SO                        05640000
         SP    DATESAV+2(2),0(2,R4)    TRY NEXT                         05650000
         LA    R4,2(R4)                                                 05660000
         BCT   R3,MDLP                                                  05670000
MDEND    L     R3,DATESAV                                               05680000
         N     R3,=X'00FF0000'          GET YEAR                        05690000
         O     R3,MONTH-2               INSERT MONTH                    05700000
         L     R4,DATESAV               GET DAY                         05710000
         SRL   R4,4                                                     05720000
         N     R4,=X'000000FF'                                          05730000
         OR    R3,R4                                                    05740000
         ST    R3,DATESAV               PREPARE TO REFORMAT DATE        05750000
         UNPK  DATESAV(9),DATESAV(5)                                    05760000
         MVC   PASDATE(2),DATESAV+4    FIRST MOVE MONTH                 05770000
         MVC   PASDATE+3(2),DATESAV+6  THEN THE DAY                     05780000
         MVC   PASDATE+6(4),DATESAV    FOLLOWED BY YEAR                 05790000
         MVI   PASDATE+2,C'-'                                           05800000
         MVI   PASDATE+5,C'-'                                           05810000
*                                                                       05820000
*        FIX TIME OF DAY STRING                                         05830000
*                                                                       05840000
         ST    R0,DATESAV                                               05850000
         UNPK  DATESAV(7),DATESAV(4)     CONVERT TO EBCDIC              05860000
         MVC   PASTIME+6(2),DATESAV+4    MOVE SECONDS                   05870000
         MVC   PASTIME+3(2),DATESAV+2    THEN MINUTES                   05880000
         MVC   PASTIME(2),DATESAV        AND HOURS                      05890000
         MVI   PASTIME+2,C':'                                           05900000
         MVI   PASTIME+5,C':'            AND FORMAT THE STRING          05910000
         MVC   PASTIME+8(2),=C'  '       PAD WITH BLANKS                05920000
*                                                                       05930000
*        FINALLY CALL THE USER PROGRAM                                  05940000
*                                                                       05950000
         LA    1,STACK                                                  05960000
         L     LINK,=A($MAINBLK)                                        05970000
         BALR  RET,LINK                                                 05980000
*                                                                       05990000
*        CLOSE THE OPEN FILES AND RETURN TO OS                          06000000
*                                                                       06010000
         SR    R2,R2               RETURN CODE = ZERO  !                06020000
QUIT1    LA    R1,PXIT             CLOSE OPEN FILES / RETURN TO OS      06030000
         L     LINK,=A($PASCSP)                                         06040000
         BR    LINK               EXIT PASCAL PROGRAM                   06050000
*                                                                       06060000
*                                                                       06070000
*        GET THE NEXT INTEGER IN THE PARAMETER LIST                     06080000
*                                                                       06090000
GETNUM   BXH   R1,R8,NOPARM        QUIT IF NO MORE CHARS             #  06100000
         CLI   0(R1),C'='                                               06110000
         BNE   GETNUM             SKIP UNTIL THE FIRST '='              06120000
*                                                                       06130000
         SR    R3,R3                                                    06140000
         SR    R4,R4              CLEAR ACCUMULATOR                     06150000
*                                                                       06160000
NXTDIG   BXH   R1,R8,0(R7)         RETURN IF NO MORE CHARS           #  06170000
         CLI   0(R1),C'9'                                               06180000
         BHR   R7                 OR IF A NON DIGIT                     06190000
         IC    R3,0(R1)                                                 06200000
         SH    R3,=Y(C'0')                                              06210000
         BLR   R7                 IS ENCOUNTERED                        06220000
         MH    R4,=H'10'                                                06230000
         AR    R4,R3              OTHERWISE KEEP ACCUMULATING           06240000
         B     NXTDIG                                                   06250000
*                                                                       06260000
         EJECT                                                          06270000
****************************************************************        06280000
*                                                                       06290000
*        TABLE OF CALLS FOR RUN TIME CHECK ROUTINES. TO BE COPIED       06300000
*        ,EXACTLY AS IS, ONTO THE RUN TIME STACK.                       06310000
*                                                                       06320000
****************************************************************        06330000
*                                                                       06340000
CALSUB   DS    0F                                                       06350000
CALLINX  L     R15,INXCHK+8                                             06360000
         BR    R15                                                      06370000
         DC    A($INXCHK)                                               06380000
*                                                                       06390000
CALLRNG  L     R15,RNGCHK+8                                             06400000
         BR    R15                                                      06410000
         DC    A($RNGCHK)                                               06420000
*                                                                       06430000
CALLPRM  L     R15,PRMCHK+8                                             06440000
         BR    R15                                                      06450000
         DC    A($PRMCHK)                                               06460000
*                                                                       06470000
CALLPTR  L     R15,PTRCHK+8                                             06480000
         BR    R15                                                      06490000
         DC    A($PTRCHK)                                               06500000
*                                                                       06510000
CALLPTA  L     R15,PTACHK+8                                             06520000
         BR    R15                                                      06530000
         DC    A($PTACHK)                                               06540000
*                                                                       06550000
CALLSET  L     R15,SETCHK+8                                             06560000
         BR    R15                                                      06570000
         DC    A($SETCHK)                                               06580000
*                                                                       06590000
CALLSTK  L     R15,STKCHK+8                                             06600000
         BR    R15                                                      06610000
         DC    A($STKCHK)                                               06620000
*                                                                       06630000
CALLSUBS EQU   CALSUB,*-CALSUB                                          06640000
*                                                                       06650000
         DROP  R10                                                      06660000
         EJECT                                                          06670000
*                                                                       06680000
BUFSTORE DC    A(IOBUFSZE)                                              06690000
REQSTORE DC    A(MINSTORE,MAXSTORE)                                     06700000
ALOSTORE DS    2A                                                       06710000
OSPARMS  DS    A                   ADDRESS OF O.S. PARAMETERS        #  06720000
OSPARMAD DC    A(0)                POINTER TO O.S. STRING            #  06730000
USESTORE DC    A(8000)                                                  06740000
OLDPICA  DC    A(1)                                                  #  06750000
PASSPIE  SPIE  $PASINT,((1,7),9,11,12,15),MF=L                       #  06760000
ERRLIMIT DC    F'1'                LIMIT ON NUMBER OF ERRORS            06770000
EXECTIME DC    XL4'7FFFFFFF'       DEFAULT TIME LIMIT                   06780000
OSPARML  DC    H'0'                LENGTH OF PARM STRING             #  06790000
DUMPFLAG DC    X'00'               X'FF' IF DUMP REQUESTED              06800000
SPIEFLAG DC    X'00'               X'FF' IF SPIE NOT TO BE ISSUED    #  06810000
SNAPFLAG DC    X'00'               X'FF' IF SNAPSHOT NOT TO BE CALLED#  06820000
*                                                                       06830000
DATESAV  DS    F         # THESE LOCATIONS TO SUCCEED WITH NO GAP       06840000
         DS    2F        #      UNPACKING BUFFER                        06850000
         DC    X'1900'   #                                              06860000
MONTH    DS    3X        #                                              06870000
JAN      DC    P'31,29,31,30,31,30,31,31,30,31,30,31'                   06880000
*                                                                       06890000
         LTORG ,                                                        06900000
         EJECT                                                          06910000
*********************************************************************** 06920000
*                                                                       06930000
*                                                                       06940000
*        INTERRRUPT PROCCESSING FOR PASCAL PROGRAMS                     06950000
*                                                                       06960000
*        ONLY FIXED/FLOAT DIVISION BY ZERO AND EXPONENT OVERFLOW        06970000
*        INTERRUPTS ARE EXPECTED TO BE CAUGHT HERE, OTHER INTERRUPTS    06980000
*        IN GENERAL ARE CAUSED BY STACK/HEAP OVER FLOW OR A BAD I/O     06990000
*        FILE SPECIFICATION AND OR MISSING APPROPRIATE DD STATEMENTS.   07000000
*                                                                       07010000
*********************************************************************** 07020000
         DS    0H                                                       07030000
         USING *,R15                                                    07040000
$PASINT  B     *+12                                                     07050000
         DC    X'7',C'$PASINT'                                          07060000
         MVC   INTDATA(32),0(R1)   SAVE ALL INTERRUPT DATA FOR       #  07070000
         STM   R3,R13,INTDATA+32   POSSIBLE INCLUSION IN ABEND DUMP  #  07080000
         LA    R0,PASINT1          GO TO PASINT1 VIA THE CONTROL     #  07090000
         ST    R0,8(R1)            PROGRAM TO CANCEL SPIE EXIT       #  07100000
         BR    R14                                                   #  07110000
         DROP  R15                                                   #  07120000
*                                                                       07130000
PASINT1  BALR  R11,0               RE-ESTABLISH ADDRESSABILITY       #  07140000
         USING *,R11                                                 #  07150000
         L     R1,=A(OLDPICA)      CANCEL THE SPIE TRAP              #  07160000
         L     1,0(R1)             THAT IS IN EFFECT                 #  07170000
         SPIE  MF=(E,(1))                                            #  07180000
*                                                                    #  07190000
*        GET INTERRUPT CODE AND POINT TO THE APPROPRIATE ERROR MESSAGE  07200000
*                                                                       07210000
         SR    R4,R4                                                    07220000
         IC    R4,INTDATA+7        GET THE INTERRUPT CODE            #  07230000
         LA    R8,2000(R4)         SET THE RETURN CODE                  07240000
         IC    R4,MSGTBL(R4)                                            07250000
         LA    R3,MSGTXT+1(R4)     R3 --> ERROR MESSAGE                 07260000
         IC    R4,MSGTXT(R4)       R4 --> MESSAGE LENGTH                07270000
         L     R14,INTDATA+8       GET LOCATION OF INTERRUPT         #  07280000
         CLI   SPUSERSA,X'FF'               SEE IF INTERR. IN SP MODULE 07290000
         BE    NOTINSP                                                  07300000
*                                                                       07310000
*        IF INTERRUPTION OCCURED WITHIN THE '$PASCSP' ROUTINE PATCH UP  07320000
*        A SAVE AREA TO POINT TO CALLERS SAVE AREA FOR A MEANINGFULL    07330000
*        ERROR MESSAGE.                                                 07340000
*                                                                       07350000
         L     R5,=A(SPUSERSA)              GET USER REGS               07360000
         LM    R12,R15,(R12-R1)*4(R5)       GET IMPORTANT VALUES        07370000
         LR    R10,R15                      SET PROC ENTRY POINT ADR    07380000
         ST    R13,FAKESA+4                 SET SAVE AREA CHAIN         07390000
         STM   R14,R15,FAKESA+12            SET RETURN ADR FIELD        07400000
         LA    R13,FAKESA                                               07410000
         L     R14,INTDATA+8       RESET INTERRUPT LOCATION          #  07420000
         B     KNOWNPRC                                                 07430000
*                                                                       07440000
*        SEE IF R10 POINTS TO THE BEGINING OF A PROC.                   07450000
*                                                                       07460000
NOTINSP  L     R12,=A(ALOSTORE)        GET THE STACK ADDRESS            07470000
         L     R12,0(R12)                                               07480000
         LA    R12,STACK-DYNSTORE(R12) POINT TO BASE OF THE STACK       07490000
         LA    R10,0(R10)                                               07500000
*        C     R10,=A($PASCSP)                                       #  07510000
*        BL    FIXENTRY                IF R10 IS OUT OF BOUND, SKIP  #  07520000
*        C     R10,=A($MAINBLK)                                      #  07530000
*        BH    FIXENTRY                                              #  07540000
         LH    R5,0(R10)               R10 IS WITHIN BOUND, SEE IF      07550000
         CH    R5,=XL2'47F0'           IT POINTS TO A PROC ENTRY POINT  07560000
         BNE   FIXENTRY                                                 07570000
         CR    R13,R12                 SEE IF SAVE AREA PTR IS          07580000
         BL    FIXENTRY                WITHIN BOUNDS                    07590000
         C     R13,NEWPTR-STACK(R12)                                    07600000
         BH    FIXENTRY                                                 07610000
         C     R10,16(R13)             CONSISTANCY CHECK                07620000
         BE    KNOWNPRC                THIS IS A USER PROCEDURE ?       07630000
*                                                                       07640000
*        R10 POINTS TO NOWHERE, FAKE A PROCEDURE HEADING                07650000
*                                                                       07660000
FIXENTRY ST    R12,4+FAKESA            CHAIN THE FAKE SAVE AREA         07670000
         L     R5,16(R12)              POINT TO $MAINBLK ENTRY POINT    07680000
         ST    R5,12+FAKESA            SET RET. ADR. FROM FAKE PROC     07690000
         LA    R10,FAKEPROC            POINT TO THE ENTRY OF FAKEPROC   07700000
         AR    R14,R10                 ALSO SET THE ERROR LOCATION ADR  07710000
         LA    R13,FAKESA                                               07720000
*                                                                       07730000
*        THIS IS THE ENTRY TO A FAKE PROC TO BE USED IF                 07740000
*        NO MEANINGFULL PROC IS FOUND AFTER AN INTRRUPT                 07750000
*                                                                       07760000
KNOWNPRC L     R15,=A($CHKMSG0)                                         07770000
         BR    R15                GO TO PRINT ERROR MESSAGE             07780000
*                                                                       07790000
         USING *,R15                                                    07800000
FAKEPROC B     *+12                                                     07810000
         DC    AL1(7),C'UNKNOWN'                                        07820000
*                                                                       07830000
FAKESA   DC    6F'0'                                                    07840000
*                                                                    #  07850000
         DC    CL8'INTDATA'                                          #  07860000
INTDATA  DS    19F                 INTERRUPT DATA                    #  07870000
*                                                                       07880000
MSGTBL   DC    AL1(0,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1,IMSG1)   07890000
         DC    AL1(IMSG2,IMSG1,IMSG2,IMSG3,IMSG1,IMSG1,IMSG2)           07900000
*                                                                       07910000
MSGTXT   DS    0C                                                       07920000
IM1      DC    AL1(L'IMSG1),C' PROGRAM INTERRUPT, SEE RETURN CODE.'     07930000
IMSG1    EQU   IM1-MSGTXT,*-IM1-1                                       07940000
IM2      DC    AL1(L'IMSG2),C' DIVISION BY ZERO '                       07950000
IMSG2    EQU   IM2-MSGTXT,*-IM2-1                                       07960000
IM3      DC    AL1(L'IMSG3),C' EXPONENT OVERFLOW '                      07970000
IMSG3    EQU   IM3-MSGTXT,*-IM3-1                                       07980000
         DC    C'    '                                                  07990000
         DROP  R11                                                      08000000
*                                                                       08010000
***************************************************************         08020000
*                                                                       08030000
*        END OF INTERRUPT HANDLING ROUTINE                              08040000
*                                                                       08050000
***************************************************************         08060000
         SPACE 2                                                        08070000
****************************************************************        08080000
*                                                                       08090000
*                                                                       08100000
*        PASCAL RUN TIME CHECK/ABORT ROUTINES                           08110000
*                                                                       08120000
*                                                                       08130000
*        THE $CHKMSG ROUTINE IS USED BY THE INTERRUPT HANDLER AS        08140000
*        WELL AS OTHER $PASCSP ROUTINES TO PRINT OUT DIAGNOSTIC         08150000
*        MESSAGES ON THE 'OUTPUT' FILE.                                 08160000
*                                                                       08170000
*                                                                       08180000
****************************************************************        08190000
*                                                                       08200000
*                                                                       08210000
*        RANGE CHECK ROUTINE                                            08220000
*                                                                       08230000
$RNGCHK  DS    0H                                                       08240000
         USING *,R15                                                    08250000
         CR    R2,R0    CHECK LOWER BOUND                               08260000
         BL    BADRNG                                                   08270000
         CR    R2,R1    CHECK UPPER BOUND                               08280000
         BNHR  R14      IF WITHIN BOUNDS, RETURN                        08290000
BADRNG   STM   R0,R15,CHKSVALL SAVE IN CASE RETURN                      08300000
         LA    R3,RNGMSG                                                08310000
         LA    R4,L'RNGMSG                                              08320000
         LA    R8,SUBERR    RETURN CODE                                 08330000
         B     $CHKMSG                                                  08340000
*                                                                       08350000
*                                                                       08360000
*        INDEX CHECK ROUTINE                                            08370000
*                                                                       08380000
$INXCHK  DS    0H                                                       08390000
         USING *,R15                                                    08400000
         CR    R2,R0    CHECK LOWER BOUND                               08410000
         BL    BADINX                                                   08420000
         CR    R2,R1    CHECK UPPER BOUND                               08430000
         BNHR  R14      IF WITHIN BOUNDS, RETURN                        08440000
BADINX   STM   R0,R15,CHKSVALL  SAVE IN CASE HAVE TO RETURN             08450000
         LA    R3,INXMSG                                                08460000
         LA    R4,L'INXMSG                                              08470000
         LA    R8,INXERR     SET RETURN CODE                            08480000
         B     $CHKMSG                                                  08490000
*                                                                       08500000
*                                                                       08510000
*        POINTER CHECK ROUTINE                                          08520000
*                                                                       08530000
*                                                                       08540000
$PTACHK  DS    0H                                                       08550000
         USING *,R15                                                    08560000
         SR    R0,R0                                                    08570000
         BCTR  R0,0     R0 <-- '-1'                                     08580000
         CR    R0,R2                                                    08590000
         BER   R14      NIL VALUE BEING ASSIGNED                        08600000
*                                                                       08610000
         BALR  R15,0    GO TO NEXT ROUTINE TO CNTINUE CHECKING          08620000
*                                                                       08630000
$PTRCHK  DS    0H                                                       08640000
         USING *,R15                                                    08650000
         LM    R0,R1,NEWPTR   LOAD POINTER RANGE                        08660000
         CR    R2,R0    CHECK LOWER BOUND                               08670000
         BL    BADPTR                                                   08680000
         CR    R2,R1    CHECK UPPER BOUND                               08690000
         BNHR  R14      IF WITHIN BOUNDS, RETURN                        08700000
BADPTR   STM   R0,R15,CHKSVALL SAVE IN CASE OF RETURN                   08710000
         LA    R3,PTRMSG                                                08720000
         LA    R4,L'PTRMSG                                              08730000
         LA    R8,PTRERR                                                08740000
         B     $CHKMSG                                                  08750000
*                                                                       08760000
*                                                                       08770000
*        PASSED PARAMETER CHECK ROUTINE                                 08780000
*                                                                       08790000
$PRMCHK  DS    0H                                                       08800000
         USING *,R15                                                    08810000
         CR    R2,R0    CHECK LOWER BOUND                               08820000
         BL    BADPRM                                                   08830000
         CR    R2,R1    CHECK UPPER BOUND                               08840000
         BNHR  R14      IF WITHIN BOUNDS, RETURN                        08850000
BADPRM   STM       R0,R15,CHKSVALL SAVE IN CASE OF RETURN               08860000
         LA    R3,PRMMSG                                                08870000
         LA    R4,L'PRMMSG                                              08880000
         LA    R8,PARERR     SET RETURN CODE                            08890000
         B     $CHKMSG                                                  08900000
*                                                                       08910000
*                                                                       08920000
*        SET MEMBER CHECK ROUTINE                                       08930000
*                                                                       08940000
$SETCHK  DS    0H                                                       08950000
         USING *,R15                                                    08960000
         CL    R2,=F'63'                                             #  08970000
         BNHR  R14                IF WITHIN BOUNDS, RETURN              08980000
BADSET   STM       R0,R15,CHKSVALL SAVE IN CASE OF RETURN               08990000
         LA    R3,SETMSG                                                09000000
         LA    R4,L'SETMSG                                              09010000
         LM    R0,R1,=F'0,63'                                           09020000
         LA    R8,SETERR                                                09030000
         B     $CHKMSG                                                  09040000
*                                                                       09050000
*        STACK/HEAP INTERFERENCE ERROR                                  09060000
*                                                                       09070000
$STKCHK  DS    0H                                                       09080000
         USING *,R15                                                    09090000
         LA    R3,STKMSG                                                09100000
         LA    R4,L'STKMSG                                              09110000
         LA    R8,STKERR                                                09120000
         B     $CHKMSG0                                                 09130000
*                                                                       09140000
*        'TIME OUT' ENTRY POINT                                         09150000
*                                                                       09160000
*        ASSUMES THAT R10 POINTS TO THE CURR PROC ENTRY POINT           09170000
*        THIS MAY NOT BE TRUE UNDER MFT OR SOME OTHER VARIANTS          09180000
*        OF THE OPERATING SYSTEM. ( 'STIMER' PECULIARITY )              09190000
*                                                                       09200000
$TIMEOUT DS    0H                 ENTRY TO TIME OUT ERROR               09210000
         BALR  R15,0                                                    09220000
         USING *,R15                                                    09230000
         L     R12,=A(ALOSTORE)   RESTORE STACK POINTER IN CASE !       09240000
         L     R12,0(R12)                                               09250000
         LA    R12,STACK-DYNSTORE(R12)                                  09260000
         LR    R13,R12                                                  09270000
*                                                                       09280000
         CLI   SPUSERSA,X'FF'     SEE IF TIMER WENT OFF IN '$PASCSP'    09290000
         BE    TIMEOUT2                                                 09300000
         LM    R1,R14,SPUSERSA     IF SO, RESTORE REGS ACCORDINGLY      09310000
         B     TIMEOUT4                                                 09320000
*                                                                       09330000
TIMEOUT2 L     R1,16          LOAD CVT ADDR                          #  09340000
         L     R1,0(,R1)      LOAD TCB WORDS ADDR                    #  09350000
         L     R1,4(,R1)      ADDR OF CURRENT TCB                    #  09360000
         L     R1,120(,R1)    ADDR OF TQE                            #  09370000
         L     R1,28(,R1)     ADDR OF RB                             #  09380000
         L     R1,20(,R1)     WORD2 OF OLD PSW (AT LAST)             #  09390000
         LA    R14,0(,R1)     SET ERROR LOC TO THIS ADDRESS          #  09400000
TIMEOUT3 C     R10,16(R13)        GO DOWN THE CALL CHAIN UP TO          09410000
         BE    TIMEOUT4           CURRENT PROC.                         09420000
         L     R13,8(R13)         PROCEED TO NEXT SAVE AREA             09430000
         B     TIMEOUT3                                                 09440000
*                                                                       09450000
TIMEOUT4 DS    0H                                                       09460000
         LA    R3,TIMMSG                                                09470000
         LA    R4,L'TIMMSG                                              09480000
         LA    R8,TIMERR                                                09490000
         B     $CHKMSG0                                                 09500000
*                                                                       09510000
*                                                                       09520000
*                                                                       09530000
*        THIS IS THE ENTRY POINT FOR RUN-TIME ERROR INDICATION          09540000
*        AND THE RELATED MESSAGES.                                      09550000
*                                                                       09560000
*                                                                       09570000
$CHKMSG0 BALR  R11,0              ENTRY POINT FOR FATAL ERRORS          09580000
         USING *,R11                                                    09590000
         MVI   NORETURN,X'FF'                                           09600000
         B     $CHKMSG3                                                 09610000
$CHKMSG  BALR  R11,0              ENTRY FOR (POSSIBLY) REPEATABLE ERROR 09620000
         USING *,R11                                                    09630000
         MVI   NORETURN,X'00'                                           09640000
$CHKMSG3 BALR  R11,0                                                    09650000
         DROP  R15                                                      09660000
         USING *,R11                                                    09670000
         LA    R14,0(R14)                                               09680000
         LA    R15,0(R15)         GET RID OF FLAG BITS                  09690000
         STM   R14,R13,CHKSAVE    SAVE RELEVENT REGISTERS               09700000
*                                                                       09710000
         L     R2,SNAPADR                                               09720000
         LTR   R2,R2               IS SNAPSHOT LOADED ?                 09730000
         BZ    NOSNAP                                                   09740000
         L     R2,=A(SNAPFLAG)                                       #  09750000
         CLI   0(R2),X'00'         SNAPSHOT TO BE USED?              #  09760000
         BNE   NOSNAP              NO                                #  09770000
*                                                                       09780000
         ST    R8,CHKSAVE-4        SAVE ERROR CODE                      09790000
         GETMAIN EC,LV=SNAPAREA,A=SNAPLOCS                           #  09800000
         LTR   R15,R15             SUCCESSFUL ?                      #  09810000
         BNZ   NOSNAP              NOT ENOUGH SPACE FOR SNAPSHOT     #  09820000
         L     R1,SNAPLOCS                                           #  09830000
*        R1 POINTS TO THE BASE OF GOTTEN AREA                           09840000
         SR    R2,R2                                                    09850000
         BCTR  R2,0                R2 <-- '-1'                          09860000
         ST    R2,LCAFTMST(R1)     FIRST PARM OF 'SNAPSHOT'             09870000
         LA    R2,CHKSAVE-4        SECOND PARM OF 'SNAPSHOT'            09880000
         ST    R2,LCAFTMST+4(R1)                                        09890000
         L     R15,SNAPADR                                              09900000
         BALR  R14,R15                                                  09910000
         FREEMAIN R,LV=SNAPAREA,A=SNAPLOCS  RETURN THE AREA TO O.S.  #  09920000
         B     SNAPDONE                                                 09930000
*                                                                       09940000
NOSNAP   DS    0H                                                       09950000
         LA    R8,SNPERR(R8)                                            09960000
         L     R15,=A($PASCSP)    PREPARE TO CALL I/O MODULE            09970000
         LA    R9,OUTPUT          PICK THE FILE NAME                    09980000
         LA    R1,PREW            (RE)OPEN THE MESSAGE (OUTPUT) FILE    09990000
         BALR  R14,R15                                                  10000000
         LA    R1,PSKP                                               #  10010000
         LA    R2,2                                                  #  10020000
         BALR  R14,R15            SPACE PROPERLY                        10030000
*                                                                       10040000
         LA    R1,PWRS            THE FUNCTION (WRITE STRING)           10050000
         LA    R2,MSG1                                                  10060000
         LA    R4,L'MSG1                                                10070000
         LA    R3,3(R4)           STRING LENGTH AND FIELD WIDTH         10080000
         BALR  R14,R15                                                  10090000
*                                                                       10100000
         LA    R1,PWRI            WRITE LOCATION OF ERROR               10110000
         L     R2,CHKSAVE                                               10120000
         S     R2,CHKSAVE+(R10+2)*4    RELATIVE ADDRESS OF ERROR        10130000
         LA    R3,11                   LOCATION AND ITS FIELD WIDTH     10140000
         BALR  R14,R15                                                  10150000
*                                                                       10160000
         L     R2,CHKSAVE+4*(R10+2)    POINT TO PROC. ENTRY POINT       10170000
         MVC   MSG2PROC,5(R2)          AND MOVE THE PROC. NAME          10180000
         LA    R1,PWRS                                                  10190000
         LA    R2,MSG2                                                  10200000
         LA    R3,L'MSG2+7                                              10210000
         LR    R4,R3                                                    10220000
         BALR  R14,R15                                                  10230000
*                                                                       10240000
*        INDICATE THE TYPE OF RUN TIME ERROR                            10250000
*                                                                       10260000
         LA    R1,PSKP                                               #  10270000
         LA    R2,2                                                  #  10280000
         BALR  R14,R15                 NEW LINE                         10290000
         LA    R1,PWRS                                                  10300000
         LA    R2,MSG1                 ' **** '                         10310000
         LA    R4,7                                                     10320000
         LA    R3,3(R4)                                                 10330000
         BALR  R14,R15                                                  10340000
         LM    R2,R3,CHKSAVE+4*(R3+2)                                   10350000
         LR    R4,R3                                                    10360000
         BALR  R14,R15                                                  10370000
*                                                                       10380000
*        INDICATE THE STATMNT # OF THE ERROR LOCATION, IF ASKED FOR     10390000
*                                                                       10400000
         BAL   R6,PRNTLOC                                               10410000
         AIF   (&SYSTEM).SYS34                                          10420000
*                                                                       10430000
*        PRINT THE ERRONEOUS VALUE AND THE RANGE                        10440000
*                                                                       10450000
PRNTRNG  L     R0,CHKSAVE+4*(R15-R14)                                   10460000
         C     R0,=A($STKCHK)          THESE ERRORS DO NOT HAVE         10470000
         BNL   CALCHAIN                A RANGE TO BE PRINTED            10480000
*                                                                       10490000
         LA    R1,PWRS                                                  10500000
         LA    R2,MSG4                                                  10510000
         LA    R4,L'MSG4                                                10520000
         LA    R3,3(R4)                                                 10530000
         BALR  R14,R15                                                  10540000
         LA    R1,PWRI                                                  10550000
         L     R2,CHKSAVE+4*(R2+2)                                      10560000
         LA    R3,8                                                     10570000
         BALR  R14,R15                 PRINT THE OUT OF RANGE VALUE     10580000
         LA    R1,PWRS                                                  10590000
         LA    R2,MSG5                                                  10600000
         LA    R4,L'MSG5                                                10610000
         LR    R3,R4                                                    10620000
         BALR  R14,R15                                                  10630000
         LA    R1,PWRI                                                  10640000
         L     R2,CHKSAVE+4*(R0+2)                                      10650000
         LA    R3,8                                                     10660000
         BALR  R14,R15                 PRINT LOWER BOUND (OF THE RANGE) 10670000
         LA    R3,10                                                    10680000
         L     R2,CHKSAVE+4*(R1+2)                                      10690000
         BALR  R14,R15                 AND THE UPPER BOUND              10700000
         LA    R1,PSKP                                               #  10710000
         LA    R2,2                                                  #  10720000
         BALR  R14,R15                                                  10730000
*                                                                       10740000
.SYS34   ANOP                                                           10750000
CALCHAIN LA    R1,PSKP                                               #  10760000
         LA    R2,2                                                  #  10770000
         BALR  R14,R15                                                  10780000
         LA    R7,16                   SET MAX # OF LINKS TO BE TRACED  10790000
NXTLNK   CR    R13,R12                 SEE IF END OF STACK              10800000
         BE    CHAINDON                                                 10810000
         MVC   CALLED(7),5(R10)        MOVE CALLERS NAME                10820000
         L     R5,12(R13)              BACK UP TO THE HIGHER SAVE AREA  10830000
         L     R13,4(R13)                                               10840000
         L     R10,12+(R15-R14)*4(R13) ENTRY POINT OF THE 'CALLER'      10850000
         MVC   CALLER(7),5(R10)        MOVE CALLER'S 'NAME'             10860000
         LA    R2,MSG7                                                  10870000
         LA    R3,L'MSG7                                                10880000
         LR    R4,R3                                                    10890000
         LA    R1,PWRS                                                  10900000
         BALR  R14,R15                                                  10910000
         BAL   R6,PRNTLOC              PRINT WHEREABOUT OF THE CALL     10920000
         BCT   R7,NXTLNK               NEXT LEVEL IF NOT EXHAUSTED      10930000
CHAINDON DS    0H                                                       10940000
*                                                                       10950000
*                                                                       10960000
*        TIME TO EXIT                                                   10970000
*                                                                       10980000
ABORT    LA    R1,PWLN                 TERMINATE LINE BUFFER            10990000
         BALR  R14,R15                                                  11000000
*                                                                       11010000
SNAPDONE DS    0H                                                       11020000
         CLI   NORETURN,X'FF'          IF NO RETURN                     11030000
         BE    ABORT2                  THEN ABORT                       11040000
         L     R1,HEAPLIM                                               11050000
         USING DYN2STOR,R1                                              11060000
         L     R3,DYNERRC                                               11070000
         LA    R3,1(R3)                                                 11080000
         ST    R3,DYNERRC                                               11090000
         C     R3,DYNERRL                                               11100000
         BNL   ABORT2                                                   11110000
         DROP  R1                                                       11120000
         LM    R0,R15,CHKSVALL                                          11130000
         BR    R14                                                      11140000
ABORT2   DS    0H                                                       11150000
         L     R15,=A($PASCSP)                                          11160000
         LA    R9,OUTPUT                                                11170000
         LA    R1,PREW                 CLOSE THE MESSAGE FILE           11180000
         BALR  R14,R15                                                  11190000
         LR    R2,R8                                                    11200000
         LA    R1,PXIT                                                  11210000
         BR    R15                                                      11220000
*                                                                       11230000
*                                                                       11240000
PRNTLOC  DS    0H                                                       11250000
SKIP2    LA    R1,PSKP                                               #  11260000
         LA    R2,2                                                  #  11270000
         BALR  R14,R15                                                  11280000
         BR    R6            RETURN TO CALLER                           11290000
.SYS36   ANOP                                                           11300000
*                                                                       11310000
NORETURN DS    X                   IF X'FF' THEN CAN RETURN             11320000
         DS    0D                                                       11330000
CHKSVALL DS    18F                                                      11340000
CHKSAVE  DS    16F                 ALSO INCLUDES THE PREV. FOUR BYTES   11350000
*                                                                       11360000
SNAPADR  DC    V(SNAPSHOT)                                              11370000
SNAPAREA EQU   2048                APPROX SIZE OF SNAPSHOT LOCAL DATA#  11380000
SNAPLOCS DS    A                   ADDRESS OF TEMP SNAPAREA          #  11390000
*                                                                       11400000
*                                                                       11410000
RNGMSG   DC    C' SUBRANGE VALUE OUT OF RANGE '                         11420000
INXMSG   DC    C' INDEX VALUE OUT OF RANGE '                            11430000
PTRMSG   DC    C' POINTER VALUE OUT OF RANGE '                          11440000
PRMMSG   DC    C' ACTUAL PARAMETER OUT OF RANGE '                       11450000
STKMSG   DC    C' STACK/HEAP OVER/UNDER_FLOW '                          11460000
SETMSG   DC    C' SET MEMBER OUT OF RANGE '                             11470000
TIMMSG   DC    C' RUNNING OUT OF TIME '                                 11480000
ENDMSG   DC    C' '                                                     11490000
*                                                                       11500000
MSG1     DC    C' ****   RUN ERROR AT LOCATION :'                       11510000
*                                                                       11520000
MSG2     DC    C'  OF PROCEDURE :  '                                    11530000
MSG2PROC DS    CL7                                                      11540000
*                                                                       11550000
MSG3     DC    C'  BETWEEN P_STATEMENTS :'                              11560000
*                                                                       11570000
MSG4     DC    C' ****   THE OFFENDING VALUE :'                         11580000
*                                                                       11590000
MSG5     DC    C'  IS NOT IN THE RANGE :'                               11600000
*                                                                       11610000
MS7      DC    C'    ****   '                                           11620000
CALLED   DC    CL7' '                                                   11630000
MSG6     DC    C'  WAS CALLED BY :  '                                   11640000
CALLER   DC    CL7' '                                                   11650000
MSG7     EQU   MS7,*-MS7                                                11660000
*                                                                       11670000
         DROP  R11                                                      11680000
         LTORG                                                          11690000
         EJECT                                                          11700000
******************************************************************      11710000
*                                                                       11720000
*                                                                       11730000
*        PASCAL I/O AND STANDARD PROCEDURE (CSP) INTERFACE              11740000
*                                                                       11750000
*        FOLLOWING CODE INTERCEPTS ERRORS DETECTED BY FORTRAN        #  11760000
*        MATH. ROUTINES.  SUCH ROUTINES ARE PRESENT IF REFERRED      #  11770000
*        TO BY THE PASCAL PROGRAM.                                   #  11780000
*                                                                       11790000
******************************************************************      11800000
         SPACE 2                                                        11810000
         AIF   (&SYSTEM).SYS38                                          11820000
*                                                                       11830000
*        IHCERRM - CALLED BY FORTRAN MATH ROUTINES IN CASE OF ERROR     11840000
*                                                                       11850000
ERRMON   DS    0H                                                    #  11860000
IHCERRM  DS    0H                                                       11870000
IHOERRM  DS    0H                                                       11880000
IHNERRM  DS    0H                                                    #  11890000
         ENTRY IHCERRM,IHOERRM,IHOERRE,IHNERRM,IHNERRE,IHCERRE       #  11900000
         ENTRY  ERRMON                                               #  11910000
         USING IHCERRM,R15                                              11920000
         L     R1,0(R1)            GET 1ST ARG - PTR TO A(LEN),C'MSG'   11930000
         SR    R4,R4                                                    11940000
         IC    R4,3(R1)            GET THE MESSAGE LENGTH               11950000
         LA    R3,4(R1)            POINT TO MESSAGE TEXT                11960000
         NOPR  0                   WARNING - THE LOCATION ERRMON+19  #  11970000
         BC    0,0                 CAN BE OVERWRITTEN BY FORTRAN     #  11980000
*                                                                       11990000
*        SET RELEVENT REGS ACCORDING TO $CHKMSG CONVENTIONS             12000000
*                                                                       12010000
         L     R13,4(R13)          POINT TO THE ORIGINAL SAVE AREA      12020000
         L     R10,12+4*1(R13)     ENTRY POINT OF THE CURRENT ROUTINE   12030000
         LR    R14,R10             SET ERROR LOC TO ENTRY POINT TOO     12040000
         L     R12,=A(ALOSTORE)                                         12050000
         L     R12,0(R12)                                               12060000
         LA    R12,STACK-DYNSTORE(R12)    AND THE GLOBAL DATA POINTER   12070000
*                                                                       12080000
         L     R15,=A($CHKMSG0)                                         12090000
         LA    R8,3001             SET ERROR RETURN CODE                12100000
         BR    R15                 AND JOIN THE ERROR HANDLER           12110000
         DROP  R15                                                      12120000
*                                                                       12130000
*        THE FOLLOWING IS FOR THE FORTRAN ERROR MESSAGES                12140000
*                                                                       12150000
IHCERRE  DS    0H                                                    #  12160000
IHNERRE  DS    0H                                                    #  12170000
IHOERRE  BR    R14                 THIS SHOULD NOT BE CALLED            12180000
         LTORG                                                       #  12190000
*                                                                       12200000
         SPACE 2                                                        12210000
.SYS38   ANOP                                                           12220000
         EJECT                                                          12230000
*****************************************************************       12240000
*                                                                       12250000
*                                                                       12260000
*        $PASCSP (PASCAL I/0) ENTRY POINT                               12270000
*                                                                       12280000
*                                                                       12290000
*****************************************************************       12300000
*                                                                       12310000
         DS    0D                                                       12320000
         USING *,15                                                     12330000
$PASCSP  B     *+12                BRANCH AROUND ID                     12340000
         DC    AL1(7),CL7'$PASCSP'                                      12350000
*                                                                       12360000
         STM   R1,R15,SPUSERSA     SAVE ONLY POTENTIALLY USEFULL ONES   12370000
         LA    R13,SPSYSTSA        SET UP SYSTEM SAVE AREA              12380000
         LR    R10,R15                                                  12390000
         LA    R11,2048(,R10)                                        #  12400000
         LA    R11,2048(,R11)      SET UP TWO BASE REGS              #  12410000
         DROP  R15                                                      12420000
         USING $PASCSP,R10,R11                                       #  12430000
         USING IHADCB-FILDCB,AE                                      #  12440000
*        SLA   R1,2                DECODE THE SUBROUTINE NUMBER         12450000
         L     R1,SUBTBL(R1)                                            12460000
         BR    R1                                                       12470000
         DS    0F                                                       12480000
SUBTBL   DC    A(GET,PUT,RES,RLN,REW,WLN,WRS,ELN)                       12490000
         DC    A(WRI,WRR,WRC,RDI,RDR,RDC)                               12500000
         DC    A(SIN,COS,EXP,LOG,SQT,ATN)                               12510000
         DC    A(EOF,XIT,RDS,TRP,SIO,EIO,CLK,FDF,PAG,CLS)               12520000
         DC    A(RDB,WRB,SKP,LIM,MSG,CTR)                            #  12530000
SPUSERSA DC    18XL4'FFFFFFFF'                                          12540000
SPSYSTSA DS    18F                                                      12550000
*                                                                       12560000
*                                                                       12570000
*        (GET FETCH) GET A CHAR TO (AD)                                 12580000
*                                                                       12590000
FILGFE   LH    R1,FILPTR(AE)                                         #  12600000
         LA    R1,1(,R1)                                             #  12610000
         CH    R1,FILEND(AE)       TEST FOR END-OF-LINE              #  12620000
         BNL   FILGFE2             IF SO, GO AND PROVIDE A BLANK     #  12630000
         IC    R0,0(R1,AF)         PICK UP INPUT CHARACTER           #  12640000
FILGFE1  STC   R0,0(AD)             AND PUT INTO CALLER'S BUFFER     #  12650000
         STH   R1,FILPTR(AE)                                         #  12660000
         BR    R5                                                    #  12670000
FILGFE2  LA    R0,FILBLA           SET EOL CHARACTER                 #  12680000
         BE    FILGFE1             GO BACK TO RETURN EOL CHAR        #  12690000
*        B     FILGET              NEED TO GET A NEW INPUT RECORD    #  12700000
*                                                                       12710000
*        GET A RECORD TO (AF)                                           12720000
*                                                                       12730000
FILGET   DS    0H                                                       12740000
         TM    FILEOF(AE),1                                             12750000
         BOR   R5                  RETURN IF END-OF-FILE             #  12760000
         AIF   (&SYSTEM).SYS42                                          12770000
         CLI   FILOPN(AE),READOPN                                       12780000
         BNE   BADREAD             IF FILE NOT OPEN FOR READ, COMPLAIN  12790000
.SYS42   ANOP                                                           12800000
FILGET1  MVI   RRFLAG,0            CLEAR REREAD FLAG                 #  12810000
         GET   FILDCB(AE)          READ THE NEXT RECORD              #  12820000
         CLI   RRFLAG,0            TEST IF REREAD ASKED FOR          #  12830000
         BNE   FILGET1             IF SO, GO BACK AND TRY AGAIN      #  12840000
         ST    R1,FILBUF(AE)       STORE ADDRESS OF INPUT RECORD     #  12850000
         LR    AF,R1                                                 #  12860000
         LH    R1,FILBEG(AE)                                         #  12870000
         STH   R1,FILPTR(AE)       RESET CHAR. PTR                   #  12880000
         IC    R0,0(R1,AF)                                           #  12890000
         STC   R0,0(AD)            UPDATE CURRENT FILE ELEMENT       #  12900000
         MVC   FILEND(2,AE),DCBLRECL    RESET BUFFER LENGTH          #  12910000
         BR    R5                                                       12920000
*                                                                    @  12930000
*        (GET NON-BLANK) GET NEXT NON-BLANK TO (AD)                  @  12940000
*                                                                    @  12950000
FILGNB   LH    R1,FILPTR(AE)                                         @  12960000
FILGNB0  LA    R15,0(R1,AF)                                          @  12970000
         CLI   0(R15),FILBLA                                         @  12980000
         BNE   FILGNB2             JUMP IF WE HAVE A NON-BLANK       @  12990000
         LA    R1,1(,R1)           OTHERWISE, STEP TO NEXT POSITION  @  13000000
         CH    R1,FILEND(AE)                                         @  13010000
         BL    FILGNB0             GO BACK AND TRY AGAIN             @  13020000
         ST    R5,FILPSTSV         NEED TO REFILL THE LINE           @  13030000
         BAL   R5,FILGET                                             @  13040000
         L     R5,FILPSTSV                                           @  13050000
         TM    FILEOF(AE),1        HAVE WE HIT THE EOF?              @  13060000
         BO    EOFREAD             IF SO, IT'S AN ERROR              @  13070000
         B     FILGNB                                                @  13080000
FILGNB2  IC    R0,0(R15)           TRANSFER THE CHAR TO              @  13090000
         STC   R0,0(AD)            THE FILE BUFFER                   @  13100000
         STH   R1,FILPTR(AE)       RESTORE THE FILE POINTER          @  13110000
         BR    R5                  AND RETURN                        @  13120000
*                                                                       13130000
*        (PUT-STORE) PUT A CHAR FROM (AD)                               13140000
*                                                                       13150000
FILPST   LH    R1,FILPTR(AE)                                            13160000
         CH    R1,FILEND(AE)       TEST IF BUFFER FULL               #  13170000
         BNL   FILPST1             CLEAR IT FIRST                    #  13180000
         IC    R0,0(AD)                                              #  13190000
         STC   R0,0(R1,AF)                                           #  13200000
         LA    R1,1(R1)            INCREMENT CHAR. PTR.              #  13210000
         STH   R1,FILPTR(AE)                                         #  13220000
         BR    R5                                                    #  13230000
FILPST1  ST    R5,FILPSTSV         SAVE RETURN ADDRESS               #  13240000
         BAL   R5,FILPUT           EMPTY THE BUFFER                  #  13250000
         L     R5,FILPSTSV                                           #  13260000
         B     FILPST                                                #  13270000
*                                                                       13280000
*        PUT A RECORD (FROM AF)                                         13290000
*                                                                       13300000
FILPUT   DS    0H                                                       13310000
         AIF   (&SYSTEM).SYS44                                          13320000
         CLI   FILOPN(AE),WRITEOPN                                      13330000
         BNE   BADWRITE            IF NOT OPEN FOR WRITE, THEN COMPLAIN 13340000
.SYS44   ANOP                                                           13350000
*        ST    R5,FILPUTSV         SAVE RETURN REG                   #  13360000
*        BAL   R5,FILPUT1          COMPLETE THE OUTPUT LINE          #  13370000
*        L     R5,FILPUTSV         RESTORE RETURN REG                #  13380000
*                                                                    #  13390000
*        PREPARE THE OUTPUT BUFFER FOR TRANSMITTING TO O.S.          #  13400000
*                                                                    #  13410000
FILPUT1  DS    0H                                                    #  13420000
         CLI   DCBRECFM,X'80'                                        #  13430000
         BNL   FILPUT4             RETURN IF F OR U-FORMAT           #  13440000
         LA    R0,6                MIN LENGTH FOR VBA RECORDS        #  13450000
         TM    DCBRECFM,X'06'                                        #  13460000
         BNZ   *+6                 JUMP IF CONTROL CHARS             #  13470000
         BCTR  R0,0                ADJUST MIN LENGTH                 #  13480000
         LH    R1,FILPTR(AE)                                         #  13490000
         CR    R1,R0                                                 #  13500000
         BNL   FILPUT2             JUMP IF RECORD SIZE OK            #  13510000
         LTR   AF,AF               RETURN IF THE I/O BUFFER IS NOT   #  13520000
         BZ    FILPUT4             ALLOCATED  (FILE NEWLY OPENED)    #  13530000
         LA    R0,FILBLA                                             #  13540000
         STC   R0,0(R1,AF)         PROVIDE 1 CHAR AT LEAST           #  13550000
         LA    R1,1(R1)                                              #  13560000
FILPUT2  STC   R1,1(AF)            SET RDW FOR V-FORMAT              @  13570000
         SRA   R1,8                - BUT DO IT WITH 2 STC INST.S TO  @  13580000
         STC   R1,0(AF)              AVOID ALIGNMENT ERRORS ON 360'S @  13590000
*                                                                    #  13600000
FILPUT4  DS    0H                                                       13610000
         PUT   FILDCB(AE)          WRITE THE RECORD                  #  13620000
         ST    R1,FILBUF(AE)       SAVE ADDRESS OF NEXT OUTPUT BUFFER#  13630000
         MVC   FILEND(2,AE),DCBLRECL  RESET BUFFER LENGTH            #  13640000
         LR    AF,R1                                                 #  13650000
         AIF   (&SYSTEM).SYS415                                      #  13660000
         L     R0,FILLIM(AE)       LOAD LINES LIMIT                  #  13670000
         BCT   R0,FILPUT6          DECREMENT                         #  13680000
         ST    R0,FILLIM(AE)       OVERFLOW OF COUNTER               #  13690000
         B     LIMITERR                                              #  13700000
FILPUT6  ST    R0,FILLIM(AE)       PUT DECREMENTED COUNT BACK        #  13710000
.SYS415  ANOP                                                        #  13720000
*        B     FILCLR              I.E., NEXT LINE                   #  13730000
*                                                                    #  13740000
*        CLEAR THE OUTPUT BUFFER TO BLANKS                           #  13750000
*                                                                    #  13760000
FILCLR   LH    R1,FILBEG(AE)                                         #  13770000
         STH   R1,FILPTR(AE)       RESET CHAR. POINTER               #  13780000
         CLI   DCBRECFM,X'80'      JUMP IF F OR U-FORMAT             #  13790000
         BNL   FILCLR1                                               #  13800000
         TM    DCBRECFM,X'06'                                        #  13810000
         BZR   R5                  RETURN IF NO CONTROL CHAR NEEDED  #  13820000
         MVI   4(AF),FILBLA        SET DEFAULT CONTROL CHAR          #  13830000
         TM    DCBRECFM,X'04'                                        #  13840000
         BOR   R5                  RETURN IF ASCII CONTROL CHARS     #  13850000
         MVI   4(AF),X'09'         REPLACE WITH MACHINE CHAR         #  13860000
         BR    R5                                                    #  13870000
FILCLR1  LH    R15,FILEND(AE)      LOAD BUFFER LENGTH                #  13880000
         LA    R14,256                                               #  13890000
         LR    R1,AF               LOAD BUFFER ADDRESS               #  13900000
         MVI   0(AF),FILBLA                                          #  13910000
         SH    R15,=H'2'                                             #  13920000
         B     FILCLR3                                               #  13930000
FILCLR2  MVC   1(256,R1),0(R1)     PROPAGATE BLANKS                  #  13940000
         AR    R1,R14                                                #  13950000
         SR    R15,R14                                               #  13960000
FILCLR3  BMR   R5                                                    #  13970000
         CR    R15,R14                                               #  13980000
         BNL   FILCLR2                                               #  13990000
         EX    R15,CLRBUF          CLEAR REMAINDER OF BUFFER         #  14000000
         TM    DCBRECFM,X'02'                                        #  14010000
         BZR   R5                  RETURN IF NOT MACH CONTROL CHAR   #  14020000
         MVI   0(AF),X'09'                                           #  14030000
         BR    R5                                                    #  14040000
*                                                                    #  14050000
CLRBUF   MVC   1(0,R1),0(R1)       PROPAGATE BLANKS                  #  14060000
*                                                                       14070000
*        'END OF DATA' EXIT, THIS ROUTINE IS ENTERED WHENEVER           14080000
*        A 'GET' IS ISSUED FOR A FILE WHICH HAS REACHED THE             14090000
*        'END OF FILE' MARK. (I.E. NO MORE INPUT)                       14100000
*                                                                       14110000
EOD      DS    0H                                                       14120000
         LA    AG,FILDCB(AE)                                         #  14130000
         CLOSE ((AG))                                                   14140000
         TM    DCBBUFCB+3,1                                          #  14150000
         BO    EOD1                SKIP IF NO BUFFER POOL            #  14160000
         FREEPOOL (AG)                                               #  14170000
EOD1     EQU   *                                                     #  14180000
         OI    FILEOF(AE),1                                             14190000
         MVI   FILOPN(AE),0         CLEAR THE OPEN FLAG                 14200000
         MVI   0(AD),FILBLA        SET EOL CHARACTER                 #  14210000
         SR    AF,AF               INDICATE NO I/O BUFFER            #  14220000
         STH   AF,FILBEG(AE)       RESET VARIOUS POINTERS            #  14230000
         STH   AF,FILEND(AE)                                         #  14240000
         STH   AF,FILPTR(AE)                                         #  14250000
         ST    AF,FILBUF(AE)                                         #  14260000
         BR    R5                                                    #  14270000
*                                                                       14280000
*        EXIT ROUTINE CALLED WHEN DCB IS OPENED                      #  14290000
*              IN THIS ROUTINE, WE PROVIDE SOME REASONABLE DEFAULTS  #  14300000
*              FOR THE RECFM, LRECL, BLKSIZE AND BUFNO ATTRIBUTES    #  14310000
*              THIS ROUTINE ALSO SETS THE REREAD FLAG WHEN NEEDED    #  14320000
*              AT THE CHANGE-OVER BETWEEN TWO CONCATENATED           #  14330000
*              INPUT FILES.                                          #  14340000
*                                                                    #  14350000
XLSTRTIN LA    R1,DEFAULTS         ENTRY FOR INPUT AND INOUT FILES   #  14360000
         TM    DCBOFLGS,X'08'      TEST IF CONCAT. FLAG SET          #  14370000
         BZ    XLSTRT1                                               #  14380000
         MVI   RRFLAG,X'FF'        REQUEST A REREAD                  #  14390000
         B     XLSTRT2                                               #  14400000
XLSTRT1  OI    DCBOFLGS,X'08'      REQUEST PROCESSING OF CONCAT FILES#  14410000
XLSTRT2  SR    R0,R0                                                 #  14420000
         CLI   DCBBUFNO,0                                            #  14430000
         BNE   XLSTRT3             JUMP IF BUFNO PROVIDED            #  14440000
         MVC   DCBBUFNO(1),4(R1)                                     #  14450000
XLSTRT3  TM    DCBRECFM,X'FE'                                        #  14460000
         BNE   XLSTRT4             JUMP IF RECFM SPECIFIED           #  14470000
         OC    DCBRECFM(1),5(R1)                                     #  14480000
XLSTRT4  LH    R15,0(R1)           LOAD TARGET BYTES PER RECORD      #  14490000
         CH    R0,DCBLRECL                                           #  14500000
         BNE   XLSTRT5             JUMP IF LRECL SPECIFIED           #  14510000
         TM    DCBRECFM,X'C0'                                        #  14520000
         BO    XLSTRT5             JUMP IF U-FORMAT (LEAVE LRECL=0)  #  14530000
         CLI   DCBRECFM,X'80'                                        #  14540000
         BNL   *+8                 JUMP IF F-FORMAT                  #  14550000
         LA    R15,4(R15)          ALLOW FOR RDW/SDW IN RECORD LENGTH#  14560000
         TM    DCBRECFM,X'06'                                        #  14570000
         BZ    *+8                 JUMP IF NO CONTROL CHAR.          #  14580000
         LA    R15,1(R15)          ADD IN 1 BYTE FOR CONTROL CHAR    #  14590000
         STH   R15,DCBLRECL                                          #  14600000
XLSTRT5  CH    R0,DCBBLKSI                                           #  14610000
         BNER  R14            RETURN IF BLKSIZE SPECIFIED            #  14620000
         LH    R1,2(R1)       LOAD TARGET BLKSIZE                    #  14630000
         CLI   DCBRECFM,X'80'                                        #  14640000
         BNL   XLSTRT6        JUMP IF NOT V-FORMAT                   #  14650000
         LA    R15,4(R15)     LRECL+4 IS MINIMUM BLKSIZE             #  14660000
         B     XLSTRT7                                               #  14670000
XLSTRT6  TM    DCBRECFM,X'C0'                                        #  14680000
         BO    XLSTRT8        JUMP IF RECFM=U                        #  14690000
         DR    R0,R15         THEREFORE, RECFM=F HERE                #  14700000
         MR    R0,R15                                                #  14710000
XLSTRT7  CR    R1,R15                                                #  14720000
         BL    XLSTRT8                                               #  14730000
         LR    R15,R1                                                #  14740000
XLSTRT8  STH   R15,DCBBLKSI                                          #  14750000
         BR    R14                                                   #  14760000
XLSTRTOT LA    R1,DEFAULTS         ENTRY FOR OUTPUT DCB'S            #  14770000
         C     AE,=A(FILOUT)       TEST IF FILE IS "OUTPUT"          #  14780000
         BNE   XLSTRT2             IT USES DIFFERENT DEFAULTS        #  14790000
         LA    R1,OUTDFLTS                                           #  14800000
         B     XLSTRT2                                               #  14810000
*                                                                       14820000
*        RESET AN INPUT FILE                                            14830000
*                                                                       14840000
*                                                                       14850000
         DC    CL4'RES '                                                14860000
RES      DS    0H                                                       14870000
         LA    R0,FILCOUNT+INPUT   LAST+1 FILE ADDRESS                  14880000
         CR    AD,R0                                                    14890000
         BNL   BADREAD             RESETTING A NON EXISTANT FILE ?      14900000
         FILADR ,                                                       14910000
         BAL   R5,FILCLS           GO AND CLOSE THE FILE             #  14920000
*                                                                       14930000
*        (GET) OPEN A FILE                                              14940000
*                                                                       14950000
FILGOP   MVI   FILOPN(AE),0        CLEAR OPEN FLAG                      14960000
         LA    AG,FILDCB(AE)                                         #  14970000
         OPEN  ((AG),(INPUT))                                           14980000
         TM    DCBOFLGS,X'10'                                           14990000
         BNO   BADREAD                                                  15000000
         LH    R1,DCBLRECL                                              15010000
         TM    DCBRECFM,X'C0'                                        #  15020000
         BNO   *+8                 JUMP IF NOT U-FORMAT              #  15030000
         LH    R1,DCBBLKSI                                           #  15040000
         STH   R1,FILEND(AE)       SET LRECL FOR THE LOCAL BUF          15050000
         NI    FILEOF(AE),255-1    SET FLAGS, PTRS, ETC.                15060000
         MVI   FILOPN(AE),READOPN                                       15070000
         XC    FILBEG(2,AE),FILBEG(AE)  RESET CHAR. START POS.       #  15080000
         CLI   DCBRECFM,X'80'                                        #  15090000
         BNL   FILGOP1             JUMP IF NOT V-FORMAT              #  15100000
         MVI   FILBEG+1(AE),4      ALLOW 4-BYTE RDW/SDW              #  15110000
FILGOP1  TM    DCBRECFM,X'06'                                        #  15120000
         BZ    FILGOP2             JUMP IF NO CONTROL CHARS          #  15130000
         CLI   CCFLAG,0            OR IF CONTROL CHARS ARE NOT       #  15140000
         BE    FILGOP2             TO BE INSERTED                    #  15150000
         OI    FILBEG+1(AE),1      ADD IN 1-BYTE CONTROL CHAR        #  15160000
FILGOP2  EQU   *                                                     #  15170000
         BAL   R5,FILGET                                                15180000
         B     RTN                 RETURN TO PASCAL PROGRAM             15190000
*                                                                       15200000
*                                                                       15210000
*                                                                       15220000
         DC    CL4'GET'                                                 15230000
GET      FILADR ,                                                       15240000
         TM    FILEOF(AE),1                                             15250000
         BO    RTN                                                      15260000
         BAL   R5,FILGFE                                                15270000
         B     RTN                                                      15280000
*                                                                       15290000
*                                                                       15300000
*                                                                       15310000
         DC    CL4'EOF '                                                15320000
EOF      FILADR ,                                                       15330000
         LA    RSLT,TRUE                                                15340000
         TM    FILEOF(AE),1                                             15350000
         BO    RTN                                                      15360000
         AIF   (&SYSTEM).SYS46                                          15370000
         CLI   FILOPN(AE),READOPN                                       15380000
         BNE   BADREAD             COMPLAIN IF 'EOF' ON OUTPUT FILE     15390000
.SYS46   ANOP                                                           15400000
         SR    RSLT,RSLT                                                15410000
         B     RTN                                                      15420000
*                                                                       15430000
*                                                                       15440000
*                                                                       15450000
         DC    CL4'RLN'                                                 15460000
RLN      FILADR ,                                                       15470000
         BAL   R5,FILGET                                                15480000
         B     RTN                                                      15490000
*                                                                       15500000
*                                                                       15510000
*                                                                       15520000
         DC    CL4'ELN '                                                15530000
ELN      FILADR ,                                                       15540000
         LA    RSLT,TRUE                                                15550000
         TM    FILEOF(AE),1                                             15560000
         BO    RTN                                                      15570000
         AIF   (&SYSTEM).SYS48                                          15580000
         CLI   FILOPN(AE),READOPN                                       15590000
         BNE   BADREAD             COMPLAIN IF 'ELN' ON OUTPUT FILE     15600000
.SYS48   ANOP                                                           15610000
         CLC   FILPTR(2,AE),FILEND(AE)  CHECK IF AT END OF LINE      #  15620000
         BE    RTN                                                      15630000
         SR    RSLT,RSLT                                                15640000
         B     RTN                                                      15650000
*                                                                       15660000
*                                                                       15670000
*        RDB, (READ BOOLEAN)   ADR(FILE),ADR(BOOLEAN)                #  15680000
*                                                                       15690000
         DC    CL4'RDB'                                                 15700000
RDB      FILADR ,                                                    #  15710000
         BAL   R5,FILGNB           ADVANCE TO A NON-BLANK            @  15720000
         LA    RSLT,TRUE                                             #  15730000
         OI    0(AD),X'40'         CONVERT TO UPPER CASE (IN CASE !)    15740000
         CLI   0(AD),C'T'          T = TRUE ?                        #  15750000
         BE    RDB6                                                  #  15760000
         CLI   0(AD),C'F'          F = FALSE ?                       #  15770000
         BNE   BADBOOL             NEITHER = AN ERROR                #  15780000
RDB4     SR    RSLT,RSLT                                             #  15790000
RDB6     STC   RSLT,0(R2)          STORE THE RESULT                  #  15800000
         BAL   R5,FILGFE           STEP TO FOLLOWING CHAR            #  15810000
         B     RTN                                                   #  15820000
*                                                                       15830000
*                                                                       15840000
         DC    CL4'RDC'                                                 15850000
*                                                                       15860000
*        RDC  ADR(FILE),ADR(CHAR)                                       15870000
*         AD : FILE ADDRESS, R2 : ADDRESS FOR THE 'CHAR'                15880000
RDC      FILADR ,                                                       15890000
         IC    R0,0(AD)                                                 15900000
         STC   R0,0(R2)                                                 15910000
         BAL   R5,FILGFE                                                15920000
         B     RTN                                                      15930000
*                                                                       15940000
*        RDI    AD: ADR(FILE),  R2: ADR(INT)                            15950000
*                                                                       15960000
         DC    CL4'RDI'                                                 15970000
RDI      FILADR ,                                                       15980000
         LR    R4,R2               CLEAR A REGISTER PAIR  (R2,R3)       15990000
         SR    R3,R3                                                    16000000
         MVI   SIGN,1              ASSUME POSITIVE                      16010000
         BAL   R5,FILGNB           ADVANCE TO A NON-BLANK            @  16020000
         CLI   0(AD),FILPLU                                             16030000
         BE    RDI23                                                 #  16040000
         CLI   0(AD),FILMIN                                             16050000
         BNE   RDI25                                                    16060000
         MVI   SIGN,0              CHANGE TO NEGATIVE                   16070000
RDI23    BAL   R5,FILGFE                                             #  16080000
RDI25    LA    R15,BADINT          PREPARE ERROR RT ADDRESS          #  16090000
RDI4     SR    R0,R0                                                 #  16100000
         IC    R0,0(AD)            GET DIGIT                         #  16110000
         SH    R0,=AL2(FILZER)                                       #  16120000
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #  16130000
         CH    R0,=AL2(9)                                            #  16140000
         BHR   R15                                                   #  16150000
         M     R2,=F'10'                                             #  16160000
         AR    R3,R0                                                    16170000
         BAL   R5,FILGFE                                                16180000
         BAL   R15,RDI4            LOOP BACK & SET EXIT ADDRESS      #  16190000
RDI5     TM    SIGN,1                                                   16200000
         BO    *+6                                                      16210000
         LCR   R3,R3                                                    16220000
         ST    R3,0(R4)                                                 16230000
         B     RTN                                                      16240000
*                                                                       16250000
*                                                                       16260000
*  RDS, (READ STRING), R2= STRING ADDRESS, R3=STRING LENGTH !           16270000
*                                                                       16280000
         DC    CL4'RDS'                                                 16290000
*                                                                       16300000
RDS      FILADR ,                                                       16310000
         LH    R1,FILPTR(AE)                                            16320000
         IC    R0,0(AD)            START WITH CURRENT CHARACTER      #  16330000
RDSNXTCH STC   R0,0(R2)            COPY CHARS ONE-BY-ONE             #  16340000
         LA    R2,CHR(R2)                                            #  16350000
         LA    R1,1(,R1)                                             #  16360000
         CH    R1,FILEND(AE)       END OF THIS LINE?                 #  16370000
         BL    RDSF1               IF NOT, JUMP                      #  16380000
         LA    R0,FILBLA           END OF LINE CHARACTER             #  16390000
         BCTR  R1,0                REVERSE INCREMENTING OF POINTER   @  16400000
         B     RDSF2               GO AND USE EOL CHARACTER          @  16410000
RDSF1    IC    R0,0(R1,AF)         LOAD NEXT INPUT CHAR              #  16420000
RDSF2    BCT   R3,RDSNXTCH         REPEAT                            #  16430000
         STC   R0,0(AD)                                                 16440000
         STH   R1,FILPTR(AE)                                            16450000
         B     RTN                                                      16460000
*                                                                       16470000
*                                                                       16480000
*  REW, (REWRITE = REWIND FOR OUTPUT)                                   16490000
*                                                                       16500000
         DC    CL4'REW'                                                 16510000
REW      DS    0H                                                       16520000
         LA    R0,FILCOUNT+INPUT   LAST+1 FILE ADDRESS                  16530000
         CR    AD,R0                                                    16540000
         BNL   BADWRITE            REWRITING A NON EXISTANT FILE ?      16550000
         FILADR ,                                                       16560000
         BAL   R5,FILCLS           GO AND CLOSE THE FILE             #  16570000
*                                                                       16580000
*        (PUT) OPEN A FILE                                              16590000
*                                                                       16600000
FILPOP   MVI   FILOPN(AE),0        PUT_OPEN THE FILE                    16610000
         LA    AG,FILDCB(AE)                                         #  16620000
         OPEN  ((AG),(OUTPUT))                                          16630000
         TM    DCBOFLGS,X'10'                                           16640000
         BNO   BADWRITE            REPORT ANY PROBLEM                   16650000
         MVI   FILOPN(AE),WRITEOPN SET FLAGS, BUF PTRS ETC.             16660000
         OI    FILEOF(AE),1                                             16670000
         SR    R0,R0                                                 #  16680000
         STH   R0,FILPTR(AE)       CLEAR BOTH LINE POSN PTR          #  16690000
         ST    R0,FILLIM(AE)       AND LINES LIMIT FOR FILE          #  16700000
         ST    R0,FILBUF(AE)       NULLIFY BUFFER POINTER            #  16710000
         LH    R1,DCBLRECL         GET LRECL FROM THE DCB            #  16720000
         TM    DCBRECFM,X'C0'                                        #  16730000
         BNO   *+12                JUMP IF NOT U-FORMAT              #  16740000
         LH    R1,DCBBLKSI                                           #  16750000
         STH   R1,DCBLRECL                                           #  16760000
         STH   R0,FILEND(AE)       NULL BUFFER LENGTH                #  16770000
         STH   R0,FILBEG(AE)       RESET CHAR. START POSITION        #  16780000
         CLI   DCBRECFM,X'80'                                        #  16790000
         BNL   FILPOP1             JUMP IF NOT V-FORMAT              #  16800000
         MVI   FILBEG+1(AE),4      ALLOW 4-BYTE RDW/SDW              #  16810000
FILPOP1  TM    DCBRECFM,X'06'      TEST IF CONTROL CHARS             #  16820000
         BZ    RTN                                                   #  16830000
         CLI   CCFLAG,0            RETURN IF CONTROL CHARS ARE NOT   #  16840000
         BE    RTN                 TO BE INSERTED                    #  16850000
         OI    FILBEG+1(AE),1      ADD 1-BYTE CONTROL CHAR.          #  16860000
         B     RTN                                                      16870000
*                                                                       16880000
*        PUT (PASCAL 'PUT' OPERATION)                                   16890000
*                                                                       16900000
         DC    CL4'PUT '                                                16910000
PUT      FILADR ,                                                       16920000
         TM    FILEOF(AE),1                                             16930000
         BZ    RTN                                                      16940000
         BAL   R5,FILPST                                                16950000
         B     RTN                                                      16960000
*                                                                       16970000
*        WLN (WRITE LINE), TERMINATE CURRENT OUTPUT LINE                16980000
*                                                                       16990000
         DC    CL4'WLN '                                                17000000
WLN      FILADR ,                                                       17010000
         LH    R1,FILPTR(AE)                                         #  17020000
         CH    R1,FILEND(AE)       IF BUFFER IS MARKED "OVER-FULL",  #  17030000
         BNH   *+12                   WE WRITE IT OUT                #  17040000
         BAL   R5,FILPUT                                             #  17050000
         LH    R1,FILPTR(AE)                                         #  17060000
         BCTR  R1,0                                                  #  17070000
         STH   R1,FILEND(AE)       FLAG BUFFER AS "OVER-FULL"        #  17080000
         B     RTN                                                   #  17090000
*                                                                       17100000
*                                                                       17110000
*        WRB (WRITE BOOLEAN):  ADR(FILE),BOOLEAN,FIELD_WIDTH         #  17120000
*                                                                       17130000
         DC    CL4'WRB'                                                 17140000
WRB      LTR   R2,R2                                                 #  17150000
         LA    R2,=C'TRUE'                                           #  17160000
         LA    R4,4                                                  #  17170000
         BNZ   WRS                 JUMP IF "TRUE"                    #  17180000
WRB1     LA    R2,=C'FALSE'                                          #  17190000
         LA    R4,5                                                  #  17200000
         B     WRS                                                   #  17210000
*                                                                       17220000
*                                                                       17230000
*        WRC   R1: ADR(FILE),  R3: FIELD_WIDTH,  R2: CHAR               17240000
*                                                                       17250000
         DC    CL4'WRC '                                                17260000
WRC      FILADR ,                                                       17270000
         BCTR  R3,0                                                     17280000
         LTR   R3,R3                                                    17290000
         BZ    WRC3                                                     17300000
         BM    RTN                                                      17310000
WRC2     MVI   0(AD),FILBLA                                             17320000
         BAL   R5,FILPST                                                17330000
         BCT   R3,WRC2                                                  17340000
WRC3     STC   R2,0(AD)                                                 17350000
         BAL   R5,FILPST                                                17360000
         B     RTN                                                      17370000
*                                                                       17380000
*     WRS   ADR(FILE): R1, STRLGTH: R4, FIELD_WIDTH:R3 ,R2: ADR(STING)  17390000
*                                                                       17400000
         DC    CL4'WRS '                                                17410000
WRS      FILADR ,                                                       17420000
         LTR   R3,R3                                                    17430000
         BNP   RTN                 ZERO FIELD WIDTH, RETURN             17440000
         LH    R1,FILPTR(AE)                                            17450000
         LA    R0,FILBLA           FILL CHARACTER                       17460000
WRSB1    CR    R3,R4               COMPARE FLD_LGTH TO STR_LGTH         17470000
         BNH   WRSF2               NO NEED FOR FILL CHARS               17480000
         CH    R1,FILEND(AE)                                         #  17490000
         BL    WRSF1                                                 #  17500000
         STH   R1,FILPTR(AE)       UPDATE LENGTH FIRST                  17510000
         BAL   R5,FILPUT           THEN EMPTY THE FULL BUFFER        #  17520000
         LH    R1,FILPTR(AE)                                         #  17530000
         LA    R0,FILBLA                                             #  17540000
WRSF1    STC   R0,0(R1,AF)         PLANT NEXT BLANK IN BUFFER        #  17550000
         LA    R1,1(R1)            AND ADVANCE TO NEXT POSITION      #  17560000
         BCT   R3,WRSB1                                              #  17570000
*    NOW WE HAVE R3 <= R4                                               17580000
WRSF2    DS    0H                                                       17590000
WRSB2    CH    R1,FILEND(AE)                                         #  17600000
         BL    WRSF3                                                 #  17610000
         STH   R1,FILPTR(AE)       UPDATE LENGTH FIELD                  17620000
         BAL   R5,FILPUT           THEN EMPTY THE FULL BUFFER        #  17630000
         LH    R1,FILPTR(AE)                                         #  17640000
WRSF3    IC    R0,0(R2)            PICK UP NEXT CHAR IN STRING       #  17650000
         STC   R0,0(R1,AF)         AND PLANT IT IN BUFFER            #  17660000
         LA    R2,CHR(R2)          ADVANCE IN THE STRING             #  17670000
         LA    R1,1(R1)            ADVANCE IN THE BUFFER             #  17680000
         BCT   R3,WRSB2                                              #  17690000
         STH   R1,FILPTR(AE)                                            17700000
         B     RTN                                                      17710000
*                                                                       17720000
*                                                                       17730000
*        WRI ADR(FILE),WIDTH,INT                                        17740000
*                                                                       17750000
         DC    CL4'WRI '                                                17760000
WRI      DS    0H                                                    #  17770000
*        AIF   (&SYSTEM).SYS7                                        #  17780000
*        LTR   R3,R3                                                 #  17790000
*        BNP   RTN                 ZERO FIELD WIDTH - RETURN         #  17800000
*.SYS7   ANOP                                                        #  17810000
         CVD   R2,PINT                                               #  17820000
         MVC   ZINT,=X'402020202020202020202120'                        17830000
         LA    R1,ZINT+11                                               17840000
         EDMK  ZINT,PINT+2                                              17850000
         LTR   R2,R2                                                    17860000
         BNM   *+10                                                     17870000
         BCTR  R1,0                                                     17880000
         MVI   0(R1),C'-'                                               17890000
         LR    R2,R1                                                 #  17900000
         LA    R4,ZINT+L'ZINT                                        #  17910000
         SR    R4,R1                                                 #  17920000
         CR    R4,R3                                                 #  17930000
         BNH   WRS                 PRINT INTEGER AS A STRING         #  17940000
         LR    R3,R4               - BUT INCREASE FIELD WIDTH IF     #  17950000
         B     WRS                 NECESSARY TO PRINT ENTIRE NUMBER  #  17960000
*                                                                       17970000
*                                                                       17980000
*        RDR, READ THE NEXT (REAL) NUMBER INTO (GRG2)                   17990000
*                                                                       18000000
         DC    CL4'RDR'                                                 18010000
RDR      DS    0H                                                       18020000
         AIF   (&SYSTEM).SYS9                                           18030000
         FILADR ,                                                       18040000
         SDR   0,0                                                      18050000
         LA    R3,1                                                     18060000
         BAL   R5,FILGNB           ADVANCE TO A NON-BLANK            @  18070000
         CLI   0(AD),FILPLU                                             18080000
         BE    RDR3                                                     18090000
         CLI   0(AD),FILMIN                                             18100000
         BNE   RDR4                                                     18110000
         LCR   R3,R3                                                    18120000
RDR3     BAL   R5,FILGFE                                                18130000
RDR4     LA    R15,BADREAL         SET ERROR EXIT ADDRESS            #  18140000
RDR45    SR    R1,R1                                                 #  18150000
         IC    R1,0(AD)            GET CHARACTER                     #  18160000
         SH    R1,=AL2(FILZER)                                       #  18170000
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #  18180000
         CH    R1,=AL2(9)                                            #  18190000
         BHR   R15                                                   #  18200000
         MD    0,=D'10.0'                                            #  18210000
         SLA   R1,3                                                     18220000
         AD    0,DECTBL(R1)                                             18230000
         BAL   R5,FILGFE                                                18240000
         BAL   R15,RDR45           LOOP BACK & SET EXIT ADDRESS      #  18250000
RDR5     SR    R4,R4                                                    18260000
         CLI   0(AD),FILDOT                                             18270000
         BNE   RDR7                                                     18280000
         BAL   R5,FILGFE                                                18290000
RDR6     CLI   0(AD),FILZER                                             18300000
         BL    RDR7                                                     18310000
         CLI   0(AD),FILNIN                                             18320000
         BH    RDR7                                                     18330000
         MD    0,=D'10.0'                                               18340000
         SR    R1,R1                                                    18350000
         IC    R1,0(AD)                                                 18360000
         SH    R1,=AL2(FILZER)                                       #  18370000
         SLA   R1,3                                                     18380000
         AD    0,DECTBL(R1)                                             18390000
         BAL   R5,FILGFE                                                18400000
         BCTR  R4,0                                                     18410000
         B     RDR6                                                     18420000
RDR7     LTR   R3,R3                                                    18430000
         BNM   *+6                                                      18440000
         LCDR  0,0                                                      18450000
         CLI   0(AD),C'e'                                               18460000
         BE    RDR75                                                    18470000
         CLI   0(AD),C'E'  FILEXP                                       18480000
         BNE   RDR13                                                    18490000
RDR75    LA    R3,1                                                     18500000
RDR8     BAL   R5,FILGFE                                                18510000
         CLI   0(AD),FILBLA                                             18520000
         BE    RDR8                                                     18530000
         ST    R4,EXPONENT                                              18540000
         SR    R4,R4                                                    18550000
RDR9     CLI   0(AD),FILPLU                                             18560000
         BE    RDR10                                                    18570000
         CLI   0(AD),FILMIN                                             18580000
         BNE   RDR11                                                    18590000
         LCR   R3,R3                                                    18600000
RDR10    BAL   R5,FILGFE                                                18610000
RDR11    LA    R15,BADREAL         SET ERROR EXIT ADDRESS            #  18620000
RDR115   SR    R1,R1                                                 #  18630000
         IC    R1,0(AD)            GET CHARACTER                     #  18640000
         SH    R1,=AL2(FILZER)                                       #  18650000
         BMR   R15                 QUIT LOOP IF NON-DIGIT            #  18660000
         CH    R1,=AL2(9)                                            #  18670000
         BHR   R15                                                   #  18680000
         MH    R4,=H'10'                                                18690000
         AR    R4,R1                                                    18700000
         BAL   R5,FILGFE                                                18710000
         BAL   R15,RDR115          LOOP BACK & SET EXIT ADDRESS      #  18720000
RDR12    LTR   R3,R3                                                    18730000
         BNM   *+6                                                      18740000
         LCR   R4,R4                                                    18750000
         A     R4,EXPONENT                                              18760000
RDR13    LTR   R4,R4                                                    18770000
         BZ    RDR16                                                    18780000
         BP    RDR14                                                    18790000
         LPR   R4,R4                                                    18800000
         B     RDR15                                                    18810000
RDR14    MD    0,=D'10.0'                                               18820000
         BCT   R4,RDR14                                                 18830000
         B     RDR16                                                    18840000
RDR15    DD    0,=D'10.0'                                               18850000
         BCT   R4,RDR15                                                 18860000
RDR16    STD   0,0(R2)             PUT THE RESULT IN PASCAL VARIABLE    18870000
.SYS9    ANOP                                                           18880000
         B     RTN                                                      18890000
*                                                                       18900000
*        WRR, REAL NUMBER IN FPRG2, FIELDWITH IN GRG3                   18910000
*                                                                       18920000
         DC    CL4'WRR'                                                 18930000
WRR      FILADR ,                                                       18940000
         SR    R2,R2         R2 <-- POWER OF 10                         18950000
         LTDR  FPR2,FPR2                                                18960000
         BNZ   WRR20                                                    18970000
*                                                                       18980000
*        PRINT 'ZERO' IN THE PROPER FORMAT                              18990000
*                                                                       19000000
         LTR   R4,R4         'F' FORMAT ?                               19010000
         BP    WRR14                                                    19020000
*        E-FORMAT ZERO                                                  19030000
         MVI   0(AD),FILBLA                                             19040000
         BAL   R5,FILPST                                                19050000
         BAL   R5,FILPST                                                19060000
         SH    R3,=H'4'                                                 19070000
         LR    R4,R3                                                    19080000
         B     WRR16                                                    19090000
*        F-FORMAT                                                       19100000
WRR14    SR    R3,R4                                                    19110000
         SH    R3,=H'2'                                                 19120000
         BNP   WRR16                                                    19130000
         MVI   0(AD),FILBLA                                             19140000
         BAL   R5,FILPST                                                19150000
         BCT   R3,*-4        PRINT LEADING BLANKS                       19160000
*                                                                       19170000
WRR16    MVI   0(AD),FILZER                                             19180000
         BAL   R5,FILPST                                                19190000
         MVI   0(AD),FILDOT                                             19200000
         BAL   R5,FILPST                                                19210000
         MVI   0(AD),FILZER                                             19220000
         BAL   R5,FILPST                                                19230000
*        PRINT TRAILING BLANKS                                          19240000
         SH    R4,=H'1'                                                 19250000
         BNP   RTN                                                      19260000
         MVI   0(AD),FILBLA                                             19270000
         BAL   R5,FILPST                                                19280000
         BCT   R4,*-4                                                   19290000
         B     RTN                                                      19300000
*                                                                       19310000
*        PRINT A NON_ZERO REAL NUMBER                                   19320000
*                                                                       19330000
WRR20    MVI   SIGN,X'00'                                               19340000
         MVI   EFORM,X'00'                                              19350000
         BP    WRR22                                                    19360000
         MVI   SIGN,X'01'    NEGATIVE VALUE, REMEMBER THE SIGN          19370000
         BCTR  R3,0          AND ADJUST FIELD WIDTH                     19380000
         LPDR  FPR2,FPR2                                                19390000
WRR22    LD    FPR0,=D'1.0E-12'                                         19400000
         MDR   FPR0,FPR2                                                19410000
         ADR   FPR2,FPR0                                                19420000
         LDR   FPR0,FPR2     SAVE THE ORIGINAL VALUE                    19430000
*                                                                       19440000
WRR24    CD    FPR2,=D'1.0'                                             19450000
         BNL   WRR26                                                    19460000
         MD    FPR2,=D'10.0'                                            19470000
         BCT   R2,WRR24                                                 19480000
WRR26    CD    FPR2,=D'10.0'                                            19490000
         BL    WRR30                                                    19500000
         DD    FPR2,=D'10.0'                                            19510000
         LA    R2,1(R2)                                                 19520000
         B     WRR26                                                    19530000
*                                                                       19540000
*        NOW WE HAVE  "1.0 <= FPR2 < 10"                                19550000
*        AND "FPR0 = FPR2 * (R2 ** 10)" .                               19560000
*                                                                       19570000
WRR30    LTR   R4,R4         SEE IF F_FORMAT REQUESTED                  19580000
         BP    WRR40                                                    19590000
*        PRINT THE VALUE IN E_FORM                                      19600000
         MVI   EFORM,X'01'   SET E_FORMAT FLAG                          19610000
         ST    R2,EXPONENT   SAVE EXPONENT VALUE                        19620000
         MVI   0(AD),FILBLA                                             19630000
         BAL   R5,FILPST                                                19640000
         LR    R4,R3         R4 <-- FIELD WIDTH (AT LEAST 9)            19650000
         SH    R4,=H'7'                                                 19660000
         TM    SIGN,X'01'                                               19670000
         BNZ   WRR32                                                    19680000
         MVI   0(AD),FILBLA  PRINT UP TO TWO LEADING BLANKS             19690000
         BAL   R5,FILPST                                                19700000
         BCTR  R4,0                                                     19710000
WRR32    LTR   R4,R4                                                    19720000
         BP    *+8                                                      19730000
         LA    R4,1                                                     19740000
         SR    R2,R2         ONLY ONE DIGIT BEFORE DECIMAL POINT        19750000
         B     WRR50                                                    19760000
*                                                                       19770000
*        F_FORMAT OUTPUT                                                19780000
*                                                                       19790000
WRR40    LTR   R2,R2                                                    19800000
         BNM   WRR44         SEE IF NEGATIVE EXPONENT                   19810000
         LDR   FPR2,FPR0     IF SO, USE THE ORIGINAL VALUE              19820000
         SR    R2,R2         ONLY ONE DIGIT BEFORE DECIMAL POINT        19830000
*                                                                       19840000
WRR44    SR    R3,R4         COMPUTE THE # OF LEADING BLANKS            19850000
         SR    R3,R2                                                    19860000
         SH    R3,=H'2'      R3 IS THE # OF LEADING BLANKS              19870000
         BNP   WRR50                                                    19880000
WRR46    MVI   0(AD),FILBLA                                             19890000
         BAL   R5,FILPST                                                19900000
         BCT   R3,*-4                                                   19910000
*                                                                       19920000
*        R2 # OF DIGITS BEFORE DECIMAL POINT                            19930000
*        R4 # OF DIGITS FOLLOWING DECIMAL POINT                         19940000
*                                                                       19950000
WRR50    TM    SIGN,X'01'                                               19960000
         BZ    WRR52                                                    19970000
         MVI   0(AD),FILMIN                                             19980000
         BAL   R5,FILPST                                                19990000
*                                                                       20000000
WRR52    LA    R2,1(R2)                                                 20010000
         BAL   R3,WRRDGTS                                               20020000
         BCT   R2,*-4                                                   20030000
         MVI   0(AD),FILDOT                                             20040000
         BAL   R5,FILPST                                                20050000
         BAL   R3,WRRDGTS                                               20060000
         BCT   R4,*-4                                                   20070000
         TM    EFORM,X'01'                                              20080000
         BZ    RTN                                                      20090000
*                                                                       20100000
*        PRINT THE EXPONENT FOR E_FORMAT OUTPUT                         20110000
*                                                                       20120000
         L     R4,EXPONENT                                              20130000
         MVI   0(AD),FILEXP                                             20140000
         BAL   R5,FILPST                                                20150000
         MVI   0(AD),FILPLU                                             20160000
         LTR   R4,R4                                                    20170000
         BNM   *+8                                                      20180000
         MVI   0(AD),FILMIN                                             20190000
         BAL   R5,FILPST                                                20200000
         LPR   R3,R4                                                    20210000
         SR    R2,R2                                                    20220000
         D     R2,=F'10'                                                20230000
         LA    R3,FILZER(R3)                                            20240000
         STC   R3,0(AD)                                                 20250000
         BAL   R5,FILPST                                                20260000
         LA    R2,FILZER(R2)                                            20270000
         STC   R2,0(AD)                                                 20280000
         BAL   R5,FILPST                                                20290000
         B     RTN                                                      20300000
*                                                                       20310000
*        THIS ROUTINE PRINTS THE NEXT DIGIT OF THE VALUE                20320000
*        IN FPR2, IT USES R3 FOR ITS RETURN ADDRESS                     20330000
*        IT IS ASSUMED THAT "0 <= FPR2 < 10" AND FPR2                   20340000
*        IS UPDATED FOR THE NEXT DIGIT                                  20350000
*                                                                       20360000
WRRDGTS  SR    R1,R1                                                 #  20370000
         LA    R1,1(R1)                                              #  20380000
         SD    FPR2,=D'1.0'                                          #  20390000
         BNM   WRRDGTS+2                                             #  20400000
         AD    FPR2,=D'1.0'                                          #  20410000
         LA    R1,FILZER-1(R1)                                       #  20420000
         STC   R1,0(AD)                                              #  20430000
         BAL   R5,FILPST           WRITE NEXT DIGIT                  #  20440000
         MD    FPR2,=D'10.0'                                         #  20450000
         BR    R3                 RETURN TO CALLER                      20460000
*                                                                       20470000
*                                                                       20480000
*        PAG   SKIP TO NEW PAGE                                         20490000
*                                                                       20500000
         DC    CL4'PAG'                                                 20510000
PAG      SR    R2,R2                                                 #  20520000
         BCT   R2,SKP1             SET R2 = -1, THEN USE SKP ROUTINE #  20530000
*                                                                    #  20540000
*                                                                    #  20550000
*        SKP - SKIP R2 INPUT OR OUTPUT LINES                         #  20560000
*                                                                    #  20570000
         DC    CL4'SKP'                                              #  20580000
SKP      LTR   R2,R2                                                 #  20590000
         BM    RTN                 FORCE NUMBER OF LINES TO BE       #  20600000
SKP1     FILADR ,                                                    #  20610000
         CLI   FILOPN(AE),READOPN                                    #  20620000
         BE    SKP7                JUMP IF AN INPUT FILE             #  20630000
         LA    R0,MAXSKIP                                            #  20640000
         CR    R2,R0                                                 #  20650000
         BL    *+6                 LIMIT NUMBER OF LINES TO "MAXSKIP"#  20660000
         LR    R2,R0                                                 #  20670000
         TM    DCBRECFM,X'06'      JUMP IF FILE DOES NOT HAVE        #  20680000
         BZ    SKP6                CARRIAGE CONTROL CHARS            #  20690000
         LA    R3,3                MAX NO. OF SKIPS PER RECORD       #  20700000
         TM    DCBRECFM,X'04'                                        #  20710000
         BNZ   SKP2                JUMP IF ANS CONTROL CHARS         #  20720000
         LTR   AF,AF               FORCE AN INITIAL PUT OPERATION IF #  20730000
         BNZ   SKP3                  NO I/O BUFFER YET ALLOCATED     #  20740000
SKP2     BAL   R5,FILPUT           CLEAR LINE BUFFER                 #  20750000
SKP3     CR    R2,R3                                                 #  20760000
         LR    R4,R2                                                 #  20770000
         BNH   *+6                                                   #  20780000
         LR    R4,R3               NOW, R4 = MIN( R2, 3 )            #  20790000
*        LH    R1,FILBEG(AE)                                         #  20800000
*        CLI   CCFLAG,0            DONT BACK UP POINTER              #  20810000
*        BE    *+6                 UNLESS NOCC IN EFFECT             #  20820000
*        BCTR  R1,0                                                  #  20830000
*        INSTEAD OF THE ABOVE LINES                                  #  20840000
         SR    R1,R1                                                 #  20850000
         CLI   DCBRECFM,X'80'                                        #  20860000
         BNL   *+8                                                   #  20870000
         LA    R1,4                                                  #  20880000
*                                                                    #  20890000
         TM    DCBRECFM,X'04'                                        #  20900000
         BZ    SKP5                JUMP IF MACHINE CHARS             #  20910000
         IC    R0,SKPASCII(R4)                                       #  20920000
         STC   R0,0(R1,AF)         SET ASCII CONTROL CHAR            #  20930000
         SR    R2,R4                                                 #  20940000
         BP    SKP2                REPEAT IF MORE LINES TO SKIP      #  20950000
         LA    R1,1(R1)                                              #  20960000
         STH   R1,FILPTR(AE)       POINT AT FIRST DATA BYTE          #  20970000
         B     RTN                                                   #  20980000
SKP5     IC    R0,SKPMACH(R4)                                        #  20990000
         STC   R0,0(R1,AF)         SET MACHINE CONTROL CHAR          #  21000000
         BAL   R5,FILPUT           AND SEND TO OUTPUT DEVICE         #  21010000
         SR    R2,R4                                                 #  21020000
         BP    SKP3                REPEAT IF MORE LINES TO SKIP      #  21030000
         B     RTN                                                   #  21040000
SKP6     BAL   R5,FILPUT           NO CONTROL CHARS                  #  21050000
         BCTR  R2,0                BUT GIVE AN APPROPRIATE NUMBER    #  21060000
         LTR   R2,R2               OF EMPTY OUTPUT RECORDS           #  21070000
         BP    SKP6                                                  #  21080000
         B     RTN                                                   #  21090000
SKP7     LTR   R2,R2               REJECT PAGE() ON AN INPUT FILE    #  21100000
         BM    BADWRITE                                              #  21110000
         BNZ   SKP8                JUMP IF > 0 SKIPS                 #  21120000
         LH    R1,FILBEG(AE)                                         #  21130000
         STH   R1,FILPTR(AE)       RESET CHAR PTR. TO REREAD LINE    #  21140000
         IC    R0,0(R1,AF)                                           #  21150000
         STC   R0,0(AD)            RESET CURRENT FILE ELEMENT        #  21160000
         B     RTN                                                   #  21170000
SKP8     BAL   R5,FILGET                                             #  21180000
         BCT   R2,SKP8             STEP THROUGH THE LINES            #  21190000
         B     RTN                                                   #  21200000
*                                                                       21210000
*                                                                       21220000
*        CLOCK FUNCTION                                                 21230000
*                                                                       21240000
         DC    CL4'CLK'                                                 21250000
CLK      TTIMER ,                                                       21260000
         S     R0,CLOCK            SUBTRACT START-UP TIME               21270000
         LCR   R1,R0                                                    21280000
         M     R0,=FS32'0.02604166'                                     21290000
         B     RTN                RETURNS THE RESULT IN R0              21300000
*                                                                       21310000
*        OBSOLETE MATH RT. HANDLING CODE.  ALL CALLS TO FORTRAN      #  21320000
*        ARE NOW DIRECT.  AN OLD PASCAL PROGRAM THAT ATTEMPTS TO     #  21330000
*        CALL THEM VIA THIS PROGRAM CAUSES AN ERROR MESSAGE.         #  21340000
*                                                                       21350000
         DC    CL4'MATH'                                                21360000
SIN      DS    0H                                                    #  21370000
COS      DS    0H                                                    #  21380000
EXP      DS    0H                                                    #  21390000
LOG      DS    0H                                                    #  21400000
SQT      DS    0H                                                    #  21410000
ATN      DS    0H                                                    #  21420000
         B     UNDFERR             GO AND PRINT AN ERROR MESSAGE     #  21430000
*                                                                       21440000
*                                                                       21450000
*        MESSAGE PROCEDURE   R2=STRING ADDR,  R3=LENGTH              #  21460000
*                                                                    #  21470000
         DC    CL4'MSG'                                              #  21480000
MSG      LTR   R3,R3                                                 #  21490000
         BNP   RTN                                                   #  21500000
         LA    R0,MAXMSGL          SET MAXIMUM MESSAGE LENGTH        #  21510000
         CR    R3,R0                                                 #  21520000
         BNH   *+6                                                   #  21530000
         LR    R3,R0                                                 #  21540000
         EX    R3,MSGMVC                                             #  21550000
         LA    R3,4(R3)            CONSTRUCT VARIABLE-LENGTH RECORD  #  21560000
         STH   R3,SYNADMSG                                           #  21570000
         LA    R3,SYNADMSG(R3)                                       #  21580000
         MVC   0(4,R3),=X'00000020' SET THE ROUTING CODE             #  21590000
         MVC   SYNADMSG+2(2),=X'8000'                                #  21600000
         LA    R1,SYNADMSG                                           #  21610000
         SVC   35                  ISSUE WTO REQUEST                 #  21620000
         B     RTN                                                   #  21630000
MSGMVC   MVC   SYNADMSG+4(*-*),0(R2)                                 #  21640000
*                                                                       21650000
*        CTR, TO ALLOCATE AND CLEAR 'R2' RUN TIME 'COUNTERS'            21660000
*                                                                       21670000
         DC    CL4'CTR'                                                 21680000
CTR      DS    0H                                                       21690000
         L     R3,HEAPLIM                                               21700000
         USING DYN2STOR,R3                                              21710000
         ST    R2,DYNRUNC          SET THE # OF COUNTERS                21720000
         DROP  R3                                                       21730000
         SLA   R2,2                CONVERT COUNT TO BYTES               21740000
         LR    R4,R3               POINT TO HEAP END                    21750000
         SR    R4,R2               LOWER IT TO ITS NEW POSITION         21760000
         ST    R4,HEAPLIM          AND SAVE THE NEW HEAP LIMIT PTR      21770000
*                                                                       21780000
         SR    R5,R5               ASSUME NO OS PARMATER AREA           21790000
         L     R6,OSPRMPTR                                              21800000
         LTR   R6,R6               SEE IF THAT IS THE CASE              21810000
         BM    CTR10                                                    21820000
         LR    R5,R3               IF NOT, FIND THE LENGTH OF           21830000
         SR    R5,R6               THE OS PARM AREA                     21840000
         SR    R3,R5               AND ADJUST 'TO' AND 'FROM' PTRS      21850000
         SR    R4,R5                                                    21860000
         ST    R4,OSPRMPTR                                              21870000
CTR10    LA    R5,DYNCOUNT-DYN2STOR(R5)   ADD THE SIZE OF FIXED AREA    21880000
*        AN EXTRA BYTE IS MOVED BUT IT IS OK.                           21890000
         EX    R5,CTRMVE           AND COPY FROM THE OLD AREA.          21900000
         ST    R4,NEWPTR           UPDATE HEAP PTR                      21910000
         AR    R4,R5               POINT BACK TO THE HEAP END           21920000
         SRA   R2,2                CONVERT BACK BYTES TO WORDS          21930000
         SR    R0,R0                                                    21940000
         ST    R0,0(R4)            AND CLEAR THE COUNTER AREA           21950000
         LA    R4,4(R4)            ADJUST THE POINTER                   21960000
         BCT   R2,*-8              REPEAT AS NEEDED                     21970000
         B     RTN                                                      21980000
*                                                                       21990000
CTRMVE   MVC   0(0,R4),0(R3)                                            22000000
*                                                                       22010000
*                                                                    #  22020000
*        LINELIMIT PROCEDURE   AD=FILE,  R2=LIMIT                    #  22030000
*                                                                    #  22040000
         DC    CL4'LIM'                                              #  22050000
LIM      FILADR ,                                                    #  22060000
         ST    R2,FILLIM(AE)       SET THE NEW LIMIT                 #  22070000
         B     RTN                                                   #  22080000
*                                                                       22090000
*                                                                       22100000
*        DEFINE THE FILE NAME                                           22110000
*                                                                       22120000
         DC    CL4'FDF'                                                 22130000
FDF      DS    0H                                                       22140000
         LR    AE,AD                                                    22150000
         SR    AE,GBR              CONVERT FILE ADR TO FILE ID          22160000
         C     AE,=A(INPUT+FILCOUNT-STACK)                              22170000
         BNL   BADFDF                                                   22180000
         SLA   AE,2                                                     22190000
         L     AD,FILBLK-PASBUFAD*4(AE)                                 22200000
         LTR   AD,AD                                                    22210000
         BNZ   RTN                 FILE BLOCK ALREADY ALLOCATED         22220000
*                                                                       22230000
         LA    R3,FILBLK-PASBUFAD*4(AE)                              #  22240000
         GETMAIN EC,LV=L'#FILREC,A=(R3)                              #  22250000
         LTR   R15,R15             TEST IF STORAGE AVAILABLE         #  22260000
         BNZ   BADFDF                                                #  22270000
         L     AE,0(,R3)                                             #  22280000
*        MOVE FILE RECORD TEMPLATE TO THE GETMAINED AREA                22290000
         L     R3,=A(#FILREC)                                           22300000
         MVC   0(L'#FILREC,AE),0(R3)                                 #  22310000
         MVC   DCBDDNAM,0(R2)      MOVE THE FILE NAME TO ITS DCB FIELD  22320000
         B     RTN                                                      22330000
*                                                                    #  22340000
*        GENERAL ROUTINE TO CLOSE A FILE                             #  22350000
*                                                                    #  22360000
FILCLS   TM    FILOPN(AE),1                                          #  22370000
         BNOR  R5                  RETURN IF FILE NOT OPEN           #  22380000
         CLI   FILOPN(AE),READOPN                                    #  22390000
         BE    FILCLS4             JUMP IF AN INPUT FILE             #  22400000
*        ST    R5,FILCLSSV                                           #  22410000
*        BAL   R5,FILCLS1          COMPLETE THE OUTPUT BUFFER        #  22420000
*        L     R5,FILCLSSV                                           #  22430000
*                                                                    #  22440000
*        PREPARE THE OUTPUT BUFFER FOR TRANSMITTING TO O.S.          #  22450000
*                                                                    #  22460000
FILCLS1  DS    0H                                                    #  22470000
         LH    R1,FILPTR(AE)       IF BUFFER IS IN "OVER-FULL" STATE @  22480000
         CH    R1,FILEND(AE)       WE MUST WRITE A RECORD NOW - IN   @  22490000
         BNH   FILCLS15            ORDER TO GET THE EXTRA BLANK LINE @  22500000
         ST    R5,FILCLSSV         WHEN THE FILE IS CLOSED.          @  22510000
         BAL   R5,FILPUT                                             @  22520000
         L     R5,FILCLSSV                                           @  22530000
FILCLS15 LH    R1,FILPTR(AE)                                         @  22540000
         CLI   DCBRECFM,X'80'                                        #  22550000
         BNL   FILCLS4             RETURN IF F OR U-FORMAT           #  22560000
         LA    R0,6                MIN LENGTH FOR VBA RECORDS        #  22570000
         TM    DCBRECFM,X'06'                                        #  22580000
         BNZ   *+6                 JUMP IF CONTROL CHARS             #  22590000
         BCTR  R0,0                ADJUST MIN LENGTH                 #  22600000
         CR    R1,R0                                                 #  22610000
         BNL   FILCLS2             JUMP IF RECORD SIZE OK            #  22620000
         LTR   AF,AF               RETURN IF THE I/O BUFFER IS NOT   #  22630000
         BZ    FILCLS4             ALLOCATED  (FILE NEWLY OPENED)    #  22640000
         LA    R0,FILBLA                                             #  22650000
         STC   R0,0(R1,AF)         PROVIDE 1 CHAR AT LEAST           #  22660000
         LA    R1,1(R1)                                              #  22670000
FILCLS2  STC   R1,1(AF)            SET RDW FOR V-VORMAT, ONE BYTE       22680000
         SRA   R1,8                AT A TIME TO MAKE 360S HAPPY         22690000
         STC   R1,0(AF)                                                 22700000
*                                                                    #  22710000
FILCLS4  LA    AG,FILDCB(AE)                                         #  22720000
         CLOSE ((AG))                                                #  22730000
         TM    DCBBUFCB+3,1        TEST IF BUFFER POOL THERE         #  22740000
         BOR   R5                  RETURN IF NOT                     #  22750000
         FREEPOOL (AG)             RELEASE THE POOL                  #  22760000
         BR    R5                                                    #  22770000
*                                                                       22780000
*                                                                       22790000
*        EXIT : TO EXIT USER PROGRAM WITH A RETURN CODE                 22800000
*                                                                       22810000
         DC    CL4'XIT'                                                 22820000
XIT      C     R2,=A(1000)         IF ERROR GO TO CLOSE/EXIT ROUTINE    22830000
         BNL   CLS                                                      22840000
         L     R4,HEAPLIM                                               22850000
         USING DYN2STOR,R4                                              22860000
         L     R5,DYNRUNC                                               22870000
         LTR   R5,R5               SEE IF RUN TIME COUNTERS ARE PRESENT 22880000
         BNP   CLS                 IF NOT, QUIT.                        22890000
         LR    R6,R2               SAVE RETURN CODE                     22900000
         LA    AD,QRR              PICK THE COUNTER FILE NAME           22910000
         LA    R1,PREW                                                  22920000
         LA    R15,$PASCSP                                              22930000
         BALR  R14,R15             CALL THE $PASCSP ROUTINES            22940000
*                                                                       22950000
*        THIS CAN BE DONE ONLY IF WE KNOW THAT WE DO NOT NEED           22960000
*        TO GO BACK TO THE PROGRAM WHICH CALLED THE EXIT                22970000
*        ROUTINE.                                                       22980000
*                                                                       22990000
         LA    R1,PWRI             SET THE FUNCTION CODE                23000000
         LA    R3,10               SET THE FIELD_WIDTH                  23010000
NXTCNT   L     R2,DYNCOUNT         PICK THE NEXT COUNT VALUE            23020000
         BALR  R14,R15             OUTPUT IT                            23030000
         LA    R4,4(R4)                                                 23040000
         BCT   R5,NXTCNT           REPEAT UNTIL DONE                    23050000
         DROP  R4                                                       23060000
*                                                                       23070000
         LA    R1,PWLN                                                  23080000
         BALR  R14,R15             OUTPUT THE LAST LINE                 23090000
         MVI   PROFFLAG,X'FF'      SET FLAG TO INDICATE PASPROF CALL @  23100000
         LR    R2,R6               RESTORE RETURN CODE                  23110000
*                                                                       23120000
         B     CLS                 GO TO COMPLETE EXIT EPILOGUE.        23130000
*                                                                       23140000
*       CLOSE ALL THE FILES                                             23150000
*                                                                       23160000
         DC    CL4'CLS '                                                23170000
CLS      L     AD,=A(FILBLK)                                         #  23180000
         LA    R3,FILCOUNT         INPUT,OUTPUT,PRD,...........         23190000
CLSB1    L     AE,0(AD)                                                 23200000
         LTR   AE,AE                IS THIS FILE DEFINED ?              23210000
         BZ    CLSF1                IF NOT, SKIP.                       23220000
         L     AF,FILBUF(AE)                                         #  23230000
         BAL   R5,FILCLS           GO AND DO A FILE CLOSE            #  23240000
         C     AD,=A(FILBLK+6*4)   TEST IF BUILT-IN FILE             #  23250000
         BL    CLSF1               IF SO, JUMP                       #  23260000
         FREEMAIN R,LV=L'#FILREC,A=(AE)  RELEASE FILE BLOCK STORAGE  #  23270000
CLSF1    LA    AD,4(AD)                                                 23280000
         BCT   R3,CLSB1                                                 23290000
*                                                                       23300000
*        TIME TO EXIT                                                   23310000
*                                                                       23320000
         L     R1,=A(OLDPICA)                                           23330000
         TM    3(R1),1             TEST IF SPIE WAS ISSUED           #  23340000
         BO    SKIPSPIE            JUMP IF NOT                       #  23350000
         L     1,0(R1)             RESET OLD PICA ADDRESS            #  23360000
         SPIE  MF=(E,(1))          TO CANCEL ANY PASCAL SPIE         #  23370000
SKIPSPIE EQU   *                                                     #  23380000
*                                                                       23390000
*        CHECK FOR ABEND                                                23400000
*                                                                       23410000
         C         R2,=A(1000)     IF RETURN CODE < 1000                23420000
         BL        XIT2              THEN DON'T ABEND                   23430000
         L         R1,HEAPLIM                                           23440000
         USING     DYN2STOR,R1                                          23450000
         CLI       DYNABEND,X'FF'                                       23460000
         DROP      R1                                                   23470000
         BNE       XIT2                                                 23480000
         LA    R1,X'FFF'                                             @  23490000
         NR    R1,R2                                                 @  23500000
         O     R1,=A(X'80000000')                                       23510000
         SVC   13                                                       23520000
XIT2     DS    0H                                                       23530000
         C     R2,=A(TIMERR)       SEE IF THIS IS A TIME OUT EXIT       23540000
         BE    XIT3                                                     23550000
         C     R2,=A(TIMERR+SNPERR)                                     23560000
         BNE   XIT4                                                     23570000
*                                                                       23580000
*        THIS ABEND IS BECAUSE THERE IS NO CLEAN AND EASY WAY           23590000
*        TO TERMINATE THE PROGRAM IN CASE OF A TIMER INTERRUPT !        23600000
*                                                                       23610000
XIT3     ABEND (R2)                                                     23620000
*                                                                       23630000
XIT4     DS    0H                                                       23640000
         LR    R13,R12             POINT TO STACK BASE               #  23650000
         S     R13,=A(STACK-DYNSTORE)                                #  23660000
         L     R15,=V(IBCOM#)      IS FORTRAN PRESENT ?                 23670000
         LTR   R15,R15                                                  23680000
         BZ    XIT6                                                     23690000
*                                                                       23700000
*        NOTE: THE IBCOME 'EXIT' ROUTINE USES THE SAVE AREA PASSED      23710000
*        TO THE IBCOM INIT ROUTINE. THE FOLLOWING PATCH SHOULD          23720000
*        ENSURE RETURNING TO 'XIT6' AFTER CLOSING FORTRAN I/O AND       23730000
*        CANCELING IBCOM 'SPIE' AND 'STAE'.                             23740000
*                                                                       23750000
         LA    R14,XIT6            IF SO, SET THE RETURN ADDRESS        23760000
         STM   R14,R12,12(R13)     SET 'RESTORE' AREA FOR THE CALL      23770000
         BAL   R14,IBCOMXIT(R15)   TO IBCOM# XIT ROUTINE.               23780000
         DC    AL2(0)              RETURN CODE FOR ABOVE CALL           23790000
XIT6     DS    0H                                                       23800000
         L     R13,4(R13)          POINT TO THE SYSTEM SAVE AREA     #  23810000
         FREEMAIN V,A=ALOSTORE     RELEASE STACK STORAGE             #  23820000
         TM    PROFFLAG,X'FF'                                        @  23830000
         BNZ   CALLPROF            JUMP IF PASPROF TO BE INVOKED     @  23840000
         LR    R15,R2              SET THE RETURN CODE               #  23850000
         L     R14,12(R13)         PICK THE RETURN ADDRESS              23860000
         LM    R0,R12,20(R13)      RESTORE OTHER REGS                   23870000
         BR    14                                                       23880000
CALLPROF L     R1,=A(OSPARMS)      GIVE PASPROF SAME PARAMETERS      @  23890000
         L     R1,0(,R1)           AS WE WERE GIVEN                  @  23900000
         L     R14,12(,R13)        SET JUST R14 (XCTL SETS REST)     @  23910000
         XCTL  (2,12),EP=PASPROF   INVOKE THE PROFILER MODULE        @  23920000
*                                                                       23930000
*                                                                       23940000
*        UNDEFINED CSP ENTRIES                                          23950000
*                                                                       23960000
TRP      DS    0H                                                       23970000
SIO      DS    0H                                                       23980000
EIO      DS    0H                                                       23990000
         B     UNDFERR             REPORT AN ERROR                   @  24000000
*                                                                       24010000
*                                                                       24020000
*                                                                       24030000
*         RETURN TO PASCAL PROGRAM                                      24040000
*                                                                       24050000
RTN      LM    R1,R15,SPUSERSA      'RSLT' REG SHOULD NOT BE RESTORED ! 24060000
         AIF   (&SYSTEM).SYS92                                          24070000
         DROP                                                           24080000
         USING $PASCSP,R15                                              24090000
         MVI   SPUSERSA,X'FF'      CLEAR 'SP' FLAG                      24100000
.SYS92   ANOP                                                           24110000
         BR    14                                                       24120000
*                                                                       24130000
*        I/O ERROR CONDITIONS                                           24140000
*                                                                       24150000
         DROP                                                           24160000
         USING $PASCSP,R10,R11                                       #  24170000
BADFDF   LA    R0,FDFMSG                                             #  24180000
         B     ERRMSGRT                                              #  24190000
UNDFERR  LA    R0,UNDFMSG                                            @  24200000
         B     ERRMSGRT                                              #  24210000
LIMITERR LA    R0,LIMMSG                                             #  24220000
         B     ERRMSGRT                                              #  24230000
BADREAD  LA    R0,READMSG                                            #  24240000
         B     ERRMSGRT                                              #  24250000
EOFREAD  LA    R0,EOFMSG                                             #  24260000
         B     ERRMSGRT                                              #  24270000
BADBOOL  LA    R0,BOOLMSG                                            #  24280000
         B     ERRMSGRT                                              #  24290000
BADINT   LA    R0,INTMSG                                             #  24300000
         B     ERRMSGRT                                              #  24310000
BADREAL  LA    R0,REALMSG                                            #  24320000
         B     ERRMSGRT                                              #  24330000
*                                                                       24340000
         USING STACK,GBR                                                24350000
BADWRITE LA    R3,OUTPUT           IF BAD FILE IS "OUTPUT" WE HAVE   #  24360000
         CR    AD,R3          TO BY-PASS GENERATION OF ERROR         #  24370000
         BNE   BADWRIT1          MESSAGES  (OTHERWISE INFINITE LOOP) #  24380000
         WTO   ' **** PASCAL MONITOR MSG: UNABLE TO USE "OUTPUT" FILE',X24390000
               ROUTCDE=11                                               24400000
         LA    R2,OUTERR                                             #  24410000
         B     XIT                                                   #  24420000
BADWRIT1 LA    R0,WRITEMSG                                           #  24430000
         B     ERRMSGRT                                              #  24440000
*                                                                    #  24450000
SYNADRT  EQU   *              GENERATES MESSAGE FOR FILE ERRORS      #  24460000
         LA    R3,OUTPUT                                             #  24470000
         CR    AD,R3          OBVIOUSLY, AN ERROR WITH "OUTPUT" FILE #  24480000
         BER   R14            CANT BE PRINTED, SO CONTINUE ABENDING  #  24490000
         SYNADAF ACSMETH=QSAM GENERATE THE ERROR DESCRIPTION         #  24500000
         MVC   SYNADMSG+1(78),50(R1) AND MOVE IT INTO LOCAL BUFFER   #  24510000
         SYNADRLS ,           NOW RELEASE THE SYSTEM'S BUFFER        #  24520000
         LA    R0,SYNMSG                                             #  24530000
*        B     ERRMSGRT                                              #  24540000
*                                                                       24550000
ERRMSGRT L     R15,=A($CHKMSG0)    RESTORE USER'S REGISTERS          #  24560000
         LM    R1,R14,SPUSERSA                                       #  24570000
         LR    R3,R0                                                 #  24580000
         LH    R8,0(R3)            SET ERROR CODE                    #  24590000
         LH    R4,2(R3)            SET MESSAGE LENGTH                #  24600000
         LA    R3,4(R3)            SET MESSAGE POINTER               #  24610000
         BR    R15                 AND EXIT WITH THE MESSAGE         #  24620000
         DROP  ,                                                        24630000
*                                                                       24640000
*          VARIOUS TABLE AND DCB DEFINITIONS                            24650000
*                                                                       24660000
         DS    0D                                                       24670000
DECTBL   DC    D'0,1,2,3,4,5,6,7,8,9'                                   24680000
PINT     DS    D                   PACKED INTEGER BUFFER                24690000
         DC    20AL1(FILBLA)                                            24700000
ZINT     DS    CL12                ZONED INTEGER BUFFER                 24710000
         DS    0F                                                       24720000
*                                                                    #  24730000
*              DCB EXIT LIST PARAMETERS                              #  24740000
*                                                                    #  24750000
XLINPUT  DC    X'85',AL3(XLSTRTIN)                                   #  24760000
XLINOUT  EQU   XLINPUT                                               #  24770000
XLOUTPUT DC    X'85',AL3(XLSTRTOT)                                   #  24780000
*                                                                    #  24790000
*        DEFAULT AND TARGET VALUES FOR FILES OTHER THAN "OUTPUT"     #  24800000
*                                                                    #  24810000
DEFAULTS DC    H'80'               TARGET DATA BYTES PER RECORD      #  24820000
         DC    H'1600'             TARGET BYTES PER BLOCK            #  24830000
         DC    AL1(3)              DEFAULT BUFNO VALUE               #  24840000
         DC    X'50'               DEFAULT RECFM = VB                #  24850000
*                                                                    #  24860000
*        DEFAULT AND TARGET VALUES FOR "OUTPUT" FILE                 #  24870000
*                                                                    #  24880000
OUTDFLTS DC    H'132'              TARGET DATA BYTES PER BLOCK       #  24890000
         DC    H'1600'             TARGET BYTES PER RECORD           #  24900000
         DC    AL1(5)              DEFAULT BUFNO VALUE               #  24910000
         DC    X'54'               DEFAULT RECFM = VBA               #  24920000
*                                                                    #  24930000
MAXSKIP  DC    F'60'               MAXIMUM NUMBER OF LINES TO SKIP   #  24940000
SKPASCII EQU   *+1                 TABLE OF ASCII CONTROL CHARS      #  24950000
         DC    C'1+ 0-'                                              #  24960000
SKPMACH  EQU   *+1                 TABLE OF MACHINE CONTROL CHARS    #  24970000
         DC    X'8901091119'                                         #  24980000
RRFLAG   DC    X'00'               REREAD FLAG                       #  24990000
PROFFLAG DC    X'00'               CALL PROFILE MODULE FLAG          @  25000000
SIGN     DS    CL1                                                      25010000
EFORM    DS    CL1                                                      25020000
CCFLAG   DC    X'00'               SET BY NOCC O.S. PARM STRING      #  25030000
FILPSTSV DS    A                                                     #  25040000
*FILPUTSV DS    A                                                    #  25050000
FILCLSSV DS    A                                                     @  25060000
EXPONENT DS    F                                                     #  25070000
*                                                                       25080000
         DS    0H                                                       25090000
READMSG  DC    AL2(INPERR,25),C' INVALID INPUT OPERATION '              25100000
         DS    0H                                                       25110000
WRITEMSG DC    AL2(OUTERR,26),C' INVALID OUTPUT OPERATION '             25120000
         DS    0H                                                       25130000
FDFMSG   DC    AL2(FDFERR,25),C' INVALID FILE DEFINITION '              25140000
         DS    0H                                                       25150000
UNDFMSG  DC    AL2(NDFERR,25),C' CALL TO UNDEF. STANDARD PROC.'      @  25160000
         DS    0H                                                       25170000
LIMMSG   DC    AL2(LIMERR,26),C' LINELIMIT VALUE EXCEEDED '          #  25180000
         DS    0H                                                       25190000
EOFMSG   DC    AL2(EOFERR,24),C' ILLEGAL READ AFTER EOF '            #  25200000
         DS    0H                                                       25210000
BOOLMSG  DC    AL2(BOLERR,21),C' BAD BOOLEAN ON INPUT '              #  25220000
         DS    0H                                                       25230000
INTMSG   DC    AL2(INTERR,21),C' BAD INTEGER ON INPUT '              #  25240000
         DS    0H                                                       25250000
REALMSG  DC    AL2(RELERR,18),C' BAD REAL ON INPUT '                 #  25260000
         DS    0H                                                       25270000
SYNMSG   DC    AL2(SYNERR,79)                                        #  25280000
         DS    0H                                                       25290000
SYNADMSG DC    CL128' '             BUFFER FOR I/O ERROR MESSAGE     #  25300000
*                                                                       25310000
*        NOTE: THIS BUFFER IS ALSO USED BY "MESSAGE". ITS LENGTH MUST#  25320000
*        NOT BE LESS THAN MAXMSGL+8.                                 #  25330000
         LTORG ,                                                        25340000
         DS    0D                                                       25350000
*                                                                       25360000
*        FILE  NAME TABLE                                               25370000
*                                                                       25380000
FILBLK   DC    A(FILINP,FILOUT,FILPRD,FILPRR,FILQRD,FILQRR)             25390000
         DC    20F'0'              USER DEFINED FILES !                 25400000
         PRINT NOGEN               TURN OFF DCB EXPANSIONS           #  25410000
*                                                                       25420000
*        FILE CONTROL BLOC AND DCB FOR THE ABOVE FILES                  25430000
*                                                                       25440000
         FILDEF INPUT,INPUT,LINELGTH                                    25450000
         FILDEF OUTPUT,OUTPUT,LINELGTH                                  25460000
         FILDEF PRD,INOUT,LINELGTH                                      25470000
*                                                                       25480000
#FILREC  EQU   FILPRD,*-FILPRD     FILE RECORD TEMPLATE                 25490000
*                                                                       25500000
         FILDEF PRR,INOUT,LINELGTH                                      25510000
         FILDEF QRD,INOUT,LINELGTH                                      25520000
         FILDEF QRR,INOUT,LINELGTH                                      25530000
**************************************************************          25540000
*                                                                       25550000
*        END OF $PASCSP MODULE                                          25560000
*                                                                       25570000
**************************************************************          25580000
         SPACE 3                                                        25590000
*        GLOBAL DEFINITIONS                                             25600000
*                                                                       25610000
*                                                                       25620000
*                                                                       25630000
*                                                                       25640000
*        REGISTER ASSIGNMENTS                                           25650000
*                                                                       25660000
R0       EQU   0                                                        25670000
R1       EQU   1                                                        25680000
R2       EQU   2                                                        25690000
R3       EQU   3                                                        25700000
R4       EQU   4                                                        25710000
R5       EQU   5                                                        25720000
R6       EQU   6                                                        25730000
R7       EQU   7                                                        25740000
R8       EQU   8                                                        25750000
R9       EQU   9                                                        25760000
R10      EQU   10                                                       25770000
R11      EQU   11                                                       25780000
R12      EQU   12                                                       25790000
R13      EQU   13                                                       25800000
R14      EQU   14                                                       25810000
R15      EQU   15                                                       25820000
GBR      EQU   12                                                       25830000
FPR0     EQU   0                   FLOATING REG 0                       25840000
FPR2     EQU   2                                                        25850000
FPR4     EQU   4                                                        25860000
FPR6     EQU   6                                                        25870000
K        EQU   1024                                                     25880000
IOBUFSZE EQU   36*K                SIZE OF AREA RETURNED TO OS FOR I/O  25890000
MINSTORE EQU   8*K                 MIN ACCEPTABLE DYNAMIC STORAGE SIZE  25900000
MAXSTORE EQU   4000*K              MAX REQUESTABLE DYNAMIC STORAGE      25910000
PASBUFAD EQU   INPUT-STACK         ADR OF THE FIRST FILE CHAR BUFFER    25920000
LCAFTMST EQU   80                  LOCAL VARIABLE AREA (PASCAL PROCS)   25930000
MAXMSGL  EQU   120                 MAX LENGTH MESSAGE                #  25940000
RET      EQU   14                  RETURN ADDRESS/LOCATION COUNTER      25950000
LINK     EQU   15                  BRANCH REGISTER                      25960000
PBASE2   EQU   11                  PROGRAM BASE REGISTER #2             25970000
PBASE1   EQU   10                  "     "      #1                      25980000
*                                                                       25990000
INXERR   EQU   1001                INDEX ERROR RETURN CODE              26000000
SUBERR   EQU   1002                SUBRANGE ERROR RETURN CODE           26010000
PARERR   EQU   1003                PARAMETER ERROR RETURN CODE          26020000
SETERR   EQU   1004                SET ELEMENT ERROR RETURN CODE        26030000
PTRERR   EQU   1005                POINTER ERROR RETURN CODE            26040000
STKERR   EQU   1006                STACK/HEAP ERROR RETURN CODE         26050000
INPERR   EQU   1007                INPUT OPERATION ERROR RETURN CODE    26060000
OUTERR   EQU   1008                OUTPUT OPERATION ERROR RETURN CODE   26070000
SYNERR   EQU   1009                SYNCHRONOUS I/O ERROR RETURN CODE #  26080000
TIMERR   EQU   1010                TIME OUT ERROR RETURN CODE           26090000
FDFERR   EQU   1011                FILE DEFINITION ERROR RETURN CODE    26100000
SPCERR   EQU   1012                'NO SPACE' ERROR RETURN CODE         26110000
NDFERR   EQU   1013                UNDEFINED CSP CALL ERROR          @  26120000
LIMERR   EQU   1014                'LINES LIMIT EXCEEDED' ERROR      #  26130000
EOFERR   EQU   1020                ILLEGAL READ PAST EOF             #  26140000
BOLERR   EQU   1021                BAD BOOLEAN ON INPUT              #  26150000
INTERR   EQU   1022                BAD INTEGER ON INPUT              #  26160000
RELERR   EQU   1023                BAD REAL ON INPUT                 #  26170000
SNPERR   EQU   100                 SNAPSHOT ERROR RETURN CODE           26180000
FILCOUNT EQU   F18PAS-INPUT+1      # OF FILES (AND FILE DCB'S)          26190000
*                                                                       26200000
*                                                                       26210000
*        MISCELANEOUS CONSTANTS                                         26220000
*                                                                       26230000
*                                                                       26240000
*        FILE RELATED SYMBOL DEFINITIONS                                26250000
*                                                                       26260000
         EXTRN $MAINBLK                                                 26270000
         WXTRN SNAPSHOT,IBCOM#                                          26280000
IBCOMINI EQU   64                  IBCOM INITIALIZATION ENTRY POINT     26290000
IBCOMXIT EQU   68                  IBCOM TERMINATION ENTRY POINT        26300000
*                                                                       26310000
*                                                                       26320000
*        CSP ROUTINE NUMBERS                                            26330000
*                                                                       26340000
PGET     EQU   0*4                                                      26350000
PPUT     EQU   1*4                                                      26360000
PRES     EQU   2*4                                                      26370000
PRLN     EQU   3*4                                                      26380000
PREW     EQU   4*4                                                      26390000
PWLN     EQU   5*4                                                      26400000
PWRS     EQU   6*4                                                      26410000
PWRI     EQU   8*4                                                      26420000
PXIT     EQU   21*4                                                     26430000
PCLS     EQU   29*4                                                     26440000
PSKP     EQU   32*4                                                  #  26450000
*                                                                       26460000
*        FILE BLOCK FIELDS                                              26470000
*                                                                       26480000
FILBUF   EQU   0                                                     #  26490000
FILEND   EQU   4                                                     #  26500000
FILPTR   EQU   6                                                     #  26510000
FILBEG   EQU   8                                                     #  26520000
FILEOF   EQU   10                                                    #  26530000
FILOPN   EQU   11                                                    #  26540000
FILLIM   EQU   12                                                    #  26550000
FILDCB   EQU   16                                                    #  26560000
*                                                                       26570000
*        INTERNAL CHARACTER CODE FOR USEFUL CHARACTERS                  26580000
*                                                                       26590000
FILEOL   EQU   0  ?                                                     26600000
FILEXP   EQU   C'E' 5                                                   26610000
FILZER   EQU   C'0' 27                                                  26620000
FILNIN   EQU   C'9' 36                                                  26630000
FILPLU   EQU   C'+' 37                                                  26640000
FILMIN   EQU   C'-' 38                                                  26650000
FILTIM   EQU   C'*' 39                                                  26660000
FILBLA   EQU   C' ' 45                                                  26670000
FILDOT   EQU   C'.' 47                                                  26680000
*                                                                       26690000
*        READ/WRITE FLAG                                                26700000
*                                                                       26710000
READOPN  EQU   1                                                        26720000
WRITEOPN EQU   3                                                        26730000
*                                                                       26740000
*        AD :  @ PASCAL_FILE_BUFFER    (WITHIN GLOBAL DATA AREA)        26750000
*        AE :  @ CSP_FILE_CTL.BLK      (INDICATING WHICH FILE )         26760000
*        AF :  @ CSP_RECORD_BUFFER     (POINTING TO THE LINE BUF)       26770000
*        AG :  @ CSP_DCB               (POINTER TO FILE DCB)            26780000
*                                                                       26790000
FALSE    EQU   0                                                        26800000
TRUE     EQU   1                                                        26810000
RSLT     EQU   0                                                        26820000
AD       EQU   9                                                        26830000
AE       EQU   8                                                        26840000
AF       EQU   7                                                        26850000
AG       EQU   6                                                        26860000
*                                                                       26870000
*        MISCELLANEOUS CONSTANTS                                        26880000
*                                                                       26890000
CHR      EQU   1                   LENGTH (IN BYTES) OF A CHAR. VALUE   26900000
BOL      EQU   1                   "     "   "     OF A LOGICAL VALUE   26910000
ADR      EQU   4                   "     "   "     OF AN ADDRESS VALUE  26920000
INT      EQU   4                   "     "   "     OF AN INTEGER VALUE  26930000
REL      EQU   8                   "     "   "     OF A REAL VALUE      26940000
SET      EQU   8                   "     "   "     OF A SET VALUE       26950000
CDS      EQU   8                   COMMON DATUM SIZE (LARGEST OF ABOVE) 26960000
*                                                                       26970000
         END   $PASENT                                                  26980000
