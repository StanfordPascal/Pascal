   4    44 1  0 (*$C+,D+,L+,X+     *) 
   5    44 1  0 (*******************) 
   6    44 1  0  
   7    44 1  0  
   8    44 1  0 program PASCALCOMPILER ( INPUT , OUTPUT , PRR ) ; 
   9    44 1  0  
  10    44 1  0 (**********************************************) 
  11    44 1  0 (*                                            *) 
  12    44 1  0 (*                                            *) 
  13    44 1  0 (*         PORTABLE PASCAL COMPILER           *) 
  14    44 1  0 (*         ************************           *) 
  15    44 1  0 (*                                            *) 
  16    44 1  0 (*                PASCAL P4                   *) 
  17    44 1  0 (*                                            *) 
  18    44 1  0 (*                                            *) 
  19    44 1  0 (*     AUTHORS:                               *) 
  20    44 1  0 (*              URS AMMANN                    *) 
  21    44 1  0 (*              KESAV NORI                    *) 
  22    44 1  0 (*              CHRISTIAN JACOBI              *) 
  23    44 1  0 (*                                            *) 
  24    44 1  0 (*     ADDRESS:                               *) 
  25    44 1  0 (*                                            *) 
  26    44 1  0 (*          INSTITUT FUER INFORMATIK          *) 
  27    44 1  0 (*          EIDG. TECHNISCHE HOCHSCHULE       *) 
  28    44 1  0 (*          CH-8096 ZUERICH                   *) 
  29    44 1  0 (*                                            *) 
  30    44 1  0 (*                                            *) 
  31    44 1  0 (*     LAST CHANGES COMPLETED IN MAY 1976     *) 
  32    44 1  0 (*                                            *) 
  33    44 1  0 (**********************************************) 
  34    44 1  0 (*                                            *) 
  35    44 1  0 (*     ADAPTED AND MODIFIED BY                *) 
  36    44 1  0 (*                                            *) 
  37    44 1  0 (*     - JUERGEN REICHMANN   1985             *) 
  38    44 1  0 (*     - BERND OPPOLZER      2019             *) 
  39    44 1  0 (*                                            *) 
  40    44 1  0 (**********************************************) 
  41    44 1  0  
  42    44 1  0  
  43    44 1  0  
  44    44 1  0 const MAXERRS = 30 ; 
  45    44 1  0       DISPLIMIT = 20 ; 
  46    44 1  0       MAXLEVEL = 10 ; 
  47    44 1  0       WORDAL = 2 ; 
  48    44 1  0       INTSIZE = 4 ; 
  49    44 1  0       INTAL = WORDAL ; 
  50    44 1  0       REALSIZE = 4 ; 
  51    44 1  0       REALAL = WORDAL ; 
  52    44 1  0       CHARSIZE = 1 ; 
  53    44 1  0       CHARAL = 1 ; 
  54    44 1  0       CHARMAX = 1 ; 
  55    44 1  0       BOOLSIZE = 1 ; 
  56    44 1  0       BOOLAL = 1 ; 
  57    44 1  0       PTRSIZE = INTSIZE ; 
  58    44 1  0       ADRAL = INTAL ; 
  59    44 1  0       SETSIZE = 32 ; 
  60    44 1  0       SETAL = WORDAL ; 
  61    44 1  0       STACKAL = WORDAL ; 
  62    44 1  0       STACKELSIZE = 1 ; 
  63    44 1  0       ALPHALEN = 16 ; 
  64    44 1  0       SUCCALPHALEN = 17 ; 
  65    44 1  0       STRGLGTH = 80 ; 
  66    44 1  0       RSTRGLGTH = 12 ; 
  67    44 1  0       MAXLINELEN = 128 ; 
  68    44 1  0       SETHIGH = 255 ; 
  69    44 1  0       SETLOW = 0 ; 
  70    44 1  0       ORDMAXCHAR = 255 ; 
  71    44 1  0       ORDMINCHAR = 0 ; 
  72    44 1  0       TAB = 9 ; 
  73    44 1  0       MAXINT = 2147483647 ; 
  74    44 1  0       LCBEFOREMARKSTACK = 8 ; 
  75    44 1  0       LCAFTERMARKSTACK = 0 ; 
  76    44 1  0       FILEAL = ADRAL ; 
  77    44 1  0       FCBSIZE = 16 ; 
  78    44 1  0       MAXSTACK = 1 ; 
  79    44 1  0       PARMAL = WORDAL ; 
  80    44 1  0       PARMSIZE = PTRSIZE ; 
  81    44 1  0       RECAL = STACKAL ; 
  82    44 1  0       FILEBUFFER = 2 ; 
  83    44 1  0       MAXADDR = 16777215 ; 
  84    44 1  0  
  85    44 1  0  
  86    44 1  0 type SYMBOL = ( IDENT , INTCONST , REALCONST , STRINGCONST , NOTSY , 
  87    44 1  0               MULOP , ADDOP , RELOP , LPARENT , RPARENT , LBRACK , 
  88    44 1  0               RBRACK , COMMA , SEMICOLON , PERIOD , ARROW , COLON , 
  89    44 1  0               BECOMES , LABELSY , CONSTSY , TYPESY , VARSY , FUNCSY , 
  90    44 1  0               PROGSY , PROCSY , SETSY , PACKEDSY , ARRAYSY , RECORDSY , 
  91    44 1  0               FILESY , FORWARDSY , BEGINSY , IFSY , CASESY , REPEATSY , 
  92    44 1  0               WHILESY , FORSY , WITHSY , GOTOSY , ENDSY , ELSESY , 
  93    44 1  0               UNTILSY , OFSY , DOSY , TOSY , DOWNTOSY , THENSY , 
  94    44 1  0               IMPORTSY , EXPORTSY , STRINGSY , OTHERWSY , OTHERSY ) ; 
  95    44 1  0      OPERATOR = ( MUL , RDIV , ANDOP , IDIV , IMOD , PLUS , MINUS , 
  96    44 1  0                 OROP , LTOP , LEOP , GEOP , GTOP , NEOP , EQOP , INOP , 
  97    44 1  0                 NOOP ) ; 
  98    44 1  0      SETOFSYS = set of SYMBOL ; 
  99    44 1  0      CHTP = ( LETTER , NUMBER , SPECIAL , ILLEGAL ) ; 
 100    44 1  0      CSTCLASS = ( REEL , PSET , STRG ) ; 
 101    44 1  0      CSP = -> CONSTANT ; 
 102    44 1  0      CONSTANT = record 
 103    44 1  0                   case CCLASS : CSTCLASS of 
 104    44 1  0                     REEL : 
 105    44 1  0                       ( RVAL : packed array [ 1 .. RSTRGLGTH ] of CHAR 
 106    44 1  0                         ) ; 
 107    44 1  0                     PSET : 
 108    44 1  0                       ( PVAL : set of SETLOW .. SETHIGH ) ; 
 109    44 1  0                     STRG : 
 110    44 1  0                       ( SLGTH : 0 .. STRGLGTH ; 
 111    44 1  0                         SVAL : packed array [ 1 .. STRGLGTH ] of CHAR ) 
 112    44 1  0                 end ; 
 113    44 1  0      VALU = record 
 114    44 1  0               case INTVAL : BOOLEAN of 
 115    44 1  0                 TRUE : 
 116    44 1  0                   ( IVAL : INTEGER ) ; 
 117    44 1  0                 FALSE : 
 118    44 1  0                   ( VALP : CSP ) 
 119    44 1  0             end ; 
 120    44 1  0      LEVRANGE = 0 .. MAXLEVEL ; 
 121    44 1  0      ADDRRANGE = - MAXADDR .. MAXADDR ; 
 122    44 1  0      STRUCTFORM = ( SCALAR , SUBRANGE , POINTER , POWER , ARRAYS , 
 123    44 1  0                   RECORDS , FILES , TAGFLD , VARIANT ) ; 
 124    44 1  0      DECLKIND = ( STANDARD , DECLARED ) ; 
 125    44 1  0      STP = -> STRUCTURE ; 
 126    44 1  0      CTP = -> IDENTIFIER ; 
 127    44 1  0      STRUCTURE = packed record 
 128    44 1  0                           MARKED : BOOLEAN ; 
 129    44 1  0                           SIZE : ADDRRANGE ; 
 130    44 1  0                           case FORM : STRUCTFORM of 
 131    44 1  0                             SCALAR : 
 132    44 1  0                               ( case SCALKIND : DECLKIND of 
 133    44 1  0                                   DECLARED : 
 134    44 1  0                                     ( FCONST : CTP ) ) ; 
 135    44 1  0                             SUBRANGE : 
 136    44 1  0                               ( RANGETYPE : STP ; 
 137    44 1  0                                 MIN , MAX : VALU ) ; 
 138    44 1  0                             POINTER : 
 139    44 1  0                               ( ELTYPE : STP ) ; 
 140    44 1  0                             POWER : 
 141    44 1  0                               ( ELSET : STP ) ; 
 142    44 1  0                             ARRAYS : 
 143    44 1  0                               ( AELTYPE , INXTYPE : STP ; 
 144    44 1  0                                 VARY : BOOLEAN ) ; 
 145    44 1  0                             RECORDS : 
 146    44 1  0                               ( FSTFLD : CTP ; 
 147    44 1  0                                 RECVAR : STP ) ; 
 148    44 1  0                             FILES : 
 149    44 1  0                               ( FILTYPE : STP ) ; 
 150    44 1  0                             TAGFLD : 
 151    44 1  0                               ( TAGFIELDP : STP ; 
 152    44 1  0                                 FSTVAR : STP ) ; 
 153    44 1  0                             VARIANT : 
 154    44 1  0                               ( NXTVAR , SUBVAR : STP ; 
 155    44 1  0                                 VARVAL : VALU ) 
 156    44 1  0                         end ; 
 157    44 1  0      IDCLASS = ( TYPES , KONST , VARS , FIELD , PROC , FUNC ) ; 
 158    44 1  0      SETOFIDS = set of IDCLASS ; 
 159    44 1  0      IDKIND = ( ACTUAL , FORMAL ) ; 
 160    44 1  0      PF_ATTRIB = ( INTERN , EXPRT , IMPRT ) ; 
 161    44 1  0      ALPHA = packed array [ 1 .. ALPHALEN ] of CHAR ; 
 162    44 1  0      IDENTIFIER = packed record 
 163    44 1  0                            NAME : ALPHA ; 
 164    44 1  0                            LLINK , RLINK : CTP ; 
 165    44 1  0                            IDTYPE : STP ; 
 166    44 1  0                            NEXT : CTP ; 
 167    44 1  0                            case KLASS : IDCLASS of 
 168    44 1  0                              KONST : 
 169    44 1  0                                ( VALUES : VALU ) ; 
 170    44 1  0                              VARS : 
 171    44 1  0                                ( VKIND : IDKIND ; 
 172    44 1  0                                  VLEV : LEVRANGE ; 
 173    44 1  0                                  VADDR : ADDRRANGE ; 
 174    44 1  0                                  VXNAME : CSP ; 
 175    44 1  0                                  VIMPORT : BOOLEAN ) ; 
 176    44 1  0                              FIELD : 
 177    44 1  0                                ( FLDADDR : ADDRRANGE ) ; 
 178    44 1  0                              PROC , FUNC : 
 179    44 1  0                                ( case PFDECKIND : DECLKIND of 
 180    44 1  0                                    STANDARD : 
 181    44 1  0                                      ( KEY : 1 .. 15 ) ; 
 182    44 1  0                                    DECLARED : 
 183    44 1  0                                      ( PFLEV : LEVRANGE ; 
 184    44 1  0                                        PFNAME , NUMB_OF_PARM , 
 185    44 1  0                                        RESULT_LABEL : INTEGER ; 
 186    44 1  0                                        case PFKIND : IDKIND of 
 187    44 1  0                                          ACTUAL : 
 188    44 1  0                                            ( FORWDECL : BOOLEAN ; 
 189    44 1  0                                              PFXNAME : CSP ; 
 190    44 1  0                                              PF_ATTR : PF_ATTRIB ) ) ) 
 191    44 1  0                          end ; 
 192    44 1  0      DISPRANGE = 0 .. DISPLIMIT ; 
 193    44 1  0      WHERE = ( BLCK , CREC , VREC , REC ) ; 
 194    44 1  0      ATTRKIND = ( CST , VARBL , EXPR ) ; 
 195    44 1  0      VACCESS = ( DRCT , INDRCT , INXD ) ; 
 196    44 1  0      ATTR = record 
 197    44 1  0               TYPTR : STP ; 
 198    44 1  0               LABEL_ACCESS : BOOLEAN ; 
 199    44 1  0               case KIND : ATTRKIND of 
 200    44 1  0                 CST : 
 201    44 1  0                   ( CVAL : VALU ) ; 
 202    44 1  0                 VARBL : 
 203    44 1  0                   ( ACP : CTP ; 
 204    44 1  0                     case ACCESS : VACCESS of 
 205    44 1  0                       DRCT : 
 206    44 1  0                         ( VLEVEL : LEVRANGE ; 
 207    44 1  0                           DPLMT : ADDRRANGE ) ; 
 208    44 1  0                       INDRCT : 
 209    44 1  0                         ( IDPLMT : ADDRRANGE ) ) 
 210    44 1  0             end ; 
 211    44 1  0      TESTP = -> TESTPOINTER ; 
 212    44 1  0      TESTPOINTER = packed record 
 213    44 1  0                             ELT1 , ELT2 : STP ; 
 214    44 1  0                             LASTTESTP : TESTP ; 
 215    44 1  0                             COMPAT : BOOLEAN ; 
 216    44 1  0                           end ; 
 217    44 1  0      LBP = -> LABL ; 
 218    44 1  0      LABL = record 
 219    44 1  0               NEXTLAB : LBP ; 
 220    44 1  0               DEFINED : BOOLEAN ; 
 221    44 1  0               LABVAL , LABNAME : INTEGER 
 222    44 1  0             end ; 
 223    44 1  0      EXTFILEP = -> FILEREC ; 
 224    44 1  0      FILEREC = record 
 225    44 1  0                  FILENAME : ALPHA ; 
 226    44 1  0                  NEXTFILE : EXTFILEP 
 227    44 1  0                end ; 
 228    44 1  0  
 229    44 1  0  
 230    48 1  0 var SY : SYMBOL ; 
 231    52 1  0     OP : OPERATOR ; 
 232    58 1  0     VAL : VALU ; 
 233    62 1  0     LGTH : INTEGER ; 
 234    78 1  0     ID : ALPHA ; 
 235    82 1  0     KK : 1 .. ALPHALEN ; 
 236    83 1  0     CH : CHAR ; 
 237    84 1  0     EOL : BOOLEAN ; 
 238    88 1  0     CHCNT : INTEGER ; 
 239    96 1  0     LC , IC : ADDRRANGE ; 
 240   104 1  0     OLDLINECOUNT , LINECOUNT : INTEGER ; 
 241   109 1  0     EXPECTSTRING , DP , PRTERR , LIST , PRCODE : BOOLEAN ; 
 242   110 1  0     DEBUG : BOOLEAN ; 
 243   110 1  0     PARMPTR , INTPTR , REALPTR , CHARPTR , BOOLPTR , NILPTR , TEXTPTR : 
 244   138 1  0                                                    STP ; 
 245   138 1  0     UTYPPTR , UCSTPTR , UVARPTR , UFLDPTR , UPRCPTR , UFCTPTR , FWPTR : 
 246   166 1  0                                                    CTP ; 
 247   170 1  0     FEXTFILEP : EXTFILEP ; 
 248   174 1  0     FILECP : CTP ; 
 249   178 1  0     GLOBTESTP : TESTP ; 
 250   186 1  0     MIN_LEVEL , LEVEL : LEVRANGE ; 
 251   194 1  0     STNEST , LASTSTNEST : INTEGER ; 
 252   202 1  0     DISX , TOP : DISPRANGE ; 
 253   219 1  0     PRR : TEXT ; 
 254   219 1  0     DISPLAY : array [ DISPRANGE ] of packed record 
 255   219 1  0                                               FNAME : CTP ; 
 256   219 1  0                                               FLABEL : LBP ; 
 257   219 1  0                                               case OCCUR : WHERE of 
 258   219 1  0                                                 CREC : 
 259   219 1  0                                                   ( CLEV : LEVRANGE ; 
 260   219 1  0                                                    CDSPL : ADDRRANGE ) 
 261   219 1  0                                                    ; 
 262   219 1  0                                                 VREC : 
 263   219 1  0                                                   ( VDSPL : ADDRRANGE ) 
 264   640 1  0                                             end ; 
 265   644 1  0     ERRINX : 0 .. 10 ; 
 266   648 1  0     TOTALERRS : INTEGER ; 
 267   648 1  0     ERRLIST : array [ 1 .. 10 ] of packed record 
 268   648 1  0                                             POS : INTEGER ; 
 269   648 1  0                                             NMR : 1 .. 400 
 270   728 1  0                                           end ; 
 271   754 1  0     GATTR : ATTR ; 
 272   754 1  0     CONSTBEGSYS , SIMPTYPEBEGSYS , TYPEBEGSYS , BLOCKBEGSYS , SELECTSYS 
 273  1010 1  0     , FACBEGSYS , STATBEGSYS , TYPEDELS : SETOFSYS ; 
 274  2034 1  0     CHARTP : array [ CHAR ] of CHTP ; 
 275  2658 1  0     RW : array [ 1 .. 39 ] of ALPHA ; 
 276  2726 1  0     FRW : array [ 1 .. SUCCALPHALEN ] of 1 .. 40 ; 
 277  2882 1  0     RSY : array [ 1 .. 39 ] of SYMBOL ; 
 278  3906 1  0     SSY : array [ CHAR ] of SYMBOL ; 
 279  4062 1  0     ROP : array [ 1 .. 39 ] of OPERATOR ; 
 280  5086 1  0     SOP : array [ CHAR ] of OPERATOR ; 
 281  5678 1  0     NA : array [ 1 .. 37 ] of ALPHA ; 
 282  5950 1  0     MN : array [ 0 .. 67 ] of packed array [ 1 .. 4 ] of CHAR ; 
 283  6050 1  0     SNA : array [ 1 .. 25 ] of packed array [ 1 .. 4 ] of CHAR ; 
 284  6322 1  0     CDX : array [ 0 .. 67 ] of - 4 .. + 4 ; 
 285  6422 1  0     PDX : array [ 1 .. 25 ] of - 7 .. + 7 ; 
 286  7446 1  0     ORDINT : array [ CHAR ] of INTEGER ; 
 287  7458 1  0     INTLABEL , MXINT10 , DIGMAX : INTEGER ; 
 288  7462 1  0     CRNTLNPOS : INTEGER ; 
 289  7590 1  0     CRNTLN : array [ 1 .. MAXLINELEN ] of CHAR ; 
 290  7671 1  0     FNAME : packed array [ 0 .. STRGLGTH ] of CHAR ; 
 291  7676 1  0     FNAMELEN : INTEGER ; 
 292  7676 1  0  
 293  7676 1  0  
 294  7676 1  0  
 295     0 2  0 procedure WRITEFNAME ; 
 296     0 2  0  
 297    -4 2  0    var I : INTEGER ; 
 298    -4 2  0  
 299     1 2  0    begin (* WRITEFNAME *) 
 300     7 2  0      WRITE ( '"' ) ; 
 301    14 2  0      for I := 0 to FNAMELEN - 1 do 
 302    24 2  1        WRITE ( FNAME [ I ] ) ; 
 303    28 2  0      WRITE ( '"' ) ; 
 304    29 2  0    end (* WRITEFNAME *) ; 
 305    29 2  0  
 306    29 2  0  
 307    29 2  0  
 308    29 2  0 procedure PRINTERR ( ERR : INTEGER ) ; 
 309    29 2  0  
 310   -82 2  0    var S : STRING ( 80 ) ; 
****                              ^11,50^6^12
"stdin":  11 '[' expected
"stdin":  50 error in constant
"stdin":   6 illegal symbol
"stdin":  12 ']' expected
 311   -82 2  0  
 312    29 2  0    begin (* PRINTERR *) 
 313    33 2  0      case ERR of 
 314    36 2  1        1 : S := 'error in simple type' ; 
 315    39 2  1        2 : S := 'identifier expected' ; 
 316    42 2  1        4 : S := ''')'' expected' ; 
 317    45 2  1        5 : S := ''':'' expected' ; 
 318    48 2  1        6 : S := 'illegal symbol' ; 
 319    51 2  1        7 : S := 'error in parameter list' ; 
 320    54 2  1        8 : S := '''of'' expected' ; 
 321    57 2  1        9 : S := '''('' expected' ; 
 322    60 2  1        10 : S := 'error in type' ; 
 323    63 2  1        11 : S := '''['' expected' ; 
 324    66 2  1        12 : S := ''']'' expected' ; 
 325    69 2  1        13 : S := '''end'' expected' ; 
 326    72 2  1        14 : S := ''';'' expected' ; 
 327    75 2  1        15 : S := 'integer expected' ; 
 328    78 2  1        16 : S := '''='' expected' ; 
 329    81 2  1        17 : S := '''begin'' expected' ; 
 330    84 2  1        18 : S := 'error in declaration part' ; 
 331    87 2  1        19 : S := 'error in field list' ; 
 332    90 2  1        20 : S := ''','' expected' ; 
 333    93 2  1        21 : S := '''*'' expected' ; 
 334    96 2  1        22 : S := 'constant expected' ; 
 335    99 2  1        23 : S := 'string constant expected' ; 
 336   102 2  1        50 : S := 'error in constant' ; 
 337   105 2  1        51 : S := ''':='' expected' ; 
 338   108 2  1        52 : S := '''then'' expected' ; 
 339   111 2  1        53 : S := '''until'' expected' ; 
 340   114 2  1        54 : S := '''do'' expected' ; 
 341   117 2  1        55 : S := '''to'' or ''downto'' expected' ; 
 342   120 2  1        58 : S := 'error in factor' ; 
 343   123 2  1        59 : S := 'error in variable' ; 
 344   126 2  1        101 : S := 'identifier declared twice' ; 
 345   129 2  1        102 : S := 'low bound exceeds high bound' ; 
 346   132 2  1        103 : S := 'identifier is not of appropriate class' ; 
 347   135 2  1        104 : S := 'identifier not declared' ; 
 348   138 2  1        105 : S := 'sign not allowed' ; 
 349   141 2  1        106 : S := 'number expected' ; 
 350   144 2  1        107 : S := 'incompatible subrange types' ; 
 351   147 2  1        108 : S := 'file not allowed here' ; 
 352   150 2  1        109 : S := 'type must not be real' ; 
 353   153 2  1        110 : S := 'tagfield type must be scalar or subrange' ; 
 354   156 2  1        111 : S := 'incompatible with tagfield type' ; 
 355   159 2  1        113 : S := 'index type must be scalar or subrange' ; 
 356   162 2  1        114 : S := 'base type must not be real' ; 
 357   165 2  1        115 : S := 'base type must be scalar or subrange' ; 
 358   168 2  1        116 : S := 'error in type of standard procedure parameter' ; 
 359   171 2  1        117 : S := 'unsatisfied forward reference' ; 
 360   172 2  1        119 : S := 
 361   172 2  2            'forward declared: repetition of parameterlist not allowed' 
 362   174 2  2                   ; 
 363   175 2  1        120 : S := 'function result must be scalar, subrange or pointer' 
 364   177 2  2                   ; 
 365   180 2  1        121 : S := 'file value parameter not allowed' ; 
 366   181 2  1        122 : S := 
 367   181 2  2     'forward declared: repetition of function result type not allowed' 
 368   183 2  2                   ; 
 369   186 2  1        123 : S := 'missing function result type' ; 
 370   189 2  1        124 : S := 'F-format for real only' ; 
 371   192 2  1        125 : S := 'error in type of standard function parameter' ; 
 372   193 2  1        126 : S := 
 373   193 2  2                 'number of parameters does not agree with declaration' 
 374   195 2  2                   ; 
 375   196 2  1        128 : S := 
 376   196 2  2    'result type of parameter function does not agree with declaration' 
 377   198 2  2                   ; 
 378   201 2  1        129 : S := 'type conflict of operands' ; 
 379   204 2  1        130 : S := 'expression is not of set type' ; 
 380   207 2  1        131 : S := 'tests on equality allowed only' ; 
 381   210 2  1        132 : S := 'strict inclusion not allowed' ; 
 382   213 2  1        133 : S := 'file comparison not allowed' ; 
 383   216 2  1        134 : S := 'illegal type of operand(s)' ; 
 384   219 2  1        135 : S := 'type of operand must be boolean' ; 
 385   222 2  1        136 : S := 'set element type must be scalar or subrange' ; 
 386   225 2  1        137 : S := 'set element types not compatible' ; 
 387   228 2  1        138 : S := 'type of variable is not array or string' ; 
 388   231 2  1        139 : S := 'index type is not compatible with declaration' ; 
 389   234 2  1        140 : S := 'type of variable is not record' ; 
 390   237 2  1        141 : S := 'type of variable must be file or pointer' ; 
 391   240 2  1        142 : S := 'illegal parameter substitution' ; 
 392   243 2  1        143 : S := 'illegal type of loop control variable' ; 
 393   246 2  1        144 : S := 'illegal type of expression' ; 
 394   249 2  1        145 : S := 'type conflict' ; 
 395   252 2  1        146 : S := 'assignment of files not allowed' ; 
 396   255 2  1        147 : S := 'label type incompatible with selecting expression' ; 
 397   258 2  1        148 : S := 'subrange bounds must be scalar' ; 
 398   261 2  1        149 : S := 'index type must not be integer' ; 
 399   264 2  1        150 : S := 'assignment to standard function is not allowed' ; 
 400   267 2  1        151 : S := 'assignment to formal function is not allowed' ; 
 401   270 2  1        152 : S := 'no such field in this record' ; 
 402   273 2  1        154 : S := 'actual parameter must be a variable' ; 
 403   276 2  1        155 : S := 'control variable must not be a variable parameter' ; 
 404   279 2  1        156 : S := 'multidefined case label' ; 
 405   282 2  1        157 : S := 'too many cases in this statement' ; 
 406   285 2  1        158 : S := 'missing corresponding variant declration' ; 
 407   288 2  1        159 : S := 'real or string tagfields not allowed' ; 
 408   291 2  1        160 : S := 'previous declaration was not forward' ; 
 409   294 2  1        161 : S := 'again forward declared' ; 
 410   297 2  1        162 : S := 'parameter size must be constant' ; 
 411   300 2  1        165 : S := 'multidefined label' ; 
 412   303 2  1        166 : S := 'multideclared label' ; 
 413   306 2  1        167 : S := 'undeclared label' ; 
 414   309 2  1        168 : S := 'undefined label' ; 
 415   310 2  1        177 : S := 'assignment to function identifier not allowed here' 
 416   312 2  2                   ; 
 417   315 2  1        178 : S := 'multidefined record variant' ; 
 418   318 2  1        201 : S := 'error in real constant: digit expected' ; 
 419   319 2  1        202 : S := 
 420   319 2  2               'string constant must not exceed source line without \\' 
 421   321 2  2                   ; 
 422   324 2  1        203 : S := 'integer constant exceeds range' ; 
 423   327 2  1        250 : S := 'too many nested scopes of identifiers' ; 
 424   330 2  1        251 : S := 'too many nested procedures and/or functions' ; 
 425   333 2  1        254 : S := 'too many long constants in this procedure' ; 
 426   336 2  1        304 : S := 'element expression out of range' ; 
 427   339 2  1        399 : S := 'implementation restriction' ; 
 428   339 2  1        400 , 401 , 402 : 
 429   342 2  1          S := 'compiler error' ; 
 430   342 2  1        otherwise 
 431   345 2  1          S := 'sorry, no text' ; 
 432   349 2  1      end (* case *) ; 
 433   351 2  0      WRITEFNAME ; 
 434   371 2  0      WRITELN ( ': ' , ERR : 3 , ' ' , S ) ; 
 435   372 2  0    end (* PRINTERR *) ; 
 436   372 2  0  
 437   372 2  0  
 438   372 2  0  
 439   372 2  0 procedure ENDOFLINE ; 
 440   372 2  0  
 441   -24 2  0    var LASTPOS , FREEPOS , CURRPOS , CURRNMR , F , K : INTEGER ; 
 442   -24 2  0  
 443   372 2  0    begin (* ENDOFLINE *) 
 444   380 2  0      if LIST or ( ERRINX > 0 ) then 
 445   380 2  1        begin 
 446   388 2  2          WRITE ( OUTPUT , LINECOUNT : 4 , ' ' : 1 ) ; 
 447   390 2  2          if DP then 
 448   394 2  3            WRITE ( OUTPUT , LC : 5 ) 
 449   395 2  4          else 
 450   399 2  3            WRITE ( OUTPUT , IC : 5 ) ; 
 451   415 2  2          WRITE ( OUTPUT , ' ' , LEVEL : 1 , ' ' , LASTSTNEST : 2 , ' ' 
 452   419 2  3                  ) ; 
 453   424 2  2          for K := 1 to CRNTLNPOS do 
 454   435 2  3            WRITE ( OUTPUT , CRNTLN [ K ] : 1 ) ; 
 455   437 2  2          WRITELN ( OUTPUT ) ; 
 456   437 2  2        end (* then *) ; 
 457   441 2  0      if ERRINX > 0 then 
 458   441 2  1        begin 
 459   445 2  2          TOTALERRS := TOTALERRS + ERRINX ; 
 460   454 2  2          WRITE ( OUTPUT , '****' , ' ' : 11 ) ; 
 461   456 2  2          LASTPOS := 0 ; 
 462   458 2  2          FREEPOS := 1 ; 
 463   463 2  2          for K := 1 to ERRINX do 
 464   463 2  3            begin 
 465   469 2  4              with ERRLIST [ K ] do 
 466   469 2  5                begin 
 467   472 2  6                  CURRPOS := POS ; 
 468   472 2  6                  CURRNMR := NMR 
 469   475 2  7                end (* with *) ; 
 470   479 2  4              if CURRPOS = LASTPOS then 
 471   483 2  5                WRITE ( OUTPUT , ',' ) 
 472   484 2  6              else 
 473   484 2  5                begin 
 474   488 2  6                  while FREEPOS < CURRPOS do 
 475   488 2  7                    begin 
 476   492 2  8                      WRITE ( OUTPUT , ' ' ) ; 
 477   493 2  8                      FREEPOS := FREEPOS + 1 
 478   497 2  9                    end (* while *) ; 
 479   501 2  6                  WRITE ( OUTPUT , '^' ) ; 
 480   501 2  6                  LASTPOS := CURRPOS 
 481   503 2  7                end (* else *) ; 
 482   507 2  4              if CURRNMR < 10 then 
 483   507 2  5                F := 1 
 484   510 2  6              else 
 485   514 2  5                if CURRNMR < 100 then 
 486   514 2  6                  F := 2 
 487   517 2  7                else 
 488   519 2  6                  F := 3 ; 
 489   523 2  4              WRITE ( OUTPUT , CURRNMR : F ) ; 
 490   526 2  4              FREEPOS := FREEPOS + F + 1 
 491   531 2  5            end (* for *) ; 
 492   533 2  2          WRITELN ( OUTPUT ) ; 
 493   538 2  2          for K := 1 to ERRINX do 
 494   549 2  3            PRINTERR ( ERRLIST [ K ] . NMR ) ; 
 495   552 2  2          ERRINX := 0 ; 
 496   556 2  2          if TOTALERRS > MAXERRS then 
 497   556 2  3            begin 
 498   563 2  4              WRITELN ( '****  Too many errors found, good bye !' ) ; 
 499   563 2  4              EXIT ( - 1 ) ; 
****                            ^104^59   ^51
"stdin": 104 identifier not declared
"stdin":  59 error in variable
"stdin":  51 ':=' expected
 500   563 2  4            end (* then *) ; 
 501   563 2  2        end (* then *) ; 
 502   566 2  0      LINECOUNT := SUCC ( LINECOUNT ) ; 
 503   568 2  0      CHCNT := 0 ; 
 504   570 2  0      CRNTLNPOS := 0 ; 
 505   572 2  0      LASTSTNEST := STNEST ; 
 506   573 2  0    end (* ENDOFLINE *) ; 
 507   573 2  0  
 508   573 2  0  
 509   573 2  0  
 510   573 2  0 procedure ERROR ( FERRNR : INTEGER ) ; 
 511   573 2  0  
 512   573 2  0    begin (* ERROR *) 
 513   578 2  0      PRCODE := FALSE ; 
 514   582 2  0      if ERRINX >= 9 then 
 515   582 2  1        begin 
 516   591 2  2          ERRLIST [ 10 ] . NMR := 255 ; 
 517   591 2  2          ERRINX := 10 
 518   594 2  3        end (* then *) 
 519   595 2  2      else 
 520   595 2  1        begin 
 521   600 2  2          ERRINX := ERRINX + 1 ; 
 522   606 2  2          ERRLIST [ ERRINX ] . NMR := FERRNR 
 523   609 2  3        end (* else *) ; 
 524   614 2  0      ERRLIST [ ERRINX ] . POS := CHCNT 
 525   617 2  1    end (* ERROR *) ; 
 526   617 2  0  
 527   617 2  0  
 528   617 2  0  
 529   617 2  0 procedure INSYMBOL ; 
 530   617 2  0  
 531     0 2  0    label 1 , 2 , 3 , 4 , 5 ; 
 532     0 2  0  
 533    -8 2  0    var I , K : INTEGER ; 
 534   -20 2  0        DIGIT : packed array [ 1 .. RSTRGLGTH ] of CHAR ; 
 535  -100 2  0        STRNG : packed array [ 1 .. STRGLGTH ] of CHAR ; 
 536  -104 2  0        LVP : CSP ; 
 537  -106 2  0        SKIP , TEST : BOOLEAN ; 
 538  -106 2  0  
 539  -106 2  0  
 540     0 3  0    procedure NEXTCHLOWER ; 
 541     0 3  0  
 542     0 3  0       label 1 ; 
 543     0 3  0  
 544    -4 3  0       var I : INTEGER ; 
 545    -4 3  0  
 546   617 3  0       begin (* NEXTCHLOWER *) 
 547   621 3  0         if EOL then 
 548   623 3  1           ENDOFLINE ; 
 549   623 3  0         1 : 
 550   627 3  1         if not EOF ( INPUT ) then 
 551   627 3  1           begin 
 552   631 3  2             EOL := EOLN ( INPUT ) ; 
 553   634 3  2             READ ( INPUT , CH ) ; 
 554   638 3  2             if CRNTLNPOS < MAXLINELEN then 
 555   638 3  3               begin 
 556   646 3  4                 if ( CRNTLNPOS = 0 ) and ( CH = '#' ) then 
 557   646 3  5                   begin 
 558   649 3  6                     READ ( INPUT , CH ) ; 
 559   652 3  6                     READ ( INPUT , CH ) ; 
 560   654 3  6                     LINECOUNT := 0 ; 
 561   663 3  6                     while CHARTP [ CH ] = NUMBER do 
 562   663 3  7                       begin 
 563   674 3  8                         LINECOUNT := LINECOUNT * 10 + ORDINT [ CH ] ; 
 564   678 3  8                         EOL := EOLN ( INPUT ) ; 
 565   681 3  8                         READ ( INPUT , CH ) ; 
 566   682 3  8                       end (* while *) ; 
 567   689 3  6                     while not EOL and ( CH <> '"' ) do 
 568   689 3  7                       begin 
 569   693 3  8                         EOL := EOLN ( INPUT ) ; 
 570   696 3  8                         READ ( INPUT , CH ) ; 
 571   697 3  8                       end (* while *) ; 
 572   700 3  6                     if not EOL then 
 573   700 3  7                       begin 
 574   702 3  8                         I := 0 ; 
 575   702 3  8                         repeat 
 576   706 3  9                           EOL := EOLN ( INPUT ) ; 
 577   709 3  9                           READ ( INPUT , CH ) ; 
 578   715 3  9                           TEST := EOL or ( CH = '"' ) or ( I > STRGLGTH 
 579   720 3 10                                   ) ; 
 580   723 3  9                           if not TEST then 
 581   723 3 10                             begin 
 582   730 3 11                               FNAME [ I ] := CH ; 
 583   733 3 11                               I := SUCC ( I ) ; 
 584   733 3 11                             end (* then *) ; 
 585   735 3  9                         until TEST ; 
 586   737 3  8                         FNAMELEN := I ; 
 587   740 3  8                         while not EOL do 
 588   740 3  9                           begin 
 589   744 3 10                             EOL := EOLN ( INPUT ) ; 
 590   747 3 10                             READ ( INPUT , CH ) ; 
 591   748 3 10                           end (* while *) ; 
 592   750 3  8                         if LIST then 
 593   750 3  9                           begin 
 594   752 3 10                             WRITELN ; 
 595   757 3 10                             WRITE ( 'file ' ) ; 
 596   759 3 10                             WRITEFNAME ; 
 597   761 3 10                             WRITELN ; 
 598   763 3 10                             WRITELN ; 
 599   763 3 10                           end (* then *) ; 
 600   763 3  8                       end (* then *) ; 
 601   764 3  6                     goto 1 ; 
 602   764 3  6                   end (* then *) ; 
 603   767 3  4                 CRNTLNPOS := SUCC ( CRNTLNPOS ) ; 
 604   775 3  4                 CRNTLN [ CRNTLNPOS ] := CH ; 
 605   775 3  4               end (* then *) ; 
 606   780 3  2             if CH = CHR ( TAB ) then 
 607   780 3  3               begin 
 608   783 3  4                 CH := ' ' ; 
 609   791 3  4                 CHCNT := ( CHCNT + 8 ) DIV 8 * 8 ; 
 610   791 3  4               end (* then *) 
 611   792 3  4             else 
 612   794 3  3               CHCNT := SUCC ( CHCNT ) 
 613   795 3  4           end (* then *) 
 614   796 3  2         else 
 615   796 3  1           begin 
 616   801 3  2             WRITELN ( OUTPUT , '****  End of file not expected here' ) 
 617   803 3  3                       ; 
 618   803 3  2             EXIT ( - 1 ) ; 
****                           ^104^59   ^51
"stdin": 104 identifier not declared
"stdin":  59 error in variable
"stdin":  51 ':=' expected
 619   803 3  2           end (* else *) 
 620   804 3  2       end (* NEXTCHLOWER *) ; 
 621   804 3  0  
 622   804 3  0  
 623   804 3  0    procedure NEXTCH ; 
 624   804 3  0  
 625   804 3  0       begin (* NEXTCH *) 
 626   808 3  0         NEXTCHLOWER ; 
 627   816 3  0         if ( CH >= 'a' ) and ( CH <= 'z' ) then 
 628   827 3  1           CH := CHR ( ORD ( CH ) - ORD ( 'a' ) + ORD ( 'A' ) ) ; 
 629   828 3  0       end (* NEXTCH *) ; 
 630   828 3  0  
 631   828 3  0  
 632   828 3  0    procedure OPTIONS ; 
 633   828 3  0  
 634    -1 3  0       var TMP : BOOLEAN ; 
 635    -1 3  0  
 636   828 3  0       begin (* OPTIONS *) 
 637   830 3  0         repeat 
 638   832 3  1           NEXTCH ; 
 639   840 3  1           if ( CH <> '*' ) and ( CH <> '}' ) then 
 640   840 3  2             begin 
 641   844 3  3               if CH = 'L' then 
 642   844 3  4                 begin 
 643   846 3  5                   NEXTCH ; 
 644   851 3  5                   LIST := CH = '+' ; 
 645   851 3  5                 end (* then *) 
 646   852 3  5               else 
 647   856 3  4                 if CH = 'D' then 
 648   856 3  5                   begin 
 649   858 3  6                     NEXTCH ; 
 650   859 3  6                     DEBUG := CH = '+' 
 651   863 3  7                   end (* then *) 
 652   864 3  6                 else 
 653   868 3  5                   if CH = 'C' then 
 654   868 3  6                     begin 
 655   870 3  7                       NEXTCH ; 
 656   871 3  7                       PRCODE := CH = '+' 
 657   875 3  8                     end (* then *) 
 658   876 3  7                   else 
 659   880 3  6                     if CH = 'S' then 
 660   880 3  7                       SKIP := TRUE 
 661   884 3  8                     else 
 662   888 3  7                       if CH = 'A' then 
 663   888 3  8                         begin 
 664   892 3  9                           WRITE ( PRR , '@' ) ; 
 665   892 3  9                           repeat 
 666   894 3 10                             NEXTCH ; 
 667   896 3 10                             if EOL then 
 668   896 3 11                               begin 
 669   898 3 12                                 NEXTCH ; 
 670   900 3 12                                 WRITELN ( PRR ) ; 
 671   904 3 12                                 WRITE ( PRR , '@' ) ; 
 672   904 3 12                               end (* then *) ; 
 673   908 3 10                             if CH <> '}' then 
 674   912 3 11                               WRITE ( PRR , CH ) ; 
 675   919 3 10                           until ( CH = '}' ) or EOF ; 
 676   921 3  9                           WRITELN ( PRR ) ; 
 677   924 3  9                           if EOF then 
 678   924 3 10                             begin 
 679   926 3 11                               WRITELN ; 
 680   931 3 11                               WRITE ( '****  "}" expected' ) ; 
 681   931 3 11                               WRITELN ( 
 682   931 3 12                              '****  (Assembly only between {$A and })' 
 683   938 3 12                                         ) ; 
 684   938 3 11                             end (* then *) ; 
 685   938 3  9                         end (* then *) ; 
 686   942 3  3               if CH <> '}' then 
 687   942 3  4                 NEXTCH 
 688   944 3  5             end (* then *) 
 689   945 3  3         until CH <> ',' 
 690   949 3  1       end (* OPTIONS *) ; 
 691   949 3  0  
 692   949 3  0  
 693   949 2  0    begin (* INSYMBOL *) 
 694   951 2  0      1 : 
 695   951 2  1      repeat 
 696   958 2  1        while ( CH = ' ' ) and not EOL do 
 697   961 2  2          NEXTCH ; 
 698   964 2  1        TEST := EOL ; 
 699   966 2  1        if TEST then 
 700   966 2  2          NEXTCH 
 701   971 2  3      until not TEST ; 
 702   980 2  0      if CHARTP [ CH ] = ILLEGAL then 
 703   980 2  1        begin 
 704   983 2  2          SY := OTHERSY ; 
 705   986 2  2          OP := NOOP ; 
 706   990 2  2          ERROR ( 399 ) ; 
 707   990 2  2          NEXTCH 
 708   992 2  3        end (* then *) 
 709   993 2  2      else 
 710   996 2  1        case CH of 
 711   996 2  2          'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 
 712   996 2  2          'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' , 'R' , 'S' , 'T' , 
 713   996 2  2          'U' , 'V' , 'W' , 'X' , 'Y' , 'Z' , '_' : 
 714   996 2  2            begin 
 715   998 2  3              K := 0 ; 
 716   998 2  3              repeat 
 717  1002 2  4                if K < ALPHALEN then 
 718  1002 2  5                  begin 
 719  1006 2  6                    K := K + 1 ; 
 720  1011 2  6                    ID [ K ] := CH 
 721  1014 2  7                  end (* then *) ; 
 722  1014 2  4                NEXTCH 
 723  1026 2  5              until CHARTP [ CH ] in [ SPECIAL , ILLEGAL ] ; 
 724  1030 2  3              if K >= KK then 
 725  1030 2  4                KK := K 
 726  1034 2  5              else 
 727  1034 2  4                repeat 
 728  1042 2  5                  ID [ KK ] := ' ' ; 
 729  1043 2  5                  KK := KK - 1 
 730  1051 2  6                until KK = K ; 
 731  1070 2  3              for I := FRW [ K ] to FRW [ K + 1 ] - 1 do 
 732  1078 2  4                if RW [ I ] = ID then 
 733  1078 2  5                  begin 
 734  1086 2  6                    SY := RSY [ I ] ; 
 735  1094 2  6                    OP := ROP [ I ] ; 
 736  1095 2  6                    goto 2 
 737  1097 2  7                  end (* then *) ; 
 738  1100 2  3              SY := IDENT ; 
 739  1103 2  3              OP := NOOP ; 
 740  1103 2  3              2 : 
 741  1103 2  4               
 742  1104 2  4            end (* tag/ca *) ; 
 743  1104 2  2          '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 
 744  1104 2  2          '$' : begin 
 745  1107 2  3                  OP := NOOP ; 
 746  1109 2  3                  I := 0 ; 
 747  1109 2  3                  5 : 
 748  1109 2  4                  repeat 
 749  1113 2  4                    I := I + 1 ; 
 750  1117 2  4                    if I <= DIGMAX then 
 751  1125 2  5                      DIGIT [ I ] := CH ; 
 752  1125 2  4                    NEXTCH 
 753  1136 2  5                  until CHARTP [ CH ] <> NUMBER ; 
 754  1145 2  3                  if DIGIT [ 1 ] = '$' then 
 755  1153 2  4                    if ( CH >= 'A' ) and ( CH <= 'F' ) then 
 756  1154 2  5                      goto 5 ; 
 757  1162 2  3                  if ( CH = '.' ) or ( CH = 'E' ) then 
 758  1162 2  4                    begin 
 759  1164 2  5                      K := I ; 
 760  1168 2  5                      if CH = '.' then 
 761  1168 2  6                        begin 
 762  1172 2  7                          K := K + 1 ; 
 763  1176 2  7                          if K <= DIGMAX then 
 764  1184 2  8                            DIGIT [ K ] := CH ; 
 765  1186 2  7                          NEXTCH ; 
 766  1190 2  7                          if CH = '.' then 
 767  1190 2  8                            begin 
 768  1193 2  9                              CH := ':' ; 
 769  1194 2  9                              goto 3 
 770  1194 2 10                            end (* then *) ; 
 771  1203 2  7                          if CHARTP [ CH ] <> NUMBER then 
 772  1205 2  8                            ERROR ( 201 ) 
 773  1208 2  9                          else 
 774  1208 2  8                            repeat 
 775  1212 2  9                              K := K + 1 ; 
 776  1216 2  9                              if K <= DIGMAX then 
 777  1224 2 10                                DIGIT [ K ] := CH ; 
 778  1224 2  9                              NEXTCH 
 779  1232 2 10                            until CHARTP [ CH ] <> NUMBER 
 780  1235 2  9                        end (* then *) ; 
 781  1239 2  5                      if CH = 'E' then 
 782  1239 2  6                        begin 
 783  1243 2  7                          K := K + 1 ; 
 784  1247 2  7                          if K <= DIGMAX then 
 785  1255 2  8                            DIGIT [ K ] := CH ; 
 786  1257 2  7                          NEXTCH ; 
 787  1265 2  7                          if ( CH = '+' ) or ( CH = '-' ) then 
 788  1265 2  8                            begin 
 789  1269 2  9                              K := K + 1 ; 
 790  1273 2  9                              if K <= DIGMAX then 
 791  1281 2 10                                DIGIT [ K ] := CH ; 
 792  1281 2  9                              NEXTCH 
 793  1283 2 10                            end (* then *) ; 
 794  1292 2  7                          if CHARTP [ CH ] <> NUMBER then 
 795  1294 2  8                            ERROR ( 201 ) 
 796  1297 2  9                          else 
 797  1297 2  8                            repeat 
 798  1301 2  9                              K := K + 1 ; 
 799  1305 2  9                              if K <= DIGMAX then 
 800  1313 2 10                                DIGIT [ K ] := CH ; 
 801  1313 2  9                              NEXTCH 
 802  1321 2 10                            until CHARTP [ CH ] <> NUMBER 
 803  1324 2  9                        end (* then *) ; 
 804  1333 2  5                      if DIGIT [ 1 ] = '$' then 
 805  1333 2  6                        begin 
 806  1337 2  7                          ERROR ( 201 ) ; 
 807  1345 2  7                          DIGIT [ 1 ] := '0' ; 
 808  1345 2  7                        end (* then *) ; 
 809  1348 2  5                      NEW ( LVP , REEL ) ; 
 810  1351 2  5                      SY := REALCONST ; 
 811  1356 2  5                      LVP -> . CCLASS := REEL ; 
 812  1359 2  5                      with LVP -> do 
 813  1359 2  6                        begin 
 814  1364 2  7                          for I := 1 to RSTRGLGTH do 
 815  1375 2  8                            RVAL [ I ] := ' ' ; 
 816  1379 2  7                          if K <= DIGMAX then 
 817  1386 2  8                            for I := 2 to K + 1 do 
 818  1399 2  9                              RVAL [ I ] := DIGIT [ I - 1 ] 
 819  1405 2 10                          else 
 820  1405 2  8                            begin 
 821  1409 2  9                              ERROR ( 203 ) ; 
 822  1418 2  9                              RVAL [ 2 ] := '0' ; 
 823  1427 2  9                              RVAL [ 3 ] := '.' ; 
 824  1433 2  9                              RVAL [ 4 ] := '0' 
 825  1436 2 10                            end (* else *) 
 826  1436 2  9                        end (* with *) ; 
 827  1436 2  5                      VAL . VALP := LVP 
 828  1439 2  6                    end (* then *) 
 829  1440 2  5                  else 
 830  1440 2  4                    3 : 
 831  1440 2  5                    begin 
 832  1444 2  5                      if I > DIGMAX then 
 833  1444 2  6                        begin 
 834  1448 2  7                          ERROR ( 203 ) ; 
 835  1448 2  7                          VAL . IVAL := 0 
 836  1450 2  8                        end (* then *) 
 837  1451 2  7                      else 
 838  1451 2  6                        with VAL do 
 839  1451 2  7                          begin 
 840  1453 2  8                            IVAL := 0 ; 
 841  1462 2  8                            if DIGIT [ 1 ] = '$' then 
 842  1467 2  9                              for K := 2 to I do 
 843  1467 2 10                                begin 
 844  1471 2 11                                  if IVAL <= MXINT10 then 
 845  1471 2 12                                    begin 
 846  1475 2 13                                      IVAL := IVAL * 16 ; 
 847  1484 2 13                                      if DIGIT [ K ] < 'A' then 
 848  1487 2 14                                        IVAL := IVAL + ORDINT [ DIGIT [ 
 849  1495 2 15                                                K ] ] 
 850  1499 2 15                                      else 
 851  1505 2 14                                        IVAL := IVAL + ORD ( DIGIT [ K ] 
 852  1514 2 15                                                ) - ORD ( 'A' ) + 10 ; 
 853  1514 2 13                                    end (* then *) 
 854  1515 2 13                                  else 
 855  1515 2 12                                    begin 
 856  1519 2 13                                      ERROR ( 203 ) ; 
 857  1519 2 13                                      IVAL := 0 
 858  1521 2 14                                    end (* else *) 
 859  1521 2 13                                end (* for *) 
 860  1524 2 11                            else 
 861  1529 2  9                              for K := 1 to I do 
 862  1529 2 10                                begin 
 863  1533 2 11                                  if IVAL <= MXINT10 then 
 864  1538 2 12                                    IVAL := IVAL * 10 + ORDINT [ DIGIT [ 
 865  1546 2 13                                            K ] ] 
 866  1550 2 13                                  else 
 867  1550 2 12                                    begin 
 868  1554 2 13                                      ERROR ( 203 ) ; 
 869  1554 2 13                                      IVAL := 0 
 870  1556 2 14                                    end (* else *) 
 871  1558 2 13                                end (* for *) ; 
 872  1558 2  8                            SY := INTCONST 
 873  1561 2  9                          end (* with *) 
 874  1561 2  8                    end 
 875  1562 2  5                end (* tag/ca *) ; 
 876  1562 2  2          '''' : begin 
 877  1564 2  3                   LGTH := 0 ; 
 878  1567 2  3                   SY := STRINGCONST ; 
 879  1570 2  3                   OP := NOOP ; 
 880  1570 2  3                   repeat 
 881  1570 2  4                     repeat 
 882  1570 2  5                       4 : 
 883  1572 2  6                       NEXTCHLOWER ; 
 884  1575 2  5                       if CH = '\' then 
****                                                 ^129
"stdin": 129 type conflict of operands
 885  1575 2  6                         begin 
 886  1577 2  7                           NEXTCHLOWER ; 
 887  1580 2  7                           case CH of 
 888  1585 2  8                             'n' : CH := CHR ( 10 ) ; 
 889  1590 2  8                             't' : CH := CHR ( 9 ) ; 
 890  1595 2  8                             'b' : CH := CHR ( 8 ) ; 
 891  1600 2  8                             'r' : CH := CHR ( 13 ) ; 
 892  1605 2  8                             'f' : CH := CHR ( 12 ) ; 
 893  1605 2  8                             '0' , '1' , '2' , '3' : 
 894  1605 2  8                               begin 
 895  1607 2  9                                 I := 0 ; 
 896  1609 2  9                                 K := 0 ; 
 897  1615 2  9                                 while ( CH >= '0' ) and ( CH <= '7' ) 
 898  1621 2 10                                 and ( K < 3 ) do 
 899  1621 2 10                                   begin 
 900  1625 2 11                                     I := I * 8 ; 
 901  1633 2 11                                     I := I + ORD ( CH ) - ORD ( '0' ) ; 
 902  1636 2 11                                     K := SUCC ( K ) ; 
 903  1640 2 11                                     if ( K < 3 ) then 
 904  1642 2 12                                       NEXTCHLOWER ; 
 905  1643 2 11                                   end (* while *) ; 
 906  1647 2  9                                 CH := CHR ( I ) ; 
 907  1648 2  9                               end (* tag/ca *) ; 
 908  1648 2  8                             otherwise 
 909  1648 2  8                                
 910  1650 2  8                             : if EOL then 
 911  1652 2  9                                 goto 4 ; 
 912  1656 2  8                           end (* case *) ; 
 913  1656 2  7                         end (* then *) ; 
 914  1660 2  5                       LGTH := LGTH + 1 ; 
 915  1664 2  5                       if LGTH <= STRGLGTH then 
 916  1669 2  6                         STRNG [ LGTH ] := CH 
 917  1678 2  7                     until ( EOL ) or ( CH = '''' ) ; 
 918  1680 2  4                     if EOL then 
 919  1682 2  5                       ERROR ( 202 ) 
 920  1685 2  6                     else 
 921  1685 2  5                       NEXTCH 
 922  1691 2  6                   until CH <> '''' ; 
 923  1695 2  3                   LGTH := LGTH - 1 ; 
 924  1702 2  3                   if not EXPECTSTRING and ( LGTH = 1 ) then 
 925  1709 2  4                     VAL . IVAL := ORD ( STRNG [ 1 ] ) 
 926  1711 2  5                   else 
 927  1711 2  4                     begin 
 928  1714 2  5                       NEW ( LVP , STRG ) ; 
 929  1719 2  5                       LVP -> . CCLASS := STRG ; 
 930  1723 2  5                       if LGTH > STRGLGTH then 
 931  1723 2  6                         begin 
 932  1727 2  7                           ERROR ( 399 ) ; 
 933  1727 2  7                           LGTH := STRGLGTH 
 934  1729 2  8                         end (* then *) ; 
 935  1732 2  5                       with LVP -> do 
 936  1732 2  6                         begin 
 937  1737 2  7                           SLGTH := LGTH ; 
 938  1742 2  7                           for I := 1 to LGTH do 
 939  1753 2  8                             SVAL [ I ] := STRNG [ I ] 
 940  1758 2  9                         end (* with *) ; 
 941  1758 2  5                       VAL . VALP := LVP 
 942  1761 2  6                     end (* else *) 
 943  1762 2  5                 end (* tag/ca *) ; 
 944  1762 2  2          ':' : begin 
 945  1765 2  3                  OP := NOOP ; 
 946  1767 2  3                  NEXTCH ; 
 947  1771 2  3                  if CH = '=' then 
 948  1771 2  4                    begin 
 949  1774 2  5                      SY := BECOMES ; 
 950  1774 2  5                      NEXTCH 
 951  1776 2  6                    end (* then *) 
 952  1777 2  5                  else 
 953  1777 2  4                    SY := COLON 
 954  1781 2  5                end (* tag/ca *) ; 
 955  1781 2  2          '.' : begin 
 956  1784 2  3                  OP := NOOP ; 
 957  1786 2  3                  NEXTCH ; 
 958  1790 2  3                  if CH = '.' then 
 959  1790 2  4                    begin 
 960  1793 2  5                      SY := COLON ; 
 961  1793 2  5                      NEXTCH 
 962  1795 2  6                    end (* then *) 
 963  1796 2  5                  else 
 964  1796 2  4                    SY := PERIOD 
 965  1800 2  5                end (* tag/ca *) ; 
 966  1800 2  2          '<' : begin 
 967  1802 2  3                  NEXTCH ; 
 968  1805 2  3                  SY := RELOP ; 
 969  1809 2  3                  if CH = '=' then 
 970  1809 2  4                    begin 
 971  1812 2  5                      OP := LEOP ; 
 972  1812 2  5                      NEXTCH 
 973  1814 2  6                    end (* then *) 
 974  1815 2  5                  else 
 975  1819 2  4                    if CH = '>' then 
 976  1819 2  5                      begin 
 977  1822 2  6                        OP := NEOP ; 
 978  1822 2  6                        NEXTCH 
 979  1824 2  7                      end (* then *) 
 980  1825 2  6                    else 
 981  1825 2  5                      OP := LTOP 
 982  1829 2  6                end (* tag/ca *) ; 
 983  1829 2  2          '>' : begin 
 984  1831 2  3                  NEXTCH ; 
 985  1834 2  3                  SY := RELOP ; 
 986  1838 2  3                  if CH = '=' then 
 987  1838 2  4                    begin 
 988  1841 2  5                      OP := GEOP ; 
 989  1841 2  5                      NEXTCH 
 990  1843 2  6                    end (* then *) 
 991  1844 2  5                  else 
 992  1844 2  4                    OP := GTOP 
 993  1848 2  5                end (* tag/ca *) ; 
 994  1848 2  2          '{' : begin 
 995  1850 2  3                  NEXTCH ; 
 996  1853 2  3                  SKIP := FALSE ; 
 997  1857 2  3                  if CH = '$' then 
 998  1859 2  4                    OPTIONS ; 
 999  1861 2  3                  if SKIP then 
1000  1861 2  4                    begin 
1001  1863 2  5                      READLN ; 
1002  1866 2  5                      LINECOUNT := SUCC ( LINECOUNT ) ; 
1003  1866 2  5                    end (* then *) 
1004  1867 2  5                  else 
1005  1871 2  4                    while CH <> '}' do 
1006  1874 2  5                      NEXTCH ; 
1007  1876 2  3                  NEXTCH ; 
1008  1877 2  3                  goto 1 
1009  1878 2  4                end (* tag/ca *) ; 
1010  1878 2  2          '(' : begin 
1011  1880 2  3                  NEXTCH ; 
1012  1883 2  3                  SKIP := FALSE ; 
1013  1887 2  3                  if CH = '*' then 
1014  1887 2  4                    begin 
1015  1889 2  5                      NEXTCH ; 
1016  1893 2  5                      if CH = '$' then 
1017  1895 2  6                        OPTIONS ; 
1018  1897 2  5                      if SKIP then 
1019  1897 2  6                        begin 
1020  1899 2  7                          READLN ; 
1021  1902 2  7                          LINECOUNT := SUCC ( LINECOUNT ) ; 
1022  1902 2  7                        end (* then *) 
1023  1903 2  7                      else 
1024  1903 2  6                        repeat 
1025  1907 2  7                          while CH <> '*' do 
1026  1910 2  8                            NEXTCH ; 
1027  1910 2  7                          NEXTCH 
1028  1916 2  8                        until CH = ')' ; 
1029  1918 2  5                      NEXTCH ; 
1030  1919 2  5                      goto 1 
1031  1919 2  6                    end (* then *) ; 
1032  1922 2  3                  SY := LPARENT ; 
1033  1922 2  3                  OP := NOOP 
1034  1926 2  4                end (* tag/ca *) ; 
1035  1926 2  2          '-' : begin 
1036  1928 2  3                  NEXTCH ; 
1037  1932 2  3                  if CH = '>' then 
1038  1932 2  4                    begin 
1039  1934 2  5                      NEXTCH ; 
1040  1937 2  5                      OP := NOOP ; 
1041  1937 2  5                      SY := ARROW 
1042  1940 2  6                    end (* then *) 
1043  1941 2  5                  else 
1044  1941 2  4                    begin 
1045  1944 2  5                      OP := MINUS ; 
1046  1944 2  5                      SY := ADDOP 
1047  1947 2  6                    end (* else *) 
1048  1948 2  5                end (* tag/ca *) ; 
1049  1948 2  2          '*' , '+' , '@' , '=' , '/' , ')' , '[' , ']' , ',' , ';' , 
1050  1948 2  2          '^' : begin 
1051  1956 2  3                  SY := SSY [ CH ] ; 
1052  1964 2  3                  OP := SOP [ CH ] ; 
1053  1964 2  3                  NEXTCH 
1054  1967 2  4                end (* tag/ca *) ; 
1055  1971 2  2          ' ' : SY := OTHERSY ; 
1056  1971 2  2          otherwise 
1057  1971 2  2             
1058  1971 2  2          : begin 
1059  1974 2  3              SY := OTHERSY ; 
1060  1977 2  3              OP := NOOP ; 
1061  1981 2  3              ERROR ( 399 ) ; 
1062  1983 2  3              NEXTCH ; 
1063  1984 2  3            end (* tag/ca *) ; 
1064  1988 2  2        end (* case *) 
1065  1989 2  2    end (* INSYMBOL *) ; 
1066  1989 2  0  
1067  1989 2  0  
1068  1989 2  0  
1069  1989 2  0 procedure ENTERID ( FCP : CTP ) ; 
1070  1989 2  0  
1071   -16 2  0    var NAM : ALPHA ; 
1072   -24 2  0        LCP , LCP1 : CTP ; 
1073   -25 2  0        LLEFT : BOOLEAN ; 
1074   -25 2  0  
1075  1989 2  0    begin (* ENTERID *) 
1076  1995 2  0      NAM := FCP -> . NAME ; 
1077  2002 2  0      LCP := DISPLAY [ TOP ] . FNAME ; 
1078  2006 2  0      if LCP = NIL then 
1079  2010 2  1        DISPLAY [ TOP ] . FNAME := FCP 
1080  2014 2  2      else 
1081  2014 2  1        begin 
1082  2014 2  2          repeat 
1083  2017 2  3            LCP1 := LCP ; 
1084  2022 2  3            if LCP -> . NAME = NAM then 
1085  2022 2  4              begin 
1086  2026 2  5                ERROR ( 101 ) ; 
1087  2031 2  5                LCP := LCP -> . RLINK ; 
1088  2031 2  5                LLEFT := FALSE 
1089  2034 2  6              end (* then *) 
1090  2035 2  5            else 
1091  2040 2  4              if LCP -> . NAME < NAM then 
1092  2040 2  5                begin 
1093  2045 2  6                  LCP := LCP -> . RLINK ; 
1094  2045 2  6                  LLEFT := FALSE 
1095  2048 2  7                end (* then *) 
1096  2049 2  6              else 
1097  2049 2  5                begin 
1098  2054 2  6                  LCP := LCP -> . LLINK ; 
1099  2054 2  6                  LLEFT := TRUE 
1100  2057 2  7                end (* else *) 
1101  2061 2  6          until LCP = NIL ; 
1102  2063 2  2          if LLEFT then 
1103  2066 2  3            LCP1 -> . LLINK := FCP 
1104  2070 2  4          else 
1105  2073 2  3            LCP1 -> . RLINK := FCP 
1106  2076 2  4        end (* else *) ; 
1107  2082 2  0      FCP -> . LLINK := NIL ; 
1108  2088 2  0      FCP -> . RLINK := NIL ; 
1109  2089 2  0    end (* ENTERID *) ; 
1110  2089 2  0  
1111  2089 2  0  
1112  2089 2  0  
1113  2089 2  0 procedure SEARCHSECTION ( FCP : CTP ; var FCP1 : CTP ) ; 
1114  2089 2  0  
1115     0 2  0    label 1 ; 
1116     0 2  0  
1117  2089 2  0    begin (* SEARCHSECTION *) 
1118  2095 2  0      while FCP <> NIL do 
1119  2100 2  1        if FCP -> . NAME = ID then 
1120  2101 2  2          goto 1 
1121  2102 2  3        else 
1122  2107 2  2          if FCP -> . NAME < ID then 
1123  2109 2  3            FCP := FCP -> . RLINK 
1124  2113 2  4          else 
1125  2119 2  3            FCP := FCP -> . LLINK ; 
1126  2119 2  0      1 : 
1127  2120 2  1      FCP1 := FCP 
1128  2124 2  1    end (* SEARCHSECTION *) ; 
1129  2124 2  0  
1130  2124 2  0  
1131  2124 2  0  
1132  2124 2  0 procedure SEARCHID ( FIDCLS : SETOFIDS ; var FCP : CTP ) ; 
1133  2124 2  0  
1134     0 2  0    label 1 ; 
1135     0 2  0  
1136    -4 2  0    var LCP : CTP ; 
1137    -4 2  0  
1138  2124 2  0    begin (* SEARCHID *) 
1139  2132 2  0      for DISX := TOP DOWNTO 0 do 
1140  2132 2  1        begin 
1141  2139 2  2          LCP := DISPLAY [ DISX ] . FNAME ; 
1142  2143 2  2          while LCP <> NIL do 
1143  2148 2  3            if LCP -> . NAME = ID then 
1144  2155 2  4              if LCP -> . KLASS in FIDCLS then 
1145  2156 2  5                goto 1 
1146  2157 2  6              else 
1147  2157 2  5                begin 
1148  2159 2  6                  if PRTERR then 
1149  2163 2  7                    ERROR ( 103 ) ; 
1150  2165 2  6                  LCP := LCP -> . RLINK 
1151  2168 2  7                end (* else *) 
1152  2169 2  6            else 
1153  2174 2  4              if LCP -> . NAME < ID then 
1154  2176 2  5                LCP := LCP -> . RLINK 
1155  2180 2  6              else 
1156  2182 2  5                LCP := LCP -> . LLINK 
1157  2188 2  6        end (* for *) ; 
1158  2190 2  0      if PRTERR then 
1159  2190 2  1        begin 
1160  2194 2  2          ERROR ( 104 ) ; 
1161  2199 2  2          if TYPES in FIDCLS then 
1162  2199 2  3            LCP := UTYPPTR 
1163  2203 2  4          else 
1164  2208 2  3            if VARS in FIDCLS then 
1165  2208 2  4              LCP := UVARPTR 
1166  2212 2  5            else 
1167  2217 2  4              if FIELD in FIDCLS then 
1168  2217 2  5                LCP := UFLDPTR 
1169  2221 2  6              else 
1170  2226 2  5                if KONST in FIDCLS then 
1171  2226 2  6                  LCP := UCSTPTR 
1172  2230 2  7                else 
1173  2235 2  6                  if PROC in FIDCLS then 
1174  2235 2  7                    LCP := UPRCPTR 
1175  2239 2  8                  else 
1176  2242 2  7                    LCP := UFCTPTR ; 
1177  2242 2  2        end (* then *) ; 
1178  2242 2  0      1 : 
1179  2243 2  1      FCP := LCP 
1180  2247 2  1    end (* SEARCHID *) ; 
1181  2247 2  0  
1182  2247 2  0  
1183  2247 2  0  
1184  2247 2  0 procedure GETBOUNDS ( FSP : STP ; var FMIN , FMAX : INTEGER ) ; 
1185  2247 2  0  
1186  2247 2  0    begin (* GETBOUNDS *) 
1187  2252 2  0      FMIN := 0 ; 
1188  2255 2  0      FMAX := 0 ; 
1189  2259 2  0      if FSP <> NIL then 
1190  2262 2  1        with FSP -> do 
1191  2267 2  2          if FORM = SUBRANGE then 
1192  2267 2  3            begin 
1193  2271 2  4              FMIN := MIN . IVAL ; 
1194  2273 2  4              FMAX := MAX . IVAL 
1195  2275 2  5            end (* then *) 
1196  2276 2  4          else 
1197  2280 2  3            if FSP = CHARPTR then 
1198  2280 2  4              begin 
1199  2283 2  5                FMIN := ORDMINCHAR ; 
1200  2284 2  5                FMAX := ORDMAXCHAR 
1201  2286 2  6              end (* then *) 
1202  2287 2  5            else 
1203  2292 2  4              if FCONST <> NIL then 
1204  2296 2  5                FMAX := FCONST -> . VALUES . IVAL 
1205  2299 2  6    end (* GETBOUNDS *) ; 
1206  2299 2  0  
1207  2299 2  0  
1208  2299 2  0  
1209  2299 2  0 function ALIGNQUOT ( FSP : STP ) : INTEGER ; 
1210  2299 2  0  
1211  2299 2  0    begin (* ALIGNQUOT *) 
1212  2303 2  0      ALIGNQUOT := 1 ; 
1213  2307 2  0      if FSP <> NIL then 
1214  2310 2  1        with FSP -> do 
1215  2314 2  2          case FORM of 
1216  2314 2  3            SCALAR : 
1217  2318 2  3              if FSP = INTPTR then 
1218  2318 2  4                ALIGNQUOT := INTAL 
1219  2321 2  5              else 
1220  2325 2  4                if FSP = BOOLPTR then 
1221  2325 2  5                  ALIGNQUOT := BOOLAL 
1222  2328 2  6                else 
1223  2333 2  5                  if SCALKIND = DECLARED then 
1224  2333 2  6                    ALIGNQUOT := INTAL 
1225  2336 2  7                  else 
1226  2340 2  6                    if FSP = CHARPTR then 
1227  2340 2  7                      ALIGNQUOT := CHARAL 
1228  2343 2  8                    else 
1229  2347 2  7                      if FSP = REALPTR then 
1230  2347 2  8                        ALIGNQUOT := REALAL 
1231  2350 2  9                      else 
1232  2353 2  8                        ALIGNQUOT := PARMAL ; 
1233  2353 2  3            SUBRANGE : 
1234  2359 2  3              ALIGNQUOT := ALIGNQUOT ( RANGETYPE ) ; 
1235  2359 2  3            POINTER : 
1236  2362 2  3              ALIGNQUOT := ADRAL ; 
1237  2365 2  3            POWER : ALIGNQUOT := SETAL ; 
1238  2368 2  3            FILES : ALIGNQUOT := FILEAL ; 
1239  2368 2  3            ARRAYS : 
1240  2371 2  3              ALIGNQUOT := RECAL ; 
1241  2371 2  3            RECORDS : 
1242  2374 2  3              ALIGNQUOT := RECAL ; 
1243  2374 2  3            VARIANT , TAGFLD : 
1244  2376 2  3              ERROR ( 402 ) 
1245  2383 2  4          end (* case *) 
1246  2384 2  3    end (* ALIGNQUOT *) ; 
1247  2384 2  0  
1248  2384 2  0  
1249  2384 2  0  
1250  2384 2  0 procedure ALIGN ( FSP : STP ; var FLC : INTEGER ) ; 
1251  2384 2  0  
1252    -4 2  0    var K : INTEGER ; 
1253    -4 2  0  
1254  2384 2  0    begin (* ALIGN *) 
1255  2390 2  0      K := ALIGNQUOT ( FSP ) ; 
1256  2395 2  0      if FLC >= 0 then 
1257  2395 2  1        begin 
1258  2407 2  2          FLC := ( FLC + ( K - 1 ) ) DIV K * K ; 
1259  2407 2  2        end (* then *) 
1260  2408 2  2      else 
1261  2408 2  1        begin 
1262  2420 2  2          FLC := ( FLC - ( K - 1 ) ) DIV K * K ; 
1263  2420 2  2        end (* else *) ; 
1264  2421 2  0    end (* ALIGN *) ; 
1265  2421 2  0  
1266  2421 2  0  
1267  2421 2  0  
1268  2421 2  0 procedure GENLABEL ( var NXTLAB : INTEGER ) ; 
1269  2421 2  0  
1270  2421 2  0    begin (* GENLABEL *) 
1271  2427 2  0      INTLABEL := INTLABEL + 1 ; 
1272  2428 2  0      NXTLAB := INTLABEL 
1273  2431 2  1    end (* GENLABEL *) ; 
1274  2431 2  0  
1275  2431 2  0  
1276  2431 2  0  
1277  2431 2  0 procedure WRITESTRG ( var CNST : CONSTANT ) ; 
1278  2431 2  0  
1279    -4 2  0    var I : INTEGER ; 
1280    -4 2  0  
1281  2431 2  0    begin (* WRITESTRG *) 
1282  2435 2  0      with CNST do 
1283  2441 2  1        for I := 1 to SLGTH do 
1284  2453 2  2          WRITE ( PRR , SVAL [ I ] ) ; 
1285  2454 2  0    end (* WRITESTRG *) ; 
1286  2454 2  0  
1287  2454 2  0  
1288  2454 2  0  
1289  2454 2  0 procedure WRITENAME ( var NAME : ALPHA ) ; 
1290  2454 2  0  
1291     0 2  0    label 1 ; 
1292     0 2  0  
1293    -4 2  0    var I : INTEGER ; 
1294    -5 2  0        C : CHAR ; 
1295    -5 2  0  
1296  2454 2  0    begin (* WRITENAME *) 
1297  2461 2  0      for I := 1 to ALPHALEN do 
1298  2461 2  1        begin 
1299  2469 2  2          C := NAME [ I ] ; 
1300  2473 2  2          if C = ' ' then 
1301  2474 2  3            goto 1 ; 
1302  2478 2  2          WRITE ( PRR , C : 1 ) ; 
1303  2480 2  2        end (* for *) ; 
1304  2480 2  0      1 : 
1305  2480 2  1       
1306  2481 2  1    end (* WRITENAME *) ; 
1307  2481 2  0  
1308  2481 2  0  
1309  2481 2  0  
1310  2481 2  0 procedure BLOCK ( FSYS : SETOFSYS ; FSY : SYMBOL ; FPROCP : CTP ) ; 
1311  2481 2  0  
1312    -4 2  0    var LSY : SYMBOL ; 
1313    -5 2  0        TEST : BOOLEAN ; 
1314   -10 2  0        LABELSDISP : DISPRANGE ; 
1315   -10 2  0  
1316   -10 2  0  
1317     0 3  0    procedure SKIP ( FSYS : SETOFSYS ) ; 
1318     0 3  0  
1319  2481 3  0       begin (* SKIP *) 
1320  2487 3  0         if not EOF ( INPUT ) then 
1321  2487 3  1           begin 
1322  2497 3  2             while not ( SY in FSYS ) and ( not EOF ( INPUT ) ) do 
1323  2500 3  3               INSYMBOL ; 
1324  2506 3  2             if not ( SY in FSYS ) then 
1325  2506 3  3               INSYMBOL 
1326  2508 3  4           end (* then *) 
1327  2509 3  2       end (* SKIP *) ; 
1328  2509 3  0  
1329  2509 3  0  
1330  2509 3  0    procedure CONSTANT ( FSYS : SETOFSYS ; var FSP : STP ; var FVALU : 
1331  2509 3  0                       VALU ) ; 
1332  2509 3  0  
1333    -4 3  0       var LSP : STP ; 
1334    -8 3  0           LCP : CTP ; 
1335   -12 3  0           SIGN : ( NONE , POS , NEG ) ; 
1336   -16 3  0           LVP : CSP ; 
1337   -20 3  0           I : 2 .. STRGLGTH ; 
1338   -20 3  0  
1339  2509 3  0       begin (* CONSTANT *) 
1340  2514 3  0         LSP := NIL ; 
1341  2518 3  0         FVALU . IVAL := 0 ; 
1342  2524 3  0         if not ( SY in CONSTBEGSYS ) then 
1343  2524 3  1           begin 
1344  2528 3  2             ERROR ( 50 ) ; 
1345  2531 3  2             SKIP ( FSYS + CONSTBEGSYS ) 
1346  2533 3  3           end (* then *) ; 
1347  2538 3  0         if SY in CONSTBEGSYS then 
1348  2538 3  1           begin 
1349  2542 3  2             if SY = STRINGCONST then 
1350  2542 3  3               begin 
1351  2549 3  4                 if not EXPECTSTRING and ( LGTH = 1 ) then 
1352  2549 3  5                   LSP := CHARPTR 
1353  2553 3  6                 else 
1354  2553 3  5                   begin 
1355  2556 3  6                     NEW ( LSP , ARRAYS ) ; 
1356  2559 3  6                     with LSP -> do 
1357  2559 3  7                       begin 
1358  2564 3  8                         AELTYPE := CHARPTR ; 
1359  2569 3  8                         INXTYPE := NIL ; 
1360  2578 3  8                         SIZE := LGTH * CHARSIZE + 1 ; 
1361  2583 3  8                         FORM := ARRAYS ; 
1362  2588 3  8                         VARY := TRUE ; 
1363  2588 3  8                       end (* with *) 
1364  2588 3  8                   end (* else *) ; 
1365  2591 3  4                 FVALU := VAL ; 
1366  2591 3  4                 INSYMBOL 
1367  2593 3  5               end (* then *) 
1368  2594 3  4             else 
1369  2594 3  3               begin 
1370  2597 3  4                 SIGN := NONE ; 
1371  2606 3  4                 if ( SY = ADDOP ) and ( OP in [ PLUS , MINUS ] ) then 
1372  2606 3  5                   begin 
1373  2610 3  6                     if OP = PLUS then 
1374  2610 3  7                       SIGN := POS 
1375  2614 3  8                     else 
1376  2617 3  7                       SIGN := NEG ; 
1377  2617 3  6                     INSYMBOL 
1378  2619 3  7                   end (* then *) ; 
1379  2623 3  4                 if SY = IDENT then 
1380  2623 3  5                   begin 
1381  2627 3  6                     SEARCHID ( [ KONST ] , LCP ) ; 
1382  2630 3  6                     with LCP -> do 
1383  2630 3  7                       begin 
1384  2634 3  8                         LSP := IDTYPE ; 
1385  2635 3  8                         FVALU := VALUES 
1386  2638 3  9                       end (* with *) ; 
1387  2642 3  6                     if SIGN <> NONE then 
1388  2646 3  7                       if LSP = INTPTR then 
1389  2646 3  8                         begin 
1390  2650 3  9                           if SIGN = NEG then 
1391  2653 3 10                             FVALU . IVAL := - FVALU . IVAL 
1392  2656 3 11                         end (* then *) 
1393  2657 3  9                       else 
1394  2661 3  8                         if LSP = REALPTR then 
1395  2661 3  9                           begin 
1396  2665 3 10                             if SIGN = NEG then 
1397  2665 3 11                               begin 
1398  2668 3 12                                 NEW ( LVP , REEL ) ; 
1399  2677 3 12                                 if FVALU . VALP -> . RVAL [ 1 ] = '-' 
1400  2680 3 13                                 then 
1401  2687 3 13                                   LVP -> . RVAL [ 1 ] := '+' 
1402  2691 3 14                                 else 
1403  2701 3 13                                   LVP -> . RVAL [ 1 ] := '-' ; 
1404  2707 3 12                                 for I := 2 to RSTRGLGTH do 
1405  2715 3 13                                   LVP -> . RVAL [ I ] := FVALU . VALP 
1406  2727 3 14                                                    -> . RVAL [ I ] ; 
1407  2732 3 12                                 FVALU . VALP := LVP ; 
1408  2732 3 12                               end (* then *) 
1409  2732 3 12                           end (* then *) 
1410  2733 3 10                         else 
1411  2737 3  9                           ERROR ( 105 ) ; 
1412  2739 3  6                     INSYMBOL ; 
1413  2739 3  6                   end (* then *) 
1414  2740 3  6                 else 
1415  2744 3  5                   if SY = INTCONST then 
1416  2744 3  6                     begin 
1417  2748 3  7                       if SIGN = NEG then 
1418  2751 3  8                         VAL . IVAL := - VAL . IVAL ; 
1419  2754 3  7                       LSP := INTPTR ; 
1420  2757 3  7                       FVALU := VAL ; 
1421  2757 3  7                       INSYMBOL 
1422  2759 3  8                     end (* then *) 
1423  2760 3  7                   else 
1424  2764 3  6                     if SY = REALCONST then 
1425  2764 3  7                       begin 
1426  2768 3  8                         if SIGN = NEG then 
1427  2778 3  9                           VAL . VALP -> . RVAL [ 1 ] := '-' ; 
1428  2781 3  8                         LSP := REALPTR ; 
1429  2784 3  8                         FVALU := VAL ; 
1430  2784 3  8                         INSYMBOL 
1431  2786 3  9                       end (* then *) 
1432  2787 3  8                     else 
1433  2787 3  7                       begin 
1434  2791 3  8                         ERROR ( 106 ) ; 
1435  2792 3  8                         SKIP ( FSYS ) 
1436  2794 3  9                       end (* else *) 
1437  2794 3  8               end (* else *) ; 
1438  2800 3  2             if not ( SY in FSYS ) then 
1439  2800 3  3               begin 
1440  2804 3  4                 ERROR ( 6 ) ; 
1441  2805 3  4                 SKIP ( FSYS ) 
1442  2807 3  5               end (* then *) 
1443  2807 3  4           end (* then *) ; 
1444  2808 3  0         FSP := LSP 
1445  2812 3  1       end (* CONSTANT *) ; 
1446  2812 3  0  
1447  2812 3  0  
1448  2812 3  0    function EQUALBOUNDS ( FSP1 , FSP2 : STP ) : BOOLEAN ; 
1449  2812 3  0  
1450   -16 3  0       var LMIN1 , LMIN2 , LMAX1 , LMAX2 : INTEGER ; 
1451   -16 3  0  
1452  2812 3  0       begin (* EQUALBOUNDS *) 
1453  2822 3  0         if ( FSP1 = NIL ) or ( FSP2 = NIL ) then 
1454  2822 3  1           EQUALBOUNDS := TRUE 
1455  2826 3  2         else 
1456  2826 3  1           begin 
1457  2831 3  2             GETBOUNDS ( FSP1 , LMIN1 , LMAX1 ) ; 
1458  2836 3  2             GETBOUNDS ( FSP1 , LMIN2 , LMAX2 ) ; 
1459  2842 3  2             EQUALBOUNDS := ( LMIN1 = LMIN2 ) and ( LMAX1 = LMAX2 ) 
1460  2845 3  3           end (* else *) 
1461  2846 3  2       end (* EQUALBOUNDS *) ; 
1462  2846 3  0  
1463  2846 3  0  
1464  2846 3  0    function COMPTYPES ( FSP1 , FSP2 : STP ) : BOOLEAN ; 
1465  2846 3  0  
1466     0 3  0       label 1 , 99 ; 
1467     0 3  0  
1468    -8 3  0       var NXT1 , NXT2 : CTP ; 
1469    -9 3  0           COMP : BOOLEAN ; 
1470   -18 3  0           LTESTP1 , LTESTP2 : TESTP ; 
1471   -18 3  0  
1472  2846 3  0       begin (* COMPTYPES *) 
1473  2852 3  0         if FSP1 = FSP2 then 
1474  2852 3  1           COMPTYPES := TRUE 
1475  2856 3  2         else 
1476  2864 3  1           if ( FSP1 <> NIL ) and ( FSP2 <> NIL ) then 
1477  2872 3  2             if FSP1 -> . FORM = FSP2 -> . FORM then 
1478  2877 3  3               case FSP1 -> . FORM of 
1479  2877 3  4                 SCALAR : 
1480  2881 3  4                   COMPTYPES := FALSE ; 
1481  2881 3  4                 SUBRANGE : 
1482  2884 3  4                   COMPTYPES := COMPTYPES ( FSP1 -> . RANGETYPE , FSP2 
1483  2892 3  5                                -> . RANGETYPE ) ; 
1484  2892 3  4                 POINTER : 
1485  2892 3  4                   begin 
1486  2895 3  5                     COMP := FALSE ; 
1487  2898 3  5                     LTESTP1 := GLOBTESTP ; 
1488  2901 3  5                     LTESTP2 := GLOBTESTP ; 
1489  2905 3  5                     while LTESTP1 <> NIL do 
1490  2908 3  6                       with LTESTP1 -> do 
1491  2908 3  7                         begin 
1492  2916 3  8                           if ( ELT1 = FSP1 -> . ELTYPE ) and ( ELT2 = 
1493  2922 3  9                           FSP2 -> . ELTYPE ) then 
1494  2922 3  9                             begin 
1495  2925 3 10                               COMP := TRUE ; 
1496  2926 3 10                               goto 1 ; 
1497  2926 3 10                             end (* then *) ; 
1498  2926 3  8                           LTESTP1 := LASTTESTP 
1499  2931 3  9                         end (* with *) ; 
1500  2934 3  5                     NEW ( LTESTP1 ) ; 
1501  2937 3  5                     with LTESTP1 -> do 
1502  2937 3  6                       begin 
1503  2943 3  7                         ELT1 := FSP1 -> . ELTYPE ; 
1504  2950 3  7                         ELT2 := FSP2 -> . ELTYPE ; 
1505  2952 3  7                         LASTTESTP := GLOBTESTP 
1506  2955 3  8                       end (* with *) ; 
1507  2958 3  5                     GLOBTESTP := LTESTP1 ; 
1508  2963 3  5                     COMP := COMPTYPES ( FSP1 -> . ELTYPE , FSP2 -> . 
1509  2968 3  6                             ELTYPE ) ; 
1510  2968 3  5                     1 : 
1511  2971 3  6                     COMPTYPES := COMP ; 
1512  2974 3  5                     GLOBTESTP := LTESTP2 ; 
1513  2975 3  5                   end (* tag/ca *) ; 
1514  2978 3  4                 POWER : COMPTYPES := COMPTYPES ( FSP1 -> . ELSET , FSP2 
1515  2986 3  5                                      -> . ELSET ) ; 
1516  2986 3  4                 ARRAYS : 
1517  2986 3  4                   begin 
1518  2991 3  5                     COMP := COMPTYPES ( FSP1 -> . AELTYPE , FSP2 -> . 
1519  2996 3  6                             AELTYPE ) and COMPTYPES ( FSP1 -> . INXTYPE 
1520  3005 3  6                             , FSP2 -> . INXTYPE ) ; 
1521  3010 3  5                     if not FSP2 -> . VARY then 
1522  3010 3  6                       begin 
1523  3014 3  7                         if FSP1 -> . VARY then 
1524  3020 3  8                           COMP := COMP and ( FSP1 -> . SIZE > FSP2 -> . 
1525  3022 3  9                                   SIZE ) 
1526  3026 3  9                         else 
1527  3032 3  8                           COMP := COMP and ( FSP1 -> . SIZE = FSP2 -> . 
1528  3037 3  9                                   SIZE ) and EQUALBOUNDS ( FSP1 -> . 
1529  3046 3  9                                   INXTYPE , FSP2 -> . INXTYPE ) ; 
1530  3046 3  7                       end (* then *) ; 
1531  3049 3  5                     COMPTYPES := COMP ; 
1532  3050 3  5                   end (* tag/ca *) ; 
1533  3050 3  4                 RECORDS : 
1534  3050 3  4                   begin 
1535  3055 3  5                     NXT1 := FSP1 -> . FSTFLD ; 
1536  3060 3  5                     NXT2 := FSP2 -> . FSTFLD ; 
1537  3063 3  5                     COMP := TRUE ; 
1538  3071 3  5                     while ( NXT1 <> NIL ) and ( NXT2 <> NIL ) do 
1539  3071 3  6                       begin 
1540  3075 3  7                         COMP := COMP and COMPTYPES ( NXT1 -> . IDTYPE , 
1541  3083 3  8                                 NXT2 -> . IDTYPE ) ; 
1542  3088 3  7                         NXT1 := NXT1 -> . NEXT ; 
1543  3090 3  7                         NXT2 := NXT2 -> . NEXT 
1544  3094 3  8                       end (* while *) ; 
1545  3100 3  5                     COMPTYPES := COMP and ( NXT1 = NIL ) and ( NXT2 = 
1546  3108 3  6                                  NIL ) and ( FSP1 -> . RECVAR = NIL ) 
1547  3114 3  6                                  and ( FSP2 -> . RECVAR = NIL ) 
1548  3118 3  6                   end (* tag/ca *) ; 
1549  3121 3  4                 FILES : COMPTYPES := COMPTYPES ( FSP1 -> . FILTYPE , 
1550  3124 3  5                                      FSP2 -> . FILTYPE ) 
1551  3133 3  5               end (* case *) 
1552  3134 3  4             else 
1553  3140 3  3               if FSP1 -> . FORM = SUBRANGE then 
1554  3144 3  4                 COMPTYPES := COMPTYPES ( FSP1 -> . RANGETYPE , FSP2 ) 
1555  3149 3  5               else 
1556  3155 3  4                 if FSP2 -> . FORM = SUBRANGE then 
1557  3159 3  5                   COMPTYPES := COMPTYPES ( FSP1 , FSP2 -> . RANGETYPE ) 
1558  3164 3  6                 else 
1559  3164 3  5                   begin 
1560  3170 3  6                     if FSP1 -> . FORM = POINTER then 
1561  3176 3  7                       if FSP1 -> . ELTYPE <> NIL then 
1562  3183 3  8                         if ( FSP1 -> . ELTYPE -> . FORM = ARRAYS ) and 
1563  3190 3  9                         ( FSP2 -> . FORM = ARRAYS ) then 
1564  3197 3  9                           if FSP1 -> . ELTYPE -> . VARY and FSP2 -> . 
1565  3200 3 10                           VARY then 
1566  3200 3 10                             begin 
1567  3203 3 11                               COMPTYPES := TRUE ; 
1568  3204 3 11                               goto 99 ; 
1569  3204 3 11                             end (* then *) ; 
1570  3204 3  6                     COMPTYPES := FALSE 
1571  3207 3  7                   end (* else *) 
1572  3208 3  6           else 
1573  3211 3  2             COMPTYPES := TRUE ; 
1574  3211 3  0         99 : 
1575  3211 3  1          
1576  3212 3  1       end (* COMPTYPES *) ; 
1577  3212 3  0  
1578  3212 3  0  
1579  3212 3  0    function ISSTRING ( FSP : STP ) : BOOLEAN ; 
1580  3212 3  0  
1581  3212 3  0       begin (* ISSTRING *) 
1582  3217 3  0         ISSTRING := FALSE ; 
1583  3221 3  0         if FSP <> NIL then 
1584  3227 3  1           if FSP -> . FORM = ARRAYS then 
1585  3233 3  2             if FSP -> . AELTYPE = CHARPTR then 
1586  3233 3  3               ISSTRING := TRUE 
1587  3237 3  4       end (* ISSTRING *) ; 
1588  3237 3  0  
1589  3237 3  0  
1590  3237 3  0    procedure TYP ( FSYS : SETOFSYS ; var FSP : STP ; var FSIZE : 
1591  3237 3  0                  ADDRRANGE ) ; 
1592  3237 3  0  
1593   -12 3  0       var LSP , LSP1 , LSP2 : STP ; 
1594   -16 3  0           OLDTOP : DISPRANGE ; 
1595   -20 3  0           LCP : CTP ; 
1596   -28 3  0           LSIZE , DISPL : ADDRRANGE ; 
1597   -36 3  0           LMIN , LMAX : INTEGER ; 
1598   -42 3  0           VALS : VALU ; 
1599   -42 3  0  
1600   -42 3  0  
1601     0 4  0       procedure SIMPLETYPE ( FSYS : SETOFSYS ; var FSP : STP ; var 
1602     0 4  0                            FSIZE : ADDRRANGE ) ; 
1603     0 4  0  
1604    -8 4  0          var LSP , LSP1 : STP ; 
1605   -16 4  0              LCP , LCP1 : CTP ; 
1606   -20 4  0              TTOP : DISPRANGE ; 
1607   -24 4  0              LCNT : INTEGER ; 
1608   -30 4  0              LVALU : VALU ; 
1609   -30 4  0  
1610  3237 4  0          begin (* SIMPLETYPE *) 
1611  3243 4  0            FSIZE := 1 ; 
1612  3249 4  0            if not ( SY in SIMPTYPEBEGSYS ) then 
1613  3249 4  1              begin 
1614  3253 4  2                ERROR ( 1 ) ; 
1615  3256 4  2                SKIP ( FSYS + SIMPTYPEBEGSYS ) 
1616  3258 4  3              end (* then *) ; 
1617  3263 4  0            if SY in SIMPTYPEBEGSYS then 
1618  3263 4  1              begin 
1619  3267 4  2                if SY = LPARENT then 
1620  3267 4  3                  begin 
1621  3270 4  4                    TTOP := TOP ; 
1622  3278 4  4                    while DISPLAY [ TOP ] . OCCUR <> BLCK do 
1623  3284 4  5                      TOP := TOP - 1 ; 
1624  3287 4  4                    NEW ( LSP , SCALAR , DECLARED ) ; 
1625  3290 4  4                    with LSP -> do 
1626  3290 4  5                      begin 
1627  3295 4  6                        SIZE := INTSIZE ; 
1628  3300 4  6                        FORM := SCALAR ; 
1629  3302 4  6                        SCALKIND := DECLARED 
1630  3305 4  7                      end (* with *) ; 
1631  3308 4  4                    LCP1 := NIL ; 
1632  3310 4  4                    LCNT := 0 ; 
1633  3310 4  4                    repeat 
1634  3312 4  5                      INSYMBOL ; 
1635  3316 4  5                      if SY = IDENT then 
1636  3316 4  6                        begin 
1637  3319 4  7                          NEW ( LCP , KONST ) ; 
1638  3322 4  7                          with LCP -> do 
1639  3322 4  8                            begin 
1640  3325 4  9                              NAME := ID ; 
1641  3330 4  9                              IDTYPE := LSP ; 
1642  3335 4  9                              NEXT := LCP1 ; 
1643  3339 4  9                              VALUES . IVAL := LCNT ; 
1644  3341 4  9                              KLASS := KONST 
1645  3344 4 10                            end (* with *) ; 
1646  3347 4  7                          ENTERID ( LCP ) ; 
1647  3351 4  7                          LCNT := LCNT + 1 ; 
1648  3354 4  7                          LCP1 := LCP ; 
1649  3354 4  7                          INSYMBOL 
1650  3356 4  8                        end (* then *) 
1651  3357 4  7                      else 
1652  3361 4  6                        ERROR ( 2 ) ; 
1653  3369 4  5                      if not ( SY in FSYS + [ COMMA , RPARENT ] ) then 
1654  3369 4  6                        begin 
1655  3373 4  7                          ERROR ( 6 ) ; 
1656  3376 4  7                          SKIP ( FSYS + [ COMMA , RPARENT ] ) 
1657  3378 4  8                        end (* then *) 
1658  3382 4  7                    until SY <> COMMA ; 
1659  3388 4  4                    LSP -> . FCONST := LCP1 ; 
1660  3391 4  4                    TOP := TTOP ; 
1661  3395 4  4                    if SY = RPARENT then 
1662  3395 4  5                      INSYMBOL 
1663  3398 4  6                    else 
1664  3400 4  5                      ERROR ( 4 ) 
1665  3402 4  6                  end (* then *) 
1666  3403 4  4                else 
1667  3403 4  3                  begin 
1668  3407 4  4                    if SY = IDENT then 
1669  3407 4  5                      begin 
1670  3411 4  6                        SEARCHID ( [ TYPES , KONST ] , LCP ) ; 
1671  3413 4  6                        INSYMBOL ; 
1672  3419 4  6                        if LCP -> . KLASS = KONST then 
1673  3419 4  7                          begin 
1674  3422 4  8                            NEW ( LSP , SUBRANGE ) ; 
1675  3428 4  8                            with LSP -> , LCP -> do 
1676  3428 4  9                              begin 
1677  3434 4 10                                RANGETYPE := IDTYPE ; 
1678  3439 4 10                                FORM := SUBRANGE ; 
1679  3444 4 10                                if ISSTRING ( RANGETYPE ) then 
1680  3444 4 11                                  begin 
1681  3448 4 12                                    ERROR ( 148 ) ; 
1682  3450 4 12                                    RANGETYPE := NIL 
1683  3453 4 13                                  end (* then *) ; 
1684  3458 4 10                                MIN := VALUES ; 
1685  3460 4 10                                SIZE := INTSIZE 
1686  3463 4 11                              end (* with *) ; 
1687  3467 4  8                            if SY = COLON then 
1688  3467 4  9                              INSYMBOL 
1689  3470 4 10                            else 
1690  3474 4  9                              ERROR ( 5 ) ; 
1691  3479 4  8                            CONSTANT ( FSYS , LSP1 , LVALU ) ; 
1692  3484 4  8                            LSP -> . MAX := LVALU ; 
1693  3490 4  8                            if LSP -> . RANGETYPE <> LSP1 then 
1694  3492 4  9                              ERROR ( 107 ) 
1695  3494 4 10                          end (* then *) 
1696  3495 4  8                        else 
1697  3495 4  7                          begin 
1698  3500 4  8                            LSP := LCP -> . IDTYPE ; 
1699  3504 4  8                            if LSP <> NIL then 
1700  3507 4  9                              FSIZE := LSP -> . SIZE 
1701  3510 4 10                          end (* else *) 
1702  3510 4  8                      end (* then *) 
1703  3511 4  6                    else 
1704  3511 4  5                      begin 
1705  3514 4  6                        NEW ( LSP , SUBRANGE ) ; 
1706  3520 4  6                        LSP -> . FORM := SUBRANGE ; 
1707  3527 4  6                        CONSTANT ( FSYS + [ COLON ] , LSP1 , LVALU ) ; 
1708  3531 4  6                        if ISSTRING ( LSP1 ) then 
1709  3531 4  7                          begin 
1710  3535 4  8                            ERROR ( 148 ) ; 
1711  3535 4  8                            LSP1 := NIL 
1712  3538 4  9                          end (* then *) ; 
1713  3541 4  6                        with LSP -> do 
1714  3541 4  7                          begin 
1715  3546 4  8                            RANGETYPE := LSP1 ; 
1716  3550 4  8                            MIN := LVALU ; 
1717  3552 4  8                            SIZE := INTSIZE 
1718  3555 4  9                          end (* with *) ; 
1719  3559 4  6                        if SY = COLON then 
1720  3559 4  7                          INSYMBOL 
1721  3562 4  8                        else 
1722  3566 4  7                          ERROR ( 5 ) ; 
1723  3571 4  6                        CONSTANT ( FSYS , LSP1 , LVALU ) ; 
1724  3576 4  6                        LSP -> . MAX := LVALU ; 
1725  3582 4  6                        if LSP -> . RANGETYPE <> LSP1 then 
1726  3584 4  7                          ERROR ( 107 ) 
1727  3586 4  8                      end (* else *) ; 
1728  3590 4  4                    if LSP <> NIL then 
1729  3593 4  5                      with LSP -> do 
1730  3598 4  6                        if FORM = SUBRANGE then 
1731  3603 4  7                          if RANGETYPE <> NIL then 
1732  3608 4  8                            if RANGETYPE = REALPTR then 
1733  3610 4  9                              ERROR ( 399 ) 
1734  3613 4 10                            else 
1735  3619 4  9                              if MIN . IVAL > MAX . IVAL then 
1736  3621 4 10                                ERROR ( 102 ) 
1737  3623 4 11                  end (* else *) ; 
1738  3627 4  2                FSP := LSP ; 
1739  3633 4  2                if not ( SY in FSYS ) then 
1740  3633 4  3                  begin 
1741  3637 4  4                    ERROR ( 6 ) ; 
1742  3638 4  4                    SKIP ( FSYS ) 
1743  3640 4  5                  end (* then *) 
1744  3640 4  4              end (* then *) 
1745  3641 4  2            else 
1746  3642 4  1              FSP := NIL 
1747  3646 4  2          end (* SIMPLETYPE *) ; 
1748  3646 4  0  
1749  3646 4  0  
1750  3646 4  0       procedure FIELDLIST ( FSYS : SETOFSYS ; var FRECVAR : STP ) ; 
1751  3646 4  0  
1752   -20 4  0          var LCP , LCP1 , NXT , NXT1 , ROOT : CTP ; 
1753   -40 4  0              LSP , LSP1 , LSP2 , LSP3 , LSP4 : STP ; 
1754   -52 4  0              MINSIZE , MAXSIZE , LSIZE : ADDRRANGE ; 
1755   -58 4  0              LVALU : VALU ; 
1756   -58 4  0  
1757  3646 4  0          begin (* FIELDLIST *) 
1758  3651 4  0            NXT1 := NIL ; 
1759  3654 4  0            LSP := NIL ; 
1760  3662 4  0            if not ( SY in ( FSYS + [ IDENT , CASESY ] ) ) then 
1761  3662 4  1              begin 
1762  3666 4  2                ERROR ( 19 ) ; 
1763  3669 4  2                SKIP ( FSYS + [ IDENT , CASESY ] ) 
1764  3671 4  3              end (* then *) ; 
1765  3675 4  0            while SY = IDENT do 
1766  3675 4  1              begin 
1767  3678 4  2                NXT := NIL ; 
1768  3681 4  2                ROOT := NIL ; 
1769  3681 4  2                repeat 
1770  3685 4  3                  if SY = IDENT then 
1771  3685 4  4                    begin 
1772  3688 4  5                      NEW ( LCP , FIELD ) ; 
1773  3691 4  5                      with LCP -> do 
1774  3691 4  6                        begin 
1775  3694 4  7                          NAME := ID ; 
1776  3699 4  7                          IDTYPE := NIL ; 
1777  3704 4  7                          NEXT := NIL ; 
1778  3706 4  7                          KLASS := FIELD 
1779  3709 4  8                        end (* with *) ; 
1780  3713 4  5                      if NXT <> NIL then 
1781  3716 4  6                        NXT -> . NEXT := LCP 
1782  3720 4  7                      else 
1783  3723 4  6                        ROOT := LCP ; 
1784  3726 4  5                      NXT := LCP ; 
1785  3729 4  5                      ENTERID ( LCP ) ; 
1786  3729 4  5                      INSYMBOL 
1787  3731 4  6                    end (* then *) 
1788  3732 4  5                  else 
1789  3736 4  4                    ERROR ( 2 ) ; 
1790  3742 4  3                  if not ( SY in [ COMMA , COLON ] ) then 
1791  3742 4  4                    begin 
1792  3746 4  5                      ERROR ( 6 ) ; 
1793  3747 4  5                      SKIP ( FSYS + [ COMMA , COLON , SEMICOLON , CASESY 
1794  3749 4  6                             ] ) 
1795  3751 4  6                    end (* then *) ; 
1796  3756 4  3                  TEST := SY <> COMMA ; 
1797  3759 4  3                  if not TEST then 
1798  3759 4  4                    INSYMBOL 
1799  3763 4  5                until TEST ; 
1800  3769 4  2                LCP -> . NEXT := NXT1 ; 
1801  3773 4  2                if SY = COLON then 
1802  3773 4  3                  INSYMBOL 
1803  3776 4  4                else 
1804  3780 4  3                  ERROR ( 5 ) ; 
1805  3787 4  2                TYP ( FSYS + [ CASESY , SEMICOLON ] , LSP , LSIZE ) ; 
1806  3790 4  2                NXT := ROOT ; 
1807  3794 4  2                while NXT <> NXT1 do 
1808  3797 4  3                  with NXT -> do 
1809  3797 4  4                    begin 
1810  3801 4  5                      ALIGN ( LSP , DISPL ) ; 
1811  3806 4  5                      IDTYPE := LSP ; 
1812  3811 4  5                      FLDADDR := DISPL ; 
1813  3816 4  5                      WRITE ( PRR , '; field ' ) ; 
1814  3819 4  5                      WRITENAME ( NAME ) ; 
1815  3833 4  5                      WRITELN ( PRR , ' disp:' , DISPL : 5 , ' size:' , 
1816  3839 4  6                                LSIZE : 3 ) ; 
1817  3843 4  5                      NXT := NEXT ; 
1818  3844 4  5                      DISPL := DISPL + LSIZE 
1819  3849 4  6                    end (* with *) ; 
1820  3852 4  2                NXT1 := ROOT ; 
1821  3856 4  2                if SY = SEMICOLON then 
1822  3856 4  3                  begin 
1823  3858 4  4                    INSYMBOL ; 
1824  3860 4  4                    if not ( SY in [ IDENT , CASESY , ENDSY , RPARENT ] 
1825  3864 4  5                    ) then 
1826  3864 4  5                      begin 
1827  3868 4  6                        ERROR ( 19 ) ; 
1828  3871 4  6                        SKIP ( FSYS + [ IDENT , CASESY ] ) 
1829  3873 4  7                      end (* then *) 
1830  3873 4  6                  end (* then *) 
1831  3874 4  4              end (* while *) ; 
1832  3877 4  0            NXT := NIL ; 
1833  3881 4  0            while NXT1 <> NIL do 
1834  3884 4  1              with NXT1 -> do 
1835  3884 4  2                begin 
1836  3888 4  3                  LCP := NEXT ; 
1837  3893 4  3                  NEXT := NXT ; 
1838  3896 4  3                  NXT := NXT1 ; 
1839  3896 4  3                  NXT1 := LCP 
1840  3900 4  4                end (* with *) ; 
1841  3904 4  0            if SY = CASESY then 
1842  3904 4  1              begin 
1843  3907 4  2                NEW ( LSP , TAGFLD ) ; 
1844  3910 4  2                with LSP -> do 
1845  3910 4  3                  begin 
1846  3915 4  4                    TAGFIELDP := NIL ; 
1847  3920 4  4                    FSTVAR := NIL ; 
1848  3922 4  4                    FORM := TAGFLD 
1849  3925 4  5                  end (* with *) ; 
1850  3929 4  2                FRECVAR := LSP ; 
1851  3931 4  2                INSYMBOL ; 
1852  3935 4  2                if SY = IDENT then 
1853  3935 4  3                  begin 
1854  3938 4  4                    PRTERR := FALSE ; 
1855  3942 4  4                    SEARCHID ( [ TYPES ] , LCP1 ) ; 
1856  3945 4  4                    PRTERR := TRUE ; 
1857  3949 4  4                    if LCP1 <> NIL then 
1858  3949 4  5                      begin 
1859  3954 4  6                        LSP1 := LCP1 -> . IDTYPE ; 
1860  3958 4  6                        if LSP1 <> NIL then 
1861  3963 4  7                          if ( LSP1 -> . FORM <= SUBRANGE ) or ISSTRING 
1862  3968 4  8                          ( LSP1 ) then 
1863  3968 4  8                            begin 
1864  3972 4  9                              if REALPTR = LSP1 then 
1865  3974 4 10                                ERROR ( 109 ) 
1866  3977 4 11                              else 
1867  3981 4 10                                if ISSTRING ( LSP1 ) then 
1868  3985 4 11                                  ERROR ( 399 ) ; 
1869  3991 4  9                              LSP -> . TAGFIELDP := LSP1 ; 
1870  3991 4  9                            end (* then *) 
1871  3992 4  9                          else 
1872  3996 4  8                            ERROR ( 110 ) ; 
1873  3998 4  6                        INSYMBOL ; 
1874  3998 4  6                      end (* then *) 
1875  3999 4  6                    else 
1876  3999 4  5                      begin 
1877  4002 4  6                        NEW ( LCP , FIELD ) ; 
1878  4005 4  6                        with LCP -> do 
1879  4005 4  7                          begin 
1880  4008 4  8                            NAME := ID ; 
1881  4013 4  8                            IDTYPE := NIL ; 
1882  4018 4  8                            KLASS := FIELD ; 
1883  4023 4  8                            NEXT := NIL ; 
1884  4025 4  8                            FLDADDR := DISPL 
1885  4028 4  9                          end (* with *) ; 
1886  4031 4  6                        ENTERID ( LCP ) ; 
1887  4033 4  6                        INSYMBOL ; 
1888  4037 4  6                        if SY = COLON then 
1889  4037 4  7                          INSYMBOL 
1890  4040 4  8                        else 
1891  4044 4  7                          ERROR ( 5 ) ; 
1892  4048 4  6                        if SY = IDENT then 
1893  4048 4  7                          begin 
1894  4052 4  8                            SEARCHID ( [ TYPES ] , LCP1 ) ; 
1895  4057 4  8                            LSP1 := LCP1 -> . IDTYPE ; 
1896  4061 4  8                            if LSP1 <> NIL then 
1897  4061 4  9                              begin 
1898  4065 4 10                                ALIGN ( LSP1 , DISPL ) ; 
1899  4071 4 10                                LCP -> . FLDADDR := DISPL ; 
1900  4076 4 10                                WRITE ( PRR , '; field ' ) ; 
1901  4080 4 10                                WRITENAME ( LCP -> . NAME ) ; 
1902  4089 4 10                                WRITELN ( PRR , ' disp:' , DISPL : 5 , 
1903  4100 4 11                                          ' size:' , LSIZE : 3 ) ; 
1904  4107 4 10                                DISPL := DISPL + LSP1 -> . SIZE ; 
1905  4112 4 10                                if ( LSP1 -> . FORM <= SUBRANGE ) or 
1906  4117 4 11                                ISSTRING ( LSP1 ) then 
1907  4117 4 11                                  begin 
1908  4121 4 12                                    if REALPTR = LSP1 then 
1909  4123 4 13                                      ERROR ( 109 ) 
1910  4126 4 14                                    else 
1911  4130 4 13                                      if ISSTRING ( LSP1 ) then 
1912  4134 4 14                                        ERROR ( 399 ) ; 
1913  4140 4 12                                    LCP -> . IDTYPE := LSP1 ; 
1914  4146 4 12                                    LSP -> . TAGFIELDP := LSP1 ; 
1915  4146 4 12                                  end (* then *) 
1916  4147 4 12                                else 
1917  4151 4 11                                  ERROR ( 110 ) ; 
1918  4151 4 10                              end (* then *) ; 
1919  4153 4  8                            INSYMBOL ; 
1920  4153 4  8                          end (* then *) 
1921  4154 4  8                        else 
1922  4154 4  7                          begin 
1923  4158 4  8                            ERROR ( 2 ) ; 
1924  4163 4  8                            SKIP ( FSYS + [ OFSY , LPARENT ] ) ; 
1925  4163 4  8                          end (* else *) ; 
1926  4163 4  6                      end (* else *) ; 
1927  4163 4  4                  end (* then *) 
1928  4164 4  4                else 
1929  4164 4  3                  begin 
1930  4168 4  4                    ERROR ( 2 ) ; 
1931  4171 4  4                    SKIP ( FSYS + [ OFSY , LPARENT ] ) 
1932  4173 4  5                  end (* else *) ; 
1933  4179 4  2                LSP -> . SIZE := DISPL ; 
1934  4183 4  2                if SY = OFSY then 
1935  4183 4  3                  INSYMBOL 
1936  4186 4  4                else 
1937  4190 4  3                  ERROR ( 8 ) ; 
1938  4193 4  2                LSP1 := NIL ; 
1939  4196 4  2                MINSIZE := DISPL ; 
1940  4199 4  2                MAXSIZE := DISPL ; 
1941  4199 4  2                repeat 
1942  4202 4  3                  LSP2 := NIL ; 
1943  4208 4  3                  if not ( SY in [ SEMICOLON , ENDSY ] ) then 
1944  4208 4  4                    begin 
1945  4208 4  5                      repeat 
1946  4211 4  6                        CONSTANT ( FSYS + [ COMMA , COLON , LPARENT ] , 
1947  4215 4  7                                   LSP3 , LVALU ) ; 
1948  4221 4  6                        if LSP -> . TAGFIELDP <> NIL then 
1949  4225 4  7                          if not COMPTYPES ( LSP -> . TAGFIELDP , LSP3 ) 
1950  4229 4  8                          then 
1951  4233 4  8                            ERROR ( 111 ) ; 
1952  4236 4  6                        NEW ( LSP3 , VARIANT ) ; 
1953  4239 4  6                        with LSP3 -> do 
1954  4239 4  7                          begin 
1955  4244 4  8                            NXTVAR := LSP1 ; 
1956  4249 4  8                            SUBVAR := LSP2 ; 
1957  4253 4  8                            VARVAL := LVALU ; 
1958  4255 4  8                            FORM := VARIANT 
1959  4258 4  9                          end (* with *) ; 
1960  4261 4  6                        LSP4 := LSP1 ; 
1961  4265 4  6                        while LSP4 <> NIL do 
1962  4268 4  7                          with LSP4 -> do 
1963  4268 4  8                            begin 
1964  4273 4  9                              if VARVAL . IVAL = LVALU . IVAL then 
1965  4277 4 10                                ERROR ( 178 ) ; 
1966  4277 4  9                              LSP4 := NXTVAR 
1967  4282 4 10                            end (* with *) ; 
1968  4285 4  6                        LSP1 := LSP3 ; 
1969  4288 4  6                        LSP2 := LSP3 ; 
1970  4293 4  6                        TEST := SY <> COMMA ; 
1971  4296 4  6                        if not TEST then 
1972  4296 4  7                          INSYMBOL 
1973  4300 4  8                      until TEST ; 
1974  4304 4  5                      if SY = COLON then 
1975  4304 4  6                        INSYMBOL 
1976  4307 4  7                      else 
1977  4311 4  6                        ERROR ( 5 ) ; 
1978  4315 4  5                      if SY = LPARENT then 
1979  4315 4  6                        INSYMBOL 
1980  4318 4  7                      else 
1981  4322 4  6                        ERROR ( 9 ) ; 
1982  4325 4  5                      FIELDLIST ( FSYS + [ RPARENT , SEMICOLON ] , LSP2 
1983  4328 4  6                                  ) ; 
1984  4332 4  5                      if DISPL > MAXSIZE then 
1985  4335 4  6                        MAXSIZE := DISPL ; 
1986  4339 4  5                      while LSP3 <> NIL do 
1987  4339 4  6                        begin 
1988  4344 4  7                          LSP4 := LSP3 -> . SUBVAR ; 
1989  4350 4  7                          LSP3 -> . SUBVAR := LSP2 ; 
1990  4356 4  7                          LSP3 -> . SIZE := DISPL ; 
1991  4356 4  7                          LSP3 := LSP4 
1992  4360 4  8                        end (* while *) ; 
1993  4364 4  5                      if SY = RPARENT then 
1994  4364 4  6                        begin 
1995  4366 4  7                          INSYMBOL ; 
1996  4374 4  7                          if not ( SY in FSYS + [ SEMICOLON ] ) then 
1997  4374 4  8                            begin 
1998  4378 4  9                              ERROR ( 6 ) ; 
1999  4381 4  9                              SKIP ( FSYS + [ SEMICOLON ] ) 
2000  4383 4 10                            end (* then *) 
2001  4383 4  9                        end (* then *) 
2002  4384 4  7                      else 
2003  4388 4  6                        ERROR ( 4 ) ; 
2004  4388 4  5                    end (* then *) ; 
2005  4393 4  3                  TEST := SY <> SEMICOLON ; 
2006  4396 4  3                  if not TEST then 
2007  4396 4  4                    begin 
2008  4399 4  5                      DISPL := MINSIZE ; 
2009  4399 4  5                      INSYMBOL 
2010  4401 4  6                    end (* then *) 
2011  4403 4  5                until TEST ; 
2012  4406 4  2                DISPL := MAXSIZE ; 
2013  4412 4  2                LSP -> . FSTVAR := LSP1 ; 
2014  4412 4  2              end (* then *) 
2015  4413 4  2            else 
2016  4414 4  1              FRECVAR := NIL 
2017  4418 4  2          end (* FIELDLIST *) ; 
2018  4418 4  0  
2019  4418 4  0  
2020  4418 3  0       begin (* TYP *) 
2021  4426 3  0         if not ( SY in TYPEBEGSYS ) then 
2022  4426 3  1           begin 
2023  4430 3  2             ERROR ( 10 ) ; 
2024  4433 3  2             SKIP ( FSYS + TYPEBEGSYS ) 
2025  4435 3  3           end (* then *) ; 
2026  4440 3  0         if SY in TYPEBEGSYS then 
2027  4440 3  1           begin 
2028  4445 3  2             if SY in SIMPTYPEBEGSYS then 
2029  4448 3  3               SIMPLETYPE ( FSYS , FSP , FSIZE ) 
2030  4451 3  4             else 
2031  4455 3  3               if SY = ARROW then 
2032  4455 3  4                 begin 
2033  4458 3  5                   NEW ( LSP , POINTER ) ; 
2034  4462 3  5                   FSP := LSP ; 
2035  4465 3  5                   with LSP -> do 
2036  4465 3  6                     begin 
2037  4470 3  7                       ELTYPE := NIL ; 
2038  4475 3  7                       SIZE := PTRSIZE ; 
2039  4477 3  7                       FORM := POINTER 
2040  4480 3  8                     end (* with *) ; 
2041  4482 3  5                   INSYMBOL ; 
2042  4486 3  5                   if SY = IDENT then 
2043  4486 3  6                     begin 
2044  4489 3  7                       PRTERR := FALSE ; 
2045  4493 3  7                       SEARCHID ( [ TYPES ] , LCP ) ; 
2046  4496 3  7                       PRTERR := TRUE ; 
2047  4500 3  7                       if LCP = NIL then 
2048  4500 3  8                         begin 
2049  4503 3  9                           NEW ( LCP , TYPES ) ; 
2050  4506 3  9                           with LCP -> do 
2051  4506 3 10                             begin 
2052  4509 3 11                               NAME := ID ; 
2053  4514 3 11                               IDTYPE := LSP ; 
2054  4519 3 11                               NEXT := FWPTR ; 
2055  4521 3 11                               KLASS := TYPES 
2056  4524 3 12                             end (* with *) ; 
2057  4524 3  9                           FWPTR := LCP 
2058  4527 3 10                         end (* then *) 
2059  4528 3  9                       else 
2060  4528 3  8                         begin 
2061  4534 3  9                           if LCP -> . IDTYPE <> NIL then 
2062  4542 3 10                             if LCP -> . IDTYPE -> . FORM = FILES then 
2063  4544 3 11                               ERROR ( 108 ) 
2064  4547 3 12                             else 
2065  4552 3 11                               LSP -> . ELTYPE := LCP -> . IDTYPE 
2066  4555 3 12                         end (* else *) ; 
2067  4557 3  7                       INSYMBOL ; 
2068  4557 3  7                     end (* then *) 
2069  4558 3  7                   else 
2070  4562 3  6                     ERROR ( 2 ) ; 
2071  4562 3  5                 end (* then *) 
2072  4563 3  5               else 
2073  4563 3  4                 begin 
2074  4567 3  5                   if SY = PACKEDSY then 
2075  4567 3  6                     begin 
2076  4569 3  7                       INSYMBOL ; 
2077  4575 3  7                       if not ( SY in TYPEDELS ) then 
2078  4575 3  8                         begin 
2079  4579 3  9                           ERROR ( 10 ) ; 
2080  4582 3  9                           SKIP ( FSYS + TYPEDELS ) 
2081  4584 3 10                         end (* then *) 
2082  4584 3  9                     end (* then *) ; 
2083  4588 3  5                   if SY = STRINGSY then 
2084  4588 3  6                     begin 
2085  4590 3  7                       INSYMBOL ; 
2086  4594 3  7                       if SY = LBRACK then 
2087  4594 3  8                         INSYMBOL 
2088  4597 3  9                       else 
2089  4601 3  8                         ERROR ( 11 ) ; 
2090  4604 3  7                       NEW ( LSP , ARRAYS ) ; 
2091  4607 3  7                       with LSP -> do 
2092  4607 3  8                         begin 
2093  4612 3  9                           AELTYPE := CHARPTR ; 
2094  4617 3  9                           INXTYPE := NIL ; 
2095  4622 3  9                           FORM := ARRAYS ; 
2096  4627 3  9                           VARY := TRUE ; 
2097  4627 3  9                         end (* with *) ; 
2098  4634 3  7                       CONSTANT ( FSYS + [ RBRACK ] , LSP1 , VALS ) ; 
2099  4638 3  7                       if LSP1 = INTPTR then 
2100  4638 3  8                         begin 
2101  4642 3  9                           LSIZE := SUCC ( VALS . IVAL ) ; 
2102  4648 3  9                           LSP -> . SIZE := LSIZE ; 
2103  4651 3  9                           NEW ( LSP1 , SUBRANGE ) ; 
2104  4654 3  9                           with LSP1 -> do 
2105  4654 3 10                             begin 
2106  4659 3 11                               SIZE := INTSIZE ; 
2107  4664 3 11                               FORM := SUBRANGE ; 
2108  4669 3 11                               RANGETYPE := INTPTR ; 
2109  4673 3 11                               MIN . IVAL := 1 ; 
2110  4677 3 11                               MAX . IVAL := LSIZE ; 
2111  4677 3 11                             end (* with *) ; 
2112  4677 3  9                         end (* then *) 
2113  4678 3  9                       else 
2114  4678 3  8                         begin 
2115  4682 3  9                           ERROR ( 106 ) ; 
2116  4682 3  9                           LSP1 := NIL 
2117  4685 3 10                         end (* else *) ; 
2118  4691 3  7                       LSP -> . INXTYPE := LSP1 ; 
2119  4695 3  7                       if SY = RBRACK then 
2120  4695 3  8                         INSYMBOL 
2121  4698 3  9                       else 
2122  4702 3  8                         ERROR ( 12 ) ; 
2123  4702 3  7                     end (* then *) 
2124  4703 3  7                   else 
2125  4707 3  6                     if SY = ARRAYSY then 
2126  4707 3  7                       begin 
2127  4709 3  8                         INSYMBOL ; 
2128  4713 3  8                         if SY = LBRACK then 
2129  4713 3  9                           INSYMBOL 
2130  4716 3 10                         else 
2131  4720 3  9                           ERROR ( 11 ) ; 
2132  4723 3  8                         LSP1 := NIL ; 
2133  4723 3  8                         repeat 
2134  4726 3  9                           NEW ( LSP , ARRAYS ) ; 
2135  4729 3  9                           with LSP -> do 
2136  4729 3 10                             begin 
2137  4734 3 11                               AELTYPE := LSP1 ; 
2138  4739 3 11                               INXTYPE := NIL ; 
2139  4744 3 11                               FORM := ARRAYS ; 
2140  4749 3 11                               VARY := FALSE ; 
2141  4749 3 11                             end (* with *) ; 
2142  4752 3  9                           LSP1 := LSP ; 
2143  4753 3  9                           SIMPLETYPE ( FSYS + [ COMMA , RBRACK , OFSY ] 
2144  4759 3 10                                        , LSP2 , LSIZE ) ; 
2145  4765 3  9                           LSP1 -> . SIZE := LSIZE ; 
2146  4769 3  9                           if LSP2 <> NIL then 
2147  4775 3 10                             if LSP2 -> . FORM <= SUBRANGE then 
2148  4775 3 11                               begin 
2149  4779 3 12                                 if LSP2 = REALPTR then 
2150  4779 3 13                                   begin 
2151  4783 3 14                                     ERROR ( 109 ) ; 
2152  4783 3 14                                     LSP2 := NIL 
2153  4786 3 15                                   end (* then *) 
2154  4787 3 14                                 else 
2155  4791 3 13                                   if LSP2 = INTPTR then 
2156  4791 3 14                                     begin 
2157  4795 3 15                                       ERROR ( 149 ) ; 
2158  4795 3 15                                       LSP2 := NIL 
2159  4798 3 16                                     end (* then *) ; 
2160  4801 3 12                                 LSP -> . INXTYPE := LSP2 
2161  4804 3 13                               end (* then *) 
2162  4805 3 12                             else 
2163  4805 3 11                               begin 
2164  4809 3 12                                 ERROR ( 113 ) ; 
2165  4809 3 12                                 LSP2 := NIL 
2166  4812 3 13                               end (* else *) ; 
2167  4817 3  9                           TEST := SY <> COMMA ; 
2168  4820 3  9                           if not TEST then 
2169  4820 3 10                             INSYMBOL 
2170  4824 3 11                         until TEST ; 
2171  4828 3  8                         if SY = RBRACK then 
2172  4828 3  9                           INSYMBOL 
2173  4831 3 10                         else 
2174  4835 3  9                           ERROR ( 12 ) ; 
2175  4839 3  8                         if SY = OFSY then 
2176  4839 3  9                           INSYMBOL 
2177  4842 3 10                         else 
2178  4846 3  9                           ERROR ( 8 ) ; 
2179  4851 3  8                         TYP ( FSYS , LSP , LSIZE ) ; 
2180  4851 3  8                         repeat 
2181  4854 3  9                           with LSP1 -> do 
2182  4854 3 10                             begin 
2183  4858 3 11                               LSP2 := AELTYPE ; 
2184  4863 3 11                               AELTYPE := LSP ; 
2185  4868 3 11                               if INXTYPE <> NIL then 
2186  4868 3 12                                 begin 
2187  4874 3 13                                   GETBOUNDS ( INXTYPE , LMIN , LMAX ) ; 
2188  4878 3 13                                   ALIGN ( LSP , LSIZE ) ; 
2189  4884 3 13                                   LSIZE := LSIZE * ( LMAX - LMIN + 1 ) 
2190  4887 3 14                                            ; 
2191  4889 3 13                                   SIZE := LSIZE 
2192  4892 3 14                                 end (* then *) 
2193  4892 3 13                             end (* with *) ; 
2194  4895 3  9                           LSP := LSP1 ; 
2195  4895 3  9                           LSP1 := LSP2 
2196  4899 3 10                         until LSP1 = NIL 
2197  4902 3  9                       end (* then *) 
2198  4903 3  8                     else 
2199  4907 3  7                       if SY = RECORDSY then 
2200  4907 3  8                         begin 
2201  4909 3  9                           INSYMBOL ; 
2202  4912 3  9                           OLDTOP := TOP ; 
2203  4916 3  9                           if TOP < DISPLIMIT then 
2204  4916 3 10                             begin 
2205  4921 3 11                               TOP := TOP + 1 ; 
2206  4926 3 11                               with DISPLAY [ TOP ] do 
2207  4926 3 12                                 begin 
2208  4930 3 13                                   FNAME := NIL ; 
2209  4935 3 13                                   FLABEL := NIL ; 
2210  4937 3 13                                   OCCUR := REC 
2211  4940 3 14                                 end (* with *) 
2212  4940 3 13                             end (* then *) 
2213  4941 3 11                           else 
2214  4945 3 10                             ERROR ( 250 ) ; 
2215  4948 3  9                           DISPL := 0 ; 
2216  4951 3  9                           FIELDLIST ( FSYS - [ SEMICOLON ] + [ ENDSY ] 
2217  4956 3 10                                       , LSP1 ) ; 
2218  4959 3  9                           NEW ( LSP , RECORDS ) ; 
2219  4962 3  9                           with LSP -> do 
2220  4962 3 10                             begin 
2221  4971 3 11                               FSTFLD := DISPLAY [ TOP ] . FNAME ; 
2222  4976 3 11                               RECVAR := LSP1 ; 
2223  4981 3 11                               SIZE := DISPL ; 
2224  4983 3 11                               FORM := RECORDS 
2225  4986 3 12                             end (* with *) ; 
2226  4989 3  9                           TOP := OLDTOP ; 
2227  4993 3  9                           if SY = ENDSY then 
2228  4993 3 10                             INSYMBOL 
2229  4996 3 11                           else 
2230  4998 3 10                             ERROR ( 13 ) 
2231  5000 3 11                         end (* then *) 
2232  5001 3  9                       else 
2233  5005 3  8                         if SY = SETSY then 
2234  5005 3  9                           begin 
2235  5007 3 10                             INSYMBOL ; 
2236  5011 3 10                             if SY = OFSY then 
2237  5011 3 11                               INSYMBOL 
2238  5014 3 12                             else 
2239  5018 3 11                               ERROR ( 8 ) ; 
2240  5023 3 10                             SIMPLETYPE ( FSYS , LSP1 , LSIZE ) ; 
2241  5027 3 10                             if LSP1 <> NIL then 
2242  5033 3 11                               if LSP1 -> . FORM > SUBRANGE then 
2243  5033 3 12                                 begin 
2244  5037 3 13                                   ERROR ( 115 ) ; 
2245  5037 3 13                                   LSP1 := NIL 
2246  5040 3 14                                 end (* then *) 
2247  5041 3 13                               else 
2248  5045 3 12                                 if LSP1 = REALPTR then 
2249  5049 3 13                                   ERROR ( 114 ) ; 
2250  5052 3 10                             NEW ( LSP , POWER ) ; 
2251  5055 3 10                             with LSP -> do 
2252  5055 3 11                               begin 
2253  5060 3 12                                 ELSET := LSP1 ; 
2254  5065 3 12                                 SIZE := SETSIZE ; 
2255  5067 3 12                                 FORM := POWER 
2256  5070 3 13                               end (* with *) ; 
2257  5070 3 10                           end (* then *) 
2258  5071 3 10                         else 
2259  5075 3  9                           if SY = FILESY then 
2260  5075 3 10                             begin 
2261  5077 3 11                               INSYMBOL ; 
2262  5081 3 11                               if SY = OFSY then 
2263  5081 3 12                                 INSYMBOL 
2264  5084 3 13                               else 
2265  5088 3 12                                 ERROR ( 8 ) ; 
2266  5091 3 11                               NEW ( LSP , FILES ) ; 
2267  5096 3 11                               TYP ( FSYS , LSP1 , LSIZE ) ; 
2268  5099 3 11                               with LSP -> do 
2269  5099 3 12                                 begin 
2270  5104 3 13                                   FORM := FILES ; 
2271  5109 3 13                                   FILTYPE := LSP1 ; 
2272  5116 3 13                                   SIZE := LSIZE + FCBSIZE ; 
2273  5116 3 13                                 end (* with *) ; 
2274  5116 3 11                             end (* then *) ; 
2275  5117 3  5                   FSP := LSP 
2276  5120 3  6                 end (* else *) ; 
2277  5126 3  2             if not ( SY in FSYS ) then 
2278  5126 3  3               begin 
2279  5130 3  4                 ERROR ( 6 ) ; 
2280  5131 3  4                 SKIP ( FSYS ) 
2281  5133 3  5               end (* then *) 
2282  5133 3  4           end (* then *) 
2283  5134 3  2         else 
2284  5138 3  1           FSP := NIL ; 
2285  5143 3  0         if FSP = NIL then 
2286  5144 3  1           FSIZE := 1 
2287  5148 3  2         else 
2288  5152 3  1           FSIZE := FSP -> . SIZE 
2289  5156 3  2       end (* TYP *) ; 
2290  5156 3  0  
2291  5156 3  0  
2292  5156 3  0    procedure LABELDECLARATION ; 
2293  5156 3  0  
2294    -4 3  0       var LLP : LBP ; 
2295    -5 3  0           REDEF : BOOLEAN ; 
2296   -10 3  0           LBNAME : INTEGER ; 
2297   -10 3  0  
2298  5156 3  0       begin (* LABELDECLARATION *) 
2299  5158 3  0         repeat 
2300  5162 3  1           if SY = INTCONST then 
2301  5167 3  2             with DISPLAY [ TOP ] do 
2302  5167 3  3               begin 
2303  5171 3  4                 LLP := FLABEL ; 
2304  5174 3  4                 REDEF := FALSE ; 
2305  5181 3  4                 while ( LLP <> NIL ) and not REDEF do 
2306  5187 3  5                   if LLP -> . LABVAL <> VAL . IVAL then 
2307  5189 3  6                     LLP := LLP -> . NEXTLAB 
2308  5193 3  7                   else 
2309  5193 3  6                     begin 
2310  5196 3  7                       REDEF := TRUE ; 
2311  5198 3  7                       ERROR ( 166 ) 
2312  5201 3  8                     end (* else *) ; 
2313  5204 3  4                 if not REDEF then 
2314  5204 3  5                   begin 
2315  5207 3  6                     NEW ( LLP ) ; 
2316  5210 3  6                     with LLP -> do 
2317  5210 3  7                       begin 
2318  5214 3  8                         LABVAL := VAL . IVAL ; 
2319  5217 3  8                         GENLABEL ( LBNAME ) ; 
2320  5222 3  8                         DEFINED := FALSE ; 
2321  5227 3  8                         NEXTLAB := FLABEL ; 
2322  5229 3  8                         LABNAME := LBNAME 
2323  5231 3  9                       end (* with *) ; 
2324  5233 3  6                     FLABEL := LLP 
2325  5236 3  7                   end (* then *) ; 
2326  5236 3  4                 INSYMBOL 
2327  5238 3  5               end (* with *) 
2328  5239 3  4           else 
2329  5243 3  2             ERROR ( 15 ) ; 
2330  5251 3  1           if not ( SY in FSYS + [ COMMA , SEMICOLON ] ) then 
2331  5251 3  2             begin 
2332  5255 3  3               ERROR ( 6 ) ; 
2333  5258 3  3               SKIP ( FSYS + [ COMMA , SEMICOLON ] ) 
2334  5260 3  4             end (* then *) ; 
2335  5265 3  1           TEST := SY <> COMMA ; 
2336  5268 3  1           if not TEST then 
2337  5268 3  2             INSYMBOL 
2338  5272 3  3         until TEST ; 
2339  5276 3  0         if SY = SEMICOLON then 
2340  5276 3  1           INSYMBOL 
2341  5279 3  2         else 
2342  5281 3  1           ERROR ( 14 ) 
2343  5284 3  2       end (* LABELDECLARATION *) ; 
2344  5284 3  0  
2345  5284 3  0  
2346  5284 3  0    procedure CONSTDECLARATION ; 
2347  5284 3  0  
2348    -4 3  0       var LCP : CTP ; 
2349    -8 3  0           LSP : STP ; 
2350   -14 3  0           LVALU : VALU ; 
2351   -14 3  0  
2352  5284 3  0       begin (* CONSTDECLARATION *) 
2353  5290 3  0         if SY <> IDENT then 
2354  5290 3  1           begin 
2355  5294 3  2             ERROR ( 2 ) ; 
2356  5297 3  2             SKIP ( FSYS + [ IDENT ] ) 
2357  5299 3  3           end (* then *) ; 
2358  5303 3  0         while SY = IDENT do 
2359  5303 3  1           begin 
2360  5306 3  2             NEW ( LCP , KONST ) ; 
2361  5309 3  2             with LCP -> do 
2362  5309 3  3               begin 
2363  5312 3  4                 NAME := ID ; 
2364  5317 3  4                 IDTYPE := NIL ; 
2365  5322 3  4                 NEXT := NIL ; 
2366  5324 3  4                 KLASS := KONST 
2367  5327 3  5               end (* with *) ; 
2368  5329 3  2             INSYMBOL ; 
2369  5337 3  2             if ( SY = RELOP ) and ( OP = EQOP ) then 
2370  5337 3  3               INSYMBOL 
2371  5340 3  4             else 
2372  5344 3  3               ERROR ( 16 ) ; 
2373  5351 3  2             CONSTANT ( FSYS + [ SEMICOLON ] , LSP , LVALU ) ; 
2374  5354 3  2             ENTERID ( LCP ) ; 
2375  5360 3  2             LCP -> . IDTYPE := LSP ; 
2376  5365 3  2             LCP -> . VALUES := LVALU ; 
2377  5369 3  2             if SY = SEMICOLON then 
2378  5369 3  3               begin 
2379  5371 3  4                 INSYMBOL ; 
2380  5379 3  4                 if not ( SY in FSYS + [ IDENT ] ) then 
2381  5379 3  5                   begin 
2382  5383 3  6                     ERROR ( 6 ) ; 
2383  5386 3  6                     SKIP ( FSYS + [ IDENT ] ) 
2384  5388 3  7                   end (* then *) 
2385  5388 3  6               end (* then *) 
2386  5389 3  4             else 
2387  5391 3  3               ERROR ( 14 ) 
2388  5393 3  4           end (* while *) 
2389  5395 3  2       end (* CONSTDECLARATION *) ; 
2390  5395 3  0  
2391  5395 3  0  
2392  5395 3  0    procedure TYPEDECLARATION ; 
2393  5395 3  0  
2394   -12 3  0       var LCP , LCP1 , LCP2 : CTP ; 
2395   -16 3  0           LSP : STP ; 
2396   -20 3  0           LSIZE : ADDRRANGE ; 
2397   -20 3  0  
2398  5395 3  0       begin (* TYPEDECLARATION *) 
2399  5401 3  0         if SY <> IDENT then 
2400  5401 3  1           begin 
2401  5405 3  2             ERROR ( 2 ) ; 
2402  5408 3  2             SKIP ( FSYS + [ IDENT ] ) 
2403  5410 3  3           end (* then *) ; 
2404  5414 3  0         while SY = IDENT do 
2405  5414 3  1           begin 
2406  5417 3  2             NEW ( LCP , TYPES ) ; 
2407  5420 3  2             with LCP -> do 
2408  5420 3  3               begin 
2409  5423 3  4                 NAME := ID ; 
2410  5428 3  4                 IDTYPE := NIL ; 
2411  5430 3  4                 KLASS := TYPES 
2412  5433 3  5               end (* with *) ; 
2413  5435 3  2             INSYMBOL ; 
2414  5443 3  2             if ( SY = RELOP ) and ( OP = EQOP ) then 
2415  5443 3  3               INSYMBOL 
2416  5446 3  4             else 
2417  5450 3  3               ERROR ( 16 ) ; 
2418  5457 3  2             TYP ( FSYS + [ SEMICOLON ] , LSP , LSIZE ) ; 
2419  5460 3  2             ENTERID ( LCP ) ; 
2420  5466 3  2             LCP -> . IDTYPE := LSP ; 
2421  5469 3  2             LCP1 := FWPTR ; 
2422  5473 3  2             while LCP1 <> NIL do 
2423  5473 3  3               begin 
2424  5479 3  4                 if LCP1 -> . NAME = LCP -> . NAME then 
2425  5479 3  5                   begin 
2426  5489 3  6                     LCP1 -> . IDTYPE -> . ELTYPE := LCP -> . IDTYPE ; 
2427  5493 3  6                     if LCP1 <> FWPTR then 
2428  5498 3  7                       LCP2 -> . NEXT := LCP1 -> . NEXT 
2429  5502 3  8                     else 
2430  5507 3  7                       FWPTR := LCP1 -> . NEXT ; 
2431  5507 3  6                   end (* then *) ; 
2432  5510 3  4                 LCP2 := LCP1 ; 
2433  5512 3  4                 LCP1 := LCP1 -> . NEXT 
2434  5516 3  5               end (* while *) ; 
2435  5520 3  2             if SY = SEMICOLON then 
2436  5520 3  3               begin 
2437  5522 3  4                 INSYMBOL ; 
2438  5530 3  4                 if not ( SY in FSYS + [ IDENT ] ) then 
2439  5530 3  5                   begin 
2440  5534 3  6                     ERROR ( 6 ) ; 
2441  5537 3  6                     SKIP ( FSYS + [ IDENT ] ) 
2442  5539 3  7                   end (* then *) 
2443  5539 3  6               end (* then *) 
2444  5540 3  4             else 
2445  5542 3  3               ERROR ( 14 ) 
2446  5545 3  4           end (* while *) ; 
2447  5549 3  0         if FWPTR <> NIL then 
2448  5549 3  1           begin 
2449  5553 3  2             ERROR ( 117 ) ; 
2450  5555 3  2             WRITELN ( OUTPUT ) ; 
2451  5555 3  2             repeat 
2452  5568 3  3               WRITELN ( OUTPUT , ' TYPE-ID ' , FWPTR -> . NAME ) ; 
2453  5570 3  3               FWPTR := FWPTR -> . NEXT 
2454  5577 3  4             until FWPTR = NIL ; 
2455  5580 3  2             if not EOL then 
2456  5586 3  3               WRITE ( OUTPUT , ' ' : CHCNT + 16 ) 
2457  5586 3  4           end (* then *) 
2458  5587 3  2       end (* TYPEDECLARATION *) ; 
2459  5587 3  0  
2460  5587 3  0  
2461  5587 3  0    procedure VARDECLARATION ; 
2462  5587 3  0  
2463   -16 3  0       var LCP , BFR , ROOT , FCP : CTP ; 
2464   -20 3  0           LSP : STP ; 
2465   -24 3  0           LSIZE : ADDRRANGE ; 
2466   -30 3  0           VALS : VALU ; 
2467   -34 3  0           XNAME : CSP ; 
2468   -34 3  0  
2469  5587 3  0       begin (* VARDECLARATION *) 
2470  5592 3  0         ROOT := NIL ; 
2471  5595 3  0         BFR := NIL ; 
2472  5595 3  0         repeat 
2473  5595 3  1           repeat 
2474  5599 3  2             if SY = IDENT then 
2475  5599 3  3               begin 
2476  5602 3  4                 NEW ( LCP , VARS ) ; 
2477  5605 3  4                 with LCP -> do 
2478  5605 3  5                   begin 
2479  5609 3  6                     if BFR <> NIL then 
2480  5612 3  7                       BFR -> . NEXT := LCP 
2481  5616 3  8                     else 
2482  5619 3  7                       ROOT := LCP ; 
2483  5622 3  6                     NAME := ID ; 
2484  5627 3  6                     NEXT := NIL ; 
2485  5632 3  6                     KLASS := VARS ; 
2486  5637 3  6                     IDTYPE := NIL ; 
2487  5642 3  6                     VKIND := ACTUAL ; 
2488  5647 3  6                     VLEV := LEVEL ; 
2489  5652 3  6                     VXNAME := NIL ; 
2490  5657 3  6                     VIMPORT := FALSE ; 
2491  5657 3  6                   end (* with *) ; 
2492  5660 3  4                 BFR := LCP ; 
2493  5663 3  4                 ENTERID ( LCP ) ; 
2494  5665 3  4                 INSYMBOL ; 
2495  5665 3  4               end (* then *) 
2496  5666 3  4             else 
2497  5670 3  3               ERROR ( 2 ) ; 
2498  5680 3  2             if not ( SY in FSYS + [ COMMA , COLON ] + TYPEDELS ) then 
2499  5680 3  3               begin 
2500  5684 3  4                 ERROR ( 6 ) ; 
2501  5687 3  4                 SKIP ( FSYS + [ COMMA , COLON , SEMICOLON ] + TYPEDELS 
2502  5689 3  5                        ) 
2503  5691 3  5               end (* then *) ; 
2504  5696 3  2             TEST := SY <> COMMA ; 
2505  5699 3  2             if not TEST then 
2506  5699 3  3               INSYMBOL 
2507  5703 3  4           until TEST ; 
2508  5707 3  1           if SY = COLON then 
2509  5707 3  2             INSYMBOL 
2510  5710 3  3           else 
2511  5714 3  2             ERROR ( 5 ) ; 
2512  5719 3  1           TYP ( FSYS + [ SEMICOLON , IMPORTSY , EXPORTSY ] + TYPEDELS , 
2513  5723 3  2                 LSP , LSIZE ) ; 
2514  5729 3  1           if LSP -> . FORM = FILES then 
2515  5733 3  2             if LEVEL > 1 then 
2516  5735 3  3               ERROR ( 399 ) 
2517  5738 3  4             else 
2518  5738 3  3               begin 
2519  5742 3  4                 if FILECP = NIL then 
2520  5742 3  5                   FILECP := LCP 
2521  5746 3  6                 else 
2522  5746 3  5                   begin 
2523  5749 3  6                     FCP := FILECP ; 
2524  5755 3  6                     while FCP -> . NEXT <> NIL do 
2525  5761 3  7                       FCP := FCP -> . NEXT ; 
2526  5767 3  6                     FCP -> . NEXT := LCP ; 
2527  5767 3  6                   end (* else *) ; 
2528  5767 3  4               end (* else *) ; 
2529  5770 3  1           BFR := ROOT ; 
2530  5774 3  1           while BFR <> NIL do 
2531  5777 3  2             with BFR -> do 
2532  5777 3  3               begin 
2533  5782 3  4                 IDTYPE := LSP ; 
2534  5786 3  4                 if ( SY = IMPORTSY ) then 
2535  5788 3  5                   VADDR := 0 
2536  5792 3  6                 else 
2537  5792 3  5                   begin 
2538  5796 3  6                     if FPROCP = NIL then 
2539  5796 3  7                       begin 
2540  5800 3  8                         ALIGN ( LSP , LC ) ; 
2541  5805 3  8                         VADDR := LC ; 
2542  5810 3  8                         LC := LC + LSIZE ; 
2543  5810 3  8                       end (* then *) 
2544  5811 3  8                     else 
2545  5811 3  7                       begin 
2546  5816 3  8                         LC := LC - LSIZE ; 
2547  5820 3  8                         ALIGN ( LSP , LC ) ; 
2548  5825 3  8                         VADDR := LC ; 
2549  5825 3  8                       end (* else *) ; 
2550  5830 3  6                     WRITE ( PRR , '; var   ' ) ; 
2551  5833 3  6                     WRITENAME ( NAME ) ; 
2552  5848 3  6                     WRITELN ( PRR , ' addr:' , VADDR : 5 , ' size:' , 
2553  5854 3  7                               LSIZE : 3 ) ; 
2554  5854 3  6                   end (* else *) ; 
2555  5858 3  4                 BFR := NEXT ; 
2556  5859 3  4               end (* with *) ; 
2557  5863 3  1           if SY = IMPORTSY then 
2558  5863 3  2             begin 
2559  5865 3  3               INSYMBOL ; 
2560  5868 3  3               XNAME := NIL ; 
2561  5872 3  3               if SY = LPARENT then 
2562  5872 3  4                 begin 
2563  5875 3  5                   EXPECTSTRING := TRUE ; 
2564  5877 3  5                   INSYMBOL ; 
2565  5884 3  5                   CONSTANT ( FSYS + [ RPARENT ] , LSP , VALS ) ; 
2566  5887 3  5                   EXPECTSTRING := FALSE ; 
2567  5891 3  5                   if LSP <> NIL then 
2568  5897 3  6                     if LSP -> . FORM = ARRAYS then 
2569  5897 3  7                       XNAME := VALS . VALP 
2570  5901 3  8                     else 
2571  5903 3  7                       ERROR ( 23 ) 
2572  5906 3  8                   else 
2573  5910 3  6                     ERROR ( 22 ) ; 
2574  5914 3  5                   if SY = RPARENT then 
2575  5914 3  6                     INSYMBOL 
2576  5917 3  7                   else 
2577  5921 3  6                     ERROR ( 4 ) ; 
2578  5921 3  5                 end (* then *) ; 
2579  5924 3  3               BFR := ROOT ; 
2580  5928 3  3               while BFR <> NIL do 
2581  5931 3  4                 with BFR -> do 
2582  5931 3  5                   begin 
2583  5936 3  6                     VIMPORT := TRUE ; 
2584  5941 3  6                     VXNAME := XNAME ; 
2585  5946 3  6                     VKIND := FORMAL ; 
2586  5950 3  6                     BFR := NEXT ; 
2587  5951 3  6                   end (* with *) ; 
2588  5951 3  3             end (* then *) 
2589  5952 3  3           else 
2590  5956 3  2             if SY = EXPORTSY then 
2591  5956 3  3               begin 
2592  5959 3  4                 BFR := ROOT ; 
2593  5963 3  4                 if LEVEL > 1 then 
2594  5963 3  5                   begin 
2595  5966 3  6                     BFR := NIL ; 
2596  5970 3  6                     ERROR ( 399 ) ; 
2597  5970 3  6                   end (* then *) ; 
2598  5974 3  4                 while BFR <> NIL do 
2599  5977 3  5                   with BFR -> do 
2600  5977 3  6                     begin 
2601  5981 3  7                       WRITE ( PRR , '@' ) ; 
2602  5984 3  7                       WRITENAME ( NAME ) ; 
2603  6001 3  7                       WRITELN ( PRR , '= ' , VADDR : 1 , '#GLOBAL' ) ; 
2604  6005 3  7                       BFR := NEXT ; 
2605  6006 3  7                     end (* with *) ; 
2606  6008 3  4                 INSYMBOL ; 
2607  6008 3  4               end (* then *) ; 
2608  6012 3  1           if SY = SEMICOLON then 
2609  6012 3  2             begin 
2610  6014 3  3               INSYMBOL ; 
2611  6022 3  3               if not ( SY in FSYS + [ IDENT ] ) then 
2612  6022 3  4                 begin 
2613  6026 3  5                   ERROR ( 6 ) ; 
2614  6029 3  5                   SKIP ( FSYS + [ IDENT ] ) 
2615  6031 3  6                 end (* then *) 
2616  6031 3  5             end (* then *) 
2617  6032 3  3           else 
2618  6034 3  2             ERROR ( 14 ) 
2619  6046 3  3         until ( SY <> IDENT ) and not ( SY in TYPEDELS ) ; 
2620  6050 3  0         if FWPTR <> NIL then 
2621  6050 3  1           begin 
2622  6054 3  2             ERROR ( 117 ) ; 
2623  6056 3  2             WRITELN ( OUTPUT ) ; 
2624  6056 3  2             repeat 
2625  6069 3  3               WRITELN ( OUTPUT , ' TYPE-ID ' , FWPTR -> . NAME ) ; 
2626  6071 3  3               FWPTR := FWPTR -> . NEXT 
2627  6078 3  4             until FWPTR = NIL ; 
2628  6078 3  2           end (* then *) 
2629  6079 3  2       end (* VARDECLARATION *) ; 
2630  6079 3  0  
2631  6079 3  0  
2632  6079 3  0    procedure PROCDECLARATION ( FSY : SYMBOL ) ; 
2633  6079 3  0  
2634     0 3  0       type P_TO_INT = -> INTEGER ; 
2635     0 3  0  
2636    -8 3  0       var OLD_MIN_LEVEL , OLDLEV : 0 .. MAXLEVEL ; 
2637   -12 3  0           LSY : SYMBOL ; 
2638   -20 3  0           LCP , LCP1 : CTP ; 
2639   -24 3  0           LSP : STP ; 
2640   -25 3  0           FORW : BOOLEAN ; 
2641   -30 3  0           OLDTOP : DISPRANGE ; 
2642   -38 3  0           PARM_COUNT , FRESSIZE : INTEGER ; 
2643   -46 3  0           LLC , LCM : ADDRRANGE ; 
2644   -50 3  0           LBNAME : INTEGER ; 
2645   -54 3  0           MARKP : -> INTEGER ; 
2646   -60 3  0           VALS : VALU ; 
2647   -60 3  0  
2648   -60 3  0  
2649     0 4  0       procedure MARK ( PTR : P_TO_INT ) ; 
2650     0 4  0  
2651  6079 4  0          begin (* MARK *) 
2652  6079 4  0             
2653  6082 4  0          end (* MARK *) ; 
2654  6082 4  0  
2655  6082 4  0  
2656  6082 4  0       procedure RELEASE ( PTR : P_TO_INT ) ; 
2657  6082 4  0  
2658  6082 4  0          begin (* RELEASE *) 
2659  6082 4  0             
2660  6085 4  0          end (* RELEASE *) ; 
2661  6085 4  0  
2662  6085 4  0  
2663  6085 4  0       procedure PARAMETERLIST ( FSY : SETOFSYS ; var FPAR : CTP ) ; 
2664  6085 4  0  
2665   -16 4  0          var LCP , LCP1 , LCP2 , LCP3 : CTP ; 
2666   -20 4  0              LSP : STP ; 
2667   -24 4  0              LKIND : IDKIND ; 
2668   -28 4  0              LLC : ADDRRANGE ; 
2669   -36 4  0              COUNT , LSIZE : INTEGER ; 
2670   -36 4  0  
2671  6085 4  0          begin (* PARAMETERLIST *) 
2672  6090 4  0            LCP1 := NIL ; 
2673  6092 4  0            PARM_COUNT := 0 ; 
2674  6100 4  0            if not ( SY in FSY + [ LPARENT ] ) then 
2675  6100 4  1              begin 
2676  6104 4  2                ERROR ( 7 ) ; 
2677  6109 4  2                SKIP ( FSYS + FSY + [ LPARENT ] ) 
2678  6111 4  3              end (* then *) ; 
2679  6115 4  0            if SY = LPARENT then 
2680  6115 4  1              begin 
2681  6117 4  2                if FORW then 
2682  6121 4  3                  ERROR ( 119 ) ; 
2683  6123 4  2                INSYMBOL ; 
2684  6127 4  2                if not ( SY in [ IDENT , VARSY , PROCSY , FUNCSY ] ) 
2685  6129 4  3                then 
2686  6129 4  3                  begin 
2687  6133 4  4                    ERROR ( 7 ) ; 
2688  6136 4  4                    SKIP ( FSYS + [ IDENT , RPARENT ] ) 
2689  6138 4  5                  end (* then *) ; 
2690  6143 4  2                while SY in [ IDENT , VARSY , PROCSY , FUNCSY ] do 
2691  6143 4  3                  begin 
2692  6147 4  4                    if SY = PROCSY then 
2693  6147 4  5                      begin 
2694  6151 4  6                        ERROR ( 399 ) ; 
2695  6151 4  6                        repeat 
2696  6153 4  7                          INSYMBOL ; 
2697  6157 4  7                          if SY = IDENT then 
2698  6157 4  8                            begin 
2699  6160 4  9                              NEW ( LCP , PROC , DECLARED , FORMAL ) ; 
2700  6163 4  9                              with LCP -> do 
2701  6163 4 10                                begin 
2702  6166 4 11                                  NAME := ID ; 
2703  6171 4 11                                  IDTYPE := NIL ; 
2704  6176 4 11                                  NEXT := LCP1 ; 
2705  6181 4 11                                  PFLEV := LEVEL ; 
2706  6186 4 11                                  KLASS := PROC ; 
2707  6191 4 11                                  PFDECKIND := DECLARED ; 
2708  6193 4 11                                  PFKIND := FORMAL 
2709  6196 4 12                                end (* with *) ; 
2710  6199 4  9                              ENTERID ( LCP ) ; 
2711  6202 4  9                              LCP1 := LCP ; 
2712  6206 4  9                              ALIGN ( PARMPTR , LC ) ; 
2713  6206 4  9                              INSYMBOL 
2714  6208 4 10                            end (* then *) 
2715  6209 4  9                          else 
2716  6213 4  8                            ERROR ( 2 ) ; 
2717  6216 4  7                          if not ( SY in FSYS + [ COMMA , SEMICOLON , 
2718  6221 4  8                          RPARENT ] ) then 
2719  6221 4  8                            begin 
2720  6225 4  9                              ERROR ( 7 ) ; 
2721  6226 4  9                              SKIP ( FSYS + [ COMMA , SEMICOLON , 
2722  6228 4 10                                     RPARENT ] ) 
2723  6230 4 10                            end (* then *) 
2724  6231 4  9                        until SY <> COMMA 
2725  6234 4  7                      end (* then *) 
2726  6235 4  6                    else 
2727  6235 4  5                      begin 
2728  6239 4  6                        if SY = FUNCSY then 
2729  6239 4  7                          begin 
2730  6243 4  8                            ERROR ( 399 ) ; 
2731  6246 4  8                            LCP2 := NIL ; 
2732  6246 4  8                            repeat 
2733  6248 4  9                              INSYMBOL ; 
2734  6252 4  9                              if SY = IDENT then 
2735  6252 4 10                                begin 
2736  6255 4 11                                  NEW ( LCP , FUNC , DECLARED , FORMAL ) 
2737  6255 4 12                                        ; 
2738  6258 4 11                                  with LCP -> do 
2739  6258 4 12                                    begin 
2740  6261 4 13                                      NAME := ID ; 
2741  6266 4 13                                      IDTYPE := NIL ; 
2742  6271 4 13                                      NEXT := LCP2 ; 
2743  6276 4 13                                      PFLEV := LEVEL ; 
2744  6281 4 13                                      KLASS := FUNC ; 
2745  6286 4 13                                      PFDECKIND := DECLARED ; 
2746  6288 4 13                                      PFKIND := FORMAL 
2747  6291 4 14                                    end (* with *) ; 
2748  6294 4 11                                  ENTERID ( LCP ) ; 
2749  6297 4 11                                  LCP2 := LCP ; 
2750  6301 4 11                                  ALIGN ( PARMPTR , LC ) ; 
2751  6303 4 11                                  INSYMBOL ; 
2752  6303 4 11                                end (* then *) ; 
2753  6309 4  9                              if not ( SY in [ COMMA , COLON ] + FSYS ) 
2754  6311 4 10                              then 
2755  6311 4 10                                begin 
2756  6315 4 11                                  ERROR ( 7 ) ; 
2757  6316 4 11                                  SKIP ( FSYS + [ COMMA , SEMICOLON , 
2758  6318 4 12                                         RPARENT ] ) 
2759  6320 4 12                                end (* then *) 
2760  6324 4 11                            until SY <> COMMA ; 
2761  6328 4  8                            if SY = COLON then 
2762  6328 4  9                              begin 
2763  6330 4 10                                INSYMBOL ; 
2764  6334 4 10                                if SY = IDENT then 
2765  6334 4 11                                  begin 
2766  6338 4 12                                    SEARCHID ( [ TYPES ] , LCP ) ; 
2767  6343 4 12                                    LSP := LCP -> . IDTYPE ; 
2768  6347 4 12                                    if LSP <> NIL then 
2769  6351 4 13                                      if not ( LSP -> . FORM in [ SCALAR 
2770  6355 4 14                                      , SUBRANGE , POINTER ] ) then 
2771  6355 4 14                                        begin 
2772  6359 4 15                                          ERROR ( 120 ) ; 
2773  6359 4 15                                          LSP := NIL 
2774  6362 4 16                                        end (* then *) ; 
2775  6365 4 12                                    LCP3 := LCP2 ; 
2776  6369 4 12                                    while LCP2 <> NIL do 
2777  6369 4 13                                      begin 
2778  6375 4 14                                        LCP2 -> . IDTYPE := LSP ; 
2779  6378 4 14                                        LCP := LCP2 ; 
2780  6380 4 14                                        LCP2 := LCP2 -> . NEXT 
2781  6384 4 15                                      end (* while *) ; 
2782  6390 4 12                                    LCP -> . NEXT := LCP1 ; 
2783  6393 4 12                                    LCP1 := LCP3 ; 
2784  6393 4 12                                    INSYMBOL 
2785  6395 4 13                                  end (* then *) 
2786  6396 4 12                                else 
2787  6400 4 11                                  ERROR ( 2 ) ; 
2788  6403 4 10                                if not ( SY in FSYS + [ SEMICOLON , 
2789  6408 4 11                                RPARENT ] ) then 
2790  6408 4 11                                  begin 
2791  6412 4 12                                    ERROR ( 7 ) ; 
2792  6413 4 12                                    SKIP ( FSYS + [ SEMICOLON , RPARENT 
2793  6415 4 13                                           ] ) 
2794  6417 4 13                                  end (* then *) 
2795  6417 4 12                              end (* then *) 
2796  6418 4 10                            else 
2797  6420 4  9                              ERROR ( 5 ) 
2798  6422 4 10                          end (* then *) 
2799  6423 4  8                        else 
2800  6423 4  7                          begin 
2801  6427 4  8                            if SY = VARSY then 
2802  6427 4  9                              begin 
2803  6430 4 10                                LKIND := FORMAL ; 
2804  6430 4 10                                INSYMBOL 
2805  6432 4 11                              end (* then *) 
2806  6433 4 10                            else 
2807  6436 4  9                              LKIND := ACTUAL ; 
2808  6439 4  8                            LCP2 := NIL ; 
2809  6441 4  8                            COUNT := 0 ; 
2810  6441 4  8                            repeat 
2811  6445 4  9                              if SY = IDENT then 
2812  6445 4 10                                begin 
2813  6448 4 11                                  NEW ( LCP , VARS ) ; 
2814  6451 4 11                                  with LCP -> do 
2815  6451 4 12                                    begin 
2816  6454 4 13                                      NAME := ID ; 
2817  6459 4 13                                      IDTYPE := NIL ; 
2818  6464 4 13                                      KLASS := VARS ; 
2819  6469 4 13                                      VKIND := LKIND ; 
2820  6474 4 13                                      NEXT := LCP2 ; 
2821  6479 4 13                                      VLEV := LEVEL ; 
2822  6484 4 13                                      VXNAME := NIL ; 
2823  6489 4 13                                      VIMPORT := FALSE ; 
2824  6489 4 13                                    end (* with *) ; 
2825  6492 4 11                                  ENTERID ( LCP ) ; 
2826  6495 4 11                                  LCP2 := LCP ; 
2827  6499 4 11                                  COUNT := COUNT + 1 ; 
2828  6501 4 11                                  INSYMBOL ; 
2829  6501 4 11                                end (* then *) ; 
2830  6507 4  9                              if not ( SY in [ COMMA , COLON ] + FSYS ) 
2831  6509 4 10                              then 
2832  6509 4 10                                begin 
2833  6513 4 11                                  ERROR ( 7 ) ; 
2834  6514 4 11                                  SKIP ( FSYS + [ COMMA , SEMICOLON , 
2835  6516 4 12                                         RPARENT ] ) 
2836  6518 4 12                                end (* then *) ; 
2837  6523 4  9                              TEST := SY <> COMMA ; 
2838  6526 4  9                              if not TEST then 
2839  6526 4 10                                INSYMBOL 
2840  6530 4 11                            until TEST ; 
2841  6534 4  8                            if SY = COLON then 
2842  6534 4  9                              begin 
2843  6536 4 10                                INSYMBOL ; 
2844  6540 4 10                                if SY = IDENT then 
2845  6540 4 11                                  begin 
2846  6544 4 12                                    SEARCHID ( [ TYPES ] , LCP ) ; 
2847  6549 4 12                                    LSP := LCP -> . IDTYPE ; 
2848  6551 4 12                                    LSIZE := PTRSIZE ; 
2849  6555 4 12                                    if LSP <> NIL then 
2850  6559 4 13                                      if LKIND = ACTUAL then 
2851  6565 4 14                                        if LSP -> . FORM = FILES then 
2852  6569 4 15                                          ERROR ( 121 ) ; 
2853  6572 4 12                                    LCP3 := LCP2 ; 
2854  6576 4 12                                    while LCP2 <> NIL do 
2855  6576 4 13                                      begin 
2856  6579 4 14                                        LCP := LCP2 ; 
2857  6582 4 14                                        with LCP2 -> do 
2858  6582 4 15                                          begin 
2859  6582 4 16                                            PARM_COUNT := SUCC ( 
2860  6585 4 17                                                    PARM_COUNT ) ; 
2861  6590 4 16                                            IDTYPE := LSP ; 
2862  6590 4 16                                          end (* with *) ; 
2863  6592 4 14                                        LCP2 := LCP2 -> . NEXT 
2864  6596 4 15                                      end (* while *) ; 
2865  6602 4 12                                    LCP -> . NEXT := LCP1 ; 
2866  6605 4 12                                    LCP1 := LCP3 ; 
2867  6605 4 12                                    INSYMBOL 
2868  6607 4 13                                  end (* then *) 
2869  6608 4 12                                else 
2870  6612 4 11                                  ERROR ( 2 ) ; 
2871  6615 4 10                                if not ( SY in FSYS + [ SEMICOLON , 
2872  6620 4 11                                RPARENT ] ) then 
2873  6620 4 11                                  begin 
2874  6624 4 12                                    ERROR ( 7 ) ; 
2875  6625 4 12                                    SKIP ( FSYS + [ SEMICOLON , RPARENT 
2876  6627 4 13                                           ] ) 
2877  6629 4 13                                  end (* then *) 
2878  6629 4 12                              end (* then *) 
2879  6630 4 10                            else 
2880  6634 4  9                              ERROR ( 5 ) ; 
2881  6634 4  8                          end (* else *) ; 
2882  6634 4  6                      end (* else *) ; 
2883  6638 4  4                    if SY = SEMICOLON then 
2884  6638 4  5                      begin 
2885  6640 4  6                        INSYMBOL ; 
2886  6643 4  6                        if not ( SY in FSYS + [ IDENT , VARSY , PROCSY , 
2887  6648 4  7                        FUNCSY ] ) then 
2888  6648 4  7                          begin 
2889  6652 4  8                            ERROR ( 7 ) ; 
2890  6655 4  8                            SKIP ( FSYS + [ IDENT , RPARENT ] ) 
2891  6657 4  9                          end (* then *) 
2892  6657 4  8                      end (* then *) 
2893  6658 4  6                  end (* while *) ; 
2894  6662 4  2                if SY = RPARENT then 
2895  6662 4  3                  begin 
2896  6664 4  4                    INSYMBOL ; 
2897  6672 4  4                    if not ( SY in FSY + FSYS ) then 
2898  6672 4  5                      begin 
2899  6676 4  6                        ERROR ( 6 ) ; 
2900  6679 4  6                        SKIP ( FSY + FSYS ) 
2901  6681 4  7                      end (* then *) 
2902  6681 4  6                  end (* then *) 
2903  6682 4  4                else 
2904  6686 4  3                  ERROR ( 4 ) ; 
2905  6689 4  2                LCP3 := NIL ; 
2906  6692 4  2                LLC := LCBEFOREMARKSTACK ; 
2907  6696 4  2                while LCP1 <> NIL do 
2908  6699 4  3                  with LCP1 -> do 
2909  6699 4  4                    begin 
2910  6703 4  5                      LCP2 := NEXT ; 
2911  6708 4  5                      NEXT := LCP3 ; 
2912  6712 4  5                      ALIGN ( PARMPTR , LLC ) ; 
2913  6717 4  5                      if KLASS = VARS then 
2914  6722 4  6                        if IDTYPE <> NIL then 
2915  6730 4  7                          if ( VKIND = ACTUAL ) and ( IDTYPE -> . FORM > 
2916  6734 4  8                          POWER ) then 
2917  6734 4  8                            begin 
2918  6742 4  9                              LC := LC - IDTYPE -> . SIZE ; 
2919  6747 4  9                              ALIGN ( IDTYPE , LC ) ; 
2920  6752 4  9                              VADDR := LC ; 
2921  6752 4  9                            end (* then *) 
2922  6753 4  9                          else 
2923  6759 4  8                            if ( VKIND = ACTUAL ) and ( ( IDTYPE = 
2924  6768 4  9                            BOOLPTR ) or ( IDTYPE = CHARPTR ) ) then 
2925  6771 4  9                              VADDR := LLC + 3 
2926  6776 4 10                            else 
2927  6778 4  9                              VADDR := LLC 
2928  6782 4 10                        else 
2929  6787 4  7                          VADDR := LLC ; 
2930  6794 4  5                      if IDTYPE -> . FORM = POWER then 
2931  6794 4  6                        begin 
2932  6799 4  7                          LLC := LLC + SETSIZE ; 
2933  6801 4  7                          PARM_COUNT := PRED ( PARM_COUNT ) + SETSIZE 
2934  6806 4  8                                        DIV PARMSIZE ; 
2935  6806 4  7                        end (* then *) 
2936  6807 4  7                      else 
2937  6812 4  6                        LLC := LLC + PTRSIZE ; 
2938  6817 4  5                      WRITE ( PRR , '; parm: ' ) ; 
2939  6820 4  5                      WRITENAME ( NAME ) ; 
2940  6832 4  5                      WRITELN ( PRR , ' addr: ' , VADDR : 5 ) ; 
2941  6835 4  5                      LCP3 := LCP1 ; 
2942  6835 4  5                      LCP1 := LCP2 
2943  6839 4  6                    end (* with *) ; 
2944  6840 4  2                FPAR := LCP3 
2945  6843 4  3              end (* then *) 
2946  6844 4  2            else 
2947  6845 4  1              FPAR := NIL 
2948  6849 4  2          end (* PARAMETERLIST *) ; 
2949  6849 4  0  
2950  6849 4  0  
2951  6849 3  0       begin (* PROCDECLARATION *) 
2952  6854 3  0         LLC := LC ; 
2953  6857 3  0         LC := LCAFTERMARKSTACK ; 
2954  6860 3  0         FORW := FALSE ; 
2955  6864 3  0         if SY = IDENT then 
2956  6864 3  1           begin 
2957  6872 3  2             SEARCHSECTION ( DISPLAY [ TOP ] . FNAME , LCP ) ; 
2958  6876 3  2             if LCP <> NIL then 
2959  6876 3  3               begin 
2960  6882 3  4                 if LCP -> . KLASS = PROC then 
2961  6889 3  5                   FORW := LCP -> . FORWDECL and ( FSY = PROCSY ) and ( 
2962  6894 3  6                           LCP -> . PFKIND = ACTUAL ) 
2963  6898 3  6                 else 
2964  6904 3  5                   if LCP -> . KLASS = FUNC then 
2965  6911 3  6                     FORW := LCP -> . FORWDECL and ( FSY = FUNCSY ) and 
2966  6916 3  7                             ( LCP -> . PFKIND = ACTUAL ) 
2967  6920 3  7                   else 
2968  6923 3  6                     FORW := FALSE ; 
2969  6926 3  4                 if not FORW then 
2970  6928 3  5                   ERROR ( 160 ) 
2971  6930 3  6               end (* then *) ; 
2972  6933 3  2             if not FORW then 
2973  6933 3  3               begin 
2974  6937 3  4                 if FSY = PROCSY then 
2975  6940 3  5                   NEW ( LCP , PROC , DECLARED , ACTUAL ) 
2976  6941 3  6                 else 
2977  6944 3  5                   NEW ( LCP , FUNC , DECLARED , ACTUAL ) ; 
2978  6947 3  4                 with LCP -> do 
2979  6947 3  5                   begin 
2980  6950 3  6                     NAME := ID ; 
2981  6955 3  6                     IDTYPE := NIL ; 
2982  6960 3  6                     PFXNAME := NIL ; 
2983  6965 3  6                     PF_ATTR := INTERN ; 
2984  6970 3  6                     PFLEV := LEVEL ; 
2985  6973 3  6                     GENLABEL ( LBNAME ) ; 
2986  6978 3  6                     PFDECKIND := DECLARED ; 
2987  6983 3  6                     PFKIND := ACTUAL ; 
2988  6987 3  6                     PFNAME := LBNAME ; 
2989  6991 3  6                     NUMB_OF_PARM := 0 ; 
2990  6995 3  6                     if FSY = PROCSY then 
2991  6997 3  7                       KLASS := PROC 
2992  7001 3  8                     else 
2993  7003 3  7                       KLASS := FUNC 
2994  7006 3  8                   end (* with *) ; 
2995  7007 3  4                 ENTERID ( LCP ) 
2996  7009 3  5               end (* then *) 
2997  7010 3  4             else 
2998  7010 3  3               begin 
2999  7015 3  4                 LCP1 := LCP -> . NEXT ; 
3000  7019 3  4                 while LCP1 <> NIL do 
3001  7019 3  5                   begin 
3002  7022 3  6                     with LCP1 -> do 
3003  7027 3  7                       if KLASS = VARS then 
3004  7032 3  8                         if IDTYPE <> NIL then 
3005  7032 3  9                           begin 
3006  7036 3 10                             LCM := VADDR ; 
3007  7040 3 10                             if LCM < LC then 
3008  7040 3 11                               LC := LCM 
3009  7043 3 12                           end (* then *) ; 
3010  7045 3  6                     LCP1 := LCP1 -> . NEXT 
3011  7048 3  7                   end (* while *) 
3012  7049 3  6               end (* else *) ; 
3013  7049 3  2             INSYMBOL 
3014  7051 3  3           end (* then *) 
3015  7052 3  2         else 
3016  7052 3  1           begin 
3017  7056 3  2             ERROR ( 2 ) ; 
3018  7056 3  2             LCP := UFCTPTR 
3019  7059 3  3           end (* else *) ; 
3020  7062 3  0         OLDLEV := LEVEL ; 
3021  7065 3  0         OLDTOP := TOP ; 
3022  7069 3  0         if LEVEL < MAXLEVEL then 
3023  7070 3  1           LEVEL := LEVEL + 1 
3024  7075 3  2         else 
3025  7079 3  1           ERROR ( 251 ) ; 
3026  7082 3  0         OLD_MIN_LEVEL := MIN_LEVEL ; 
3027  7086 3  0         if TOP < DISPLIMIT then 
3028  7086 3  1           begin 
3029  7091 3  2             TOP := TOP + 1 ; 
3030  7096 3  2             with DISPLAY [ TOP ] do 
3031  7096 3  3               begin 
3032  7098 3  4                 if FORW then 
3033  7101 3  5                   FNAME := LCP -> . NEXT 
3034  7105 3  6                 else 
3035  7109 3  5                   FNAME := NIL ; 
3036  7114 3  4                 FLABEL := NIL ; 
3037  7116 3  4                 OCCUR := BLCK 
3038  7119 3  5               end (* with *) 
3039  7119 3  4           end (* then *) 
3040  7120 3  2         else 
3041  7124 3  1           ERROR ( 250 ) ; 
3042  7128 3  0         if FSY = PROCSY then 
3043  7128 3  1           begin 
3044  7132 3  2             PARAMETERLIST ( [ SEMICOLON ] , LCP1 ) ; 
3045  7135 3  2             if not FORW then 
3046  7135 3  3               begin 
3047  7141 3  4                 LCP -> . NEXT := LCP1 ; 
3048  7146 3  4                 LCP -> . NUMB_OF_PARM := PARM_COUNT ; 
3049  7146 3  4               end (* then *) ; 
3050  7146 3  2           end (* then *) 
3051  7147 3  2         else 
3052  7147 3  1           begin 
3053  7151 3  2             PARAMETERLIST ( [ SEMICOLON , COLON ] , LCP1 ) ; 
3054  7154 3  2             if not FORW then 
3055  7154 3  3               begin 
3056  7160 3  4                 LCP -> . NEXT := LCP1 ; 
3057  7165 3  4                 LCP -> . NUMB_OF_PARM := PARM_COUNT ; 
3058  7165 3  4               end (* then *) ; 
3059  7170 3  2             GENLABEL ( LCP -> . RESULT_LABEL ) ; 
3060  7174 3  2             if SY = COLON then 
3061  7174 3  3               begin 
3062  7176 3  4                 INSYMBOL ; 
3063  7180 3  4                 if SY = IDENT then 
3064  7180 3  5                   begin 
3065  7182 3  6                     if FORW then 
3066  7186 3  7                       ERROR ( 122 ) ; 
3067  7190 3  6                     SEARCHID ( [ TYPES ] , LCP1 ) ; 
3068  7195 3  6                     LSP := LCP1 -> . IDTYPE ; 
3069  7201 3  6                     LCP -> . IDTYPE := LSP ; 
3070  7205 3  6                     if LSP <> NIL then 
3071  7211 3  7                       if LSP -> . FORM >= POWER then 
3072  7211 3  8                         begin 
3073  7215 3  9                           ERROR ( 120 ) ; 
3074  7218 3  9                           LCP -> . IDTYPE := NIL 
3075  7221 3 10                         end (* then *) ; 
3076  7221 3  6                     INSYMBOL 
3077  7223 3  7                   end (* then *) 
3078  7224 3  6                 else 
3079  7224 3  5                   begin 
3080  7228 3  6                     ERROR ( 2 ) ; 
3081  7231 3  6                     SKIP ( FSYS + [ SEMICOLON ] ) 
3082  7233 3  7                   end (* else *) 
3083  7233 3  6               end (* then *) 
3084  7234 3  4             else 
3085  7237 3  3               if not FORW then 
3086  7239 3  4                 ERROR ( 123 ) 
3087  7241 3  5           end (* else *) ; 
3088  7245 3  0         if SY = SEMICOLON then 
3089  7245 3  1           INSYMBOL 
3090  7248 3  2         else 
3091  7252 3  1           ERROR ( 14 ) ; 
3092  7256 3  0         if SY = IMPORTSY then 
3093  7256 3  1           begin 
3094  7262 3  2             LCP -> . PF_ATTR := IMPRT ; 
3095  7264 3  2             INSYMBOL ; 
3096  7268 3  2             if SY = LPARENT then 
3097  7268 3  3               begin 
3098  7271 3  4                 EXPECTSTRING := TRUE ; 
3099  7273 3  4                 INSYMBOL ; 
3100  7280 3  4                 CONSTANT ( FSYS + [ RPARENT ] , LSP , VALS ) ; 
3101  7283 3  4                 EXPECTSTRING := FALSE ; 
3102  7287 3  4                 if LSP <> NIL then 
3103  7293 3  5                   if LSP -> . FORM = ARRAYS then 
3104  7296 3  6                     LCP -> . PFXNAME := VALS . VALP 
3105  7300 3  7                   else 
3106  7302 3  6                     ERROR ( 23 ) 
3107  7305 3  7                 else 
3108  7309 3  5                   ERROR ( 22 ) ; 
3109  7313 3  4                 if SY = RPARENT then 
3110  7313 3  5                   INSYMBOL 
3111  7316 3  6                 else 
3112  7320 3  5                   ERROR ( 4 ) ; 
3113  7320 3  4               end (* then *) ; 
3114  7324 3  2             if SY = SEMICOLON then 
3115  7324 3  3               INSYMBOL 
3116  7327 3  4             else 
3117  7331 3  3               ERROR ( 14 ) ; 
3118  7337 3  2             if not ( SY in FSYS ) then 
3119  7337 3  3               begin 
3120  7341 3  4                 ERROR ( 6 ) ; 
3121  7344 3  4                 SKIP ( FSYS ) ; 
3122  7344 3  4               end (* then *) ; 
3123  7344 3  2           end (* then *) 
3124  7345 3  2         else 
3125  7345 3  1           begin 
3126  7349 3  2             if SY = FORWARDSY then 
3127  7349 3  3               begin 
3128  7351 3  4                 if FORW then 
3129  7353 3  5                   ERROR ( 161 ) 
3130  7356 3  6                 else 
3131  7362 3  5                   LCP -> . FORWDECL := TRUE ; 
3132  7364 3  4                 INSYMBOL ; 
3133  7368 3  4                 if SY = SEMICOLON then 
3134  7368 3  5                   INSYMBOL 
3135  7371 3  6                 else 
3136  7375 3  5                   ERROR ( 14 ) ; 
3137  7381 3  4                 if not ( SY in FSYS ) then 
3138  7381 3  5                   begin 
3139  7385 3  6                     ERROR ( 6 ) ; 
3140  7386 3  6                     SKIP ( FSYS ) 
3141  7388 3  7                   end (* then *) 
3142  7388 3  6               end (* then *) 
3143  7389 3  4             else 
3144  7389 3  3               begin 
3145  7395 3  4                 LCP -> . FORWDECL := FALSE ; 
3146  7398 3  4                 MARK ( MARKP ) ; 
3147  7400 3  4                 if PRCODE then 
3148  7400 3  5                   begin 
3149  7405 3  6                     WRITE ( PRR , '; PROC ' ) ; 
3150  7409 3  6                     WRITENAME ( LCP -> . NAME ) ; 
3151  7411 3  6                     WRITELN ( PRR ) ; 
3152  7411 3  6                   end (* then *) ; 
3153  7411 3  4                 repeat 
3154  7418 3  5                   BLOCK ( FSYS , SEMICOLON , LCP ) ; 
3155  7422 3  5                   if SY = SEMICOLON then 
3156  7422 3  6                     begin 
3157  7424 3  7                       INSYMBOL ; 
3158  7428 3  7                       if not ( SY in [ BEGINSY , PROCSY , FUNCSY ] ) 
3159  7430 3  8                       then 
3160  7430 3  8                         begin 
3161  7434 3  9                           ERROR ( 6 ) ; 
3162  7435 3  9                           SKIP ( FSYS ) 
3163  7437 3 10                         end (* then *) 
3164  7437 3  9                     end (* then *) 
3165  7438 3  7                   else 
3166  7440 3  6                     ERROR ( 14 ) 
3167  7446 3  7                 until ( SY in [ BEGINSY , PROCSY , FUNCSY ] ) or EOF ( 
3168  7450 3  5                 INPUT ) ; 
3169  7453 3  4                 GLOBTESTP := NIL ; 
3170  7456 3  4                 RELEASE ( MARKP ) ; 
3171  7456 3  4               end (* else *) ; 
3172  7456 3  2           end (* else *) ; 
3173  7459 3  0         MIN_LEVEL := OLD_MIN_LEVEL ; 
3174  7462 3  0         LEVEL := OLDLEV ; 
3175  7465 3  0         TOP := OLDTOP ; 
3176  7468 3  0         LC := LLC ; 
3177  7469 3  0       end (* PROCDECLARATION *) ; 
3178  7469 3  0  
3179  7469 3  0  
3180  7469 3  0    procedure BODY ( FSYS : SETOFSYS ) ; 
3181  7469 3  0  
3182     0 3  0       const CSTOCCMAX = 2 ; 
3183     0 3  0             CIXMAX = 1000 ; 
3184     0 3  0  
3185     0 3  0       type OPRANGE = 0 .. 67 ; 
3186     0 3  0  
3187    -4 3  0       var LLCP : CTP ; 
3188   -20 3  0           SAVEID : ALPHA ; 
3189   -24 3  0           CSTPTRIX : 0 .. CSTOCCMAX ; 
3190   -36 3  0           I , ENTNAME , SEGSIZE : INTEGER ; 
3191   -48 3  0           STACKTOP , TOPNEW , TOPMAX : INTEGER ; 
3192   -60 3  0           FCBADDR , LCMAX , LLC1 : ADDRRANGE ; 
3193   -68 3  0           FCP , LCP : CTP ; 
3194   -72 3  0           LLP : LBP ; 
3195   -80 3  0           CSTPTR : array [ 1 .. CSTOCCMAX ] of CSP ; 
3196   -80 3  0  
3197   -80 3  0  
3198     0 4  0       procedure MES ( I : INTEGER ) ; 
3199     0 4  0  
3200  7469 4  0          begin (* MES *) 
3201  7481 4  0            TOPNEW := TOPNEW + CDX [ I ] * MAXSTACK ; 
3202  7485 4  0            if TOPNEW > TOPMAX then 
3203  7485 4  1              TOPMAX := TOPNEW 
3204  7488 4  2          end (* MES *) ; 
3205  7488 4  0  
3206  7488 4  0  
3207  7488 4  0       procedure PPUTLC ; 
3208  7488 4  0  
3209  7488 4  0          begin (* PPUTLC *) 
3210  7494 4  0            if LINECOUNT <> OLDLINECOUNT then 
3211  7494 4  1              begin 
3212  7504 4  2                WRITELN ( PRR , '=' , LINECOUNT : 1 ) ; 
3213  7506 4  2                OLDLINECOUNT := LINECOUNT ; 
3214  7506 4  2              end (* then *) ; 
3215  7507 4  0          end (* PPUTLC *) ; 
3216  7507 4  0  
3217  7507 4  0  
3218  7507 4  0       procedure PUTLC ; 
3219  7507 4  0  
3220  7507 4  0          begin (* PUTLC *) 
3221  7511 4  0            if DEBUG then 
3222  7511 4  1              PPUTLC 
3223  7514 4  2            else 
3224  7520 4  1              if LINECOUNT - OLDLINECOUNT >= 10 then 
3225  7522 4  2                PPUTLC ; 
3226  7523 4  0          end (* PUTLC *) ; 
3227  7523 4  0  
3228  7523 4  0  
3229  7523 4  0       procedure GEN0 ( FOP : OPRANGE ) ; 
3230  7523 4  0  
3231  7523 4  0          begin (* GEN0 *) 
3232  7527 4  0            if PRCODE then 
3233  7527 4  1              begin 
3234  7529 4  2                PUTLC ; 
3235  7537 4  2                WRITELN ( PRR , MN [ FOP ] : 4 ) 
3236  7539 4  3              end (* then *) ; 
3237  7544 4  0            IC := IC + 1 ; 
3238  7546 4  0            MES ( FOP ) 
3239  7549 4  1          end (* GEN0 *) ; 
3240  7549 4  0  
3241  7549 4  0  
3242  7549 4  0       procedure GEN1 ( FOP : OPRANGE ; FP2 : INTEGER ) ; 
3243  7549 4  0  
3244    -4 4  0          var K : INTEGER ; 
3245    -4 4  0  
3246  7549 4  0          begin (* GEN1 *) 
3247  7553 4  0            if PRCODE then 
3248  7553 4  1              begin 
3249  7555 4  2                PUTLC ; 
3250  7563 4  2                WRITE ( PRR , MN [ FOP ] : 4 ) ; 
3251  7567 4  2                if FOP = 30 then 
3252  7567 4  3                  begin 
3253  7578 4  4                    WRITELN ( PRR , SNA [ FP2 ] : 5 ) ; 
3254  7589 4  4                    TOPNEW := TOPNEW + PDX [ FP2 ] * MAXSTACK ; 
3255  7593 4  4                    if TOPNEW > TOPMAX then 
3256  7593 4  5                      TOPMAX := TOPNEW 
3257  7595 4  6                  end (* then *) 
3258  7596 4  4                else 
3259  7596 4  3                  begin 
3260  7600 4  4                    if FOP = 38 then 
3261  7600 4  5                      begin 
3262  7608 4  6                        with CSTPTR [ FP2 ] -> do 
3263  7608 4  7                          begin 
3264  7622 4  8                            WRITE ( PRR , ' ' , SLGTH : 1 , ' "' ) ; 
3265  7630 4  8                            for K := 1 to SLGTH - 1 do 
3266  7630 4  9                              begin 
3267  7641 4 10                                WRITE ( PRR , ORD ( SVAL [ K ] ) : 1 , 
3268  7645 4 11                                        ',' ) ; 
3269  7647 4 10                              end (* for *) ; 
3270  7659 4  8                            WRITELN ( PRR , ORD ( SVAL [ SLGTH ] ) : 1 , 
3271  7665 4  9                                      '"' ) ; 
3272  7665 4  8                          end (* with *) ; 
3273  7665 4  6                      end (* then *) 
3274  7666 4  6                    else 
3275  7670 4  5                      if FOP = 42 then 
3276  7675 4  6                        WRITELN ( PRR , CHR ( FP2 ) ) 
3277  7678 4  7                      else 
3278  7688 4  6                        WRITELN ( PRR , ' ' , FP2 : 1 ) ; 
3279  7690 4  4                    MES ( FOP ) 
3280  7692 4  5                  end (* else *) 
3281  7692 4  4              end (* then *) ; 
3282  7693 4  0            IC := IC + 1 
3283  7698 4  1          end (* GEN1 *) ; 
3284  7698 4  0  
3285  7698 4  0  
3286  7698 4  0       procedure GEN2 ( FOP : OPRANGE ; FP1 , FP2 : INTEGER ) ; 
3287  7698 4  0  
3288    -8 4  0          var L , K : INTEGER ; 
3289    -8 4  0  
3290  7698 4  0          begin (* GEN2 *) 
3291  7702 4  0            if PRCODE then 
3292  7702 4  1              begin 
3293  7704 4  2                PUTLC ; 
3294  7712 4  2                WRITE ( PRR , MN [ FOP ] : 4 ) ; 
3295  7714 4  2                case FOP of 
3296  7714 4  3                  41 , 45 , 50 , 54 , 56 : 
3297  7733 4  3                    WRITELN ( PRR , ' ' , FP1 : 1 , ' ' , FP2 : 1 ) ; 
3298  7733 4  3                  47 , 48 , 49 , 52 , 53 , 55 : 
3299  7733 4  3                    begin 
3300  7738 4  4                      WRITE ( PRR , CHR ( FP1 ) ) ; 
3301  7746 4  4                      if ( CHR ( FP1 ) = 'M' ) or ( CHR ( FP1 ) = 'V' ) 
3302  7748 4  5                      then 
3303  7756 4  5                        WRITE ( PRR , ' ' , FP2 : 1 ) ; 
3304  7756 4  4                      WRITELN ( PRR ) 
3305  7759 4  5                    end (* tag/ca *) ; 
3306  7761 4  3                  51 : case FP1 of 
3307  7773 4  4                         1 : WRITELN ( PRR , 'I ' , FP2 : 1 ) ; 
3308  7773 4  4                         2 : begin 
3309  7778 4  5                               WRITE ( PRR , 'R ' ) ; 
3310  7786 4  5                               with CSTPTR [ FP2 ] -> do 
3311  7791 4  6                                 for K := 1 to RSTRGLGTH do 
3312  7803 4  7                                   WRITE ( PRR , RVAL [ K ] ) ; 
3313  7803 4  5                               WRITELN ( PRR ) 
3314  7806 4  6                             end (* tag/ca *) ; 
3315  7818 4  4                         3 : WRITELN ( PRR , 'B ' , FP2 : 1 ) ; 
3316  7825 4  4                         4 : WRITELN ( PRR , 'N' ) ; 
3317  7835 4  4                         6 : WRITELN ( PRR , 'C ''' : 3 , CHR ( FP2 ) , 
3318  7842 4  5                                       '''' ) ; 
3319  7842 4  4                         5 : begin 
3320  7846 4  5                               WRITE ( PRR , '(' ) ; 
3321  7849 4  5                               L := - 1 ; 
3322  7857 4  5                               with CSTPTR [ FP2 ] -> do 
3323  7857 4  6                                 begin 
3324  7859 4  7                                   K := SETLOW ; 
3325  7859 4  7                                   repeat 
3326  7864 4  8                                     if K in PVAL then 
3327  7864 4  9                                       begin 
3328  7866 4 10                                         L := K ; 
3329  7866 4 10                                         repeat 
3330  7869 4 11                                           K := SUCC ( K ) ; 
3331  7874 4 11                                         until not ( K in PVAL ) or ( K 
3332  7879 4 11                                         > SETHIGH ) ; 
3333  7882 4 10                                         K := PRED ( K ) ; 
3334  7886 4 10                                         if K = L then 
3335  7894 4 11                                           WRITE ( PRR , ' ' , K : 1 ) 
3336  7895 4 12                                         else 
3337  7903 4 11                                           WRITE ( PRR , ' ' , L : 1 , 
3338  7911 4 12                                                   '-' , K : 1 ) ; 
3339  7911 4 10                                       end (* then *) ; 
3340  7914 4  8                                     K := SUCC ( K ) ; 
3341  7918 4  8                                   until K > SETHIGH ; 
3342  7918 4  7                                 end (* with *) ; 
3343  7922 4  5                               WRITELN ( PRR , ')' ) 
3344  7924 4  6                             end (* tag/ca *) 
3345  7929 4  5                       end (* case *) 
3346  7934 4  4                end (* case *) ; 
3347  7934 4  2              end (* then *) ; 
3348  7939 4  0            IC := IC + 1 ; 
3349  7941 4  0            MES ( FOP ) 
3350  7944 4  1          end (* GEN2 *) ; 
3351  7944 4  0  
3352  7944 4  0  
3353  7944 4  0       procedure GEN3 ( FOP : OPRANGE ; FP1 , FP2 , FP3 : INTEGER ) ; 
3354  7944 4  0  
3355    -4 4  0          var K : INTEGER ; 
3356    -4 4  0  
3357  7944 4  0          begin (* GEN3 *) 
3358  7948 4  0            if PRCODE then 
3359  7948 4  1              begin 
3360  7950 4  2                PUTLC ; 
3361  7970 4  2                WRITELN ( PRR , MN [ FOP ] : 4 , ' ' , FP1 : 1 , ' ' , 
3362  7984 4  3                          FP2 : 1 , ' ' , FP3 : 1 ) ; 
3363  7984 4  2              end (* then *) ; 
3364  7988 4  0            IC := SUCC ( IC ) ; 
3365  7992 4  0            MES ( FOP ) ; 
3366  7993 4  0          end (* GEN3 *) ; 
3367  7993 4  0  
3368  7993 4  0  
3369  7993 4  0       procedure GENTYPINDICATOR ( FSP : STP ) ; 
3370  7993 4  0  
3371  7993 4  0          begin (* GENTYPINDICATOR *) 
3372  7999 4  0            if FSP <> NIL then 
3373  8002 4  1              with FSP -> do 
3374  8006 4  2                case FORM of 
3375  8006 4  3                  SCALAR : 
3376  8010 4  3                    if FSP = INTPTR then 
3377  8014 4  4                      WRITE ( PRR , 'I' ) 
3378  8015 4  5                    else 
3379  8019 4  4                      if FSP = BOOLPTR then 
3380  8023 4  5                        WRITE ( PRR , 'B' ) 
3381  8024 4  6                      else 
3382  8028 4  5                        if FSP = CHARPTR then 
3383  8032 4  6                          WRITE ( PRR , 'C' ) 
3384  8033 4  7                        else 
3385  8038 4  6                          if SCALKIND = DECLARED then 
3386  8042 4  7                            WRITE ( PRR , 'I' ) 
3387  8043 4  8                          else 
3388  8049 4  7                            WRITE ( PRR , 'R ' ) ; 
3389  8049 4  3                  SUBRANGE : 
3390  8054 4  3                    GENTYPINDICATOR ( RANGETYPE ) ; 
3391  8054 4  3                  FILES , POINTER : 
3392  8059 4  3                    WRITE ( PRR , 'A' ) ; 
3393  8064 4  3                  POWER : WRITE ( PRR , 'S' ) ; 
3394  8064 4  3                  ARRAYS : 
3395  8064 4  3                    begin 
3396  8067 4  4                      if VARY then 
3397  8071 4  5                        WRITE ( PRR , 'V' ) 
3398  8072 4  6                      else 
3399  8076 4  5                        WRITE ( PRR , 'M' ) ; 
3400  8077 4  4                    end (* tag/ca *) ; 
3401  8077 4  3                  RECORDS : 
3402  8082 4  3                    WRITE ( PRR , 'M' ) ; 
3403  8082 4  3                  TAGFLD , VARIANT : 
3404  8084 4  3                    ERROR ( 401 ) 
3405  8091 4  4                end (* case *) ; 
3406  8095 4  0            WRITE ( PRR , ' ' ) ; 
3407  8096 4  0          end (* GENTYPINDICATOR *) ; 
3408  8096 4  0  
3409  8096 4  0  
3410  8096 4  0       procedure GEN0T ( FOP : OPRANGE ; FSP : STP ) ; 
3411  8096 4  0  
3412  8096 4  0          begin (* GEN0T *) 
3413  8100 4  0            if PRCODE then 
3414  8100 4  1              begin 
3415  8102 4  2                PUTLC ; 
3416  8110 4  2                WRITE ( PRR , MN [ FOP ] : 4 ) ; 
3417  8113 4  2                GENTYPINDICATOR ( FSP ) ; 
3418  8115 4  2                WRITELN ( PRR ) ; 
3419  8115 4  2              end (* then *) ; 
3420  8120 4  0            IC := IC + 1 ; 
3421  8122 4  0            MES ( FOP ) 
3422  8125 4  1          end (* GEN0T *) ; 
3423  8125 4  0  
3424  8125 4  0  
3425  8125 4  0       procedure GEN1T ( FOP : OPRANGE ; FP2 : INTEGER ; FSP : STP ) ; 
3426  8125 4  0  
3427  8125 4  0          begin (* GEN1T *) 
3428  8129 4  0            if PRCODE then 
3429  8129 4  1              begin 
3430  8131 4  2                PUTLC ; 
3431  8139 4  2                WRITE ( PRR , MN [ FOP ] : 4 ) ; 
3432  8142 4  2                GENTYPINDICATOR ( FSP ) ; 
3433  8146 4  2                WRITELN ( PRR , FP2 : 1 ) 
3434  8148 4  3              end (* then *) ; 
3435  8153 4  0            IC := IC + 1 ; 
3436  8155 4  0            MES ( FOP ) 
3437  8158 4  1          end (* GEN1T *) ; 
3438  8158 4  0  
3439  8158 4  0  
3440  8158 4  0       procedure GEN2T ( FOP : OPRANGE ; FP1 , FP2 : INTEGER ; FSP : STP 
3441  8158 4  0                       ) ; 
3442  8158 4  0  
3443  8158 4  0          begin (* GEN2T *) 
3444  8162 4  0            if PRCODE then 
3445  8162 4  1              begin 
3446  8164 4  2                PUTLC ; 
3447  8172 4  2                WRITE ( PRR , MN [ FOP ] : 4 ) ; 
3448  8175 4  2                GENTYPINDICATOR ( FSP ) ; 
3449  8189 4  2                WRITELN ( PRR , FP1 : 1 , ' ' , FP2 : 1 ) ; 
3450  8189 4  2              end (* then *) ; 
3451  8194 4  0            IC := IC + 1 ; 
3452  8196 4  0            MES ( FOP ) 
3453  8199 4  1          end (* GEN2T *) ; 
3454  8199 4  0  
3455  8199 4  0  
3456  8199 4  0       procedure GEN2TL ( FOP : OPRANGE ; FP1 , FP2 : INTEGER ; FSP : 
3457  8199 4  0                        STP ) ; 
3458  8199 4  0  
3459  8199 4  0          begin (* GEN2TL *) 
3460  8203 4  0            if PRCODE then 
3461  8203 4  1              begin 
3462  8205 4  2                PUTLC ; 
3463  8213 4  2                WRITE ( PRR , MN [ FOP ] : 4 ) ; 
3464  8216 4  2                GENTYPINDICATOR ( FSP ) ; 
3465  8231 4  2                WRITELN ( PRR , FP1 : 1 , ' &' , FP2 : 1 ) ; 
3466  8231 4  2              end (* then *) ; 
3467  8236 4  0            IC := IC + 1 ; 
3468  8238 4  0            MES ( FOP ) 
3469  8241 4  1          end (* GEN2TL *) ; 
3470  8241 4  0  
3471  8241 4  0  
3472  8241 4  0       procedure LOAD ; 
3473  8241 4  0  
3474  8241 4  0          begin (* LOAD *) 
3475  8243 4  0            with GATTR do 
3476  8247 4  1              if TYPTR <> NIL then 
3477  8247 4  2                begin 
3478  8250 4  3                  case KIND of 
3479  8256 4  4                    CST : if ( TYPTR -> . FORM = SCALAR ) and ( TYPTR <> 
3480  8260 4  5                          REALPTR ) then 
3481  8264 4  5                            if TYPTR = BOOLPTR then 
3482  8271 4  6                              GEN2 ( 51 , 3 , CVAL . IVAL ) 
3483  8274 4  7                            else 
3484  8278 4  6                              if TYPTR = CHARPTR then 
3485  8285 4  7                                GEN2 ( 51 , 6 , CVAL . IVAL ) 
3486  8288 4  8                              else 
3487  8295 4  7                                GEN2 ( 51 , 1 , CVAL . IVAL ) 
3488  8298 4  8                          else 
3489  8302 4  5                            if TYPTR = NILPTR then 
3490  8309 4  6                              GEN2 ( 51 , 4 , 0 ) 
3491  8312 4  7                            else 
3492  8316 4  6                              if CSTPTRIX >= CSTOCCMAX then 
3493  8318 4  7                                ERROR ( 254 ) 
3494  8321 4  8                              else 
3495  8321 4  7                                begin 
3496  8324 4  8                                  CSTPTRIX := 1 ; 
3497  8332 4  8                                  CSTPTR [ CSTPTRIX ] := CVAL . VALP ; 
3498  8336 4  8                                  if TYPTR = REALPTR then 
3499  8343 4  9                                    GEN2 ( 51 , 2 , CSTPTRIX ) 
3500  8346 4 10                                  else 
3501  8353 4  9                                    GEN2 ( 51 , 5 , CSTPTRIX ) 
3502  8356 4 10                                end (* else *) ; 
3503  8356 4  4                    VARBL : begin 
3504  8359 4  5                              case ACCESS of 
3505  8359 4  6                                DRCT : begin 
3506  8363 4  7                                         if VLEVEL <= 1 then 
3507  8369 4  8                                           GEN1T ( 39 , DPLMT , TYPTR ) 
3508  8372 4  9                                         else 
3509  8379 4  8                                           GEN2T ( 54 , LEVEL - VLEVEL , 
3510  8384 4  9                                                   DPLMT , TYPTR ) ; 
3511  8386 4  7                                         if PRCODE then 
3512  8386 4  8                                           begin 
3513  8391 4  9                                             WRITE ( PRR , '; load ' ) ; 
3514  8393 4  9                                             WRITENAME ( ACP -> . NAME ) 
3515  8395 4 10                                                    ; 
3516  8397 4  9                                             WRITELN ( PRR ) ; 
3517  8397 4  9                                           end (* then *) ; 
3518  8398 4  7                                       end (* tag/ca *) ; 
3519  8398 4  6                                INDRCT : 
3520  8407 4  6                                  GEN1T ( 35 , IDPLMT , TYPTR ) ; 
3521  8409 4  6                                INXD : ERROR ( 400 ) 
3522  8416 4  7                              end (* case *) ; 
3523  8417 4  5                            end (* tag/ca *) ; 
3524  8417 4  4                    EXPR : 
3525  8422 4  4                  end (* case *) ; 
3526  8422 4  3                  KIND := EXPR 
3527  8425 4  4                end (* then *) 
3528  8426 4  3          end (* LOAD *) ; 
3529  8426 4  0  
3530  8426 4  0  
3531  8426 4  0       procedure STORE ( var FATTR : ATTR ) ; 
3532  8426 4  0  
3533  8426 4  0          begin (* STORE *) 
3534  8430 4  0            with FATTR do 
3535  8435 4  1              if TYPTR <> NIL then 
3536  8439 4  2                case ACCESS of 
3537  8439 4  3                  DRCT : begin 
3538  8444 4  4                           if VLEVEL <= 1 then 
3539  8452 4  5                             GEN1T ( 43 , DPLMT , TYPTR ) 
3540  8455 4  6                           else 
3541  8458 4  5                             if LABEL_ACCESS then 
3542  8469 4  6                               GEN2TL ( 56 , LEVEL - VLEVEL , DPLMT , 
3543  8471 4  7                                        TYPTR ) 
3544  8474 4  7                             else 
3545  8485 4  6                               GEN2T ( 56 , LEVEL - VLEVEL , DPLMT , 
3546  8489 4  7                                       TYPTR ) ; 
3547  8491 4  4                           if PRCODE then 
3548  8491 4  5                             begin 
3549  8496 4  6                               WRITE ( PRR , '; store ' ) ; 
3550  8501 4  6                               WRITENAME ( ACP -> . NAME ) ; 
3551  8503 4  6                               WRITELN ( PRR ) ; 
3552  8503 4  6                             end (* then *) ; 
3553  8504 4  4                         end (* tag/ca *) ; 
3554  8504 4  3                  INDRCT : 
3555  8509 4  3                    if IDPLMT <> 0 then 
3556  8511 4  4                      ERROR ( 400 ) 
3557  8514 4  5                    else 
3558  8524 4  4                      GEN1T ( 26 , 0 , TYPTR ) ; 
3559  8526 4  3                  INXD : ERROR ( 400 ) 
3560  8533 4  4                end (* case *) ; 
3561  8534 4  0          end (* STORE *) ; 
3562  8534 4  0  
3563  8534 4  0  
3564  8534 4  0       procedure LOADADDRESS ; 
3565  8534 4  0  
3566  8534 4  0          begin (* LOADADDRESS *) 
3567  8536 4  0            with GATTR do 
3568  8540 4  1              if TYPTR <> NIL then 
3569  8540 4  2                begin 
3570  8543 4  3                  case KIND of 
3571  8547 4  4                    CST : if ISSTRING ( TYPTR ) then 
3572  8551 4  5                            if CSTPTRIX >= CSTOCCMAX then 
3573  8553 4  6                              ERROR ( 254 ) 
3574  8556 4  7                            else 
3575  8556 4  6                              begin 
3576  8559 4  7                                CSTPTRIX := 1 ; 
3577  8567 4  7                                CSTPTR [ CSTPTRIX ] := CVAL . VALP ; 
3578  8572 4  7                                GEN1 ( 38 , CSTPTRIX ) 
3579  8574 4  8                              end (* else *) 
3580  8575 4  7                          else 
3581  8580 4  5                            ERROR ( 400 ) ; 
3582  8583 4  4                    VARBL : case ACCESS of 
3583  8583 4  5                              DRCT : begin 
3584  8587 4  6                                       if VLEVEL <= 1 then 
3585  8592 4  7                                         GEN1 ( 37 , DPLMT ) 
3586  8595 4  8                                       else 
3587  8602 4  7                                         GEN2 ( 50 , LEVEL - VLEVEL , 
3588  8606 4  8                                                DPLMT ) ; 
3589  8608 4  6                                       if PRCODE then 
3590  8608 4  7                                         begin 
3591  8613 4  8                                           WRITE ( PRR , '; loadaddr ' ) 
3592  8613 4  9                                                   ; 
3593  8617 4  8                                           WRITENAME ( ACP -> . NAME ) ; 
3594  8619 4  8                                           WRITELN ( PRR ) ; 
3595  8619 4  8                                         end (* then *) ; 
3596  8620 4  6                                     end (* tag/ca *) ; 
3597  8620 4  5                              INDRCT : 
3598  8624 4  5                                if IDPLMT <> 0 then 
3599  8633 4  6                                  GEN1T ( 34 , IDPLMT , NILPTR ) ; 
3600  8635 4  5                              INXD : ERROR ( 400 ) 
3601  8643 4  6                            end (* case *) ; 
3602  8645 4  4                    EXPR : ERROR ( 400 ) 
3603  8652 4  5                  end (* case *) ; 
3604  8655 4  3                  KIND := VARBL ; 
3605  8658 4  3                  ACCESS := INDRCT ; 
3606  8658 4  3                  IDPLMT := 0 
3607  8661 4  4                end (* then *) 
3608  8662 4  3          end (* LOADADDRESS *) ; 
3609  8662 4  0  
3610  8662 4  0  
3611  8662 4  0       procedure GENFJP ( FADDR : INTEGER ) ; 
3612  8662 4  0  
3613  8662 4  0          begin (* GENFJP *) 
3614  8666 4  0            LOAD ; 
3615  8670 4  0            if GATTR . TYPTR <> NIL then 
3616  8674 4  1              if GATTR . TYPTR <> BOOLPTR then 
3617  8678 4  2                ERROR ( 144 ) ; 
3618  8680 4  0            if PRCODE then 
3619  8680 4  1              begin 
3620  8682 4  2                PUTLC ; 
3621  8690 4  2                WRITE ( PRR , MN [ 33 ] : 4 ) ; 
3622  8699 4  2                WRITELN ( PRR , ' &' , FADDR : 1 ) 
3623  8701 4  3              end (* then *) ; 
3624  8706 4  0            IC := IC + 1 ; 
3625  8708 4  0            MES ( 33 ) 
3626  8711 4  1          end (* GENFJP *) ; 
3627  8711 4  0  
3628  8711 4  0  
3629  8711 4  0       procedure GENUJP ( FOP : OPRANGE ; FP2 : INTEGER ) ; 
3630  8711 4  0  
3631  8711 4  0          begin (* GENUJP *) 
3632  8715 4  0            if PRCODE then 
3633  8715 4  1              begin 
3634  8717 4  2                PUTLC ; 
3635  8725 4  2                WRITE ( PRR , MN [ FOP ] : 4 ) ; 
3636  8734 4  2                WRITELN ( PRR , ' &' , FP2 : 1 ) 
3637  8736 4  3              end (* then *) ; 
3638  8741 4  0            IC := IC + 1 ; 
3639  8743 4  0            MES ( FOP ) 
3640  8746 4  1          end (* GENUJP *) ; 
3641  8746 4  0  
3642  8746 4  0  
3643  8746 4  0       procedure GENJPA ( FP1 , FP2 : INTEGER ) ; 
3644  8746 4  0  
3645  8746 4  0          begin (* GENJPA *) 
3646  8750 4  0            if PRCODE then 
3647  8772 4  1              WRITELN ( PRR , ' JPA ' , '&' , FP1 : 1 , ' &' , FP2 : 1 ) 
3648  8774 4  2                        ; 
3649  8775 4  0          end (* GENJPA *) ; 
3650  8775 4  0  
3651  8775 4  0  
3652  8775 4  0       procedure GENXJP ( FOP : OPRANGE ; MAXI , LAB : INTEGER ) ; 
3653  8775 4  0  
3654  8775 4  0          begin (* GENXJP *) 
3655  8779 4  0            if PRCODE then 
3656  8779 4  1              begin 
3657  8781 4  2                PUTLC ; 
3658  8789 4  2                WRITE ( PRR , MN [ FOP ] : 4 ) ; 
3659  8808 4  2                WRITELN ( PRR , ' ' , MAXI : 1 , ' &' , LAB : 1 ) ; 
3660  8808 4  2              end (* then *) ; 
3661  8812 4  0            IC := SUCC ( IC ) ; 
3662  8816 4  0            MES ( FOP ) ; 
3663  8817 4  0          end (* GENXJP *) ; 
3664  8817 4  0  
3665  8817 4  0  
3666  8817 4  0       procedure GENCUPENT ( FOP : OPRANGE ; FP1 , FP2 : INTEGER ) ; 
3667  8817 4  0  
3668  8817 4  0          begin (* GENCUPENT *) 
3669  8821 4  0            if PRCODE then 
3670  8821 4  1              begin 
3671  8823 4  2                PUTLC ; 
3672  8831 4  2                WRITE ( PRR , MN [ FOP ] : 4 ) ; 
3673  8848 4  2                WRITE ( PRR , ' ' , FP1 : 1 , ' &' , FP2 : 1 ) ; 
3674  8852 4  2                if FOP = 46 then 
3675  8856 4  3                  if GATTR . ACP = NIL then 
3676  8865 4  4                    WRITE ( PRR , ' ' , '_MAIN' ) 
3677  8866 4  5                  else 
3678  8866 4  4                    begin 
3679  8870 4  5                      WRITE ( PRR , ' ' ) ; 
3680  8874 4  5                      WRITENAME ( GATTR . ACP -> . NAME ) ; 
3681  8874 4  5                    end (* else *) ; 
3682  8876 4  2                WRITELN ( PRR ) ; 
3683  8876 4  2              end (* then *) ; 
3684  8881 4  0            IC := IC + 1 ; 
3685  8883 4  0            MES ( FOP ) 
3686  8886 4  1          end (* GENCUPENT *) ; 
3687  8886 4  0  
3688  8886 4  0  
3689  8886 4  0       procedure CHECKBNDS ( FSP : STP ) ; 
3690  8886 4  0  
3691    -8 4  0          var LMIN , LMAX : INTEGER ; 
3692    -8 4  0  
3693  8886 4  0          begin (* CHECKBNDS *) 
3694  8892 4  0            if FSP <> NIL then 
3695  8896 4  1              if FSP <> INTPTR then 
3696  8900 4  2                if FSP <> REALPTR then 
3697  8906 4  3                  if FSP -> . FORM <= SUBRANGE then 
3698  8906 4  4                    begin 
3699  8911 4  5                      GETBOUNDS ( FSP , LMIN , LMAX ) ; 
3700  8919 4  5                      GEN2T ( 45 , LMIN , LMAX , FSP ) 
3701  8921 4  6                    end (* then *) 
3702  8922 4  5          end (* CHECKBNDS *) ; 
3703  8922 4  0  
3704  8922 4  0  
3705  8922 4  0       procedure PUTLABEL ( LABNAME : INTEGER ) ; 
3706  8922 4  0  
3707  8922 4  0          begin (* PUTLABEL *) 
3708  8926 4  0            if PRCODE then 
3709  8934 4  1              WRITELN ( PRR , '&' , LABNAME : 1 ) 
3710  8937 4  2          end (* PUTLABEL *) ; 
3711  8937 4  0  
3712  8937 4  0  
3713  8937 4  0       procedure STATEMENT ( FSYS : SETOFSYS ) ; 
3714  8937 4  0  
3715     0 4  0          label 1 ; 
3716     0 4  0  
3717    -4 4  0          var LCP : CTP ; 
3718    -8 4  0              LLP : LBP ; 
3719    -8 4  0  
3720    -8 4  0  
3721     0 5  0          procedure EXPRESSION ( FSYS : SETOFSYS ) ; 
3722     0 5  0  
3723     0 5  0             FORWARD ; 
3724     0 5  0  
3725     0 5  0  
3726     0 5  0          procedure SELECTOR ( FSYS : SETOFSYS ; FCP : CTP ) ; 
3727     0 5  0  
3728     0 5  0             label 1 ; 
3729     0 5  0  
3730   -26 5  0             var LATTR : ATTR ; 
3731   -30 5  0                 LCP : CTP ; 
3732   -42 5  0                 LSIZE , LMIN , LMAX : INTEGER ; 
3733   -46 5  0                 I : INTEGER ; 
3734   -47 5  0                 C : CHAR ; 
3735   -47 5  0  
3736  8937 5  0             begin (* SELECTOR *) 
3737  8942 5  0               with FCP -> , GATTR do 
3738  8942 5  1                 begin 
3739  8946 5  2                   TYPTR := IDTYPE ; 
3740  8949 5  2                   KIND := VARBL ; 
3741  8952 5  2                   LABEL_ACCESS := FALSE ; 
3742  8956 5  2                   case KLASS of 
3743  8961 5  3                     VARS : if VKIND = ACTUAL then 
3744  8961 5  4                              begin 
3745  8964 5  5                                ACCESS := DRCT ; 
3746  8968 5  5                                VLEVEL := VLEV ; 
3747  8972 5  5                                DPLMT := VADDR ; 
3748  8975 5  5                                ACP := FCP ; 
3749  8975 5  5                              end (* then *) 
3750  8976 5  5                            else 
3751  8976 5  4                              begin 
3752  8979 5  5                                if VIMPORT then 
3753  8979 5  6                                  begin 
3754  8981 5  7                                    if PRCODE then 
3755  8981 5  8                                      begin 
3756  8986 5  9                                        WRITE ( PRR , ' LXA ' ) ; 
3757  8991 5  9                                        if VXNAME <> NIL then 
3758  8994 5 10                                          WRITESTRG ( VXNAME -> ) 
3759  8997 5 11                                        else 
3760  8997 5 10                                          begin 
3761  9001 5 11                                            WRITE ( PRR , '_' ) ; 
3762  9006 5 11                                            for I := 1 to ALPHALEN do 
3763  9006 5 12                                              begin 
3764  9014 5 13                                                C := NAME [ I ] ; 
3765  9018 5 13                                                if C = ' ' then 
3766  9019 5 14                                                  goto 1 ; 
3767  9022 5 13                                                if ( C >= 'A' ) and ( C 
3768  9027 5 14                                                <= 'Z' ) then 
3769  9029 5 14                                                  C := CHR ( ORD ( C ) + 
3770  9034 5 15                                                    32 ) ; 
3771  9038 5 13                                                WRITE ( PRR , C : 1 ) ; 
3772  9040 5 13                                              end (* for *) ; 
3773  9040 5 11                                          end (* else *) ; 
3774  9040 5  9                                        1 : 
3775  9042 5 10                                        WRITELN ( PRR ) ; 
3776  9042 5  9                                      end (* then *) ; 
3777  9042 5  7                                  end (* then *) 
3778  9043 5  7                                else 
3779  9054 5  6                                  GEN2T ( 54 , LEVEL - VLEV , VADDR , 
3780  9057 5  7                                          NILPTR ) ; 
3781  9060 5  5                                ACCESS := INDRCT ; 
3782  9063 5  5                                IDPLMT := 0 ; 
3783  9066 5  5                                ACP := FCP ; 
3784  9067 5  5                              end (* else *) ; 
3785  9072 5  3                     FIELD : with DISPLAY [ DISX ] do 
3786  9077 5  4                               if OCCUR = CREC then 
3787  9077 5  5                                 begin 
3788  9080 5  6                                   ACCESS := DRCT ; 
3789  9084 5  6                                   VLEVEL := CLEV ; 
3790  9091 5  6                                   DPLMT := CDSPL + FLDADDR ; 
3791  9095 5  6                                   ACP := FNAME ; 
3792  9095 5  6                                 end (* then *) 
3793  9096 5  6                               else 
3794  9096 5  5                                 begin 
3795  9100 5  6                                   if LEVEL = 1 then 
3796  9107 5  7                                     GEN1T ( 39 , VDSPL , NILPTR ) 
3797  9110 5  8                                   else 
3798  9121 5  7                                     GEN2T ( 54 , 0 , VDSPL , NILPTR ) ; 
3799  9124 5  6                                   ACCESS := INDRCT ; 
3800  9128 5  6                                   IDPLMT := FLDADDR ; 
3801  9132 5  6                                   ACP := FNAME ; 
3802  9133 5  6                                 end (* else *) ; 
3803  9138 5  3                     FUNC : if PFDECKIND = STANDARD then 
3804  9138 5  4                              begin 
3805  9142 5  5                                ERROR ( 150 ) ; 
3806  9142 5  5                                TYPTR := NIL 
3807  9145 5  6                              end (* then *) 
3808  9146 5  5                            else 
3809  9146 5  4                              begin 
3810  9151 5  5                                if PFKIND = FORMAL then 
3811  9153 5  6                                  ERROR ( 151 ) 
3812  9156 5  7                                else 
3813  9162 5  6                                  if ( PFLEV + 1 <> LEVEL ) or ( FPROCP 
3814  9167 5  7                                  <> FCP ) then 
3815  9171 5  7                                    ERROR ( 177 ) ; 
3816  9171 5  5                                begin 
3817  9174 5  6                                  ACCESS := DRCT ; 
3818  9180 5  6                                  VLEVEL := PFLEV + 1 ; 
3819  9183 5  6                                  LABEL_ACCESS := TRUE ; 
3820  9188 5  6                                  DPLMT := FPROCP -> . RESULT_LABEL ; 
3821  9191 5  6                                  ACP := FCP ; 
3822  9191 5  6                                end 
3823  9191 5  6                              end (* else *) 
3824  9196 5  5                   end (* case *) 
3825  9196 5  3                 end (* with *) ; 
3826  9204 5  0               if not ( SY in SELECTSYS + FSYS ) then 
3827  9204 5  1                 begin 
3828  9208 5  2                   ERROR ( 59 ) ; 
3829  9211 5  2                   SKIP ( SELECTSYS + FSYS ) 
3830  9213 5  3                 end (* then *) ; 
3831  9218 5  0               while SY in SELECTSYS do 
3832  9218 5  1                 begin 
3833  9222 5  2                   if SY = LBRACK then 
3834  9222 5  3                     begin 
3835  9222 5  4                       repeat 
3836  9225 5  5                         LATTR := GATTR ; 
3837  9225 5  5                         with LATTR do 
3838  9229 5  6                           if TYPTR <> NIL then 
3839  9235 5  7                             if TYPTR -> . FORM <> ARRAYS then 
3840  9235 5  8                               begin 
3841  9239 5  9                                 ERROR ( 138 ) ; 
3842  9239 5  9                                 TYPTR := NIL 
3843  9242 5 10                               end (* then *) ; 
3844  9244 5  5                         LOADADDRESS ; 
3845  9246 5  5                         INSYMBOL ; 
3846  9251 5  5                         EXPRESSION ( FSYS + [ COMMA , RBRACK ] ) ; 
3847  9253 5  5                         LOAD ; 
3848  9257 5  5                         if GATTR . TYPTR <> NIL then 
3849  9263 5  6                           if GATTR . TYPTR -> . FORM <> SCALAR then 
3850  9265 5  7                             ERROR ( 113 ) 
3851  9268 5  8                           else 
3852  9272 5  7                             if GATTR . TYPTR <> INTPTR then 
3853  9278 5  8                               GEN0T ( 58 , GATTR . TYPTR ) ; 
3854  9282 5  5                         if LATTR . TYPTR <> NIL then 
3855  9285 5  6                           with LATTR . TYPTR -> do 
3856  9285 5  7                             begin 
3857  9288 5  8                               if COMPTYPES ( INXTYPE , GATTR . TYPTR ) 
3858  9291 5  9                               then 
3859  9291 5  9                                 begin 
3860  9296 5 10                                   if INXTYPE <> NIL then 
3861  9296 5 11                                     begin 
3862  9299 5 12                                       GETBOUNDS ( INXTYPE , LMIN , LMAX 
3863  9302 5 13                                                   ) ; 
3864  9304 5 12                                       if DEBUG then 
3865  9311 5 13                                         GEN2T ( 45 , LMIN , LMAX , 
3866  9314 5 14                                                 INTPTR ) ; 
3867  9318 5 12                                       if LMIN > 0 then 
3868  9324 5 13                                         GEN1T ( 31 , LMIN , INTPTR ) 
3869  9327 5 14                                       else 
3870  9331 5 13                                         if LMIN < 0 then 
3871  9337 5 14                                           GEN1T ( 34 , - LMIN , INTPTR 
3872  9340 5 15                                                   ) ; 
3873  9340 5 12                                     end (* then *) 
3874  9340 5 12                                 end (* then *) 
3875  9341 5 10                               else 
3876  9345 5  9                                 ERROR ( 139 ) ; 
3877  9345 5  8                               with GATTR do 
3878  9345 5  9                                 begin 
3879  9349 5 10                                   TYPTR := AELTYPE ; 
3880  9352 5 10                                   KIND := VARBL ; 
3881  9355 5 10                                   ACCESS := INDRCT ; 
3882  9355 5 10                                   IDPLMT := 0 
3883  9358 5 11                                 end (* with *) ; 
3884  9362 5  8                               if GATTR . TYPTR <> NIL then 
3885  9362 5  9                                 begin 
3886  9366 5 10                                   LSIZE := GATTR . TYPTR -> . SIZE ; 
3887  9370 5 10                                   ALIGN ( GATTR . TYPTR , LSIZE ) ; 
3888  9375 5 10                                   GEN1 ( 36 , LSIZE ) 
3889  9377 5 11                                 end (* then *) 
3890  9377 5 10                             end (* with *) 
3891  9381 5  8                       until SY <> COMMA ; 
3892  9385 5  4                       if SY = RBRACK then 
3893  9385 5  5                         INSYMBOL 
3894  9388 5  6                       else 
3895  9390 5  5                         ERROR ( 12 ) 
3896  9392 5  6                     end (* then *) 
3897  9393 5  4                   else 
3898  9397 5  3                     if SY = PERIOD then 
3899  9397 5  4                       begin 
3900  9397 5  5                         with GATTR do 
3901  9397 5  6                           begin 
3902  9401 5  7                             if TYPTR <> NIL then 
3903  9407 5  8                               if TYPTR -> . FORM <> RECORDS then 
3904  9407 5  9                                 begin 
3905  9411 5 10                                   ERROR ( 140 ) ; 
3906  9411 5 10                                   TYPTR := NIL 
3907  9414 5 11                                 end (* then *) ; 
3908  9416 5  7                             INSYMBOL ; 
3909  9420 5  7                             if SY = IDENT then 
3910  9420 5  8                               begin 
3911  9424 5  9                                 if TYPTR <> NIL then 
3912  9424 5 10                                   begin 
3913  9427 5 11                                     SEARCHSECTION ( TYPTR -> . FSTFLD , 
3914  9430 5 12                                                    LCP ) ; 
3915  9434 5 11                                     if LCP = NIL then 
3916  9434 5 12                                       begin 
3917  9438 5 13                                         ERROR ( 152 ) ; 
3918  9438 5 13                                         TYPTR := NIL 
3919  9441 5 14                                       end (* then *) 
3920  9442 5 13                                     else 
3921  9445 5 12                                       with LCP -> do 
3922  9445 5 13                                         begin 
3923  9449 5 14                                           TYPTR := IDTYPE ; 
3924  9452 5 14                                           case ACCESS of 
3925  9453 5 15                                             DRCT : DPLMT := DPLMT + 
3926  9459 5 16                                                    FLDADDR ; 
3927  9459 5 15                                             INDRCT : 
3928  9460 5 15                                               IDPLMT := IDPLMT + 
3929  9466 5 16                                                    FLDADDR ; 
3930  9468 5 15                                             INXD : ERROR ( 400 ) 
3931  9475 5 16                                           end (* case *) 
3932  9475 5 15                                         end (* with *) 
3933  9475 5 14                                   end (* then *) ; 
3934  9475 5  9                                 INSYMBOL 
3935  9477 5 10                               end (* then *) 
3936  9478 5  9                             else 
3937  9480 5  8                               ERROR ( 2 ) 
3938  9482 5  9                           end (* with *) 
3939  9482 5  7                       end (* then *) 
3940  9483 5  5                     else 
3941  9483 5  4                       begin 
3942  9487 5  5                         if GATTR . TYPTR <> NIL then 
3943  9490 5  6                           with GATTR , TYPTR -> do 
3944  9490 5  7                             begin 
3945  9492 5  8                               LOAD ; 
3946  9497 5  8                               if FORM = POINTER then 
3947  9497 5  9                                 TYPTR := ELTYPE 
3948  9502 5 10                               else 
3949  9507 5  9                                 if FORM = FILES then 
3950  9507 5 10                                   TYPTR := FILTYPE 
3951  9512 5 11                                 else 
3952  9516 5 10                                   ERROR ( 141 ) ; 
3953  9518 5  8                               if DEBUG then 
3954  9528 5  9                                 GEN2T ( 45 , 1 , MAXADDR , NILPTR ) ; 
3955  9528 5  8                               with GATTR do 
3956  9528 5  9                                 begin 
3957  9531 5 10                                   KIND := VARBL ; 
3958  9534 5 10                                   ACCESS := INDRCT ; 
3959  9534 5 10                                   IDPLMT := 0 
3960  9537 5 11                                 end (* with *) 
3961  9537 5 10                             end (* with *) ; 
3962  9537 5  5                         INSYMBOL 
3963  9539 5  6                       end (* else *) ; 
3964  9547 5  2                   if not ( SY in FSYS + SELECTSYS ) then 
3965  9547 5  3                     begin 
3966  9551 5  4                       ERROR ( 6 ) ; 
3967  9554 5  4                       SKIP ( FSYS + SELECTSYS ) 
3968  9556 5  5                     end (* then *) 
3969  9556 5  4                 end (* while *) 
3970  9558 5  2             end (* SELECTOR *) ; 
3971  9558 5  0  
3972  9558 5  0  
3973  9558 5  0          procedure CALL ( FSYS : SETOFSYS ; FCP : CTP ) ; 
3974  9558 5  0  
3975    -4 5  0             var LKEY : 1 .. 15 ; 
3976    -4 5  0  
3977    -4 5  0  
3978     0 6  0             procedure VARIABLE ( FSYS : SETOFSYS ) ; 
3979     0 6  0  
3980    -4 6  0                var LCP : CTP ; 
3981    -4 6  0  
3982  9558 6  0                begin (* VARIABLE *) 
3983  9564 6  0                  if SY = IDENT then 
3984  9564 6  1                    begin 
3985  9568 6  2                      SEARCHID ( [ VARS , FIELD ] , LCP ) ; 
3986  9570 6  2                      INSYMBOL ; 
3987  9574 6  2                      if LCP <> NIL then 
3988  9580 6  3                        if LCP -> . KLASS = VARS then 
3989  9586 6  4                          if LCP -> . VLEV < MIN_LEVEL then 
3990  9590 6  5                            ERROR ( 59 ) ; 
3991  9590 6  2                    end (* then *) 
3992  9591 6  2                  else 
3993  9591 6  1                    begin 
3994  9595 6  2                      ERROR ( 2 ) ; 
3995  9595 6  2                      LCP := UVARPTR 
3996  9598 6  3                    end (* else *) ; 
3997  9600 6  0                  SELECTOR ( FSYS , LCP ) 
3998  9603 6  1                end (* VARIABLE *) ; 
3999  9603 6  0  
4000  9603 6  0  
4001  9603 6  0             procedure GETPUTRESETREWRITE ; 
4002  9603 6  0  
4003    -4 6  0                var FCP : CTP ; 
4004   -12 6  0                    SLEN , I : INTEGER ; 
4005   -12 6  0  
4006  9603 6  0                begin (* GETPUTRESETREWRITE *) 
4007  9610 6  0                  VARIABLE ( FSYS + [ RPARENT , COMMA ] ) ; 
4008  9614 6  0                  if GATTR . TYPTR = NIL then 
4009  9614 6  1                    begin 
4010  9622 6  2                      if ( LKEY = 1 ) or ( LKEY = 3 ) then 
4011  9624 6  3                        FCP := FILECP -> . NEXT 
4012  9628 6  4                      else 
4013  9631 6  3                        FCP := FILECP ; 
4014  9640 6  2                      GEN1 ( 37 , FCP -> . VADDR ) ; 
4015  9645 6  2                      GATTR . TYPTR := FCP -> . IDTYPE ; 
4016  9648 6  2                      GATTR . ACP := FCP ; 
4017  9648 6  2                    end (* then *) 
4018  9649 6  2                  else 
4019  9649 6  1                    begin 
4020  9652 6  2                      FCP := GATTR . ACP ; 
4021  9654 6  2                      LOADADDRESS ; 
4022  9660 6  2                      if GATTR . TYPTR -> . FORM <> FILES then 
4023  9660 6  3                        begin 
4024  9664 6  4                          ERROR ( 116 ) ; 
4025  9669 6  4                          GATTR . TYPTR := FILECP -> . IDTYPE ; 
4026  9669 6  4                        end (* then *) ; 
4027  9669 6  2                    end (* else *) ; 
4028  9673 6  0                  if LKEY <= 2 then 
4029  9673 6  1                    begin 
4030  9677 6  2                      if SY = COMMA then 
4031  9677 6  3                        begin 
4032  9681 6  4                          ERROR ( 4 ) ; 
4033  9686 6  4                          SKIP ( FSYS + [ RPARENT ] ) ; 
4034  9686 6  4                        end (* then *) ; 
4035  9691 6  2                      GEN1 ( 30 , LKEY ) 
4036  9693 6  3                    end (* then *) 
4037  9694 6  2                  else 
4038  9694 6  1                    begin 
4039  9698 6  2                      if GATTR . TYPTR = TEXTPTR then 
4040  9705 6  3                        GEN2 ( 51 , 1 , 0 ) 
4041  9708 6  4                      else 
4042  9717 6  3                        GEN2 ( 51 , 1 , GATTR . TYPTR -> . FILTYPE -> . 
4043  9721 6  4                               SIZE ) ; 
4044  9725 6  2                      if SY = COMMA then 
4045  9725 6  3                        begin 
4046  9727 6  4                          INSYMBOL ; 
4047  9729 6  4                          SLEN := 0 ; 
4048  9734 6  4                          EXPRESSION ( FSYS + [ RPARENT ] ) ; 
4049  9739 6  4                          if not ISSTRING ( GATTR . TYPTR ) then 
4050  9741 6  5                            ERROR ( 116 ) 
4051  9744 6  6                          else 
4052  9744 6  5                            with GATTR do 
4053  9744 6  6                              begin 
4054  9748 6  7                                if KIND = CST then 
4055  9750 6  8                                  SLEN := CVAL . VALP -> . SLGTH 
4056  9753 6  9                                else 
4057  9757 6  8                                  SLEN := TYPTR -> . SIZE ; 
4058  9757 6  7                              end (* with *) ; 
4059  9766 6  4                          GEN2 ( 51 , 1 , SLEN ) ; 
4060  9768 6  4                          LOADADDRESS ; 
4061  9768 6  4                        end (* then *) 
4062  9769 6  4                      else 
4063  9773 6  3                        if FCP = FILECP then 
4064  9773 6  4                          begin 
4065  9780 6  5                            WRITELN ( PRR , ' LDCI     1  ; output' ) ; 
4066  9789 6  5                            GEN2 ( 51 , 1 , 0 ) ; 
4067  9789 6  5                          end (* then *) 
4068  9790 6  5                        else 
4069  9796 6  4                          if FCP = FILECP -> . NEXT then 
4070  9796 6  5                            begin 
4071  9803 6  6                              WRITELN ( PRR , ' LDCI     0  ; input' ) ; 
4072  9812 6  6                              GEN2 ( 51 , 1 , 0 ) ; 
4073  9812 6  6                            end (* then *) 
4074  9813 6  6                          else 
4075  9816 6  5                            with FCP -> do 
4076  9816 6  6                              begin 
4077  9818 6  7                                SLEN := 0 ; 
4078  9823 6  7                                for I := 1 to ALPHALEN do 
4079  9832 6  8                                  if NAME [ I ] <> ' ' then 
4080  9837 6  9                                    SLEN := SUCC ( SLEN ) ; 
4081  9848 6  7                                GEN2 ( 51 , 1 , SLEN + 4 ) ; 
4082  9853 6  7                                WRITE ( PRR , ' LCA''' ) ; 
4083  9858 6  7                                for I := 1 to SLEN do 
4084  9869 6  8                                  WRITE ( PRR , NAME [ I ] ) ; 
4085  9876 6  7                                WRITELN ( PRR , '.dat''' ) ; 
4086  9876 6  7                              end (* with *) ; 
4087  9885 6  2                      GEN1 ( 30 , LKEY + 21 ) ; 
4088  9885 6  2                    end (* else *) 
4089  9886 6  2                end (* GETPUTRESETREWRITE *) ; 
4090  9886 6  0  
4091  9886 6  0  
4092  9886 6  0             procedure SREAD ; 
4093  9886 6  0  
4094    -8 6  0                var LCP , FCP : CTP ; 
4095   -12 6  0                    LLEV : LEVRANGE ; 
4096   -16 6  0                    LADDR : ADDRRANGE ; 
4097   -20 6  0                    LSP : STP ; 
4098   -24 6  0                    N : INTEGER ; 
4099   -24 6  0  
4100  9886 6  0                begin (* SREAD *) 
4101  9891 6  0                  LLEV := 1 ; 
4102  9898 6  0                  LADDR := FILECP -> . NEXT -> . VADDR ; 
4103  9902 6  0                  if SY = LPARENT then 
4104  9902 6  1                    begin 
4105  9904 6  2                      INSYMBOL ; 
4106  9909 6  2                      VARIABLE ( FSYS + [ COMMA , RPARENT ] ) ; 
4107  9912 6  2                      LSP := GATTR . TYPTR ; 
4108  9915 6  2                      TEST := FALSE ; 
4109  9919 6  2                      if LSP <> NIL then 
4110  9925 6  3                        if LSP -> . FORM = FILES then 
4111  9928 6  4                          with GATTR , LSP -> do 
4112  9928 6  5                            begin 
4113  9933 6  6                              if FILTYPE = CHARPTR then 
4114  9933 6  7                                begin 
4115  9936 6  8                                  LLEV := VLEVEL ; 
4116  9939 6  8                                  LADDR := DPLMT ; 
4117  9939 6  8                                end (* then *) 
4118  9940 6  8                              else 
4119  9944 6  7                                ERROR ( 399 ) ; 
4120  9948 6  6                              if SY = RPARENT then 
4121  9948 6  7                                begin 
4122  9952 6  8                                  if LKEY = 8 then 
4123  9956 6  9                                    ERROR ( 116 ) ; 
4124  9956 6  8                                  TEST := TRUE 
4125  9959 6  9                                end (* then *) 
4126  9960 6  8                              else 
4127  9964 6  7                                if SY <> COMMA then 
4128  9964 6  8                                  begin 
4129  9968 6  9                                    ERROR ( 116 ) ; 
4130  9971 6  9                                    SKIP ( FSYS + [ COMMA , RPARENT ] ) 
4131  9973 6 10                                  end (* then *) ; 
4132  9977 6  6                              if SY = COMMA then 
4133  9977 6  7                                begin 
4134  9979 6  8                                  INSYMBOL ; 
4135  9980 6  8                                  VARIABLE ( FSYS + [ COMMA , RPARENT ] 
4136  9982 6  9                                             ) 
4137  9984 6  9                                end (* then *) 
4138  9985 6  8                              else 
4139  9985 6  7                                TEST := TRUE 
4140  9988 6  8                            end (* with *) ; 
4141  9991 6  2                      if not TEST then 
4142  9991 6  3                        repeat 
4143  9993 6  4                          LOADADDRESS ; 
4144 10004 6  4                          GEN2 ( 50 , LEVEL - LLEV , LADDR ) ; 
4145 10008 6  4                          if GATTR . TYPTR <> NIL then 
4146 10014 6  5                            if GATTR . TYPTR -> . FORM <= SUBRANGE then 
4147 10016 6  6                              if COMPTYPES ( INTPTR , GATTR . TYPTR ) 
4148 10019 6  7                              then 
4149 10024 6  7                                GEN1 ( 30 , 3 ) 
4150 10027 6  8                              else 
4151 10029 6  7                                if COMPTYPES ( REALPTR , GATTR . TYPTR ) 
4152 10032 6  8                                then 
4153 10037 6  8                                  GEN1 ( 30 , 4 ) 
4154 10040 6  9                                else 
4155 10044 6  8                                  if CHARPTR = GATTR . TYPTR then 
4156 10049 6  9                                    GEN1 ( 30 , 5 ) 
4157 10052 6 10                                  else 
4158 10054 6  9                                    ERROR ( 399 ) 
4159 10057 6 10                            else 
4160 10061 6  6                              if ISSTRING ( GATTR . TYPTR ) then 
4161 10061 6  7                                begin 
4162 10065 6  8                                  N := GATTR . TYPTR -> . SIZE ; 
4163 10069 6  8                                  if GATTR . TYPTR -> . VARY then 
4164 10072 6  9                                    N := - N ; 
4165 10081 6  8                                  GEN2 ( 51 , 1 , N ) ; 
4166 10088 6  8                                  GEN1 ( 30 , 6 ) ; 
4167 10088 6  8                                end (* then *) 
4168 10089 6  8                              else 
4169 10093 6  7                                ERROR ( 116 ) ; 
4170 10098 6  4                          TEST := SY <> COMMA ; 
4171 10101 6  4                          if not TEST then 
4172 10101 6  5                            begin 
4173 10103 6  6                              INSYMBOL ; 
4174 10106 6  6                              VARIABLE ( FSYS + [ COMMA , RPARENT ] ) 
4175 10108 6  7                            end (* then *) 
4176 10110 6  6                        until TEST ; 
4177 10114 6  2                      if SY = RPARENT then 
4178 10114 6  3                        INSYMBOL 
4179 10117 6  4                      else 
4180 10119 6  3                        ERROR ( 4 ) 
4181 10121 6  4                    end (* then *) 
4182 10122 6  2                  else 
4183 10126 6  1                    if LKEY = 5 then 
4184 10130 6  2                      ERROR ( 116 ) ; 
4185 10134 6  0                  if LKEY = 11 then 
4186 10134 6  1                    begin 
4187 10145 6  2                      GEN2 ( 50 , LEVEL - LLEV , LADDR ) ; 
4188 10150 6  2                      GEN1 ( 30 , 21 ) 
4189 10152 6  3                    end (* then *) 
4190 10153 6  2                end (* SREAD *) ; 
4191 10153 6  0  
4192 10153 6  0  
4193 10153 6  0             procedure SWRITE ; 
4194 10153 6  0  
4195    -4 6  0                var LSP : STP ; 
4196    -5 6  0                    DEFAULT : BOOLEAN ; 
4197   -10 6  0                    LLKEY : 1 .. 15 ; 
4198   -14 6  0                    LCP : CTP ; 
4199   -18 6  0                    LLEV : LEVRANGE ; 
4200   -26 6  0                    LADDR , LEN : ADDRRANGE ; 
4201   -26 6  0  
4202 10153 6  0                begin (* SWRITE *) 
4203 10158 6  0                  LLKEY := LKEY ; 
4204 10161 6  0                  LLEV := 1 ; 
4205 10166 6  0                  LADDR := FILECP -> . VADDR ; 
4206 10170 6  0                  if SY = LPARENT then 
4207 10170 6  1                    begin 
4208 10172 6  2                      INSYMBOL ; 
4209 10175 6  2                      EXPRESSION ( FSYS + [ COMMA , COLON , RPARENT ] ) 
4210 10177 6  3                                   ; 
4211 10180 6  2                      LSP := GATTR . TYPTR ; 
4212 10183 6  2                      TEST := FALSE ; 
4213 10187 6  2                      if LSP <> NIL then 
4214 10193 6  3                        if LSP -> . FORM = FILES then 
4215 10196 6  4                          with GATTR , LSP -> do 
4216 10196 6  5                            begin 
4217 10201 6  6                              if FILTYPE = CHARPTR then 
4218 10201 6  7                                begin 
4219 10204 6  8                                  LLEV := VLEVEL ; 
4220 10204 6  8                                  LADDR := DPLMT 
4221 10207 6  9                                end (* then *) 
4222 10208 6  8                              else 
4223 10212 6  7                                ERROR ( 399 ) ; 
4224 10216 6  6                              if SY = RPARENT then 
4225 10216 6  7                                begin 
4226 10220 6  8                                  if LLKEY = 10 then 
4227 10224 6  9                                    ERROR ( 116 ) ; 
4228 10224 6  8                                  TEST := TRUE 
4229 10227 6  9                                end (* then *) 
4230 10228 6  8                              else 
4231 10232 6  7                                if SY <> COMMA then 
4232 10232 6  8                                  begin 
4233 10236 6  9                                    ERROR ( 116 ) ; 
4234 10239 6  9                                    SKIP ( FSYS + [ COMMA , RPARENT ] ) 
4235 10241 6 10                                  end (* then *) ; 
4236 10245 6  6                              if SY = COMMA then 
4237 10245 6  7                                begin 
4238 10247 6  8                                  INSYMBOL ; 
4239 10248 6  8                                  EXPRESSION ( FSYS + [ COMMA , COLON , 
4240 10250 6  9                                               RPARENT ] ) 
4241 10252 6  9                                end (* then *) 
4242 10253 6  8                              else 
4243 10253 6  7                                TEST := TRUE 
4244 10256 6  8                            end (* with *) ; 
4245 10259 6  2                      if not TEST then 
4246 10259 6  3                        repeat 
4247 10262 6  4                          LSP := GATTR . TYPTR ; 
4248 10266 6  4                          if LSP <> NIL then 
4249 10272 6  5                            if LSP -> . FORM <= SUBRANGE then 
4250 10272 6  6                              LOAD 
4251 10275 6  7                            else 
4252 10277 6  6                              LOADADDRESS ; 
4253 10281 6  4                          if SY = COLON then 
4254 10281 6  5                            begin 
4255 10283 6  6                              INSYMBOL ; 
4256 10284 6  6                              EXPRESSION ( FSYS + [ COMMA , COLON , 
4257 10288 6  7                                           RPARENT ] ) ; 
4258 10292 6  6                              if GATTR . TYPTR <> NIL then 
4259 10296 6  7                                if GATTR . TYPTR <> INTPTR then 
4260 10300 6  8                                  ERROR ( 116 ) ; 
4261 10302 6  6                              LOAD ; 
4262 10302 6  6                              DEFAULT := FALSE 
4263 10305 6  7                            end (* then *) 
4264 10306 6  6                          else 
4265 10309 6  5                            DEFAULT := TRUE ; 
4266 10313 6  4                          if SY = COLON then 
4267 10313 6  5                            begin 
4268 10315 6  6                              INSYMBOL ; 
4269 10318 6  6                              EXPRESSION ( FSYS + [ COMMA , RPARENT ] ) 
4270 10320 6  7                                           ; 
4271 10324 6  6                              if GATTR . TYPTR <> NIL then 
4272 10328 6  7                                if GATTR . TYPTR <> INTPTR then 
4273 10332 6  8                                  ERROR ( 116 ) ; 
4274 10336 6  6                              if LSP <> REALPTR then 
4275 10340 6  7                                ERROR ( 124 ) ; 
4276 10342 6  6                              LOAD ; 
4277 10346 6  6                              ERROR ( 399 ) ; 
4278 10346 6  6                            end (* then *) 
4279 10347 6  6                          else 
4280 10351 6  5                            if LSP = INTPTR then 
4281 10351 6  6                              begin 
4282 10353 6  7                                if DEFAULT then 
4283 10362 6  8                                  GEN2 ( 51 , 1 , 1 ) ; 
4284 10373 6  7                                GEN2 ( 50 , LEVEL - LLEV , LADDR ) ; 
4285 10378 6  7                                GEN1 ( 30 , 7 ) 
4286 10380 6  8                              end (* then *) 
4287 10381 6  7                            else 
4288 10385 6  6                              if LSP = REALPTR then 
4289 10385 6  7                                begin 
4290 10387 6  8                                  if DEFAULT then 
4291 10396 6  9                                    GEN2 ( 51 , 1 , 1 ) ; 
4292 10407 6  8                                  GEN2 ( 50 , LEVEL - LLEV , LADDR ) ; 
4293 10412 6  8                                  GEN1 ( 30 , 8 ) 
4294 10414 6  9                                end (* then *) 
4295 10415 6  8                              else 
4296 10419 6  7                                if LSP = CHARPTR then 
4297 10419 6  8                                  begin 
4298 10421 6  9                                    if DEFAULT then 
4299 10430 6 10                                      GEN2 ( 51 , 1 , 1 ) ; 
4300 10441 6  9                                    GEN2 ( 50 , LEVEL - LLEV , LADDR ) ; 
4301 10446 6  9                                    GEN1 ( 30 , 9 ) 
4302 10448 6 10                                  end (* then *) 
4303 10449 6  9                                else 
4304 10453 6  8                                  if LSP <> NIL then 
4305 10453 6  9                                    begin 
4306 10459 6 10                                      if LSP -> . FORM = SCALAR then 
4307 10461 6 11                                        ERROR ( 399 ) 
4308 10464 6 12                                      else 
4309 10468 6 11                                        if ISSTRING ( LSP ) then 
4310 10468 6 12                                          begin 
4311 10471 6 13                                            LEN := LSP -> . SIZE DIV 
4312 10475 6 14                                                   CHARMAX ; 
4313 10479 6 13                                            if LSP -> . VARY then 
4314 10483 6 14                                              LEN := PRED ( LEN ) ; 
4315 10485 6 13                                            if DEFAULT then 
4316 10494 6 14                                              GEN2 ( 51 , 1 , 0 ) ; 
4317 10503 6 13                                            GEN2 ( 51 , 1 , LEN ) ; 
4318 10510 6 13                                            GEN2 ( 50 , LEVEL - LLEV , 
4319 10514 6 14                                                   LADDR ) ; 
4320 10519 6 13                                            GEN1 ( 30 , 10 ) 
4321 10521 6 14                                          end (* then *) 
4322 10522 6 13                                        else 
4323 10524 6 12                                          ERROR ( 116 ) 
4324 10526 6 13                                    end (* then *) ; 
4325 10531 6  4                          TEST := SY <> COMMA ; 
4326 10534 6  4                          if not TEST then 
4327 10534 6  5                            begin 
4328 10536 6  6                              INSYMBOL ; 
4329 10537 6  6                              EXPRESSION ( FSYS + [ COMMA , COLON , 
4330 10539 6  7                                           RPARENT ] ) 
4331 10541 6  7                            end (* then *) 
4332 10543 6  6                        until TEST ; 
4333 10547 6  2                      if SY = RPARENT then 
4334 10547 6  3                        INSYMBOL 
4335 10550 6  4                      else 
4336 10552 6  3                        ERROR ( 4 ) 
4337 10554 6  4                    end (* then *) 
4338 10555 6  2                  else 
4339 10559 6  1                    if LKEY = 6 then 
4340 10563 6  2                      ERROR ( 116 ) ; 
4341 10567 6  0                  if LLKEY = 12 then 
4342 10567 6  1                    begin 
4343 10578 6  2                      GEN2 ( 50 , LEVEL - LLEV , LADDR ) ; 
4344 10583 6  2                      GEN1 ( 30 , 22 ) 
4345 10585 6  3                    end (* then *) 
4346 10586 6  2                end (* SWRITE *) ; 
4347 10586 6  0  
4348 10586 6  0  
4349 10586 6  0             procedure SPACK ; 
4350 10586 6  0  
4351    -8 6  0                var LSP , LSP1 : STP ; 
4352    -8 6  0  
4353 10586 6  0                begin (* SPACK *) 
4354 10592 6  0                  ERROR ( 399 ) ; 
4355 10597 6  0                  VARIABLE ( FSYS + [ COMMA , RPARENT ] ) ; 
4356 10600 6  0                  LSP := NIL ; 
4357 10603 6  0                  LSP1 := NIL ; 
4358 10607 6  0                  if GATTR . TYPTR <> NIL then 
4359 10610 6  1                    with GATTR . TYPTR -> do 
4360 10615 6  2                      if FORM = ARRAYS then 
4361 10615 6  3                        begin 
4362 10619 6  4                          LSP := INXTYPE ; 
4363 10619 6  4                          LSP1 := AELTYPE 
4364 10623 6  5                        end (* then *) 
4365 10624 6  4                      else 
4366 10628 6  3                        ERROR ( 116 ) ; 
4367 10632 6  0                  if SY = COMMA then 
4368 10632 6  1                    INSYMBOL 
4369 10635 6  2                  else 
4370 10639 6  1                    ERROR ( 20 ) ; 
4371 10644 6  0                  EXPRESSION ( FSYS + [ COMMA , RPARENT ] ) ; 
4372 10648 6  0                  if GATTR . TYPTR <> NIL then 
4373 10654 6  1                    if GATTR . TYPTR -> . FORM <> SCALAR then 
4374 10656 6  2                      ERROR ( 116 ) 
4375 10659 6  3                    else 
4376 10665 6  2                      if not COMPTYPES ( LSP , GATTR . TYPTR ) then 
4377 10669 6  3                        ERROR ( 116 ) ; 
4378 10673 6  0                  if SY = COMMA then 
4379 10673 6  1                    INSYMBOL 
4380 10676 6  2                  else 
4381 10680 6  1                    ERROR ( 20 ) ; 
4382 10685 6  0                  VARIABLE ( FSYS + [ RPARENT ] ) ; 
4383 10689 6  0                  if GATTR . TYPTR <> NIL then 
4384 10692 6  1                    with GATTR . TYPTR -> do 
4385 10697 6  2                      if FORM = ARRAYS then 
4386 10697 6  3                        begin 
4387 10703 6  4                          if not COMPTYPES ( AELTYPE , LSP1 ) or not 
4388 10711 6  5                          COMPTYPES ( INXTYPE , LSP ) then 
4389 10713 6  5                            ERROR ( 116 ) 
4390 10715 6  6                        end (* then *) 
4391 10716 6  4                      else 
4392 10718 6  3                        ERROR ( 116 ) 
4393 10721 6  4                end (* SPACK *) ; 
4394 10721 6  0  
4395 10721 6  0  
4396 10721 6  0             procedure SUNPACK ; 
4397 10721 6  0  
4398    -8 6  0                var LSP , LSP1 : STP ; 
4399    -8 6  0  
4400 10721 6  0                begin (* SUNPACK *) 
4401 10727 6  0                  ERROR ( 399 ) ; 
4402 10732 6  0                  VARIABLE ( FSYS + [ COMMA , RPARENT ] ) ; 
4403 10735 6  0                  LSP := NIL ; 
4404 10738 6  0                  LSP1 := NIL ; 
4405 10742 6  0                  if GATTR . TYPTR <> NIL then 
4406 10745 6  1                    with GATTR . TYPTR -> do 
4407 10750 6  2                      if FORM = ARRAYS then 
4408 10750 6  3                        begin 
4409 10754 6  4                          LSP := INXTYPE ; 
4410 10754 6  4                          LSP1 := AELTYPE 
4411 10758 6  5                        end (* then *) 
4412 10759 6  4                      else 
4413 10763 6  3                        ERROR ( 116 ) ; 
4414 10767 6  0                  if SY = COMMA then 
4415 10767 6  1                    INSYMBOL 
4416 10770 6  2                  else 
4417 10774 6  1                    ERROR ( 20 ) ; 
4418 10779 6  0                  VARIABLE ( FSYS + [ COMMA , RPARENT ] ) ; 
4419 10783 6  0                  if GATTR . TYPTR <> NIL then 
4420 10786 6  1                    with GATTR . TYPTR -> do 
4421 10791 6  2                      if FORM = ARRAYS then 
4422 10791 6  3                        begin 
4423 10797 6  4                          if not COMPTYPES ( AELTYPE , LSP1 ) or not 
4424 10805 6  5                          COMPTYPES ( INXTYPE , LSP ) then 
4425 10807 6  5                            ERROR ( 116 ) 
4426 10809 6  6                        end (* then *) 
4427 10810 6  4                      else 
4428 10814 6  3                        ERROR ( 116 ) ; 
4429 10818 6  0                  if SY = COMMA then 
4430 10818 6  1                    INSYMBOL 
4431 10821 6  2                  else 
4432 10825 6  1                    ERROR ( 20 ) ; 
4433 10830 6  0                  EXPRESSION ( FSYS + [ RPARENT ] ) ; 
4434 10834 6  0                  if GATTR . TYPTR <> NIL then 
4435 10840 6  1                    if GATTR . TYPTR -> . FORM <> SCALAR then 
4436 10842 6  2                      ERROR ( 116 ) 
4437 10845 6  3                    else 
4438 10851 6  2                      if not COMPTYPES ( LSP , GATTR . TYPTR ) then 
4439 10855 6  3                        ERROR ( 116 ) ; 
4440 10856 6  0                end (* SUNPACK *) ; 
4441 10856 6  0  
4442 10856 6  0  
4443 10856 6  0             procedure SNEW ; 
4444 10856 6  0  
4445     0 6  0                label 1 ; 
4446     0 6  0  
4447    -8 6  0                var LSP , LSP1 : STP ; 
4448   -20 6  0                    VARTS , LMIN , LMAX : INTEGER ; 
4449   -28 6  0                    LSIZE , LSZ : ADDRRANGE ; 
4450   -34 6  0                    LVAL : VALU ; 
4451   -34 6  0  
4452 10856 6  0                begin (* SNEW *) 
4453 10863 6  0                  VARIABLE ( FSYS + [ COMMA , RPARENT ] ) ; 
4454 10865 6  0                  LOADADDRESS ; 
4455 10868 6  0                  LSP := NIL ; 
4456 10870 6  0                  VARTS := 0 ; 
4457 10873 6  0                  LSIZE := 0 ; 
4458 10877 6  0                  if GATTR . TYPTR <> NIL then 
4459 10880 6  1                    with GATTR . TYPTR -> do 
4460 10885 6  2                      if FORM = POINTER then 
4461 10885 6  3                        begin 
4462 10890 6  4                          if ELTYPE <> NIL then 
4463 10890 6  5                            begin 
4464 10896 6  6                              LSIZE := ELTYPE -> . SIZE ; 
4465 10903 6  6                              if ELTYPE -> . FORM = RECORDS then 
4466 10906 6  7                                LSP := ELTYPE -> . RECVAR 
4467 10909 6  8                            end (* then *) 
4468 10909 6  6                        end (* then *) 
4469 10910 6  4                      else 
4470 10914 6  3                        ERROR ( 116 ) ; 
4471 10918 6  0                  while SY = COMMA do 
4472 10918 6  1                    begin 
4473 10920 6  2                      INSYMBOL ; 
4474 10924 6  2                      CONSTANT ( FSYS + [ COMMA , RPARENT ] , LSP1 , 
4475 10927 6  3                                 LVAL ) ; 
4476 10931 6  2                      VARTS := VARTS + 1 ; 
4477 10935 6  2                      if LSP = NIL then 
4478 10937 6  3                        ERROR ( 158 ) 
4479 10940 6  4                      else 
4480 10946 6  3                        if LSP -> . FORM <> TAGFLD then 
4481 10948 6  4                          ERROR ( 162 ) 
4482 10951 6  5                        else 
4483 10957 6  4                          if LSP -> . TAGFIELDP <> NIL then 
4484 10963 6  5                            if ISSTRING ( LSP1 ) or ( LSP1 = REALPTR ) 
4485 10965 6  6                            then 
4486 10967 6  6                              ERROR ( 159 ) 
4487 10970 6  7                            else 
4488 10974 6  6                              if COMPTYPES ( LSP -> . TAGFIELDP , LSP1 ) 
4489 10977 6  7                              then 
4490 10977 6  7                                begin 
4491 10982 6  8                                  LSP1 := LSP -> . FSTVAR ; 
4492 10986 6  8                                  while LSP1 <> NIL do 
4493 10989 6  9                                    with LSP1 -> do 
4494 10991 6 10                                      if VARVAL . IVAL = LVAL . IVAL 
4495 10994 6 11                                      then 
4496 10994 6 11                                        begin 
4497 10998 6 12                                          LSIZE := SIZE ; 
4498 11002 6 12                                          LSP := SUBVAR ; 
4499 11003 6 12                                          goto 1 
4500 11003 6 13                                        end (* then *) 
4501 11004 6 12                                      else 
4502 11009 6 11                                        LSP1 := NXTVAR ; 
4503 11014 6  8                                  LSIZE := LSP -> . SIZE ; 
4504 11017 6  8                                  LSP := NIL ; 
4505 11017 6  8                                end (* then *) 
4506 11018 6  8                              else 
4507 11022 6  7                                ERROR ( 116 ) ; 
4508 11022 6  2                      1 : 
4509 11022 6  3                       
4510 11023 6  3                    end (* while *) ; 
4511 11032 6  0                  GEN2 ( 51 , 1 , LSIZE ) ; 
4512 11039 6  0                  GEN1 ( 30 , 12 ) ; 
4513 11040 6  0                end (* SNEW *) ; 
4514 11040 6  0  
4515 11040 6  0  
4516 11040 6  0             procedure SMARK ; 
4517 11040 6  0  
4518 11040 6  0                begin (* SMARK *) 
4519 11047 6  0                  VARIABLE ( FSYS + [ RPARENT ] ) ; 
4520 11051 6  0                  if GATTR . TYPTR <> NIL then 
4521 11057 6  1                    if GATTR . TYPTR -> . FORM = POINTER then 
4522 11057 6  2                      begin 
4523 11059 6  3                        LOADADDRESS ; 
4524 11064 6  3                        GEN1 ( 30 , 23 ) 
4525 11066 6  4                      end (* then *) 
4526 11067 6  3                    else 
4527 11069 6  2                      ERROR ( 125 ) 
4528 11072 6  3                end (* SMARK *) ; 
4529 11072 6  0  
4530 11072 6  0  
4531 11072 6  0             procedure SRELEASE ; 
4532 11072 6  0  
4533 11072 6  0                begin (* SRELEASE *) 
4534 11079 6  0                  VARIABLE ( FSYS + [ RPARENT ] ) ; 
4535 11083 6  0                  if GATTR . TYPTR <> NIL then 
4536 11089 6  1                    if GATTR . TYPTR -> . FORM = POINTER then 
4537 11089 6  2                      begin 
4538 11091 6  3                        LOAD ; 
4539 11096 6  3                        GEN1 ( 30 , 13 ) 
4540 11098 6  4                      end (* then *) 
4541 11099 6  3                    else 
4542 11101 6  2                      ERROR ( 125 ) 
4543 11104 6  3                end (* SRELEASE *) ; 
4544 11104 6  0  
4545 11104 6  0  
4546 11104 6  0             procedure SABS ; 
4547 11104 6  0  
4548 11104 6  0                begin (* SABS *) 
4549 11110 6  0                  if GATTR . TYPTR <> NIL then 
4550 11114 6  1                    if GATTR . TYPTR = INTPTR then 
4551 11117 6  2                      GEN0 ( 0 ) 
4552 11120 6  3                    else 
4553 11124 6  2                      if GATTR . TYPTR = REALPTR then 
4554 11127 6  3                        GEN0 ( 1 ) 
4555 11130 6  4                      else 
4556 11130 6  3                        begin 
4557 11134 6  4                          ERROR ( 125 ) ; 
4558 11134 6  4                          GATTR . TYPTR := INTPTR 
4559 11137 6  5                        end (* else *) 
4560 11138 6  4                end (* SABS *) ; 
4561 11138 6  0  
4562 11138 6  0  
4563 11138 6  0             procedure SSQR ; 
4564 11138 6  0  
4565 11138 6  0                begin (* SSQR *) 
4566 11144 6  0                  if GATTR . TYPTR <> NIL then 
4567 11148 6  1                    if GATTR . TYPTR = INTPTR then 
4568 11151 6  2                      GEN0 ( 24 ) 
4569 11154 6  3                    else 
4570 11158 6  2                      if GATTR . TYPTR = REALPTR then 
4571 11161 6  3                        GEN0 ( 25 ) 
4572 11164 6  4                      else 
4573 11164 6  3                        begin 
4574 11168 6  4                          ERROR ( 125 ) ; 
4575 11168 6  4                          GATTR . TYPTR := INTPTR 
4576 11171 6  5                        end (* else *) 
4577 11172 6  4                end (* SSQR *) ; 
4578 11172 6  0  
4579 11172 6  0  
4580 11172 6  0             procedure STRUNC ; 
4581 11172 6  0  
4582 11172 6  0                begin (* STRUNC *) 
4583 11178 6  0                  if GATTR . TYPTR <> NIL then 
4584 11182 6  1                    if GATTR . TYPTR <> REALPTR then 
4585 11186 6  2                      ERROR ( 125 ) ; 
4586 11191 6  0                  GEN0 ( 27 ) ; 
4587 11191 6  0                  GATTR . TYPTR := INTPTR 
4588 11195 6  1                end (* STRUNC *) ; 
4589 11195 6  0  
4590 11195 6  0  
4591 11195 6  0             procedure SROUND ; 
4592 11195 6  0  
4593 11195 6  0                begin (* SROUND *) 
4594 11201 6  0                  if GATTR . TYPTR <> NIL then 
4595 11205 6  1                    if GATTR . TYPTR <> REALPTR then 
4596 11209 6  2                      ERROR ( 125 ) ; 
4597 11216 6  0                  WRITELN ( PRR , ' CSP  RND' ) ; 
4598 11216 6  0                  GATTR . TYPTR := INTPTR 
4599 11220 6  1                end (* SROUND *) ; 
4600 11220 6  0  
4601 11220 6  0  
4602 11220 6  0             procedure SODD ; 
4603 11220 6  0  
4604 11220 6  0                begin (* SODD *) 
4605 11226 6  0                  if GATTR . TYPTR <> NIL then 
4606 11230 6  1                    if GATTR . TYPTR <> INTPTR then 
4607 11234 6  2                      ERROR ( 125 ) ; 
4608 11239 6  0                  GEN0 ( 20 ) ; 
4609 11239 6  0                  GATTR . TYPTR := BOOLPTR 
4610 11243 6  1                end (* SODD *) ; 
4611 11243 6  0  
4612 11243 6  0  
4613 11243 6  0             procedure SORD ; 
4614 11243 6  0  
4615 11243 6  0                begin (* SORD *) 
4616 11249 6  0                  if GATTR . TYPTR <> NIL then 
4617 11255 6  1                    if GATTR . TYPTR -> . FORM >= POWER then 
4618 11259 6  2                      ERROR ( 125 ) ; 
4619 11265 6  0                  GEN0T ( 58 , GATTR . TYPTR ) ; 
4620 11265 6  0                  GATTR . TYPTR := INTPTR 
4621 11269 6  1                end (* SORD *) ; 
4622 11269 6  0  
4623 11269 6  0  
4624 11269 6  0             procedure SCHR ; 
4625 11269 6  0  
4626 11269 6  0                begin (* SCHR *) 
4627 11275 6  0                  if GATTR . TYPTR <> NIL then 
4628 11279 6  1                    if GATTR . TYPTR <> INTPTR then 
4629 11283 6  2                      ERROR ( 125 ) ; 
4630 11288 6  0                  GEN0 ( 59 ) ; 
4631 11288 6  0                  GATTR . TYPTR := CHARPTR 
4632 11292 6  1                end (* SCHR *) ; 
4633 11292 6  0  
4634 11292 6  0  
4635 11292 6  0             procedure PREDSUCC ; 
4636 11292 6  0  
4637    -4 6  0                var N : INTEGER ; 
4638    -8 6  0                    SP : STP ; 
4639    -8 6  0  
4640 11292 6  0                begin (* PREDSUCC *) 
4641 11298 6  0                  if GATTR . TYPTR <> NIL then 
4642 11304 6  1                    if GATTR . TYPTR -> . FORM > POINTER then 
4643 11308 6  2                      ERROR ( 125 ) ; 
4644 11311 6  0                  SP := GATTR . TYPTR ; 
4645 11313 6  0                  N := 1 ; 
4646 11319 6  0                  if GATTR . TYPTR -> . FORM = POINTER then 
4647 11319 6  1                    begin 
4648 11324 6  2                      SP := GATTR . TYPTR -> . ELTYPE ; 
4649 11328 6  2                      N := SP -> . SIZE ; 
4650 11328 6  2                    end (* then *) ; 
4651 11332 6  0                  if LKEY = 7 then 
4652 11338 6  1                    GEN1T ( 31 , N , SP ) 
4653 11341 6  2                  else 
4654 11347 6  1                    GEN1T ( 34 , N , SP ) 
4655 11350 6  2                end (* PREDSUCC *) ; 
4656 11350 6  0  
4657 11350 6  0  
4658 11350 6  0             procedure SEOF ; 
4659 11350 6  0  
4660 11350 6  0                begin (* SEOF *) 
4661 11356 6  0                  if SY = LPARENT then 
4662 11356 6  1                    begin 
4663 11358 6  2                      INSYMBOL ; 
4664 11363 6  2                      VARIABLE ( FSYS + [ RPARENT ] ) ; 
4665 11367 6  2                      if SY = RPARENT then 
4666 11367 6  3                        INSYMBOL 
4667 11370 6  4                      else 
4668 11372 6  3                        ERROR ( 4 ) 
4669 11374 6  4                    end (* then *) 
4670 11375 6  2                  else 
4671 11375 6  1                    with GATTR do 
4672 11375 6  2                      begin 
4673 11378 6  3                        TYPTR := TEXTPTR ; 
4674 11381 6  3                        KIND := VARBL ; 
4675 11384 6  3                        ACCESS := DRCT ; 
4676 11387 6  3                        VLEVEL := 1 ; 
4677 11394 6  3                        DPLMT := FILECP -> . NEXT -> . VADDR ; 
4678 11394 6  3                      end (* with *) ; 
4679 11396 6  0                  LOADADDRESS ; 
4680 11400 6  0                  if GATTR . TYPTR <> NIL then 
4681 11406 6  1                    if GATTR . TYPTR -> . FORM <> FILES then 
4682 11410 6  2                      ERROR ( 125 ) ; 
4683 11414 6  0                  if LKEY = 9 then 
4684 11417 6  1                    GEN0 ( 8 ) 
4685 11420 6  2                  else 
4686 11427 6  1                    GEN1 ( 30 , 14 ) ; 
4687 11427 6  0                  GATTR . TYPTR := BOOLPTR 
4688 11431 6  1                end (* SEOF *) ; 
4689 11431 6  0  
4690 11431 6  0  
4691 11431 6  0             procedure SSIZEOF ; 
4692 11431 6  0  
4693    -4 6  0                var CP : CTP ; 
4694    -4 6  0  
4695 11431 6  0                begin (* SSIZEOF *) 
4696 11437 6  0                  if SY = LPARENT then 
4697 11437 6  1                    INSYMBOL 
4698 11440 6  2                  else 
4699 11444 6  1                    ERROR ( 9 ) ; 
4700 11448 6  0                  SEARCHID ( [ TYPES , VARS ] , CP ) ; 
4701 11450 6  0                  INSYMBOL ; 
4702 11454 6  0                  if CP <> NIL then 
4703 11460 6  1                    if CP -> . IDTYPE <> NIL then 
4704 11473 6  2                      GEN2 ( 51 , 1 , CP -> . IDTYPE -> . SIZE ) ; 
4705 11476 6  0                  GATTR . TYPTR := INTPTR ; 
4706 11477 6  0                end (* SSIZEOF *) ; 
4707 11477 6  0  
4708 11477 6  0  
4709 11477 6  0             procedure SADDROF ; 
4710 11477 6  0  
4711    -4 6  0                var SP : STP ; 
4712    -4 6  0  
4713 11477 6  0                begin (* SADDROF *) 
4714 11483 6  0                  if SY = LPARENT then 
4715 11483 6  1                    INSYMBOL 
4716 11486 6  2                  else 
4717 11490 6  1                    ERROR ( 9 ) ; 
4718 11495 6  0                  VARIABLE ( FSYS + [ RPARENT ] ) ; 
4719 11497 6  0                  LOADADDRESS ; 
4720 11501 6  0                  if GATTR . TYPTR <> NIL then 
4721 11501 6  1                    begin 
4722 11504 6  2                      NEW ( SP , POINTER ) ; 
4723 11507 6  2                      with SP -> do 
4724 11507 6  3                        begin 
4725 11512 6  4                          SIZE := PTRSIZE ; 
4726 11517 6  4                          FORM := POINTER ; 
4727 11522 6  4                          ELTYPE := GATTR . TYPTR ; 
4728 11522 6  4                        end (* with *) ; 
4729 11525 6  2                      GATTR . TYPTR := SP ; 
4730 11525 6  2                    end (* then *) 
4731 11526 6  2                end (* SADDROF *) ; 
4732 11526 6  0  
4733 11526 6  0  
4734 11526 6  0             procedure CALLNONSTANDARD ; 
4735 11526 6  0  
4736     0 6  0                label 1 ; 
4737     0 6  0  
4738    -8 6  0                var NXT , LCP : CTP ; 
4739   -12 6  0                    LSP : STP ; 
4740   -16 6  0                    LKIND : IDKIND ; 
4741   -17 6  0                    LB : BOOLEAN ; 
4742   -22 6  0                    LLC : ADDRRANGE ; 
4743   -34 6  0                    LOCPAR , FRESSIZE , I : INTEGER ; 
4744   -35 6  0                    C : CHAR ; 
4745   -35 6  0  
4746 11526 6  0                begin (* CALLNONSTANDARD *) 
4747 11530 6  0                  LOCPAR := 0 ; 
4748 11533 6  0                  with FCP -> do 
4749 11533 6  1                    begin 
4750 11537 6  2                      NXT := NEXT ; 
4751 11541 6  2                      LKIND := PFKIND ; 
4752 11546 6  2                      if PFLEV < MIN_LEVEL then 
4753 11550 6  3                        ERROR ( 59 ) ; 
4754 11550 6  2                    end (* with *) ; 
4755 11554 6  0                  if SY = LPARENT then 
4756 11554 6  1                    begin 
4757 11557 6  2                      LLC := LC ; 
4758 11557 6  2                      repeat 
4759 11560 6  3                        LB := FALSE ; 
4760 11564 6  3                        if LKIND = ACTUAL then 
4761 11564 6  4                          begin 
4762 11570 6  5                            if ( NXT = NIL ) and ( FCP -> . PF_ATTR <> 
4763 11574 6  6                            IMPRT ) then 
4764 11576 6  6                              ERROR ( 126 ) 
4765 11579 6  7                            else 
4766 11583 6  6                              LB := NXT -> . KLASS in [ PROC , FUNC ] 
4767 11587 6  7                          end (* then *) 
4768 11588 6  5                        else 
4769 11592 6  4                          ERROR ( 399 ) ; 
4770 11594 6  3                        if LB then 
4771 11594 6  4                          begin 
4772 11596 6  5                            INSYMBOL ; 
4773 11600 6  5                            ERROR ( 399 ) ; 
4774 11604 6  5                            if SY <> IDENT then 
4775 11604 6  6                              begin 
4776 11608 6  7                                ERROR ( 2 ) ; 
4777 11611 6  7                                SKIP ( FSYS + [ COMMA , RPARENT ] ) 
4778 11613 6  8                              end (* then *) 
4779 11614 6  7                            else 
4780 11614 6  6                              begin 
4781 11620 6  7                                if NXT -> . KLASS = PROC then 
4782 11622 6  8                                  SEARCHID ( [ PROC ] , LCP ) 
4783 11625 6  9                                else 
4784 11625 6  8                                  begin 
4785 11629 6  9                                    SEARCHID ( [ FUNC ] , LCP ) ; 
4786 11632 6  9                                    if not COMPTYPES ( LCP -> . IDTYPE , 
4787 11639 6 10                                    NXT -> . IDTYPE ) then 
4788 11641 6 10                                      ERROR ( 128 ) 
4789 11643 6 11                                  end (* else *) ; 
4790 11645 6  7                                INSYMBOL ; 
4791 11648 6  7                                if not ( SY in FSYS + [ COMMA , RPARENT 
4792 11653 6  8                                ] ) then 
4793 11653 6  8                                  begin 
4794 11657 6  9                                    ERROR ( 6 ) ; 
4795 11660 6  9                                    SKIP ( FSYS + [ COMMA , RPARENT ] ) 
4796 11662 6 10                                  end (* then *) 
4797 11662 6  9                              end (* else *) 
4798 11662 6  7                          end (* then *) 
4799 11663 6  5                        else 
4800 11663 6  4                          begin 
4801 11667 6  5                            if NXT <> NIL then 
4802 11671 6  6                              EXPECTSTRING := ( NXT -> . IDTYPE -> . 
4803 11676 6  7                                              FORM = ARRAYS ) ; 
4804 11678 6  5                            INSYMBOL ; 
4805 11683 6  5                            EXPRESSION ( FSYS + [ COMMA , RPARENT ] ) ; 
4806 11686 6  5                            EXPECTSTRING := FALSE ; 
4807 11690 6  5                            if GATTR . TYPTR <> NIL then 
4808 11694 6  6                              if LKIND = ACTUAL then 
4809 11694 6  7                                begin 
4810 11697 6  8                                  LOCPAR := SUCC ( LOCPAR ) ; 
4811 11701 6  8                                  if NXT <> NIL then 
4812 11701 6  9                                    begin 
4813 11706 6 10                                      LSP := NXT -> . IDTYPE ; 
4814 11710 6 10                                      if LSP <> NIL then 
4815 11710 6 11                                        begin 
4816 11715 6 12                                          if ( NXT -> . VKIND = ACTUAL ) 
4817 11716 6 13                                          then 
4818 11719 6 13                                            if LSP -> . FORM <= POWER 
4819 11722 6 14                                            then 
4820 11722 6 14                                              begin 
4821 11725 6 15                                                if LSP -> . FORM = POWER 
4822 11728 6 16                                                then 
4823 11728 6 16                                                  LOCPAR := PRED ( 
4824 11730 6 17                                                    LOCPAR ) + SETSIZE 
4825 11735 6 17                                                    DIV PARMSIZE ; 
4826 11737 6 15                                                LOAD ; 
4827 11739 6 15                                                if DEBUG then 
4828 11742 6 16                                                  CHECKBNDS ( LSP ) ; 
4829 11743 6 15                                                if ( GATTR . TYPTR = 
4830 11746 6 16                                                INTPTR ) and ( LSP = 
4831 11750 6 16                                                REALPTR ) then 
4832 11750 6 16                                                  begin 
4833 11755 6 17                                                    GEN0 ( 10 ) ; 
4834 11755 6 17                                                    GATTR . TYPTR := 
4835 11755 6 18                                                    REALPTR 
4836 11758 6 18                                                  end (* then *) 
4837 11759 6 17                                                else 
4838 11762 6 16                                                  if LSP -> . FORM <= 
4839 11765 6 17                                                  SUBRANGE then 
4840 11768 6 17                                                    GEN0T ( 58 , GATTR . 
4841 11771 6 18                                                    TYPTR ) ; 
4842 11771 6 15                                              end (* then *) 
4843 11772 6 15                                            else 
4844 11772 6 14                                              begin 
4845 11774 6 15                                                LOADADDRESS ; 
4846 11774 6 15                                              end (* else *) 
4847 11775 6 15                                          else 
4848 11779 6 13                                            if GATTR . KIND = VARBL then 
4849 11779 6 14                                              begin 
4850 11781 6 15                                                LOADADDRESS ; 
4851 11781 6 15                                              end (* then *) 
4852 11782 6 15                                            else 
4853 11786 6 14                                              ERROR ( 154 ) ; 
4854 11787 6 12                                          if not COMPTYPES ( LSP , GATTR 
4855 11792 6 13                                          . TYPTR ) then 
4856 11794 6 13                                            ERROR ( 142 ) 
4857 11796 6 14                                        end (* then *) 
4858 11796 6 12                                    end (* then *) 
4859 11797 6 10                                  else 
4860 11800 6  9                                    with GATTR . TYPTR -> do 
4861 11805 6 10                                      if FORM <= POWER then 
4862 11805 6 11                                        begin 
4863 11807 6 12                                          LOAD ; 
4864 11812 6 12                                          if FORM <= SUBRANGE then 
4865 11816 6 13                                            GEN0T ( 59 , GATTR . TYPTR ) 
4866 11818 6 14                                                    ; 
4867 11818 6 12                                        end (* then *) 
4868 11819 6 12                                      else 
4869 11821 6 11                                        LOADADDRESS ; 
4870 11821 6  8                                end (* then *) 
4871 11822 6  8                              else 
4872 11822 6  7                                begin 
4873 11822 6  8                                   
4874 11822 6  8                                end (* else *) 
4875 11822 6  8                          end (* else *) ; 
4876 11830 6  3                        if ( LKIND = ACTUAL ) and ( NXT <> NIL ) then 
4877 11832 6  4                          NXT := NXT -> . NEXT 
4878 11839 6  5                      until SY <> COMMA ; 
4879 11842 6  2                      LC := LLC ; 
4880 11846 6  2                      if SY = RPARENT then 
4881 11846 6  3                        INSYMBOL 
4882 11849 6  4                      else 
4883 11851 6  3                        ERROR ( 4 ) 
4884 11853 6  4                    end (* then *) ; 
4885 11857 6  0                  if LKIND = ACTUAL then 
4886 11857 6  1                    begin 
4887 11861 6  2                      if ( NXT <> NIL ) then 
4888 11865 6  3                        ERROR ( 126 ) ; 
4889 11868 6  2                      GATTR . ACP := FCP ; 
4890 11871 6  2                      with FCP -> do 
4891 11871 6  3                        begin 
4892 11878 6  4                          if PRCODE and ( PF_ATTR <> INTERN ) then 
4893 11878 6  5                            begin 
4894 11887 6  6                              WRITE ( PRR , ' CXP  ' , LOCPAR : 2 , ' ' 
4895 11891 6  7                                      ) ; 
4896 11896 6  6                              if PFXNAME <> NIL then 
4897 11899 6  7                                WRITESTRG ( PFXNAME -> ) 
4898 11902 6  8                              else 
4899 11902 6  7                                begin 
4900 11906 6  8                                  WRITE ( PRR , '_' ) ; 
4901 11908 6  8                                  I := 1 ; 
4902 11913 6  8                                  for I := 1 to ALPHALEN do 
4903 11913 6  9                                    begin 
4904 11921 6 10                                      C := NAME [ I ] ; 
4905 11925 6 10                                      if C = ' ' then 
4906 11926 6 11                                        goto 1 ; 
4907 11932 6 10                                      if ( C >= 'A' ) and ( C <= 'Z' ) 
4908 11934 6 11                                      then 
4909 11941 6 11                                        C := CHR ( ORD ( C ) + 32 ) ; 
4910 11945 6 10                                      WRITE ( PRR , C : 1 ) ; 
4911 11947 6 10                                    end (* for *) ; 
4912 11947 6  8                                end (* else *) ; 
4913 11947 6  6                              1 : 
4914 11949 6  7                              WRITELN ( PRR ) ; 
4915 11949 6  6                            end (* then *) 
4916 11950 6  6                          else 
4917 11963 6  5                            GENCUPENT ( 46 , LEVEL - PFLEV , PFNAME ) ; 
4918 11974 6  4                          GEN1T ( 41 , LOCPAR * PTRSIZE , IDTYPE ) ; 
4919 11974 6  4                        end (* with *) 
4920 11974 6  4                    end (* then *) ; 
4921 11976 6  0                  GATTR . TYPTR := FCP -> . IDTYPE 
4922 11980 6  1                end (* CALLNONSTANDARD *) ; 
4923 11980 6  0  
4924 11980 6  0  
4925 11980 5  0             begin (* CALL *) 
4926 11988 5  0               if FCP -> . PFDECKIND = STANDARD then 
4927 11988 5  1                 begin 
4928 11993 5  2                   LKEY := FCP -> . KEY ; 
4929 11999 5  2                   if FCP -> . KLASS = PROC then 
4930 11999 5  3                     begin 
4931 12004 5  4                       if not ( LKEY in [ 5 , 6 , 11 , 12 ] ) then 
4932 12008 5  5                         if SY = LPARENT then 
4933 12008 5  6                           INSYMBOL 
4934 12011 5  7                         else 
4935 12015 5  6                           ERROR ( 9 ) ; 
4936 12017 5  4                       case LKEY of 
4937 12017 5  5                         1 , 2 , 3 , 4 : 
4938 12020 5  5                           GETPUTRESETREWRITE ; 
4939 12020 5  5                         5 , 11 : 
4940 12023 5  5                           SREAD ; 
4941 12023 5  5                         6 , 12 : 
4942 12026 5  5                           SWRITE ; 
4943 12029 5  5                         7 : SPACK ; 
4944 12032 5  5                         8 : SUNPACK ; 
4945 12035 5  5                         9 : SNEW ; 
4946 12038 5  5                         10 : SRELEASE ; 
4947 12038 5  5                         13 : SMARK 
4948 12045 5  6                       end (* case *) ; 
4949 12050 5  4                       if not ( LKEY in [ 5 , 6 , 11 , 12 ] ) then 
4950 12054 5  5                         if SY = RPARENT then 
4951 12054 5  6                           INSYMBOL 
4952 12057 5  7                         else 
4953 12059 5  6                           ERROR ( 4 ) 
4954 12061 5  7                     end (* then *) 
4955 12062 5  4                   else 
4956 12062 5  3                     begin 
4957 12070 5  4                       if ( LKEY <= 8 ) or ( LKEY = 11 ) then 
4958 12070 5  5                         begin 
4959 12074 5  6                           if SY = LPARENT then 
4960 12074 5  7                             INSYMBOL 
4961 12077 5  8                           else 
4962 12081 5  7                             ERROR ( 9 ) ; 
4963 12086 5  6                           EXPRESSION ( FSYS + [ RPARENT ] ) ; 
4964 12086 5  6                           LOAD 
4965 12088 5  7                         end (* then *) ; 
4966 12090 5  4                       case LKEY of 
4967 12093 5  5                         1 : SABS ; 
4968 12096 5  5                         2 : SSQR ; 
4969 12099 5  5                         3 : STRUNC ; 
4970 12102 5  5                         4 : SODD ; 
4971 12105 5  5                         5 : SORD ; 
4972 12108 5  5                         6 : SCHR ; 
4973 12111 5  5                         7 , 8 : PREDSUCC ; 
4974 12111 5  5                         9 , 10 : 
4975 12114 5  5                           SEOF ; 
4976 12117 5  5                         11 : SROUND ; 
4977 12120 5  5                         12 : SSIZEOF ; 
4978 12123 5  5                         13 : SADDROF ; 
4979 12127 5  5                       end (* case *) ; 
4980 12135 5  4                       if ( LKEY <= 8 ) or ( LKEY >= 11 ) then 
4981 12139 5  5                         if SY = RPARENT then 
4982 12139 5  6                           INSYMBOL 
4983 12142 5  7                         else 
4984 12144 5  6                           ERROR ( 4 ) 
4985 12146 5  7                     end (* else *) ; 
4986 12146 5  2                 end (* then *) 
4987 12147 5  2               else 
4988 12147 5  1                 CALLNONSTANDARD 
4989 12150 5  2             end (* CALL *) ; 
4990 12150 5  0  
4991 12150 5  0  
4992 12150 5  0          procedure EXPRESSION ; 
4993 12150 5  0  
4994   -26 5  0             var LATTR : ATTR ; 
4995   -30 5  0                 LOP : OPERATOR ; 
4996   -31 5  0                 TYPIND : CHAR ; 
4997   -40 5  0                 LSIZE , GSIZE : ADDRRANGE ; 
4998   -40 5  0  
4999   -40 5  0  
5000     0 6  0             procedure SIMPLEEXPRESSION ( FSYS : SETOFSYS ) ; 
5001     0 6  0  
5002   -26 6  0                var LATTR : ATTR ; 
5003   -30 6  0                    LOP : OPERATOR ; 
5004   -31 6  0                    SIGNED : BOOLEAN ; 
5005   -31 6  0  
5006   -31 6  0  
5007     0 7  0                procedure TERM ( FSYS : SETOFSYS ) ; 
5008     0 7  0  
5009   -26 7  0                   var LATTR : ATTR ; 
5010   -30 7  0                       LOP : OPERATOR ; 
5011   -30 7  0  
5012   -30 7  0  
5013     0 8  0                   procedure FACTOR ( FSYS : SETOFSYS ) ; 
5014     0 8  0  
5015    -4 8  0                      var LCP : CTP ; 
5016    -8 8  0                          LVP : CSP ; 
5017    -9 8  0                          VARPART : BOOLEAN ; 
5018   -42 8  0                          CSTPART : set of SETLOW .. SETHIGH ; 
5019   -50 8  0                          LSP , LSP1 : STP ; 
5020   -56 8  0                          VALS : VALU ; 
5021   -64 8  0                          LOW , HIGH : INTEGER ; 
5022   -64 8  0  
5023 12150 8  0                      begin (* FACTOR *) 
5024 12158 8  0                        if not ( SY in FACBEGSYS ) then 
5025 12158 8  1                          begin 
5026 12162 8  2                            ERROR ( 58 ) ; 
5027 12167 8  2                            SKIP ( FSYS + FACBEGSYS ) ; 
5028 12167 8  2                            GATTR . TYPTR := NIL 
5029 12170 8  3                          end (* then *) ; 
5030 12175 8  0                        while SY in FACBEGSYS do 
5031 12175 8  1                          begin 
5032 12178 8  2                            case SY of 
5033 12178 8  3                              IDENT : begin 
5034 12178 8  4                                        SEARCHID ( [ KONST , VARS , 
5035 12179 8  5                                                   FIELD , FUNC ] , LCP 
5036 12182 8  5                                                   ) ; 
5037 12184 8  4                                        INSYMBOL ; 
5038 12187 8  4                                        GATTR . ACP := LCP ; 
5039 12193 8  4                                        if LCP -> . KLASS = FUNC then 
5040 12193 8  5                                          begin 
5041 12197 8  6                                            CALL ( FSYS , LCP ) ; 
5042 12197 8  6                                            with GATTR do 
5043 12197 8  7                                              begin 
5044 12200 8  8                                                KIND := EXPR ; 
5045 12204 8  8                                                if TYPTR <> NIL then 
5046 12207 8  9                                                  if TYPTR -> . FORM = 
5047 12210 8 10                                                  SUBRANGE then 
5048 12212 8 10                                                    TYPTR := TYPTR -> . 
5049 12212 8 11                                                    RANGETYPE 
5050 12215 8 11                                              end (* with *) 
5051 12215 8  8                                          end (* then *) 
5052 12216 8  6                                        else 
5053 12222 8  5                                          if LCP -> . KLASS = KONST then 
5054 12225 8  6                                            with GATTR , LCP -> do 
5055 12225 8  7                                              begin 
5056 12229 8  8                                                TYPTR := IDTYPE ; 
5057 12232 8  8                                                KIND := CST ; 
5058 12233 8  8                                                CVAL := VALUES 
5059 12236 8  9                                              end (* with *) 
5060 12237 8  8                                          else 
5061 12237 8  6                                            begin 
5062 12240 8  7                                              if LCP -> . KLASS = VARS 
5063 12243 8  8                                              then 
5064 12246 8  8                                                if LCP -> . VLEV < 
5065 12249 8  9                                                MIN_LEVEL then 
5066 12253 8  9                                                  ERROR ( 59 ) ; 
5067 12257 8  7                                              SELECTOR ( FSYS , LCP ) ; 
5068 12258 8  7                                              if GATTR . TYPTR <> NIL 
5069 12261 8  8                                              then 
5070 12264 8  8                                                with GATTR , TYPTR -> do 
5071 12266 8  9                                                  if FORM = SUBRANGE 
5072 12269 8 10                                                  then 
5073 12269 8 10                                                    TYPTR := RANGETYPE 
5074 12273 8 11                                            end (* else *) 
5075 12274 8  7                                      end (* tag/ca *) ; 
5076 12274 8  3                              INTCONST : 
5077 12274 8  3                                begin 
5078 12274 8  4                                  with GATTR do 
5079 12274 8  5                                    begin 
5080 12277 8  6                                      TYPTR := INTPTR ; 
5081 12280 8  6                                      KIND := CST ; 
5082 12281 8  6                                      CVAL := VAL 
5083 12283 8  7                                    end (* with *) ; 
5084 12283 8  4                                  INSYMBOL 
5085 12286 8  5                                end (* tag/ca *) ; 
5086 12286 8  3                              REALCONST : 
5087 12286 8  3                                begin 
5088 12286 8  4                                  with GATTR do 
5089 12286 8  5                                    begin 
5090 12289 8  6                                      TYPTR := REALPTR ; 
5091 12292 8  6                                      KIND := CST ; 
5092 12293 8  6                                      CVAL := VAL 
5093 12295 8  7                                    end (* with *) ; 
5094 12295 8  4                                  INSYMBOL 
5095 12298 8  5                                end (* tag/ca *) ; 
5096 12298 8  3                              STRINGCONST : 
5097 12298 8  3                                begin 
5098 12298 8  4                                  with GATTR do 
5099 12298 8  5                                    begin 
5100 12301 8  6                                      if not EXPECTSTRING and ( LGTH = 1 
5101 12305 8  7                                      ) then 
5102 12305 8  7                                        TYPTR := CHARPTR 
5103 12309 8  8                                      else 
5104 12309 8  7                                        begin 
5105 12312 8  8                                          NEW ( LSP , ARRAYS ) ; 
5106 12315 8  8                                          with LSP -> do 
5107 12315 8  9                                            begin 
5108 12320 8 10                                              AELTYPE := CHARPTR ; 
5109 12325 8 10                                              FORM := ARRAYS ; 
5110 12330 8 10                                              INXTYPE := NIL ; 
5111 12335 8 10                                              SIZE := LGTH * CHARSIZE + 
5112 12339 8 11                                                    1 ; 
5113 12344 8 10                                              VARY := TRUE ; 
5114 12344 8 10                                            end (* with *) ; 
5115 12344 8  8                                          TYPTR := LSP 
5116 12347 8  9                                        end (* else *) ; 
5117 12350 8  6                                      KIND := CST ; 
5118 12351 8  6                                      CVAL := VAL 
5119 12353 8  7                                    end (* with *) ; 
5120 12353 8  4                                  INSYMBOL 
5121 12356 8  5                                end (* tag/ca *) ; 
5122 12356 8  3                              LPARENT : 
5123 12356 8  3                                begin 
5124 12358 8  4                                  INSYMBOL ; 
5125 12363 8  4                                  EXPRESSION ( FSYS + [ RPARENT ] ) ; 
5126 12367 8  4                                  if SY = RPARENT then 
5127 12367 8  5                                    INSYMBOL 
5128 12370 8  6                                  else 
5129 12372 8  5                                    ERROR ( 4 ) 
5130 12375 8  6                                end (* tag/ca *) ; 
5131 12375 8  3                              NOTSY : begin 
5132 12377 8  4                                        INSYMBOL ; 
5133 12380 8  4                                        FACTOR ( FSYS ) ; 
5134 12382 8  4                                        LOAD ; 
5135 12387 8  4                                        GEN0 ( 19 ) ; 
5136 12391 8  4                                        if GATTR . TYPTR <> NIL then 
5137 12392 8  5                                          if GATTR . TYPTR <> BOOLPTR 
5138 12395 8  6                                          then 
5139 12395 8  6                                            begin 
5140 12399 8  7                                              ERROR ( 135 ) ; 
5141 12399 8  7                                              GATTR . TYPTR := NIL 
5142 12402 8  8                                            end (* then *) ; 
5143 12403 8  4                                      end (* tag/ca *) ; 
5144 12403 8  3                              LBRACK : 
5145 12403 8  3                                begin 
5146 12405 8  4                                  INSYMBOL ; 
5147 12407 8  4                                  CSTPART := [ ] ; 
5148 12410 8  4                                  VARPART := FALSE ; 
5149 12413 8  4                                  NEW ( LSP , POWER ) ; 
5150 12416 8  4                                  with LSP -> do 
5151 12416 8  5                                    begin 
5152 12421 8  6                                      ELSET := NIL ; 
5153 12426 8  6                                      SIZE := SETSIZE ; 
5154 12428 8  6                                      FORM := POWER 
5155 12431 8  7                                    end (* with *) ; 
5156 12435 8  4                                  if SY = RBRACK then 
5157 12435 8  5                                    begin 
5158 12435 8  6                                      with GATTR do 
5159 12435 8  7                                        begin 
5160 12438 8  8                                          TYPTR := LSP ; 
5161 12438 8  8                                          KIND := CST 
5162 12441 8  9                                        end (* with *) ; 
5163 12441 8  6                                      INSYMBOL 
5164 12443 8  7                                    end (* then *) 
5165 12444 8  6                                  else 
5166 12444 8  5                                    begin 
5167 12444 8  6                                      repeat 
5168 12445 8  7                                        EXPRESSION ( FSYS + [ COMMA , 
5169 12449 8  8                                                    RBRACK , COLON ] ) ; 
5170 12453 8  7                                        if GATTR . TYPTR <> NIL then 
5171 12456 8  8                                          if GATTR . TYPTR -> . FORM <> 
5172 12459 8  9                                          SCALAR then 
5173 12459 8  9                                            begin 
5174 12463 8 10                                              ERROR ( 136 ) ; 
5175 12463 8 10                                              GATTR . TYPTR := NIL 
5176 12466 8 11                                            end (* then *) 
5177 12467 8 10                                          else 
5178 12469 8  9                                            if COMPTYPES ( LSP -> . 
5179 12474 8 10                                            ELSET , GATTR . TYPTR ) then 
5180 12474 8 10                                              begin 
5181 12475 8 11                                                if GATTR . KIND = CST 
5182 12478 8 12                                                then 
5183 12478 8 12                                                  begin 
5184 12478 8 13                                                    LOW := GATTR . CVAL 
5185 12480 8 14                                                    . IVAL ; 
5186 12482 8 13                                                    HIGH := LOW ; 
5187 12486 8 13                                                    if SY = COLON then 
5188 12486 8 14                                                    begin 
5189 12488 8 15                                                    INSYMBOL ; 
5190 12489 8 15                                                    CONSTANT ( FSYS + [ 
5191 12491 8 16                                                    COMMA , RBRACK ] , 
5192 12495 8 16                                                    LSP1 , VALS ) ; 
5193 12499 8 15                                                    if LSP1 <> NIL then 
5194 12502 8 16                                                    if LSP1 -> . FORM = 
5195 12505 8 17                                                    SCALAR then 
5196 12505 8 17                                                    HIGH := VALS . IVAL 
5197 12508 8 18                                                    else 
5198 12510 8 17                                                    ERROR ( 136 ) 
5199 12513 8 18                                                    else 
5200 12517 8 16                                                    ERROR ( 106 ) ; 
5201 12517 8 15                                                    end (* then *) ; 
5202 12520 8 13                                                    if ( LOW <= HIGH ) 
5203 12521 8 14                                                    and ( LOW >= SETLOW 
5204 12525 8 14                                                    ) and ( HIGH <= 
5205 12529 8 14                                                    SETHIGH ) then 
5206 12532 8 14                                                    for LOW := LOW to 
5207 12534 8 15                                                    HIGH do 
5208 12535 8 15                                                    CSTPART := CSTPART + 
5209 12537 8 16                                                    [ LOW ] 
