program PRETTYPRINT ( INPUTFILE ,       // from
                      OUTPUTFILE ) ;    // to

(**********************************************************************)
(* output file not used [sam]                                         *)
(*====================================================================*)
(*                                                                    *)
(*  PROGRAM TITLE: PASCAL PRETTYPRINTING PROGRAM                      *)
(*                                                                    *)
(*  AUTHORS: JON F. HUERAS AND HENRY F. LEDGARD                       *)
(*           COMPUTER AND INFORMATION SCIENCE DEPARTMENT              *)
(*           UNIVERSITY OF MASSACHUSETTS, AMHERST                     *)
(*           (EARLIER VERSIONS AND CONTRIBUTIONS BY RANDY CHOW        *)
(*            AND JOHN GORMAN.)                                       *)
(*                                                                    *)
(*  PROGRAM SUMMARY:                                                  *)
(*                                                                    *)
(*     THIS PROGRAM TAKES AS INPUT A PASCAL PROGRAM AND               *)
(*     REFORMATS THE PROGRAM ACCORDING TO A STANDARD SET OF           *)
(*     PRETTYPRINTING RULES. THE PRETTYPRINTED PROGRAM IS GIVEN       *)
(*     AS OUTPUT. THE PRETTYPRINTING RULES ARE GIVEN BELOW.           *)
(*                                                                    *)
(*     AN IMPORTANT FEATURE IS THE PROVISION FOR THE USE OF EXTRA     *)
(*     SPACES AND EXTRA BLANK LINES. THEY MAY BE FREELY INSERTED BY   *)
(*     THE USER IN ADDITION TO THE SPACES AND BLANK LINES INSERTED    *)
(*     BY THE PRETTYPRINTER.                                          *)
(*                                                                    *)
(*     NO ATTEMPT IS MADE TO DETECT OR CORRECT SYNTACTIC ERRORS IN    *)
(*     THE USER'S PROGRAM. HOWEVER, SYNTACTIC ERRORS MAY RESULT IN    *)
(*     ERRONEOUS PRETTYPRINTING.                                      *)
(*                                                                    *)
(*                                                                    *)
(*  INPUT FILE:   INPUTFILE  - A FILE OF CHARACTERS, PRESUMABLY A     *)
(*                             PASCAL PROGRAM OR PROGRAM FRAGMENT.    *)
(*                                                                    *)
(*  OUTPUT FILE:  OUTPUTFILE - THE PRETTYPRINTED PROGRAM.             *)
(*                                                                    *)
(*                OUTPUT     - STANDARD PASCAL FILE FOR RUNTIME       *)
(*                             MESSAGES.                              *)
(*                                                                    *)
(*                                                                    *)
(**********************************************************************)


(**********************************************************************)
(*                                                                    *)
(*                     PASCAL  PRETTYPRINTING  RULES                  *)
(*                                                                    *)
(*                                                                    *)
(* [ GENERAL PRETTYPRINTING RULES ]                                   *)
(*                                                                    *)
(*  1.    ANY SPACES OR BLANK LINES BEYOND THOSE GENERATED BY THE     *)
(*     PRETTYPRINTER ARE LEFT ALONE. THE USER IS ENCOURAGED, FOR THE  *)
(*     SAKE OF READABILITY, TO MAKE USE OF THIS FACILITY.             *)
(*        IN ADDITION, COMMENTS ARE LEFT WHERE THEY ARE FOUND, UNLESS *)
(*     THEY ARE SHIFTED RIGHT BY PRECEEDING TEXT ON A LINE.           *)
(*                                                                    *)
(*  2.    ALL STATEMENTS AND DECLARATIONS BEGIN ON SEPARATE LINES.    *)
(*                                                                    *)
(*  3.    NO LINE MAY BE GREATER THAN 120 CHARACTERS LONG. ANY LINE   *)
(*     LONGER THAN THIS IS CONTINUED ON A SEPARATE LINE.              *)
(*                                                                    *)
(*  4.    THE KEYWORDS "BEGIN", "END", "REPEAT", AND "RECORD" ARE     *)
(*     FORCED TO STAND ON LINES BY THEMSELVES (OR POSSIBLY FOLLOWED BY*)
(*     SUPPORTING COMMENTS).                                          *)
(*        IN ADDITION, THE "UNTIL" CLAUSE OF A "REPEAT-UNTIL" STATE-  *)
(*     MENT IS FORCED TO START ON A NEW LINE.                         *)
(*                                                                    *)
(*  5.    A BLANK LINE IS FORCED BEFORE THE KEYWORDS "PROGRAM",       *)
(*     "PROCEDURE", "FUNCTION", "LABEL", "CONST", "TYPE", AND "VAR".  *)
(*                                                                    *)
(*  6.    A SPACE IS FORCED BEFORE AND AFTER THE SYMBOLS ":=" AND     *)
(*     "=". ADDITIONALLY, A SPACE IS FORCED AFTER THE SYMBOL ":".     *)
(*     NOTE THAT ONLY "="S IN DECLARATIONS ARE FORMATTED. "="S IN     *)
(*     EXPRESSIONS ARE IGNORED.                                       *)
(*                                                                    *)
(*                                                                    *)
(* [ INDENTATION RULES ]                                              *)
(*                                                                    *)
(*  1.    THE BODIES OF "LABEL", "CONST", "TYPE", AND "VAR" DECLARA-  *)
(*     TIONS ARE INDENTED FROM THEIR CORRESPONDING DECLARATION HEADER *)
(*     KEYWORDS.                                                      *)
(*                                                                    *)
(*  2.    THE BODIES OF "BEGIN-END", "REPEAT-UNTIL", "FOR", "WHILE",  *)
(*     "WITH", AND "CASE" STATEMENTS, AS WELL AS "RECORD-END" STRUC-  *)
(*     TURES AND "CASE" VARIANTS (TO ONE LEVEL) ARE INDENTED FROM     *)
(*     THEIR HEADER KEYWORDS.                                         *)
(*                                                                    *)
(*  3.    AN "IF-THEN-ELSE" STATEMENT IS INDENTED AS FOLLOWS:         *)
(*                                                                    *)
(*            IF < EXPRESSION >                                       *)
(*               THEN                                                 *)
(*                  < STATEMENT >                                     *)
(*               ELSE                                                 *)
(*                  < STATEMENT >                                     *)
(*                                                                    *)
(*                                                                    *)
(**********************************************************************)


(**********************************************************************)
(*                                                                    *)
(*                      GENERAL  ALGORITHM                            *)
(*                                                                    *)
(*                                                                    *)
(*     THE STRATEGY OF THE PRETTYPRINTER IS TO SCAN SYMBOLS FROM      *)
(*  THE INPUT PROGRAM AND MAP EACH SYMBOL INTO A PRETTYPRINTING       *)
(*  ACTION, INDEPENDENTLY OF THE CONTEXT IN WHICH THE SYMBOL          *)
(*  APPEARS. THIS IS ACCOMPLISHED BY A TABLE OF PRETTYPRINTING        *)
(*  OPTIONS.                                                          *)
(*                                                                    *)
(*     FOR EACH DISTINGUISHED SYMBOL IN THE TABLE, THERE IS AN        *)
(*  ASSOCIATED SET OF OPTIONS. IF THE OPTION HAS BEEN SELECTED FOR    *)
(*  THE SYMBOL BEING SCANNED, THEN THE ACTION CORRESPONDING WITH      *)
(*  EACH OPTION IS PERFORMED.                                         *)
(*                                                                    *)
(*     THE BASIC ACTIONS INVOLVED IN PRETTYPRINTING ARE THE INDENT-   *)
(*  ATION AND DE-INDENTATION OF THE MARGIN. EACH TIME THE MARGIN IS   *)
(*  INDENTED, THE PREVIOUS VALUE OF THE MARGIN IS PUSHED ONTO A       *)
(*  STACK, ALONG WITH THE NAME OF THE SYMBOL THAT CAUSED IT TO BE     *)
(*  INDENTED. EACH TIME THE MARGIN IS DE-INDENTED, THE STACK IS       *)
(*  POPPED OFF TO OBTAIN THE PREVIOUS VALUE OF THE MARGIN.            *)
(*                                                                    *)
(*     THE PRETTYPRINTING OPTIONS ARE PROCESSED IN THE FOLLOWING      *)
(*  ORDER, AND INVOKE THE FOLLOWING ACTIONS:                          *)
(*                                                                    *)
(*                                                                    *)
(*    CRSUPPRESS       - IF A CARRIAGE RETURN HAS BEEN INSERTED       *)
(*                       FOLLOWING THE PREVIOUS SYMBOL, THEN IT IS    *)
(*                       INHIBITED UNTIL THE NEXT SYMBOL IS PRINTED.  *)
(*                                                                    *)
(*    CRBEFORE         - A CARRIAGE RETURN IS INSERTED BEFORE THE     *)
(*                       CURRENT SYMBOL (UNLESS ONE IS ALREADY THERE).*)
(*                                                                    *)
(*    BLANKLINEBEFORE  - A BLANK LINE IS INSERTED BEFORE THE CURRENT  *)
(*                       SYMBOL (UNLESS ALREADY THERE).               *)
(*                                                                    *)
(*    DINDENTONKEYS    - IF ANY OF THE SPECIFIED KEYS ARE ON TOP OF   *)
(*                       OF THE STACK, THE STACK IS POPPED, DE-INDENT-*)
(*                       ING THE MARGIN. THE PROCESS IS REPEATED      *)
(*                       UNTIL THE TOP OF THE STACK IS NOT ONE OF THE *)
(*                       SPECIFIED KEYS.                              *)
(*                                                                    *)
(*    DINDENT          - THE STACK IS UNCONDITIONALLY POPPED AND THE  *)
(*                       MARGIN IS DE-INDENTED.                       *)
(*                                                                    *)
(*    SPACEBEFORE      - A SPACE IS INSERTED BEFORE THE SYMBOL BEING  *)
(*                       SCANNED (UNLESS ALREADY THERE).              *)
(*                                                                    *)
(*    [ THE SYMBOL IS PRINTED AT THIS POINT ]                         *)
(*                                                                    *)
(*    SPACEAFTER       - A SPACE IS INSERTED AFTER THE SYMBOL BEING   *)
(*                       SCANNED (UNLESS ALREADY THERE).              *)
(*                                                                    *)
(*    GOBBLESYMBOLS    - SYMBOLS ARE CONTINUOUSLY SCANNED AND PRINTED *)
(*                       WITHOUT ANY PROCESSING UNTIL ONE OF THE      *)
(*                       SPECIFIED SYMBOLS IS SEEN (BUT NOT GOBBLED). *)
(*                                                                    *)
(*    INDENTBYTAB      - THE MARGIN IS INDENTED BY A STANDARD AMOUNT  *)
(*                       FROM THE PREVIOUS MARGIN.                    *)
(*                                                                    *)
(*    INDENTTOCLP      - THE MARGIN IS INDENTED TO THE CURRENT LINE   *)
(*                       POSITION.                                    *)
(*                                                                    *)
(*    CRAFTER          - A CARRIAGE RETURN IS INSERTED FOLLOWING THE  *)
(*                       SYMBOL SCANNED.                              *)
(**********************************************************************)



const MAXSYMBOLSIZE = 200 ;

      (*******************************************)
      (* THE MAXIMUM SIZE (IN CHARACTERS) OF A   *)
      (* SYMBOL  SCANNED BY THE LEXICAL SCANNER. *)
      (*******************************************)

      MAXSTACKSIZE = 100 ; // THE MAXIMUM NUMBER OF SYMBOLS CAUSING
                           // INDENTATION THAT MAY BE STACKED.     
      MAXKEYLENGTH = 10 ;  // THE MAXIMUM LENGTH (IN CHARACTERS) OF A
                           // PASCAL RESERVED KEYWORD.               
      MAXLINESIZE = 72 ;

      (*****************************************)
      (* THE MAXIMUM SIZE (IN CHARACTERS) OF A *)
      (* LINE OUTPUT BY THE PRETTYPRINTER.     *)
      (*****************************************)

      SLOFAIL1 = 30 ;      // UP TO THIS COLUMN POSITION, EACH TIME
                           // "INDENTBYTAB" IS INVOKED, THE MARGIN 
                           // WILL BE INDENTED BY "INDENT1".       
      SLOFAIL2 = 48 ;      // UP TO THIS COLUMN POSITION, EACH TIME
                           // "INDENTBYTAB" IS INVOKED, THE MARGIN 
                           // WILL BE INDENTED BY "INDENT2". BEYOND
                           // THIS, NO INDENTATION OCCURS.         
      INDENT1 = 3 ;
      INDENT2 = 1 ;
      SPACE = ' ' ;


type KEYSYMBOL = ( PROGSYM , FUNCSYM , PROCSYM , LABELSYM , CONSTSYM ,
                 TYPESYM , VARSYM , BEGINSYM , REPEATSYM , RECORDSYM ,
                 CASESYM , CASEVARSYM , OFSYM , FORSYM , WHILESYM ,
                 WITHSYM , DOSYM , IFSYM , THENSYM , ELSESYM , ENDSYM ,
                 UNTILSYM , BECOMES , OPENCOMMENT , CLOSECOMMENT ,
                 SEMICOLON , COLON , EQUALS , OPENPAREN , CLOSEPAREN ,
                 PERIOD , ENDOFFILE , OTHERSYM ) ;
     OPTION = ( CRSUPPRESS , CRBEFORE , BLANKLINEBEFORE , DINDENTONKEYS
              , DINDENT , SPACEBEFORE , SPACEAFTER , GOBBLESYMBOLS ,
              INDENTBYTAB , INDENTTOCLP , CRAFTER ) ;
     OPTIONSET = set of OPTION ;
     KEYSYMSET = set of KEYSYMBOL ;
     TABLEENTRY = record
                    OPTIONSSELECTED : OPTIONSET ;
                    DINDENTSYMBOLS : KEYSYMSET ;
                    GOBBLETERMINATORS : KEYSYMSET
                  end ;
     OPTIONTABLE = array [ KEYSYMBOL ] of TABLEENTRY ;
     KEY = packed array [ 1 .. MAXKEYLENGTH ] of CHAR ;
     KEYWORDTABLE = array [ PROGSYM .. UNTILSYM ] of KEY ;
     SPECIALCHAR = packed array [ 1 .. 2 ] of CHAR ;
     DBLCHRSET = set of BECOMES .. OPENCOMMENT ;
     DBLCHARTABLE = array [ BECOMES .. OPENCOMMENT ] of SPECIALCHAR ;
     SGLCHARTABLE = array [ SEMICOLON .. PERIOD ] of CHAR ;
     STRINGX = array [ 1 .. MAXSYMBOLSIZE ] of CHAR ;
     SYMBOL = record
                NAME : KEYSYMBOL ;
                VALUE : STRINGX ;
                LENGTH : INTEGER ;
                SPACESBEFORE : INTEGER ;
                CRSBEFORE : INTEGER
              end ;
     SYMBOLINFO = -> SYMBOL ;
     CHARNAME = ( LETTER , DIGIT , BLANK , QUOTE , ENDOFLINE , FILEMARK
                , OTHERCHAR ) ;
     CHARINFO = record
                  NAME : CHARNAME ;
                  VALUE : CHAR
                end ;
     STACKENTRY = record
                    INDENTSYMBOL : KEYSYMBOL ;
                    PREVMARGIN : INTEGER
                  end ;
     SYMBOLSTACK = array [ 1 .. MAXSTACKSIZE ] of STACKENTRY ;


var INPUTFILE , OUTPUTFILE : TEXT ;
    RECORDSEEN : BOOLEAN ;
    CURRCHAR , NEXTCHAR : CHARINFO ;
    CURRSYM , NEXTSYM : SYMBOLINFO ;
    CRPENDING : BOOLEAN ;
    PPOPTION : OPTIONTABLE ;
    KEYWORD : KEYWORDTABLE ;
    DBLCHARS : DBLCHRSET ;
    DBLCHAR : DBLCHARTABLE ;
    SGLCHAR : SGLCHARTABLE ;
    STACK : SYMBOLSTACK ;
    TOP : INTEGER ;
    CURRLINEPOS , CURRMARGIN : INTEGER ;



procedure GETCHAR ( var INPUTFILE : TEXT ;        // from
                  var NEXTCHAR : CHARINFO ;       // updating
                  var CURRCHAR : CHARINFO ) ;     // returning

   begin (* GETCHAR *)
     CURRCHAR := NEXTCHAR ;
     with NEXTCHAR do
       begin
         if EOF ( INPUTFILE ) then
           NAME := FILEMARK
         else
           if EOLN ( INPUTFILE ) then
             NAME := ENDOFLINE
           else
             if INPUTFILE -> in [ 'A' .. 'Z' , 'a' .. 'z' ]

     (**************************)
     (* added lower case [sam] *)
     (**************************)

             then
               NAME := LETTER
             else
               if INPUTFILE -> in [ '0' .. '9' ] then
                 NAME := DIGIT
               else
                 if INPUTFILE -> = '''' then
                   NAME := QUOTE
                 else
                   if INPUTFILE -> = SPACE then
                     NAME := BLANK
                   else
                     NAME := OTHERCHAR ;
         if NAME in [ FILEMARK , ENDOFLINE ] then
           VALUE := SPACE
         else
           VALUE := INPUTFILE -> ;
         if NAME <> FILEMARK then
           GET ( INPUTFILE )
       end (* with *)
   end (* GETCHAR *) ;



procedure STORENEXTCHAR ( var INPUTFILE : TEXT ; var LENGTH : INTEGER ;
                        var CURRCHAR , NEXTCHAR : CHARINFO ; var VALUE
                        : STRINGX ) ;

   begin (* STORENEXTCHAR *)
     GETCHAR ( INPUTFILE , NEXTCHAR , CURRCHAR ) ;
     if LENGTH < MAXSYMBOLSIZE then
       begin
         LENGTH := LENGTH + 1 ;
         VALUE [ LENGTH ] := CURRCHAR . VALUE
       end (* then *)
   end (* STORENEXTCHAR *) ;



procedure SKIPSPACES ( var INPUTFILE : TEXT ; var CURRCHAR , NEXTCHAR :
                     CHARINFO ; var SPACESBEFORE , CRSBEFORE : INTEGER
                     ) ;

   begin (* SKIPSPACES *)
     CRSBEFORE := 0 ;
     while NEXTCHAR . NAME in [ BLANK , ENDOFLINE ] do
       begin
         GETCHAR ( INPUTFILE , NEXTCHAR , CURRCHAR ) ;
         case CURRCHAR . NAME of
           BLANK : SPACESBEFORE := SPACESBEFORE + 1 ;
           ENDOFLINE :
             begin
               CRSBEFORE := CRSBEFORE + 1 ;
               SPACESBEFORE := 0
             end (* tag/ca *)
         end (* case *)
       end (* while *)
   end (* SKIPSPACES *) ;



procedure GETCOMMENT ( var INPUTFILE : TEXT ; var CURRCHAR , NEXTCHAR :
                     CHARINFO ; var NAME : KEYSYMBOL ; var VALUE :
                     STRINGX ; var LENGTH : INTEGER ) ;

   begin (* GETCOMMENT *)
     NAME := OPENCOMMENT ;
     while not ( ( ( CURRCHAR . VALUE = '*' ) and ( NEXTCHAR . VALUE =
     ')' ) ) or ( NEXTCHAR . NAME = ENDOFLINE ) or ( NEXTCHAR . NAME =
     FILEMARK ) ) do
       STORENEXTCHAR ( INPUTFILE , LENGTH , CURRCHAR , NEXTCHAR , VALUE
                       ) ;
     if ( CURRCHAR . VALUE = '*' ) and ( NEXTCHAR . VALUE = ')' ) then
       begin
         STORENEXTCHAR ( INPUTFILE , LENGTH , CURRCHAR , NEXTCHAR ,
                         VALUE ) ;
         NAME := CLOSECOMMENT ;
       end (* then *)
   end (* GETCOMMENT *) ;



function IDTYPE ( VALUE : STRINGX ; LENGTH : INTEGER ) : KEYSYMBOL ;

   var I : INTEGER ;
       KEYVALUE : KEY ;
       HIT : BOOLEAN ;
       THISKEY : KEYSYMBOL ;

   begin (* IDTYPE *)
     IDTYPE := OTHERSYM ;
     if LENGTH <= MAXKEYLENGTH then
       begin
         for I := 1 to LENGTH do
           KEYVALUE [ I ] := VALUE [ I ] ;
         for I := LENGTH + 1 to MAXKEYLENGTH do
           KEYVALUE [ I ] := SPACE ;
         THISKEY := PROGSYM ;
         HIT := FALSE ;
         while not ( HIT or ( PRED ( THISKEY ) = UNTILSYM ) ) do
           if KEYVALUE = KEYWORD [ THISKEY ] then
             HIT := TRUE
           else
             THISKEY := SUCC ( THISKEY ) ;
         if HIT then
           IDTYPE := THISKEY
       end (* then *) ;
   end (* IDTYPE *) ;



procedure GETIDENTIFIER ( var INPUTFILE : TEXT ; var CURRCHAR ,
                        NEXTCHAR : CHARINFO ; var NAME : KEYSYMBOL ;
                        var VALUE : STRINGX ; var LENGTH : INTEGER ) ;

   begin (* GETIDENTIFIER *)
     while NEXTCHAR . NAME in [ LETTER , DIGIT ] do
       STORENEXTCHAR ( INPUTFILE , LENGTH , CURRCHAR , NEXTCHAR , VALUE
                       ) ;
     NAME := IDTYPE ( VALUE , LENGTH ) ;
     if NAME in [ RECORDSYM , CASESYM , ENDSYM ] then
       case NAME of
         RECORDSYM :
           RECORDSEEN := TRUE ;
         CASESYM :
           if RECORDSEEN then
             NAME := CASEVARSYM ;
         ENDSYM :
           RECORDSEEN := FALSE
       end (* case *)
   end (* GETIDENTIFIER *) ;



procedure GETNUMBER ( var INPUTFILE : TEXT ; var CURRCHAR , NEXTCHAR :
                    CHARINFO ; var NAME : KEYSYMBOL ; var VALUE :
                    STRINGX ; var LENGTH : INTEGER ) ;

   begin (* GETNUMBER *)
     while NEXTCHAR . NAME = DIGIT do
       STORENEXTCHAR ( INPUTFILE , LENGTH , CURRCHAR , NEXTCHAR , VALUE
                       ) ;
     NAME := OTHERSYM
   end (* GETNUMBER *) ;



procedure GETCHARLITERAL ( var INPUTFILE : TEXT ; var CURRCHAR ,
                         NEXTCHAR : CHARINFO ; var NAME : KEYSYMBOL ;
                         var VALUE : STRINGX ; var LENGTH : INTEGER ) ;

   begin (* GETCHARLITERAL *)
     while NEXTCHAR . NAME = QUOTE do
       begin
         STORENEXTCHAR ( INPUTFILE , LENGTH , CURRCHAR , NEXTCHAR ,
                         VALUE ) ;
         while not ( NEXTCHAR . NAME in [ QUOTE , ENDOFLINE , FILEMARK
         ] ) do
           STORENEXTCHAR ( INPUTFILE , LENGTH , CURRCHAR , NEXTCHAR ,
                           VALUE ) ;
         if NEXTCHAR . NAME = QUOTE then
           STORENEXTCHAR ( INPUTFILE , LENGTH , CURRCHAR , NEXTCHAR ,
                           VALUE )
       end (* while *) ;
     NAME := OTHERSYM
   end (* GETCHARLITERAL *) ;



function CHARTYPE ( CURRCHAR , NEXTCHAR : CHARINFO ) : KEYSYMBOL ;

   var NEXTTWOCHARS : SPECIALCHAR ;
       HIT : BOOLEAN ;
       THISCHAR : KEYSYMBOL ;

   begin (* CHARTYPE *)
     NEXTTWOCHARS [ 1 ] := CURRCHAR . VALUE ;
     NEXTTWOCHARS [ 2 ] := NEXTCHAR . VALUE ;
     THISCHAR := BECOMES ;
     HIT := FALSE ;
     while not ( HIT or ( THISCHAR = CLOSECOMMENT ) ) do
       if NEXTTWOCHARS = DBLCHAR [ THISCHAR ] then
         HIT := TRUE
       else
         THISCHAR := SUCC ( THISCHAR ) ;
     if not HIT then
       begin
         THISCHAR := SEMICOLON ;
         while not ( HIT or ( PRED ( THISCHAR ) = PERIOD ) ) do
           if CURRCHAR . VALUE = SGLCHAR [ THISCHAR ] then
             HIT := TRUE
           else
             THISCHAR := SUCC ( THISCHAR )
       end (* then *) ;
     if HIT then
       CHARTYPE := THISCHAR
     else
       CHARTYPE := OTHERSYM
   end (* CHARTYPE *) ;



procedure GETSPECIALCHAR ( var INPUTFILE : TEXT ; var CURRCHAR ,
                         NEXTCHAR : CHARINFO ; var NAME : KEYSYMBOL ;
                         var VALUE : STRINGX ; var LENGTH : INTEGER ) ;

   begin (* GETSPECIALCHAR *)
     STORENEXTCHAR ( INPUTFILE , LENGTH , CURRCHAR , NEXTCHAR , VALUE )
                     ;
     NAME := CHARTYPE ( CURRCHAR , NEXTCHAR ) ;
     if NAME in DBLCHARS then
       STORENEXTCHAR ( INPUTFILE , LENGTH , CURRCHAR , NEXTCHAR , VALUE
                       ) ;
   end (* GETSPECIALCHAR *) ;



procedure GETNEXTSYMBOL ( var INPUTFILE : TEXT ; var CURRCHAR ,
                        NEXTCHAR : CHARINFO ; var NAME : KEYSYMBOL ;
                        var VALUE : STRINGX ; var LENGTH : INTEGER ) ;

   begin (* GETNEXTSYMBOL *)
     case NEXTCHAR . NAME of
       LETTER :
         GETIDENTIFIER ( INPUTFILE , CURRCHAR , NEXTCHAR , NAME , VALUE
                         , LENGTH ) ;
       DIGIT : GETNUMBER ( INPUTFILE , CURRCHAR , NEXTCHAR , NAME ,
                           VALUE , LENGTH ) ;
       QUOTE : GETCHARLITERAL ( INPUTFILE , CURRCHAR , NEXTCHAR , NAME
                                , VALUE , LENGTH ) ;
       OTHERCHAR :
         begin
           GETSPECIALCHAR ( INPUTFILE , CURRCHAR , NEXTCHAR , NAME ,
                            VALUE , LENGTH ) ;
           if NAME = OPENCOMMENT then
             GETCOMMENT ( INPUTFILE , CURRCHAR , NEXTCHAR , NAME ,
                          VALUE , LENGTH ) ;
         end (* tag/ca *) ;
       FILEMARK :
         NAME := ENDOFFILE
     end (* case *)
   end (* GETNEXTSYMBOL *) ;



procedure GETSYMBOL ( var INPUTFILE : TEXT ; var NEXTSYM : SYMBOLINFO ;
                    var CURRSYM : SYMBOLINFO ) ;

   var DUMMY : SYMBOLINFO ;

   begin (* GETSYMBOL *)
     DUMMY := CURRSYM ;
     CURRSYM := NEXTSYM ;
     NEXTSYM := DUMMY ;
     with NEXTSYM -> do
       begin
         SKIPSPACES ( INPUTFILE , CURRCHAR , NEXTCHAR , SPACESBEFORE ,
                      CRSBEFORE ) ;
         LENGTH := 0 ;
         if CURRSYM -> . NAME = OPENCOMMENT then
           GETCOMMENT ( INPUTFILE , CURRCHAR , NEXTCHAR , NAME , VALUE
                        , LENGTH )
         else
           GETNEXTSYMBOL ( INPUTFILE , CURRCHAR , NEXTCHAR , NAME ,
                           VALUE , LENGTH ) ;
       end (* with *) ;
   end (* GETSYMBOL *) ;



procedure INITIALISE ( var INPUTFILE , OUTPUTFILE : TEXT ; var
                     TOPOFSTACK : INTEGER ; var CURRLINEPOS ,
                     CURRMARGIN : INTEGER ; var KEYWORD : KEYWORDTABLE
                     ; var DBLCHARS : DBLCHRSET ; var DBLCHAR :
                     DBLCHARTABLE ; var SGLCHAR : SGLCHARTABLE ; var
                     RECORDSEEN : BOOLEAN ; var CURRCHAR , NEXTCHAR :
                     CHARINFO ; var CURRSYM , NEXTSYM : SYMBOLINFO ;
                     var PPOPTION : OPTIONTABLE ) ;

   begin (* INITIALISE *)
     RESET ( INPUTFILE ) ;
     REWRITE ( OUTPUTFILE ) ;
     TOPOFSTACK := 0 ;
     CURRLINEPOS := 0 ;
     CURRMARGIN := 0 ;
     KEYWORD [ PROGSYM ] := 'PROGRAM   ' ;
     KEYWORD [ FUNCSYM ] := 'FUNCTION  ' ;
     KEYWORD [ PROCSYM ] := 'PROCEDURE ' ;
     KEYWORD [ LABELSYM ] := 'LABEL     ' ;
     KEYWORD [ CONSTSYM ] := 'CONST     ' ;
     KEYWORD [ TYPESYM ] := 'TYPE      ' ;
     KEYWORD [ VARSYM ] := 'VAR       ' ;
     KEYWORD [ BEGINSYM ] := 'BEGIN     ' ;
     KEYWORD [ REPEATSYM ] := 'REPEAT    ' ;
     KEYWORD [ RECORDSYM ] := 'RECORD    ' ;
     KEYWORD [ CASESYM ] := 'CASE      ' ;
     KEYWORD [ CASEVARSYM ] := 'CASE      ' ;
     KEYWORD [ OFSYM ] := 'OF        ' ;
     KEYWORD [ FORSYM ] := 'FOR       ' ;
     KEYWORD [ WHILESYM ] := 'WHILE     ' ;
     KEYWORD [ WITHSYM ] := 'WITH      ' ;
     KEYWORD [ DOSYM ] := 'DO        ' ;
     KEYWORD [ IFSYM ] := 'IF        ' ;
     KEYWORD [ THENSYM ] := 'THEN      ' ;
     KEYWORD [ ELSESYM ] := 'ELSE      ' ;
     KEYWORD [ ENDSYM ] := 'END       ' ;
     KEYWORD [ UNTILSYM ] := 'UNTIL     ' ;
     DBLCHARS := [ BECOMES , OPENCOMMENT ] ;
     DBLCHAR [ BECOMES ] := ':=' ;
     DBLCHAR [ OPENCOMMENT ] := '(*' ;
     SGLCHAR [ SEMICOLON ] := ';' ;
     SGLCHAR [ COLON ] := ':' ;
     SGLCHAR [ EQUALS ] := '=' ;
     SGLCHAR [ OPENPAREN ] := '(' ;
     SGLCHAR [ CLOSEPAREN ] := ')' ;
     SGLCHAR [ PERIOD ] := '.' ;
     RECORDSEEN := FALSE ;
     GETCHAR ( INPUTFILE , NEXTCHAR , CURRCHAR ) ;
     NEW ( CURRSYM ) ;
     NEW ( NEXTSYM ) ;
     GETSYMBOL ( INPUTFILE , NEXTSYM , CURRSYM ) ;
     with PPOPTION [ PROGSYM ] do
       begin
         OPTIONSSELECTED := [ BLANKLINEBEFORE , SPACEAFTER ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ FUNCSYM ] do
       begin
         OPTIONSSELECTED := [ BLANKLINEBEFORE , DINDENTONKEYS ,
                            SPACEAFTER ] ;
         DINDENTSYMBOLS := [ LABELSYM , CONSTSYM , TYPESYM , VARSYM ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ PROCSYM ] do
       begin
         OPTIONSSELECTED := [ BLANKLINEBEFORE , DINDENTONKEYS ,
                            SPACEAFTER ] ;
         DINDENTSYMBOLS := [ LABELSYM , CONSTSYM , TYPESYM , VARSYM ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ LABELSYM ] do
       begin
         OPTIONSSELECTED := [ BLANKLINEBEFORE , SPACEAFTER ,
                            INDENTTOCLP ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ CONSTSYM ] do
       begin
         OPTIONSSELECTED := [ BLANKLINEBEFORE , DINDENTONKEYS ,
                            SPACEAFTER , INDENTTOCLP ] ;
         DINDENTSYMBOLS := [ LABELSYM ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ TYPESYM ] do
       begin
         OPTIONSSELECTED := [ BLANKLINEBEFORE , DINDENTONKEYS ,
                            SPACEAFTER , INDENTTOCLP ] ;
         DINDENTSYMBOLS := [ LABELSYM , CONSTSYM ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ VARSYM ] do
       begin
         OPTIONSSELECTED := [ BLANKLINEBEFORE , DINDENTONKEYS ,
                            SPACEAFTER , INDENTTOCLP ] ;
         DINDENTSYMBOLS := [ LABELSYM , CONSTSYM , TYPESYM ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ BEGINSYM ] do
       begin
         OPTIONSSELECTED := [ DINDENTONKEYS , INDENTBYTAB , CRAFTER ] ;
         DINDENTSYMBOLS := [ LABELSYM , CONSTSYM , TYPESYM , VARSYM ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ REPEATSYM ] do
       begin
         OPTIONSSELECTED := [ INDENTBYTAB , CRAFTER ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ RECORDSYM ] do
       begin
         OPTIONSSELECTED := [ INDENTBYTAB , CRAFTER ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ CASESYM ] do
       begin
         OPTIONSSELECTED := [ SPACEAFTER , INDENTBYTAB , GOBBLESYMBOLS
                            , CRAFTER ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ OFSYM ]
       end (* with *) ;
     with PPOPTION [ CASEVARSYM ] do
       begin
         OPTIONSSELECTED := [ SPACEAFTER , INDENTBYTAB , GOBBLESYMBOLS
                            , CRAFTER ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ OFSYM ]
       end (* with *) ;
     with PPOPTION [ OFSYM ] do
       begin
         OPTIONSSELECTED := [ CRSUPPRESS , SPACEBEFORE ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ FORSYM ] do
       begin
         OPTIONSSELECTED := [ SPACEAFTER , INDENTBYTAB , GOBBLESYMBOLS
                            , CRAFTER ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ DOSYM ]
       end (* with *) ;
     with PPOPTION [ WHILESYM ] do
       begin
         OPTIONSSELECTED := [ SPACEAFTER , INDENTBYTAB , GOBBLESYMBOLS
                            , CRAFTER ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ DOSYM ]
       end (* with *) ;
     with PPOPTION [ WITHSYM ] do
       begin
         OPTIONSSELECTED := [ SPACEAFTER , INDENTBYTAB , GOBBLESYMBOLS
                            , CRAFTER ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ DOSYM ]
       end (* with *) ;
     with PPOPTION [ DOSYM ] do
       begin
         OPTIONSSELECTED := [ CRSUPPRESS , SPACEBEFORE ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ] ;
       end (* with *) ;
     with PPOPTION [ IFSYM ] do
       begin
         OPTIONSSELECTED := [ SPACEAFTER , INDENTBYTAB , GOBBLESYMBOLS
                            , CRAFTER ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ THENSYM ]
       end (* with *) ;
     with PPOPTION [ THENSYM ] do
       begin
         OPTIONSSELECTED := [ INDENTBYTAB , CRAFTER ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ ELSESYM ] do
       begin
         OPTIONSSELECTED := [ CRBEFORE , DINDENTONKEYS , DINDENT ,
                            INDENTBYTAB , CRAFTER ] ;
         DINDENTSYMBOLS := [ IFSYM , ELSESYM ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ ENDSYM ] do
       begin
         OPTIONSSELECTED := [ CRBEFORE , DINDENTONKEYS , DINDENT ,
                            CRAFTER ] ;
         DINDENTSYMBOLS := [ IFSYM , THENSYM , ELSESYM , FORSYM ,
                           WHILESYM , WITHSYM , CASEVARSYM , COLON ,
                           EQUALS ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ UNTILSYM ] do
       begin
         OPTIONSSELECTED := [ CRBEFORE , DINDENTONKEYS , DINDENT ,
                            SPACEAFTER , GOBBLESYMBOLS , CRAFTER ] ;
         DINDENTSYMBOLS := [ IFSYM , THENSYM , ELSESYM , FORSYM ,
                           WHILESYM , WITHSYM , COLON , EQUALS ] ;
         GOBBLETERMINATORS := [ ENDSYM , UNTILSYM , ELSESYM , SEMICOLON
                              ] ;
       end (* with *) ;
     with PPOPTION [ BECOMES ] do
       begin
         OPTIONSSELECTED := [ SPACEBEFORE , SPACEAFTER , GOBBLESYMBOLS
                            ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ENDSYM , UNTILSYM , ELSESYM , SEMICOLON
                              ]
       end (* with *) ;
     with PPOPTION [ OPENCOMMENT ] do
       begin
         OPTIONSSELECTED := [ CRSUPPRESS ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ CLOSECOMMENT ] do
       begin
         OPTIONSSELECTED := [ CRSUPPRESS ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ SEMICOLON ] do
       begin
         OPTIONSSELECTED := [ CRSUPPRESS , DINDENTONKEYS , CRAFTER ] ;
         DINDENTSYMBOLS := [ IFSYM , THENSYM , ELSESYM , FORSYM ,
                           WHILESYM , WITHSYM , COLON , EQUALS ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ COLON ] do
       begin
         OPTIONSSELECTED := [ SPACEAFTER , INDENTTOCLP ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ EQUALS ] do
       begin
         OPTIONSSELECTED := [ SPACEBEFORE , SPACEAFTER , INDENTTOCLP ]
                            ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ OPENPAREN ] do
       begin
         OPTIONSSELECTED := [ GOBBLESYMBOLS ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ CLOSEPAREN ]
       end (* with *) ;
     with PPOPTION [ CLOSEPAREN ] do
       begin
         OPTIONSSELECTED := [ ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ PERIOD ] do
       begin
         OPTIONSSELECTED := [ CRSUPPRESS ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ ENDOFFILE ] do
       begin
         OPTIONSSELECTED := [ ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
     with PPOPTION [ OTHERSYM ] do
       begin
         OPTIONSSELECTED := [ ] ;
         DINDENTSYMBOLS := [ ] ;
         GOBBLETERMINATORS := [ ]
       end (* with *) ;
   end (* INITIALISE *) ;



function STACKEMPTY : BOOLEAN ;

   begin (* STACKEMPTY *)
     if TOP = 0 then
       STACKEMPTY := TRUE
     else
       STACKEMPTY := FALSE
   end (* STACKEMPTY *) ;



function STACKFULL : BOOLEAN ;

   begin (* STACKFULL *)
     if TOP = MAXSTACKSIZE then
       STACKFULL := TRUE
     else
       STACKFULL := FALSE
   end (* STACKFULL *) ;



procedure POPSTACK ( var INDENTSYMBOL : KEYSYMBOL ; var PREVMARGIN :
                   INTEGER ) ;

   begin (* POPSTACK *)
     if not STACKEMPTY then
       begin
         INDENTSYMBOL := STACK [ TOP ] . INDENTSYMBOL ;
         PREVMARGIN := STACK [ TOP ] . PREVMARGIN ;
         TOP := TOP - 1
       end (* then *)
     else
       begin
         INDENTSYMBOL := OTHERSYM ;
         PREVMARGIN := 0
       end (* else *) ;
   end (* POPSTACK *) ;



procedure PUSHSTACK ( INDENTSYMBOL : KEYSYMBOL ; PREVMARGIN : INTEGER )
                    ;

   begin (* PUSHSTACK *)
     TOP := TOP + 1 ;
     STACK [ TOP ] . INDENTSYMBOL := INDENTSYMBOL ;
     STACK [ TOP ] . PREVMARGIN := PREVMARGIN ;
   end (* PUSHSTACK *) ;



procedure WRITECRS ( NUMBEROFCRS : INTEGER ; var CURRLINEPOS : INTEGER
                   ; var OUTPUTFILE : TEXT ) ;

   var I : INTEGER ;

   begin (* WRITECRS *)
     if NUMBEROFCRS > 0 then
       begin
         for I := 1 to NUMBEROFCRS do
           WRITELN ( OUTPUTFILE ) ;
         CURRLINEPOS := 0
       end (* then *)
   end (* WRITECRS *) ;



procedure INSERTCR ( var CURRSYM : SYMBOLINFO ; var OUTPUTFILE : TEXT )
                   ;

   const ONCE = 1 ;

   begin (* INSERTCR *)
     if CURRSYM -> . CRSBEFORE = 0 then
       begin
         WRITECRS ( ONCE , CURRLINEPOS , OUTPUTFILE ) ;
         CURRSYM -> . SPACESBEFORE := 0
       end (* then *)
   end (* INSERTCR *) ;



procedure INSERTBLANKLINE ( var CURRSYM : SYMBOLINFO ; var OUTPUTFILE :
                          TEXT ) ;

   const ONCE = 1 ;
         TWICE = 2 ;

   begin (* INSERTBLANKLINE *)
     if CURRSYM -> . CRSBEFORE = 0 then
       begin
         if CURRLINEPOS = 0 then
           WRITECRS ( ONCE , CURRLINEPOS , OUTPUTFILE )
         else
           WRITECRS ( TWICE , CURRLINEPOS , OUTPUTFILE ) ;
         CURRSYM -> . SPACESBEFORE := 0
       end (* then *)
     else
       if CURRSYM -> . CRSBEFORE = 1 then
         if CURRLINEPOS > 0 then
           WRITECRS ( ONCE , CURRLINEPOS , OUTPUTFILE )
   end (* INSERTBLANKLINE *) ;



procedure LSHIFTON ( DINDENTSYMBOLS : KEYSYMSET ) ;

   var INDENTSYMBOL : KEYSYMBOL ;
       PREVMARGIN : INTEGER ;

   begin (* LSHIFTON *)
     if not STACKEMPTY then
       begin
         repeat
           POPSTACK ( INDENTSYMBOL , PREVMARGIN ) ;
           if INDENTSYMBOL in DINDENTSYMBOLS then
             CURRMARGIN := PREVMARGIN
         until not ( INDENTSYMBOL in DINDENTSYMBOLS ) or ( STACKEMPTY )
         ;
         if not ( INDENTSYMBOL in DINDENTSYMBOLS ) then
           PUSHSTACK ( INDENTSYMBOL , PREVMARGIN ) ;
       end (* then *)
   end (* LSHIFTON *) ;



procedure LSHIFT ;

   var INDENTSYMBOL : KEYSYMBOL ;
       PREVMARGIN : INTEGER ;

   begin (* LSHIFT *)
     if not STACKEMPTY then
       begin
         POPSTACK ( INDENTSYMBOL , PREVMARGIN ) ;
         CURRMARGIN := PREVMARGIN
       end (* then *)
   end (* LSHIFT *) ;



procedure INSERTSPACE ( var SYMBOL : SYMBOLINFO ; var OUTPUTFILE : TEXT
                      ) ;

   begin (* INSERTSPACE *)
     if CURRLINEPOS < MAXLINESIZE then
       begin
         WRITE ( OUTPUTFILE , SPACE ) ;
         CURRLINEPOS := CURRLINEPOS + 1 ;
         with SYMBOL -> do
           if ( CRSBEFORE = 0 ) and ( SPACESBEFORE > 0 ) then
             SPACESBEFORE := SPACESBEFORE - 1
       end (* then *)
   end (* INSERTSPACE *) ;



procedure MOVELINEPOS ( NEWLINEPOS : INTEGER ; var CURRLINEPOS :
                      INTEGER ; var OUTPUTFILE : TEXT ) ;

   var I : INTEGER ;

   begin (* MOVELINEPOS *)
     for I := CURRLINEPOS + 1 to NEWLINEPOS do
       WRITE ( OUTPUTFILE , SPACE ) ;
     CURRLINEPOS := NEWLINEPOS
   end (* MOVELINEPOS *) ;



procedure PRINTSYMBOL ( CURRSYM : SYMBOLINFO ; var CURRLINEPOS :
                      INTEGER ; var OUTPUTFILE : TEXT ) ;

   var I : INTEGER ;

   begin (* PRINTSYMBOL *)
     with CURRSYM -> do
       begin
         for I := 1 to LENGTH do
           WRITE ( OUTPUTFILE , VALUE [ I ] ) ;
         CURRLINEPOS := CURRLINEPOS + LENGTH
       end (* with *)
   end (* PRINTSYMBOL *) ;



procedure PPSYMBOL ( CURRSYM : SYMBOLINFO ; var OUTPUTFILE : TEXT ) ;

   const ONCE = 1 ;

   var NEWLINEPOS : INTEGER ;

   begin (* PPSYMBOL *)
     with CURRSYM -> do
       begin
         WRITECRS ( CRSBEFORE , CURRLINEPOS , OUTPUTFILE ) ;
         if ( CURRLINEPOS + SPACESBEFORE > CURRMARGIN ) or ( NAME in [
         OPENCOMMENT , CLOSECOMMENT ] ) then
           NEWLINEPOS := CURRLINEPOS + SPACESBEFORE
         else
           NEWLINEPOS := CURRMARGIN ;
         if NEWLINEPOS + LENGTH > MAXLINESIZE then
           begin
             WRITECRS ( ONCE , CURRLINEPOS , OUTPUTFILE ) ;
             if CURRMARGIN + LENGTH <= MAXLINESIZE then
               NEWLINEPOS := CURRMARGIN
             else
               if LENGTH <= MAXLINESIZE then
                 NEWLINEPOS := MAXLINESIZE - LENGTH
               else
                 NEWLINEPOS := 0
           end (* then *) ;
         MOVELINEPOS ( NEWLINEPOS , CURRLINEPOS , OUTPUTFILE ) ;
         PRINTSYMBOL ( CURRSYM , CURRLINEPOS , OUTPUTFILE )
       end (* with *)
   end (* PPSYMBOL *) ;



procedure RSHIFTTOCLP ( CURRSYM : KEYSYMBOL ) ;

   FORWARD ;



procedure GOBBLE ( var INPUTFILE : TEXT ; TERMINATORS : KEYSYMSET ; var
                 CURRSYM , NEXTSYM : SYMBOLINFO ; var OUTPUTFILE : TEXT
                 ) ;

   begin (* GOBBLE *)
     RSHIFTTOCLP ( CURRSYM -> . NAME ) ;
     while not ( NEXTSYM -> . NAME in ( TERMINATORS + [ ENDOFFILE ] ) )
     do
       begin
         GETSYMBOL ( INPUTFILE , NEXTSYM , CURRSYM ) ;
         PPSYMBOL ( CURRSYM , OUTPUTFILE )
       end (* while *) ;
     LSHIFT
   end (* GOBBLE *) ;



procedure RSHIFT ( CURRSYM : KEYSYMBOL ) ;

   begin (* RSHIFT *)
     if not STACKFULL then
       PUSHSTACK ( CURRSYM , CURRMARGIN ) ;
     if CURRMARGIN < SLOFAIL1 then
       CURRMARGIN := CURRMARGIN + INDENT1
     else
       if CURRMARGIN < SLOFAIL2 then
         CURRMARGIN := CURRMARGIN + INDENT2
   end (* RSHIFT *) ;



procedure RSHIFTTOCLP ;

   begin (* RSHIFTTOCLP *)
     if not STACKFULL then
       PUSHSTACK ( CURRSYM , CURRMARGIN ) ;
     CURRMARGIN := CURRLINEPOS ;
   end (* RSHIFTTOCLP *) ;



begin (* HAUPTPROGRAMM *)
  INITIALISE ( INPUTFILE , OUTPUTFILE , TOP , CURRLINEPOS , CURRMARGIN
               , KEYWORD , DBLCHARS , DBLCHAR , SGLCHAR , RECORDSEEN ,
               CURRCHAR , NEXTCHAR , CURRSYM , NEXTSYM , PPOPTION ) ;
  CRPENDING := FALSE ;
  while ( NEXTSYM -> . NAME <> ENDOFFILE ) do
    begin
      GETSYMBOL ( INPUTFILE , NEXTSYM , CURRSYM ) ;
      with PPOPTION [ CURRSYM -> . NAME ] do
        begin
          if ( CRPENDING and not ( CRSUPPRESS in OPTIONSSELECTED ) ) or
          ( CRBEFORE in OPTIONSSELECTED ) then
            begin
              INSERTCR ( CURRSYM , OUTPUTFILE ) ;
              CRPENDING := FALSE ;
            end (* then *) ;
          if BLANKLINEBEFORE in OPTIONSSELECTED then
            begin
              INSERTBLANKLINE ( CURRSYM , OUTPUTFILE ) ;
              CRPENDING := FALSE
            end (* then *) ;
          if DINDENTONKEYS in OPTIONSSELECTED then
            LSHIFTON ( DINDENTSYMBOLS ) ;
          if DINDENT in OPTIONSSELECTED then
            LSHIFT ;
          if SPACEBEFORE in OPTIONSSELECTED then
            INSERTSPACE ( CURRSYM , OUTPUTFILE ) ;
          PPSYMBOL ( CURRSYM , OUTPUTFILE ) ;
          if SPACEAFTER in OPTIONSSELECTED then
            INSERTSPACE ( NEXTSYM , OUTPUTFILE ) ;
          if INDENTBYTAB in OPTIONSSELECTED then
            RSHIFT ( CURRSYM -> . NAME ) ;
          if INDENTTOCLP in OPTIONSSELECTED then
            RSHIFTTOCLP ( CURRSYM -> . NAME ) ;
          if GOBBLESYMBOLS in OPTIONSSELECTED then
            GOBBLE ( INPUTFILE , GOBBLETERMINATORS , CURRSYM , NEXTSYM
                     , OUTPUTFILE ) ;
          if CRAFTER in OPTIONSSELECTED then
            CRPENDING := TRUE ;
        end (* with *) ;
    end (* while *) ;
  if CRPENDING then
    WRITELN ( OUTPUTFILE ) ;
end (* HAUPTPROGRAMM *) .
